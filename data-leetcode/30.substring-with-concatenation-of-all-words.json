[
    {
        "title": "Substring with Concatenation of All Words",
        "question_content": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\n\tFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 in s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\t1 <= words.length <= 5000\n\t1 <= words[i].length <= 30\n\ts and words[i] consist of lowercase English letters.",
        "solutions": [
            {
                "id": 13658,
                "title": "easy-two-map-solution-c-java",
                "content": "I think the following code is self-explanatory enough. We use an `unordered_map<string, int> counts` to record the expected times of each word and another `unordered_map<string, int> seen` to record the times we have seen. Then we check for every possible position of `i`. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push `i` to the result `indexes`.\\n\\n* C++\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            unordered_map<string, int> counts;\\n            for (string word : words)\\n                counts[word]++;\\n            int n = s.length(), num = words.size(), len = words[0].length();\\n            vector<int> indexes;\\n            for (int i = 0; i < n - num * len + 1; i++) {\\n                unordered_map<string, int> seen;\\n                int j = 0;\\n                for (; j < num; j++) {\\n                    string word = s.substr(i + j * len, len);\\n                    if (counts.find(word) != counts.end()) {\\n                        seen[word]++;\\n                        if (seen[word] > counts[word])\\n                            break;\\n                    } \\n                    else break;\\n                }\\n                if (j == num) indexes.push_back(i);\\n            }\\n            return indexes;\\n        }\\n    };\\n\\n* Java\\n\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        final Map<String, Integer> counts = new HashMap<>();\\n        for (final String word : words) {\\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\\n        }\\n        final List<Integer> indexes = new ArrayList<>();\\n        final int n = s.length(), num = words.length, len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            final Map<String, Integer> seen = new HashMap<>();\\n            int j = 0;\\n            while (j < num) {\\n                final String word = s.substring(i + j * len, i + (j + 1) * len);\\n                if (counts.containsKey(word)) {\\n                    seen.put(word, seen.getOrDefault(word, 0) + 1);\\n                    if (seen.get(word) > counts.getOrDefault(word, 0)) {\\n                        break;\\n                    }\\n                } else {\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (j == num) {\\n                indexes.add(i);\\n            }\\n        }\\n        return indexes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        final Map<String, Integer> counts = new HashMap<>();\\n        for (final String word : words) {\\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\\n        }\\n        final List<Integer> indexes = new ArrayList<>();\\n        final int n = s.length(), num = words.length, len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            final Map<String, Integer> seen = new HashMap<>();\\n            int j = 0;\\n            while (j < num) {\\n                final String word = s.substring(i + j * len, i + (j + 1) * len);\\n                if (counts.containsKey(word)) {\\n                    seen.put(word, seen.getOrDefault(word, 0) + 1);\\n                    if (seen.get(word) > counts.getOrDefault(word, 0)) {\\n                        break;\\n                    }\\n                } else {\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (j == num) {\\n                indexes.add(i);\\n            }\\n        }\\n        return indexes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13656,
                "title": "an-o-n-solution-with-detailed-explanation",
                "content": "        // travel all the words combinations to maintain a window\\n        // there are wl(word len) times travel\\n        // each time, n/wl words, mostly 2 times travel for each word\\n        // one left side of the window, the other right side of the window\\n        // so, time complexity O(wl * 2 * N/wl) = O(2N)\\n        vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> ans;\\n            int n = S.size(), cnt = L.size();\\n            if (n <= 0 || cnt <= 0) return ans;\\n            \\n            // init word occurence\\n            unordered_map<string, int> dict;\\n            for (int i = 0; i < cnt; ++i) dict[L[i]]++;\\n            \\n            // travel all sub string combinations\\n            int wl = L[0].size();\\n            for (int i = 0; i < wl; ++i) {\\n                int left = i, count = 0;\\n                unordered_map<string, int> tdict;\\n                for (int j = i; j <= n - wl; j += wl) {\\n                    string str = S.substr(j, wl);\\n                    // a valid word, accumulate results\\n                    if (dict.count(str)) {\\n                        tdict[str]++;\\n                        if (tdict[str] <= dict[str]) \\n                            count++;\\n                        else {\\n                            // a more word, advance the window left side possiablly\\n                            while (tdict[str] > dict[str]) {\\n                                string str1 = S.substr(left, wl);\\n                                tdict[str1]--;\\n                                if (tdict[str1] < dict[str1]) count--;\\n                                left += wl;\\n                            }\\n                        }\\n                        // come to a result\\n                        if (count == cnt) {\\n                            ans.push_back(left);\\n                            // advance one word\\n                            tdict[S.substr(left, wl)]--;\\n                            count--;\\n                            left += wl;\\n                        }\\n                    }\\n                    // not a valid word, reset all vars\\n                    else {\\n                        tdict.clear();\\n                        count = 0;\\n                        left = j + wl;\\n                    }\\n                }\\n            }\\n            \\n            return ans;\\n        }",
                "solutionTags": [],
                "code": "        // travel all the words combinations to maintain a window\\n        // there are wl(word len) times travel\\n        // each time, n/wl words, mostly 2 times travel for each word\\n        // one left side of the window, the other right side of the window\\n        // so, time complexity O(wl * 2 * N/wl) = O(2N)\\n        vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> ans;\\n            int n = S.size(), cnt = L.size();\\n            if (n <= 0 || cnt <= 0) return ans;\\n            \\n            // init word occurence\\n            unordered_map<string, int> dict;\\n            for (int i = 0; i < cnt; ++i) dict[L[i]]++;\\n            \\n            // travel all sub string combinations\\n            int wl = L[0].size();\\n            for (int i = 0; i < wl; ++i) {\\n                int left = i, count = 0;\\n                unordered_map<string, int> tdict;\\n                for (int j = i; j <= n - wl; j += wl) {\\n                    string str = S.substr(j, wl);\\n                    // a valid word, accumulate results\\n                    if (dict.count(str)) {\\n                        tdict[str]++;\\n                        if (tdict[str] <= dict[str]) \\n                            count++;\\n                        else {\\n                            // a more word, advance the window left side possiablly\\n                            while (tdict[str] > dict[str]) {\\n                                string str1 = S.substr(left, wl);\\n                                tdict[str1]--;\\n                                if (tdict[str1] < dict[str1]) count--;\\n                                left += wl;\\n                            }\\n                        }\\n                        // come to a result\\n                        if (count == cnt) {\\n                            ans.push_back(left);\\n                            // advance one word\\n                            tdict[S.substr(left, wl)]--;\\n                            count--;\\n                            left += wl;\\n                        }\\n                    }\\n                    // not a valid word, reset all vars\\n                    else {\\n                        tdict.clear();\\n                        count = 0;\\n                        left = j + wl;\\n                    }\\n                }\\n            }\\n            \\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 13673,
                "title": "accepted-java-solution-12ms-with-explanation",
                "content": "It's not too hard to find some resemblance between this problem and [minimum-window-substring][1]. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the \"words\" array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the \"words\" array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S.\\n\\n\\tpublic List<Integer> findSubstring(String s, String[] words) {\\n\\t\\tint N = s.length();\\n\\t\\tList<Integer> indexes = new ArrayList<Integer>(s.length());\\n\\t\\tif (words.length == 0) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint M = words[0].length();\\n\\t\\tif (N < M * words.length) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint last = N - M + 1;\\n\\t\\t\\n\\t\\t//map each string in words array to some index and compute target counters\\n\\t\\tMap<String, Integer> mapping = new HashMap<String, Integer>(words.length);\\n\\t\\tint [][] table = new int[2][words.length];\\n\\t\\tint failures = 0, index = 0;\\n\\t\\tfor (int i = 0; i < words.length; ++i) {\\n\\t\\t\\tInteger mapped = mapping.get(words[i]);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\t++failures;\\n\\t\\t\\t\\tmapping.put(words[i], index);\\n\\t\\t\\t\\tmapped = index++;\\n\\t\\t\\t}\\n\\t\\t\\t++table[0][mapped];\\n\\t\\t}\\n\\t\\t\\n\\t\\t//find all occurrences at string S and map them to their current integer, -1 means no such string is in words array\\n\\t\\tint [] smapping = new int[last];\\n\\t\\tfor (int i = 0; i < last; ++i) {\\n\\t\\t\\tString section = s.substring(i, i + M);\\n\\t\\t\\tInteger mapped = mapping.get(section);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\tsmapping[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsmapping[i] = mapped;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t//fix the number of linear scans\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\t//reset scan variables\\n\\t\\t\\tint currentFailures = failures; //number of current mismatches\\n\\t\\t\\tint left = i, right = i;\\n\\t\\t\\tArrays.fill(table[1], 0);\\n\\t\\t\\t//here, simple solve the minimum-window-substring problem\\n\\t\\t\\twhile (right < last) {\\n\\t\\t\\t\\twhile (currentFailures > 0 && right < last) {\\n\\t\\t\\t\\t\\tint target = smapping[right];\\n\\t\\t\\t\\t\\tif (target != -1 && ++table[1][target] == table[0][target]) {\\n\\t\\t\\t\\t\\t\\t--currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (currentFailures == 0 && left < right) {\\n\\t\\t\\t\\t\\tint target = smapping[left];\\n\\t\\t\\t\\t\\tif (target != -1 && --table[1][target] == table[0][target] - 1) {\\n\\t\\t\\t\\t\\t\\tint length = right - left;\\n\\t\\t\\t\\t\\t\\t//instead of checking every window, we know exactly the length we want\\n\\t\\t\\t\\t\\t\\tif ((length / M) ==  words.length) {\\n\\t\\t\\t\\t\\t\\t\\tindexes.add(left);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t++currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tleft += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn indexes;\\n\\t}\\n\\n\\n  [1]: https://leetcode.com/problems/minimum-window-substring/",
                "solutionTags": [
                    "Java"
                ],
                "code": "It's not too hard to find some resemblance between this problem and [minimum-window-substring][1]. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the \"words\" array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the \"words\" array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S.\\n\\n\\tpublic List<Integer> findSubstring(String s, String[] words) {\\n\\t\\tint N = s.length();\\n\\t\\tList<Integer> indexes = new ArrayList<Integer>(s.length());\\n\\t\\tif (words.length == 0) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint M = words[0].length();\\n\\t\\tif (N < M * words.length) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint last = N - M + 1;\\n\\t\\t\\n\\t\\t//map each string in words array to some index and compute target counters\\n\\t\\tMap<String, Integer> mapping = new HashMap<String, Integer>(words.length);\\n\\t\\tint [][] table = new int[2][words.length];\\n\\t\\tint failures = 0, index = 0;\\n\\t\\tfor (int i = 0; i < words.length; ++i) {\\n\\t\\t\\tInteger mapped = mapping.get(words[i]);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\t++failures;\\n\\t\\t\\t\\tmapping.put(words[i], index);\\n\\t\\t\\t\\tmapped = index++;\\n\\t\\t\\t}\\n\\t\\t\\t++table[0][mapped];\\n\\t\\t}\\n\\t\\t\\n\\t\\t//find all occurrences at string S and map them to their current integer, -1 means no such string is in words array\\n\\t\\tint [] smapping = new int[last];\\n\\t\\tfor (int i = 0; i < last; ++i) {\\n\\t\\t\\tString section = s.substring(i, i + M);\\n\\t\\t\\tInteger mapped = mapping.get(section);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\tsmapping[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsmapping[i] = mapped;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t//fix the number of linear scans\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\t//reset scan variables\\n\\t\\t\\tint currentFailures = failures; //number of current mismatches\\n\\t\\t\\tint left = i, right = i;\\n\\t\\t\\tArrays.fill(table[1], 0);\\n\\t\\t\\t//here, simple solve the minimum-window-substring problem\\n\\t\\t\\twhile (right < last) {\\n\\t\\t\\t\\twhile (currentFailures > 0 && right < last) {\\n\\t\\t\\t\\t\\tint target = smapping[right];\\n\\t\\t\\t\\t\\tif (target != -1 && ++table[1][target] == table[0][target]) {\\n\\t\\t\\t\\t\\t\\t--currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (currentFailures == 0 && left < right) {\\n\\t\\t\\t\\t\\tint target = smapping[left];\\n\\t\\t\\t\\t\\tif (target != -1 && --table[1][target] == table[0][target] - 1) {\\n\\t\\t\\t\\t\\t\\tint length = right - left;\\n\\t\\t\\t\\t\\t\\t//instead of checking every window, we know exactly the length we want\\n\\t\\t\\t\\t\\t\\tif ((length / M) ==  words.length) {\\n\\t\\t\\t\\t\\t\\t\\tindexes.add(left);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t++currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tleft += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn indexes;\\n\\t}\\n\\n\\n  [1]: https://leetcode.com/problems/minimum-window-substring/",
                "codeTag": "Unknown"
            },
            {
                "id": 2418173,
                "title": "c-unordered-map-sliding-window-simple-easy-to-understand",
                "content": "**Approach :**  We are using Hashing & Sliding Window Technique to solve the above problem.\\n \\n**Let\\u2019s see the steps :**\\n\\n1. Declare a map `wordCount` which stores all words count\\n2. Select a window of size `wordsWindow` (total number of characters produced if all the words are concatenated).\\n3. Check if that window is possible to build using our `wordCount` map.\\n4. If `True`, add the starting index to our result vector\\n5. Increasing the window by 1 & check until we are able to select `wordsWindow` size window.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkSubstring(unordered_map<string, int> wordCount, string s, int wordLen) {\\n        for(int j=0; j<s.size(); j+=wordLen) {\\n            string w = s.substr(j, wordLen);\\n            if(wordCount.find(w) != wordCount.end()) {\\n                if(--wordCount[w] == -1) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> res;\\n        int wordLen = words[0].size();\\n        int sLen = s.size();\\n        int wordsWindow = words.size() * wordLen;\\n        \\n        unordered_map<string, int> wordCount;\\n        for(int i=0; i<words.size(); i++) {\\n            wordCount[words[i]]++;\\n        }\\n        \\n        int i = 0;\\n        while(i + wordsWindow <= sLen) {\\n            if(checkSubstring(wordCount, s.substr(i, wordsWindow), wordLen)) {\\n                res.push_back(i);\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool checkSubstring(unordered_map<string, int> wordCount, string s, int wordLen) {\\n        for(int j=0; j<s.size(); j+=wordLen) {\\n            string w = s.substr(j, wordLen);\\n            if(wordCount.find(w) != wordCount.end()) {\\n                if(--wordCount[w] == -1) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> res;\\n        int wordLen = words[0].size();\\n        int sLen = s.size();\\n        int wordsWindow = words.size() * wordLen;\\n        \\n        unordered_map<string, int> wordCount;\\n        for(int i=0; i<words.size(); i++) {\\n            wordCount[words[i]]++;\\n        }\\n        \\n        int i = 0;\\n        while(i + wordsWindow <= sLen) {\\n            if(checkSubstring(wordCount, s.substr(i, wordsWindow), wordLen)) {\\n                res.push_back(i);\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753357,
                "title": "clear-solution-easy-to-understand-with-diagrams-o-n-x-w-approach",
                "content": "Let\\'s just take one example for reference: \\n\\n\\n**Input**: \\n\\n**s** = \"wordbestgoodwordword\", **words** = [\"word\",\"good\",\"best\",\"word\"]\\n\\nlet **w** be the length of each word in words array.\\nlet **m** be the length of words array.\\nlet **n** be the lenth of s string. \\n\\nNow let\\'s define a subproblem(i) as whether index i is present in our answer or not ? (let\\'s take i = 0 for example)\\n\\nNow, index i will be present in our answer if substring of s ( i,  i+(m x w) ), if broken to w length pieces, contains all the words in the words array in any order.\\n\\n![image](https://assets.leetcode.com/users/images/7c57e142-edca-44f5-889b-4697398bad03_1644254764.2690675.png)\\n\\n\\nSo, in a standard brute force approach **how can we just solve subproblem(i) ???**\\n\\nCreate a hashmap storing what all is present in words array. \\nStart from index i consumng w length m sub-strings, storing in another hashmap to keep track of what is observed. \\nif two hash-maps match at the end, subproblem(i) tells i should be present in our answer. \\n\\nQuick time complexity check for solving a single subproblem(i) is O(w x m)\\n\\n*This is very easy, and I hope everyone reached till here.* \\n\\nNow, we can finally solve subproblem(i) like above for each possible i the s string, ie i can range from 0 to n-1,\\n\\nQuick time complexity check for solving a single subproblem(i) is O(n x (w x m)). Now this is cubic complexity and we do not want this. \\n\\nNow, always remember whenever we want to optimise an approach, we want to re-use already done computations. \\n\\n### Can we re-use previously done computations in this problem ???\\n\\nLet us assume we solved the sub-problem(i), where can be re-use it: \\n\\nNow, while solving the sub-problem(i), we generate a hash-map of observed words. Can we reuse this hash-map for other sub-problems ?? \\n\\n![image](https://assets.leetcode.com/users/images/4b034119-e729-436d-8ebb-9ae0dc230ca7_1644255347.323178.png)\\n\\nNow let\\'s see how the sub-problem(i+1) looks ? \\n\\n![image](https://assets.leetcode.com/users/images/f6c00157-6b27-4ce8-9aab-854c7598ea97_1644255670.64441.png)\\n\\nNow the hash-map created in sub-problem(i) cannot be used in sub-problem(i+1) because w length words have completely changed now. \\n\\nBut, the hash-map created in sub-problem(i), can be re-used (after removing w length word starting with i) for sub-problem(i+w) because intermediate 3 words of length w remain same. \\n\\n![image](https://assets.leetcode.com/users/images/1530055a-0e3c-4ca0-8040-14765662a1f4_1644255864.0705793.png)\\n\\nSo, computations made in subproblem(i) can be re-used in sub-problem(i+w).\\nSimilarly, computations made in subproblem(i+w) can be re-used in sub-problem(i+2 x w) \\n\\n     i  ---> i+w ---> i+2w ----> i+3w ----> i+4w  (These all can re-use their computations)\\n\\t \\nQuick, time complexity check: \\n           solving for sub-problems i, i+w, i+2xw,..... sequentially would require O(n) time complexity. \\n\\t\\t                for solving sub-problem(i), it took us O(m x w).\\n\\t\\t\\t\\t\\t\\tfor next sub-problem(i+w), it took us just O(w), removing initial w character, adding latter w character.\\n\\t\\t\\t\\t\\t\\tso, to solve all problems, we effectively consume all array elements atmost O(1) \\n\\t\\t\\t\\t\\t\\tSo, total time complexity for this is O(n)\\nSimilarly, we can solve many such subproblems together, using computations of previous sub-problems\\n\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            i  ---> i+w ---> i+2w ----> i+3w ----> i+4w \\n\\t\\t\\t\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+1)  ---> (i+1)+w ---> (i+1)+2w ----> (i+1)+3w ----> (i+1)+4w \\n\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+2)  ---> (i+2)+w ---> (i+2)+2w ----> (i+2)+3w ----> (i+2)+4w \\n\\t\\t\\t\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+3)  ---> (i+3)+w ---> (i+3)+2w ----> (i+3)+3w ----> (i+3)+4w \\n\\t\\t\\t\\nNow, we realise all the subproblems are solved: because i+4 was solved in first iteration as w here is 4.\\n\\nSo, we need to do w such iterations above and each iteration take O(n) time. So, total time complexity is O(n x w).\\n\\nSo, this problem effectively is a combination of w sliding window problems. \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "Let\\'s just take one example for reference: \\n\\n\\n**Input**: \\n\\n**s** = \"wordbestgoodwordword\", **words** = [\"word\",\"good\",\"best\",\"word\"]\\n\\nlet **w** be the length of each word in words array.\\nlet **m** be the length of words array.\\nlet **n** be the lenth of s string. \\n\\nNow let\\'s define a subproblem(i) as whether index i is present in our answer or not ? (let\\'s take i = 0 for example)\\n\\nNow, index i will be present in our answer if substring of s ( i,  i+(m x w) ), if broken to w length pieces, contains all the words in the words array in any order.\\n\\n![image](https://assets.leetcode.com/users/images/7c57e142-edca-44f5-889b-4697398bad03_1644254764.2690675.png)\\n\\n\\nSo, in a standard brute force approach **how can we just solve subproblem(i) ???**\\n\\nCreate a hashmap storing what all is present in words array. \\nStart from index i consumng w length m sub-strings, storing in another hashmap to keep track of what is observed. \\nif two hash-maps match at the end, subproblem(i) tells i should be present in our answer. \\n\\nQuick time complexity check for solving a single subproblem(i) is O(w x m)\\n\\n*This is very easy, and I hope everyone reached till here.* \\n\\nNow, we can finally solve subproblem(i) like above for each possible i the s string, ie i can range from 0 to n-1,\\n\\nQuick time complexity check for solving a single subproblem(i) is O(n x (w x m)). Now this is cubic complexity and we do not want this. \\n\\nNow, always remember whenever we want to optimise an approach, we want to re-use already done computations. \\n\\n### Can we re-use previously done computations in this problem ???\\n\\nLet us assume we solved the sub-problem(i), where can be re-use it: \\n\\nNow, while solving the sub-problem(i), we generate a hash-map of observed words. Can we reuse this hash-map for other sub-problems ?? \\n\\n![image](https://assets.leetcode.com/users/images/4b034119-e729-436d-8ebb-9ae0dc230ca7_1644255347.323178.png)\\n\\nNow let\\'s see how the sub-problem(i+1) looks ? \\n\\n![image](https://assets.leetcode.com/users/images/f6c00157-6b27-4ce8-9aab-854c7598ea97_1644255670.64441.png)\\n\\nNow the hash-map created in sub-problem(i) cannot be used in sub-problem(i+1) because w length words have completely changed now. \\n\\nBut, the hash-map created in sub-problem(i), can be re-used (after removing w length word starting with i) for sub-problem(i+w) because intermediate 3 words of length w remain same. \\n\\n![image](https://assets.leetcode.com/users/images/1530055a-0e3c-4ca0-8040-14765662a1f4_1644255864.0705793.png)\\n\\nSo, computations made in subproblem(i) can be re-used in sub-problem(i+w).\\nSimilarly, computations made in subproblem(i+w) can be re-used in sub-problem(i+2 x w) \\n\\n     i  ---> i+w ---> i+2w ----> i+3w ----> i+4w  (These all can re-use their computations)\\n\\t \\nQuick, time complexity check: \\n           solving for sub-problems i, i+w, i+2xw,..... sequentially would require O(n) time complexity. \\n\\t\\t                for solving sub-problem(i), it took us O(m x w).\\n\\t\\t\\t\\t\\t\\tfor next sub-problem(i+w), it took us just O(w), removing initial w character, adding latter w character.\\n\\t\\t\\t\\t\\t\\tso, to solve all problems, we effectively consume all array elements atmost O(1) \\n\\t\\t\\t\\t\\t\\tSo, total time complexity for this is O(n)\\nSimilarly, we can solve many such subproblems together, using computations of previous sub-problems\\n\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            i  ---> i+w ---> i+2w ----> i+3w ----> i+4w \\n\\t\\t\\t\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+1)  ---> (i+1)+w ---> (i+1)+2w ----> (i+1)+3w ----> (i+1)+4w \\n\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+2)  ---> (i+2)+w ---> (i+2)+2w ----> (i+2)+3w ----> (i+2)+4w \\n\\t\\t\\t\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+3)  ---> (i+3)+w ---> (i+3)+2w ----> (i+3)+3w ----> (i+3)+4w \\n\\t\\t\\t\\nNow, we realise all the subproblems are solved: because i+4 was solved in first iteration as w here is 4.\\n\\nSo, we need to do w such iterations above and each iteration take O(n) time. So, total time complexity is O(n x w).\\n\\nSo, this problem effectively is a combination of w sliding window problems. \\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 13664,
                "title": "simple-java-solution-with-two-pointers-and-map",
                "content": "My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match.\\n\\n    public static List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (S == null || L == null || L.length == 0) return res;\\n        int len = L[0].length(); // length of each word\\n        \\n        Map<String, Integer> map = new HashMap<String, Integer>(); // map for L\\n        for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);\\n        \\n        for (int i = 0; i <= S.length() - len * L.length; i++) {\\n            Map<String, Integer> copy = new HashMap<String, Integer>(map);\\n            for (int j = 0; j < L.length; j++) { // checkc if match\\n                String str = S.substring(i + j*len, i + j*len + len); // next word\\n                if (copy.containsKey(str)) { // is in remaining words\\n                    int count = copy.get(str);\\n                    if (count == 1) copy.remove(str);\\n                    else copy.put(str, count - 1);\\n                    if (copy.isEmpty()) { // matches\\n                        res.add(i);\\n                        break;\\n                    }\\n                } else break; // not in L\\n            }\\n        }\\n        return res;\\n    }\\n\\nAt first I was gonna to use a set for words. Owing to the fact that duplicate is allowed in L, we need to use map instead.",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match.\\n\\n    public static List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (S == null || L == null || L.length == 0) return res;\\n        int len = L[0].length(); // length of each word\\n        \\n        Map<String, Integer> map = new HashMap<String, Integer>(); // map for L\\n        for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);\\n        \\n        for (int i = 0; i <= S.length() - len * L.length; i++) {\\n            Map<String, Integer> copy = new HashMap<String, Integer>(map);\\n            for (int j = 0; j < L.length; j++) { // checkc if match\\n                String str = S.substring(i + j*len, i + j*len + len); // next word\\n                if (copy.containsKey(str)) { // is in remaining words\\n                    int count = copy.get(str);\\n                    if (count == 1) copy.remove(str);\\n                    else copy.put(str, count - 1);\\n                    if (copy.isEmpty()) { // matches\\n                        res.add(i);\\n                        break;\\n                    }\\n                } else break; // not in L\\n            }\\n        }\\n        return res;\\n    }\\n\\nAt first I was gonna to use a set for words. Owing to the fact that duplicate is allowed in L, we need to use map instead.",
                "codeTag": "Unknown"
            },
            {
                "id": 2419817,
                "title": "python-easily-understood-faster-than-96-less-than-78-o-nm",
                "content": "Method: `Hash Table`\\n\\nFirst we can create a `dict` to store the occurrence times for each word in `words`.\\n\\nFor example,\\nIf `s = \"barfoofoobarthefoobarman\"` and `words = [\"bar\",\"foo\",\"the\"]`, \\nthe dict will be `word_count = {\\'bar\\': 1, \\'foo\\': 1, \\'the\\': 1}`,\\n\\nSince all the strings stored in `words` have the same length, the size of **sliding window** will be the word length of a single string. In the example above, the **sliding window** will be `3`\\n\\n![image](https://assets.leetcode.com/users/images/e6551130-deeb-49fe-a6a6-bf16815b413b_1660394841.6954787.png)\\n```\\nbar -> foo -> foo -> bar -> the -> foo -> bar -> man\\nignore b -> arf -> oof -> oob -> art -> hef -> oob -> arm -> ignore an\\nignore ba -> rfo -> ofo -> oba -> rth -> efo -> oba -> rma -> ignore n\\n```\\nThen, we can scan `s` in these 3 ways one by one\\n\\nLet the word in **sliding window** be `word`.\\nAlso, we will create a `queue` to store the scan history.\\n```\\n1) word_count.get(word, 0) >= 0 \\n    -> word_count[word] -= 1 as it uses one of the string in words\\n\\t-> queue.append(word)\\n\\t\\n2) word_count.get(word, 0) == 0 \\n    -> while queue.pop()\\n\\t\\t-> queue.pop() == word\\n\\t\\t\\t-> queue.append(queue.pop()) # Only the beginning word is dropped, the remaining words are still in use\\n\\t\\t\\t-> break\\n\\t\\t-> queue.pop() != word\\n\\t\\t\\t# Since the beginning word is dropped, the count of beginning word should be added 1.\\n\\t\\t\\t-> word_dict[last_element] += 1\\n\\t\\t\\t\\t-> word_dict[last_element] exceeds its original value, reset the whole word_dict\\n\\t\\t\\t-> continue\\n```\\nCode:\\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        ori_word_dict = defaultdict(int)\\n\\t\\t\\n        for word in words:\\n            ori_word_dict[word] += 1\\n        \\n        all_word_len = len(words) * word_len\\n        result = []\\n        for i in range(word_len):\\n            queue = deque()\\n            word_dict = ori_word_dict.copy()\\n            for j in range(i, len(s) - word_len + 1, word_len):\\n                word = s[j:j + word_len]\\n                if word_dict.get(word, 0) != 0:\\n                    word_dict[word] -= 1\\n                    queue.append(word)\\n                    if sum(word_dict.values()) == 0:\\n                        result.append(j - all_word_len + word_len)\\n                        last_element = queue.popleft()\\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                else:\\n                    while len(queue):\\n                        last_element = queue.popleft()\\n                        if last_element == word:\\n                            queue.append(word)\\n                            break\\n                        else:\\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                            if word_dict[last_element] > ori_word_dict[last_element]:\\n                                word_dict = ori_word_dict.copy()\\n\\n        return result\\n```\\n\\nLet `n` be the length of a word in `words`\\nand `m` be the total number of words in `words`\\n\\n**Time complexity**: `O(n * m)`\\n**Space complexity**: `O(n + m)`\\n<br/>",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nbar -> foo -> foo -> bar -> the -> foo -> bar -> man\\nignore b -> arf -> oof -> oob -> art -> hef -> oob -> arm -> ignore an\\nignore ba -> rfo -> ofo -> oba -> rth -> efo -> oba -> rma -> ignore n\\n```\n```\\n1) word_count.get(word, 0) >= 0 \\n    -> word_count[word] -= 1 as it uses one of the string in words\\n\\t-> queue.append(word)\\n\\t\\n2) word_count.get(word, 0) == 0 \\n    -> while queue.pop()\\n\\t\\t-> queue.pop() == word\\n\\t\\t\\t-> queue.append(queue.pop()) # Only the beginning word is dropped, the remaining words are still in use\\n\\t\\t\\t-> break\\n\\t\\t-> queue.pop() != word\\n\\t\\t\\t# Since the beginning word is dropped, the count of beginning word should be added 1.\\n\\t\\t\\t-> word_dict[last_element] += 1\\n\\t\\t\\t\\t-> word_dict[last_element] exceeds its original value, reset the whole word_dict\\n\\t\\t\\t-> continue\\n```\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        ori_word_dict = defaultdict(int)\\n\\t\\t\\n        for word in words:\\n            ori_word_dict[word] += 1\\n        \\n        all_word_len = len(words) * word_len\\n        result = []\\n        for i in range(word_len):\\n            queue = deque()\\n            word_dict = ori_word_dict.copy()\\n            for j in range(i, len(s) - word_len + 1, word_len):\\n                word = s[j:j + word_len]\\n                if word_dict.get(word, 0) != 0:\\n                    word_dict[word] -= 1\\n                    queue.append(word)\\n                    if sum(word_dict.values()) == 0:\\n                        result.append(j - all_word_len + word_len)\\n                        last_element = queue.popleft()\\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                else:\\n                    while len(queue):\\n                        last_element = queue.popleft()\\n                        if last_element == word:\\n                            queue.append(word)\\n                            break\\n                        else:\\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                            if word_dict[last_element] > ori_word_dict[last_element]:\\n                                word_dict = ori_word_dict.copy()\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13700,
                "title": "my-ac-c-code-o-n-complexity-26ms",
                "content": "    class Solution {\\n    // The general idea:\\n    // Construct a hash function f for L, f: vector<string> -> int, \\n    // Then use the return value of f to check whether a substring is a concatenation \\n    // of all words in L.\\n    // f has two levels, the first level is a hash function f1 for every single word in L.\\n    // f1 : string -> double\\n    // So with f1, L is converted into a vector of float numbers\\n    // Then another hash function f2 is defined to convert a vector of doubles into a single int.\\n    // Finally f(L) := f2(f1(L))\\n    // To obtain lower complexity, we require f1 and f2 can be computed through moving window.\\n    // The following corner case also needs to be considered:\\n    // f2(f1([\"ab\", \"cd\"])) != f2(f1([\"ac\", \"bd\"]))\\n    // There are many possible options for f2 and f1. \\n    // The following code only shows one possibility (probably not the best), \\n    // f2 is the function \"hash\" in the class,\\n    // f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )\\n    public:\\n        // The complexity of this function is O(nW).\\n        double hash(double f, double code[], string &word) {\\n            double result = 0.;\\n            for (auto &c : word) result = result * f + code[c];\\n            return result;\\n        }\\n        vector<int> findSubstring(string S, vector<string> &L) {\\n            uniform_real_distribution<double> unif(0., 1.);\\n            default_random_engine seed;\\n            double code[128];\\n            for (auto &d : code) d = unif(seed);\\n            double f = unif(seed) / 5. + 0.8;\\n            double value = 0;\\n\\n            // The complexity of the following for loop is O(L.size( ) * nW).\\n            for (auto &str : L) value += log(hash(f, code, str));\\n\\n            int unit = 1e9;\\n            int key = (value-floor(value))*unit;\\n            int nS = S.size(), nL = L.size(), nW = L[0].size();\\n            double fn = pow(f, nW-1.);\\n            vector<int> result;\\n            if (nS < nW) return result;\\n            vector<double> values(nS-nW+1);\\n            string word(S.begin(), S.begin()+nW);\\n            values[0] = hash(f, code, word);\\n\\n            // Use a moving window to hash every word with length nW in S to a float number, \\n            // which is stored in vector values[]\\n            // The complexity of this step is O(nS).\\n            for (int i=1; i<=nS-nW; ++i) values[i] = (values[i-1] - code[S[i-1]]*fn)*f + code[S[i+nW-1]];\\n\\n            // This for loop will run nW times, each iteration has a complexity O(nS/nW)\\n            // So the overall complexity is O(nW * (nS / nW)) = O(nS)\\n            for (int i=0; i<nW; ++i) {\\n                int j0=i, j1=i, k=0;\\n                double sum = 0.;\\n\\n                // Use a moving window to hash every L.size() continuous words with length nW in S.\\n                // This while loop will terminate within nS/nW iterations since the increasement of j1 is nW,\\n                // So the complexity of this while loop is O(nS / nW).\\n                while(j1<=nS-nW) {\\n                    sum += log(values[j1]);\\n                    ++k;\\n                    j1 += nW;\\n                    if (k==nL) {\\n                        int key1 = (sum-floor(sum)) * unit;\\n                        if (key1==key) result.push_back(j0);\\n                        sum -= log(values[j0]);\\n                        --k;\\n                        j0 += nW;\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };\\n\\nThough theoretically it has a very small chance to fail.",
                "solutionTags": [],
                "code": "class Solution {\\n    // The general idea:\\n    // Construct a hash function f for L, f: vector<string> -> int, \\n    // Then use the return value of f to check whether a substring is a concatenation \\n    // of all words in L.\\n    // f has two levels, the first level is a hash function f1 for every single word in L.\\n    // f1 : string -> double\\n    // So with f1, L is converted into a vector of float numbers\\n    // Then another hash function f2 is defined to convert a vector of doubles into a single int.\\n    // Finally f(L) := f2(f1(L))\\n    // To obtain lower complexity, we require f1 and f2 can be computed through moving window.\\n    // The following corner case also needs to be considered:\\n    // f2(f1([\"ab\", \"cd\"])) != f2(f1([\"ac\", \"bd\"]))\\n    // There are many possible options for f2 and f1. \\n    // The following code only shows one possibility (probably not the best), \\n    // f2 is the function \"hash\" in the class,\\n    // f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )\\n    public:\\n        // The complexity of this function is O(nW).\\n        double hash(double f, double code[], string &word) {\\n            double result = 0.;\\n            for (auto &c : word) result = result * f + code[c];\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 13667,
                "title": "ac-python-80ms-solution-dictionary-and-two-pointers",
                "content": "    def _findSubstring(self, l, r, n, k, t, s, req, ans):\\n        curr = {}\\n        while r + k <= n:\\n            w = s[r:r + k]\\n            r += k\\n            if w not in req:\\n                l = r\\n                curr.clear()\\n            else:\\n                curr[w] = curr[w] + 1 if w in curr else 1\\n                while curr[w] > req[w]:\\n                    curr[s[l:l + k]] -= 1\\n                    l += k\\n                if r - l == t:\\n                    ans.append(l)\\n\\n    def findSubstring(self, s, words):\\n        if not s or not words or not words[0]:\\n            return []\\n        n = len(s)\\n        k = len(words[0])\\n        t = len(words) * k\\n        req = {}\\n        for w in words:\\n            req[w] = req[w] + 1 if w in req else 1\\n        ans = []\\n        for i in xrange(min(k, n - t + 1)):\\n            self._findSubstring(i, i, n, k, t, s, req, ans)\\n        return ans\\n\\n\\n    # 169 / 169 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 80 ms\\n    # 98.60%\\n\\n\\nFirst of all consider s as several series of  words with length k starting at [0, k-1]. For example \"barfoothe\" with k = 3, can be view as [\"bar\", \"foo\", \"the\"] for i=0 and [\"arf\", \"oot\"] for i = 1 and [\"rfo\", \"oth\"] for i = 2.\\nThus we need to check each  of these series and find out the valid index by definition.\\n\\nFor each series, we just need to check if there exist a range [l, r) where the occurrence or \"spectrum\" of the words in the range is the same as our given word list's \"spectrum\". We use dictionary to store the spectrum and maintain it as we loop through s.\\n\\ncollections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed.",
                "solutionTags": [],
                "code": "    def _findSubstring(self, l, r, n, k, t, s, req, ans):\\n        curr = {}\\n        while r + k <= n:\\n            w = s[r:r + k]\\n            r += k\\n            if w not in req:\\n                l = r\\n                curr.clear()\\n            else:\\n                curr[w] = curr[w] + 1 if w in curr else 1\\n                while curr[w] > req[w]:\\n                    curr[s[l:l + k]] -= 1\\n                    l += k\\n                if r - l == t:\\n                    ans.append(l)\\n\\n    def findSubstring(self, s, words):\\n        if not s or not words or not words[0]:\\n            return []\\n        n = len(s)\\n        k = len(words[0])\\n        t = len(words) * k\\n        req = {}\\n        for w in words:\\n            req[w] = req[w] + 1 if w in req else 1\\n        ans = []\\n        for i in xrange(min(k, n - t + 1)):\\n            self._findSubstring(i, i, n, k, t, s, req, ans)\\n        return ans\\n\\n\\n    # 169 / 169 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 80 ms\\n    # 98.60%\\n\\n\\nFirst of all consider s as several series of  words with length k starting at [0, k-1]. For example \"barfoothe\" with k = 3, can be view as [\"bar\", \"foo\", \"the\"] for i=0 and [\"arf\", \"oot\"] for i = 1 and [\"rfo\", \"oth\"] for i = 2.\\nThus we need to check each  of these series and find out the valid index by definition.\\n\\nFor each series, we just need to check if there exist a range [l, r) where the occurrence or \"spectrum\" of the words in the range is the same as our given word list's \"spectrum\". We use dictionary to store the spectrum and maintain it as we loop through s.\\n\\ncollections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed.",
                "codeTag": "Java"
            },
            {
                "id": 13669,
                "title": "99ms-python-o-kmn-solution",
                "content": "The idea comes from [https://leetcode.com/discuss/20151/an-o-n-solution-with-detailed-explanation]\\n\\nUsing a counter and a sliding window, we push the window from left to right, counting the number of valid words in the window. When the number of a word in the window is more than the times it appears in **words** or we meet a invalid word, push the window.\\n\\n    class Solution:\\n\\t# @param {string} s\\n\\t# @param {string[]} words\\n\\t# @return {integer[]}\\n\\tdef findSubstring(self, s, words):\\n\\t\\tif len(words) == 0:\\n\\t\\t\\treturn []\\n\\t\\t# initialize d, l, ans\\n\\t\\tl = len(words[0])\\n\\t\\td = {}\\n\\t\\tfor w in words:\\n\\t\\t\\tif w in d:\\n\\t\\t\\t\\td[w] += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\td[w] = 1\\n\\t\\ti = 0\\n\\t\\tans = []\\n\\n\\t\\t# sliding window(s)\\n\\t\\tfor k in range(l):\\n\\t\\t\\tleft = k\\n\\t\\t\\tsubd = {}\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor j in xrange(k, len(s)-l+1, l):\\n\\t\\t\\t\\ttword = s[j:j+l]\\n\\t\\t\\t\\t# valid word\\n\\t\\t\\t\\tif tword in d:\\n\\t\\t\\t\\t\\tif tword in subd:\\n\\t\\t\\t\\t\\t\\tsubd[tword] += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsubd[tword] = 1\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\twhile subd[tword] > d[tword]:\\n\\t\\t\\t\\t\\t\\tsubd[s[left:left+l]] -= 1\\n\\t\\t\\t\\t\\t\\tleft += l\\n\\t\\t\\t\\t\\t\\tcount -= 1\\n\\t\\t\\t\\t\\tif count == len(words):\\n\\t\\t\\t\\t\\t\\tans.append(left)\\n\\t\\t\\t\\t# not valid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = j + l\\n\\t\\t\\t\\t\\tsubd = {}\\n\\t\\t\\t\\t\\tcount = 0\\n\\n\\t\\treturn ans\\n\\nAssuming we have k words in **words**, and there are m substrings in the string, the complexity is O(kmn) because we need to adjust the window when more valid words are found.\\n\\nThis solution runs 99ms on OJ.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t# @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 2417727,
                "title": "python-90-with-detailed-explanation-sliding-windows-using-counter",
                "content": "![image](https://assets.leetcode.com/users/images/4a450c74-27dd-4de5-a764-d70851ce0378_1660399303.2203338.jpeg)\\n\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen = len(words[0])\\n        wslen = len(words) * len(words[0])\\n        res = []\\n        \\n        for pos in range(wlen):\\n            i = pos\\n            d = Counter(words)\\n            \\n            for j in range(i, len(s) + 1 - wlen, wlen):\\n                word = s[j: j + wlen]\\n                d[word] -= 1\\n                \\n                while d[word] < 0:\\n                    d[s[i: i + wlen]] += 1\\n                    i += wlen\\n                if i + wslen == j + wlen:\\n                    res. append(i)\\n        \\n        return res\\n```\\n**Please UPVOTE if you LIKE**\\n![image](https://assets.leetcode.com/users/images/962eda17-1c28-4f38-be08-3d812101817c_1660399631.2653482.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen = len(words[0])\\n        wslen = len(words) * len(words[0])\\n        res = []\\n        \\n        for pos in range(wlen):\\n            i = pos\\n            d = Counter(words)\\n            \\n            for j in range(i, len(s) + 1 - wlen, wlen):\\n                word = s[j: j + wlen]\\n                d[word] -= 1\\n                \\n                while d[word] < 0:\\n                    d[s[i: i + wlen]] += 1\\n                    i += wlen\\n                if i + wslen == j + wlen:\\n                    res. append(i)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992611,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n\\tstruct matcher {\\n\\t\\tstruct info { int mtindex, count; };\\n\\t\\tunordered_map<string_view, info>dict;\\n\\t\\tint different_word_count;\\n\\n\\t\\tvector<int>slot;\\n\\t\\tint maching_slot_count;\\n\\n\\t\\tmatcher(const vector<string>& words) {\\n\\t\\t\\tint mtind = 0;\\n\\t\\t\\tfor (auto& word : words) {\\n\\t\\t\\t\\tauto find = dict.find(word);\\n\\t\\t\\t\\tif (find != dict.end()) {\\n\\t\\t\\t\\t\\t++find->second.count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse { dict[word] = { mtind++,1 }; }\\n\\t\\t\\t}\\n\\t\\t\\tdifferent_word_count = mtind;\\n\\t\\t\\tslot = vector<int>(different_word_count, 0);\\n\\t\\t\\tmaching_slot_count = 0;\\n\\t\\t}\\n\\n\\t\\tvoid reset() {\\n\\t\\t\\tfor (auto& i : slot) { i = 0; }\\n\\t\\t\\tmaching_slot_count = 0;\\n\\t\\t}\\n\\t\\tbool match() {\\n\\t\\t\\treturn maching_slot_count == different_word_count;\\n\\t\\t}\\n\\t\\tvoid push(string_view sv) {\\n\\t\\t\\tauto find = dict.find(sv);\\n\\t\\t\\tif (find == dict.end())return;\\n\\t\\t\\tif (++slot[find->second.mtindex] == find->second.count) {\\n\\t\\t\\t\\t++maching_slot_count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid pop(string_view sv) {\\n\\t\\t\\tauto find = dict.find(sv);\\n\\t\\t\\tif (find == dict.end())return;\\n\\t\\t\\tif (--slot[find->second.mtindex] == find->second.count - 1) {\\n\\t\\t\\t\\t--maching_slot_count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tvector<int> findSubstring(string s, const vector<string>& words) {\\n\\t\\tint word_count = words.size();\\n\\t\\tint word_len = words[0].size();\\n\\n\\t\\tmatcher matcher(words);\\n\\n\\t\\tconst char* str = s.c_str();\\n\\t\\tint len = s.size();\\n\\t\\tvector<int> ret;\\n\\n\\t\\tfor (int off = 0; off < word_len; off++) {\\n\\t\\t\\tconst char* beg = str + off, * end = str + len;\\n\\t\\t\\tif (beg + word_len * word_count <= end) {\\n\\t\\t\\t\\tmatcher.reset();\\n\\t\\t\\t\\tfor (int i = 0; i < word_count; i++) {\\n\\t\\t\\t\\t\\tstring_view sv(beg + i * word_len, word_len);\\n\\t\\t\\t\\t\\tmatcher.push(sv);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (matcher.match()) {\\n\\t\\t\\t\\t\\tret.push_back(beg - str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tconst char* pos = beg + word_len * word_count;\\n\\t\\t\\t\\twhile (pos + word_len <= end) {\\n\\t\\t\\t\\t\\tstring_view del(beg, word_len);\\n\\t\\t\\t\\t\\tstring_view add(pos, word_len);\\n\\t\\t\\t\\t\\tbeg += word_len;\\n\\t\\t\\t\\t\\tpos += word_len;\\n\\t\\t\\t\\t\\tmatcher.pop(del);\\n\\t\\t\\t\\t\\tmatcher.push(add);\\n\\t\\t\\t\\t\\tif (matcher.match()) {\\n\\t\\t\\t\\t\\t\\tret.push_back(beg - str);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n_word = len(words)\\n        n_char = len(words[0])\\n        word2freq = {}\\n        for word in words:\\n            if word in word2freq:\\n                word2freq[word] += 1\\n            else:\\n                word2freq[word] = 1\\n\\n        all_start_ind = []\\n        for start_ind in range(n_char):\\n            curr_map = {}\\n            curr_total = 0\\n            excessive = False\\n            for i in range(start_ind, len(s), n_char):\\n                word = s[i:i+n_char]\\n                if word in word2freq: # a valid word for permutation \\n                    curr_total += 1\\n                    if word in curr_map: # found valid word\\n                        curr_map[word] += 1\\n                        if curr_map[word] > word2freq[word]: \\n                            excessive = word\\n                    else:\\n                        curr_map[word] = 1\\n\\n                    earliest_ind = i - (curr_total-1)*n_char\\n                    while excessive:\\n                        earliest_word = s[earliest_ind: earliest_ind+n_char]\\n                        curr_map[earliest_word] -= 1\\n                        curr_total -= 1\\n                        if earliest_word == excessive:\\n                            excessive = False\\n                            break\\n                        earliest_ind += n_char\\n                    if curr_total == n_word:\\n                        earliest_ind = i - (n_word-1)*n_char\\n\\n                        all_start_ind.append(earliest_ind)\\n\\n                        earliest_word = s[earliest_ind: earliest_ind+n_char]\\n                        curr_total -= 1\\n                        curr_map[earliest_word] -= 1\\n                else:\\n                    curr_total = 0\\n                    curr_map = {}\\n        return all_start_ind\\n    \\n    def check_map_equal(self, curr_map, ref_map) -> bool:\\n        for word, freq in curr_map.items():\\n            if word not in ref_map or freq != ref_map[word]:\\n                return False\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int wordLength = words[0].length();\\n        int totalWordsLength = wordLength * words.length;\\n        Map<String, Integer> hash = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        char[] s2 = s.toCharArray();\\n        for (String value : words) {\\n            hash.putIfAbsent(value, hash.size());\\n        }\\n        int[] count = new int[hash.size()];\\n        for (String word : words) {\\n            count[hash.get(word)]++;\\n        }\\n        for (int i = 0; i < wordLength; i++) {\\n            for (int j = i; j <= s.length() - totalWordsLength; j += wordLength) {\\n                int[] localCount = new int[hash.size()];\\n                for (int k = j + totalWordsLength - wordLength; k >= j; k -= wordLength) {\\n                    String str = new String(s2, k, wordLength);     // [ k, k+wordLength )\\n                    Integer key = hash.get(str);\\n                    if (!(key != null && count[key] >= ++localCount[key])) {\\n                        j = k;\\n                        break;\\n                    }\\n                    if (j == k) {\\n                        ans.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\tstruct matcher {\\n\\t\\tstruct info { int mtindex, count; };\\n\\t\\tunordered_map<string_view, info>dict;\\n\\t\\tint different_word_count;\\n\\n\\t\\tvector<int>slot;\\n\\t\\tint maching_slot_count;\\n\\n\\t\\tmatcher(const vector<string>& words) {\\n\\t\\t\\tint mtind = 0;\\n\\t\\t\\tfor (auto& word : words) {\\n\\t\\t\\t\\tauto find = dict.find(word);\\n\\t\\t\\t\\tif (find != dict.end()) {\\n\\t\\t\\t\\t\\t++find->second.count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse { dict[word] = { mtind++,1 }; }\\n\\t\\t\\t}\\n\\t\\t\\tdifferent_word_count = mtind;\\n\\t\\t\\tslot = vector<int>(different_word_count, 0);\\n\\t\\t\\tmaching_slot_count = 0;\\n\\t\\t}\\n\\n\\t\\tvoid reset() {\\n\\t\\t\\tfor (auto& i : slot) { i = 0; }\\n\\t\\t\\tmaching_slot_count = 0;\\n\\t\\t}\\n\\t\\tbool match() {\\n\\t\\t\\treturn maching_slot_count == different_word_count;\\n\\t\\t}\\n\\t\\tvoid push(string_view sv) {\\n\\t\\t\\tauto find = dict.find(sv);\\n\\t\\t\\tif (find == dict.end())return;\\n\\t\\t\\tif (++slot[find->second.mtindex] == find->second.count) {\\n\\t\\t\\t\\t++maching_slot_count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid pop(string_view sv) {\\n\\t\\t\\tauto find = dict.find(sv);\\n\\t\\t\\tif (find == dict.end())return;\\n\\t\\t\\tif (--slot[find->second.mtindex] == find->second.count - 1) {\\n\\t\\t\\t\\t--maching_slot_count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tvector<int> findSubstring(string s, const vector<string>& words) {\\n\\t\\tint word_count = words.size();\\n\\t\\tint word_len = words[0].size();\\n\\n\\t\\tmatcher matcher(words);\\n\\n\\t\\tconst char* str = s.c_str();\\n\\t\\tint len = s.size();\\n\\t\\tvector<int> ret;\\n\\n\\t\\tfor (int off = 0; off < word_len; off++) {\\n\\t\\t\\tconst char* beg = str + off, * end = str + len;\\n\\t\\t\\tif (beg + word_len * word_count <= end) {\\n\\t\\t\\t\\tmatcher.reset();\\n\\t\\t\\t\\tfor (int i = 0; i < word_count; i++) {\\n\\t\\t\\t\\t\\tstring_view sv(beg + i * word_len, word_len);\\n\\t\\t\\t\\t\\tmatcher.push(sv);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (matcher.match()) {\\n\\t\\t\\t\\t\\tret.push_back(beg - str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tconst char* pos = beg + word_len * word_count;\\n\\t\\t\\t\\twhile (pos + word_len <= end) {\\n\\t\\t\\t\\t\\tstring_view del(beg, word_len);\\n\\t\\t\\t\\t\\tstring_view add(pos, word_len);\\n\\t\\t\\t\\t\\tbeg += word_len;\\n\\t\\t\\t\\t\\tpos += word_len;\\n\\t\\t\\t\\t\\tmatcher.pop(del);\\n\\t\\t\\t\\t\\tmatcher.push(add);\\n\\t\\t\\t\\t\\tif (matcher.match()) {\\n\\t\\t\\t\\t\\t\\tret.push_back(beg - str);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n_word = len(words)\\n        n_char = len(words[0])\\n        word2freq = {}\\n        for word in words:\\n            if word in word2freq:\\n                word2freq[word] += 1\\n            else:\\n                word2freq[word] = 1\\n\\n        all_start_ind = []\\n        for start_ind in range(n_char):\\n            curr_map = {}\\n            curr_total = 0\\n            excessive = False\\n            for i in range(start_ind, len(s), n_char):\\n                word = s[i:i+n_char]\\n                if word in word2freq: # a valid word for permutation \\n                    curr_total += 1\\n                    if word in curr_map: # found valid word\\n                        curr_map[word] += 1\\n                        if curr_map[word] > word2freq[word]: \\n                            excessive = word\\n                    else:\\n                        curr_map[word] = 1\\n\\n                    earliest_ind = i - (curr_total-1)*n_char\\n                    while excessive:\\n                        earliest_word = s[earliest_ind: earliest_ind+n_char]\\n                        curr_map[earliest_word] -= 1\\n                        curr_total -= 1\\n                        if earliest_word == excessive:\\n                            excessive = False\\n                            break\\n                        earliest_ind += n_char\\n                    if curr_total == n_word:\\n                        earliest_ind = i - (n_word-1)*n_char\\n\\n                        all_start_ind.append(earliest_ind)\\n\\n                        earliest_word = s[earliest_ind: earliest_ind+n_char]\\n                        curr_total -= 1\\n                        curr_map[earliest_word] -= 1\\n                else:\\n                    curr_total = 0\\n                    curr_map = {}\\n        return all_start_ind\\n    \\n    def check_map_equal(self, curr_map, ref_map) -> bool:\\n        for word, freq in curr_map.items():\\n            if word not in ref_map or freq != ref_map[word]:\\n                return False\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int wordLength = words[0].length();\\n        int totalWordsLength = wordLength * words.length;\\n        Map<String, Integer> hash = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        char[] s2 = s.toCharArray();\\n        for (String value : words) {\\n            hash.putIfAbsent(value, hash.size());\\n        }\\n        int[] count = new int[hash.size()];\\n        for (String word : words) {\\n            count[hash.get(word)]++;\\n        }\\n        for (int i = 0; i < wordLength; i++) {\\n            for (int j = i; j <= s.length() - totalWordsLength; j += wordLength) {\\n                int[] localCount = new int[hash.size()];\\n                for (int k = j + totalWordsLength - wordLength; k >= j; k -= wordLength) {\\n                    String str = new String(s2, k, wordLength);     // [ k, k+wordLength )\\n                    Integer key = hash.get(str);\\n                    if (!(key != null && count[key] >= ++localCount[key])) {\\n                        j = k;\\n                        break;\\n                    }\\n                    if (j == k) {\\n                        ans.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349245,
                "title": "solution-swift-substring-with-concatenation-of-all-words-test-cases",
                "content": "```swift\\nclass Solution {\\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\\n        guard !(s.isEmpty) || !(words.isEmpty) else { return [] }\\n        \\n        let lenS = s.count, chars = Array(s)\\n        let size = words[0].count, count = words.count * size\\n        \\n        guard lenS >= count else { return [] }\\n        \\n        var wordDict = [[Character]:Int]()\\n        \\n        for word in words {\\n            let arr: [Character] = word.map({$0})\\n            wordDict[arr, default: 0] = (wordDict[arr] ?? 0) + 1\\n        }\\n        \\n        var result = [Int]()\\n        \\n        for i in 0..<size {\\n            var val = i\\n            while val <= (lenS - count) {\\n                var diff = (val + count)\\n                var dict = [[Character]:Int]()\\n                var equal: Bool = true\\n                while val < diff {\\n                    let temp: [Character] = chars[(diff - size)..<diff].map({$0})\\n                    dict[temp] = (dict[temp] ?? 0) + 1\\n                    if let char = dict[temp], char > (wordDict[temp] ?? 0) {\\n                        equal = false\\n                        break\\n                    }\\n                    diff -= size\\n                }\\n                if dict == wordDict { result.append(val) }\\n                if equal { val += size } else { val = diff }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.050 (0.052) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\\n    /// The output order does not matter, returning [9,0] is fine too.\\n    func test0() {\\n        let value = solution.findSubstring(\"barfoothefoobarman\", [\"foo\",\"bar\"])\\n        XCTAssertEqual(value, [0,9])\\n    }\\n    \\n    func test1() {\\n        let value = solution.findSubstring(\"wordgoodgoodgoodbestword\", [\"word\",\"good\",\"best\",\"word\"])\\n        XCTAssertEqual(value, [])\\n    }\\n    \\n    func test2() {\\n        let value = solution.findSubstring(\"barfoofoobarthefoobarman\", [\"bar\",\"foo\",\"the\"])\\n        XCTAssertEqual(value, [6,9,12])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\\n        guard !(s.isEmpty) || !(words.isEmpty) else { return [] }\\n        \\n        let lenS = s.count, chars = Array(s)\\n        let size = words[0].count, count = words.count * size\\n        \\n        guard lenS >= count else { return [] }\\n        \\n        var wordDict = [[Character]:Int]()\\n        \\n        for word in words {\\n            let arr: [Character] = word.map({$0})\\n            wordDict[arr, default: 0] = (wordDict[arr] ?? 0) + 1\\n        }\\n        \\n        var result = [Int]()\\n        \\n        for i in 0..<size {\\n            var val = i\\n            while val <= (lenS - count) {\\n                var diff = (val + count)\\n                var dict = [[Character]:Int]()\\n                var equal: Bool = true\\n                while val < diff {\\n                    let temp: [Character] = chars[(diff - size)..<diff].map({$0})\\n                    dict[temp] = (dict[temp] ?? 0) + 1\\n                    if let char = dict[temp], char > (wordDict[temp] ?? 0) {\\n                        equal = false\\n                        break\\n                    }\\n                    diff -= size\\n                }\\n                if dict == wordDict { result.append(val) }\\n                if equal { val += size } else { val = diff }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\\n    /// The output order does not matter, returning [9,0] is fine too.\\n    func test0() {\\n        let value = solution.findSubstring(\"barfoothefoobarman\", [\"foo\",\"bar\"])\\n        XCTAssertEqual(value, [0,9])\\n    }\\n    \\n    func test1() {\\n        let value = solution.findSubstring(\"wordgoodgoodgoodbestword\", [\"word\",\"good\",\"best\",\"word\"])\\n        XCTAssertEqual(value, [])\\n    }\\n    \\n    func test2() {\\n        let value = solution.findSubstring(\"barfoofoobarthefoobarman\", [\"bar\",\"foo\",\"the\"])\\n        XCTAssertEqual(value, [6,9,12])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969070,
                "title": "approach-using-hashmap-and-sliding-window-concepts-in-c-easy-understandable-code",
                "content": "Please give a upvote if you like this solutions. Comment if you didn\\'t get it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        unordered_map<string, int> M, temp;\\n        vector<int> Ans;\\n        int N = words.size();\\n        int L = words[0].size();\\n        \\n        // Store all the frequencies of all strings\\n        // in the array words[]\\n        for(auto &it : words) {\\n            M[it]++;\\n        }\\n        int size = s.length();\\n        \\n        // Loop till possible number of starting\\n        // index of the valid indices\\n        for(int i = 0; i < size - N*L + 1; i++) {\\n            \\n            // Iterate the current window of\\n            // length N*L over the range\\n            // [i, i + N*L] and extract the\\n            // substring of length L and store\\n            // it\\'s frequency\\n            for(int j = i; j < i + N*L; j+= L) {\\n                string ans = s.substr(j, L);\\n                temp[ans]++;\\n            }\\n            \\n            int flag = 1;\\n            \\n            // Now, check if the frequency of each string\\n            // in map M is the same as the frequency in\\n            // map temp. This ensure that the current\\n            // window is of the same concatenation of\\n            // the strings in the array words[]\\n            for(auto &it : M) {\\n                if(M[it.first] != temp[it.first]) {\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n            \\n            // If the current window is the possible\\n\\t\\t\\t// result then store the starting index of it\\n            if(flag) Ans.push_back(i);\\n            \\n            // Clear the temp for another window\\n            temp.clear();\\n        }\\n        \\n        // Return the resultant vector of indices\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        unordered_map<string, int> M, temp;\\n        vector<int> Ans;\\n        int N = words.size();\\n        int L = words[0].size();\\n        \\n        // Store all the frequencies of all strings\\n        // in the array words[]\\n        for(auto &it : words) {\\n            M[it]++;\\n        }\\n        int size = s.length();\\n        \\n        // Loop till possible number of starting\\n        // index of the valid indices\\n        for(int i = 0; i < size - N*L + 1; i++) {\\n            \\n            // Iterate the current window of\\n            // length N*L over the range\\n            // [i, i + N*L] and extract the\\n            // substring of length L and store\\n            // it\\'s frequency\\n            for(int j = i; j < i + N*L; j+= L) {\\n                string ans = s.substr(j, L);\\n                temp[ans]++;\\n            }\\n            \\n            int flag = 1;\\n            \\n            // Now, check if the frequency of each string\\n            // in map M is the same as the frequency in\\n            // map temp. This ensure that the current\\n            // window is of the same concatenation of\\n            // the strings in the array words[]\\n            for(auto &it : M) {\\n                if(M[it.first] != temp[it.first]) {\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n            \\n            // If the current window is the possible\\n\\t\\t\\t// result then store the starting index of it\\n            if(flag) Ans.push_back(i);\\n            \\n            // Clear the temp for another window\\n            temp.clear();\\n        }\\n        \\n        // Return the resultant vector of indices\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13699,
                "title": "92-java-o-n-with-explaination",
                "content": "```java\\npublic class Solution {\\n\\t\\n\\t/*\\n\\t\\tA time & space O(n) solution\\n\\t\\tRun a moving window for wordLen times.\\n\\t\\tEach time we keep a window of size windowLen (= wordLen * numWord), each step length is wordLen.\\n\\t\\tSo each scan takes O(sLen / wordLen), totally takes O(sLen / wordLen * wordLen) = O(sLen) time.\\n\\t\\t\\n\\t\\tOne trick here is use count to record the number of exceeded occurrences of word in current window\\n\\t*/\\n    public static List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> res = new ArrayList<>();\\n        if(words == null || words.length == 0 || s.length() == 0) return res;\\n        int wordLen = words[0].length();\\n        int numWord = words.length;\\n        int windowLen = wordLen * numWord;\\n        int sLen = s.length();\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n\\n        for(int i = 0; i < wordLen; i++) {  // Run wordLen scans\\n            HashMap<String, Integer> curMap = new HashMap<>();\\n            for(int j = i, count = 0, start = i; j + wordLen <= sLen; j += wordLen) {  // Move window in step of wordLen\\n                // count: number of exceeded occurences in current window\\n                // start: start index of current window of size windowLen\\n                if(start + windowLen > sLen) break;\\n                String word = s.substring(j, j + wordLen);\\n                if(!map.containsKey(word)) {\\n                    curMap.clear();\\n                    count = 0;\\n                    start = j + wordLen;\\n                }\\n                else {\\n                    if(j == start + windowLen) { // Remove previous word of current window\\n                        String preWord = s.substring(start, start + wordLen);\\n                        start += wordLen;\\n                        int val = curMap.get(preWord);\\n                        if(val == 1) curMap.remove(preWord);\\n                        else curMap.put(preWord, val - 1);\\n                        if(val - 1 >= map.get(preWord)) count--;  // Reduce count of exceeded word\\n                    }\\n                    // Add new word\\n                    curMap.put(word, curMap.getOrDefault(word, 0) + 1);\\n                    if(curMap.get(word) > map.get(word)) count++;  // More than expected, increase count\\n                    // Check if current window valid\\n                    if(count == 0 && start + windowLen == j + wordLen) {\\n                        res.add(start);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n\\t\\n\\t/*\\n\\t\\tA time & space O(n) solution\\n\\t\\tRun a moving window for wordLen times.\\n\\t\\tEach time we keep a window of size windowLen (= wordLen * numWord), each step length is wordLen.\\n\\t\\tSo each scan takes O(sLen / wordLen), totally takes O(sLen / wordLen * wordLen) = O(sLen) time.\\n\\t\\t\\n\\t\\tOne trick here is use count to record the number of exceeded occurrences of word in current window\\n\\t*/\\n    public static List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> res = new ArrayList<>();\\n        if(words == null || words.length == 0 || s.length() == 0) return res;\\n        int wordLen = words[0].length();\\n        int numWord = words.length;\\n        int windowLen = wordLen * numWord;\\n        int sLen = s.length();\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n\\n        for(int i = 0; i < wordLen; i++) {  // Run wordLen scans\\n            HashMap<String, Integer> curMap = new HashMap<>();\\n            for(int j = i, count = 0, start = i; j + wordLen <= sLen; j += wordLen) {  // Move window in step of wordLen\\n                // count: number of exceeded occurences in current window\\n                // start: start index of current window of size windowLen\\n                if(start + windowLen > sLen) break;\\n                String word = s.substring(j, j + wordLen);\\n                if(!map.containsKey(word)) {\\n                    curMap.clear();\\n                    count = 0;\\n                    start = j + wordLen;\\n                }\\n                else {\\n                    if(j == start + windowLen) { // Remove previous word of current window\\n                        String preWord = s.substring(start, start + wordLen);\\n                        start += wordLen;\\n                        int val = curMap.get(preWord);\\n                        if(val == 1) curMap.remove(preWord);\\n                        else curMap.put(preWord, val - 1);\\n                        if(val - 1 >= map.get(preWord)) count--;  // Reduce count of exceeded word\\n                    }\\n                    // Add new word\\n                    curMap.put(word, curMap.getOrDefault(word, 0) + 1);\\n                    if(curMap.get(word) > map.get(word)) count++;  // More than expected, increase count\\n                    // Check if current window valid\\n                    if(count == 0 && start + windowLen == j + wordLen) {\\n                        res.add(start);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13812,
                "title": "hash-idea-and-exception-case",
                "content": "The following python code is accepted by OJ. It is based on the following idea (assumption)\\n\\n -  We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets ->  those multisets are identical\\n\\n \\nThis is not true for same very very rare cases. Please describe such a case.\\n\\n    def findSubstring(self, S, L):\\n        n = len(L) #num words\\n        w = len(L[0])  #length of each word\\n        t = n*w    # total length\\n    \\n        hashsum = sum([hash(x) for x in L])\\n        h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)]\\n        return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum]",
                "solutionTags": [],
                "code": "The following python code is accepted by OJ. It is based on the following idea (assumption)\\n\\n -  We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets ->  those multisets are identical\\n\\n \\nThis is not true for same very very rare cases. Please describe such a case.\\n\\n    def findSubstring(self, S, L):\\n        n = len(L) #num words\\n        w = len(L[0])  #length of each word\\n        t = n*w    # total length\\n    \\n        hashsum = sum([hash(x) for x in L])\\n        h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)]\\n        return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum]",
                "codeTag": "Python3"
            },
            {
                "id": 13691,
                "title": "java-12ms-beats-100",
                "content": "The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test.\\n\\n    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t\\t */\\n\\t\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\t\\tString test, temp;\\n\\t\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\t\\tres.add(start);\\n\\t\\t\\t\\t// slide start to the next word\\n\\t\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\t\\treturn start + k;\\n\\t\\t\\t}\\n\\t\\t\\treturn start;\\n\\t\\t}\\n\\n\\t\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\t\\tint x = curDict.get(key);\\n\\t\\t\\tif (x == 1)\\n\\t\\t\\t\\tcurDict.remove(key);\\n\\t\\t\\telse\\n\\t\\t\\t\\tcurDict.put(key, x - 1);\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test.\\n\\n    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t\\t */\\n\\t\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\t\\tString test, temp;\\n\\t\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\t\\tres.add(start);\\n\\t\\t\\t\\t// slide start to the next word\\n\\t\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\t\\treturn start + k;\\n\\t\\t\\t}\\n\\t\\t\\treturn start;\\n\\t\\t}\\n\\n\\t\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\t\\tint x = curDict.get(key);\\n\\t\\t\\tif (x == 1)\\n\\t\\t\\t\\tcurDict.remove(key);\\n\\t\\t\\telse\\n\\t\\t\\t\\tcurDict.put(key, x - 1);\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2417602,
                "title": "c-easy-solution-using-hashmap",
                "content": "# **C++ Easy Solution Using Hashmap**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>ans;\\n        int n=words.size();\\n        int m=words[0].size();\\n        int total=n*m;\\n        if(s.size()<total){\\n            return ans;\\n        }\\n        for(int i=0;i<=s.size()-total;i++){\\n            unordered_map<string,int>mp;\\n            \\n            for(int j=0;j<words.size();j++){\\n                mp[words[j]]++;\\n            }\\n            int k;\\n            for(k=0;k<n;k++){\\n                \\n                string temp=s.substr(i+k*m,m);\\n                // cout<<temp<<\" \"<<i<<endl;\\n                if(mp.count(temp)==0){\\n                    break;\\n                }\\n                else{\\n                    if(mp[temp]!=0){\\n                        mp[temp]--;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            if(k==n){\\n                ans.push_back(i);\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>ans;\\n        int n=words.size();\\n        int m=words[0].size();\\n        int total=n*m;\\n        if(s.size()<total){\\n            return ans;\\n        }\\n        for(int i=0;i<=s.size()-total;i++){\\n            unordered_map<string,int>mp;\\n            \\n            for(int j=0;j<words.size();j++){\\n                mp[words[j]]++;\\n            }\\n            int k;\\n            for(k=0;k<n;k++){\\n                \\n                string temp=s.substr(i+k*m,m);\\n                // cout<<temp<<\" \"<<i<<endl;\\n                if(mp.count(temp)==0){\\n                    break;\\n                }\\n                else{\\n                    if(mp[temp]!=0){\\n                        mp[temp]--;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            if(k==n){\\n                ans.push_back(i);\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13733,
                "title": "accepted-short-java-solution",
                "content": "Hey, guys!\\n\\nActually, there's nothing special in my solution except the comparably short Java code. It's just a simple sliding window approach which is greatly described in other posts.\\n\\nIn short, we got the source histogram from the dictionary L and build the new histogram for each possible window comparing it with the help of Java's *equals* method to the source one. Additionally, for the sake of tiny optimization, we check the starting word for being in the dictionary. \\n\\n\\n    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> result = new ArrayList<>();\\n        int size = L[0].length();\\n        if (L.length == 0 || L[0].isEmpty() || L[0].length() > S.length()) \\n            return result;\\n        Map<String, Integer> hist = new HashMap<>();\\n        for (String w : L) {\\n            hist.put(w, !hist.containsKey(w) ? 1 : hist.get(w)+1);\\n        }\\n        for (int i = 0; i+size*L.length <= S.length(); i++) {\\n            if (hist.containsKey(S.substring(i, i+size))) {\\n                Map<String, Integer> currHist = new HashMap<>();\\n                for (int j = 0; j < L.length; j++) {\\n                    String word = S.substring(i+j*size, i+(j+1)*size);\\n                    currHist.put(word, !currHist.containsKey(word) ? \\n                            1 : currHist.get(word)+1);\\n                }\\n                if (currHist.equals(hist)) result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hey, guys!\\n\\nActually, there's nothing special in my solution except the comparably short Java code. It's just a simple sliding window approach which is greatly described in other posts.\\n\\nIn short, we got the source histogram from the dictionary L and build the new histogram for each possible window comparing it with the help of Java's *equals* method to the source one. Additionally, for the sake of tiny optimization, we check the starting word for being in the dictionary. \\n\\n\\n    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> result = new ArrayList<>();\\n        int size = L[0].length();\\n        if (L.length == 0 || L[0].isEmpty() || L[0].length() > S.length()) \\n            return result;\\n        Map<String, Integer> hist = new HashMap<>();\\n        for (String w : L) {\\n            hist.put(w, !hist.containsKey(w) ? 1 : hist.get(w)+1);\\n        }\\n        for (int i = 0; i+size*L.length <= S.length(); i++) {\\n            if (hist.containsKey(S.substring(i, i+size))) {\\n                Map<String, Integer> currHist = new HashMap<>();\\n                for (int j = 0; j < L.length; j++) {\\n                    String word = S.substring(i+j*size, i+(j+1)*size);\\n                    currHist.put(word, !currHist.containsKey(word) ? \\n                            1 : currHist.get(word)+1);\\n                }\\n                if (currHist.equals(hist)) result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 163145,
                "title": "clean-python-o-n-k-with-two-maps-and-detailed-explanation",
                "content": "* Count the occurance of each word in words and store in a dict\\n* Have a temp dict to check for the number of word used\\n* Iterate through string s and check substring of len(word[0]) each time (note all words in words have the same length)\\n\\t* Two things can happen when we check \\n\\t\\t* substring match and we haven\\'t used the word yet -> word_used += 1 and decrease count of word in counter\\n\\t\\t* substring either doesn\\'t match or we already used the substring -> break and move to the next substring\\n* if we have used all of the words in word list then we have found a index\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not s or not words:\\n            return []\\n        \\n        word_map = Counter(words)\\n        results = []\\n        word_size = len(words[0])\\n        num_word = len(words)\\n        list_size = word_size*num_word\\n        for i in range(len(s) - list_size + 1):\\n            seen = dict(word_map)\\n            word_used = 0\\n            for j in range(i, i + list_size, word_size):\\n                sub_str = s[j: j + word_size]\\n                if sub_str in seen and seen[sub_str] > 0:\\n                    seen[sub_str] -= 1\\n                    word_used += 1\\n                else:\\n                    break\\n            if word_used == num_word:\\n                results.append(i)\\n        return results\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not s or not words:\\n            return []\\n        \\n        word_map = Counter(words)\\n        results = []\\n        word_size = len(words[0])\\n        num_word = len(words)\\n        list_size = word_size*num_word\\n        for i in range(len(s) - list_size + 1):\\n            seen = dict(word_map)\\n            word_used = 0\\n            for j in range(i, i + list_size, word_size):\\n                sub_str = s[j: j + word_size]\\n                if sub_str in seen and seen[sub_str] > 0:\\n                    seen[sub_str] -= 1\\n                    word_used += 1\\n                else:\\n                    break\\n            if word_used == num_word:\\n                results.append(i)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418368,
                "title": "java-clean-solution-using-hashmap",
                "content": "The fact that all words are the same length makes it easy to iterate over a string. \\n\\tFor each potential substring, we make a map of the words in it and compare it with the map of the words of the input set \\n\\t(with the condition of an early exit, if the word is not in the input set or is present fewer times)\\n\\n```java\\npublic List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> indices = new ArrayList<>();\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n        Arrays.stream(words).forEach(word -> wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1));\\n\\n        int wordLength = words[0].length(), count = words.length;\\n        for (int index = 0; index <= s.length() - wordLength * count; ++index) {\\n            if (isContainsAllWords(wordsMap, s.substring(index, index + wordLength * count), wordLength))\\n                indices.add(index);\\n        }\\n\\n        return indices;\\n    }\\n\\n    private boolean isContainsAllWords(Map<String, Integer> wordsMap, String substring, int wordLength) {\\n        Map<String, Integer> substringWordsMap = new HashMap<>();\\n        for (int i = 0; i < substring.length(); i += wordLength) {\\n            String word = substring.substring(i, i + wordLength);\\n            substringWordsMap.put(word, substringWordsMap.getOrDefault(word, 0) + 1);\\n            \\n\\t\\t\\tif (substringWordsMap.get(word) > wordsMap.getOrDefault(word, 0))\\n                return false;\\n        }\\n        return substringWordsMap.equals(wordsMap);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> indices = new ArrayList<>();\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n        Arrays.stream(words).forEach(word -> wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1));\\n\\n        int wordLength = words[0].length(), count = words.length;\\n        for (int index = 0; index <= s.length() - wordLength * count; ++index) {\\n            if (isContainsAllWords(wordsMap, s.substring(index, index + wordLength * count), wordLength))\\n                indices.add(index);\\n        }\\n\\n        return indices;\\n    }\\n\\n    private boolean isContainsAllWords(Map<String, Integer> wordsMap, String substring, int wordLength) {\\n        Map<String, Integer> substringWordsMap = new HashMap<>();\\n        for (int i = 0; i < substring.length(); i += wordLength) {\\n            String word = substring.substring(i, i + wordLength);\\n            substringWordsMap.put(word, substringWordsMap.getOrDefault(word, 0) + 1);\\n            \\n\\t\\t\\tif (substringWordsMap.get(word) > wordsMap.getOrDefault(word, 0))\\n                return false;\\n        }\\n        return substringWordsMap.equals(wordsMap);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082532,
                "title": "javascript-solution",
                "content": "Thank you to jianchao-li for the great solution!\\n\\n```\\nvar findSubstring = function(s, words) {\\n    \\n    let res = [];\\n\\n    let wordLength = words[0].length;\\n    let wordCount = words.length;\\n    let len = wordCount * wordLength; //Length of sliding window\\n    \\n    let map = {}\\n    \\n    for (let word of words) map[word] = map[word] + 1 || 1; //Hash word freq\\n\\n  \\tfor (let i = 0; i < s.length - len + 1; i++) {\\n            let sub = s.slice(i, i + len); //Generate substring of sliding window length\\n            if (isConcat(sub, map, wordLength)) res.push(i)\\n        }\\n    \\n    return res;\\n};\\n\\nfunction isConcat(sub,map,wordLength){\\n    \\n    let seen = {};\\n    for (let i = 0; i < sub.length; i+=wordLength) {\\n        let word = sub.slice(i,i + wordLength);\\n        seen[word] = seen[word] + 1 || 1\\n    }\\n    \\n    for(let key in map){\\n        if(map[key] !== seen[key]) return false; //Word freq must match between map and seen\\n    }\\n    return true;\\n}```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar findSubstring = function(s, words) {\\n    \\n    let res = [];\\n\\n    let wordLength = words[0].length;\\n    let wordCount = words.length;\\n    let len = wordCount * wordLength; //Length of sliding window\\n    \\n    let map = {}\\n    \\n    for (let word of words) map[word] = map[word] + 1 || 1; //Hash word freq\\n\\n  \\tfor (let i = 0; i < s.length - len + 1; i++) {\\n            let sub = s.slice(i, i + len); //Generate substring of sliding window length\\n            if (isConcat(sub, map, wordLength)) res.push(i)\\n        }\\n    \\n    return res;\\n};\\n\\nfunction isConcat(sub,map,wordLength){\\n    \\n    let seen = {};\\n    for (let i = 0; i < sub.length; i+=wordLength) {\\n        let word = sub.slice(i,i + wordLength);\\n        seen[word] = seen[word] + 1 || 1\\n    }\\n    \\n    for(let key in map){\\n        if(map[key] !== seen[key]) return false; //Word freq must match between map and seen\\n    }\\n    return true;\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 13797,
                "title": "accepted-recursive-solution-using-trie-tree",
                "content": "The idea is quite simple. Just use a trie tree to accelerate testing whether a substring is valid. The value of each TrieNode is used to deal with duplication and to mark whether the word is used before.\\n\\n          static class TrieNode {\\n               int value = 0;\\n               Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\\n           }\\n    \\n           TrieNode trie;\\n    \\n\\t    // build a trie tree\\n\\t    public List<Integer> findSubstring(String S, String[] L) {\\n\\t        trie = buildTrie(L);\\n\\t        int length = getTotalLength(L);\\n\\t        List<Integer> result = new LinkedList<Integer>();\\n\\t        for (int i = 0; i < S.length() - length + 1; i++) {\\n\\t            if (isSubString(S, i, i + length))\\n\\t                result.add(i);\\n\\t        }\\n\\t        return result;\\n\\t    }\\n\\t    \\n\\t    private int getTotalLength(String[] L) {\\n\\t        int sum = 0;\\n\\t        for (String l : L)\\n\\t            sum += l.length();\\n\\t        return sum;\\n\\t    }\\n\\t    \\n\\t    private TrieNode buildTrie(String[] L) {\\n\\t        TrieNode root = new TrieNode();\\n\\t        for (String l : L)\\n\\t            addWord(root, l);\\n\\t        return root;\\n\\t    }\\n\\t    \\n\\t    private void addWord(TrieNode root, String s) {\\n\\t        TrieNode node = root;\\n\\t        for (int i = 0; i < s.length(); i++) {\\n\\t            char c = s.charAt(i);\\n\\t            TrieNode next = node.children.get(c);\\n\\t            if (next == null) {\\n\\t                next = new TrieNode();\\n\\t                node.children.put(c, next);\\n\\t            }\\n\\t            node = next;\\n\\t        }\\n\\t        node.value++;\\n\\t    }\\n\\t    \\n\\t    private boolean isSubString(String S, int start, int end) {\\n\\t    \\tif (start == end)\\n\\t    \\t\\treturn true;\\n\\t        // search in the trie tree\\n\\t        TrieNode node = trie;\\n\\t        for (int i = start; i < end; i++) {\\n\\t            char c = S.charAt(i);\\n\\t            if (node.children.get(c) == null)\\n\\t                return false;\\n\\t            node = node.children.get(c);\\n\\t            if (node.value > 0) {  // leaf & can be used\\n\\t                node.value--; // mark as used\\n\\t                if (isSubString(S, i + 1, end)) {\\n\\t                    node.value++; // mark as unused\\n\\t                    return true;\\n\\t                }\\n\\t                node.value++; // mark as unused\\n\\t            }\\n\\t        }\\n\\t        return false;\\n\\t    }",
                "solutionTags": [],
                "code": "The idea is quite simple. Just use a trie tree to accelerate testing whether a substring is valid. The value of each TrieNode is used to deal with duplication and to mark whether the word is used before.\\n\\n          static class TrieNode {\\n               int value = 0;\\n               Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\\n           }\\n    \\n           TrieNode trie;\\n    \\n\\t    // build a trie tree\\n\\t    public List<Integer> findSubstring(String S, String[] L) {\\n\\t        trie = buildTrie(L);\\n\\t        int length = getTotalLength(L);\\n\\t        List<Integer> result = new LinkedList<Integer>();\\n\\t        for (int i = 0; i < S.length() - length + 1; i++) {\\n\\t            if (isSubString(S, i, i + length))\\n\\t                result.add(i);\\n\\t        }\\n\\t        return result;\\n\\t    }\\n\\t    \\n\\t    private int getTotalLength(String[] L) {\\n\\t        int sum = 0;\\n\\t        for (String l : L)\\n\\t            sum += l.length();\\n\\t        return sum;\\n\\t    }\\n\\t    \\n\\t    private TrieNode buildTrie(String[] L) {\\n\\t        TrieNode root = new TrieNode();\\n\\t        for (String l : L)\\n\\t            addWord(root, l);\\n\\t        return root;\\n\\t    }\\n\\t    \\n\\t    private void addWord(TrieNode root, String s) {\\n\\t        TrieNode node = root;\\n\\t        for (int i = 0; i < s.length(); i++) {\\n\\t            char c = s.charAt(i);\\n\\t            TrieNode next = node.children.get(c);\\n\\t            if (next == null) {\\n\\t                next = new TrieNode();\\n\\t                node.children.put(c, next);\\n\\t            }\\n\\t            node = next;\\n\\t        }\\n\\t        node.value++;\\n\\t    }\\n\\t    \\n\\t    private boolean isSubString(String S, int start, int end) {\\n\\t    \\tif (start == end)\\n\\t    \\t\\treturn true;\\n\\t        // search in the trie tree\\n\\t        TrieNode node = trie;\\n\\t        for (int i = start; i < end; i++) {\\n\\t            char c = S.charAt(i);\\n\\t            if (node.children.get(c) == null)\\n\\t                return false;\\n\\t            node = node.children.get(c);\\n\\t            if (node.value > 0) {  // leaf & can be used\\n\\t                node.value--; // mark as used\\n\\t                if (isSubString(S, i + 1, end)) {\\n\\t                    node.value++; // mark as unused\\n\\t                    return true;\\n\\t                }\\n\\t                node.value++; // mark as unused\\n\\t            }\\n\\t        }\\n\\t        return false;\\n\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 13668,
                "title": "python-solution-k-sliding-window",
                "content": "````\\ndef findSubstring(self, s, words):\\n        if not words: return []\\n        k = len(words[0])\\n        res = []\\n        for left in range(k):\\n            d = collections.Counter(words)\\n            for right in range(left + k, len(s) + 1, k):\\n                word = s[right - k: right]\\n                d[word] -= 1\\n                while d[word] < 0:\\n                    d[s[left:left + k]] += 1\\n                    left += k\\n                if left + k * len(words) == right:\\n                    res.append(left)\\n        return res",
                "solutionTags": [],
                "code": "````\\ndef findSubstring(self, s, words):\\n        if not words: return []\\n        k = len(words[0])\\n        res = []\\n        for left in range(k):\\n            d = collections.Counter(words)\\n            for right in range(left + k, len(s) + 1, k):\\n                word = s[right - k: right]\\n                d[word] -= 1\\n                while d[word] < 0:\\n                    d[s[left:left + k]] += 1\\n                    left += k\\n                if left + k * len(words) == right:\\n                    res.append(left)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2418640,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.*\\nAlso you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\n\\nhttps://www.youtube.com/watch?v=JbCcTa7vyBE\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\\n**JAVA**(Copied)\\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**PYTHON**((Copied)\\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```**Please Don\\'t forget to UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367134,
                "title": "c-simple-and-easy-sliding-window-solution-28-ms-faster-than-97",
                "content": "We start from each i and count the words we find starting from i till the end.\\nIf we found a word more times than the frequency of it in the list, then we have to start from the beginning.\\nIf we found n words, then we have a solution.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].size(), n = words.size(), ssize = s.size(), left, found;\\n        vector<int> res;\\n        \\n        unordered_map<string, int> freq, tmp;\\n        for (auto word : words) freq[word]++;\\n            \\n        for (int i = 0; i < len; i++) {\\n            tmp.clear();\\n            left = i, found = 0;\\n            \\n            for (int j = i; j <= ssize - len; j += len) {\\n                string curr = s.substr(j, len);\\n                \\n                if (freq.find(curr) != freq.end()) {\\n                    tmp[curr]++;\\n                    found++;\\n\\n                    while (freq[curr] < tmp[curr]) {\\n                        tmp[s.substr(left, len)]--;\\n                        found--;\\n                        left += len;\\n                    }\\n\\n                    if (found == n) res.push_back(left);\\n                }\\n                \\n                else {\\n                    tmp.clear();\\n                    found = 0;\\n                    left = j + len;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].size(), n = words.size(), ssize = s.size(), left, found;\\n        vector<int> res;\\n        \\n        unordered_map<string, int> freq, tmp;\\n        for (auto word : words) freq[word]++;\\n            \\n        for (int i = 0; i < len; i++) {\\n            tmp.clear();\\n            left = i, found = 0;\\n            \\n            for (int j = i; j <= ssize - len; j += len) {\\n                string curr = s.substr(j, len);\\n                \\n                if (freq.find(curr) != freq.end()) {\\n                    tmp[curr]++;\\n                    found++;\\n\\n                    while (freq[curr] < tmp[curr]) {\\n                        tmp[s.substr(left, len)]--;\\n                        found--;\\n                        left += len;\\n                    }\\n\\n                    if (found == n) res.push_back(left);\\n                }\\n                \\n                else {\\n                    tmp.clear();\\n                    found = 0;\\n                    left = j + len;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418859,
                "title": "python-elegant-short-sliding-window-98-89-faster",
                "content": "![image](https://assets.leetcode.com/users/images/85899573-7ca7-4b61-9499-b4ba0c46df99_1660381001.113569.png)\\n\\n```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*k), n = length of s, k = length of each word\\n\\tMemory: O(m*k), m = length of words, k = length of each word\\n\\t\"\"\"\\n\\n\\tdef findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\t\\tlength = len(words[0])\\n\\t\\tword_count = Counter(words)\\n\\t\\tindexes = []\\n\\n\\t\\tfor i in range(length):\\n\\t\\t\\tstart = i\\n\\t\\t\\twindow = defaultdict(int)\\n\\t\\t\\twords_used = 0\\n\\n\\t\\t\\tfor j in range(i, len(s) - length + 1, length):\\n\\t\\t\\t\\tword = s[j:j + length]\\n\\n\\t\\t\\t\\tif word not in word_count:\\n\\t\\t\\t\\t\\tstart = j + length\\n\\t\\t\\t\\t\\twindow = defaultdict(int)\\n\\t\\t\\t\\t\\twords_used = 0\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\twords_used += 1\\n\\t\\t\\t\\twindow[word] += 1\\n\\n\\t\\t\\t\\twhile window[word] > word_count[word]:\\n\\t\\t\\t\\t\\twindow[s[start:start + length]] -= 1\\n\\t\\t\\t\\t\\tstart += length\\n\\t\\t\\t\\t\\twords_used -= 1\\n\\n\\t\\t\\t\\tif words_used == len(words):\\n\\t\\t\\t\\t\\tindexes.append(start)\\n\\n\\t\\treturn indexes\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*k), n = length of s, k = length of each word\\n\\tMemory: O(m*k), m = length of words, k = length of each word\\n\\t\"\"\"\\n\\n\\tdef findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\t\\tlength = len(words[0])\\n\\t\\tword_count = Counter(words)\\n\\t\\tindexes = []\\n\\n\\t\\tfor i in range(length):\\n\\t\\t\\tstart = i\\n\\t\\t\\twindow = defaultdict(int)\\n\\t\\t\\twords_used = 0\\n\\n\\t\\t\\tfor j in range(i, len(s) - length + 1, length):\\n\\t\\t\\t\\tword = s[j:j + length]\\n\\n\\t\\t\\t\\tif word not in word_count:\\n\\t\\t\\t\\t\\tstart = j + length\\n\\t\\t\\t\\t\\twindow = defaultdict(int)\\n\\t\\t\\t\\t\\twords_used = 0\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\twords_used += 1\\n\\t\\t\\t\\twindow[word] += 1\\n\\n\\t\\t\\t\\twhile window[word] > word_count[word]:\\n\\t\\t\\t\\t\\twindow[s[start:start + length]] -= 1\\n\\t\\t\\t\\t\\tstart += length\\n\\t\\t\\t\\t\\twords_used -= 1\\n\\n\\t\\t\\t\\tif words_used == len(words):\\n\\t\\t\\t\\t\\tindexes.append(start)\\n\\n\\t\\treturn indexes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373766,
                "title": "c-solution-32ms-based-on-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> result;\\n\\t\\tif (words.empty())return result;\\n\\t\\tunordered_map<string, int> counts, record;\\n\\t\\tfor (string word : words) {\\n\\t\\t\\tcounts[word]++;\\n\\t\\t}\\n\\t\\tint len = words[0].size(), num = words.size(), sl = s.size();\\n\\t\\tfor (int i = 0; i < len; ++i) {\\n\\t\\t\\tint left = i, sum = 0;\\n            record.clear();\\n\\t\\t\\tfor (int j = i; j <= sl - len; j+=len) {\\n\\t\\t\\t\\tstring word = s.substr(j, len);\\n\\t\\t\\t\\tif (counts.count(word)) {\\n\\t\\t\\t\\t\\trecord[word]++;\\n                    sum++;\\n                    while (record[word] > counts[word])\\n                    {\\n                        //remove the most left word\\n                        record[s.substr(left, len)]--;\\n                        left += len;\\n                        sum--;\\n                    }\\n\\t\\t\\t\\t\\tif (sum == num) \\n\\t\\t\\t\\t\\t\\tresult.push_back(left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trecord.clear();\\n\\t\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\t\\tleft = j + len;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> result;\\n\\t\\tif (words.empty())return result;\\n\\t\\tunordered_map<string, int> counts, record;\\n\\t\\tfor (string word : words) {\\n\\t\\t\\tcounts[word]++;\\n\\t\\t}\\n\\t\\tint len = words[0].size(), num = words.size(), sl = s.size();\\n\\t\\tfor (int i = 0; i < len; ++i) {\\n\\t\\t\\tint left = i, sum = 0;\\n            record.clear();\\n\\t\\t\\tfor (int j = i; j <= sl - len; j+=len) {\\n\\t\\t\\t\\tstring word = s.substr(j, len);\\n\\t\\t\\t\\tif (counts.count(word)) {\\n\\t\\t\\t\\t\\trecord[word]++;\\n                    sum++;\\n                    while (record[word] > counts[word])\\n                    {\\n                        //remove the most left word\\n                        record[s.substr(left, len)]--;\\n                        left += len;\\n                        sum--;\\n                    }\\n\\t\\t\\t\\t\\tif (sum == num) \\n\\t\\t\\t\\t\\t\\tresult.push_back(left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trecord.clear();\\n\\t\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\t\\tleft = j + len;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263684,
                "title": "sliding-window-solution-in-python",
                "content": "```\\n    def findSubstring(self, s: str, words: \\'List[str]\\') -> \\'List[int]\\':\\n        if not words:\\n            return []\\n        \\n        word_len, res = len(words[0]), []\\n        \\n        # start offset from 0 to word_len, and step is word_len\\n        for i in range(word_len):\\n            # reset state every epoch\\n\\t\\t\\t# counter maintain current state\\n            counter = Counter(words)\\n\\t\\t\\t# two-pointer as boundary of sliding window to traverse, and count as condition checker, update it when trigger some key changes\\n            start, end, count = i, i, len(words)\\n            while end < len(s):\\n                cur_word = s[end:end + word_len]\\n                # check is not necessary here, just for performance\\n                if cur_word in counter:\\n                    counter[cur_word] -= 1\\n                    if counter[cur_word] >= 0:\\n                        count -= 1\\n                end += word_len\\n\\n                if count == 0:\\n                    res.append(start)\\n\\n                # ensure consecutive words\\n                if end - start == word_len * len(words):\\n                    cur_word = s[start:start + word_len]\\n                    if cur_word in counter:\\n                        counter[cur_word] += 1\\n                        if counter[cur_word] > 0:\\n                            count += 1\\n                    start += word_len\\n\\n        # the order is not necessary here\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    def findSubstring(self, s: str, words: \\'List[str]\\') -> \\'List[int]\\':\\n        if not words:\\n            return []\\n        \\n        word_len, res = len(words[0]), []\\n        \\n        # start offset from 0 to word_len, and step is word_len\\n        for i in range(word_len):\\n            # reset state every epoch\\n\\t\\t\\t# counter maintain current state\\n            counter = Counter(words)\\n\\t\\t\\t# two-pointer as boundary of sliding window to traverse, and count as condition checker, update it when trigger some key changes\\n            start, end, count = i, i, len(words)\\n            while end < len(s):\\n                cur_word = s[end:end + word_len]\\n                # check is not necessary here, just for performance\\n                if cur_word in counter:\\n                    counter[cur_word] -= 1\\n                    if counter[cur_word] >= 0:\\n                        count -= 1\\n                end += word_len\\n\\n                if count == 0:\\n                    res.append(start)\\n\\n                # ensure consecutive words\\n                if end - start == word_len * len(words):\\n                    cur_word = s[start:start + word_len]\\n                    if cur_word in counter:\\n                        counter[cur_word] += 1\\n                        if counter[cur_word] > 0:\\n                            count += 1\\n                    start += word_len\\n\\n        # the order is not necessary here\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 181494,
                "title": "share-my-concise-javascript-solution",
                "content": "```javascript\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nconst findSubstring = (s, words) => {\\n    // Sanity check\\n    if (!words || words.length === 0) return [];\\n\\n    const m = words.length, n = words[0].length, len = m * n, result = [];\\n    \\n    // Build the word-count hash map\\n    const map = {};\\n    for (word of words) map[word] = ~~map[word] + 1;\\n\\n    // Try every possible start position i\\n    for (let i = 0; i < s.length - len + 1; i++) {\\n        // Make a copy of the hash map\\n        const temp = Object.assign({}, map);\\n\\n        for (let j = i; j < i + len; j += n) {\\n            const str = s.substr(j, n);\\n            // Cannot find the word in hash map (words list), try another position\\n            if (!(str in temp)) break;\\n            // All the same word str are found, remove it from the hash map\\n            if (--temp[str] === 0) delete temp[str];\\n        }\\n        \\n        // We have gone through the whole s and used all our words in the list\\n        if (Object.keys(temp).length === 0) result.push(i);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nconst findSubstring = (s, words) => {\\n    // Sanity check\\n    if (!words || words.length === 0) return [];\\n\\n    const m = words.length, n = words[0].length, len = m * n, result = [];\\n    \\n    // Build the word-count hash map\\n    const map = {};\\n    for (word of words) map[word] = ~~map[word] + 1;\\n\\n    // Try every possible start position i\\n    for (let i = 0; i < s.length - len + 1; i++) {\\n        // Make a copy of the hash map\\n        const temp = Object.assign({}, map);\\n\\n        for (let j = i; j < i + len; j += n) {\\n            const str = s.substr(j, n);\\n            // Cannot find the word in hash map (words list), try another position\\n            if (!(str in temp)) break;\\n            // All the same word str are found, remove it from the hash map\\n            if (--temp[str] === 0) delete temp[str];\\n        }\\n        \\n        // We have gone through the whole s and used all our words in the list\\n        if (Object.keys(temp).length === 0) result.push(i);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2182261,
                "title": "sliding-window-hashmap-java-solution-simple-code",
                "content": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int n = words.length;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        int k = words[0].length() * words.length;\\n        int z = words[0].length();\\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            if (j - i + 1 == k) {\\n                String sub = s.substring(i, j + 1);\\n                HashMap<String, Integer> map2 = new HashMap<>();\\n                int p = 0;\\n                while (p < sub.length()) {\\n                    String temp = sub.substring(p, p + z);\\n                    map2.put(temp,map2.getOrDefault(temp,0)+1);\\n                    p +=z;\\n                }\\n                if (map.equals(map2)){\\n                    ans.add(i);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int n = words.length;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        int k = words[0].length() * words.length;\\n        int z = words[0].length();\\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            if (j - i + 1 == k) {\\n                String sub = s.substring(i, j + 1);\\n                HashMap<String, Integer> map2 = new HashMap<>();\\n                int p = 0;\\n                while (p < sub.length()) {\\n                    String temp = sub.substring(p, p + z);\\n                    map2.put(temp,map2.getOrDefault(temp,0)+1);\\n                    p +=z;\\n                }\\n                if (map.equals(map2)){\\n                    ans.add(i);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417760,
                "title": "hashmap",
                "content": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        int n = words.size();\\n        int len = words[0].size();\\n        vector<int> ans;\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(string &str : words) {\\n            mp[str]++;\\n        }\\n        \\n        for(int i=0; i<s.size()-(n*len)+1; i++) {\\n            unordered_map<string, int>m;\\n            for(int j=i; j<i+n*len; j+=len) {\\n                string str = s.substr(j, len);\\n                m[str]++;\\n            }\\n            if(mp == m) {\\n                ans.push_back(i);\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n};****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        int n = words.size();\\n        int len = words[0].size();\\n        vector<int> ans;\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(string &str : words) {\\n            mp[str]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2136167,
                "title": "c-faster-than-92-72-of-c-less-than-91-23-of-c",
                "content": "Runtime: 40 ms, faster than 92.72% of C++ online submissions for Substring with Concatenation of All Words.\\nMemory Usage: 16.5 MB, less than 91.23% of C++ online submissions for Substring with Concatenation of All Words.\\n\\nHere we are using the concept of longest-substring-without-repeating-characters\\nLink: https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n\\nLets understand the approach with example:\\n\\n\"wordgoodgoodgoodbestword\", \\nwords = [\"word\",\"good\",\"best\",\"word\"]\\n\\nWe will store the word and its freq in a map, lets name the map as \"contain\".\\ncontain[words[i]]++\\n\\nOur map will look like:\\nword = 2\\ngood = 1\\nbest = 1\\n\\nlet len = length of words in words, ie len = words[0].length()\\n\\nThen we will use two loops to iterate \\nOutermost loop will determine the starting which is from 0 to  len - 1\\nInnermost loop will do a jump of i += len\\nand within this we will implement longest substring without repeating.\\n\\nLets try to visualise why we used two loop\\n\\ns = \"wordgoodgoodgoodbestword\", \\nwords = [\"word\",\"good\",\"best\",\"word\"]\\n\\nWe can break this as\\n\\nword good good good best word \\nor\\nw ordg oodg oodg oodb estw ord\\nor\\nwo rdgo odgo odgo odbe stwo rd\\nor\\nwor dgoo dgoo dgoo dbes twor d\\n\\nif we further break it then it will be identical to the first \\n\\nNow after breaking, we just need to find the  longest substring without repeating-characters\\nBut here our words may repeat as per the freq so instead of > 1 we will use > contain[word[i]] (contain is the map we made earlier) in our if condition.\\n\\nCode:\\n```\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        int len = words[0].length();\\n        \\n        unordered_map<string, int> contain;\\n        for(string s: words) contain[s]++;\\n        \\n        vector<int> res;\\n        for(int j = 0; j < len; j++) {\\n            unordered_map<string, int> found;\\n            int st = j;\\n            for(int i = 0 + j; i < str.size() - len + 1; i += len) {\\n                string curr = str.substr(i, len);\\n                if(contain.find(curr) != contain.end()) {\\n                    found[curr]++;\\n                    while(found[curr] > contain[curr]) {\\n                        found[str.substr(st, len)]--;\\n                        st += len;\\n                    }\\n                    int size = (i - st + len) / len;\\n                    if(size == words.size()) {\\n                        cout << j << \" \" << st << \" \" << i << endl;\\n                        res.push_back(st);\\n                    }\\n                } else {\\n                    found.clear();\\n                    st = i + len;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nPS: I am not a good with writing explanations so please bear with that\\nIf it helped please upvote.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        int len = words[0].length();\\n        \\n        unordered_map<string, int> contain;\\n        for(string s: words) contain[s]++;\\n        \\n        vector<int> res;\\n        for(int j = 0; j < len; j++) {\\n            unordered_map<string, int> found;\\n            int st = j;\\n            for(int i = 0 + j; i < str.size() - len + 1; i += len) {\\n                string curr = str.substr(i, len);\\n                if(contain.find(curr) != contain.end()) {\\n                    found[curr]++;\\n                    while(found[curr] > contain[curr]) {\\n                        found[str.substr(st, len)]--;\\n                        st += len;\\n                    }\\n                    int size = (i - st + len) / len;\\n                    if(size == words.size()) {\\n                        cout << j << \" \" << st << \" \" << i << endl;\\n                        res.push_back(st);\\n                    }\\n                } else {\\n                    found.clear();\\n                    st = i + len;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1902490,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    let map: [Character: Int] = [\\n        \"a\": 11,\\n        \"b\": 13,\\n        \"c\": 17,\\n        \"d\": 19,\\n        \"e\": 23,\\n        \"f\": 29,\\n        \"g\": 31,\\n        \"h\": 37,\\n        \"i\": 39,\\n        \"j\": 41,\\n        \"k\": 43,\\n        \"l\": 47,\\n        \"m\": 53,\\n        \"n\": 59,\\n        \"o\": 61,\\n        \"p\": 67,\\n        \"q\": 71,\\n        \"r\": 73,\\n        \"s\": 79,\\n        \"t\": 83,\\n        \"u\": 89,\\n        \"v\": 97,\\n        \"w\": 101,\\n        \"x\": 103,\\n        \"y\": 107,\\n        \"z\": 109\\n    ]\\n\\n\\n    func hash(_ s: [Character]) -> Int {\\n        var hashvalue: Int = 0\\n        for c in s {  hashvalue += map[c]! }\\n        return hashvalue\\n    }\\n\\n\\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\\n        let s = Array(s)\\n        let words = words.map({ Array($0) })\\n        let sLength = s.count\\n        let wLength = words.reduce(0, { $0 + $1.count })\\n        \\n        if sLength < wLength { return [] }\\n        \\n        let wHash = words.reduce(0, { $0 + hash($1) })\\n        let wSubLength = words.count > 0 ? words[0].count : 0\\n        var invalidStringList: [[Character]] = []\\n        var validStringList: [[Character]] = []\\n        var res: [Int] = []\\n        var i = 0\\n        var sHash = 0\\n\\n        while i <= sLength - wLength {\\n            if i == 0 {\\n                sHash = hash(Array(s[i..<i+wLength]))\\n            } else {\\n                sHash += map[s[i + wLength - 1]]! - map[s[i - 1]]!\\n            }\\n            if wHash == sHash {\\n                let subString = Array(s[i..<i + wLength])\\n                if invalidStringList.contains(subString) {\\n                    i += 1\\n                    continue\\n                }\\n                if validStringList.contains(subString) {\\n                    res.append(i)\\n                    i += 1\\n                    continue\\n                }\\n                var is_match = true\\n                var words = words\\n                for j in 0..<words.count {\\n                    let word = Array(s[(i + j * wSubLength)..<(i + (j + 1) * wSubLength)])\\n                    if !words.contains(word) {\\n                        is_match = false\\n                        break\\n                    } else {\\n                        let index = words.firstIndex(of: word)!\\n                        words.remove(at: index)\\n                    }\\n                }\\n                if is_match {\\n                    res.append(i)\\n                    validStringList.append(subString)\\n                } else {\\n                    invalidStringList.append(subString)\\n                }\\n            }\\n            i += 1\\n        }\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    let map: [Character: Int] = [\\n        \"a\": 11,\\n        \"b\": 13,\\n        \"c\": 17,\\n        \"d\": 19,\\n        \"e\": 23,\\n        \"f\": 29,\\n        \"g\": 31,\\n        \"h\": 37,\\n        \"i\": 39,\\n        \"j\": 41,\\n        \"k\": 43,\\n        \"l\": 47,\\n        \"m\": 53,\\n        \"n\": 59,\\n        \"o\": 61,\\n        \"p\": 67,\\n        \"q\": 71,\\n        \"r\": 73,\\n        \"s\": 79,\\n        \"t\": 83,\\n        \"u\": 89,\\n        \"v\": 97,\\n        \"w\": 101,\\n        \"x\": 103,\\n        \"y\": 107,\\n        \"z\": 109\\n    ]\\n\\n\\n    func hash(_ s: [Character]) -> Int {\\n        var hashvalue: Int = 0\\n        for c in s {  hashvalue += map[c]! }\\n        return hashvalue\\n    }\\n\\n\\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\\n        let s = Array(s)\\n        let words = words.map({ Array($0) })\\n        let sLength = s.count\\n        let wLength = words.reduce(0, { $0 + $1.count })\\n        \\n        if sLength < wLength { return [] }\\n        \\n        let wHash = words.reduce(0, { $0 + hash($1) })\\n        let wSubLength = words.count > 0 ? words[0].count : 0\\n        var invalidStringList: [[Character]] = []\\n        var validStringList: [[Character]] = []\\n        var res: [Int] = []\\n        var i = 0\\n        var sHash = 0\\n\\n        while i <= sLength - wLength {\\n            if i == 0 {\\n                sHash = hash(Array(s[i..<i+wLength]))\\n            } else {\\n                sHash += map[s[i + wLength - 1]]! - map[s[i - 1]]!\\n            }\\n            if wHash == sHash {\\n                let subString = Array(s[i..<i + wLength])\\n                if invalidStringList.contains(subString) {\\n                    i += 1\\n                    continue\\n                }\\n                if validStringList.contains(subString) {\\n                    res.append(i)\\n                    i += 1\\n                    continue\\n                }\\n                var is_match = true\\n                var words = words\\n                for j in 0..<words.count {\\n                    let word = Array(s[(i + j * wSubLength)..<(i + (j + 1) * wSubLength)])\\n                    if !words.contains(word) {\\n                        is_match = false\\n                        break\\n                    } else {\\n                        let index = words.firstIndex(of: word)!\\n                        words.remove(at: index)\\n                    }\\n                }\\n                if is_match {\\n                    res.append(i)\\n                    validStringList.append(subString)\\n                } else {\\n                    invalidStringList.append(subString)\\n                }\\n            }\\n            i += 1\\n        }\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175458,
                "title": "sliding-window-logical-thinking-reuse-lc-438",
                "content": ">All words share the same length, if we regard each word as a character,  we could apply the same idea as [Solution for 438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/175381/Beats-96-Sliding-Window-Java-with-Explanations).\\n\\n>Current window `[i, j]` for `i`, `j` move `wordLength` characters per step.\\n\\n>As long as window\\'s length equals to `wordsTotalLength`, we validate current window.\\n\\n>To cover all possible starting indices of concatenation, we should do LC438 for `wordLength` rounds. In each round, `i` starts at `round`.\\n\\n****\\n```\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        if (s == null || s.isEmpty() || words == null || words.length == 0) return new ArrayList<>();\\n        \\n        int wordLength = words[0].length(), wordsTotalLength = wordLength * words.length;\\n        List<Integer> startIndices = new ArrayList<>();\\n        \\n        // Map word to its frequency in words.\\n        Map<String, Integer> wordToFreqWords = new HashMap<>();\\n        for (String word : words) {\\n            wordToFreqWords.put(word, wordToFreqWords.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        Map<String, Integer> wordToFreqWindow;\\n        \\n        for (int round = 0; round < wordLength; round++) {\\n            int j = round + wordLength - 1;\\n            wordToFreqWindow = new HashMap<>();\\n            for (int i = round; i + wordsTotalLength - 1 < s.length(); i += wordLength) {\\n                while (j - i + 1 <= wordsTotalLength) { \\n                    String word = s.substring(j - wordLength + 1, j + 1);\\n                    wordToFreqWindow.put(word, wordToFreqWindow.getOrDefault(word, 0) + 1);\\n                    j += wordLength;\\n                }\\n\\n                if (wordToFreqWindow.equals(wordToFreqWords)) startIndices.add(i);\\n                \\n                String word = s.substring(i, i + wordLength);\\n                wordToFreqWindow.put(word, wordToFreqWindow.getOrDefault(word, 0) - 1);\\n                if (wordToFreqWindow.get(word) == 0) wordToFreqWindow.remove(word);\\n            }\\n        }\\n        \\n        return startIndices;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        if (s == null || s.isEmpty() || words == null || words.length == 0) return new ArrayList<>();\\n        \\n        int wordLength = words[0].length(), wordsTotalLength = wordLength * words.length;\\n        List<Integer> startIndices = new ArrayList<>();\\n        \\n        // Map word to its frequency in words.\\n        Map<String, Integer> wordToFreqWords = new HashMap<>();\\n        for (String word : words) {\\n            wordToFreqWords.put(word, wordToFreqWords.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        Map<String, Integer> wordToFreqWindow;\\n        \\n        for (int round = 0; round < wordLength; round++) {\\n            int j = round + wordLength - 1;\\n            wordToFreqWindow = new HashMap<>();\\n            for (int i = round; i + wordsTotalLength - 1 < s.length(); i += wordLength) {\\n                while (j - i + 1 <= wordsTotalLength) { \\n                    String word = s.substring(j - wordLength + 1, j + 1);\\n                    wordToFreqWindow.put(word, wordToFreqWindow.getOrDefault(word, 0) + 1);\\n                    j += wordLength;\\n                }\\n\\n                if (wordToFreqWindow.equals(wordToFreqWords)) startIndices.add(i);\\n                \\n                String word = s.substring(i, i + wordLength);\\n                wordToFreqWindow.put(word, wordToFreqWindow.getOrDefault(word, 0) - 1);\\n                if (wordToFreqWindow.get(word) == 0) wordToFreqWindow.remove(word);\\n            }\\n        }\\n        \\n        return startIndices;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13766,
                "title": "very-very-straightforward-python-solution",
                "content": "When we saw this problem at the first sight, we can come up with `O(n*k)` solution easily. That is, for every position `s[i]`, we check that whether the `k` words is `s[i:i + k*length)]`. But unfortunately it got TLE.\\n\\nAnd then we found that there are a lot of situations we calculated duplicately. If we use the result we have calculated, it would be faster. Based on above thought, we have solution below.\\n\\n    class Solution(object):\\n        '''\\n        Variables:\\n          - window:    words queue appeared in order.\\n          - localCout:     appeared times of each word in current window.\\n    \\n        Processing:\\n          - if current word is not in `words`, then we should re-start calculating from\\n            next word.\\n          - if current word is in `words` and it's appeared times beyond that in `words`,\\n            then we should set the left boundary of `window` to position next to that in\\n            which current word appeared the first time.\\n          - if the length of window equals to that of `words`, then we get one pefect\\n            position.\\n        '''\\n        def findSubstring(self, s, words):\\n            n, m, r = len(words), len(words[0]) if words else 0, []\\n            counter = collections.Counter(words)\\n    \\n            for i in xrange(m):\\n                localCout = collections.defaultdict(int)\\n                window = collections.deque()\\n    \\n                for j in xrange(i, len(s), m):\\n                    word = s[j:j + m]\\n                    if word in counter:\\n                        localCout[word] += 1\\n                        window.append(word)\\n    \\n                        while localCout[word] > counter[word]:\\n                            localCout[window.popleft()] -= 1\\n    \\n                        if len(window) == n:\\n                            r.append(j - (n - 1) * m)\\n                    else:\\n                        localCout.clear()\\n                        window.clear()\\n            return r",
                "solutionTags": [
                    "Python"
                ],
                "code": "When we saw this problem at the first sight, we can come up with `O(n*k)` solution easily. That is, for every position `s[i]`, we check that whether the `k` words is `s[i:i + k*length)]`. But unfortunately it got TLE.\\n\\nAnd then we found that there are a lot of situations we calculated duplicately. If we use the result we have calculated, it would be faster. Based on above thought, we have solution below.\\n\\n    class Solution(object):\\n        '''\\n        Variables:\\n          - window:    words queue appeared in order.\\n          - localCout:     appeared times of each word in current window.\\n    \\n        Processing:\\n          - if current word is not in `words`, then we should re-start calculating from\\n            next word.\\n          - if current word is in `words` and it's appeared times beyond that in `words`,\\n            then we should set the left boundary of `window` to position next to that in\\n            which current word appeared the first time.\\n          - if the length of window equals to that of `words`, then we get one pefect\\n            position.\\n        '''\\n        def findSubstring(self, s, words):\\n            n, m, r = len(words), len(words[0]) if words else 0, []\\n            counter = collections.Counter(words)\\n    \\n            for i in xrange(m):\\n                localCout = collections.defaultdict(int)\\n                window = collections.deque()\\n    \\n                for j in xrange(i, len(s), m):\\n                    word = s[j:j + m]\\n                    if word in counter:\\n                        localCout[word] += 1\\n                        window.append(word)\\n    \\n                        while localCout[word] > counter[word]:\\n                            localCout[window.popleft()] -= 1\\n    \\n                        if len(window) == n:\\n                            r.append(j - (n - 1) * m)\\n                    else:\\n                        localCout.clear()\\n                        window.clear()\\n            return r",
                "codeTag": "Java"
            },
            {
                "id": 3188059,
                "title": "c-sliding-window-hash-map-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is store the words in a map and then check in string s if the words are present in a particular window or not if yes thwn push the index in ans vector else move to next window.\\nSo here window size = m*p \\nwhere m=words.size() , p=words[0].size();\\nSo if we check each  window of this size in s whther the words are present or not.\\nWe can have a map that will check the occurence of word in s = occurence in words vector. So if there is some word in s in a particular window which is not present in words vector that window is invalid, we will move to next window and check for the same again . If all the words are presnet then push the starting index of window in the answer vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n*m*p)-(m*p)^2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*p)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        map<string,int>mp;\\n        int ws=words.size();\\n        int wsz=words[0].size();\\n        for(auto w:words)mp[w]++;\\n        int window=ws*wsz;\\n        vector<int>ans;\\n        for(int i=0;i<s.size()-window+1;i++){\\n           unordered_map<string,int>seen;\\n           bool f=true;\\n           for(int j=0;j<ws;j++){\\n              string t=s.substr(i+j*wsz,wsz);\\n               seen[t]++;\\n               if(seen[t]>mp[t]){\\n                   f=false;\\n                   break;\\n               }\\n           }\\n           if(f)\\n           ans.push_back(i);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        map<string,int>mp;\\n        int ws=words.size();\\n        int wsz=words[0].size();\\n        for(auto w:words)mp[w]++;\\n        int window=ws*wsz;\\n        vector<int>ans;\\n        for(int i=0;i<s.size()-window+1;i++){\\n           unordered_map<string,int>seen;\\n           bool f=true;\\n           for(int j=0;j<ws;j++){\\n              string t=s.substr(i+j*wsz,wsz);\\n               seen[t]++;\\n               if(seen[t]>mp[t]){\\n                   f=false;\\n                   break;\\n               }\\n           }\\n           if(f)\\n           ans.push_back(i);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568181,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.*\\nAlso you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\n\\nhttps://www.youtube.com/watch?v=JbCcTa7vyBE\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\\n**JAVA**(Copied)\\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**PYTHON**((Copied)\\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```**Please Don\\'t forget to UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450785,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.*\\nAlso you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\n\\nhttps://www.youtube.com/watch?v=JbCcTa7vyBE\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\\n**JAVA**(Copied)\\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**PYTHON**((Copied)\\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```**Please Don\\'t forget to UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279986,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v1;\\n       \\n        int n=words.size();\\n        int len=words[0].length();\\n        int k=n*len;\\n       if(s.length()<k)return v1;\\n        unordered_map <string,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        for(int i=0;i<=s.length()-k;i++)\\n        {\\n            \\n            int count=n;\\n            int st=i;\\n            unordered_map<string,int> mp1;\\n            while(count)\\n            {\\n               \\n                string s1=s.substr(st,len);\\n                mp1[s1]++;\\n                if(mp.find(s1)!=mp.end() && mp[s1]>=mp1[s1])\\n                {\\n                    count--;\\n                    st+=len;\\n                }\\n                else break;\\n                \\n            }\\n            if(count==0)\\n            {\\n                v1.push_back(i);\\n                \\n            }\\n           \\n        }\\n        return v1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v1;\\n       \\n        int n=words.size();\\n        int len=words[0].length();\\n        int k=n*len;\\n       if(s.length()<k)return v1;\\n        unordered_map <string,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 457214,
                "title": "python-easy-sliding-window-solution-with-explanation",
                "content": "The intuition of this problem is using sliding window concept, because apparently we are looking for a ***substring*** having some particular pattern.\\n\\nWe then introduce a counter to represent this pattern - how many does each word should have in this particular range of substring? To do so, we remove the word from the counter if it is in the sliding window, and when the window size equals the total characters in `words` list (`wordlen * nwords`), we append the left index into the answer list if all values in the counters is `0`.\\n\\nLastly, we need to do this process for `wordlen` times, such that each character in string `s` can be iterated over as a start index.\\n\\n``` python\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not words or not s:\\n            return []\\n        \\n        wordlen, nwords = len(words[0]), len(words)\\n        indices = []\\n        \\n\\t\\t# iterative over `wordlen` times\\n        for i in range(wordlen):\\n            counter = collections.Counter(words)\\n\\t\\t\\t# start index of sliding window left and right pointer\\n            l = r = i\\n            while r + wordlen <= len(s):\\n\\t\\t\\t    # remove the substring from the counter\\n                counter[s[r:r+wordlen]] -= 1\\n                r += wordlen\\n\\t\\t\\t\\t# move left pointer one word offset to the right once the window size exceeds\\n                if r - l > wordlen * nwords:\\n                    counter[s[l:l+wordlen]] += 1\\n                    l += wordlen\\n\\t\\t\\t\\t# if the window size is what we want and we found that all values in counter are 0\\n\\t\\t\\t\\t# we can make sure that the substring in this window is one of the answer\\n\\t\\t\\t\\t# we are looking for\\n                if r - l == wordlen * nwords and all(count == 0 for count in counter.values()):\\n                    indices.append(l)\\n        \\n        return indices\\n            \\n```\\n\\nThe time complexity is `O(NL + WL)` where `N` is length of input string `s`, `L` is the word length, and `W` is the number of words in the `words` list.",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not words or not s:\\n            return []\\n        \\n        wordlen, nwords = len(words[0]), len(words)\\n        indices = []\\n        \\n\\t\\t# iterative over `wordlen` times\\n        for i in range(wordlen):\\n            counter = collections.Counter(words)\\n\\t\\t\\t# start index of sliding window left and right pointer\\n            l = r = i\\n            while r + wordlen <= len(s):\\n\\t\\t\\t    # remove the substring from the counter\\n                counter[s[r:r+wordlen]] -= 1\\n                r += wordlen\\n\\t\\t\\t\\t# move left pointer one word offset to the right once the window size exceeds\\n                if r - l > wordlen * nwords:\\n                    counter[s[l:l+wordlen]] += 1\\n                    l += wordlen\\n\\t\\t\\t\\t# if the window size is what we want and we found that all values in counter are 0\\n\\t\\t\\t\\t# we can make sure that the substring in this window is one of the answer\\n\\t\\t\\t\\t# we are looking for\\n                if r - l == wordlen * nwords and all(count == 0 for count in counter.values()):\\n                    indices.append(l)\\n        \\n        return indices\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417915,
                "title": "java-very-easy-hashmap-graphical-representation-algorithm-explanation",
                "content": "# Please Upvote\\n\\n**Algorithm**\\n\\n1. Initialize some variables:\\n\\n* n as the length of s.\\n* k as the length of words\\n* wordLength as the length of each word in words.\\n* substringSize as wordLength * k, which represents the size of each valid substring.\\n* wordCount as a hash table that tracks how many times a word occurs in words.\\n\\n\\n2. Create a function check that takes a starting index i and returns if a valid substring starts at index i:\\n\\n* Create a copy of wordCount to make use of for this particular index. Let\\'s call it remaining. Also, initialize an integer wordsUsed which tracks how many matches we have found so far.\\n* Iterate starting from i. Iterate until i + substringSize - we know that each valid substring will have this size, so we don\\'t need to go further. At each iteration, we will be checking for a word - and we know each word has a length of wordLength, so increment by wordLength each time.\\n* If the variable we are iterating with is j, then at each iteration, check for a word sub = s.substring(j, j + wordLength).\\n* If sub is in remaining and has a value greater than 0, then decrease its count by 1 and increase wordsUsed by 1. Otherwise, break out of the loop.\\n* At the end of it all, if wordsUsed == k, that means we used up all the words in words and have found a valid substring. Return true if so, false otherwise.\\n\\n3. Now that we have this function check, we can just check all possible starting indices. Because a valid substring has a length of substringSize, we only need to iterate up to n - substringSize. Build an array with all indices that pass check and return it.\\n\\n![image](https://assets.leetcode.com/users/images/87443bc5-0518-4085-810e-61a19a102871_1660365761.2647388.png)\\n\\n**CODE**\\n\\n```\\nclass Solution {\\n    private HashMap<String, Integer> wordCount = new HashMap<String, Integer>();\\n    private int wordLength;\\n    private int substringSize;\\n    private int k;\\n    \\n    private boolean check(int i, String s) {\\n        // Copy the original dictionary to use for this index\\n        HashMap<String, Integer> remaining = new HashMap<>(wordCount);\\n        int wordsUsed = 0;\\n        \\n        // Each iteration will check for a match in words\\n        for (int j = i; j < i + substringSize; j += wordLength) {\\n            String sub = s.substring(j, j + wordLength);\\n            if (remaining.getOrDefault(sub, 0) != 0) {\\n                remaining.put(sub, remaining.get(sub) - 1);\\n                wordsUsed++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return wordsUsed == k;\\n    }\\n    \\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int n = s.length();\\n        k = words.length;\\n        wordLength = words[0].length();\\n        substringSize = wordLength * k;\\n        \\n        for (String word : words) {\\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        List<Integer> answer = new ArrayList<>();\\n        for (int i = 0; i < n - substringSize + 1; i++) {\\n            if (check(i, s)) {\\n                answer.add(i);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private HashMap<String, Integer> wordCount = new HashMap<String, Integer>();\\n    private int wordLength;\\n    private int substringSize;\\n    private int k;\\n    \\n    private boolean check(int i, String s) {\\n        // Copy the original dictionary to use for this index\\n        HashMap<String, Integer> remaining = new HashMap<>(wordCount);\\n        int wordsUsed = 0;\\n        \\n        // Each iteration will check for a match in words\\n        for (int j = i; j < i + substringSize; j += wordLength) {\\n            String sub = s.substring(j, j + wordLength);\\n            if (remaining.getOrDefault(sub, 0) != 0) {\\n                remaining.put(sub, remaining.get(sub) - 1);\\n                wordsUsed++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return wordsUsed == k;\\n    }\\n    \\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int n = s.length();\\n        k = words.length;\\n        wordLength = words[0].length();\\n        substringSize = wordLength * k;\\n        \\n        for (String word : words) {\\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        List<Integer> answer = new ArrayList<>();\\n        for (int i = 0; i < n - substringSize + 1; i++) {\\n            if (check(i, s)) {\\n                answer.add(i);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417431,
                "title": "daily-leetcoding-challenge-august-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/substring-with-concatenation-of-all-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Check All Indices Using a Hash Table\n\n  \n**Approach 2:** Sliding Window\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/substring-with-concatenation-of-all-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1931775,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(unordered_map<string, int> hash, string current, int wordSize){\\n        for(int i = 0; i < current.size(); i += wordSize){\\n            string word = current.substr(i, wordSize);\\n            \\n            if(!hash[word]) return false;\\n            hash[word]--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int size = words[0].size() * words.size();\\n        vector<int> result;\\n        unordered_map<string, int> hash;\\n        \\n        if(s.size() < size) return {};\\n    \\n        for(string word : words) hash[word]++;\\n        \\n        for(int i = 0; i <= s.size() - size; i++){\\n            if(check(hash, s.substr(i, size), words[0].size()))\\n                result.push_back(i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Please upvote if this solution helped**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(unordered_map<string, int> hash, string current, int wordSize){\\n        for(int i = 0; i < current.size(); i += wordSize){\\n            string word = current.substr(i, wordSize);\\n            \\n            if(!hash[word]) return false;\\n            hash[word]--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int size = words[0].size() * words.size();\\n        vector<int> result;\\n        unordered_map<string, int> hash;\\n        \\n        if(s.size() < size) return {};\\n    \\n        for(string word : words) hash[word]++;\\n        \\n        for(int i = 0; i <= s.size() - size; i++){\\n            if(check(hash, s.substr(i, size), words[0].size()))\\n                result.push_back(i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224626,
                "title": "c-solution-with-comments",
                "content": "```\\n#include <unordered_map>\\n#include <stdio.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordLength = wordLength = words[0].length(); //each word in the words vector is the same length, so we can just check the first entry. Normally I would check the size of the vector before writing a line of code like this to prevent a seg fault, but the conditions of this test gauruntee the vector size will be at least 1 or greater\\n        int numberOfWords = words.size();\\n        vector<int> resultIndices; //we\\'ll use this to store the results that this function will return\\n        \\n        //copy the vector of words into an unordered_map. This map will contain a count of how many times that word appears in the words vector\\n        unordered_map<string, int> wordBankMap;\\n        for (int i = 0; i < words.size(); i++) {\\n            if (wordBankMap.find(words[i]) == wordBankMap.end()) {\\n                wordBankMap[words[i]] = 1; //if it\\'s the first time this string has been added, set the counter to 1\\n            }\\n            else {\\n                wordBankMap[words[i]] = wordBankMap[words[i]] + 1; //otherwise, increment the counter, because the vector of words can contain repeated words\\n            }\\n        }\\n        \\n        \\n        /*this is a simple check to return nothing in the case that the \"s\" string is not\\n        sufficiently long enough to check for a concatenation of the words in the vector of words*/\\n        if (wordLength * numberOfWords > s.length()) {\\n            return resultIndices;\\n        }\\n        \\n        //iterate through the whole s string, a wordLength at a time\\n        for (int idx = 0; idx <= s.length() - (numberOfWords * wordLength); idx++) {\\n            unordered_map<string, int> wordsUsedMap;\\n            \\n            //now we\\'re checking a subset to see if it matches a concatenation of the words in the words vector\\n            for (int chunkIdx = idx; chunkIdx < idx + (numberOfWords * wordLength); chunkIdx += wordLength) {\\n                //check to see if that chunk matches a word in the vector of words\\n                if (wordBankMap.find(s.substr(chunkIdx, wordLength)) == wordBankMap.end()) { //in this case, it doesn\\'t match\\n                    break;\\n                }\\n                else if (wordsUsedMap.find(s.substr(chunkIdx, wordLength)) == wordsUsedMap.end()) { //in this case, the word exists in the wordBankMap, but it hasn\\'t been accounted for in our wordsUsedMap\\n                    wordsUsedMap[s.substr(chunkIdx, wordLength)] = 1; //assign the counter to 1\\n                }\\n                else { //in this case, there already has been at least 1 entry into the wordsUsedMap, so now we just increment the counter and check if we went past our allowed count\\n                    wordsUsedMap[s.substr(chunkIdx, wordLength)] = wordsUsedMap[s.substr(chunkIdx, wordLength)] + 1;\\n                    if (wordsUsedMap[s.substr(chunkIdx, wordLength)] > wordBankMap[s.substr(chunkIdx, wordLength)]) {\\n                        break; //we went past our allotted count, so we can break out of this loop and move on\\n                    }\\n                }\\n            }\\n            \\n            if (wordsUsedMap == wordBankMap) { //if what was used matches what\\'s in the word bank, we have a winner!\\n                resultIndices.push_back(idx); //add to the results\\n            }\\n        }\\n        \\n        return resultIndices;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <unordered_map>\\n#include <stdio.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordLength = wordLength = words[0].length(); //each word in the words vector is the same length, so we can just check the first entry. Normally I would check the size of the vector before writing a line of code like this to prevent a seg fault, but the conditions of this test gauruntee the vector size will be at least 1 or greater\\n        int numberOfWords = words.size();\\n        vector<int> resultIndices; //we\\'ll use this to store the results that this function will return\\n        \\n        //copy the vector of words into an unordered_map. This map will contain a count of how many times that word appears in the words vector\\n        unordered_map<string, int> wordBankMap;\\n        for (int i = 0; i < words.size(); i++) {\\n            if (wordBankMap.find(words[i]) == wordBankMap.end()) {\\n                wordBankMap[words[i]] = 1; //if it\\'s the first time this string has been added, set the counter to 1\\n            }\\n            else {\\n                wordBankMap[words[i]] = wordBankMap[words[i]] + 1; //otherwise, increment the counter, because the vector of words can contain repeated words\\n            }\\n        }\\n        \\n        \\n        /*this is a simple check to return nothing in the case that the \"s\" string is not\\n        sufficiently long enough to check for a concatenation of the words in the vector of words*/\\n        if (wordLength * numberOfWords > s.length()) {\\n            return resultIndices;\\n        }\\n        \\n        //iterate through the whole s string, a wordLength at a time\\n        for (int idx = 0; idx <= s.length() - (numberOfWords * wordLength); idx++) {\\n            unordered_map<string, int> wordsUsedMap;\\n            \\n            //now we\\'re checking a subset to see if it matches a concatenation of the words in the words vector\\n            for (int chunkIdx = idx; chunkIdx < idx + (numberOfWords * wordLength); chunkIdx += wordLength) {\\n                //check to see if that chunk matches a word in the vector of words\\n                if (wordBankMap.find(s.substr(chunkIdx, wordLength)) == wordBankMap.end()) { //in this case, it doesn\\'t match\\n                    break;\\n                }\\n                else if (wordsUsedMap.find(s.substr(chunkIdx, wordLength)) == wordsUsedMap.end()) { //in this case, the word exists in the wordBankMap, but it hasn\\'t been accounted for in our wordsUsedMap\\n                    wordsUsedMap[s.substr(chunkIdx, wordLength)] = 1; //assign the counter to 1\\n                }\\n                else { //in this case, there already has been at least 1 entry into the wordsUsedMap, so now we just increment the counter and check if we went past our allowed count\\n                    wordsUsedMap[s.substr(chunkIdx, wordLength)] = wordsUsedMap[s.substr(chunkIdx, wordLength)] + 1;\\n                    if (wordsUsedMap[s.substr(chunkIdx, wordLength)] > wordBankMap[s.substr(chunkIdx, wordLength)]) {\\n                        break; //we went past our allotted count, so we can break out of this loop and move on\\n                    }\\n                }\\n            }\\n            \\n            if (wordsUsedMap == wordBankMap) { //if what was used matches what\\'s in the word bank, we have a winner!\\n                resultIndices.push_back(idx); //add to the results\\n            }\\n        }\\n        \\n        return resultIndices;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13791,
                "title": "my-24ms-c-solution-o-n-time-using-an-unordered-map",
                "content": "We can leverage the fact that the strings in words have the same length to speed up our algorithm. We can divide all the possible starting points (i.e. 0..sLen-1) into wordL sequences and the i-th sequence is \\n(i, i+wordL, i+2*wordL, ...) (I=0..wordL-1). Each time we scan one sequence (for j loop). First, we need to build a dictionary based on words and unordered_map is used to simplify look-up operation (key is string, value is count). Then for each sequence starting at i, we check if s[i..i+wordL-1] is a word in dict, if no (which means it is not a word in words), then we reset count (the number of words we found in the current window starting at start), and move start to i+wordL to skip the current word and also we need to recover dict. If s[i..i+wordL-1] is a word in dict, then we check if we already found all such words before in the current window (i.e. --dict[s.substr(i, wordL)] < 0). If so, the current one is a redundant one, then we have to move forward start to remove one occurence of the current word (i.e. to make dict[s.substr(i, wordL)] == 0) so that the current word can be included in the window. We also need to update count accordingly. If we find all the words in the current window ( i.e. (++count == wSize)), then we save start to res and move start to remove one occurence of the current word to continue the search. \\nWe repeat the above process for each word sequence (i.e. each i). remember after each i iteration, we need to recover dict(map).\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            unordered_map<string, int> map;\\n            int i, wSize = words.size(), wL=words[0].size(), start, cur, sL=s.size(), wCnt;\\n            vector<int> res;\\n            if(sL<wL*wSize) return res;\\n            \\n            //build the map\\n            for(i=0; i<wSize; ++i)\\n                map[words[i]] = map.count(words[i])>0? ++map[words[i]]:1;\\n                \\n            for(i=0; i<wL; ++i)\\n            {// go through each possible starting point sequences\\n                start = cur = i; // start is the starting point of the current search window, cur is the end of the current search window\\n                wCnt = wSize; // reset the words to be searched\\n                while(start<=sL-wL*wSize)\\n                { // if it is a valid start\\n                    if(map.count(s.substr(cur,wL))==0){// if the current word is not one in the map, then move the starting window to the next word positon, reset wCnt and recover map counts.\\n                            for(wCnt = wSize; start!=cur; start+=wL) ++map[s.substr(start,wL)];\\n                            start +=wL; //skip the current invalid word;\\n                    }\\n                    else if(map[s.substr(cur,wL)]==0){\\n                     // if the current word is a valid word in the map, but it is already found in the current search window, then we have to move start to skip the previously found one, and update wCnt and map counts accordingly.\\n                        for(;s.substr(cur,wL)!=s.substr(start,wL); start+=wL)\\n                        {\\n                            ++map[s.substr(start,wL)];\\n                            ++wCnt;\\n                        }\\n                        start += wL;//skip the previously found one\\n                    }\\n                    else{\\n                    // if the current word is a valid one and it is not found before in the current search window\\n                        --map[s.substr(cur,wL)]; // then reduce its counter\\n                        if(--wCnt == 0) { // update wCnt, if we find all the words\\n                            res.push_back(start); // save start\\n                            ++map[s.substr(start,wL)]; //moving start to skip the first word in the current search window\\n                            start +=wL;\\n                            ++wCnt;\\n                        }\\n                    }\\n                    cur+=wL; // update cur\\n                }\\n                for(;start<cur;start+=wL)  ++map[s.substr(start,wL)];//reset the map count\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            unordered_map<string, int> map;\\n            int i, wSize = words.size(), wL=words[0].size(), start, cur, sL=s.size(), wCnt;\\n            vector<int> res;\\n            if(sL<wL*wSize) return res;\\n            \\n            //build the map\\n            for(i=0; i<wSize; ++i)\\n                map[words[i]] = map.count(words[i])>0? ++map[words[i]]:1;\\n                \\n            for(i=0; i<wL; ++i)\\n            {// go through each possible starting point sequences\\n                start = cur = i; // start is the starting point of the current search window, cur is the end of the current search window\\n                wCnt = wSize; // reset the words to be searched\\n                while(start<=sL-wL*wSize)\\n                { // if it is a valid start\\n                    if(map.count(s.substr(cur,wL))==0){// if the current word is not one in the map, then move the starting window to the next word positon, reset wCnt and recover map counts.\\n                            for(wCnt = wSize; start!=cur; start+=wL) ++map[s.substr(start,wL)];\\n                            start +=wL; //skip the current invalid word;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1859027,
                "title": "c-solution-with-full-explanations-including-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We have to find all the permutations of words present in a fix size string,\\n- The possible size is the ***(length of any word * size of words).***\\n- If the given string has a size less than ***(length of any word * size of words),*** simply return ans.\\n- If not then put given words into an unordered map `unordered_map<string, int> mp`\\n- Now in the next loop, we\\u2019ll iterate elements from start till ***n-(len*size)*** & take another map to keep the word track of the current substring.\\n- In the next loop, we took the string that can be the ans. we\\u2019re keeping the words in current & check if this is present in the given words, if not then break the loop.\\n- Else we keep track of this in another map, if any point current element value in the present map became greater than the given words map then break the loop.\\n- Finally, if both map matches then push the index to ans vector.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847319,
                "title": "javascript-using-sliding-window",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n    let totalCharCount = 0\\n    let map = new Map()\\n    \\n    let wordLength = words[0].length\\n    let wordCount = words.length\\n    \\n    let slideWindow = wordLength * wordCount\\n    \\n    for (let word of words) {\\n        map.has(word) ? map.set(word, map.get(word) + 1) : map.set(word, 1)\\n    }\\n    \\n    let leftIndex = 0\\n    let rightIndex = slideWindow - 1\\n    let result = []\\n    \\n    const helper = (tempStr) => {\\n        let visited = new Map()\\n        \\n        for (let i = 0; i < tempStr.length; i+= wordLength) {\\n            let word = tempStr.substr(i, wordLength)\\n            \\n            visited.has(word) ? visited.set(word, visited.get(word) + 1) : visited.set(word, 1)\\n        }\\n        \\n        for (let [key, val] of visited) {\\n            if (map.get(key) != val) return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    while (rightIndex < s.length) {\\n        \\n        if (rightIndex - leftIndex + 1 == slideWindow) {\\n            let tempStr = s.substring(leftIndex, rightIndex + 1)\\n            \\n            if (helper(tempStr)) result.push(leftIndex)\\n            \\n            leftIndex++\\n        }\\n        \\n        \\n        rightIndex++\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n    let totalCharCount = 0\\n    let map = new Map()\\n    \\n    let wordLength = words[0].length\\n    let wordCount = words.length\\n    \\n    let slideWindow = wordLength * wordCount\\n    \\n    for (let word of words) {\\n        map.has(word) ? map.set(word, map.get(word) + 1) : map.set(word, 1)\\n    }\\n    \\n    let leftIndex = 0\\n    let rightIndex = slideWindow - 1\\n    let result = []\\n    \\n    const helper = (tempStr) => {\\n        let visited = new Map()\\n        \\n        for (let i = 0; i < tempStr.length; i+= wordLength) {\\n            let word = tempStr.substr(i, wordLength)\\n            \\n            visited.has(word) ? visited.set(word, visited.get(word) + 1) : visited.set(word, 1)\\n        }\\n        \\n        for (let [key, val] of visited) {\\n            if (map.get(key) != val) return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    while (rightIndex < s.length) {\\n        \\n        if (rightIndex - leftIndex + 1 == slideWindow) {\\n            let tempStr = s.substring(leftIndex, rightIndex + 1)\\n            \\n            if (helper(tempStr)) result.push(leftIndex)\\n            \\n            leftIndex++\\n        }\\n        \\n        \\n        rightIndex++\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 484588,
                "title": "python-3-three-lines-counter",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, S: str, W: List[str]) -> List[int]:\\n        if not W: return []\\n        LS, M, N, C = len(S), len(W), len(W[0]), collections.Counter(W)\\n        return [i for i in range(LS-M*N+1) if collections.Counter([S[a:a+N] for a in range(i,i+M*N,N)]) == C]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, S: str, W: List[str]) -> List[int]:\\n        if not W: return []\\n        LS, M, N, C = len(S), len(W), len(W[0]), collections.Counter(W)\\n        return [i for i in range(LS-M*N+1) if collections.Counter([S[a:a+N] for a in range(i,i+M*N,N)]) == C]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 2417993,
                "title": "c-use-hashmap-easy-and-efficient-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n        vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size(); // each word has the same length;\\n        int t = m*n;\\n        \\n        if(s.size() < t) return res;\\n        \\n        unordered_map<string, int> freq;\\n            \\n        for(auto it:words)\\n            freq[it]++;\\n        \\n        for(int i=0; i<=s.size()-t; i++)\\n        {\\n            unordered_map<string, int> mp = freq;\\n            \\n            int j;\\n            for(j=0; j<s.size(); j++)\\n            {\\n                string temp = s.substr(i+j*m, m); //create string of size m and starting index i+j*m\\n                \\n                if(mp[temp]==0)\\n                    break;\\n                else\\n                    mp[temp]--;\\n            }\\n            if(j==n) //check whether all word in words are in the string or not \\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n        vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size(); // each word has the same length;\\n        int t = m*n;\\n        \\n        if(s.size() < t) return res;\\n        \\n        unordered_map<string, int> freq;\\n            \\n        for(auto it:words)\\n            freq[it]++;\\n        \\n        for(int i=0; i<=s.size()-t; i++)\\n        {\\n            unordered_map<string, int> mp = freq;\\n            \\n            int j;\\n            for(j=0; j<s.size(); j++)\\n            {\\n                string temp = s.substr(i+j*m, m); //create string of size m and starting index i+j*m\\n                \\n                if(mp[temp]==0)\\n                    break;\\n                else\\n                    mp[temp]--;\\n            }\\n            if(j==n) //check whether all word in words are in the string or not \\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805387,
                "title": "sliding-window-intuitive-python-solution-with-counter",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        counter = collections.Counter(words)\\n        window_size = len(words) * word_len\\n        ans = []\\n        for i in range(len(s) - window_size + 1):\\n            temp = s[i:i+window_size]\\n            temp = [temp[j:j+word_len] for j in range(0, window_size, word_len)]\\n            if collections.Counter(temp) == counter:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        counter = collections.Counter(words)\\n        window_size = len(words) * word_len\\n        ans = []\\n        for i in range(len(s) - window_size + 1):\\n            temp = s[i:i+window_size]\\n            temp = [temp[j:j+word_len] for j in range(0, window_size, word_len)]\\n            if collections.Counter(temp) == counter:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345983,
                "title": "straightforward-python-solution",
                "content": "```\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n, num_words = len(s), len(words)\\n        if n == 0 or num_words == 0:\\n            return []\\n        count = collections.Counter(words)\\n        word_len = len(words[0])\\n        total_len = num_words * word_len\\n        res = []\\n        i = 0\\n        while i <= n - total_len:\\n            # determine whether s[i:i+total_len] is valid\\n            seen = collections.defaultdict(int)\\n            for j in range(i, i + total_len, word_len):\\n                w = s[j:j + word_len]\\n                if w in count:\\n                    seen[w] += 1\\n                    if seen[w] > count[w]:\\n                        break\\n                else:\\n                    break    \\n            if seen == count:\\n                res.append(i)\\n            i = i + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n, num_words = len(s), len(words)\\n        if n == 0 or num_words == 0:\\n            return []\\n        count = collections.Counter(words)\\n        word_len = len(words[0])\\n        total_len = num_words * word_len\\n        res = []\\n        i = 0\\n        while i <= n - total_len:\\n            # determine whether s[i:i+total_len] is valid\\n            seen = collections.defaultdict(int)\\n            for j in range(i, i + total_len, word_len):\\n                w = s[j:j + word_len]\\n                if w in count:\\n                    seen[w] += 1\\n                    if seen[w] > count[w]:\\n                        break\\n                else:\\n                    break    \\n            if seen == count:\\n                res.append(i)\\n            i = i + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 300985,
                "title": "c-99-9-beat-single-map-solution",
                "content": "The trick with using one single hash map... Instead of simply skipping on an invalid chunk, close out the existing window and THEN skip the chunk. It\\'s like matter and anti-matter. Your dictionary must always be accurate.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        vector <int> aResult;\\n        \\n        int aWordCount = words.size();\\n        if (aWordCount <= 0) { return aResult; }\\n        \\n        int aLen = words[0].size();\\n        if (aLen <= 0 || aLen > s.size()) { return aResult; }\\n        \\n        int aKeySize = aWordCount * aLen;\\n        if (aKeySize > s.size()) { return aResult; }\\n        \\n        unordered_map <string, int> aDic;\\n        for (auto aWord : words) { aDic[aWord]++; }\\n        \\n        int aCap = s.size() - aKeySize;\\n        \\n        //Start index of sliding window. Our stride will be aLen.\\n        for (int i=0;i<aLen;i++) {\\n            \\n            int aFront = i;\\n            int aRear = i;\\n            \\n            while (aFront <= aCap) {\\n                \\n                string aChunk = s.substr(aRear, aLen);\\n                \\n                if (aDic.find(aChunk) == aDic.end()) {\\n                    \\n                    //Close the front of the sliding window.\\n                    while (aFront < aRear) {\\n                        aDic[s.substr(aFront, aLen)]++;\\n                        aWordCount += 1;\\n                        aFront += aLen;\\n                    }\\n                    \\n                    //Advance past the current rear.\\n                    aRear += aLen;\\n                    aFront = aRear;\\n                    \\n                    continue;\\n                }\\n                \\n                if (aDic[aChunk] > 0) {\\n                    //We need to eliminate more of this word to match-all\\n                    aDic[aChunk]--;\\n                    aWordCount -= 1;\\n                    if (aWordCount == 0) {\\n                        aResult.push_back(aFront);\\n                    }\\n                    aRear += aLen;\\n                } else {\\n                    //We have too many of this word, advance the front of the window...\\n                    aDic[s.substr(aFront, aLen)]++;\\n                    aWordCount += 1;\\n                    aFront += aLen;\\n                }\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nProps to the original solution provider. I have simply learned this from studying them. \\n\\nStill not 100% sure why we KNOW that we can ADVANCE the FRONT of the sliding window when (aDic[aChunk] <= 0)\\n\\nSeems like Harry Potter sorcery and wizard magic to me.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        vector <int> aResult;\\n        \\n        int aWordCount = words.size();\\n        if (aWordCount <= 0) { return aResult; }\\n        \\n        int aLen = words[0].size();\\n        if (aLen <= 0 || aLen > s.size()) { return aResult; }\\n        \\n        int aKeySize = aWordCount * aLen;\\n        if (aKeySize > s.size()) { return aResult; }\\n        \\n        unordered_map <string, int> aDic;\\n        for (auto aWord : words) { aDic[aWord]++; }\\n        \\n        int aCap = s.size() - aKeySize;\\n        \\n        //Start index of sliding window. Our stride will be aLen.\\n        for (int i=0;i<aLen;i++) {\\n            \\n            int aFront = i;\\n            int aRear = i;\\n            \\n            while (aFront <= aCap) {\\n                \\n                string aChunk = s.substr(aRear, aLen);\\n                \\n                if (aDic.find(aChunk) == aDic.end()) {\\n                    \\n                    //Close the front of the sliding window.\\n                    while (aFront < aRear) {\\n                        aDic[s.substr(aFront, aLen)]++;\\n                        aWordCount += 1;\\n                        aFront += aLen;\\n                    }\\n                    \\n                    //Advance past the current rear.\\n                    aRear += aLen;\\n                    aFront = aRear;\\n                    \\n                    continue;\\n                }\\n                \\n                if (aDic[aChunk] > 0) {\\n                    //We need to eliminate more of this word to match-all\\n                    aDic[aChunk]--;\\n                    aWordCount -= 1;\\n                    if (aWordCount == 0) {\\n                        aResult.push_back(aFront);\\n                    }\\n                    aRear += aLen;\\n                } else {\\n                    //We have too many of this word, advance the front of the window...\\n                    aDic[s.substr(aFront, aLen)]++;\\n                    aWordCount += 1;\\n                    aFront += aLen;\\n                }\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166076,
                "title": "python-3-solution-with-explanation",
                "content": "Might not be the most effiecent solution but easy to understand and explained\\n\\n```\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        # the solution should be appended in the below list\\n        result = []\\n        \\n        # ignoring any action if the string or the list of words has 0 length\\n        if len(s) == 0 or len(words) == 0:\\n            return result\\n        \\n        from collections import Counter\\n        \\n        word_length = len(words[0])\\n        words_count = len(words)\\n        \\n        # the window size that we are going to slide\\n        window_length = words_count * word_length\\n   \\n        # temp list to store splitted window size part of the string \\n        temp = []\\n   \\n        # checking from 0 till word length before the sting end   \\n        for i in range(0,len(s) - window_length + 1):\\n            # the sliding window from the string to be checked against the words\\n            word_window = s[i:i + window_length]\\n            # splitting the window string to a list of splitted words\\n            temp = [word_window[j:j+word_length] for j in range(0, window_length, word_length)]\\n            # checking if the splitted words and original words are the same\\n            if Counter(temp) == Counter(words):\\n                # append the value of i which is the index of the first letter in the sliding window\\n                result.append(i)\\n    \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        # the solution should be appended in the below list\\n        result = []\\n        \\n        # ignoring any action if the string or the list of words has 0 length\\n        if len(s) == 0 or len(words) == 0:\\n            return result\\n        \\n        from collections import Counter\\n        \\n        word_length = len(words[0])\\n        words_count = len(words)\\n        \\n        # the window size that we are going to slide\\n        window_length = words_count * word_length\\n   \\n        # temp list to store splitted window size part of the string \\n        temp = []\\n   \\n        # checking from 0 till word length before the sting end   \\n        for i in range(0,len(s) - window_length + 1):\\n            # the sliding window from the string to be checked against the words\\n            word_window = s[i:i + window_length]\\n            # splitting the window string to a list of splitted words\\n            temp = [word_window[j:j+word_length] for j in range(0, window_length, word_length)]\\n            # checking if the splitted words and original words are the same\\n            if Counter(temp) == Counter(words):\\n                # append the value of i which is the index of the first letter in the sliding window\\n                result.append(i)\\n    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643371,
                "title": "explained-simple-and-clear-python3-code",
                "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306644,
                "title": "c-with-explanation",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach (Gives TLE)\\n- The function first initializes an empty vector **a** to store the starting indices of the substrings. It then calculates the length **n** of each word in the vector **words**, sorts the vector **words**, and calculates the total length **N** of all the words combined.\\n- The function then loops through each possible starting index **i** in **s** where a substring of length **N** can be formed. For each starting index, it uses a stringstream **ss** to concatenate substrings of length **n** starting from that index, until it has concatenated **N** characters.\\n- It then extracts the concatenated substrings from the stringstream **ss** and stores them in a vector **b**. The vector **b** is sorted and compared with the sorted vector **words**. If they are equal, it means that the substring is a concatenation of all the words in **words**, and its starting index is added to the vector **a**.\\n- If **b** is not equal to **words**, it means that the substring is not a concatenation of all the words in **words**, so the function moves to the next possible starting index by incrementing **i** by 1.\\n- Finally, the function returns the vector **a** containing all the starting indices of the substrings that are a concatenation of all the words in **words**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(len * NlogN)$$\\n    - The time complexity of this function is $$O(len * NlogN)$$, where **len** is the length of the input string **s** and **N** is the length of all the words combined.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n    - The space complexity is $$O(N)$$ for the vector **b**.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> a;\\n        int n = words.front().length();\\n        sort(words.begin(), words.end());\\n        int N = n * words.size();\\n        int len = s.length();\\n        for(int i = 0; i < len - N + 1;i++ ) {\\n            stringstream ss;\\n            for(int j = i; j < i + N; j += n) {\\n                string c = s.substr(j, n);\\n                ss << c;\\n            }\\n            vector<string> b;\\n            string str = ss.str();\\n            for(int k = 0; k < N; k += n) {\\n                b.push_back(str.substr(k, n));\\n            }\\n            sort(b.begin(), b.end());\\n            if(b == words) {\\n                a.push_back(i);  \\n            } \\n        }\\n        return a;\\n    }\\n};\\n```\\n\\n# 2nd Approach (Optimized):  Sliding Window with Hashing for Word Frequency\\n- Initialize an empty vector **result** to store the starting indices of valid concatenated substrings.\\n- Retrieve the length **n** of the input string **s** and the number of words **numWords** in the **words** array. If n is 0 or **numWords** is 0, return an empty **result** vector.\\n- Determine the length of each word **wordLen** by considering the length of the first word in the **words** array.\\n- Calculate the total length **totalLen** required for a valid concatenated substring (**totalLen = numWords * wordLen**).\\n- Create an unordered map **wordCount** to store the frequency count of each word in the **words** array.\\n- Iterate through the **words** array and update the frequency count of each word in the **wordCount** map.\\n- Begin the main loop from index 0 up to **wordLen - 1** (the length of each word).\\n- Initialize two pointers, **left** and **right**, both set to the current index of the loop.\\n- Initialize a variable **count** to keep track of the number of valid words in the current window.\\n- Create an unordered map **currentCount** to store the frequency count of words present in the current window.\\n- Enter a nested loop where **right** is iterated over the input string s using the condition **right + wordLen <= n.**\\n- Extract the **currentWord** of length **wordLen** starting from the index **right**.\\n- Increment **right** by **wordLen**.\\n- Check if **currentWord** is present in the **wordCount** map. If so, it is a valid word.\\n  - Increment the frequency count of **currentWord** in the **currentCount** map.\\n  - Increment the **count** variable.\\n  - If the frequency count of **currentWord** in **currentCount** exceeds its frequency count in **wordCount**, it means there are extra occurrences of the word. Move the **left** pointer and decrease the count and frequency until the extra occurrence is resolved.\\n  - If **count** becomes equal to **numWords**, it implies all required words are present in the current window. Add the **left** index to the **result** vector.\\n- If **currentWord** is not present in the **wordCount** map, reset **currentCount**, reset **count** to 0, and move the **left** pointer to **right**.\\n- Once the loop completes, return the **result** vector containing starting indices of valid concatenated substrings.\\n\\n\\n# Complexity\\n- Time complexity: $$O(len * wordLen)$$\\n    - where **len** is the length of the input string **s** and **wordLen** is the length of each word in the **words** array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(wordCount)$$\\n    - the space required for the **wordCount** and **currentCount** unordered maps.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> result;\\n        int n = s.length();\\n        int numWords = words.size();\\n        if (n == 0 || numWords == 0) {\\n            return result;\\n        }\\n        \\n        int wordLen = words[0].length();\\n        int totalLen = numWords * wordLen;\\n        unordered_map<string, int> wordCount; // Stores the count of each word\\n        \\n        for (const string& word : words) {\\n            wordCount[word]++;\\n        }\\n        \\n        for (int i = 0; i < wordLen; ++i) {\\n            int left = i, right = i, count = 0;\\n            unordered_map<string, int> currentCount; // Stores count of words in current window\\n            \\n            while (right + wordLen <= n) {\\n                string currentWord = s.substr(right, wordLen);\\n                right += wordLen;\\n                \\n                if (wordCount.find(currentWord) != wordCount.end()) {\\n                    currentCount[currentWord]++;\\n                    count++;\\n                    \\n                    while (currentCount[currentWord] > wordCount[currentWord]) {\\n                        string leftWord = s.substr(left, wordLen);\\n                        left += wordLen;\\n                        currentCount[leftWord]--;\\n                        count--;\\n                    }\\n                    \\n                    if (count == numWords) {\\n                        result.push_back(left);\\n                    }\\n                } else {\\n                    currentCount.clear();\\n                    count = 0;\\n                    left = right;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sort",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> a;\\n        int n = words.front().length();\\n        sort(words.begin(), words.end());\\n        int N = n * words.size();\\n        int len = s.length();\\n        for(int i = 0; i < len - N + 1;i++ ) {\\n            stringstream ss;\\n            for(int j = i; j < i + N; j += n) {\\n                string c = s.substr(j, n);\\n                ss << c;\\n            }\\n            vector<string> b;\\n            string str = ss.str();\\n            for(int k = 0; k < N; k += n) {\\n                b.push_back(str.substr(k, n));\\n            }\\n            sort(b.begin(), b.end());\\n            if(b == words) {\\n                a.push_back(i);  \\n            } \\n        }\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> result;\\n        int n = s.length();\\n        int numWords = words.size();\\n        if (n == 0 || numWords == 0) {\\n            return result;\\n        }\\n        \\n        int wordLen = words[0].length();\\n        int totalLen = numWords * wordLen;\\n        unordered_map<string, int> wordCount; // Stores the count of each word\\n        \\n        for (const string& word : words) {\\n            wordCount[word]++;\\n        }\\n        \\n        for (int i = 0; i < wordLen; ++i) {\\n            int left = i, right = i, count = 0;\\n            unordered_map<string, int> currentCount; // Stores count of words in current window\\n            \\n            while (right + wordLen <= n) {\\n                string currentWord = s.substr(right, wordLen);\\n                right += wordLen;\\n                \\n                if (wordCount.find(currentWord) != wordCount.end()) {\\n                    currentCount[currentWord]++;\\n                    count++;\\n                    \\n                    while (currentCount[currentWord] > wordCount[currentWord]) {\\n                        string leftWord = s.substr(left, wordLen);\\n                        left += wordLen;\\n                        currentCount[leftWord]--;\\n                        count--;\\n                    }\\n                    \\n                    if (count == numWords) {\\n                        result.push_back(left);\\n                    }\\n                } else {\\n                    currentCount.clear();\\n                    count = 0;\\n                    left = right;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233323,
                "title": "substring-with-concatenation-of-all-words",
                "content": "[https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/]()\\n[https://www.linkedin.com/in/shivansh-srivastava-cs/]()\\n# DO UPVOTE IF YOU FIND IT SUITABLE AND HELPFUL AND FOR ANY DOUBTS COMMENT.\\n# DO LIKE AS EACH VOTE COUNTS\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Refer and take the refernce from the find all anagrams and permutations in a string question of leetcode 438.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->  Sliding window + hashtable for each word in words list and then inside nested loop use substrcount each time new and compare for equivalence\\\\.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The first for-loop iterates over all words in the input list words and takes O(N) time where N is the number of words in the list.\\nThe second for-loop iterates over all substrings of length len(words)*len(words[0]) in the input string s. The number of substrings will be O(M) where M is the length of the input string. For each substring, the code creates a new dictionary substrcount and iterates over all words of length len(words[0]) in the substring. This takes O(len(substr)/len(words[0])) time for each substring. Therefore, the overall time complexity of the second for-loop is O(M * len(substr)/len(words[0])) = O(M*N), where N and M are defined as before.\\nThe dictionary operations (insertion, lookup) in the code take O(1) time.\\nThus, the overall time complexity of the code is O(M*N), where N is the number of words in the input list and M is the length of the input string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The code uses two dictionaries, wordcount and substrcount, to store word frequencies. The maximum size of each dictionary is N (the number of words in the input list).\\nThe code stores the input string s, which takes O(M) space.\\nThe code stores the result list result, which can take up to O(M/N) space in the worst case (when all substrings are valid).\\nThus, the overall space complexity of the code is O(M + N).\\n\\nIn summary, the time complexity of the given code is O(M*N) and the space complexity is O(M + N), where N is the number of words in the input list and M is the length of the input string.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wordcount={}\\n        for word in words:\\n            wordcount[word]=1+wordcount.get(word,0)\\n        result=[]\\n        substringlength=len(words)*len(words[0])\\n        for i in range(len(s)-substringlength+1):\\n            substr=s[i:i+substringlength]\\n            substrcount={}\\n            for j in range(0,len(substr),len(words[0])):\\n                word=substr[j:j+len(words[0])]\\n                substrcount[word]=1+substrcount.get(word,0)\\n            if substrcount==wordcount:\\n                result.append(i)\\n        return result\\n\\n#         m=\\'\\'.join(words)\\n#         pcount=dict()\\n#         scount=dict()\\n#         if len(m)>len(s):\\n#             print([])\\n#         for i in range(len(m)):\\n#                  pcount[m[i]]=1+pcount.get(m[i],0)\\n#                  scount[s[i]]=1+scount.get(s[i],0)\\n# # print(pcount)\\n# # print(scount)\\n#         res=[0]if pcount==scount else []\\n#         l=0\\n#         for i in range(len(m),len(s),1):\\n#               scount[s[i]]=1+scount.get(s[i],0)\\n#               scount[s[l]]-=1 \\n#               if scount[s[l]]==0:\\n#                   del scount[s[l]]\\n#               l+=1 \\n#               if scount==pcount:\\n#                 res.append(l)\\n# #@print(res)\\n#         return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wordcount={}\\n        for word in words:\\n            wordcount[word]=1+wordcount.get(word,0)\\n        result=[]\\n        substringlength=len(words)*len(words[0])\\n        for i in range(len(s)-substringlength+1):\\n            substr=s[i:i+substringlength]\\n            substrcount={}\\n            for j in range(0,len(substr),len(words[0])):\\n                word=substr[j:j+len(words[0])]\\n                substrcount[word]=1+substrcount.get(word,0)\\n            if substrcount==wordcount:\\n                result.append(i)\\n        return result\\n\\n#         m=\\'\\'.join(words)\\n#         pcount=dict()\\n#         scount=dict()\\n#         if len(m)>len(s):\\n#             print([])\\n#         for i in range(len(m)):\\n#                  pcount[m[i]]=1+pcount.get(m[i],0)\\n#                  scount[s[i]]=1+scount.get(s[i],0)\\n# # print(pcount)\\n# # print(scount)\\n#         res=[0]if pcount==scount else []\\n#         l=0\\n#         for i in range(len(m),len(s),1):\\n#               scount[s[i]]=1+scount.get(s[i],0)\\n#               scount[s[l]]-=1 \\n#               if scount[s[l]]==0:\\n#                   del scount[s[l]]\\n#               l+=1 \\n#               if scount==pcount:\\n#                 res.append(l)\\n# #@print(res)\\n#         return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103559,
                "title": "easy-and-commented-2-map-solution-with-example",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        unordered_map < string, int > map;\\n        int l = 0, r = 0 ,cnt = words.size(), len = words[0].size(), winSize = len * cnt;\\n        \\n        //checking if string size is enough or not\\n        if(winSize > s.size() )return {};\\n        \\n        // filling all words in map\\n        for(auto str: words) map[str]++;\\n        \\n        string str = \"\";\\n        vector<int> ans; //vector to store starting ind of valid substring\\n        \\n        // as all words are of len l so to check over all possibilities of combinations words can start from 0,1,..., len-1\\n        for(int i = 0; i < len; i++){\\n            \\n            ///l,r -> starting and ending indexes of window\\n            r = i, l = i;\\n            unordered_map<string ,int> map_s;\\n            \\n            while(r < s.size()){\\n                \\n                str = s.substr( r, len );\\n                cout<<str<<\" \";\\n                r += len;\\n                map_s[str]++;\\n                \\n                // maps are equal means cur substr in window is valid so storing starting index of it\\n                if(map_s == map) \\n                    ans.push_back( l );\\n                \\n                // minimising the window\\n                if( r-l == winSize ){\\n                    \\n                    string x = s.substr( l, len );\\n                    map_s[x]-- ;\\n                    \\n                    if(map_s[x] == 0) \\n                        map_s.erase(x);\\n                    //moving starting ptr of window to next position\\n                    l+=len;\\n                    \\n                }   \\n            }\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\n\\n`outer for loop from 0->len-1 , can be understood from this example `\\n\\nling mind rabo ofoo owin gdin gbar rwin gmon keyp ound cake \\ningm indr aboo fooo wing ding barr wing monk eypo undc ake \\nngmi ndra boof ooow ingd ingb arrw ingm onke ypou ndca ke \\ngmin drab oofo oowi ngdi ngba rrwi ngmo nkey poun dcak e \\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        unordered_map < string, int > map;\\n        int l = 0, r = 0 ,cnt = words.size(), len = words[0].size(), winSize = len * cnt;\\n        \\n        //checking if string size is enough or not\\n        if(winSize > s.size() )return {};\\n        \\n        // filling all words in map\\n        for(auto str: words) map[str]++;\\n        \\n        string str = \"\";\\n        vector<int> ans; //vector to store starting ind of valid substring\\n        \\n        // as all words are of len l so to check over all possibilities of combinations words can start from 0,1,..., len-1\\n        for(int i = 0; i < len; i++){\\n            \\n            ///l,r -> starting and ending indexes of window\\n            r = i, l = i;\\n            unordered_map<string ,int> map_s;\\n            \\n            while(r < s.size()){\\n                \\n                str = s.substr( r, len );\\n                cout<<str<<\" \";\\n                r += len;\\n                map_s[str]++;\\n                \\n                // maps are equal means cur substr in window is valid so storing starting index of it\\n                if(map_s == map) \\n                    ans.push_back( l );\\n                \\n                // minimising the window\\n                if( r-l == winSize ){\\n                    \\n                    string x = s.substr( l, len );\\n                    map_s[x]-- ;\\n                    \\n                    if(map_s[x] == 0) \\n                        map_s.erase(x);\\n                    //moving starting ptr of window to next position\\n                    l+=len;\\n                    \\n                }   \\n            }\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1799300,
                "title": "c-two-map-solution-commented",
                "content": "```\\nvector<int> findSubstring(string s, vector<string>& words) {\\n        int n = s.length(), wlen = words[0].length(), m = words.size();\\n        int tot = m*wlen;   //length of the window\\n        \\n        vector<int> ans;\\n        \\n        unordered_map<string, int> mp;\\n        for(auto i : words)                 //store the words in a map\\n            mp[i]++;\\n        \\n        for(int i=0;i<=n-tot; i++){\\n            unordered_map<string,int> cur;  //make a map for the words of the current window\\n            \\n            for(int j=i; j<i+tot; j+=wlen){ //add the words to the map\\n                string w = \"\";\\n                for(int k=j; k<j+wlen; k++){\\n                    w+=s[k];\\n                }\\n                cur[w]++;\\n            }\\n            if(cur==mp) ans.push_back(i);   //compare both maps\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> findSubstring(string s, vector<string>& words) {\\n        int n = s.length(), wlen = words[0].length(), m = words.size();\\n        int tot = m*wlen;   //length of the window\\n        \\n        vector<int> ans;\\n        \\n        unordered_map<string, int> mp;\\n        for(auto i : words)                 //store the words in a map\\n            mp[i]++;\\n        \\n        for(int i=0;i<=n-tot; i++){\\n            unordered_map<string,int> cur;  //make a map for the words of the current window\\n            \\n            for(int j=i; j<i+tot; j+=wlen){ //add the words to the map\\n                string w = \"\";\\n                for(int k=j; k<j+wlen; k++){\\n                    w+=s[k];\\n                }\\n                cur[w]++;\\n            }\\n            if(cur==mp) ans.push_back(i);   //compare both maps\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1691161,
                "title": "c-solution-easy-to-understand-free-from-tle",
                "content": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int n=words.size(),x=words[0].size(),window=x*n;\\n        vector<int> result;\\n        if(s.size()<n*x) return {};\\n        unordered_map<string,int> f;\\n        for(auto &x:words){\\n            f[x]++;\\n        }\\n        int limit=s.size()-window;\\n        for(int i=0;i<=limit;i++){\\n            unordered_map<string,int> m;\\n            int flag=0;\\n            \\n            for(int j=i;j<i+window;j+=x){\\n                string temp=s.substr(j,x);\\n                if(f[temp]>m[temp]){\\n                    m[temp]++;\\n                    flag++;\\n                }\\n                else break;  //important for tle\\n            }\\n            if(flag==n) result.push_back(i);\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int n=words.size(),x=words[0].size(),window=x*n;\\n        vector<int> result;\\n        if(s.size()<n*x) return {}",
                "codeTag": "Java"
            },
            {
                "id": 1423256,
                "title": "js-o-l-n-m-solution-beats-98-18-in-runtime-and-43-77-in-memory-usage",
                "content": "```\\nvar findSubstring = function(s, words) {\\n    let result = [],\\n        pattern = {},\\n        wordLength = words[0].length;\\n\\n    for (const word of words) {\\n        pattern[word] = (pattern[word] || 0) + 1;\\n    }\\n\\n    for (let i = 0; i < wordLength; i++) {\\n        let back = i,\\n            front = back + wordLength,\\n            matches = {},\\n            count = 0\\n\\n        while (front <= s.length) {\\n            let word = s.slice(front - wordLength, front);\\n\\n            if (pattern[word]) {\\n                matches[word] = (matches[word] ?? 0) + 1;\\n                count++;\\n\\n                while (matches[word] > pattern[word]) {\\n                    matches[s.slice(back, back + wordLength)] -= 1;\\n                    back += wordLength;\\n                    count--;\\n                }\\n\\n                if (count === words.length) {\\n                    result.push(back)\\n                }                \\n            } else {\\n                matches = {}\\n                count = 0;\\n                back = front;\\n            }\\n\\n            front += wordLength;\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\ntime complexity: O(L * N + M) where L is the length of a word in \\'words\\', N is the number of letters in \\'s\\' and M is the number of words in \\'words\\'.",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar findSubstring = function(s, words) {\\n    let result = [],\\n        pattern = {},\\n        wordLength = words[0].length;\\n\\n    for (const word of words) {\\n        pattern[word] = (pattern[word] || 0) + 1;\\n    }\\n\\n    for (let i = 0; i < wordLength; i++) {\\n        let back = i,\\n            front = back + wordLength,\\n            matches = {},\\n            count = 0\\n\\n        while (front <= s.length) {\\n            let word = s.slice(front - wordLength, front);\\n\\n            if (pattern[word]) {\\n                matches[word] = (matches[word] ?? 0) + 1;\\n                count++;\\n\\n                while (matches[word] > pattern[word]) {\\n                    matches[s.slice(back, back + wordLength)] -= 1;\\n                    back += wordLength;\\n                    count--;\\n                }\\n\\n                if (count === words.length) {\\n                    result.push(back)\\n                }                \\n            } else {\\n                matches = {}\\n                count = 0;\\n                back = front;\\n            }\\n\\n            front += wordLength;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816466,
                "title": "java-o-n-m-len-clear-easy-to-understand-sliding-window-solution-beats-70-of-submissions",
                "content": "I was struggling to find the intuitive solution so gonna post my own, hope that helps someone to get the clue faster.\\nPls look up numbered comments in the code to link certain pseudocode steps to actual code\\nPseudo:\\n1.  Create a map of words and store their frequencies as by the definition there can be several the same wordsin sequence f.e. \\'foodfoodfood\\'\\n2.  We are going to iterate all over the search string and lookup for our window, so in case of search string like \\'likefoodfoodfoodstring\\' and words=[food,food] we will make a sliding window of word.length()*words.length\\n3.  Create another map to track what have we seen so far and the count\\n4.  Now start another loop which will compare substrings of current words window starting from *i* position\\n5.  As the order is not important we will make substring candidate of word\\'s size \\n6.  Check if the candidate is not in our words list (fq map) than the entire substring will be invalid, so we break from the inner loop\\n7.  Now we woul like to track frequency of candidate words in substring so if the candidate matches for 3 times like in \\'foodfoodfood\\' but search sequence is \\'foodfoodlike\\' we would exit the inner loop \\n8.  if we have managed to reach till the last substring candidate that means entire sequence matches our words list so we can add start position i into our result\\n9.   return result and enjoy :) \\n\\n\\n```\\npublic List<Integer> findSubstring(String s, String[] words) {\\n       if(words.length==0) return Collections.emptyList();\\n        \\n        // 1\\n        Map<String, Integer> fqMap = new HashMap<>();\\n        for(String w: words){\\n            fqMap.put(w, fqMap.getOrDefault(w, 0)+1);\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int count=words.length, len=words[0].length();\\n        //2\\n        for(int i=0; i<=s.length()-(count*len); i++){\\n            //3\\n            Map<String, Integer> seen = new HashMap<>();\\n            //4\\n            for(int j=0; j<count; j++){\\n                int nextIdx = i+j*len;\\n                //5\\n                String candidate = s.substring(nextIdx,nextIdx+len);\\n                //6\\n                if(!fqMap.containsKey(candidate))\\n                    break;\\n                //7\\n                seen.put(candidate, seen.getOrDefault(candidate, 0)+1);\\n                if(seen.get(candidate)>fqMap.get(candidate))\\n                    break;\\n                //8\\n                if(j == count-1){\\n                    result.add(i);\\n                }\\n            }\\n        }\\n        //9\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic List<Integer> findSubstring(String s, String[] words) {\\n       if(words.length==0) return Collections.emptyList();\\n        \\n        // 1\\n        Map<String, Integer> fqMap = new HashMap<>();\\n        for(String w: words){\\n            fqMap.put(w, fqMap.getOrDefault(w, 0)+1);\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int count=words.length, len=words[0].length();\\n        //2\\n        for(int i=0; i<=s.length()-(count*len); i++){\\n            //3\\n            Map<String, Integer> seen = new HashMap<>();\\n            //4\\n            for(int j=0; j<count; j++){\\n                int nextIdx = i+j*len;\\n                //5\\n                String candidate = s.substring(nextIdx,nextIdx+len);\\n                //6\\n                if(!fqMap.containsKey(candidate))\\n                    break;\\n                //7\\n                seen.put(candidate, seen.getOrDefault(candidate, 0)+1);\\n                if(seen.get(candidate)>fqMap.get(candidate))\\n                    break;\\n                //8\\n                if(j == count-1){\\n                    result.add(i);\\n                }\\n            }\\n        }\\n        //9\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739338,
                "title": "java-simple-solution-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (String word: words) {\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        \\n        List<Integer> resultIndices = new ArrayList<>();\\n        \\n        if (s == \"\" || words.length == 0) {\\n            return resultIndices;\\n        }\\n        \\n        int wordsCount = words.length;\\n        int wordLength = words[0].length();\\n        \\n        for (int i=0; i<=s.length() - wordsCount * wordLength; i++) {\\n            Map<String, Integer> wordsSeen = new HashMap<>();\\n            \\n            for (int j=0; j<wordsCount; j++) {\\n                int nextWordIndex = i + j * wordLength;\\n                String word = s.substring(nextWordIndex, nextWordIndex + wordLength);\\n                \\n                if (!map.containsKey(word)) {\\n                    break;\\n                }\\n                \\n                wordsSeen.put(word, wordsSeen.getOrDefault(word, 0) + 1);\\n                \\n                if (wordsSeen.get(word) > map.getOrDefault(word, 0)) {\\n                    break;\\n                }\\n                \\n                if (j + 1 == wordsCount) {\\n                    resultIndices.add(i);\\n                }\\n                \\n            }\\n        }\\n        \\n        return resultIndices;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (String word: words) {\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        \\n        List<Integer> resultIndices = new ArrayList<>();\\n        \\n        if (s == \"\" || words.length == 0) {\\n            return resultIndices;\\n        }\\n        \\n        int wordsCount = words.length;\\n        int wordLength = words[0].length();\\n        \\n        for (int i=0; i<=s.length() - wordsCount * wordLength; i++) {\\n            Map<String, Integer> wordsSeen = new HashMap<>();\\n            \\n            for (int j=0; j<wordsCount; j++) {\\n                int nextWordIndex = i + j * wordLength;\\n                String word = s.substring(nextWordIndex, nextWordIndex + wordLength);\\n                \\n                if (!map.containsKey(word)) {\\n                    break;\\n                }\\n                \\n                wordsSeen.put(word, wordsSeen.getOrDefault(word, 0) + 1);\\n                \\n                if (wordsSeen.get(word) > map.getOrDefault(word, 0)) {\\n                    break;\\n                }\\n                \\n                if (j + 1 == wordsCount) {\\n                    resultIndices.add(i);\\n                }\\n                \\n            }\\n        }\\n        \\n        return resultIndices;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568460,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public IList<int> FindSubstring(string s, string[] words) {\\n        \\n        List<int> res = new List<int>();      \\n        \\n        if(words.Length == 0)\\n            return res;\\n        \\n        int n = words.Length, len = words[0].Length;        \\n        Dictionary<string, int> expect = new Dictionary<string, int>();\\n        \\n        foreach(string word in words)\\n        {\\n            if(expect.ContainsKey(word))\\n                expect[word]++;\\n            else\\n                expect.Add(word, 1);\\n        }\\n        \\n        Dictionary<string, int> seen = new Dictionary<string, int>();\\n\\t\\t\\n\\t\\t// (s.Length - 1) - i + 1 = n * len --> i = s.Length - n * len\\n        for(int i = 0; i < s.Length - n * len + 1; i++)\\n        {\\n            seen.Clear();\\n            int count = 0;\\n            while(count < n)\\n            {\\n                string curr = s.Substring(i + count * len, len);\\n                \\n                if(expect.ContainsKey(curr))\\n                {\\n                    if(seen.ContainsKey(curr))\\n                        seen[curr]++;\\n                    else\\n                        seen.Add(curr, 1);\\n\\n                    if(seen[curr] > expect[curr])\\n                        break;\\n                }\\n                else\\n                    break;\\n\\n                count++;\\n            }\\n            \\n            if(count == n)\\n                res.Add(i);            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindSubstring(string s, string[] words) {\\n        \\n        List<int> res = new List<int>();      \\n        \\n        if(words.Length == 0)\\n            return res;\\n        \\n        int n = words.Length, len = words[0].Length;        \\n        Dictionary<string, int> expect = new Dictionary<string, int>();\\n        \\n        foreach(string word in words)\\n        {\\n            if(expect.ContainsKey(word))\\n                expect[word]++;\\n            else\\n                expect.Add(word, 1);\\n        }\\n        \\n        Dictionary<string, int> seen = new Dictionary<string, int>();\\n\\t\\t\\n\\t\\t// (s.Length - 1) - i + 1 = n * len --> i = s.Length - n * len\\n        for(int i = 0; i < s.Length - n * len + 1; i++)\\n        {\\n            seen.Clear();\\n            int count = 0;\\n            while(count < n)\\n            {\\n                string curr = s.Substring(i + count * len, len);\\n                \\n                if(expect.ContainsKey(curr))\\n                {\\n                    if(seen.ContainsKey(curr))\\n                        seen[curr]++;\\n                    else\\n                        seen.Add(curr, 1);\\n\\n                    if(seen[curr] > expect[curr])\\n                        break;\\n                }\\n                else\\n                    break;\\n\\n                count++;\\n            }\\n            \\n            if(count == n)\\n                res.Add(i);            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13655,
                "title": "aho-corasick-algorithm-o-s-length-words-len-word-count",
                "content": "The time complexity is Great.\\n1. Using Aho-Corasick algorithm to build a Trie.\\n1. Separate the string S into totally words.count numbers substring.\\n1. For each substring, scanning from first to last, and get the answer.\\n\\n**e.g.:**\\n**1. Using Aho-Corasick algorithm.**\\n```txt\\n    S : \"wwwwwopowwwoww\";\\nwords : {\"opo\",\"www\",\"oww\"};\\nwords Id:  0     1     2\\n\\n 0  1  2  3  4  5  6  7  8  9 10 11 12 13  << index\\n w  w  w  w  w  o  p  o  w  w  w  o  w  w  << string\\n-1 -1  1  1  1 -1 -1  0 -1  2  1 -1 -1  2  << Assigned ID\\n```\\n\\n**2. Separate the string S into totally 3 numbers substrings.**\\n```txt\\nS1: w(2) o(5) w(8)  o(11)  ==>  1 -1 -1  2\\nS2: w(3) p(6) w(9)  w(12)  ==>  1 -1  2 -1\\nS3: w(4) o(7) w(10) w(13)  ==>  1  0  1  2\\n```\\n\\n**3. And check each substring whether it have the ans in it.**\\nif we found continuously \"012\"/\"021\"/\"102\"/etc.. , we got the answer.\\n``` S3: 1 0 1 2 ``` have a continuously sequence \"0 1 2\" that meet the require.\\n\\n**Be aware the strings with same content in dictionary(words[])!**\\n\\n```cpp\\nclass Solution {\\n    int wordIdPtr=0;\\n    vector<int> wordIdCount;\\n    \\n    struct Trie {\\n        Trie *failure;\\n        int id=-1;\\n        Trie *next[26];\\n        Trie () {\\n            memset(next,0,sizeof(next));\\n        }\\n    }*root;\\n    void buildTrie (vector<string>& dict) {\\n        root = new Trie();\\n        for (auto it : dict) {\\n            Trie *p=root;\\n            for (int i=0; i<it.length(); i++) {\\n                if (p->next[it[i]-'a'] == nullptr)\\n                    p->next[it[i]-'a'] = new Trie();\\n                p=p->next[it[i]-'a'];\\n            }\\n            if (p->id == -1)\\n                p->id = wordIdPtr++;\\n            wordIdCount[p->id]++;\\n        }\\n        queue<Trie*> Q;\\n        for (int i=0; i<26; i++) {\\n            if (root->next[i]) {\\n                root->next[i]->failure = root;\\n                Q.push(root->next[i]);\\n            }else\\n                root->next[i] = root;\\n        }\\n        while (!Q.empty()) {\\n            Trie *x = Q.front(); Q.pop();\\n            for (int i=0; i<26; i++)\\n                if (x->next[i]) {\\n                    Trie *seek=x->failure;\\n                    while (!seek->next[i])\\n                        seek = seek->failure;\\n                    x->next[i]->failure = seek->next[i];\\n                    if (seek->next[i]->id != -1)\\n                        x->next[i]->id = seek->next[i]->id;\\n                    Q.push(x->next[i]);\\n                }\\n        }\\n    }\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> ans;\\n        if (s.length()==0 || words.size()==0 || words[0].size()==0)\\n            return ans;\\n        wordIdCount.assign(words.size(), 0);\\n        buildTrie(words);\\n        \\n        //find all words in s. O(s.length() + wordlen*wordcount)\\n        vector<int> sid(s.length());\\n        Trie *p=root;\\n        for (int i=0; i<s.length(); i++) {\\n            int chIdx = s[i]-'a';\\n            while (!p->next[chIdx])\\n                p=p->failure;\\n            p = p->next[chIdx];\\n            sid[i]=p->id;\\n            cout<<setw(2)<<sid[i]<<\" \";\\n        }\\n        cout<<\" << Assigned ID\"<<endl;\\n        for (int i=0; i<s.length(); i++)\\n            cout<<setw(2)<<s[i]<<\" \";\\n        cout<<\" << string\"<<endl;\\n        for (int i=0; i<s.length(); i++)\\n            cout<<setw(2)<<i<<\" \";\\n        cout<<\" << index\"<<endl;\\n        \\n        //getAnswer\\n        int wlen = words[0].length();\\n        for (int offset=wlen-1; offset<wlen-1+wlen; offset++) {\\n            auto idx = [&](int k) {return offset+k*wlen;};\\n            int count=0;\\n            //each item at most push and pop once.\\n            vector<queue<int>> appearPos(wordIdPtr);\\n            for (int i=0; idx(i)<s.length(); i++)\\n                if(sid[idx(i)]!=-1) {\\n                    int nowSid = sid[idx(i)];\\n                    if (appearPos[nowSid].size()+1 > wordIdCount[nowSid]) {\\n                        int stopborder=i-count;\\n                        for (int j=appearPos[nowSid].front(); j >= stopborder; j--) {\\n                            appearPos[sid[idx(j)]].pop(), count--;\\n                        }\\n                    }\\n                    appearPos[nowSid].push(i), count++;\\n                    cout<<\"\\\\twork at: \"<<idx(i)<<\" count=\"<<count<<endl;\\n                    if (count == words.size()) {\\n                        ans.push_back(idx(i)-words.size()*wlen+1);\\n                        cout<<\"Got Ans At=\"<<idx(i)<<endl;\\n                    }\\n                }else if (count){\\n                    count=0;\\n                    appearPos.assign(wordIdPtr, queue<int>());\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```txt\\n    S : \"wwwwwopowwwoww\";\\nwords : {\"opo\",\"www\",\"oww\"};\\nwords Id:  0     1     2\\n\\n 0  1  2  3  4  5  6  7  8  9 10 11 12 13  << index\\n w  w  w  w  w  o  p  o  w  w  w  o  w  w  << string\\n-1 -1  1  1  1 -1 -1  0 -1  2  1 -1 -1  2  << Assigned ID\\n```\n```txt\\nS1: w(2) o(5) w(8)  o(11)  ==>  1 -1 -1  2\\nS2: w(3) p(6) w(9)  w(12)  ==>  1 -1  2 -1\\nS3: w(4) o(7) w(10) w(13)  ==>  1  0  1  2\\n```\n``` S3: 1 0 1 2 ```\n```cpp\\nclass Solution {\\n    int wordIdPtr=0;\\n    vector<int> wordIdCount;\\n    \\n    struct Trie {\\n        Trie *failure;\\n        int id=-1;\\n        Trie *next[26];\\n        Trie () {\\n            memset(next,0,sizeof(next));\\n        }\\n    }*root;\\n    void buildTrie (vector<string>& dict) {\\n        root = new Trie();\\n        for (auto it : dict) {\\n            Trie *p=root;\\n            for (int i=0; i<it.length(); i++) {\\n                if (p->next[it[i]-'a'] == nullptr)\\n                    p->next[it[i]-'a'] = new Trie();\\n                p=p->next[it[i]-'a'];\\n            }\\n            if (p->id == -1)\\n                p->id = wordIdPtr++;\\n            wordIdCount[p->id]++;\\n        }\\n        queue<Trie*> Q;\\n        for (int i=0; i<26; i++) {\\n            if (root->next[i]) {\\n                root->next[i]->failure = root;\\n                Q.push(root->next[i]);\\n            }else\\n                root->next[i] = root;\\n        }\\n        while (!Q.empty()) {\\n            Trie *x = Q.front(); Q.pop();\\n            for (int i=0; i<26; i++)\\n                if (x->next[i]) {\\n                    Trie *seek=x->failure;\\n                    while (!seek->next[i])\\n                        seek = seek->failure;\\n                    x->next[i]->failure = seek->next[i];\\n                    if (seek->next[i]->id != -1)\\n                        x->next[i]->id = seek->next[i]->id;\\n                    Q.push(x->next[i]);\\n                }\\n        }\\n    }\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> ans;\\n        if (s.length()==0 || words.size()==0 || words[0].size()==0)\\n            return ans;\\n        wordIdCount.assign(words.size(), 0);\\n        buildTrie(words);\\n        \\n        //find all words in s. O(s.length() + wordlen*wordcount)\\n        vector<int> sid(s.length());\\n        Trie *p=root;\\n        for (int i=0; i<s.length(); i++) {\\n            int chIdx = s[i]-'a';\\n            while (!p->next[chIdx])\\n                p=p->failure;\\n            p = p->next[chIdx];\\n            sid[i]=p->id;\\n            cout<<setw(2)<<sid[i]<<\" \";\\n        }\\n        cout<<\" << Assigned ID\"<<endl;\\n        for (int i=0; i<s.length(); i++)\\n            cout<<setw(2)<<s[i]<<\" \";\\n        cout<<\" << string\"<<endl;\\n        for (int i=0; i<s.length(); i++)\\n            cout<<setw(2)<<i<<\" \";\\n        cout<<\" << index\"<<endl;\\n        \\n        //getAnswer\\n        int wlen = words[0].length();\\n        for (int offset=wlen-1; offset<wlen-1+wlen; offset++) {\\n            auto idx = [&](int k) {return offset+k*wlen;};\\n            int count=0;\\n            //each item at most push and pop once.\\n            vector<queue<int>> appearPos(wordIdPtr);\\n            for (int i=0; idx(i)<s.length(); i++)\\n                if(sid[idx(i)]!=-1) {\\n                    int nowSid = sid[idx(i)];\\n                    if (appearPos[nowSid].size()+1 > wordIdCount[nowSid]) {\\n                        int stopborder=i-count;\\n                        for (int j=appearPos[nowSid].front(); j >= stopborder; j--) {\\n                            appearPos[sid[idx(j)]].pop(), count--;\\n                        }\\n                    }\\n                    appearPos[nowSid].push(i), count++;\\n                    cout<<\"\\\\twork at: \"<<idx(i)<<\" count=\"<<count<<endl;\\n                    if (count == words.size()) {\\n                        ans.push_back(idx(i)-words.size()*wlen+1);\\n                        cout<<\"Got Ans At=\"<<idx(i)<<endl;\\n                    }\\n                }else if (count){\\n                    count=0;\\n                    appearPos.assign(wordIdPtr, queue<int>());\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13736,
                "title": "consice-and-clear-python-solution-o-len-s-len-word-80ms",
                "content": "    class Solution(object):\\n        def findSubstring(self, s, words):\\n            \"\"\"\\n            :type s: str\\n            :type words: List[str]\\n            :rtype: List[int]\\n            \"\"\"\\n            from collections import deque, defaultdict, Counter\\n            s_len, word_len = len(s), len(words[0])\\n            word_len_total = len(words) * word_len\\n            count = Counter(words)\\n            footprint = defaultdict(deque)\\n            result = []\\n            for start in range(word_len):\\n                footprint.clear()\\n                end = start\\n                while start + word_len_total <= s_len:\\n                    sub = s[end:end+word_len]\\n                    end += word_len\\n                    if sub in count:\\n                        queue = footprint[sub]\\n                        queue.append(end)\\n                        while queue[0] < start:\\n                            queue.popleft()\\n                        if len(queue) > count[sub]:\\n                            start = queue.popleft()\\n                        if start + word_len_total == end:\\n                            result.append(start)\\n                    else:\\n                        start = end\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def findSubstring(self, s, words):\\n            \"\"\"\\n            :type s: str\\n            :type words: List[str]\\n            :rtype: List[int]\\n            \"\"\"\\n            from collections import deque, defaultdict, Counter\\n            s_len, word_len = len(s), len(words[0])\\n            word_len_total = len(words) * word_len\\n            count = Counter(words)\\n            footprint = defaultdict(deque)\\n            result = []\\n            for start in range(word_len):\\n                footprint.clear()\\n                end = start\\n                while start + word_len_total <= s_len:\\n                    sub = s[end:end+word_len]\\n                    end += word_len\\n                    if sub in count:\\n                        queue = footprint[sub]\\n                        queue.append(end)\\n                        while queue[0] < start:\\n                            queue.popleft()\\n                        if len(queue) > count[sub]:\\n                            start = queue.popleft()\\n                        if start + word_len_total == end:\\n                            result.append(start)\\n                    else:\\n                        start = end\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 13754,
                "title": "java-o-n-solution-when-consider-substring-as-o-1",
                "content": "Maybe this is the so called window technique. The window was moved right by the while(){} loop. Since substring() is actually expensive in Java, each time I store the substring in a variable to avoid repeatedly calling the substring() function.\\n\\nMore specifically, there are three cases that the window changes: \\n\\n1.The substring at the right of the window is not in words dictionary, then we **move the whole window to the right** side of this substring and set the window back to an **empty window**.\\n\\n2.The substring at the right of window is a candidate word and not used out by the current window, then we add this substring into window. **The window's right boundary extends**. Now **if** the window is a valid solution, add the start index of window to result and cut off the head word of the window for further checking, **the window's left boundary shrinks**.\\n\\n3.The substring at the right of window is a candidate word and is used out by the current window. Then we cut off the head word of the window, **the window's left boundary shrinks** (This would be done **repeatedly** by the while loop until the substring is not used out by the current window and could be added into the window).\\n\\n\\n\\n    public class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if(words.length==0||words[0].length()==0) return res;\\n            Map<String,Integer> wordDict = new HashMap<String,Integer>();\\n            for(String word : words) {\\n                if(!wordDict.containsKey(word)) wordDict.put(word,1);\\n                else wordDict.put(word,wordDict.get(word) + 1);\\n            }\\n            Map<String,Integer> currWords = new HashMap<String,Integer>();\\n            int len = words[0].length();\\n            for(int i = 0; i < len; i++) {\\n                int k = i, j = i; //k is at the head of the window and j is the last.\\n                int addedCount = 0; //to indicate whether we add index to res.\\n                while(k<= s.length()-len*words.length&&j + len <= s.length()) { //make sure the remaining length is enough.\\n                    String subWord = s.substring(j,j+len);\\n                    if(!wordDict.containsKey(subWord)) { //the substring is not in words, head jumps to the right of this substring.\\n                        addedCount = 0;\\n                        currWords.clear();\\n                        j += len;\\n                        k = j;\\n                        continue;\\n                    }\\n                    if(!currWords.containsKey(subWord)||currWords.get(subWord)!=wordDict.get(subWord)) {\\n                        if(!currWords.containsKey(subWord)) currWords.put(subWord,1);\\n                        else currWords.put(subWord,currWords.get(subWord) + 1); //update the current words we used.\\n                        addedCount++;\\n                        if(addedCount == words.length) { //if get a index, add it to res. And we need to continue checking\\n                            res.add(k);\\n                            addedCount--; //remove the head and check new substring, so count-- and move head to new position.\\n                            String preHead = s.substring(k,k+len);\\n                            if(currWords.get(preHead)==1) currWords.remove(preHead); //update the currWords map.\\n                            else currWords.put(preHead,currWords.get(preHead)-1);\\n                            k += len;\\n                        }\\n                        j += len;\\n                    }\\n                    else { //the current substring was used out before. Move head len steps right.\\n                        String preHead = s.substring(k,k+len);\\n                        addedCount--;\\n                        if(currWords.get(preHead)==1) currWords.remove(preHead); //update the currWords map.\\n                        else currWords.put(preHead,currWords.get(preHead)-1);\\n                        k += len; //don't move j this case.\\n                    }\\n                }\\n                currWords.clear();\\n            }\\n            return res;\\n        }\\n    }'",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if(words.length==0||words[0].length()==0) return res;\\n            Map<String,Integer> wordDict = new HashMap<String,Integer>();\\n            for(String word : words) {\\n                if(!wordDict.containsKey(word)) wordDict.put(word,1);\\n                else wordDict.put(word,wordDict.get(word) + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13800,
                "title": "520-ms-c-two-pointer-solution-o-n-len-word-with-explanations",
                "content": "520ms is the fastest C# solution in OJ so far.\\n\\nThe idea is to pick up starting point from 0 to Len(word) - 1, so we will take advantage of Hashmap for each starting point in the loop to avoid repeating creating hashmap and clear history data to save time.\\n\\nSay we have input pair (\"wordgoodgoodgoodbestword\", { \"word\", \"good\", \"best\", \"good\"}), we will loop from starting point of 'w', 'o', 'r' and 'd', and in each loop of starting point, we are checking word by word by using another right point with step of the word's length, so the hashmap will be updated at real time as the right point going ahead.\\n\\nOnce there is no matching word, the starting point will jump to right point, or word's count exceeding the dictionary's count, starting point will go ahead until hashmap refreshed to have word's count == dictionary's word count.\\n\\nCode as follow:\\n\\n    public IList<int> FindSubstring(string s, string[] words) {\\n        List<int> result = new List<int>();\\n        int wordCount = words[0].Length;\\n        IDictionary<string, int> hist = new Dictionary<string, int>(), currHist = new Dictionary<string, int>();\\n        foreach (string w in words) hist[w] = hist.ContainsKey(w) ? hist[w] + 1 : 1;\\n        for (int i = 0; i < wordCount; i++){\\n            currHist.Clear();\\n            for (int j = i, k = i; j + words.Length * wordCount <= s.Length; k += wordCount){\\n                string word = s.Substring(k, wordCount);\\n                if (!hist.ContainsKey(word)){\\n                    currHist.Clear();\\n                    j = k + wordCount;\\n                    continue;\\n                }\\n                currHist[word] = currHist.ContainsKey(word) ? currHist[word] + 1 : 1;\\n                if (currHist[word] > hist[word])\\n                    while (currHist[word] > hist[word]){\\n                        currHist[s.Substring(j, wordCount)]--;\\n                        j += wordCount;\\n                    }\\n                else if ((k - j) / wordCount == words.Length - 1){\\n                    result.Add(j);\\n                    currHist[s.Substring(j, wordCount)]--;\\n                    j += wordCount;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "520ms is the fastest C# solution in OJ so far.\\n\\nThe idea is to pick up starting point from 0 to Len(word) - 1, so we will take advantage of Hashmap for each starting point in the loop to avoid repeating creating hashmap and clear history data to save time.\\n\\nSay we have input pair (\"wordgoodgoodgoodbestword\", { \"word\", \"good\", \"best\", \"good\"}), we will loop from starting point of 'w', 'o', 'r' and 'd', and in each loop of starting point, we are checking word by word by using another right point with step of the word's length, so the hashmap will be updated at real time as the right point going ahead.\\n\\nOnce there is no matching word, the starting point will jump to right point, or word's count exceeding the dictionary's count, starting point will go ahead until hashmap refreshed to have word's count == dictionary's word count.\\n\\nCode as follow:\\n\\n    public IList<int> FindSubstring(string s, string[] words) {\\n        List<int> result = new List<int>();\\n        int wordCount = words[0].Length;\\n        IDictionary<string, int> hist = new Dictionary<string, int>(), currHist = new Dictionary<string, int>();\\n        foreach (string w in words) hist[w] = hist.ContainsKey(w) ? hist[w] + 1 : 1;\\n        for (int i = 0; i < wordCount; i++){\\n            currHist.Clear();\\n            for (int j = i, k = i; j + words.Length * wordCount <= s.Length; k += wordCount){\\n                string word = s.Substring(k, wordCount);\\n                if (!hist.ContainsKey(word)){\\n                    currHist.Clear();\\n                    j = k + wordCount;\\n                    continue;\\n                }\\n                currHist[word] = currHist.ContainsKey(word) ? currHist[word] + 1 : 1;\\n                if (currHist[word] > hist[word])\\n                    while (currHist[word] > hist[word]){\\n                        currHist[s.Substring(j, wordCount)]--;\\n                        j += wordCount;\\n                    }\\n                else if ((k - j) / wordCount == words.Length - 1){\\n                    result.Add(j);\\n                    currHist[s.Substring(j, wordCount)]--;\\n                    j += wordCount;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13755,
                "title": "accepted-java-o-n-solution-using-histogram",
                "content": "    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<>();\\n        if (L.length == 0) {\\n            return res;\\n        }\\n        int len = L[0].length();\\n        int num = L.length;\\n        if (len * num > S.length()) {\\n            return res;\\n        }\\n\\n        //histogram of words in L\\n        HashMap<String, Integer> dic = new HashMap<>();\\n        for (String s : L) {\\n            if (dic.containsKey(s)) {\\n                dic.put(s, dic.get(s) + 1);\\n            } else {\\n                dic.put(s, 1);\\n            }\\n        }\\n\\n        //the word that starts from i in S\\n        String[] sDic = new String[S.length() - len + 1];\\n        for (int i = 0; i < sDic.length; i++) {\\n            String sub = S.substring(i, i + len);\\n            if (dic.containsKey(sub)) {\\n                sDic[i] = sub;\\n            } else {\\n                sDic[i] = \"\";\\n            }\\n        }\\n\\n        //traverse in order of 0,0+len,...,1,1+len,...len-1,len-1+len...therefore it is O(n) despite of two loops\\n        for (int i = 0; i < len; i++) {\\n\\n            //start of concatenation\\n            int start = i;\\n            //number of words found\\n            int found = 0;\\n            //dynamic word histogram of words in substring(start,j);\\n            HashMap<String, Integer> tempDic = new HashMap<>();\\n            for (int j = i; j <= S.length() - len; j = j + len) {\\n                String word = sDic[j];\\n                if (word.equals(\"\")) {\\n                    tempDic = new HashMap<>();\\n                    start = j + len;\\n                    found = 0;\\n                    continue;\\n                } else {\\n                    if (!tempDic.containsKey(word)) {\\n                        tempDic.put(word, 1);\\n                    } else {\\n                        tempDic.put(word, tempDic.get(word) + 1);\\n                    }\\n                    found++;\\n                }\\n                //if we over-count a word, delete the first word in front. Also delete the words before that.\\n                if (tempDic.get(word) > dic.get(word)) {\\n                    while (!sDic[start].equals(word)) {\\n                        tempDic.put(sDic[start], tempDic.get(sDic[start]) - 1);\\n                        start += len;\\n                        found--;\\n                    }\\n                    tempDic.put(word, tempDic.get(word) - 1);\\n                    start += len;\\n                    found--;\\n                }\\n                if (found == num) {\\n                    res.add(start);\\n                }\\n\\n            }\\n\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<>();\\n        if (L.length == 0) {\\n            return res;\\n        }\\n        int len = L[0].length();\\n        int num = L.length;\\n        if (len * num > S.length()) {\\n            return res;\\n        }\\n\\n        //histogram of words in L\\n        HashMap<String, Integer> dic = new HashMap<>();\\n        for (String s : L) {\\n            if (dic.containsKey(s)) {\\n                dic.put(s, dic.get(s) + 1);\\n            } else {\\n                dic.put(s, 1);\\n            }\\n        }\\n\\n        //the word that starts from i in S\\n        String[] sDic = new String[S.length() - len + 1];\\n        for (int i = 0; i < sDic.length; i++) {\\n            String sub = S.substring(i, i + len);\\n            if (dic.containsKey(sub)) {\\n                sDic[i] = sub;\\n            } else {\\n                sDic[i] = \"\";\\n            }\\n        }\\n\\n        //traverse in order of 0,0+len,...,1,1+len,...len-1,len-1+len...therefore it is O(n) despite of two loops\\n        for (int i = 0; i < len; i++) {\\n\\n            //start of concatenation\\n            int start = i;\\n            //number of words found\\n            int found = 0;\\n            //dynamic word histogram of words in substring(start,j);\\n            HashMap<String, Integer> tempDic = new HashMap<>();\\n            for (int j = i; j <= S.length() - len; j = j + len) {\\n                String word = sDic[j];\\n                if (word.equals(\"\")) {\\n                    tempDic = new HashMap<>();\\n                    start = j + len;\\n                    found = 0;\\n                    continue;\\n                } else {\\n                    if (!tempDic.containsKey(word)) {\\n                        tempDic.put(word, 1);\\n                    } else {\\n                        tempDic.put(word, tempDic.get(word) + 1);\\n                    }\\n                    found++;\\n                }\\n                //if we over-count a word, delete the first word in front. Also delete the words before that.\\n                if (tempDic.get(word) > dic.get(word)) {\\n                    while (!sDic[start].equals(word)) {\\n                        tempDic.put(sDic[start], tempDic.get(sDic[start]) - 1);\\n                        start += len;\\n                        found--;\\n                    }\\n                    tempDic.put(word, tempDic.get(word) - 1);\\n                    start += len;\\n                    found--;\\n                }\\n                if (found == num) {\\n                    res.add(start);\\n                }\\n\\n            }\\n\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13821,
                "title": "o-s-length-word-length-c-solution-36-ms",
                "content": "1. Assign id to each word and count repeating words. Store counts of words into baseline_counts array.\\n2. Split the string into chunks of word length and thus convert the string into a vector of word id\\'s. After that move a sliding window of size N, maintain count for each word id in this window and recalculate the distance between the current count vector and the baseline count vector. The distance is calculated as Sum{i=1..N}(abs(count[i] - baseline_count[i])) and is updated in constant time on each step.\\n3. The procedure 2 is repeated (word_length-1) times by moving staring position in the string.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string S, vector<string> &L) {\\n        vector<int> res;\\n\\n        if (L.empty() || L.size()*L[0].size()>S.length())\\n            return res;\\n\\n        int l = S.length();             // string length\\n        long long int n = L.size();     // number of words\\n        int wl = L[0].size();           // word length\\n        \\n        // give 1..n id\\'s to words\\n        unordered_map<string, int> dict;\\n        dict.reserve(n);\\n        vector<int> dc(n+1,0);          // baseline counts (needed for repeating words)\\n        for (int i = 0; i < n; ++i) {\\n            if (dict[L[i]] == 0)\\n                dict[L[i]] = i+1;\\n            dc[dict[L[i]]]++;\\n        }\\n        \\n        vector<int> cc;\\n        cc.reserve(l/wl);\\n            \\n        // shift start position from 0 to wl-1\\n        for (int sh = 0; sh < wl; ++sh) {\\n            cc.clear();\\n            // convert words to their id\\'s\\n            for (int p = sh; p + wl <= l; p += wl) {\\n                auto di = dict.find(S.substr(p, wl));\\n                if (di != dict.end())\\n                    cc.push_back(di->second);   // replace known word with id\\n                else\\n                    cc.push_back(-1);           // replace unknown word with -1\\n            }\\n            \\n            // Fill the sliding window with first n-1 elements\\n            // we keep the count of each word and calculate error as the distance\\n            // between the current counts vector and the baseline count vector\\n            vector<int> cnt(n+1,0);\\n            long long int err = n;\\n            for (int k = 0; k < n-1; ++k) {\\n                int id = cc[k];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp + 1 -dc[id]);\\n                    cnt[id]++;\\n                }\\n            }\\n            \\n            // move the window of size n maintaining the counts\\n            for (int j = 0; j + n <= cc.size(); ++j) {\\n                // add next element\\n                int id = cc[j+n-1];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp+1 -dc[id]);\\n                    cnt[id]++;\\n                }\\n                \\n                // if counts match\\n                if (err == 0)\\n                    res.push_back(sh + j*wl);\\n                \\n                // remove first element\\n                id = cc[j];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp-1 - dc[id]);\\n                    cnt[id]--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string S, vector<string> &L) {\\n        vector<int> res;\\n\\n        if (L.empty() || L.size()*L[0].size()>S.length())\\n            return res;\\n\\n        int l = S.length();             // string length\\n        long long int n = L.size();     // number of words\\n        int wl = L[0].size();           // word length\\n        \\n        // give 1..n id\\'s to words\\n        unordered_map<string, int> dict;\\n        dict.reserve(n);\\n        vector<int> dc(n+1,0);          // baseline counts (needed for repeating words)\\n        for (int i = 0; i < n; ++i) {\\n            if (dict[L[i]] == 0)\\n                dict[L[i]] = i+1;\\n            dc[dict[L[i]]]++;\\n        }\\n        \\n        vector<int> cc;\\n        cc.reserve(l/wl);\\n            \\n        // shift start position from 0 to wl-1\\n        for (int sh = 0; sh < wl; ++sh) {\\n            cc.clear();\\n            // convert words to their id\\'s\\n            for (int p = sh; p + wl <= l; p += wl) {\\n                auto di = dict.find(S.substr(p, wl));\\n                if (di != dict.end())\\n                    cc.push_back(di->second);   // replace known word with id\\n                else\\n                    cc.push_back(-1);           // replace unknown word with -1\\n            }\\n            \\n            // Fill the sliding window with first n-1 elements\\n            // we keep the count of each word and calculate error as the distance\\n            // between the current counts vector and the baseline count vector\\n            vector<int> cnt(n+1,0);\\n            long long int err = n;\\n            for (int k = 0; k < n-1; ++k) {\\n                int id = cc[k];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp + 1 -dc[id]);\\n                    cnt[id]++;\\n                }\\n            }\\n            \\n            // move the window of size n maintaining the counts\\n            for (int j = 0; j + n <= cc.size(); ++j) {\\n                // add next element\\n                int id = cc[j+n-1];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp+1 -dc[id]);\\n                    cnt[id]++;\\n                }\\n                \\n                // if counts match\\n                if (err == 0)\\n                    res.push_back(sh + j*wl);\\n                \\n                // remove first element\\n                id = cc[j];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp-1 - dc[id]);\\n                    cnt[id]--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13848,
                "title": "some-clarification-about-the-characteristics-of-the-input-s-l-by-trial",
                "content": "I found that the description of the problem does not give much detail about the input string and the words list. Here are a few of them that I figured out by trials. I list as follows as a supplementary information. All the examples below are the real cases from OJ.\\n\\n1). The words in the list L do NOT have to be unique. \\ne.g. \\n\\n    S = \\u201clingmindraboofooowingdingbarrwingmonkeypoundcake\\u201d\\n    L = {\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"}   // expected {13}\\n\\n2). The words in the list might have certain parts overlapping, which makes the input a bit of tricky for certain algorithm\\u2026\\ne.g. \\n\\n    S = \"aaaaaa\";\\n    L = {\"aaa\", \"aaa\"}; // expected {0}\\n\\n\\t\\n\\n3). If we consider the entire word list as a slide window, then the windows might overlap with each other in the result.\\ne.g.\\n\\n    S = \"abaababbaba\";\\n    L = {\"ab\",\"ba\",\"ab\",\"ba\"};  // expected {1, 3}",
                "solutionTags": [],
                "code": "I found that the description of the problem does not give much detail about the input string and the words list. Here are a few of them that I figured out by trials. I list as follows as a supplementary information. All the examples below are the real cases from OJ.\\n\\n1). The words in the list L do NOT have to be unique. \\ne.g. \\n\\n    S = \\u201clingmindraboofooowingdingbarrwingmonkeypoundcake\\u201d\\n    L = {\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"}   // expected {13}\\n\\n2). The words in the list might have certain parts overlapping, which makes the input a bit of tricky for certain algorithm\\u2026\\ne.g. \\n\\n    S = \"aaaaaa\";\\n    L = {\"aaa\", \"aaa\"}; // expected {0}\\n\\n\\t\\n\\n3). If we consider the entire word list as a slide window, then the windows might overlap with each other in the result.\\ne.g.\\n\\n    S = \"abaababbaba\";\\n    L = {\"ab\",\"ba\",\"ab\",\"ba\"};  // expected {1, 3}",
                "codeTag": "Unknown"
            },
            {
                "id": 3928025,
                "title": "c-two-approaches-explained-with-comments",
                "content": "# SOL-1\\n\\n## Intuition\\nThe problem asks us to find all starting indices of substrings in a given string `s` such that the concatenation of these substrings forms all the words from a given list `words`. The order of the words in the concatenated substring doesn\\'t matter. To solve this problem, we need to devise a method to efficiently check and track the occurrence of valid concatenated substrings within the given string `s`.\\n\\n## Approach\\nThe approach to solving this problem involves using the sliding window technique and hash maps.\\n\\n1. We start by constructing a hash map called `wordFreqMap` to store the frequency of each word from the given list `words`.\\n\\n2. Next, we iterate through each possible starting position for the substring. For each starting position, we create a new hash map called `currWordFreqMap` to track the frequency of words in the current substring. We also maintain a `wordCount` variable to count the total number of valid words in the current substring.\\n\\n3. Within each substring, we process each word of length `wordLen` (length of any word from the given list) and update the `currWordFreqMap` and `wordCount`. If the word is valid (its frequency doesn\\'t exceed that of `wordFreqMap`), we increment `wordCount`.\\n\\n4. If at any point `wordCount` matches the total number of words (`numWords`), we consider the starting position as a potential result index and add it to the result vector.\\n\\n5. After processing the initial substring, we slide the window to the right by considering the next character. We remove the word that\\'s no longer part of the sliding window and update the `wordCount`. Then, we add the new word to the sliding window and update the `wordCount`. Again, if `wordCount` matches `numWords`, we add the starting position to the result vector.\\n\\n6. We repeat steps 3-5 for each possible starting position within the string `s`.\\n\\n7. Finally, we return the vector containing the result indices.\\n\\n## Complexity\\n- Time complexity: O(N * M * L), where N is the length of the input string `s`, M is the number of words in the list `words`, and L is the length of each word.\\n- Space complexity: O(M + L), where M is the number of words and L is the length of each word. The space is used to store the frequency of words in the hash maps `wordFreqMap` and `currWordFreqMap`.\\n\\n# Code-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = s.size();\\n        int numWords = words.size();\\n        int wordLen = words[0].size();\\n        \\n        // Check if the input string length is less than the minimum required length\\n        if (len < (wordLen * numWords)) {\\n            return {};\\n        }\\n        \\n        vector<int> resultIndices;\\n\\n        // Create a map to store the frequency of words\\n        unordered_map<string, int> wordFreqMap;\\n        for (string word : words) {\\n            wordFreqMap[word]++;\\n        }\\n\\n        // Iterate through different starting positions for the substring\\n        for (int startPos = 0; startPos < wordLen; startPos++) {\\n            unordered_map<string, int> currWordFreqMap;\\n            int wordCount = 0;\\n\\n            // Process each substring with a fixed starting position\\n            for (int i = startPos; i < startPos + (numWords * wordLen); i += wordLen) {\\n                string currentWord = s.substr(i, wordLen);\\n                currWordFreqMap[currentWord]++;\\n                if (currWordFreqMap[currentWord] <= wordFreqMap[currentWord]) {\\n                    wordCount++;\\n                }\\n            }\\n\\n            if (wordCount == numWords) {\\n                resultIndices.push_back(startPos);\\n            }\\n\\n            int endIndex = startPos + numWords * wordLen;\\n            for (int j = startPos + numWords * wordLen; j <= len - wordLen; j += wordLen) {\\n                string removedWord = s.substr(j - numWords * wordLen, wordLen);\\n                if (currWordFreqMap.find(removedWord) != currWordFreqMap.end()) {\\n                    currWordFreqMap[removedWord]--;\\n                    if (currWordFreqMap[removedWord] < wordFreqMap[removedWord]) {\\n                        wordCount--;\\n                    }\\n                }\\n\\n                string addedWord = s.substr(j, wordLen);\\n                currWordFreqMap[addedWord]++;\\n                if (currWordFreqMap[addedWord] <= wordFreqMap[addedWord]) {\\n                    wordCount++;\\n                }\\n\\n                if (wordCount == numWords) {\\n                    resultIndices.push_back(j - (numWords - 1) * wordLen);\\n                }\\n            }\\n        }\\n\\n        return resultIndices;\\n    }\\n};\\n\\n```\\n\\n\\n# SOL-2 : Simple Nested Iterations\\n\\n## Approach\\n\\n1. Initialize variables `len`, `n`, and `wordlen` to store the length of the input string, the number of words, and the length of each word respectively.\\n2. Check if the length of the input string is sufficient to accommodate concatenated words. If not, return an empty vector.\\n3. Create an unordered map `map` to store the frequencies of words from the given list.\\n4. Iterate through possible starting positions of the substring in `s`:\\n   - Create a new unordered map `wordmap` to track the frequencies of words in the current substring.\\n   - Initialize `j`, `cnt`, and other variables.\\n   - Process each word in the current substring using a nested loop and update `wordmap` and `cnt`.\\n   - If the word frequency in `wordmap` does not exceed that in `map`, increment `cnt`.\\n   - If `cnt` equals `n`, push the current starting position to the `ans` vector.\\n5. Return the `ans` vector containing the valid starting positions.\\n\\n## Complexity\\n\\n- Time complexity: The code iterates through different starting positions and nested loops to match concatenated words, resulting in a time complexity of O(N * M * L), where N is the length of the input string, M is the number of words, and L is the length of each word.\\n- Space complexity: The code uses additional space to store the unordered maps `map` and `wordmap`, as well as the `ans` vector, leading to a space complexity of O(M + N).\\n\\n## CODE-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int totalLength = s.size();\\n        int numWords = words.size();\\n        int wordLength = words[0].size();\\n        \\n        // If the total length of the string is less than the combined length of all words, return an empty vector.\\n        if (totalLength < (wordLength * numWords)) {\\n            return {};\\n        }\\n        \\n        vector<int> resultIndices;\\n\\n        // Create a frequency map to store the occurrences of each word in the given list.\\n        unordered_map<string, int> wordFrequencyMap;\\n        for (string word : words) {\\n            wordFrequencyMap[word]++;\\n        }\\n\\n        // Iterate through possible starting positions for the substring.\\n        for (int startPos = 0; startPos <= totalLength - (numWords * wordLength); startPos++) {\\n            unordered_map<string, int> currentWordFrequencyMap;\\n            int wordCount = 0;\\n\\n            // Process each word in the current substring.\\n            for (int j = startPos; j < startPos + (numWords * wordLength); j += wordLength) {\\n                string currentWord = s.substr(j, wordLength);\\n                currentWordFrequencyMap[currentWord]++;\\n                if (currentWordFrequencyMap[currentWord] <= wordFrequencyMap[currentWord]) {\\n                    wordCount++;\\n                } else {\\n                    // If the word occurs more times than needed, break out of the loop.\\n                    break;\\n                }\\n            }\\n\\n            // If all words are found in the current substring, add the starting position to the result vector.\\n            if (wordCount == numWords) {\\n                resultIndices.push_back(startPos);\\n            }\\n        }\\n\\n        return resultIndices;\\n    }\\n};\\n```\\n\\nTry understanding and implementing the code on your own instead of mugging it up. It\\'s not that difficult, just get the glimpse of the approach from these solutions. Thanks for reading.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = s.size();\\n        int numWords = words.size();\\n        int wordLen = words[0].size();\\n        \\n        // Check if the input string length is less than the minimum required length\\n        if (len < (wordLen * numWords)) {\\n            return {};\\n        }\\n        \\n        vector<int> resultIndices;\\n\\n        // Create a map to store the frequency of words\\n        unordered_map<string, int> wordFreqMap;\\n        for (string word : words) {\\n            wordFreqMap[word]++;\\n        }\\n\\n        // Iterate through different starting positions for the substring\\n        for (int startPos = 0; startPos < wordLen; startPos++) {\\n            unordered_map<string, int> currWordFreqMap;\\n            int wordCount = 0;\\n\\n            // Process each substring with a fixed starting position\\n            for (int i = startPos; i < startPos + (numWords * wordLen); i += wordLen) {\\n                string currentWord = s.substr(i, wordLen);\\n                currWordFreqMap[currentWord]++;\\n                if (currWordFreqMap[currentWord] <= wordFreqMap[currentWord]) {\\n                    wordCount++;\\n                }\\n            }\\n\\n            if (wordCount == numWords) {\\n                resultIndices.push_back(startPos);\\n            }\\n\\n            int endIndex = startPos + numWords * wordLen;\\n            for (int j = startPos + numWords * wordLen; j <= len - wordLen; j += wordLen) {\\n                string removedWord = s.substr(j - numWords * wordLen, wordLen);\\n                if (currWordFreqMap.find(removedWord) != currWordFreqMap.end()) {\\n                    currWordFreqMap[removedWord]--;\\n                    if (currWordFreqMap[removedWord] < wordFreqMap[removedWord]) {\\n                        wordCount--;\\n                    }\\n                }\\n\\n                string addedWord = s.substr(j, wordLen);\\n                currWordFreqMap[addedWord]++;\\n                if (currWordFreqMap[addedWord] <= wordFreqMap[addedWord]) {\\n                    wordCount++;\\n                }\\n\\n                if (wordCount == numWords) {\\n                    resultIndices.push_back(j - (numWords - 1) * wordLen);\\n                }\\n            }\\n        }\\n\\n        return resultIndices;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int totalLength = s.size();\\n        int numWords = words.size();\\n        int wordLength = words[0].size();\\n        \\n        // If the total length of the string is less than the combined length of all words, return an empty vector.\\n        if (totalLength < (wordLength * numWords)) {\\n            return {};\\n        }\\n        \\n        vector<int> resultIndices;\\n\\n        // Create a frequency map to store the occurrences of each word in the given list.\\n        unordered_map<string, int> wordFrequencyMap;\\n        for (string word : words) {\\n            wordFrequencyMap[word]++;\\n        }\\n\\n        // Iterate through possible starting positions for the substring.\\n        for (int startPos = 0; startPos <= totalLength - (numWords * wordLength); startPos++) {\\n            unordered_map<string, int> currentWordFrequencyMap;\\n            int wordCount = 0;\\n\\n            // Process each word in the current substring.\\n            for (int j = startPos; j < startPos + (numWords * wordLength); j += wordLength) {\\n                string currentWord = s.substr(j, wordLength);\\n                currentWordFrequencyMap[currentWord]++;\\n                if (currentWordFrequencyMap[currentWord] <= wordFrequencyMap[currentWord]) {\\n                    wordCount++;\\n                } else {\\n                    // If the word occurs more times than needed, break out of the loop.\\n                    break;\\n                }\\n            }\\n\\n            // If all words are found in the current substring, add the starting position to the result vector.\\n            if (wordCount == numWords) {\\n                resultIndices.push_back(startPos);\\n            }\\n        }\\n\\n        return resultIndices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490497,
                "title": "java-solution-for-substring-with-concatenation-of-all-words-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to use a sliding window technique to traverse the string s and check if each substring of length len starting from the current index is a concatenation of all the words in the array words. We maintain a frequency map of the words in words and a current frequency map of the words in the current substring. We also maintain a count of the number of words in the current substring that match the words in words. If the current frequency map of the words in the current substring exceeds the frequency map of the words in words, we move the start of the window to the next index and update the frequency maps and count accordingly. If the count equals the length of words, we add the start index of the current substring to the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the input string s is null or empty, or if the input array words is null or empty. If so, return an empty list, as there are no substrings to find.\\n- Initialize an empty ArrayList result to store the starting indices of the substrings.\\n- Initialize a frequency map map to store the frequency of the words in words.\\n- Initialize the length len to the length of the first word in words.\\n- Traverse the string s from left to right for each starting index j from 0 to len-1.\\n- Initialize a current frequency map currentMap to store the frequency of the words in the current substring.\\n- Initialize the start index start to j and the count count to 0.\\n- Traverse the string s from the current index i to the end of the string in steps of len.\\n- Extract the substring of length len starting from the current index i.\\n- If the substring is in the frequency map map, update the current frequency map currentMap and the count count.\\n- If the frequency of the substring in currentMap exceeds the frequency of the substring in map, move the start index start to the next index and update the current frequency map currentMap and the count count accordingly.\\n- If the count count equals the length of words, add the start index start to the result and move the start index start to the next index.\\n- Repeat steps 9-12 until the end of the string is reached.\\nReturn the ArrayList result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m), where n is the length of the input string s and m is the length of the input array words. The algorithm iterates through the string s once and performs constant-time operations for each substring of length len.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m), as the algorithm uses a frequency map map of the words in words and a current frequency map currentMap of the words in the current substring.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        if(s==null||s.length()==0||words==null||words.length==0)\\n        {\\n            return result;\\n        }\\n        //frequency of words\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(String w: words)\\n        {\\n            if(map.containsKey(w))\\n            {\\n                map.put(w, map.get(w)+1);\\n            }\\n            else\\n            {\\n                map.put(w, 1);\\n            }\\n        }\\n        int len = words[0].length();\\n        for(int j=0; j<len; j++)\\n        {\\n            HashMap<String, Integer> currentMap = new HashMap<String, Integer>();\\n            int start = j;//start index of start\\n            int count = 0;//count totoal qualified words so far\\n            for(int i=j; i<=s.length()-len; i=i+len)\\n            {\\n                String sub = s.substring(i, i+len);\\n                if(map.containsKey(sub))\\n                {\\n                    //set frequency in current map\\n                    if(currentMap.containsKey(sub))\\n                    {\\n                        currentMap.put(sub, currentMap.get(sub)+1);\\n                    }\\n                    else\\n                    {\\n                        currentMap.put(sub, 1);\\n                    }\\n                    count++;\\n                    while(currentMap.get(sub)>map.get(sub))\\n                    {\\n                        String left = s.substring(start, start+len);\\n                        currentMap.put(left, currentMap.get(left)-1);\\n                        count--;\\n                        start = start + len;\\n                    }\\n                    if(count==words.length)\\n                    {\\n                        result.add(start); //add to result\\n                        //shift right and reset currentMap, count & start point\\n                        String left = s.substring(start, start+len);\\n                        currentMap.put(left, currentMap.get(left)-1);\\n                        count--;\\n                        start = start + len;\\n                    }\\n                }\\n                else\\n                {\\n                    currentMap.clear();\\n                    start = i+len;\\n                    count = 0;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        if(s==null||s.length()==0||words==null||words.length==0)\\n        {\\n            return result;\\n        }\\n        //frequency of words\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(String w: words)\\n        {\\n            if(map.containsKey(w))\\n            {\\n                map.put(w, map.get(w)+1);\\n            }\\n            else\\n            {\\n                map.put(w, 1);\\n            }\\n        }\\n        int len = words[0].length();\\n        for(int j=0; j<len; j++)\\n        {\\n            HashMap<String, Integer> currentMap = new HashMap<String, Integer>();\\n            int start = j;//start index of start\\n            int count = 0;//count totoal qualified words so far\\n            for(int i=j; i<=s.length()-len; i=i+len)\\n            {\\n                String sub = s.substring(i, i+len);\\n                if(map.containsKey(sub))\\n                {\\n                    //set frequency in current map\\n                    if(currentMap.containsKey(sub))\\n                    {\\n                        currentMap.put(sub, currentMap.get(sub)+1);\\n                    }\\n                    else\\n                    {\\n                        currentMap.put(sub, 1);\\n                    }\\n                    count++;\\n                    while(currentMap.get(sub)>map.get(sub))\\n                    {\\n                        String left = s.substring(start, start+len);\\n                        currentMap.put(left, currentMap.get(left)-1);\\n                        count--;\\n                        start = start + len;\\n                    }\\n                    if(count==words.length)\\n                    {\\n                        result.add(start); //add to result\\n                        //shift right and reset currentMap, count & start point\\n                        String left = s.substring(start, start+len);\\n                        currentMap.put(left, currentMap.get(left)-1);\\n                        count--;\\n                        start = start + len;\\n                    }\\n                }\\n                else\\n                {\\n                    currentMap.clear();\\n                    start = i+len;\\n                    count = 0;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077316,
                "title": "c-fast-and-easy-solution-using-map-and-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> mp, temp;\\n        vector<int> ans;\\n        for(string &w:words) mp[w]++;\\n\\n        int ws = words[0].size(), sn = s.size(), wn = words.size();\\n        int k = ws*wn;\\n\\n        for(int i=0;i+k<=sn;i++)\\n        {\\n            bool flag = true;\\n            temp = mp;\\n            for(int j=0;j<wn and flag;j++)\\n            {\\n                string substr=\"\";\\n                for(int d=0;d<ws;d++)\\n                substr+=s[i+j*ws+d];\\n\\n                if(temp[substr])\\n                {\\n                    temp[substr]--;\\n                }\\n                else\\n                flag = false;\\n            }\\n            if(flag)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> mp, temp;\\n        vector<int> ans;\\n        for(string &w:words) mp[w]++;\\n\\n        int ws = words[0].size(), sn = s.size(), wn = words.size();\\n        int k = ws*wn;\\n\\n        for(int i=0;i+k<=sn;i++)\\n        {\\n            bool flag = true;\\n            temp = mp;\\n            for(int j=0;j<wn and flag;j++)\\n            {\\n                string substr=\"\";\\n                for(int d=0;d<ws;d++)\\n                substr+=s[i+j*ws+d];\\n\\n                if(temp[substr])\\n                {\\n                    temp[substr]--;\\n                }\\n                else\\n                flag = false;\\n            }\\n            if(flag)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724345,
                "title": "faster-than-99-python-solution",
                "content": "\\nLet n be the length of a word in words\\nand m be the total number of words in words\\n\\n**Space Complexity - O(n+m)\\nTime Complexity - O(n+m)**\\n\\n\\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        ori_word_dict = defaultdict(int)\\n\\t\\t\\n        for word in words:\\n            ori_word_dict[word] += 1\\n        \\n        all_word_len = len(words) * word_len\\n        result = []\\n        for i in range(word_len):\\n            queue = deque()\\n            word_dict = ori_word_dict.copy()\\n            for j in range(i, len(s) - word_len + 1, word_len):\\n                word = s[j:j + word_len]\\n                if word_dict.get(word, 0) != 0:\\n                    word_dict[word] -= 1\\n                    queue.append(word)\\n                    if sum(word_dict.values()) == 0:\\n                        result.append(j - all_word_len + word_len)\\n                        last_element = queue.popleft()\\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                else:\\n                    while len(queue):\\n                        last_element = queue.popleft()\\n                        if last_element == word:\\n                            queue.append(word)\\n                            break\\n                        else:\\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                            if word_dict[last_element] > ori_word_dict[last_element]:\\n                                word_dict = ori_word_dict.copy()\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        ori_word_dict = defaultdict(int)\\n\\t\\t\\n        for word in words:\\n            ori_word_dict[word] += 1\\n        \\n        all_word_len = len(words) * word_len\\n        result = []\\n        for i in range(word_len):\\n            queue = deque()\\n            word_dict = ori_word_dict.copy()\\n            for j in range(i, len(s) - word_len + 1, word_len):\\n                word = s[j:j + word_len]\\n                if word_dict.get(word, 0) != 0:\\n                    word_dict[word] -= 1\\n                    queue.append(word)\\n                    if sum(word_dict.values()) == 0:\\n                        result.append(j - all_word_len + word_len)\\n                        last_element = queue.popleft()\\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                else:\\n                    while len(queue):\\n                        last_element = queue.popleft()\\n                        if last_element == word:\\n                            queue.append(word)\\n                            break\\n                        else:\\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                            if word_dict[last_element] > ori_word_dict[last_element]:\\n                                word_dict = ori_word_dict.copy()\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425998,
                "title": "java-simple-sliding-window",
                "content": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        \\n        int wLength = words[0].length();\\n        int tLength = words[0].length() * words.length; \\n        \\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            \\n            if(j - i + 1 < tLength)\\n                j++;\\n            \\n            else if (j - i + 1 == tLength) {\\n                String sub = s.substring(i, j + 1);\\n                Map<String, Integer> map2 = new HashMap<>();\\n                int index = 0;\\n                while (index < sub.length()) {\\n                    String temp = sub.substring(index, index + wLength);\\n                    map2.put(temp,map2.getOrDefault(temp, 0) + 1);\\n                    index += wLength;\\n                }\\n                \\n                if (map.equals(map2))\\n                    ans.add(i);\\n                i++;   j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        \\n        int wLength = words[0].length();\\n        int tLength = words[0].length() * words.length; \\n        \\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            \\n            if(j - i + 1 < tLength)\\n                j++;\\n            \\n            else if (j - i + 1 == tLength) {\\n                String sub = s.substring(i, j + 1);\\n                Map<String, Integer> map2 = new HashMap<>();\\n                int index = 0;\\n                while (index < sub.length()) {\\n                    String temp = sub.substring(index, index + wLength);\\n                    map2.put(temp,map2.getOrDefault(temp, 0) + 1);\\n                    index += wLength;\\n                }\\n                \\n                if (map.equals(map2))\\n                    ans.add(i);\\n                i++;   j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418661,
                "title": "simple-easy-to-understand-80-faster-solution-java",
                "content": "```\\nclass Solution { // 110ms 74.97% Faster\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int res=0,i,lens=s.length(),lenw=words[0].length(),n=words.length,j;\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(String w : words) map.put(w,map.getOrDefault(w,0)+1);\\n        \\n        HashMap<String,Integer> hashmap = new HashMap<String,Integer>();;\\n        for(i=0;i<=(lens-lenw*n);i++){\\n            hashmap.clear();\\n            for(j=0;j<n;j++){\\n                String str = s.substring(i+lenw*j,i+lenw*(j+1));\\n                hashmap.put(str,hashmap.getOrDefault(str,0)+1);\\n                if(map.getOrDefault(str,Integer.MIN_VALUE)<hashmap.get(str)) break;\\n            }\\n            if(j==n) list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { // 110ms 74.97% Faster\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int res=0,i,lens=s.length(),lenw=words[0].length(),n=words.length,j;\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(String w : words) map.put(w,map.getOrDefault(w,0)+1);\\n        \\n        HashMap<String,Integer> hashmap = new HashMap<String,Integer>();;\\n        for(i=0;i<=(lens-lenw*n);i++){\\n            hashmap.clear();\\n            for(j=0;j<n;j++){\\n                String str = s.substring(i+lenw*j,i+lenw*(j+1));\\n                hashmap.put(str,hashmap.getOrDefault(str,0)+1);\\n                if(map.getOrDefault(str,Integer.MIN_VALUE)<hashmap.get(str)) break;\\n            }\\n            if(j==n) list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308956,
                "title": "40-line-of-codes-n-n-m",
                "content": "```\\nfunc findSubstring(s string, words []string) []int {\\n    wordFrequency := make(map[string]int)\\n    \\n    for _, word := range words {\\n        wordFrequency[word]++\\n    }\\n    \\n    var res []int\\n    \\n    length := len(words[0])\\n    \\n    for i := 0; i < len(s)-length*len(words)+1; i++ {\\n        seen := make(map[string]int)\\n        \\n        for j := 0; j < len(words); j++ {\\n            nextIndex := i + j*length\\n            word := s[nextIndex: nextIndex + length]\\n\\n            if _, ok := wordFrequency[word]; !ok {\\n                break\\n            }\\n            \\n            seen[word]++\\n            \\n            seenFrequency, _ := seen[word]\\n            originFrequency, _ := wordFrequency[word]\\n            \\n            if seenFrequency > originFrequency {\\n                break\\n            }\\n \\n            if j + 1 == len(words) {\\n                res = append(res, i)\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findSubstring(s string, words []string) []int {\\n    wordFrequency := make(map[string]int)\\n    \\n    for _, word := range words {\\n        wordFrequency[word]++\\n    }\\n    \\n    var res []int\\n    \\n    length := len(words[0])\\n    \\n    for i := 0; i < len(s)-length*len(words)+1; i++ {\\n        seen := make(map[string]int)\\n        \\n        for j := 0; j < len(words); j++ {\\n            nextIndex := i + j*length\\n            word := s[nextIndex: nextIndex + length]\\n\\n            if _, ok := wordFrequency[word]; !ok {\\n                break\\n            }\\n            \\n            seen[word]++\\n            \\n            seenFrequency, _ := seen[word]\\n            originFrequency, _ := wordFrequency[word]\\n            \\n            if seenFrequency > originFrequency {\\n                break\\n            }\\n \\n            if j + 1 == len(words) {\\n                res = append(res, i)\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270670,
                "title": "python-counter-sliding-window-explained",
                "content": "The idea is to check if each sliding window from i to j (inclusive) has the same frequency with the \\'words\\'. I use \\'tmp\\' to record the frequency in each sliding window. During the sliding window, if I found that the frequency of one word is higher than the frequency in \\'words\\', just ditch the current sliding window using \\'break\\'.\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        ans = []\\n        n,m = len(words), len(words[0])\\n        words = collections.Counter(words)\\n        \\n        for i in range(len(s)-n*m+1):\\n            tmp = collections.Counter()\\n            cnt = 0\\n            for j in range(i,i+n*m,m): # at most n*m characters in the sliding window \\n                w = s[j:j+m]\\n                if w in words:\\n                    tmp[w]+=1\\n                    cnt+=1\\n                    if tmp[w]>words[w]: # ditch current sliding window\\n                        break\\n                    if cnt==n:\\n                        ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        ans = []\\n        n,m = len(words), len(words[0])\\n        words = collections.Counter(words)\\n        \\n        for i in range(len(s)-n*m+1):\\n            tmp = collections.Counter()\\n            cnt = 0\\n            for j in range(i,i+n*m,m): # at most n*m characters in the sliding window \\n                w = s[j:j+m]\\n                if w in words:\\n                    tmp[w]+=1\\n                    cnt+=1\\n                    if tmp[w]>words[w]: # ditch current sliding window\\n                        break\\n                    if cnt==n:\\n                        ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181581,
                "title": "python3-2-solutions-easy-to-understand-fastest-and-use-least-memory",
                "content": "```\\n#This is the solution 1............this is the fastest solution with 52 ms speed..\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        \\n        count = {}\\n        for word in words:\\n            count[word] = count.get(word,0) + 1\\n        \\n        lw = len(words[0])\\n        fin = []\\n        \\n        for i in range(lw):\\n            l = r = i\\n            window = {}\\n           \\n            while r < len(s):\\n                curr_w = s[r:r+lw]\\n                \\n                if curr_w not in count:\\n                    window.clear()\\n                    r += lw\\n                    l = r\\n                else:\\n                    window[curr_w] = window.get(curr_w,0) + 1\\n                    \\n                    if window[curr_w] <= count[curr_w]:\\n                        r += lw\\n\\n                    else:\\n                        while l <= r and window[curr_w]>count[curr_w]:\\n                            w = s[l:l+lw]\\n                            window[w] -= 1\\n                            l += lw\\n                        r += lw\\n                   \\n                    if window == count:\\n                            fin.append(l)\\n        return fin\\n```\\n\\n\\n```\\n#This is the solution 2............this solution is not the fastest but easiest to understand......\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\t    from itertools import permutations\\n\\t\\tlength=len(words)\\n\\t\\tk=[]\\n\\t\\tg=[]\\n\\t\\ta=list(set(permutations(words,length)))\\n\\t\\tfor i in a:\\n\\t\\t\\ts1=\\'\\'.join(i)\\n\\t\\t\\tl1=len(s1)\\n\\t\\t\\tk.append(s1)\\n\\t\\tfor i in range(0,(len(s)-l1)+1):\\n\\t\\t\\ts2=s[i:(l1+i)]\\n\\t\\t\\tif s2 in k:\\n\\t\\t\\t\\tg.append(i)\\n\\t\\treturn(g)        \\n\\t\\t\\n\\t    \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#This is the solution 1............this is the fastest solution with 52 ms speed..\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        \\n        count = {}\\n        for word in words:\\n            count[word] = count.get(word,0) + 1\\n        \\n        lw = len(words[0])\\n        fin = []\\n        \\n        for i in range(lw):\\n            l = r = i\\n            window = {}\\n           \\n            while r < len(s):\\n                curr_w = s[r:r+lw]\\n                \\n                if curr_w not in count:\\n                    window.clear()\\n                    r += lw\\n                    l = r\\n                else:\\n                    window[curr_w] = window.get(curr_w,0) + 1\\n                    \\n                    if window[curr_w] <= count[curr_w]:\\n                        r += lw\\n\\n                    else:\\n                        while l <= r and window[curr_w]>count[curr_w]:\\n                            w = s[l:l+lw]\\n                            window[w] -= 1\\n                            l += lw\\n                        r += lw\\n                   \\n                    if window == count:\\n                            fin.append(l)\\n        return fin\\n```\n```\\n#This is the solution 2............this solution is not the fastest but easiest to understand......\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\t    from itertools import permutations\\n\\t\\tlength=len(words)\\n\\t\\tk=[]\\n\\t\\tg=[]\\n\\t\\ta=list(set(permutations(words,length)))\\n\\t\\tfor i in a:\\n\\t\\t\\ts1=\\'\\'.join(i)\\n\\t\\t\\tl1=len(s1)\\n\\t\\t\\tk.append(s1)\\n\\t\\tfor i in range(0,(len(s)-l1)+1):\\n\\t\\t\\ts2=s[i:(l1+i)]\\n\\t\\t\\tif s2 in k:\\n\\t\\t\\t\\tg.append(i)\\n\\t\\treturn(g)        \\n\\t\\t\\n\\t    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862010,
                "title": "simple-java-solution-with-explanation-using-2-hashmaps-o-m-n-m-no-of-words-in-words",
                "content": "**Approach:**\\n\\nThe idea to solve the problem is - \\n- Search for each word in given string in every substring window of length = sum of length of concatenated words from words[]. \\n- Whenever all the words are found in the substring window, then we store the starting index of that substring window.\\n\\n**Algo:**\\n\\nWe can break the solution of the problem into 4 steps - \\n1. Store all the words from the `words[]` in a `wordsMap` with the count of each word.\\n2. Calculate the total length of concatenated words in the `words[]` and store it in a variable say `concatWordLen`.\\n3. Iterate through the actual string and extract words of length of `words[0]` (any word in words[] as all length are same) from the string upto `concatWordLen`. Store the extracted words in another `substringWordsMap`. If at any point of time if we find a word that is not in the original `wordsMap` OR the count of any particular word in the `substringWordsMap` is greater than the count of that word in `wordsMap`, we break out of that window.\\n4.  Once all the words from the substring are matched till the length of `concatWordLen`, we check if the contents of this substring map is equal to the contents of the word map. If the contents match, we add to the indices list.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n        List<Integer> indices = new ArrayList<>();\\n\\n        for(String word : words)\\n            wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1);\\n\\n        int wordLen = words[0].length();\\n        int concatWordLen = wordLen * words.length;\\n\\n        for (int i=0; i<= s.length() - concatWordLen; i++){\\n            int startingWordIdx = i;\\n            Map<String, Integer> substringWordsMap = new HashMap<>();\\n            while(startingWordIdx < i + concatWordLen){\\n                String word = s.substring(startingWordIdx, startingWordIdx + wordLen);\\n                if (!wordsMap.containsKey(word) || \\n                    (wordsMap.containsKey(word) && substringWordsMap.containsKey(word) &&\\n                     substringWordsMap.get(word) > wordsMap.get(word)))\\n                    break;\\n                substringWordsMap.put(word, substringWordsMap.getOrDefault(word, 0) + 1);\\n                startingWordIdx = startingWordIdx + wordLen;\\n            }\\n            if (wordsMap.equals(substringWordsMap))\\n                indices.add(i);\\n        }\\n        return indices;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n        List<Integer> indices = new ArrayList<>();\\n\\n        for(String word : words)\\n            wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1);\\n\\n        int wordLen = words[0].length();\\n        int concatWordLen = wordLen * words.length;\\n\\n        for (int i=0; i<= s.length() - concatWordLen; i++){\\n            int startingWordIdx = i;\\n            Map<String, Integer> substringWordsMap = new HashMap<>();\\n            while(startingWordIdx < i + concatWordLen){\\n                String word = s.substring(startingWordIdx, startingWordIdx + wordLen);\\n                if (!wordsMap.containsKey(word) || \\n                    (wordsMap.containsKey(word) && substringWordsMap.containsKey(word) &&\\n                     substringWordsMap.get(word) > wordsMap.get(word)))\\n                    break;\\n                substringWordsMap.put(word, substringWordsMap.getOrDefault(word, 0) + 1);\\n                startingWordIdx = startingWordIdx + wordLen;\\n            }\\n            if (wordsMap.equals(substringWordsMap))\\n                indices.add(i);\\n        }\\n        return indices;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565286,
                "title": "pure-o-n-number-of-words-runtime-beats-84-in-runtime-and-100-in-memory",
                "content": "To understand what will be going on inside my solution, let\\'s discuss some hashing concepts for comparing two sets.\\n\\n**Concept**\\nLet\\'s consider we have two unordered sets (it can be multisets too, no problem) as **s1** and **s2**. Now, we need to determine whether these two sets are equal or not. Here, being **equal** means if we sort these two sets, they will eventually turn out to be the same sets.\\n\\n**Solution:**\\nConsidering both sets are of equal size, the solution is O(|s|) in runtime and O(1) in space complexity. All we need to do is: find hash values for both sets and compare whether they are the same or not! That\\'s it!\\nOur hashing function will be:\\n![image](https://assets.leetcode.com/users/bonchitoboys/image_1586102364.png)\\nwhere,\\n* initially **h = 1** and OFFSET is any random value greater than 0. \\n* n = size of set\\n\\nProbability of Collision: O(N / MOD) where N is the number of items in one set. This probability can be written as our hash function is nothing but a polynomial of degree N. (from **Schwartz-Zippel lemma**)\\n\\n**Main Solution:**\\n\\nConsider each word from **words** as a single integer! Now the problem can be reduced to the following:\\n\\n*Find the number of sets in **S** those are equal to set **words***\\n\\nExample:\\n s = \"barfoothefoobarman\",\\n words = [\"foo\",\"bar\"]\\n \\n converted words = [\"123\", \"456\"] (just assumed their hash values)\\n hash of words = [\"999999\"] (another assumption)\\n\\nNow, iterate over each 3 length substring from **S**, calculate their hash values with polynomial string hashing, add the same OFFSET previously used, consider this hash value as an integer from the set and calculate the final hash value for the contiguous substring. It\\'s kind of running a sliding window of length **|words| * |words[0]|** and checking whether the contiguous substring forms an equal set as **words**.\\n\\nSo, that\\'s all!\\n\\nTotal runtime complexity: **O(N * number of words)**\\nTotal space complexity: **O(|s|)**\\n\\n```\\n#define MAX 10000\\n#define MOD 1000000007\\n#define ll long long\\n#define OFFSET 7\\n\\nll h[MAX + 5], po[MAX + 5];\\n\\nvoid pre(string &s)\\n{\\n    h[0] = s[0];\\n    po[0] = 1;\\n    for(int i = 1; i < s.size(); i++)\\n    {\\n        h[i] = ((h[i - 1] * 263) + (s[i])) % MOD;\\n        po[i] = (po[i - 1] * 263) % MOD;\\n    }\\n}\\n\\nll getHash(int L, int R)\\n{\\n    if(!L) return h[R];\\n    return (h[R] - ((h[L - 1] * po[R - L + 1])%MOD) + MOD) % MOD;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        if(s.size() == 0 || words.size() == 0) return vector<int>();\\n        pre(s);\\n        ll wH = 1;\\n        for(auto &word : words)\\n        {\\n            ll h = 0;\\n            for(auto &ch : word)\\n            {\\n                h = ((h * 263) + ch) % MOD;\\n            }\\n            wH = (wH * (h + OFFSET)) % MOD;\\n        }\\n        int tot_len = words[0].size();\\n        tot_len *= words.size();\\n        int plen = words[0].size();\\n        vector<int>indices;\\n        for(int i = 0; i + tot_len <= s.size(); i++)\\n        {\\n            ll substr_hash = 1;\\n            for(int j = i, idx = 0; idx < words.size(); idx++, j += plen)\\n            {\\n                int L = j;\\n                int R = j + plen - 1;\\n                if(R >= s.size()) break;\\n                substr_hash = (substr_hash * (getHash(L, R) + OFFSET)) % MOD;\\n            }\\n            if(substr_hash == wH) indices.push_back(i);\\n        }\\n        return indices;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n#define MAX 10000\\n#define MOD 1000000007\\n#define ll long long\\n#define OFFSET 7\\n\\nll h[MAX + 5], po[MAX + 5];\\n\\nvoid pre(string &s)\\n{\\n    h[0] = s[0];\\n    po[0] = 1;\\n    for(int i = 1; i < s.size(); i++)\\n    {\\n        h[i] = ((h[i - 1] * 263) + (s[i])) % MOD;\\n        po[i] = (po[i - 1] * 263) % MOD;\\n    }\\n}\\n\\nll getHash(int L, int R)\\n{\\n    if(!L) return h[R];\\n    return (h[R] - ((h[L - 1] * po[R - L + 1])%MOD) + MOD) % MOD;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        if(s.size() == 0 || words.size() == 0) return vector<int>();\\n        pre(s);\\n        ll wH = 1;\\n        for(auto &word : words)\\n        {\\n            ll h = 0;\\n            for(auto &ch : word)\\n            {\\n                h = ((h * 263) + ch) % MOD;\\n            }\\n            wH = (wH * (h + OFFSET)) % MOD;\\n        }\\n        int tot_len = words[0].size();\\n        tot_len *= words.size();\\n        int plen = words[0].size();\\n        vector<int>indices;\\n        for(int i = 0; i + tot_len <= s.size(); i++)\\n        {\\n            ll substr_hash = 1;\\n            for(int j = i, idx = 0; idx < words.size(); idx++, j += plen)\\n            {\\n                int L = j;\\n                int R = j + plen - 1;\\n                if(R >= s.size()) break;\\n                substr_hash = (substr_hash * (getHash(L, R) + OFFSET)) % MOD;\\n            }\\n            if(substr_hash == wH) indices.push_back(i);\\n        }\\n        return indices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380143,
                "title": "javascript-solution-faster-than-100",
                "content": "Javascript solution, faster than 100% of solutions\\n\\nIf you enjoyed the solution, don\\'t forget to like\\nAlso, if you have questions or ideas, I appreciate if you write them in the comments\\nHave fun, and more solutions to come ))\\n\\nLink to run: https://leetcode.com/submissions/detail/259635818/\\n\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = (s, words) => {\\n    const result = [];\\n    if (words.length > 0) {\\n        const wordsCount = words.length;\\n        const wordLength = words[0] ? words[0].length : 0;\\n        const offset = wordLength * (wordsCount - 1);\\n        const map = createHashTable(words);\\n\\n        for (let i = 0; i < wordLength; i++) {\\n            let wordsFound = 0;\\n            let tempMap = new Map();\\n\\n            let sequenceStart = i;\\n\\n            const endLength = s.length - wordLength;\\n            for (let j = i; j <= endLength; j += wordLength) {\\n                const word = s.substr(j, wordLength);\\n                const wordEntriesNeeded = map.get(word);\\n                const wordEntriesUsed = tempMap.get(word);\\n                if (wordEntriesUsed !== wordEntriesNeeded) {\\n                    wordsFound++;\\n                    tempMap.set(word, wordEntriesUsed ? wordEntriesUsed + 1 : 1);\\n                } else if (!wordEntriesNeeded) {\\n                    wordsFound = 0;\\n                    tempMap = new Map();\\n                    sequenceStart = j + wordLength;\\n                } else {\\n                    let wordToRemove;\\n\\n                    do {\\n                        wordToRemove = s.substr(sequenceStart, wordLength);\\n                        sequenceStart += wordLength;\\n                        tempMap.set(wordToRemove, tempMap.get(wordToRemove) - 1);\\n                        wordsFound--;\\n                    }\\n                    while (wordToRemove !== word && sequenceStart <= j);\\n\\n                    wordsFound++;\\n                    tempMap.set(word, tempMap.get(word) + 1);\\n                }\\n                if (wordsFound === wordsCount) {\\n                    result.push(j - offset);\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\nconst createHashTable = (words) => {\\n    const map = new Map();\\n    words.forEach(word => {\\n        const oldValue = map.get(word);\\n        if (map.has(word)) {\\n            map.set(word, oldValue + 1);\\n        } else {\\n            map.set(word, 1);\\n        }\\n    });\\n    return map;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = (s, words) => {\\n    const result = [];\\n    if (words.length > 0) {\\n        const wordsCount = words.length;\\n        const wordLength = words[0] ? words[0].length : 0;\\n        const offset = wordLength * (wordsCount - 1);\\n        const map = createHashTable(words);\\n\\n        for (let i = 0; i < wordLength; i++) {\\n            let wordsFound = 0;\\n            let tempMap = new Map();\\n\\n            let sequenceStart = i;\\n\\n            const endLength = s.length - wordLength;\\n            for (let j = i; j <= endLength; j += wordLength) {\\n                const word = s.substr(j, wordLength);\\n                const wordEntriesNeeded = map.get(word);\\n                const wordEntriesUsed = tempMap.get(word);\\n                if (wordEntriesUsed !== wordEntriesNeeded) {\\n                    wordsFound++;\\n                    tempMap.set(word, wordEntriesUsed ? wordEntriesUsed + 1 : 1);\\n                } else if (!wordEntriesNeeded) {\\n                    wordsFound = 0;\\n                    tempMap = new Map();\\n                    sequenceStart = j + wordLength;\\n                } else {\\n                    let wordToRemove;\\n\\n                    do {\\n                        wordToRemove = s.substr(sequenceStart, wordLength);\\n                        sequenceStart += wordLength;\\n                        tempMap.set(wordToRemove, tempMap.get(wordToRemove) - 1);\\n                        wordsFound--;\\n                    }\\n                    while (wordToRemove !== word && sequenceStart <= j);\\n\\n                    wordsFound++;\\n                    tempMap.set(word, tempMap.get(word) + 1);\\n                }\\n                if (wordsFound === wordsCount) {\\n                    result.push(j - offset);\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\nconst createHashTable = (words) => {\\n    const map = new Map();\\n    words.forEach(word => {\\n        const oldValue = map.get(word);\\n        if (map.has(word)) {\\n            map.set(word, oldValue + 1);\\n        } else {\\n            map.set(word, 1);\\n        }\\n    });\\n    return map;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360060,
                "title": "python-brute-force-super-short-passed-all-test-cases",
                "content": "The idea is:\\n1). Sort the words list, and concatenate it to a single string **words_cat**. \\n2). Loop over the string **s**. At each position **i**, get the substring starting at **i** with the same length as **words_cat**. Then, sort this substring and compare it with **words_cat**. If they are the same, add **i** into the list of valid index.\\n\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if len(words) == 0 or len(s) == 0: return []\\n        if len(s) < len(\\'\\'.join(words)): return []\\n        \\n        rst = []\\n        words_cat = \\'\\'.join(sorted(words))\\n        l, m = len(words[0]), len(words)\\n        l_all = len(words_cat)\\n        \\n        for i in range(len(s) - l_all + 1): \\n            s_sub = []\\n            for j in range(m):\\n                s_sub.append(s[i + l * j : i + l * (j+1)])       \\n            s_sub = \\'\\'.join(sorted(s_sub))\\n            if s_sub == words_cat: rst.append(i)\\n        \\n        return rst \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if len(words) == 0 or len(s) == 0: return []\\n        if len(s) < len(\\'\\'.join(words)): return []\\n        \\n        rst = []\\n        words_cat = \\'\\'.join(sorted(words))\\n        l, m = len(words[0]), len(words)\\n        l_all = len(words_cat)\\n        \\n        for i in range(len(s) - l_all + 1): \\n            s_sub = []\\n            for j in range(m):\\n                s_sub.append(s[i + l * j : i + l * (j+1)])       \\n            s_sub = \\'\\'.join(sorted(s_sub))\\n            if s_sub == words_cat: rst.append(i)\\n        \\n        return rst \\n```",
                "codeTag": "Java"
            },
            {
                "id": 238924,
                "title": "solved-by-js",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n    let res=[];\\n    if(s.length==0 || words.length==0) return res;\\n    let n=words.length,m=words[0].length;\\n    let m1={};\\n//     \\u5C06\\u6240\\u6709\\u5355\\u8BCD\\u5B58\\u5165\\u54C8\\u5E0C\\u8868\\n    for(let w of words){  \\n        m1[w]?m1[w]++:(m1[w]=1)\\n    }\\n\\n    for(let i=0;i<=s.length-n*m;i++){\\n        let m2={};\\n        let j=0;\\n        for(j=0;j<n;j++){\\n//             \\u83B7\\u53D6\\u957F\\u5EA6\\u4E3Am\\u7684\\u5B57\\u4E32t\\n            let t=s.substr(i+j*m,m);\\n//             \\u5982\\u679Cm1\\u4E2D\\u4E0D\\u5B58\\u5728\\u5219\\u8DF3\\u51FA\\u5FAA\\u73AF\\n            if(!m1[t]) break;\\n//             \\u5982\\u679Cm1\\u4E2D\\u5B58\\u5728\\u5B57\\u4E32t,\\u5219\\u5B58\\u5165m2\\n            m2[t]?m2[t]++:(m2[t]=1);\\n//             \\u5982\\u679Cm2\\u4E2D\\u51FA\\u73B0\\u7684\\u5355\\u8BCD\\u6B21\\u6570\\u6BD4m1\\u591A\\uFF0C\\u8DF3\\u51FA\\u5FAA\\u73AF\\n            if(m2[t]>m1[t]) break;\\n        }\\n        if(j==n) res.push(i);\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n    let res=[];\\n    if(s.length==0 || words.length==0) return res;\\n    let n=words.length,m=words[0].length;\\n    let m1={};\\n//     \\u5C06\\u6240\\u6709\\u5355\\u8BCD\\u5B58\\u5165\\u54C8\\u5E0C\\u8868\\n    for(let w of words){  \\n        m1[w]?m1[w]++:(m1[w]=1)\\n    }\\n\\n    for(let i=0;i<=s.length-n*m;i++){\\n        let m2={};\\n        let j=0;\\n        for(j=0;j<n;j++){\\n//             \\u83B7\\u53D6\\u957F\\u5EA6\\u4E3Am\\u7684\\u5B57\\u4E32t\\n            let t=s.substr(i+j*m,m);\\n//             \\u5982\\u679Cm1\\u4E2D\\u4E0D\\u5B58\\u5728\\u5219\\u8DF3\\u51FA\\u5FAA\\u73AF\\n            if(!m1[t]) break;\\n//             \\u5982\\u679Cm1\\u4E2D\\u5B58\\u5728\\u5B57\\u4E32t,\\u5219\\u5B58\\u5165m2\\n            m2[t]?m2[t]++:(m2[t]=1);\\n//             \\u5982\\u679Cm2\\u4E2D\\u51FA\\u73B0\\u7684\\u5355\\u8BCD\\u6B21\\u6570\\u6BD4m1\\u591A\\uFF0C\\u8DF3\\u51FA\\u5FAA\\u73AF\\n            if(m2[t]>m1[t]) break;\\n        }\\n        if(j==n) res.push(i);\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13741,
                "title": "key-idea-maintain-multiple-windows-o-n-solution",
                "content": "because every word in the words list has the same length. We can maintain multiple sliding windows and go through String s only once. The number of the windows needed is the length of the word.\\n\\n For example suppose s=123456789, word length =3, all substrings we need to check are:\\n\\n123, 234, 345, 456, 567, 678, 789, \\nIf we group them by their first char index % word length and we get:\\n\\n0: 123, 456, 789\\n\\n1: 234, 567\\n\\n2: 345, 678\\n\\nNow we only need to check if we find a match in each window. For each window, the match algorithm is same as single sliding window problem.\\n\\n    public class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            ArrayList<Integer> ret = new ArrayList<Integer>();\\n            if (s==null || s.length()==0 || words==null || words.length==0) return ret;\\n            int wordL=words[0].length();\\n            if (s.length()<(wordL*words.length)) return ret;\\n            \\n\\n            HashMap<String, Integer> wordId = new HashMap<String,Integer>();\\n            int[] wordCount = new int[words.length];\\n            int distinctCount=0;\\n            for (int i=0;i<words.length;i++){\\n                if (wordId.containsKey(words[i])){\\n                    int idx = wordId.get(words[i]);\\n                    wordCount[idx]++;\\n                }else{\\n                    wordId.put(words[i],distinctCount);\\n                    wordCount[distinctCount++]=1;\\n                }\\n            }\\n            \\n           \\n            int[][] windows = new int[wordL][distinctCount];\\n            int[] matchCount = new int[wordL];\\n            for (int i=0;i<=s.length()-wordL;i++){\\n                String subS = s.substring(i,i+wordL);\\n            \\n                if (wordId.containsKey(subS)){\\n                    int idx = wordId.get(subS);\\n                    if (windows[i%wordL][idx]>=wordCount[idx]) {\\n                        for (int j=i-matchCount[i%wordL]*wordL;j<i;j+=wordL){\\n                            String sRemove=s.substring(j,j+wordL);\\n                            int idxRemove = wordId.get(sRemove);\\n                            windows[i%wordL][idxRemove]--;\\n                            matchCount[i%wordL]--;\\n                            if (idxRemove==idx) break;\\n                        }\\n                    }\\n                    windows[i%wordL][idx]++;\\n                    if (++matchCount[i%wordL]==words.length) ret.add(i-(matchCount[i%wordL]-1)*wordL);\\n                    \\n                    \\n                }else {\\n                     for (int j=i-matchCount[i%wordL]*wordL;j<i;j+=wordL){\\n                        String sRemove=s.substring(j,j+wordL);\\n                        int idxRemove = wordId.get(sRemove);\\n                        windows[i%wordL][idxRemove]--;\\n                        matchCount[i%wordL]--;\\n                       \\n                    }\\n                }\\n                \\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            ArrayList<Integer> ret = new ArrayList<Integer>();\\n            if (s==null || s.length()==0 || words==null || words.length==0) return ret;\\n            int wordL=words[0].length();\\n            if (s.length()<(wordL*words.length)) return ret;\\n            \\n\\n            HashMap<String, Integer> wordId = new HashMap<String,Integer>();\\n            int[] wordCount = new int[words.length];\\n            int distinctCount=0;\\n            for (int i=0;i<words.length;i++){\\n                if (wordId.containsKey(words[i])){\\n                    int idx = wordId.get(words[i]);\\n                    wordCount[idx]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 13761,
                "title": "c-16ms-beating-99-86-simple-idea-easy-to-understand",
                "content": "**Basic idea**, in each position, check whether satisfies conditions.\\n\\n**Problem**, the check operation is tooooo slow. So, how to reduce the operation frequency? Using **Hash**.\\n\\n**Hash 1**, hash(str=c1c2..cn) = c1 + c2 + .. cn. Too simple? Yes, yet efficient. You could try!\\n\\n**Hash 2**, improved version, grouping by different position. For example, dict = [\"abc\", \"def\"], then our hash array is ['a' + 'd', 'b' + 'e', 'c' + 'f']. Given a str \"123456\", its hash is ['1' + '4', '2' + '5', '3' + '6']. Then compare this hash array with standard dict hash!\\n\\nIn my code, all member variables have a suffix '_'; the hash array is called FingerPrint.\\n\\n   \\n\\n    // Author: Tian Xia\\n    class Solution {\\n     public:\\n      typedef vector<int> FingerPrint;\\n    \\n      vector<int> findSubstring(const string str, const vector<string>& dict) {\\n        vector<int> ret;\\n        word_len_ = SIZE(dict[0]);\\n        char_size_ = dict.size() * word_len_; \\n    \\n        if (SIZE(str) < char_size_) {\\n          return ret;\\n        }\\n    \\n        dict_.clear();\\n        for (auto &w: dict) {\\n          dict_[w] += 1;\\n        }\\n    \\n        fp_ = gen_fingerprint();\\n        decltype(fp_) lfp(word_len_, 0);\\n        for (int p = 0; p < char_size_; ++p) {\\n          lfp[p % word_len_] += str[p];\\n        }\\n        if (equal(lfp, 0) && check(str, 0)) {\\n          ret.push_back(0);\\n        }\\n    \\n        for (int p = char_size_; p < SIZE(str); ++p) {\\n          lfp[(p) % word_len_] += -str[p - char_size_] + str[p];\\n          if (equal(lfp, p + 1) && check(str, p + 1 - char_size_)) {\\n            ret.push_back(p + 1 - char_size_);\\n          }\\n        }\\n    \\n        return ret;\\n      }\\n    \\n     protected:\\n      bool equal(const FingerPrint &fp, int start) {\\n        for (int p = 0; p < word_len_; ++p) {\\n          if (fp[(start + p) % word_len_] != fp_[p]) {\\n            return false;\\n          }\\n        }\\n        return true;\\n      }\\n    \\n      bool check(const string &str, int p) {\\n        map<string, int> freqs; \\n        for (int d = p; d < p + char_size_; d += word_len_) {\\n          string substr = str.substr(d, word_len_);\\n          freqs[substr] += 1;\\n        }\\n    \\n        auto ite1 = freqs.begin(), ite2 = dict_.begin();\\n        while (ite1 != freqs.end() && ite2 != freqs.end()) {\\n          if (ite1->first == ite2->first && ite1->second == ite2->second) {\\n            ++ite1;\\n            ++ite2;\\n            continue;\\n          }\\n          return false;\\n        }\\n    \\n        return true;\\n      }\\n    \\n      FingerPrint gen_fingerprint() {\\n        FingerPrint ret(word_len_, 0);\\n        for (auto &pair: dict_) {\\n          for (int p = 0; p < word_len_; ++p) {\\n            ret[p] += pair.first[p] * pair.second;\\n          }\\n        }\\n    \\n        return ret;\\n      }\\n    \\n      map<string, int> dict_;\\n      int char_size_, word_len_;\\n      FingerPrint fp_;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n      typedef vector<int> FingerPrint;\\n    \\n      vector<int> findSubstring(const string str, const vector<string>& dict) {\\n        vector<int> ret;\\n        word_len_ = SIZE(dict[0]);\\n        char_size_ = dict.size() * word_len_; \\n    \\n        if (SIZE(str) < char_size_) {\\n          return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 13771,
                "title": "short-ac-java-solution-with-o-n",
                "content": "        public List<Integer> findSubstring(String s, String[] words) {\\n            if(words.length==0||words[0].length()==0)   return new ArrayList<>();\\n            HashMap<String, Integer> map = new HashMap<>();\\n            for(String word:words)  map.put(word,map.getOrDefault(word,0)+1);\\n            List<Integer> list = new ArrayList<>();\\n            int gap = words[0].length();\\n            int nlen = words.length*gap;\\n            for(int k=0;k<gap;k++){\\n                HashMap<String,Integer> wordmap = new HashMap<>(map);\\n                for(int i=k,j=0;i<s.length()-nlen+1&&i+j<=s.length()-gap;){\\n                    String temp = s.substring(i+j,i+j+gap);\\n                    if(wordmap.containsKey(temp)){\\n                        wordmap.put(temp,wordmap.get(temp)-1);\\n                        if(wordmap.get(temp)==0)    wordmap.remove(temp);\\n                        if(wordmap.isEmpty())   list.add(i);\\n                        j+=gap;\\n                    }\\n                    else{\\n                        if(j==0)    i+=gap;\\n                        else{\\n                            wordmap.put(s.substring(i,i+gap),wordmap.getOrDefault(s.substring(i,i+gap),0)+1);\\n                            i+=gap;\\n                            j-=gap;\\n                        }\\n                    }\\n                }\\n            }\\n            return list;\\n        }\\nI made k as first word-length indexes starting from 0.  The number of all indexes that the two pointers i and j move in total is 2*N/gap (N = s.length()) because i+j does not move backwards.  Together with k, total runtime is O(N).",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        public List<Integer> findSubstring(String s, String[] words) {\\n            if(words.length==0||words[0].length()==0)   return new ArrayList<>();\\n            HashMap<String, Integer> map = new HashMap<>();\\n            for(String word:words)  map.put(word,map.getOrDefault(word,0)+1);\\n            List<Integer> list = new ArrayList<>();\\n            int gap = words[0].length();\\n            int nlen = words.length*gap;\\n            for(int k=0;k<gap;k++){\\n                HashMap<String,Integer> wordmap = new HashMap<>(map);\\n                for(int i=k,j=0;i<s.length()-nlen+1&&i+j<=s.length()-gap;){\\n                    String temp = s.substring(i+j,i+j+gap);\\n                    if(wordmap.containsKey(temp)){\\n                        wordmap.put(temp,wordmap.get(temp)-1);\\n                        if(wordmap.get(temp)==0)    wordmap.remove(temp);\\n                        if(wordmap.isEmpty())   list.add(i);\\n                        j+=gap;\\n                    }\\n                    else{\\n                        if(j==0)    i+=gap;\\n                        else{\\n                            wordmap.put(s.substring(i,i+gap),wordmap.getOrDefault(s.substring(i,i+gap),0)+1);\\n                            i+=gap;\\n                            j-=gap;\\n                        }\\n                    }\\n                }\\n            }\\n            return list;\\n        }\\nI made k as first word-length indexes starting from 0.  The number of all indexes that the two pointers i and j move in total is 2*N/gap (N = s.length()) because i+j does not move backwards.  Together with k, total runtime is O(N).",
                "codeTag": "Unknown"
            },
            {
                "id": 13747,
                "title": "my-68ms-c-solution-without-hashing",
                "content": "it's a good idea to using Aho-Corasick to match all words, if so, the entire algorithm may down to O(n) where n is the total character count of all input strings.\\n\\n**Edition 2015/09/02:** this algorithm behaves like [Accepted Java O(n) solution using histogram][1].\\n\\n    #define newArray(type, size) ((type*)calloc(size, sizeof(type)))\\n    #define resizeArray(ptr, type, size) ((type*)realloc(ptr, (size) * sizeof(type)))\\n    \\n    int *pushback(int *array, int *size, int value) {\\n        int *output = resizeArray(array, int, *size + 1);\\n        output[(*size)++] = value;\\n        return output;\\n    }\\n    \\n    typedef struct {\\n        char *word;\\n        int occurs;\\n    } wordEntry;\\n    \\n    /**\\n     * Return an array of size *returnSize.\\n     * Note: The returned array must be malloced, assume caller calls free().\\n     */\\n    int* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\\n        int *result = NULL;\\n        *returnSize = 0;\\n    \\n        // edge conditions\\n        if (wordsSize <= 0)\\n            return result;\\n        int slength = strlen(s), wlength = strlen(words[0]);\\n        if (slength < wlength * wordsSize)\\n            return result;\\n    \\n        // handle words, count the duplicates.\\n        wordEntry *ws = newArray(wordEntry, wordsSize);\\n        int wsSize = 0, i, j, k;\\n        for (i = 0; i < wordsSize; ++i) {\\n            char *word = words[i];\\n            for (k = -1, j = 0; k < 0 && j < wsSize; ++j)\\n                if (strcmp(ws[j].word, word) == 0)\\n                    k = j;\\n            if (k < 0)\\n                k = wsSize++;\\n            ws[k].word = word;\\n            ws[k].occurs++;\\n        }\\n    \\n        // calulate word matched at each position.\\n        slength -= wlength - 1;\\n        int *ms = newArray(int, slength);\\n        for (i = 0; i < slength; ++i) {\\n            for (k = -1, j = 0; k < 0 && j < wsSize; ++j)\\n                if (strncmp(s + i, ws[j].word, wlength) == 0)\\n                    k = j;\\n            // store matched index in word list without duplicates.\\n            ms[i] = k;\\n        }\\n    \\n        // scan all possible chains, cached word indices stored in os.\\n        int *os = newArray(int, wordsSize);\\n        for (i = 0; i < wlength; ++i) {\\n            int start = i, found = 0;\\n            for (j = i; j < slength; j += wlength) {\\n                int windex = ms[j];\\n                if (windex < 0) {\\n                    // no matched word here, simply reset the marker,\\n                    // and write back all cached words.\\n                    start = j + wlength;\\n                    while (found > 0) {\\n                        ws[os[--found]].occurs++;\\n                    }\\n                    continue;\\n                }\\n                // move the matched word from word list to cache,\\n                // write back the leading cached words if necessary.\\n                if (ws[windex].occurs == 0) {\\n                    for (k = 0; k < found; ++k) {\\n                        ws[os[k]].occurs++;\\n                        start += wlength;\\n                        if (os[k] == windex) {\\n                            ++k;\\n                            break;\\n                        }\\n                    }\\n                    found -= k;\\n                    if (found)\\n                        memmove(os, os + k, found * sizeof(*os));\\n                }\\n                ws[windex].occurs--;\\n                os[found++] = windex;\\n                // push the marker position if matched all words.\\n                if (found == wordsSize)\\n                    result = pushback(result, returnSize, start);\\n            }\\n            // after scanning, write back all cached words.\\n            while (found > 0) {\\n                ws[os[--found]].occurs++;\\n            }\\n        }\\n    \\n        free(ws);\\n        free(ms);\\n        free(os);\\n    \\n        return result;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/45050/accepted-java-o-n-solution-using-histogram",
                "solutionTags": [],
                "code": "it's a good idea to using Aho-Corasick to match all words, if so, the entire algorithm may down to O(n) where n is the total character count of all input strings.\\n\\n**Edition 2015/09/02:** this algorithm behaves like [Accepted Java O(n) solution using histogram][1].\\n\\n    #define newArray(type, size) ((type*)calloc(size, sizeof(type)))\\n    #define resizeArray(ptr, type, size) ((type*)realloc(ptr, (size) * sizeof(type)))\\n    \\n    int *pushback(int *array, int *size, int value) {\\n        int *output = resizeArray(array, int, *size + 1);\\n        output[(*size)++] = value;\\n        return output;\\n    }\\n    \\n    typedef struct {\\n        char *word;\\n        int occurs;\\n    } wordEntry;\\n    \\n    /**\\n     * Return an array of size *returnSize.\\n     * Note: The returned array must be malloced, assume caller calls free().\\n     */\\n    int* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\\n        int *result = NULL;\\n        *returnSize = 0;\\n    \\n        // edge conditions\\n        if (wordsSize <= 0)\\n            return result;\\n        int slength = strlen(s), wlength = strlen(words[0]);\\n        if (slength < wlength * wordsSize)\\n            return result;\\n    \\n        // handle words, count the duplicates.\\n        wordEntry *ws = newArray(wordEntry, wordsSize);\\n        int wsSize = 0, i, j, k;\\n        for (i = 0; i < wordsSize; ++i) {\\n            char *word = words[i];\\n            for (k = -1, j = 0; k < 0 && j < wsSize; ++j)\\n                if (strcmp(ws[j].word, word) == 0)\\n                    k = j;\\n            if (k < 0)\\n                k = wsSize++;\\n            ws[k].word = word;\\n            ws[k].occurs++;\\n        }\\n    \\n        // calulate word matched at each position.\\n        slength -= wlength - 1;\\n        int *ms = newArray(int, slength);\\n        for (i = 0; i < slength; ++i) {\\n            for (k = -1, j = 0; k < 0 && j < wsSize; ++j)\\n                if (strncmp(s + i, ws[j].word, wlength) == 0)\\n                    k = j;\\n            // store matched index in word list without duplicates.\\n            ms[i] = k;\\n        }\\n    \\n        // scan all possible chains, cached word indices stored in os.\\n        int *os = newArray(int, wordsSize);\\n        for (i = 0; i < wlength; ++i) {\\n            int start = i, found = 0;\\n            for (j = i; j < slength; j += wlength) {\\n                int windex = ms[j];\\n                if (windex < 0) {\\n                    // no matched word here, simply reset the marker,\\n                    // and write back all cached words.\\n                    start = j + wlength;\\n                    while (found > 0) {\\n                        ws[os[--found]].occurs++;\\n                    }\\n                    continue;\\n                }\\n                // move the matched word from word list to cache,\\n                // write back the leading cached words if necessary.\\n                if (ws[windex].occurs == 0) {\\n                    for (k = 0; k < found; ++k) {\\n                        ws[os[k]].occurs++;\\n                        start += wlength;\\n                        if (os[k] == windex) {\\n                            ++k;\\n                            break;\\n                        }\\n                    }\\n                    found -= k;\\n                    if (found)\\n                        memmove(os, os + k, found * sizeof(*os));\\n                }\\n                ws[windex].occurs--;\\n                os[found++] = windex;\\n                // push the marker position if matched all words.\\n                if (found == wordsSize)\\n                    result = pushback(result, returnSize, start);\\n            }\\n            // after scanning, write back all cached words.\\n            while (found > 0) {\\n                ws[os[--found]].occurs++;\\n            }\\n        }\\n    \\n        free(ws);\\n        free(ms);\\n        free(os);\\n    \\n        return result;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/45050/accepted-java-o-n-solution-using-histogram",
                "codeTag": "Python3"
            },
            {
                "id": 13823,
                "title": "my-java-solution-with-recursion",
                "content": "    public class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (s==null || words.length == 0){\\n                return result;\\n            }\\n           \\n            HashMap<String, Integer> allWords = new HashMap<String, Integer>();\\n            for (int i=0;i<words.length;i++){\\n            \\tString w = words[i];\\n            \\tif (!allWords.containsKey(w)){\\n            \\t\\tallWords.put(w, 1);\\n            \\t}\\n            \\telse{\\n            \\t\\tInteger count = allWords.get(w);\\n            \\t\\tcount++;\\n            \\t\\tallWords.put(w, count);\\n            \\t}\\n            }\\n            int wordLength = words[0].length();\\n            int length = words.length*wordLength;\\n            for (int i=0;i<=s.length()-length;i++){\\n            \\tboolean b = findWords(s, i, (Map)allWords.clone(), wordLength);\\n            \\tif (b){\\n            \\t\\tresult.add(i);\\n            \\t}\\n            }\\n            return result;\\n    \\t}\\n    \\t\\n    \\tprivate boolean findWords(String s, int startIndex, Map<String, Integer> allWords, int wordLength){\\n    \\t\\tif (allWords.isEmpty()){\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\tString s1 = s.substring(startIndex, startIndex+wordLength);\\n    \\t\\tif (allWords.containsKey(s1)){\\n    \\t\\t\\tint result = allWords.get(s1);\\n    \\t\\t\\tresult--;\\n    \\t\\t\\tif (result == 0){\\n    \\t\\t\\t\\tallWords.remove(s1);\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tallWords.put(s1, result);\\n    \\t\\t\\t}\\n    \\t\\t\\treturn findWords(s, startIndex+wordLength, allWords, wordLength);\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (s==null || words.length == 0){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13825,
                "title": "my-c-code-with-hashtable-with-queue-for-o-n-runtime-71ms-runtime",
                "content": "I would like share my linear solution with HashTable and Queue with runtime only 71ms. The Queue is used to store the last appearance position of the first word of that type. You need to update the Queue each time.\\n\\n   \\n\\n    vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> res;\\n            if (L.size() == 0) return res;\\n            if (S.size() == 0) return res;\\n            int wordLen = L[0].size();\\n            if (S.size() < wordLen) return res;\\n            \\n            unordered_map<string, queue<int> > wordhash; // word and appearing positions.\\n            unordered_map<string, queue<int> >::iterator it;\\n            queue<int> Q;\\n            Q.push(-1);\\n            for (int i = 0; i<L.size(); ++i) {\\n                it = wordhash.find(L[i]);\\n                if (it == wordhash.end()) {\\n                    wordhash[L[i]] = Q;\\n                } else {\\n                    it->second.push(-1);\\n                }\\n            }\\n            unordered_map<string, queue<int> > temp = wordhash;\\n            for (int i = 0; i<wordLen; ++i) {\\n                int currWordCnt = 0;\\n                wordhash = temp;\\n                for (int index = i; index<=S.size()-wordLen; index += wordLen) {\\n                    it = wordhash.find(S.substr(index, wordLen));\\n                    if (it == wordhash.end()) {\\n                        currWordCnt = 0;\\n                    } else {\\n                        int lastPos = it->second.front();\\n                        if (lastPos == -1) {\\n                            currWordCnt++;\\n                        } else if (currWordCnt*wordLen < index-lastPos) {\\n                            currWordCnt++;\\n                        } else {\\n                            currWordCnt = (index-lastPos)/wordLen;\\n                        }\\n                        it->second.pop();\\n                        it->second.push(index);\\n                        if (currWordCnt == L.size()) {\\n                            res.push_back(index-wordLen*(L.size()-1));\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }",
                "solutionTags": [
                    "Queue"
                ],
                "code": "I would like share my linear solution with HashTable and Queue with runtime only 71ms. The Queue is used to store the last appearance position of the first word of that type. You need to update the Queue each time.\\n\\n   \\n\\n    vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> res;\\n            if (L.size() == 0) return res;\\n            if (S.size() == 0) return res;\\n            int wordLen = L[0].size();\\n            if (S.size() < wordLen) return res;\\n            \\n            unordered_map<string, queue<int> > wordhash; // word and appearing positions.\\n            unordered_map<string, queue<int> >::iterator it;\\n            queue<int> Q;\\n            Q.push(-1);\\n            for (int i = 0; i<L.size(); ++i) {\\n                it = wordhash.find(L[i]);\\n                if (it == wordhash.end()) {\\n                    wordhash[L[i]] = Q;\\n                } else {\\n                    it->second.push(-1);\\n                }\\n            }\\n            unordered_map<string, queue<int> > temp = wordhash;\\n            for (int i = 0; i<wordLen; ++i) {\\n                int currWordCnt = 0;\\n                wordhash = temp;\\n                for (int index = i; index<=S.size()-wordLen; index += wordLen) {\\n                    it = wordhash.find(S.substr(index, wordLen));\\n                    if (it == wordhash.end()) {\\n                        currWordCnt = 0;\\n                    } else {\\n                        int lastPos = it->second.front();\\n                        if (lastPos == -1) {\\n                            currWordCnt++;\\n                        } else if (currWordCnt*wordLen < index-lastPos) {\\n                            currWordCnt++;\\n                        } else {\\n                            currWordCnt = (index-lastPos)/wordLen;\\n                        }\\n                        it->second.pop();\\n                        it->second.push(index);\\n                        if (currWordCnt == L.size()) {\\n                            res.push_back(index-wordLen*(L.size()-1));\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3732123,
                "title": "easy-solution-with-o-n-tc",
                "content": "# Intuition\\nWe can reduce the Time Complexity to O(N) by checking for starting points only lets asume if we are at index i and if this is starting point of a string then next string will start from i+k, each required substring will start from : P+ MxK\\nwhere 0<=P<K and m is some int, K is length of individual string\\n\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string,int> cnt,record;\\n        for(auto w: words) cnt[w]++;\\n        vector <int> ans;\\n        int n = s.size(),m = words.size(),k = words[0].size();\\n        \\n        for(int P = 0;P < k;P++){\\n            int left =P;int sum = 0;record.clear();\\n            for(int j = P;j <=n - k;j+=k){\\n                string tmp = s.substr(j,k);\\n                if(cnt.count(tmp)){\\n                    record[tmp]++;sum++;\\n                    while(record[tmp] > cnt[tmp]){\\n                        string rem = s.substr(left,k);\\n                        record[rem]--;\\n                        if(record[rem]==0) record.erase(rem);\\n                        left += k;\\n                        sum--;\\n                    }\\n                    if(sum==m){\\n                        ans.push_back(left);\\n                    }\\n                }else{\\n                    left = j+k;\\n                    record.clear();\\n                    sum=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string,int> cnt,record;\\n        for(auto w: words) cnt[w]++;\\n        vector <int> ans;\\n        int n = s.size(),m = words.size(),k = words[0].size();\\n        \\n        for(int P = 0;P < k;P++){\\n            int left =P;int sum = 0;record.clear();\\n            for(int j = P;j <=n - k;j+=k){\\n                string tmp = s.substr(j,k);\\n                if(cnt.count(tmp)){\\n                    record[tmp]++;sum++;\\n                    while(record[tmp] > cnt[tmp]){\\n                        string rem = s.substr(left,k);\\n                        record[rem]--;\\n                        if(record[rem]==0) record.erase(rem);\\n                        left += k;\\n                        sum--;\\n                    }\\n                    if(sum==m){\\n                        ans.push_back(left);\\n                    }\\n                }else{\\n                    left = j+k;\\n                    record.clear();\\n                    sum=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580379,
                "title": "simple-o-n-solution-typescript-regex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRather than doing a recursive solution, it seemed simpler and more efficient to use a moving window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize the `right` pointer as the lentgh of all the `words` items lengths.\\n\\nFor each letter in the `s` string, create a substring from `i` to the `right` pointer, and run a RegEx to break up the result string into an array, where each item length is equal to the `words[0]` length. Sort the array, and compare the string values of both arrays. If they match, save the `i` index.\\n\\nRetun results.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findSubstring(s: string, words: string[]): number[] {\\n    words.sort();\\n    let right = words.reduce((acc, curr) => acc += curr.length, 0);\\n    const results = [];\\n    for (let i = 0 ; right < s.length + 1 ; i++, right++) {\\n        let subString = s.substring(i, right).match(new RegExp(`.{1,${words[0].length}}`, \\'g\\')).sort();\\n        if (JSON.stringify(subString) === JSON.stringify(words)) results.push(i)\\n    };\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "String Matching"
                ],
                "code": "```\\nfunction findSubstring(s: string, words: string[]): number[] {\\n    words.sort();\\n    let right = words.reduce((acc, curr) => acc += curr.length, 0);\\n    const results = [];\\n    for (let i = 0 ; right < s.length + 1 ; i++, right++) {\\n        let subString = s.substring(i, right).match(new RegExp(`.{1,${words[0].length}}`, \\'g\\')).sort();\\n        if (JSON.stringify(subString) === JSON.stringify(words)) results.push(i)\\n    };\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565841,
                "title": "not-easy-but-you-can-take-a-look",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> res;\\n        if (words.empty()) return res;\\n        int n = s.size(), m = words.size(), k = words[0].size();\\n        unordered_map<string, int> mp;\\n        for (string& word : words) mp[word]++;\\n        for (int i = 0; i < k; i++) {\\n            int left = i, count = 0;\\n            unordered_map<string, int> t;\\n            for (int j = i; j <= n - k; j += k) {\\n                string str = s.substr(j, k);\\n                if (mp.count(str)) {\\n                    t[str]++;\\n                    if (t[str] <= mp[str]) count++;\\n                    else {\\n                        while (t[str] > mp[str]) {\\n                            string str1 = s.substr(left, k);\\n                            t[str1]--;\\n                            if (t[str1] < mp[str1]) count--;\\n                            left += k;\\n                        }\\n                    }\\n                    if (count == m) {\\n                        res.push_back(left);\\n                        t[s.substr(left, k)]--;\\n                        count--;\\n                        left += k;\\n                    }\\n                } else {\\n                    t.clear();\\n                    count = 0;\\n                    left = j + k;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nUpvote if you understood.\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> res;\\n        if (words.empty()) return res;\\n        int n = s.size(), m = words.size(), k = words[0].size();\\n        unordered_map<string, int> mp;\\n        for (string& word : words) mp[word]++;\\n        for (int i = 0; i < k; i++) {\\n            int left = i, count = 0;\\n            unordered_map<string, int> t;\\n            for (int j = i; j <= n - k; j += k) {\\n                string str = s.substr(j, k);\\n                if (mp.count(str)) {\\n                    t[str]++;\\n                    if (t[str] <= mp[str]) count++;\\n                    else {\\n                        while (t[str] > mp[str]) {\\n                            string str1 = s.substr(left, k);\\n                            t[str1]--;\\n                            if (t[str1] < mp[str1]) count--;\\n                            left += k;\\n                        }\\n                    }\\n                    if (count == m) {\\n                        res.push_back(left);\\n                        t[s.substr(left, k)]--;\\n                        count--;\\n                        left += k;\\n                    }\\n                } else {\\n                    t.clear();\\n                    count = 0;\\n                    left = j + k;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nUpvote if you understood.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952804,
                "title": "well-explained-code-in-java-with-space-and-time-complexity",
                "content": "**UPVOTE IF YOU LIKED THE SOLUTION!**\\n# Approach\\nThe code is a solution in Java that returns the starting indices of all concatenated substrings in a given input string. The function takes in two arguments: a string s and an array of strings words.\\n\\nThe function first handles an edge case where the input string is empty or the array of words is empty, in which case it returns an empty list. It then initializes a list to store the starting indices of the concatenated substrings and a map to store the counts of each word in the words array. The function then loops through the words array and increments the count for each word in the map.\\n\\nNext, the function initializes a map to store the counts of each word in the current substring and variables to keep track of the length of each word and the total length of all the words. It then loops through the input string, checking for concatenated substrings at each position. For each position, it clears the current counts map and loops through the words in the current substring, updating their counts in the current counts map.\\n\\nFinally, the function checks if the current counts map is equal to the original word counts map using the equals() method. If they are equal, it means that the current substring is a concatenation of all the words in the words array, so the function adds the starting index of the current substring to the list of indices.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n * m), where n is the length of the input string and m is the total length of all the words in the words array. The outer loop iterates through the input string with a time complexity of O(n), and the inner loop iterates through the words in the current substring with a time complexity of O(m).\\n\\n- Space complexity:\\nThe space complexity is O(m), because it stores the counts of each word in the words array in a map.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n    // Edge case: return an empty list if the input string is empty or the array of words is empty\\n    if (s.isEmpty() || words.length == 0) {\\n      return new ArrayList<>();\\n    }\\n\\n    // Initialize a list to store the starting indices of the concatenated substrings\\n    List<Integer> indices = new ArrayList<>();\\n\\n    // Initialize a map to store the counts of each word in the array of words\\n    Map<String, Integer> wordCounts = new HashMap<>();\\n    for (String word : words) {\\n      wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\\n    }\\n\\n    // Initialize a map to store the counts of each word in the current substring\\n    Map<String, Integer> currentCounts = new HashMap<>();\\n\\n    // Initialize variables to keep track of the length of each word and the total length of all the words\\n    int wordLength = words[0].length();\\n    int totalLength = wordLength * words.length;\\n\\n    // Loop through the input string, checking for concatenated substrings at each position\\n    for (int i = 0; i < s.length() - totalLength + 1; i++) {\\n      // Initialize the current counts map for the new substring\\n      currentCounts.clear();\\n\\n      // Loop through the words in the current substring and update their counts in the current counts map\\n      for (int j = 0; j < words.length; j++) {\\n        String word = s.substring(i + j * wordLength, i + (j + 1) * wordLength);\\n        currentCounts.put(word, currentCounts.getOrDefault(word, 0) + 1);\\n      }\\n\\n      // Check if the current counts map is equal to the original word counts map\\n      if (currentCounts.equals(wordCounts)) {\\n        // If they are equal, add the starting index of the current substring to the list of indices\\n        indices.add(i);\\n      }\\n    }\\n\\n    // Return the list of indices\\n    return indices;\\n  }\\n}\\n\\n    \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n    // Edge case: return an empty list if the input string is empty or the array of words is empty\\n    if (s.isEmpty() || words.length == 0) {\\n      return new ArrayList<>();\\n    }\\n\\n    // Initialize a list to store the starting indices of the concatenated substrings\\n    List<Integer> indices = new ArrayList<>();\\n\\n    // Initialize a map to store the counts of each word in the array of words\\n    Map<String, Integer> wordCounts = new HashMap<>();\\n    for (String word : words) {\\n      wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\\n    }\\n\\n    // Initialize a map to store the counts of each word in the current substring\\n    Map<String, Integer> currentCounts = new HashMap<>();\\n\\n    // Initialize variables to keep track of the length of each word and the total length of all the words\\n    int wordLength = words[0].length();\\n    int totalLength = wordLength * words.length;\\n\\n    // Loop through the input string, checking for concatenated substrings at each position\\n    for (int i = 0; i < s.length() - totalLength + 1; i++) {\\n      // Initialize the current counts map for the new substring\\n      currentCounts.clear();\\n\\n      // Loop through the words in the current substring and update their counts in the current counts map\\n      for (int j = 0; j < words.length; j++) {\\n        String word = s.substring(i + j * wordLength, i + (j + 1) * wordLength);\\n        currentCounts.put(word, currentCounts.getOrDefault(word, 0) + 1);\\n      }\\n\\n      // Check if the current counts map is equal to the original word counts map\\n      if (currentCounts.equals(wordCounts)) {\\n        // If they are equal, add the starting index of the current substring to the list of indices\\n        indices.add(i);\\n      }\\n    }\\n\\n    // Return the list of indices\\n    return indices;\\n  }\\n}\\n\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792019,
                "title": "c-unordered-map-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> findSubstring(string s, vector<string>& words) {\\n\\t\\t\\tunordered_map<string, int>m;\\n\\t\\t\\tint sz=0, len=words[0].size();\\n\\t\\t\\tfor(int i=0; i<words.size(); i++){\\n\\t\\t\\t\\tm[words[i]]++;\\n\\t\\t\\t\\tsz+=words[i].size();\\n\\t\\t\\t}\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0; i<s.size()-sz+1; i++){\\n\\t\\t\\t\\tunordered_map<string, int>m1(m);\\n\\t\\t\\t\\t//vector<int>v;\\n\\t\\t\\t\\tint i1=i, j1=i+sz-1;\\n\\t\\t\\t\\t//cout<<i1<<\" \"<<j1<<endl;\\n\\t\\t\\t\\twhile(i1<=j1){\\n\\t\\t\\t\\t\\t//cout<<s.substr(i1, len)<<\" \"<<i1<<endl;\\n\\t\\t\\t\\t\\tif(m1[s.substr(i1, len)]>0){\\n\\t\\t\\t\\t\\t\\t//v.push_back(i1);\\n\\t\\t\\t\\t\\t\\t//cout<<s.substr(i1, len)<<\" \"<<i1<<endl;\\n\\t\\t\\t\\t\\t\\tm1[s.substr(i1, len)]--;\\n\\t\\t\\t\\t\\t\\tif(m1[s.substr(i1, len)]==0){\\n\\t\\t\\t\\t\\t\\t\\tm1.erase(s.substr(i1, len));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t//cout<<\"here\"<<endl;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti1+=len;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//cout<<m1.size()<<endl;\\n\\t\\t\\t\\tif(m1.size()==0){ans.push_back(i);}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> findSubstring(string s, vector<string>& words) {\\n\\t\\t\\tunordered_map<string, int>m;\\n\\t\\t\\tint sz=0, len=words[0].size();\\n\\t\\t\\tfor(int i=0; i<words.size(); i++){\\n\\t\\t\\t\\tm[words[i]]++;\\n\\t\\t\\t\\tsz+=words[i].size();\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2782961,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/substring-with-concatenation-of-all.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar findSubstring = function (s, words) {\\n    // Initialise an array to store our answers in\\n    let answers = [];\\n\\n    // Calculate the total length of the words\\n    const totalLengthOfWords = words.reduce(\\n        (total, word) => (total += word.length),\\n        0\\n    );\\n\\n    // Loop through the string, until there is insufficient space left to find all words\\n    for (let i = 0; i <= s.length - totalLengthOfWords; i++) {\\n        // If the string from this point contains all target words, store the starting position\\n        if (doesStringContainAllWords(s.substring(i), words.slice())) {\\n            answers.push(i);\\n        }\\n    }\\n\\n    return answers;\\n};\\n\\nfunction doesStringContainAllWords(string, words) {\\n    // If all words have been found\\n    if (!words.length) return true;\\n\\n    // Loop through all words\\n    for (let i = 0; i < words.length; i++) {\\n        // Store the length of the target word (as it may be spliced)\\n        const targetWordLength = words[i].length;\\n\\n        // Check if the word in question matches is found at the start of the string\\n        if (string.substring(0, targetWordLength) === words[i]) {\\n            // Remove the found word from the words array\\n            words.splice(i, 1);\\n\\n            // Look for the remaining words in the rest of the string\\n            return doesStringContainAllWords(\\n                string.substring(targetWordLength),\\n                words\\n            );\\n        }\\n    }\\n\\n    // If no words were found in the current string\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findSubstring = function (s, words) {\\n    // Initialise an array to store our answers in\\n    let answers = [];\\n\\n    // Calculate the total length of the words\\n    const totalLengthOfWords = words.reduce(\\n        (total, word) => (total += word.length),\\n        0\\n    );\\n\\n    // Loop through the string, until there is insufficient space left to find all words\\n    for (let i = 0; i <= s.length - totalLengthOfWords; i++) {\\n        // If the string from this point contains all target words, store the starting position\\n        if (doesStringContainAllWords(s.substring(i), words.slice())) {\\n            answers.push(i);\\n        }\\n    }\\n\\n    return answers;\\n};\\n\\nfunction doesStringContainAllWords(string, words) {\\n    // If all words have been found\\n    if (!words.length) return true;\\n\\n    // Loop through all words\\n    for (let i = 0; i < words.length; i++) {\\n        // Store the length of the target word (as it may be spliced)\\n        const targetWordLength = words[i].length;\\n\\n        // Check if the word in question matches is found at the start of the string\\n        if (string.substring(0, targetWordLength) === words[i]) {\\n            // Remove the found word from the words array\\n            words.splice(i, 1);\\n\\n            // Look for the remaining words in the rest of the string\\n            return doesStringContainAllWords(\\n                string.substring(targetWordLength),\\n                words\\n            );\\n        }\\n    }\\n\\n    // If no words were found in the current string\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681911,
                "title": "using-hashmap",
                "content": "```class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len=words[0].size();\\n        int noofWords=words.size();\\n        vector<int> ans;\\n        unordered_map<string,int> umap;\\n        if(len*noofWords>s.length())\\n        {\\n            return ans;\\n        }\\n        for(string word:words)\\n        {\\n            umap[word]++;\\n        }\\n        for(int i=0;i<=s.length()-(noofWords*len);i++)\\n        {\\n            unordered_map<string,int> mp;\\n            for(int j=i;j<i+(noofWords*len);j+=len)\\n            {\\n                string str=s.substr(j,len);\\n                if(umap.find(str)==mp.end())break;\\n                else\\n                {\\n                    mp[str]++;\\n                }\\n                if(mp[str]>umap[str])break;\\n            }\\n            if(mp==umap)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n      \\n};\\n```\\n**UPVOTE IF U FOUND IT HELPFUL**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len=words[0].size();\\n        int noofWords=words.size();\\n        vector<int> ans;\\n        unordered_map<string,int> umap;\\n        if(len*noofWords>s.length())\\n        {\\n            return ans;\\n        }\\n        for(string word:words)\\n        {\\n            umap[word]++;\\n        }\\n        for(int i=0;i<=s.length()-(noofWords*len);i++)\\n        {\\n            unordered_map<string,int> mp;\\n            for(int j=i;j<i+(noofWords*len);j+=len)\\n            {\\n                string str=s.substr(j,len);\\n                if(umap.find(str)==mp.end())break;\\n                else\\n                {\\n                    mp[str]++;\\n                }\\n                if(mp[str]>umap[str])break;\\n            }\\n            if(mp==umap)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419835,
                "title": "c-most-optimal-solution-beats-96-easy-readable-and-commented-code",
                "content": "```\\nclass Solution {\\n\\t// function to remove a word from usedWords hasmap\\n    void remove(unordered_map<string, int> &hashmap, string &key)\\n    {\\n        hashmap[key]--;\\n        if(hashmap[key] <= 0)\\n            hashmap.erase(key);\\n    }\\n    \\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> wordDict;\\n        unordered_map<string, int> usedWords;\\n        int word_len = words[0].length(), total_words = words.size();\\n        int left = 0, right = 0, n = s.length();\\n        int words_used = 0;\\n        vector<int> ans;\\n        \\n\\t\\t// wordDict contains all words with their frequencies\\n        for(auto &word: words)\\n            wordDict[word]++;\\n        \\n\\t\\t// We iterate staring from every index in range [0, word_len] to get every possible combination\\n        for(int i=0; i<word_len; i++)\\n        {\\n\\t\\t\\t// right pointer is used to expand the current window and \\n\\t\\t\\t// left pointer is used to shrink the current window whenever the window becomes invalid\\n            left = i, right = i;\\n            usedWords.clear();\\n            words_used = 0;\\n\\t\\t\\t\\n\\t\\t\\t// We start iterating till end of string\\n\\t\\t\\t// Once we pick a word of length \\'word_len\\' then we go to next index = \\'right + word_len\\'\\n            while(right < n)\\n            {\\n                auto curr = s.substr(right, min(n-right, word_len));\\n                \\n\\t\\t\\t\\t// If the curr picked word does not exist in the words array given to us then the current window is no longer usefull and so we discard all the words we have used untill now and increment our right and left pointer to point to the next word in sequence\\n                if(wordDict.find(curr) == wordDict.end())\\n                {\\n                    usedWords.clear();\\n                    words_used = 0;\\n                    right += word_len;\\n                    left = right;\\n                    continue;\\n                }\\n                \\n\\t\\t\\t\\t// If freq of curr word is less then required freq of that word we can add it to our usedWords and also increment the no of words that we have used in the current window\\n                if(usedWords[curr] < wordDict[curr])\\n                    usedWords[curr]++, words_used++;\\n\\t\\t\\t\\t// If the freq gets higher then we start removing words from the begining of window until the window becomes valid again\\n                else\\n                {\\n                    while(left < right)\\n                    {\\n                        auto to_remove = s.substr(left, word_len);\\n                        remove(usedWords, to_remove);\\n                        words_used--;\\n                        left += word_len;\\n                        if(usedWords[curr] < wordDict[curr])\\n                            break;\\n                    }\\n\\t\\t\\t\\t\\t// Now the window has becomes valid so we can add the curr word to the usedWords\\n                    usedWords[curr]++, words_used++;\\n                }\\n                right += word_len;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if the words of our current window get equal to the total words required the we can add the index of the starting of the window(left pointer) to our answer array and move the left pointer one step forward.\\n\\t\\t\\t\\t// We cant set the left pointer to point to right because we might have an answer starting from \\'left+word_len\\'. So we only increment it one step forward.\\n                if(words_used == total_words)\\n                {                    \\n                    ans.push_back(left);\\n                    auto to_remove = s.substr(left, word_len);\\n                    remove(usedWords, to_remove);\\n                    words_used--;\\n                    left += word_len;\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nTC: O(n * word_len)\\nwhere n = length of string s\\nword_len = length of word[i] (max value = 30)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\t// function to remove a word from usedWords hasmap\\n    void remove(unordered_map<string, int> &hashmap, string &key)\\n    {\\n        hashmap[key]--;\\n        if(hashmap[key] <= 0)\\n            hashmap.erase(key);\\n    }\\n    \\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> wordDict;\\n        unordered_map<string, int> usedWords;\\n        int word_len = words[0].length(), total_words = words.size();\\n        int left = 0, right = 0, n = s.length();\\n        int words_used = 0;\\n        vector<int> ans;\\n        \\n\\t\\t// wordDict contains all words with their frequencies\\n        for(auto &word: words)\\n            wordDict[word]++;\\n        \\n\\t\\t// We iterate staring from every index in range [0, word_len] to get every possible combination\\n        for(int i=0; i<word_len; i++)\\n        {\\n\\t\\t\\t// right pointer is used to expand the current window and \\n\\t\\t\\t// left pointer is used to shrink the current window whenever the window becomes invalid\\n            left = i, right = i;\\n            usedWords.clear();\\n            words_used = 0;\\n\\t\\t\\t\\n\\t\\t\\t// We start iterating till end of string\\n\\t\\t\\t// Once we pick a word of length \\'word_len\\' then we go to next index = \\'right + word_len\\'\\n            while(right < n)\\n            {\\n                auto curr = s.substr(right, min(n-right, word_len));\\n                \\n\\t\\t\\t\\t// If the curr picked word does not exist in the words array given to us then the current window is no longer usefull and so we discard all the words we have used untill now and increment our right and left pointer to point to the next word in sequence\\n                if(wordDict.find(curr) == wordDict.end())\\n                {\\n                    usedWords.clear();\\n                    words_used = 0;\\n                    right += word_len;\\n                    left = right;\\n                    continue;\\n                }\\n                \\n\\t\\t\\t\\t// If freq of curr word is less then required freq of that word we can add it to our usedWords and also increment the no of words that we have used in the current window\\n                if(usedWords[curr] < wordDict[curr])\\n                    usedWords[curr]++, words_used++;\\n\\t\\t\\t\\t// If the freq gets higher then we start removing words from the begining of window until the window becomes valid again\\n                else\\n                {\\n                    while(left < right)\\n                    {\\n                        auto to_remove = s.substr(left, word_len);\\n                        remove(usedWords, to_remove);\\n                        words_used--;\\n                        left += word_len;\\n                        if(usedWords[curr] < wordDict[curr])\\n                            break;\\n                    }\\n\\t\\t\\t\\t\\t// Now the window has becomes valid so we can add the curr word to the usedWords\\n                    usedWords[curr]++, words_used++;\\n                }\\n                right += word_len;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if the words of our current window get equal to the total words required the we can add the index of the starting of the window(left pointer) to our answer array and move the left pointer one step forward.\\n\\t\\t\\t\\t// We cant set the left pointer to point to right because we might have an answer starting from \\'left+word_len\\'. So we only increment it one step forward.\\n                if(words_used == total_words)\\n                {                    \\n                    ans.push_back(left);\\n                    auto to_remove = s.substr(left, word_len);\\n                    remove(usedWords, to_remove);\\n                    words_used--;\\n                    left += word_len;\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nTC: O(n * word_len)\\nwhere n = length of string s\\nword_len = length of word[i] (max value = 30)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419138,
                "title": "c-using-sliding-window-approach-easy-solution",
                "content": "Approach\\n*  In this question we\\'ve to return all start index of substring in s that form is a concatenation of each word in words\\n*  We solve this question using Sliding window approach and Hashing\\n   for example:\\n   s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"];\\n   check \"bar\" is available in  words or not\\n*  We\\'ll stored frequency in freq map\\n*  Then we\\'ll run a from i=0 to s.size()-(m*n) because  \\n    s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]; \\n\\ti=10 then only 3 character left but we\\'ve to find 4 character so in this case we run our loop till s.size()-(m*n)\\n*  then create a temporary map that store frequency of words we\\'ll erase frequency to that word  when we got word\\n*   string substre=s.substr(i+m*j,m); This will give us string that we compare with map with if it is present then we\\'ll erase that word from map or it is not present then we\\'ll break the loop\\n*  if j==n it mean we find n character so we\\'ll push in res vector\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n       vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size();\\n        unordered_map<string,int> freq;\\n        for(auto i:words)\\n        {\\n            freq[i]++;\\n        }\\n        if(s.size()==0||s.size()<n*m)\\n        {\\n            return res;\\n        }\\n        for(int i=0;i<=s.size()-(m*n);i++)\\n        {\\n            unordered_map<string,int> ourfreq=freq;\\n            int j;\\n            for( j=0;j<n;j++)\\n            {\\n                \\n                string substre=s.substr(i+m*j,m);\\n                \\n                if(ourfreq[substre]==0)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    ourfreq[substre]--;\\n                }\\n                \\n            }\\n            cout<<endl;\\n            if(j==n)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n       vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size();\\n        unordered_map<string,int> freq;\\n        for(auto i:words)\\n        {\\n            freq[i]++;\\n        }\\n        if(s.size()==0||s.size()<n*m)\\n        {\\n            return res;\\n        }\\n        for(int i=0;i<=s.size()-(m*n);i++)\\n        {\\n            unordered_map<string,int> ourfreq=freq;\\n            int j;\\n            for( j=0;j<n;j++)\\n            {\\n                \\n                string substre=s.substr(i+m*j,m);\\n                \\n                if(ourfreq[substre]==0)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    ourfreq[substre]--;\\n                }\\n                \\n            }\\n            cout<<endl;\\n            if(j==n)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2418534,
                "title": "6-ms-faster-than-97-hashmap-sliding-window-golang",
                "content": "I\\'m a new user of Golang, so if there any part where it can be improved, please let me know ^^.\\n\\n- The main idea is that, if we put each string in ```words``` into the hashmap ```cnt```, we would get some kind of frequency table. Thus, a range that satisfy the statement condition, must have the frequency of each word match our frequency table ```cnt``` right?\\n- Now, applying sliding window, we will slide a window through ```s```.\\n- Since each word in ```words``` has the same length (the problem will be a lot more difficult if they are of different length), we can slide the window through that length, and remove the rightmost string from ```cnt``` (remember if the leftmost string go out of the window, add that string to the ```cnt``` again). \\n- If at a point, every key in ```cnt``` has the value 0, that means the current window satisfy the statement condition. Thus we can simply add the current window into ```ans```.\\n- One small problem, we might need to offset our range from ```0``` to ```len(words[0])```, since otherwise, we might miss some ranges from our answer.\\n- The rest is just implementation detail\\n```\\nfunc findSubstring(s string, words []string) []int {\\n    ans := make([]int, 0) // Initialize the answer as a slice\\n    cnt, dif := make(map[string]int), 0 // Create the hashmap, also count the different elements in words\\n        for _, curString := range words {\\n            cnt[curString]++;\\n            if cnt[curString] == 1 {\\n                dif++\\n            }\\n        }\\n    sz, totSz := len(words[0]), len(words[0]) * len(words) // Initialize some length for sliding window\\n    for st := 0; st < sz; st++ { // Offset\\n        for k := range cnt { // Reset the map\\n            delete(cnt, k)\\n        }\\n        for _, curString := range words {\\n            cnt[curString]++;\\n        }        \\n        \\n        cntOk := 0 // Number of key in cnt has the value 0\\n        for i := st; i + sz - 1 < len(s); i += sz {\\n            if i >= totSz { // Remove the left part\\n                cur := s[i-totSz:i-totSz+sz]\\n                if _, ok := cnt[cur]; ok {\\n                    cnt[cur]++\\n                    if cnt[cur] == 1 {\\n                        cntOk--\\n                    }\\n                }\\n            }\\n            cur := s[i:i+sz]; // Insert the right part\\n            if _, ok := cnt[cur]; ok {\\n                cnt[cur]--\\n                if cnt[cur] == 0 {\\n                    cntOk++\\n                }\\n            }\\n            if cntOk == dif { // If everything is good\\n                ans = append(ans, i - totSz + sz) // Then add the current range into the answer\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```words```\n```cnt```\n```cnt```\n```s```\n```words```\n```cnt```\n```cnt```\n```cnt```\n```ans```\n```0```\n```len(words[0])```\n```\\nfunc findSubstring(s string, words []string) []int {\\n    ans := make([]int, 0) // Initialize the answer as a slice\\n    cnt, dif := make(map[string]int), 0 // Create the hashmap, also count the different elements in words\\n        for _, curString := range words {\\n            cnt[curString]++;\\n            if cnt[curString] == 1 {\\n                dif++\\n            }\\n        }\\n    sz, totSz := len(words[0]), len(words[0]) * len(words) // Initialize some length for sliding window\\n    for st := 0; st < sz; st++ { // Offset\\n        for k := range cnt { // Reset the map\\n            delete(cnt, k)\\n        }\\n        for _, curString := range words {\\n            cnt[curString]++;\\n        }        \\n        \\n        cntOk := 0 // Number of key in cnt has the value 0\\n        for i := st; i + sz - 1 < len(s); i += sz {\\n            if i >= totSz { // Remove the left part\\n                cur := s[i-totSz:i-totSz+sz]\\n                if _, ok := cnt[cur]; ok {\\n                    cnt[cur]++\\n                    if cnt[cur] == 1 {\\n                        cntOk--\\n                    }\\n                }\\n            }\\n            cur := s[i:i+sz]; // Insert the right part\\n            if _, ok := cnt[cur]; ok {\\n                cnt[cur]--\\n                if cnt[cur] == 0 {\\n                    cntOk++\\n                }\\n            }\\n            if cntOk == dif { // If everything is good\\n                ans = append(ans, i - totSz + sz) // Then add the current range into the answer\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2418153,
                "title": "python-fastest-solution-explained",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        # remove empty cases\\n        if not s or words==[]:\\n            return []  \\n        len_str=len(s)\\n        len_word=len(words[0])\\n        len_substr=len(words)*len_word\\n\\n        # creating dict of the number of appearance that should be in s for each word\\n        appearance={}\\n        for word in words:\\n            if word in appearance:\\n                appearance[word]+=1\\n            else:\\n                appearance[word]=1\\n\\n        ans=[]\\n        for str_start in range(min(len_word,len_str-len_substr+1)):\\n            ans += self.findAnswer(str_start,len_word,len_substr,s,appearance)\\n        return ans\\n\\n\\n    def findAnswer(self,str_start,len_word,len_substr,s,appearance):\\n        word_start=str_start\\n        curr_appearance={}\\n        res = []\\n\\n        while str_start + len_substr <= len(s):\\n            word = s[word_start:word_start+len_word]\\n            word_start += len_word\\n            # if we encountered word that is not in words, start checking again\\n            if word not in appearance:\\n                str_start=word_start\\n                curr_appearance.clear()\\n\\n            else:\\n                # add the word to the current appearance\\n                if word in curr_appearance:\\n                    curr_appearance[word]+=1\\n                else:\\n                    curr_appearance[word]=1\\n\\n                # as long as this word appears in our counting more than it should, \\n                # update the substring to be one less word, until we reach to\\n                # this word (sub 1 from the count of the first word count again)\\n                while curr_appearance[word] > appearance[word]:\\n                    curr_appearance[s[str_start:str_start+len_word]]-=1\\n                    str_start += len_word\\n\\n                # if we handled the last word missing in substring- we found res!\\n                if word_start-str_start==len_substr:\\n                    res.append(str_start)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        # remove empty cases\\n        if not s or words==[]:\\n            return []  \\n        len_str=len(s)\\n        len_word=len(words[0])\\n        len_substr=len(words)*len_word\\n\\n        # creating dict of the number of appearance that should be in s for each word\\n        appearance={}\\n        for word in words:\\n            if word in appearance:\\n                appearance[word]+=1\\n            else:\\n                appearance[word]=1\\n\\n        ans=[]\\n        for str_start in range(min(len_word,len_str-len_substr+1)):\\n            ans += self.findAnswer(str_start,len_word,len_substr,s,appearance)\\n        return ans\\n\\n\\n    def findAnswer(self,str_start,len_word,len_substr,s,appearance):\\n        word_start=str_start\\n        curr_appearance={}\\n        res = []\\n\\n        while str_start + len_substr <= len(s):\\n            word = s[word_start:word_start+len_word]\\n            word_start += len_word\\n            # if we encountered word that is not in words, start checking again\\n            if word not in appearance:\\n                str_start=word_start\\n                curr_appearance.clear()\\n\\n            else:\\n                # add the word to the current appearance\\n                if word in curr_appearance:\\n                    curr_appearance[word]+=1\\n                else:\\n                    curr_appearance[word]=1\\n\\n                # as long as this word appears in our counting more than it should, \\n                # update the substring to be one less word, until we reach to\\n                # this word (sub 1 from the count of the first word count again)\\n                while curr_appearance[word] > appearance[word]:\\n                    curr_appearance[s[str_start:str_start+len_word]]-=1\\n                    str_start += len_word\\n\\n                # if we handled the last word missing in substring- we found res!\\n                if word_start-str_start==len_substr:\\n                    res.append(str_start)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418146,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tvector<int> findSubstring(string s, vector<string>& words) \\n    {\\n        vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size(); // each word has the same length;\\n        int t = m*n;           // total letters in words vector \\n        \\n        if(s.size() < t) return res;\\n        \\n        unordered_map<string, int> freq;\\n            \\n        for(auto it:words)\\n            freq[it]++;     // update frequency of each word\\n        \\n        for(int i=0; i<=s.size()-t; i++)\\n        {\\n            unordered_map<string, int> mp = freq;  // new map equivalent to freq map\\n            \\n            int j;\\n            for(j=0; j<s.size(); j++)\\n            {\\n                string temp = s.substr(i+j*m, m); //create string of size m and starting index i+j*m\\n                \\n                if(mp[temp]==0)\\n                    break;\\n                else\\n                    mp[temp]--;\\n            }\\n            if(j==n) //check whether all word in words are in the string or not \\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tvector<int> findSubstring(string s, vector<string>& words) \\n    {\\n        vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size(); // each word has the same length;\\n        int t = m*n;           // total letters in words vector \\n        \\n        if(s.size() < t) return res;\\n        \\n        unordered_map<string, int> freq;\\n            \\n        for(auto it:words)\\n            freq[it]++;     // update frequency of each word\\n        \\n        for(int i=0; i<=s.size()-t; i++)\\n        {\\n            unordered_map<string, int> mp = freq;  // new map equivalent to freq map\\n            \\n            int j;\\n            for(j=0; j<s.size(); j++)\\n            {\\n                string temp = s.substr(i+j*m, m); //create string of size m and starting index i+j*m\\n                \\n                if(mp[temp]==0)\\n                    break;\\n                else\\n                    mp[temp]--;\\n            }\\n            if(j==n) //check whether all word in words are in the string or not \\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2418055,
                "title": "explained-with-comments-c",
                "content": "To get a valid substring , the size of the window has to be words.size()* words[0].size() .So we will check for every window of this size .\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(string &s,int i,int j , unordered_map<string,int> &hm,int len){\\n        \\n        unordered_map<string,int> freq;   // map frequency of each word occuring in this window \\n        int k = i;\\n        while(k<j-len+2){\\n           string str = s.substr(k,len);\\n            freq[str]++;\\n            k+=len;\\n        }\\n        \\n        for(auto i : freq){\\n            if(i.second != hm[i.first])return false;   // if frequency of any word differs from the frequency we want ( stored in hm) return false\\n        }\\n        \\n  \\n        return true;\\n        \\n    }\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n    \\n        \\n       unordered_map<string,int> hm;\\n        for(int k = 0;k<words.size();k++){  // store frequency of words \\n            hm[words[k]]++;\\n        }\\n        \\n      int windowSize = words.size()*(words[0].size());  // take window size such that it cover each word\\n       int i =0,j = windowSize-1;\\n        \\n        vector<int> ans;    // ans vector  \\n        \\n        while(j<s.size()){    // apply sliding window \\n            \\n         if(isPossible(s,i,j,hm,words[0].size()))ans.push_back(i);  // if the window contains all words (see function above)  push the index in ans  \\n            i++;\\n            j++;  \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(string &s,int i,int j , unordered_map<string,int> &hm,int len){\\n        \\n        unordered_map<string,int> freq;   // map frequency of each word occuring in this window \\n        int k = i;\\n        while(k<j-len+2){\\n           string str = s.substr(k,len);\\n            freq[str]++;\\n            k+=len;\\n        }\\n        \\n        for(auto i : freq){\\n            if(i.second != hm[i.first])return false;   // if frequency of any word differs from the frequency we want ( stored in hm) return false\\n        }\\n        \\n  \\n        return true;\\n        \\n    }\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n    \\n        \\n       unordered_map<string,int> hm;\\n        for(int k = 0;k<words.size();k++){  // store frequency of words \\n            hm[words[k]]++;\\n        }\\n        \\n      int windowSize = words.size()*(words[0].size());  // take window size such that it cover each word\\n       int i =0,j = windowSize-1;\\n        \\n        vector<int> ans;    // ans vector  \\n        \\n        while(j<s.size()){    // apply sliding window \\n            \\n         if(isPossible(s,i,j,hm,words[0].size()))ans.push_back(i);  // if the window contains all words (see function above)  push the index in ans  \\n            i++;\\n            j++;  \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417593,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wslen, wlen = len(words), len(words[0])\\n        words, res = Counter(words), []\\n        for i in range(0, len(s) - wslen*wlen + 1):\\n            hmap = words.copy()\\n            for j in range(i, i + wslen*wlen, wlen):\\n                if not hmap[s[j:j + wlen]]:\\n                    break\\n                hmap[s[j:j + wlen]] -= 1\\n            if not any(hmap.values()):\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wslen, wlen = len(words), len(words[0])\\n        words, res = Counter(words), []\\n        for i in range(0, len(s) - wslen*wlen + 1):\\n            hmap = words.copy()\\n            for j in range(i, i + wslen*wlen, wlen):\\n                if not hmap[s[j:j + wlen]]:\\n                    break\\n                hmap[s[j:j + wlen]] -= 1\\n            if not any(hmap.values()):\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417571,
                "title": "c-hashmaps-and-stuff",
                "content": "let wordCharacters = the number of characters in words\\nlet n = the length of s\\n\\ncheck every index up until n - wordCharacters + 1  to see if it is a potential answer.\\n\\n**Tune in LIVE ON TWITCH to watch the solution happen in real time.  Everyday 6pm PT.  Link in profile**\\n\\n\\n\\n```\\nclass Solution {   \\n    bool checkIt(string& s, unordered_map<string,int>& ogMap, int start, int size, int checkSize) {\\n        int i = start;\\n        int n = s.length();\\n        unordered_map<string, int> winMap;\\n        while(i < n) {\\n            string right = s.substr(i, size);\\n            if(ogMap.find(right) == ogMap.end()) return false;\\n            else {\\n                winMap[right]++;\\n                if(winMap[right] > ogMap[right]) return false;\\n                if(winMap == ogMap) return true;\\n                i += size;\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> ans;\\n        int size = words[0].size();\\n        int checkSize = words.size();\\n        int superLen = size*checkSize;\\n        unordered_map<string, int> ogMap;\\n        for(auto& word : words) {\\n            ogMap[word]++;\\n        }\\n        \\n        int n = s.length();\\n        for(int i = 0; i < n - superLen + 1; i++) {\\n            if(checkIt(s, ogMap, i, size, checkSize)) {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {   \\n    bool checkIt(string& s, unordered_map<string,int>& ogMap, int start, int size, int checkSize) {\\n        int i = start;\\n        int n = s.length();\\n        unordered_map<string, int> winMap;\\n        while(i < n) {\\n            string right = s.substr(i, size);\\n            if(ogMap.find(right) == ogMap.end()) return false;\\n            else {\\n                winMap[right]++;\\n                if(winMap[right] > ogMap[right]) return false;\\n                if(winMap == ogMap) return true;\\n                i += size;\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> ans;\\n        int size = words[0].size();\\n        int checkSize = words.size();\\n        int superLen = size*checkSize;\\n        unordered_map<string, int> ogMap;\\n        for(auto& word : words) {\\n            ogMap[word]++;\\n        }\\n        \\n        int n = s.length();\\n        for(int i = 0; i < n - superLen + 1; i++) {\\n            if(checkIt(s, ogMap, i, size, checkSize)) {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417563,
                "title": "java-100-faster-code-with-explanation",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n   public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t/**\\n\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t */\\n\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\treturn res;\\n\\n\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\telse\\n\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t}\\n\\n\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\tString test, temp;\\n\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\tcurDict.clear();\\n\\t\\t\\tstart = i;\\n\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\tres.add(start);\\n\\t\\t\\t// slide start to the next word\\n\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\treturn start + k;\\n\\t\\t}\\n\\t\\treturn start;\\n\\t}\\n\\n\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\tint x = curDict.get(key);\\n\\t\\tif (x == 1)\\n\\t\\t\\tcurDict.remove(key);\\n\\t\\telse\\n\\t\\t\\tcurDict.put(key, x - 1);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t/**\\n\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t */\\n\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\treturn res;\\n\\n\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\telse\\n\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t}\\n\\n\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\tString test, temp;\\n\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\tcurDict.clear();\\n\\t\\t\\tstart = i;\\n\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\tres.add(start);\\n\\t\\t\\t// slide start to the next word\\n\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\treturn start + k;\\n\\t\\t}\\n\\t\\treturn start;\\n\\t}\\n\\n\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\tint x = curDict.get(key);\\n\\t\\tif (x == 1)\\n\\t\\t\\tcurDict.remove(key);\\n\\t\\telse\\n\\t\\t\\tcurDict.put(key, x - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417525,
                "title": "python-counters-with-lookback",
                "content": "**Solution**:\\nIterate through s and check every possible substrings. For each substring, count all words and their counts. If the counter of the substring is equal to the counter of words, add the starting index to to the resulting list.     \\n\\nWe can optimize the counter calculation by performing some lookback. A counter at some arbitrary i is the counter at i-w removed the first word of i-w and added the last word of i where w is the length of each word. \\n\\n```\\n   ie: words = 1,2,3,4,5 and numWord = 3\\n   counter(0) = [1,2,3]\\n   counter(1) = [2,3,4]\\n   counter(3) = [3,4,5]\\n  ```\\n\\nHowever, since each counter represents words of size w, we have to maintain at most w counters to account for all possible starting characters.\\n\\n```\\n   Ex: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\\n    i   substring   counterNum  counter                 result\\n    0   barfoo      0           {\\'bar\\': 1, \\'foo\\': 1}    [0]\\n    1   arfoot      1           {\\'arf\\': 1, \\'oot\\': 1}    [0]\\n    2   rfooth      2           {\\'rfo\\': 1, \\'oth\\': 1}    [0]\\n    3   foothe      0           {\\'foo\\': 1, \\'the\\': 1}    [0]\\n    4   oothef      1           {\\'oot\\': 1, \\'hef\\': 1}    [0]\\n    5   othefo      2           {\\'oth\\': 1, \\'efo\\': 1}    [0]\\n    6   thefoo      0           {\\'the\\': 1, \\'foo\\': 1}    [0]\\n    7   hefoob      1           {\\'hef\\': 1, \\'oob\\': 1}    [0]\\n    8   efooba      2           {\\'efo\\': 1, \\'oba\\': 1}    [0]\\n    9   foobar      0           {\\'foo\\': 1, \\'bar\\': 1}    [0,9]\\n    10  oobarm      1           {\\'oob\\': 1, \\'arm\\': 1}    [0,9]\\n    11  obarma      2           {\\'oba\\': 1, \\'rma\\': 1}    [0,9]\\n    12  barman      0           {\\'bar\\': 1, \\'man\\': 1}    [0,9]\\n```\\n\\nSpecial thank to this [post](https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/1753357/Clear-solution!-Easy-to-understand-with-diagrams%5C) for the counter lookback.\\n\\n**Complexity**:\\n    Time: O(mn) where m is the length of s and n is the length of words\\n    Space: O(nw) where n is the length of words and w is the length of each word\\n\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\\n\\n\\t# Find the length of s, words, and each word\\n\\tm, n, w = len(s), len(words), len(words[0])\\n\\n\\t# Count words\\n\\twords = Counter(words)\\n\\n\\t# Cache to store previously calculated counter\\n\\tcache = {}\\n\\n\\t# Count words in a substring\\n\\tdef counts(i):\\n\\n\\t\\t# Initialize the counter\\n\\t\\tcounter = defaultdict(int) if 0 <= i < w else cache[i % w]\\n\\n\\t\\t# Calcualte the start and end of the current substring\\n\\t\\tstart, end = i, i + n * w\\n\\n\\t\\t# We have to do a full counter calculation for the first w characters\\n\\t\\tif 0 <= i < w:\\n\\t\\t\\tfor j in range(start, end, w):\\n\\t\\t\\t\\tcounter[s[j : j + w]] += 1\\n\\n\\t\\t# Else, we can reused i-w counter\\n\\t\\telse:\\n\\n\\t\\t\\t# Remove the first word of i-w substring from the counter\\n\\n\\t\\t\\t# First word of i-w substring\\n\\t\\t\\tfirstWordPrevCounter = s[start - w : start]\\n\\n\\t\\t\\t# Remove the first word of the i-w substring from the counter\\n\\t\\t\\tcounter[firstWordPrevCounter] -= 1\\n\\n\\t\\t\\t# Remove the word if its count is 0\\n\\t\\t\\tif counter[firstWordPrevCounter] == 0:\\n\\t\\t\\t\\tcounter.pop(firstWordPrevCounter)\\n\\n\\t\\t\\t# Add the last word of i substring\\n\\n\\t\\t\\t# Lastword of i substring\\n\\t\\t\\tlastWord = s[end - w : end]\\n\\n\\t\\t\\t# Add such word to the counter\\n\\t\\t\\tcounter[lastWord] += 1\\n\\n\\t\\t# Save the counter to cache\\n\\t\\tcache[i % w] = counter\\n\\n\\t\\t# Return the counter\\n\\t\\treturn cache[i % w]\\n\\n\\t# Initialize the result\\n\\tres = []\\n\\n\\t# Iterate through all possible substrings\\n\\tfor i in range(0, m - n * w + 1):\\n\\n\\t\\t# If counters of substring and words are equal, add the starting index to the result\\n\\t\\tif counts(i) == words:\\n\\t\\t\\tres.append(i)\\n\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n   ie: words = 1,2,3,4,5 and numWord = 3\\n   counter(0) = [1,2,3]\\n   counter(1) = [2,3,4]\\n   counter(3) = [3,4,5]\\n  ```\n```\\n   Ex: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\\n    i   substring   counterNum  counter                 result\\n    0   barfoo      0           {\\'bar\\': 1, \\'foo\\': 1}    [0]\\n    1   arfoot      1           {\\'arf\\': 1, \\'oot\\': 1}    [0]\\n    2   rfooth      2           {\\'rfo\\': 1, \\'oth\\': 1}    [0]\\n    3   foothe      0           {\\'foo\\': 1, \\'the\\': 1}    [0]\\n    4   oothef      1           {\\'oot\\': 1, \\'hef\\': 1}    [0]\\n    5   othefo      2           {\\'oth\\': 1, \\'efo\\': 1}    [0]\\n    6   thefoo      0           {\\'the\\': 1, \\'foo\\': 1}    [0]\\n    7   hefoob      1           {\\'hef\\': 1, \\'oob\\': 1}    [0]\\n    8   efooba      2           {\\'efo\\': 1, \\'oba\\': 1}    [0]\\n    9   foobar      0           {\\'foo\\': 1, \\'bar\\': 1}    [0,9]\\n    10  oobarm      1           {\\'oob\\': 1, \\'arm\\': 1}    [0,9]\\n    11  obarma      2           {\\'oba\\': 1, \\'rma\\': 1}    [0,9]\\n    12  barman      0           {\\'bar\\': 1, \\'man\\': 1}    [0,9]\\n```\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\\n\\n\\t# Find the length of s, words, and each word\\n\\tm, n, w = len(s), len(words), len(words[0])\\n\\n\\t# Count words\\n\\twords = Counter(words)\\n\\n\\t# Cache to store previously calculated counter\\n\\tcache = {}\\n\\n\\t# Count words in a substring\\n\\tdef counts(i):\\n\\n\\t\\t# Initialize the counter\\n\\t\\tcounter = defaultdict(int) if 0 <= i < w else cache[i % w]\\n\\n\\t\\t# Calcualte the start and end of the current substring\\n\\t\\tstart, end = i, i + n * w\\n\\n\\t\\t# We have to do a full counter calculation for the first w characters\\n\\t\\tif 0 <= i < w:\\n\\t\\t\\tfor j in range(start, end, w):\\n\\t\\t\\t\\tcounter[s[j : j + w]] += 1\\n\\n\\t\\t# Else, we can reused i-w counter\\n\\t\\telse:\\n\\n\\t\\t\\t# Remove the first word of i-w substring from the counter\\n\\n\\t\\t\\t# First word of i-w substring\\n\\t\\t\\tfirstWordPrevCounter = s[start - w : start]\\n\\n\\t\\t\\t# Remove the first word of the i-w substring from the counter\\n\\t\\t\\tcounter[firstWordPrevCounter] -= 1\\n\\n\\t\\t\\t# Remove the word if its count is 0\\n\\t\\t\\tif counter[firstWordPrevCounter] == 0:\\n\\t\\t\\t\\tcounter.pop(firstWordPrevCounter)\\n\\n\\t\\t\\t# Add the last word of i substring\\n\\n\\t\\t\\t# Lastword of i substring\\n\\t\\t\\tlastWord = s[end - w : end]\\n\\n\\t\\t\\t# Add such word to the counter\\n\\t\\t\\tcounter[lastWord] += 1\\n\\n\\t\\t# Save the counter to cache\\n\\t\\tcache[i % w] = counter\\n\\n\\t\\t# Return the counter\\n\\t\\treturn cache[i % w]\\n\\n\\t# Initialize the result\\n\\tres = []\\n\\n\\t# Iterate through all possible substrings\\n\\tfor i in range(0, m - n * w + 1):\\n\\n\\t\\t# If counters of substring and words are equal, add the starting index to the result\\n\\t\\tif counts(i) == words:\\n\\t\\t\\tres.append(i)\\n\\n\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352807,
                "title": "python-my-soln-sliding-window",
                "content": "class Solution:\\n\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        counter = Counter(words)\\n        window_size = len(words) * word_len\\n        ans = []\\n        for i in range(len(s) - window_size + 1):\\n            temp = s[i:i+window_size]\\n            \\n            lst = []\\n            while temp:\\n                lst.append(temp[:word_len])\\n                temp = temp[word_len:]\\n           \\n            if Counter(lst) == counter:\\n                ans.append(i)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        counter = Counter(words)\\n        window_size = len(words) * word_len\\n        ans = []\\n        for i in range(len(s) - window_size + 1):\\n            temp = s[i:i+window_size]\\n            \\n            lst = []\\n            while temp:\\n                lst.append(temp[:word_len])\\n                temp = temp[word_len:]\\n           \\n            if Counter(lst) == counter:\\n                ans.append(i)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1622909,
                "title": "easy-solution-using-map-in-js",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n   let m2 = new Map()\\n for(let i = 0; i< words.length; i++){\\n     m2.set(words[i] , (m2.get(words[i]) || 0 ) + 1)\\n }\\n    let ans= []\\n    let m1  = new Map()\\n let len =  words.length  * words[0].length\\nfor(let i = 0  ; i< s.length-len+1; i++){\\n let curr = s.substring(i, i+len)\\n     if(check(curr, m2, words[0].length)) ans.push(i)\\n}\\nreturn ans\\n}\\n    function check(curr, m2, length){\\n        let m1 =  new Map()\\n        for(let i = 0; i< curr.length; i+=length){\\n            let sub = curr.substring(i, i+length)\\n            m1.set(sub, (m1.get(sub)|| 0 ) +1 )\\n        }\\n          for(let [key, val] of  m2){\\n            if(m1.get(key) !== m2.get(key)) return false\\n        }\\n        return true\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n   let m2 = new Map()\\n for(let i = 0; i< words.length; i++){\\n     m2.set(words[i] , (m2.get(words[i]) || 0 ) + 1)\\n }\\n    let ans= []\\n    let m1  = new Map()\\n let len =  words.length  * words[0].length\\nfor(let i = 0  ; i< s.length-len+1; i++){\\n let curr = s.substring(i, i+len)\\n     if(check(curr, m2, words[0].length)) ans.push(i)\\n}\\nreturn ans\\n}\\n    function check(curr, m2, length){\\n        let m1 =  new Map()\\n        for(let i = 0; i< curr.length; i+=length){\\n            let sub = curr.substring(i, i+length)\\n            m1.set(sub, (m1.get(sub)|| 0 ) +1 )\\n        }\\n          for(let [key, val] of  m2){\\n            if(m1.get(key) !== m2.get(key)) return false\\n        }\\n        return true\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1483223,
                "title": "c-sliding-window-logic-explained",
                "content": "```\\nvector<int> findSubstring(string s, vector<string>& a) {\\n        int wordLen = a[0].size(), windowSize = wordLen * a.size(); \\n        vector<int> res;\\n        if(windowSize > s.size()) return res;\\n        unordered_map<string, int> original;        \\n        for(auto &g:a) original[g]++;\\n\\t\\t\\n        //The task of this for loop is to move the window, 1 index at a time.\\n        for(int i=0; i<=s.size()-windowSize; i++){\\n            unordered_map<string, int> m;\\n            \\n            //The task of this for loop is to check whether all words of vector a are present in window are not.\\n            for(int windowIndex=i; windowIndex < i+windowSize; windowIndex+=wordLen){\\n                string curWord = s.substr(windowIndex, wordLen);\\n\\t\\t\\t\\t\\n                //If current word of window doesn\\'t exist in map -> break. Break from 2nd for loop, i.e. window will now move further to next index due to first for loop.\\n                if(original.find(curWord) == original.end()) break;\\n                \\n                m[curWord]++;\\n                \\n                //This for loop saves extra iterations if window contains extra duplicates than required\\n                if(m[curWord] > original[curWord]) break;\\n                \\n            }\\n            \\n            //Now after exiting window check whether both the maps are identical, if they are we have a result.\\n            if(m == original) res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> findSubstring(string s, vector<string>& a) {\\n        int wordLen = a[0].size(), windowSize = wordLen * a.size(); \\n        vector<int> res;\\n        if(windowSize > s.size()) return res;\\n        unordered_map<string, int> original;        \\n        for(auto &g:a) original[g]++;\\n\\t\\t\\n        //The task of this for loop is to move the window, 1 index at a time.\\n        for(int i=0; i<=s.size()-windowSize; i++){\\n            unordered_map<string, int> m;\\n            \\n            //The task of this for loop is to check whether all words of vector a are present in window are not.\\n            for(int windowIndex=i; windowIndex < i+windowSize; windowIndex+=wordLen){\\n                string curWord = s.substr(windowIndex, wordLen);\\n\\t\\t\\t\\t\\n                //If current word of window doesn\\'t exist in map -> break. Break from 2nd for loop, i.e. window will now move further to next index due to first for loop.\\n                if(original.find(curWord) == original.end()) break;\\n                \\n                m[curWord]++;\\n                \\n                //This for loop saves extra iterations if window contains extra duplicates than required\\n                if(m[curWord] > original[curWord]) break;\\n                \\n            }\\n            \\n            //Now after exiting window check whether both the maps are identical, if they are we have a result.\\n            if(m == original) res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1450731,
                "title": "python-1-intuitive-1-fast-sliding",
                "content": "Solution 1: Short, intuitive and simple, but rebuilds matches\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\n        c = Counter(words)\\n        word_len = len(words[0])\\n        seq_len = len(words)*word_len\\n        \\n        def success(i, word):\\n\\t\\t\\t# Copy of word counts to remove from as needed\\n            counter = c.copy()\\n            counter[word] -= 1\\n            \\n            # Continue removing as long as sequence is not complete or until invalid word is encountered\\n            for i in range(i, i+seq_len-word_len, word_len):\\n                if not counter[(w := s[i:i+word_len])]:\\n                    return False\\n                counter[w] -= 1\\n            \\n            # Sequence built successfully\\n            return True\\n        \\n        # Return indices where there is a valid word and valid combo of words from thereafter \\n        return [i for i in range(len(s)-seq_len+1) if c[(w := s[i:i+word_len])] and success(i+word_len, w)]\\n```\\n\\nSolution 2: Maintains matches (Inspired by https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/1439131/Simple-Python-solution \\'s solution)\\n\\n```\\nfrom collections import Counter\\n\\ndef findSubstring(s: str, words: List[str]) -> List[int]:\\n    indices = set()\\n    counts = Counter(words)\\n\\n    word_len = len(words[0])\\n    list_len = len(words)\\n\\tseq_len_remove_1 = (list_len-1)*word_len\\n\\n    for start in range(word_len): \\n        matches = 0\\n        counts_copy = counts.copy()\\n        \\n        # Iterate through s in steps of word_len starting at start in [0, word_len) \\n        for ind in range(start, len(s), word_len): \\n            # Not in words list\\n            if not (word := s[ind:ind+word_len]) in counts_copy:\\n                if matches: # We were building and must reset since we encountered a non-word\\n                    matches = 0\\n                    counts_copy = counts.copy()\\n            # Unused word from words list\\n            elif counts_copy[word]:\\n                counts_copy[word] -= 1\\n                matches += 1\\n\\n                if matches == list_len:\\n                    indices.add(ind-seq_len_remove_1)\\n            # In words list, but used (trickiest part of solution, think of it as a sliding left pointer)\\n            else:\\n                # Find leftmost occurunce of word in matches (we know it has been used)\\n                k = next(k for k in range(ind - matches*word_len, ind, word_len) if s[k:k+word_len]==word)\\n                # Everything before this occurence is not part of matches anymore\\n                counts_copy.update([s[p:p+word_len] for p in range(ind - matches*word_len, k, word_len)])\\n                matches = (ind-k)//word_len\\n\\n                if matches == list_len:\\n                    indices.add(ind-seq_len_remove_1)\\n\\n    return indices\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\n        c = Counter(words)\\n        word_len = len(words[0])\\n        seq_len = len(words)*word_len\\n        \\n        def success(i, word):\\n\\t\\t\\t# Copy of word counts to remove from as needed\\n            counter = c.copy()\\n            counter[word] -= 1\\n            \\n            # Continue removing as long as sequence is not complete or until invalid word is encountered\\n            for i in range(i, i+seq_len-word_len, word_len):\\n                if not counter[(w := s[i:i+word_len])]:\\n                    return False\\n                counter[w] -= 1\\n            \\n            # Sequence built successfully\\n            return True\\n        \\n        # Return indices where there is a valid word and valid combo of words from thereafter \\n        return [i for i in range(len(s)-seq_len+1) if c[(w := s[i:i+word_len])] and success(i+word_len, w)]\\n```\n```\\nfrom collections import Counter\\n\\ndef findSubstring(s: str, words: List[str]) -> List[int]:\\n    indices = set()\\n    counts = Counter(words)\\n\\n    word_len = len(words[0])\\n    list_len = len(words)\\n\\tseq_len_remove_1 = (list_len-1)*word_len\\n\\n    for start in range(word_len): \\n        matches = 0\\n        counts_copy = counts.copy()\\n        \\n        # Iterate through s in steps of word_len starting at start in [0, word_len) \\n        for ind in range(start, len(s), word_len): \\n            # Not in words list\\n            if not (word := s[ind:ind+word_len]) in counts_copy:\\n                if matches: # We were building and must reset since we encountered a non-word\\n                    matches = 0\\n                    counts_copy = counts.copy()\\n            # Unused word from words list\\n            elif counts_copy[word]:\\n                counts_copy[word] -= 1\\n                matches += 1\\n\\n                if matches == list_len:\\n                    indices.add(ind-seq_len_remove_1)\\n            # In words list, but used (trickiest part of solution, think of it as a sliding left pointer)\\n            else:\\n                # Find leftmost occurunce of word in matches (we know it has been used)\\n                k = next(k for k in range(ind - matches*word_len, ind, word_len) if s[k:k+word_len]==word)\\n                # Everything before this occurence is not part of matches anymore\\n                counts_copy.update([s[p:p+word_len] for p in range(ind - matches*word_len, k, word_len)])\\n                matches = (ind-k)//word_len\\n\\n                if matches == list_len:\\n                    indices.add(ind-seq_len_remove_1)\\n\\n    return indices\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419019,
                "title": "c-simple-multiset",
                "content": "Was able to make sliding window approach, but was curious about multiset solution I thought of earlier\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), n = words.size(), m = s.length();\\n        multiset<string> db;\\n        vector<int> results;\\n        \\n        for(auto& word : words) {\\n            db.insert(word);\\n        }\\n        \\n        auto temp = db;\\n        for(int i = 0; i < m - n * len + 1; i += 1) {\\n            string word = s.substr(i, len);\\n            auto it = temp.find(word);\\n            \\n            if(it != temp.end()) {\\n                temp.erase(it);\\n                int j = i + len;\\n                \\n                while(j < m) {\\n                    word = s.substr(j, len);\\n                    it = temp.find(word);\\n                    \\n                    if(it != temp.end()) {\\n                        temp.erase(it);\\n                    }\\n                    else {\\n                        break;\\n                    }\\n                    \\n                    j += len;\\n                }\\n                \\n                if(temp.empty()) {\\n                    results.push_back(i);\\n                }\\n                \\n                temp = db;\\n            }\\n        }\\n        \\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), n = words.size(), m = s.length();\\n        multiset<string> db;\\n        vector<int> results;\\n        \\n        for(auto& word : words) {\\n            db.insert(word);\\n        }\\n        \\n        auto temp = db;\\n        for(int i = 0; i < m - n * len + 1; i += 1) {\\n            string word = s.substr(i, len);\\n            auto it = temp.find(word);\\n            \\n            if(it != temp.end()) {\\n                temp.erase(it);\\n                int j = i + len;\\n                \\n                while(j < m) {\\n                    word = s.substr(j, len);\\n                    it = temp.find(word);\\n                    \\n                    if(it != temp.end()) {\\n                        temp.erase(it);\\n                    }\\n                    else {\\n                        break;\\n                    }\\n                    \\n                    j += len;\\n                }\\n                \\n                if(temp.empty()) {\\n                    results.push_back(i);\\n                }\\n                \\n                temp = db;\\n            }\\n        }\\n        \\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380395,
                "title": "clean-python-solution-explained-o-n-wl-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(N*wl), N is the length of the input string s; wl is the length of each word.\\nSpace: O(N)\\n\\nFor word count wc and word length wl, the string we are looking for will be between i and j (s[i:j]).\\n`test()` all s[i:j]. If pass, append into ans.\\n\\nEach `test()` will test the sub-string s[i:j]`.\\nIf any \"word\" in the sub-string is not in the countExpected, the test failed.\\nIf the word is used too many times (more than \"countExpected\"), the test failed.\\nOtherwise, the test pass.\\n\\nThis is the solution I learn from @gabbu.\\n\\n\"\"\"\\nimport collections\\n\\nclass Solution(object):\\n    def findSubstring(self, s, words):\\n        if not words: return []\\n        \\n        wc = len(words) #word count\\n        wl = len(words[0]) #word length\\n        ans = []\\n        \\n        i = 0\\n        j = wc*wl\\n        \\n        countExpected = collections.Counter(words)\\n        \\n        while j<=len(s):\\n            if self.test(s[i:j], wl, countExpected): ans.append(i)\\n            i += 1\\n            j += 1\\n        \\n        return ans\\n    \\n    \\n    def test(self, s, wl, countExpected):\\n        counter = collections.Counter() #{word:how many time the word is used}\\n        i = 0\\n        \\n        while i<len(s):\\n            word = s[i:i+wl]\\n            if word not in countExpected or counter[word]>=countExpected[word]: return False\\n            i += wl\\n            counter[word] += 1\\n            \\n        return True\\n        \\n\"\"\"\\nRelated Problems:\\nLongest Substring Without Repeating Characters\\nLongest Substring that contains k unique characters\\nSubstring with Concatenation of All Words\\nMinimum Window Substring\\nLongest Substring with At Least K Repeating Characters\\nPermutation in String\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N*wl), N is the length of the input string s; wl is the length of each word.\\nSpace: O(N)\\n\\nFor word count wc and word length wl, the string we are looking for will be between i and j (s[i:j]).\\n`test()` all s[i:j]. If pass, append into ans.\\n\\nEach `test()` will test the sub-string s[i:j]`.\\nIf any \"word\" in the sub-string is not in the countExpected, the test failed.\\nIf the word is used too many times (more than \"countExpected\"), the test failed.\\nOtherwise, the test pass.\\n\\nThis is the solution I learn from @gabbu.\\n\\n\"\"\"\\nimport collections\\n\\nclass Solution(object):\\n    def findSubstring(self, s, words):\\n        if not words: return []\\n        \\n        wc = len(words) #word count\\n        wl = len(words[0]) #word length\\n        ans = []\\n        \\n        i = 0\\n        j = wc*wl\\n        \\n        countExpected = collections.Counter(words)\\n        \\n        while j<=len(s):\\n            if self.test(s[i:j], wl, countExpected): ans.append(i)\\n            i += 1\\n            j += 1\\n        \\n        return ans\\n    \\n    \\n    def test(self, s, wl, countExpected):\\n        counter = collections.Counter() #{word:how many time the word is used}\\n        i = 0\\n        \\n        while i<len(s):\\n            word = s[i:i+wl]\\n            if word not in countExpected or counter[word]>=countExpected[word]: return False\\n            i += wl\\n            counter[word] += 1\\n            \\n        return True\\n        \\n\"\"\"\\nRelated Problems:\\nLongest Substring Without Repeating Characters\\nLongest Substring that contains k unique characters\\nSubstring with Concatenation of All Words\\nMinimum Window Substring\\nLongest Substring with At Least K Repeating Characters\\nPermutation in String\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188946,
                "title": "c-196ms-72-hashmap-three-versions",
                "content": "Runtime: 196 ms, faster than 71.52% of C++ online submissions for Substring with Concatenation of All Words.\\nMemory Usage: 20 MB, less than 77.86% of C++ online submissions for Substring with Concatenation of All Words.\\n**General idea:**\\n1. Consruct hash_map <word from words , pair <number of \"word\" in words, number of \"word\" in words>> (first number we will use in our seeking and second number for \"refresh\" first number for next seeking)\\n2. try to put all words from map from current index from string s\\n\\n\\n**If we refresh all map** \\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit; i++){\\n      int tN = 0, j = i;\\n      for(; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      \\n      for(auto &it: mp) it.second.first = it.second.second;\\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```\\n**if we refresh only \"worked\" words from map** \\nRuntime: 240 ms, faster than 52.97% of C++ online submissions for Substring with Concatenation of All Words.\\nMemory Usage: 22.8 MB, less than 72.96% of C++ online submissions for Substring with Concatenation of All Words.\\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit;i++){\\n      int tN = 0, j = i;\\n      for(; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      \\n      for(int k = i; k <= j; k += n){\\n        string tmp = s.substr(k,n);\\n        int p = mp[tmp].second;\\n        mp[tmp] = {p,p};\\n      } \\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```\\n\\n**If we replace \"bad\" pair with \"good\"** \\nRuntime: 892 ms, faster than 17.72% of C++ online submissions for Substring with Concatenation of All Words.\\nMemory Usage: 20 MB, less than 77.65% of C++ online submissions for Substring with Concatenation of All Words.\\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit;i++){\\n      int tN = 0;\\n      for(int j = i; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      for(unordered_map<string,pair<int,int>>::iterator it = mp.begin(); it != mp.end();it++){\\n        mp[it->first] = {it->second.second,it->second.second};\\n      } \\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit; i++){\\n      int tN = 0, j = i;\\n      for(; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      \\n      for(auto &it: mp) it.second.first = it.second.second;\\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit;i++){\\n      int tN = 0, j = i;\\n      for(; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      \\n      for(int k = i; k <= j; k += n){\\n        string tmp = s.substr(k,n);\\n        int p = mp[tmp].second;\\n        mp[tmp] = {p,p};\\n      } \\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit;i++){\\n      int tN = 0;\\n      for(int j = i; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      for(unordered_map<string,pair<int,int>>::iterator it = mp.begin(); it != mp.end();it++){\\n        mp[it->first] = {it->second.second,it->second.second};\\n      } \\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158065,
                "title": "c-solution-sliding-window-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    #define pb push_back\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        int a=words.size();\\n        vector<int >ans;\\n\\tunordered_map<string , int >m;\\n\\tfor (int i = 0; i < a; i++) {\\n\\t\\tm[words[i]]++;\\n\\t}\\n\\tint word = words[0].length();\\n\\tint window = word * a;\\n        if(window>str.length()){\\n            return ans;\\n        }\\n\\tfor (int i = 0; i <= str.size() - window; i++) {\\n\\t\\tstring temp = str.substr(i, window);\\n\\t\\tunordered_map<string , int >t;\\n\\t\\tint j = 0;\\n\\t\\tint index = 0;\\n\\t\\twhile (index < a) {\\n\\t\\t\\tstring rest = temp.substr(j, word);\\n\\t\\t\\tt[rest]++;\\n\\t\\t\\tj += word;\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t\\t//cout << m.size() << \" \" << t.size() << endl;\\n\\t\\tif (m == t) {\\n\\t\\t\\tans.pb(i);\\n\\t\\t}\\n\\n//\\t\\treturn 0;\\n\\t}\\n\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pb push_back\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        int a=words.size();\\n        vector<int >ans;\\n\\tunordered_map<string , int >m;\\n\\tfor (int i = 0; i < a; i++) {\\n\\t\\tm[words[i]]++;\\n\\t}\\n\\tint word = words[0].length();\\n\\tint window = word * a;\\n        if(window>str.length()){\\n            return ans;\\n        }\\n\\tfor (int i = 0; i <= str.size() - window; i++) {\\n\\t\\tstring temp = str.substr(i, window);\\n\\t\\tunordered_map<string , int >t;\\n\\t\\tint j = 0;\\n\\t\\tint index = 0;\\n\\t\\twhile (index < a) {\\n\\t\\t\\tstring rest = temp.substr(j, word);\\n\\t\\t\\tt[rest]++;\\n\\t\\t\\tj += word;\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t\\t//cout << m.size() << \" \" << t.size() << endl;\\n\\t\\tif (m == t) {\\n\\t\\t\\tans.pb(i);\\n\\t\\t}\\n\\n//\\t\\treturn 0;\\n\\t}\\n\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1090701,
                "title": "python-easy-to-follow",
                "content": "```\\n        w_len = len(words[0])\\n        tot_len = w_len*len(words)\\n        rtn = []\\n        words.sort()\\n\\n        for i in range(0, len(s)-tot_len+1):\\n\\n            temp = s[i:i+tot_len]\\n            temp_list = []\\n\\n            for j in range(0 , len(temp) , w_len):\\n\\n                temp_list.append(temp[j:j+w_len])\\n\\n            temp_list.sort()\\n\\n            if(temp_list == words):\\n                rtn.append(i)\\n\\n        return rtn",
                "solutionTags": [],
                "code": "```\\n        w_len = len(words[0])\\n        tot_len = w_len*len(words)\\n        rtn = []\\n        words.sort()\\n\\n        for i in range(0, len(s)-tot_len+1):\\n\\n            temp = s[i:i+tot_len]\\n            temp_list = []\\n\\n            for j in range(0 , len(temp) , w_len):\\n\\n                temp_list.append(temp[j:j+w_len])\\n\\n            temp_list.sort()\\n\\n            if(temp_list == words):\\n                rtn.append(i)\\n\\n        return rtn",
                "codeTag": "Unknown"
            },
            {
                "id": 1058574,
                "title": "java-7ms-faster-than-97",
                "content": "**Use sliding window**\\n\\n*Intuition* : Given that each word is N-characters-long (N-long), a valid subtring is formed by concatenating N-long words from words array in any order without intervening characters. Our task is to return a list of possible starting indices of valid substrings of s.\\n\\n*Algorithm* : \\n\\tFirst off, there are N possible ways to choose the starting index from which we traverse string s, \\n    so such a variable holds values from 0 to N-1.\\n    As we traverse s in N-long strides, we build a potential valid substring by enqueueing each \\n    encountered N-long substring. \\n    If this N-long substring is a word in words array, we verify if it features in substrWordToCount,a map which counts the frequency of N-long substrings in the potential valid substring, more than once. \\n    If it doesn\\'t, then we put it in the map.\\n\\tIf it does, then we decrement the frequency of the word at the front of the potential valid substring, removing it from the map if it featured once and moving the possible starting index N-long places to the right of s.\\n     The, we enqueue the N-long substring into our potential valid substring.\\n     Finally, we check that the valid substring has as many words as the words array. If so, we have a valid substring and we add our current starting index to the final list of possible starting indices of valid substrings in s.\\n    If this N-long substring is not in words array, we\\'ve encounter a word-long intervening substring which invalidates our potential valid substring so that we reset our queue, reset the map which stores the frequency of N-long substrings in the potential valid substring and move the possible starting index just after this N-long substring in s.\\n\\t\\n*Complexity* : \\t\\nLet M be the length of words array and N be length of each word, then our Time complexity is O(N^2) and our Space complexity is O(M!)\\n\\n\\t ```\\n\\t    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\tList<Integer> indices = new ArrayList<>();\\n        \\n\\t\\t\\tif (s == null || words == null || s.length() == 0 || words.length == 0) {\\n\\t\\t\\t\\treturn indices;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tint wordLen = words[0].length(), wordsCount = words.length;\\n        \\n\\t\\t\\tMap<String, Integer> wordToCount = new HashMap<>();\\n\\t\\t\\tfor (String word : words)\\n\\t\\t\\t\\twordToCount.put(word, wordToCount.getOrDefault(word, 0) + 1);\\n        \\n\\t\\t\\tfor (int start = 0; start < wordLen; start++) {\\n\\t\\t\\t\\tQueue<String> queue = new LinkedList<>();\\n\\t\\t\\t\\tMap<String, Integer> substrWordToCount = new HashMap<>();\\n\\t\\t\\t\\tfor (int lo = start, hi = start; hi <= s.length() - wordLen; hi += wordLen) {\\n\\t\\t\\t\\t\\tString word = s.substring(hi, hi + wordLen);\\n\\t\\t\\t\\t\\tif (!wordToCount.containsKey(word)) {\\n\\t\\t\\t\\t\\t\\tqueue = new LinkedList<>();\\n\\t\\t\\t\\t\\t\\tlo = hi + wordLen;\\n\\t\\t\\t\\t\\t\\tsubstrWordToCount = new HashMap<>();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tint substrWordCount = substrWordToCount.getOrDefault(word, 0);\\n\\t\\t\\t\\t\\t\\tif (substrWordCount >= wordToCount.get(word)) {\\n\\t\\t\\t\\t\\t\\t\\twhile (!queue.peek().equals(word)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tString wordToRemove = queue.poll();\\n\\t\\t\\t\\t\\t\\t\\t\\tint count = substrWordToCount.get(wordToRemove);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (count == 1) substrWordToCount.remove(wordToRemove);\\n\\t\\t\\t\\t\\t\\t\\t\\telse substrWordToCount.put(wordToRemove, count - 1);\\n\\t\\t\\t\\t\\t\\t\\t\\tlo += wordLen;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlo += wordLen;\\n\\t\\t\\t\\t\\t\\t\\tqueue.poll();\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsubstrWordToCount.put(word, substrWordCount + 1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqueue.offer(word);\\n\\t\\t\\t\\t\\t\\tif (queue.size() == wordsCount) {\\n\\t\\t\\t\\t\\t\\t\\tindices.add(lo);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn indices;\\n\\t\\t}\\n\\t ```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n\\t    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\tList<Integer> indices = new ArrayList<>();\\n        \\n\\t\\t\\tif (s == null || words == null || s.length() == 0 || words.length == 0) {\\n\\t\\t\\t\\treturn indices;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tint wordLen = words[0].length(), wordsCount = words.length;\\n        \\n\\t\\t\\tMap<String, Integer> wordToCount = new HashMap<>();\\n\\t\\t\\tfor (String word : words)\\n\\t\\t\\t\\twordToCount.put(word, wordToCount.getOrDefault(word, 0) + 1);\\n        \\n\\t\\t\\tfor (int start = 0; start < wordLen; start++) {\\n\\t\\t\\t\\tQueue<String> queue = new LinkedList<>();\\n\\t\\t\\t\\tMap<String, Integer> substrWordToCount = new HashMap<>();\\n\\t\\t\\t\\tfor (int lo = start, hi = start; hi <= s.length() - wordLen; hi += wordLen) {\\n\\t\\t\\t\\t\\tString word = s.substring(hi, hi + wordLen);\\n\\t\\t\\t\\t\\tif (!wordToCount.containsKey(word)) {\\n\\t\\t\\t\\t\\t\\tqueue = new LinkedList<>();\\n\\t\\t\\t\\t\\t\\tlo = hi + wordLen;\\n\\t\\t\\t\\t\\t\\tsubstrWordToCount = new HashMap<>();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tint substrWordCount = substrWordToCount.getOrDefault(word, 0);\\n\\t\\t\\t\\t\\t\\tif (substrWordCount >= wordToCount.get(word)) {\\n\\t\\t\\t\\t\\t\\t\\twhile (!queue.peek().equals(word)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tString wordToRemove = queue.poll();\\n\\t\\t\\t\\t\\t\\t\\t\\tint count = substrWordToCount.get(wordToRemove);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (count == 1) substrWordToCount.remove(wordToRemove);\\n\\t\\t\\t\\t\\t\\t\\t\\telse substrWordToCount.put(wordToRemove, count - 1);\\n\\t\\t\\t\\t\\t\\t\\t\\tlo += wordLen;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlo += wordLen;\\n\\t\\t\\t\\t\\t\\t\\tqueue.poll();\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsubstrWordToCount.put(word, substrWordCount + 1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqueue.offer(word);\\n\\t\\t\\t\\t\\t\\tif (queue.size() == wordsCount) {\\n\\t\\t\\t\\t\\t\\t\\tindices.add(lo);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn indices;\\n\\t\\t}\\n\\t ```",
                "codeTag": "Unknown"
            },
            {
                "id": 912023,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string,int>m,aux;\\n        for(int i=0;i<words.size();i++)\\n        {\\n                m[words[i]]++;\\n        }\\n        aux=m;\\n        int num=words[0].length();   //you have to skip this much i, if it matches\\n        int count=words.size(); //total number of words that should match!\\n        vector<int>ans;\\n        if(num*count>s.length()) return ans;\\n        for(int i=0;i<s.length()-num*count+1;i++)\\n        {\\n            if(aux.find(s.substr(i,num))!=aux.end()) \\n            {\\n                aux[s.substr(i,num)]--;\\n                int rep=1;\\n                int j=i+num;\\n                while(1)\\n                {\\n                    if(aux[s.substr(j,num)]>0)\\n                    {\\n                        rep++;\\n                        aux[s.substr(j,num)]--;\\n                    }\\n                    else break;\\n                    j=j+num;\\n                }\\n                if(rep==count) \\n                {\\n                    ans.push_back(i);\\n                }\\n                aux=m;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string,int>m,aux;\\n        for(int i=0;i<words.size();i++)\\n        {\\n                m[words[i]]++;\\n        }\\n        aux=m;\\n        int num=words[0].length();   //you have to skip this much i, if it matches\\n        int count=words.size(); //total number of words that should match!\\n        vector<int>ans;\\n        if(num*count>s.length()) return ans;\\n        for(int i=0;i<s.length()-num*count+1;i++)\\n        {\\n            if(aux.find(s.substr(i,num))!=aux.end()) \\n            {\\n                aux[s.substr(i,num)]--;\\n                int rep=1;\\n                int j=i+num;\\n                while(1)\\n                {\\n                    if(aux[s.substr(j,num)]>0)\\n                    {\\n                        rep++;\\n                        aux[s.substr(j,num)]--;\\n                    }\\n                    else break;\\n                    j=j+num;\\n                }\\n                if(rep==count) \\n                {\\n                    ans.push_back(i);\\n                }\\n                aux=m;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871132,
                "title": "python-3-simple-fast-and-easy-to-understand",
                "content": "```\\ndef wrap(s, n):\\n    return [s[i:i+n] for i in range(0, len(s), n)]\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wordlength = len(words[0])\\n        wordset = set(words)\\n        strlength = len(s)     \\n        matchlength = len(words) * wordlength\\n        sortedmatch = \"\".join(sorted(words))\\n        result = []\\n        for i in range(0,(strlength - matchlength) + 1):\\n            if s[i:i + wordlength] in wordset:\\n                cursortedmatch = \"\".join(sorted(wrap(s[i:i + matchlength], wordlength)))\\n                if cursortedmatch == sortedmatch:\\n                    result.append(i)                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\ndef wrap(s, n):\\n    return [s[i:i+n] for i in range(0, len(s), n)]\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wordlength = len(words[0])\\n        wordset = set(words)\\n        strlength = len(s)     \\n        matchlength = len(words) * wordlength\\n        sortedmatch = \"\".join(sorted(words))\\n        result = []\\n        for i in range(0,(strlength - matchlength) + 1):\\n            if s[i:i + wordlength] in wordset:\\n                cursortedmatch = \"\".join(sorted(wrap(s[i:i + matchlength], wordlength)))\\n                if cursortedmatch == sortedmatch:\\n                    result.append(i)                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827924,
                "title": "amazing-solution-easier-than-ever-1-please-up-vote",
                "content": "class Solution {\\n    \\n    public List<Integer> findSubstring(String s, String[] words) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n       HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        int n = s.length();\\n        int eachWordLength = words[0].length();\\n        int totalWordsLength = words.length*eachWordLength;\\n        for(String word: words){\\n            hm.put(word,hm.getOrDefault(word,0)+1);\\n        }\\n       for(int i=0;i<=n-totalWordsLength;i++){\\n           int j = i;\\n           int count = words.length;\\n            HashMap<String, Integer> temp = (HashMap<String, Integer>) hm.clone(); \\n           while(j<i+totalWordsLength){\\n               String str = s.substring(j,j+eachWordLength);\\n               if(!hm.containsKey(str)||temp.get(str)==0){\\n                   break;\\n               }else{\\n                   temp.put(str,temp.get(str)-1);\\n                   count--;\\n               }\\n               j=j+eachWordLength;\\n           }\\n           if(count==0){\\n               al.add(i);\\n           }\\n       } \\n        return al;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public List<Integer> findSubstring(String s, String[] words) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n       HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        int n = s.length();\\n        int eachWordLength = words[0].length();\\n        int totalWordsLength = words.length*eachWordLength;\\n        for(String word: words){\\n            hm.put(word,hm.getOrDefault(word,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 769615,
                "title": "bug-wrong-expected-result-for-a-specific-case",
                "content": "Hello @LeetCode,\\n\\nI tested my code (Python3) with the case below, I got a wrong expected output:\\n\\n```\\n\"bar\"\\n[\"\"]\\nexpected: [0,1,2,3] \\n```\\nThe index 3 **isn\\'t in the range** of the string `bar`\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"bar\"\\n[\"\"]\\nexpected: [0,1,2,3] \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 737563,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s: str, w: List[str]) -> List[int]:\\n        return [i for i in range(len(s)-len(w)*len(w[0])+1)\\n                if Counter([s[a:a+len(w[0])]for a in range(i,i+len(w)*len(w[0]),len(w[0]))]) == Counter(w)] if w else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, w: List[str]) -> List[int]:\\n        return [i for i in range(len(s)-len(w)*len(w[0])+1)\\n                if Counter([s[a:a+len(w[0])]for a in range(i,i+len(w)*len(w[0]),len(w[0]))]) == Counter(w)] if w else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674099,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        if (str.empty() or words.empty()) {return vector<int> ();}\\n        if (str.size() < words.size()*words[0].size()) {return vector<int> ();}\\n        vector<int> resultIndices;\\n        unordered_map<string, int> wordFrequencyMap;\\n        for (auto word : words) {\\n          wordFrequencyMap[word]++;\\n        }\\n        int wordsCount = words.size(), wordLength = words[0].length();\\n\\n        for (int i = 0; i <= str.length() - wordsCount * wordLength; i++) {\\n          unordered_map<string, int> wordsSeen;\\n          for (int j = 0; j < wordsCount; j++) {\\n            int nextWordIndex = i + j * wordLength;\\n            string word = str.substr(nextWordIndex, wordLength);\\n            if (!wordFrequencyMap.count(word)) { \\n              break;\\n            }\\n            wordsSeen[word]++;  \\n            if (wordsSeen[word] > wordFrequencyMap[word]) {\\n              break;\\n            }\\n            if (j + 1 == wordsCount) { \\n              resultIndices.push_back(i);\\n            }\\n          }\\n        }\\n\\n        return resultIndices;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        if (str.empty() or words.empty()) {return vector<int> ();}",
                "codeTag": "Java"
            },
            {
                "id": 572222,
                "title": "python-3-easy-to-understand-solution-o-n-no-of-words",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        res=[]\\n        chk=defaultdict(int)\\n        ln_chk=len(words)\\n        for i in words:\\n            chk[i]+=1\\n            \\n        ln=len(words[0])\\n        n=len(s)\\n        i=0\\n        \\n        for i in range(n-(ln*ln_chk)+1):\\n            temp=chk.copy() # copy of dict. chk\\n            k=i\\n            test=0\\n            for j in range(ln_chk):\\n                word=s[k:k+ln]\\n                if temp[word]>0:\\n                    temp[word]-=1\\n                else:\\n                    test=1\\n                    break\\n                k+=ln\\n            \\n            if test!=1:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        res=[]\\n        chk=defaultdict(int)\\n        ln_chk=len(words)\\n        for i in words:\\n            chk[i]+=1\\n            \\n        ln=len(words[0])\\n        n=len(s)\\n        i=0\\n        \\n        for i in range(n-(ln*ln_chk)+1):\\n            temp=chk.copy() # copy of dict. chk\\n            k=i\\n            test=0\\n            for j in range(ln_chk):\\n                word=s[k:k+ln]\\n                if temp[word]>0:\\n                    temp[word]-=1\\n                else:\\n                    test=1\\n                    break\\n                k+=ln\\n            \\n            if test!=1:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538906,
                "title": "two-map-solution-with-clear-explanation-and-reasonable-variable-names",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        \\n        allwords = {}\\n        for word in words:\\n            if word in allwords:\\n                allwords[word] += 1\\n            else:\\n                allwords[word] = 1\\n       \\n\\t    lens = len(s)\\n        lenoneword = len(words[0])\\n        lenallwords = len(words) * lenoneword\\n        ans = []\\n       \\n        for i in range(lens - lenallwords + 1):\\n            thissegmentwords = {}\\n            for start in range(i, i + lenallwords, lenoneword): \\n                temp_word = s[start: start + lenoneword] \\n                #print(temp_word)\\n                \\n                if temp_word in allwords:\\n                    if temp_word in thissegmentwords:\\n                        thissegmentwords[temp_word] += 1\\n                        if thissegmentwords[temp_word] > allwords[temp_word]:\\n                            break\\n                    else:\\n                        thissegmentwords[temp_word] = 1\\n                else:\\n                    break\\n            if allwords == thissegmentwords:\\n                ans.append(i)\\n        return ans\\n```\\nUse two dictionaries to solve the problem. The first dict `allwords` stores all the word in `words` as key and accumulates their respective required counts as value.  \\n\\nThen, for each starting position `i` in string `s`, we refer to another dict `thissegmentwords`, which store the word:count pair in the `s[i:i+lenallwords]`. At each step, we check the substring `s[i:i+lenoneword]` and then increases `i` by `lenoneword`. During the scanning, if the substring your are checking is not presented in the first dict `allwords` or if its count is larger than its required count (`thissegmentwords[temp_word] > allwords[temp_word]`), then you can directly `break` and go check the next position `i`. Else, you can keep scanning. If at the end of the first loop, you find out that the two dicts are identical, then this current substring `s[i:i+lenallwords]` is a legit substring so you save the index `i`.\\n\\nBy checking every starting position, you will get all the index you want. Hope this help!\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        \\n        allwords = {}\\n        for word in words:\\n            if word in allwords:\\n                allwords[word] += 1\\n            else:\\n                allwords[word] = 1\\n       \\n\\t    lens = len(s)\\n        lenoneword = len(words[0])\\n        lenallwords = len(words) * lenoneword\\n        ans = []\\n       \\n        for i in range(lens - lenallwords + 1):\\n            thissegmentwords = {}\\n            for start in range(i, i + lenallwords, lenoneword): \\n                temp_word = s[start: start + lenoneword] \\n                #print(temp_word)\\n                \\n                if temp_word in allwords:\\n                    if temp_word in thissegmentwords:\\n                        thissegmentwords[temp_word] += 1\\n                        if thissegmentwords[temp_word] > allwords[temp_word]:\\n                            break\\n                    else:\\n                        thissegmentwords[temp_word] = 1\\n                else:\\n                    break\\n            if allwords == thissegmentwords:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357817,
                "title": "c-o-n-solution-aho-corasick-automaton-sliding-window",
                "content": "Let `w` be the length of a word.\\nA key observation: for every `i`, `s[i..i+w-1]` matches at most one word in the word list (after removing duplicates), since all words have same length `w`.\\nSo, we can first find all matches and memorize which word matches `s[i..i+w-1]` .\\nThen, for every `0 <= j < w`, we can use a sliding window to find desired substrings starting at `s[j + k * w]` for some integer `k`.\\nThus, this solution runs strictly in `O(|s| + |words| * w)` time.\\n\\nCode (C++):\\n```c++\\nclass Solution {\\nprivate:\\n  class AcAutomaton {\\n  private:\\n    struct Node {\\n      Node* child[26]{};\\n      Node* fail{};\\n      // no next needed since all words have same length\\n      // Node* next{};\\n      size_t id{};\\n    };\\n  public:\\n    inline AcAutomaton(size_t nNode) :\\n      nodes(new Node[nNode]), queue(new Node*[nNode]) {}\\n\\n    inline void add(string_view sv, vector<int>& ctr) {\\n      auto cur = &root;\\n      for (auto ch : sv) {\\n        auto key = (size_t) (ch - \\'a\\');\\n        if (!cur->child[key])\\n          cur->child[key] = &nodes[nNode++];\\n        cur = cur->child[key];\\n      }\\n      if (cur->id)\\n        ++ctr[cur->id - 1];\\n      else {\\n        ctr.emplace_back(1);\\n        cur->id = ctr.size();\\n      }\\n    }\\n\\n    inline void build() {\\n      root.fail = &root;\\n      size_t qEnd = 0;\\n      for (auto key = 0; key < 26; ++key)\\n        if (root.child[key]) {\\n          auto cur = root.child[key];\\n          cur->fail = &root;\\n          queue[qEnd++] = cur;\\n        }\\n      for (size_t qBeg = 0; qBeg != qEnd; ++qBeg)\\n        for (auto key = 0; key < 26; ++key)\\n          if (queue[qBeg]->child[key]) {\\n            auto cur = queue[qBeg]->child[key];\\n            auto fail = queue[qBeg]->fail;\\n            while (fail != &root && !fail->child[key])\\n              fail = fail->fail;\\n            cur->fail = fail->child[key] ? fail->child[key] : &root;\\n            queue[qEnd++] = cur;\\n          }\\n    }\\n\\n    inline void match(vector<size_t>& ids, string_view sv, size_t lenWord) {\\n      auto fail = &root;\\n      for (size_t i = 0; i != sv.size(); ++i) {\\n        auto key = sv[i] - \\'a\\';\\n        while (fail != &root && !fail->child[key])\\n          fail = fail->fail;\\n        if (fail->child[key]) {\\n          fail = fail->child[key];\\n          if (fail->id)\\n            ids[i - lenWord + 1] = fail->id;\\n        }\\n      }\\n    }\\n\\n  private:\\n    unique_ptr<Node[]> nodes;\\n    unique_ptr<Node*[]> queue;\\n    Node root{};\\n    size_t nNode{};\\n  };\\npublic:\\n  vector<int> findSubstring(string text, vector<string>& words) {\\n    if (text.empty() || words.empty() || words[0].empty())\\n      return {};\\n    auto lenText = text.size();\\n    auto nWord = words.size();\\n    auto lenWord = words[0].size();\\n    auto lenPattern = nWord * lenWord;\\n    if (lenText < lenPattern)\\n      return {};\\n    vector<size_t> ids(text.size());\\n    vector<int> ctrDict;\\n    ctrDict.reserve(nWord);\\n    {\\n      AcAutomaton aca(nWord * lenWord);\\n      for (auto& word : words)\\n        aca.add(word, ctrDict);\\n      aca.build();\\n      aca.match(ids, text, lenWord);\\n    }\\n    auto nDistWord = ctrDict.size();\\n    vector<int> ctrText(nDistWord);\\n    vector<int> res;\\n    for (size_t i = 0; i < lenWord && i + lenPattern <= lenText; ++i) {\\n      fill(ctrText.begin(), ctrText.end(), 0);\\n      auto nMatchedDistWord = 0;\\n      for (size_t j = i; j < i + lenPattern; j += lenWord) {\\n        if (ids[j]) {\\n          auto idx = ids[j] - 1;\\n          if (ctrText[idx]++ == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n      }\\n      if (nMatchedDistWord == nDistWord)\\n        res.emplace_back(i);\\n      for (size_t j = i + lenPattern; j < lenText; j += lenWord) {\\n        if (ids[j]) {\\n          auto idx = ids[j] - 1;\\n          if (ctrText[idx]++ == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n        if (ids[j - lenPattern]) {\\n          auto idx = ids[j - lenPattern] - 1;\\n          if (ctrText[idx]-- == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n        if (nMatchedDistWord == nDistWord)\\n          res.emplace_back(j - lenPattern + lenWord);\\n      }\\n    }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\nprivate:\\n  class AcAutomaton {\\n  private:\\n    struct Node {\\n      Node* child[26]{};\\n      Node* fail{};\\n      // no next needed since all words have same length\\n      // Node* next{};\\n      size_t id{};\\n    };\\n  public:\\n    inline AcAutomaton(size_t nNode) :\\n      nodes(new Node[nNode]), queue(new Node*[nNode]) {}\\n\\n    inline void add(string_view sv, vector<int>& ctr) {\\n      auto cur = &root;\\n      for (auto ch : sv) {\\n        auto key = (size_t) (ch - \\'a\\');\\n        if (!cur->child[key])\\n          cur->child[key] = &nodes[nNode++];\\n        cur = cur->child[key];\\n      }\\n      if (cur->id)\\n        ++ctr[cur->id - 1];\\n      else {\\n        ctr.emplace_back(1);\\n        cur->id = ctr.size();\\n      }\\n    }\\n\\n    inline void build() {\\n      root.fail = &root;\\n      size_t qEnd = 0;\\n      for (auto key = 0; key < 26; ++key)\\n        if (root.child[key]) {\\n          auto cur = root.child[key];\\n          cur->fail = &root;\\n          queue[qEnd++] = cur;\\n        }\\n      for (size_t qBeg = 0; qBeg != qEnd; ++qBeg)\\n        for (auto key = 0; key < 26; ++key)\\n          if (queue[qBeg]->child[key]) {\\n            auto cur = queue[qBeg]->child[key];\\n            auto fail = queue[qBeg]->fail;\\n            while (fail != &root && !fail->child[key])\\n              fail = fail->fail;\\n            cur->fail = fail->child[key] ? fail->child[key] : &root;\\n            queue[qEnd++] = cur;\\n          }\\n    }\\n\\n    inline void match(vector<size_t>& ids, string_view sv, size_t lenWord) {\\n      auto fail = &root;\\n      for (size_t i = 0; i != sv.size(); ++i) {\\n        auto key = sv[i] - \\'a\\';\\n        while (fail != &root && !fail->child[key])\\n          fail = fail->fail;\\n        if (fail->child[key]) {\\n          fail = fail->child[key];\\n          if (fail->id)\\n            ids[i - lenWord + 1] = fail->id;\\n        }\\n      }\\n    }\\n\\n  private:\\n    unique_ptr<Node[]> nodes;\\n    unique_ptr<Node*[]> queue;\\n    Node root{};\\n    size_t nNode{};\\n  };\\npublic:\\n  vector<int> findSubstring(string text, vector<string>& words) {\\n    if (text.empty() || words.empty() || words[0].empty())\\n      return {};\\n    auto lenText = text.size();\\n    auto nWord = words.size();\\n    auto lenWord = words[0].size();\\n    auto lenPattern = nWord * lenWord;\\n    if (lenText < lenPattern)\\n      return {};\\n    vector<size_t> ids(text.size());\\n    vector<int> ctrDict;\\n    ctrDict.reserve(nWord);\\n    {\\n      AcAutomaton aca(nWord * lenWord);\\n      for (auto& word : words)\\n        aca.add(word, ctrDict);\\n      aca.build();\\n      aca.match(ids, text, lenWord);\\n    }\\n    auto nDistWord = ctrDict.size();\\n    vector<int> ctrText(nDistWord);\\n    vector<int> res;\\n    for (size_t i = 0; i < lenWord && i + lenPattern <= lenText; ++i) {\\n      fill(ctrText.begin(), ctrText.end(), 0);\\n      auto nMatchedDistWord = 0;\\n      for (size_t j = i; j < i + lenPattern; j += lenWord) {\\n        if (ids[j]) {\\n          auto idx = ids[j] - 1;\\n          if (ctrText[idx]++ == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n      }\\n      if (nMatchedDistWord == nDistWord)\\n        res.emplace_back(i);\\n      for (size_t j = i + lenPattern; j < lenText; j += lenWord) {\\n        if (ids[j]) {\\n          auto idx = ids[j] - 1;\\n          if (ctrText[idx]++ == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n        if (ids[j - lenPattern]) {\\n          auto idx = ids[j - lenPattern] - 1;\\n          if (ctrText[idx]-- == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n        if (nMatchedDistWord == nDistWord)\\n          res.emplace_back(j - lenPattern + lenWord);\\n      }\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315292,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n     \\n        List<Integer> ans = new ArrayList<>();\\n        if(words.length == 0) return ans;\\n        \\n        Map<String, Integer> t = new HashMap<>();\\n        for(String word : words)\\n            t.put(word, t.getOrDefault(word,0) +1);\\n        \\n        int k = words[0].length() * words.length;\\n        int inc = words[0].length();\\n        int n = s.length();\\n        \\n        \\n        for(int i=0; i< n-k+1; i++) { // Iterate through all windows\\n            Map<String, Integer> copy = new HashMap<String, Integer>(t);\\n            int counter = copy.size();\\n            for(int j =i; j < i+k ; j+=inc) { // For each window, check if  each word is in the hashmap.\\n                String word = s.substring(j,j+inc);\\n                if(copy.containsKey(word)) {\\n                    if(copy.get(word) == 1) counter--;\\n                    \\n                    copy.put(word,copy.get(word)-1);\\n                }\\n            }\\n            if(counter == 0) ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n     \\n        List<Integer> ans = new ArrayList<>();\\n        if(words.length == 0) return ans;\\n        \\n        Map<String, Integer> t = new HashMap<>();\\n        for(String word : words)\\n            t.put(word, t.getOrDefault(word,0) +1);\\n        \\n        int k = words[0].length() * words.length;\\n        int inc = words[0].length();\\n        int n = s.length();\\n        \\n        \\n        for(int i=0; i< n-k+1; i++) { // Iterate through all windows\\n            Map<String, Integer> copy = new HashMap<String, Integer>(t);\\n            int counter = copy.size();\\n            for(int j =i; j < i+k ; j+=inc) { // For each window, check if  each word is in the hashmap.\\n                String word = s.substring(j,j+inc);\\n                if(copy.containsKey(word)) {\\n                    if(copy.get(word) == 1) counter--;\\n                    \\n                    copy.put(word,copy.get(word)-1);\\n                }\\n            }\\n            if(counter == 0) ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286590,
                "title": "java-9ms-slide-window-and-map-solution-with-detailed-explanation",
                "content": "This problem is similar to [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/).  As mentioned in the title, we can use slide window and hashmap to solve the problem. The key though is sliding by a **word** instead of a **character**.\\n\\nThe slide window includes three parameters:\\n1. ```begin``` denotes the begin index of current window\\n2. ```current``` denotes the frequency of words contained in the current window\\n3. ```size``` denotes the number of words contained in current window\\n\\n```\\npublic List<Integer> findSubstring(String s, String[] words) {\\n    List<Integer> resultList = new ArrayList<Integer>();\\n    if( s == null || s.length() < 1 || words.length < 1)\\n        return resultList;\\n\\t\\t\\n    Map<String, Integer> wordToFreq = new HashMap<String, Integer>();\\n    for(int i = 0; i < words.length; i++) {\\n        wordToFreq.put(words[i], wordToFreq.getOrDefault(words[i], 0) + 1);\\n    }\\n\\t\\n    int length = words[0].length();\\n    String str[] = new String[s.length()];\\n    for(int i = 0; i < length; i++) { \\n\\t\\t// initialize slide window\\n        int begin = i;\\n        Map<String, Integer> current = new HashMap<String, Integer>();\\n        int size = 0;\\t\\n\\t\\t\\n        for(int j = i; j <= s.length() - length; j += length) { // slide by the length of word\\n            str[j] = s.substring(j, j + length);\\n            if( wordToFreq.containsKey(str[j]) ) { // update slide window\\n                begin = begin == -1 ? j : begin;\\n                current.put(str[j], current.getOrDefault(str[j], 0) + 1);\\n                size++;\\n                if( size == words.length ) {\\n                    if( current.equals(wordToFreq) )\\n                        resultList.add(begin);\\n                    current.put(str[begin], current.get(str[begin]) - 1);\\n                    size--;\\n                    begin += length;\\n                }\\n            } else { // reset the slide window\\n                begin = -1;\\n                current.clear();\\n                size = 0;\\n            }\\n        }\\n    }\\n    return resultList;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```begin```\n```current```\n```size```\n```\\npublic List<Integer> findSubstring(String s, String[] words) {\\n    List<Integer> resultList = new ArrayList<Integer>();\\n    if( s == null || s.length() < 1 || words.length < 1)\\n        return resultList;\\n\\t\\t\\n    Map<String, Integer> wordToFreq = new HashMap<String, Integer>();\\n    for(int i = 0; i < words.length; i++) {\\n        wordToFreq.put(words[i], wordToFreq.getOrDefault(words[i], 0) + 1);\\n    }\\n\\t\\n    int length = words[0].length();\\n    String str[] = new String[s.length()];\\n    for(int i = 0; i < length; i++) { \\n\\t\\t// initialize slide window\\n        int begin = i;\\n        Map<String, Integer> current = new HashMap<String, Integer>();\\n        int size = 0;\\t\\n\\t\\t\\n        for(int j = i; j <= s.length() - length; j += length) { // slide by the length of word\\n            str[j] = s.substring(j, j + length);\\n            if( wordToFreq.containsKey(str[j]) ) { // update slide window\\n                begin = begin == -1 ? j : begin;\\n                current.put(str[j], current.getOrDefault(str[j], 0) + 1);\\n                size++;\\n                if( size == words.length ) {\\n                    if( current.equals(wordToFreq) )\\n                        resultList.add(begin);\\n                    current.put(str[begin], current.get(str[begin]) - 1);\\n                    size--;\\n                    begin += length;\\n                }\\n            } else { // reset the slide window\\n                begin = -1;\\n                current.clear();\\n                size = 0;\\n            }\\n        }\\n    }\\n    return resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218762,
                "title": "10-line-python-solution",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        if not words: return []\\n        m, n, o, target = len(s), len(words), len(words[0]), []\\n        for i in range(m-n*o+1):\\n            word_target = words[:]\\n            for k in range(n):\\n                word = s[i+k*o:i+k*o+o]\\n                if word in word_target: word_target.remove(word)\\n                else: break\\n            if not word_target: target.append(i)\\n        return target\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        if not words: return []\\n        m, n, o, target = len(s), len(words), len(words[0]), []\\n        for i in range(m-n*o+1):\\n            word_target = words[:]\\n            for k in range(n):\\n                word = s[i+k*o:i+k*o+o]\\n                if word in word_target: word_target.remove(word)\\n                else: break\\n            if not word_target: target.append(i)\\n        return target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192123,
                "title": "o-n-c-solution-8ms-beats-100",
                "content": "Basic idea is that you hash each word and sum the results. Then you can do a sliding window over the string (backwards) to see if you can match the hash. An additional optimization is present to achieve O(n) when looping over the string - rather than re-calculating the hash for every letter, we iterate using a stride of wordlength, drop the least recently hashed entry, and add the new entry. We need to repeat this wordlength times to ensure we match patterns with offsets not equal to wordlength.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> retVal;\\n        if (words.size()<1 || s.size()<1) return retVal;\\n        // Hash all the words seperately then add them together to get a magic number\\n        std::hash<std::string> hash_fn;\\n        size_t magicNumber = 0;\\n        for (int i=0; i<words.size(); i++) {\\n            magicNumber += hash_fn(words[i]);\\n        }\\n        int wordLength = words[0].size();\\n        // Concatenated substring will be a given length\\n        int minimumSize = words.size()*wordLength;\\n        // We do a sliding window calculation for each \\'offset\\' a pattern might have\\n        // This is faster than re-hashing the entire window because we can just drop the least recently hashed value\\n        for (int startOffset=0; startOffset<wordLength; startOffset++) {\\n            int i;\\n            size_t hashSum = 0;\\n            int minimum = 0LL-minimumSize-startOffset+s.size();\\n            // This means that the requested offset does not leave us with enough characters in the string!\\n            if (minimum < 0) return retVal;\\n            for (i=s.size()-startOffset-wordLength; i>=minimum; i-=wordLength) {\\n                hashSum+=hash_fn(s.substr(i,wordLength));\\n            }\\n            if (hashSum==magicNumber) retVal.push_back(i+wordLength);\\n            for (;i>=0; i-=wordLength) {\\n                hashSum-=hash_fn(s.substr(i+minimumSize,wordLength));\\n                hashSum+=hash_fn(s.substr(i,wordLength));\\n                if (hashSum==magicNumber) retVal.push_back(i);\\n            }\\n        }        \\n        return retVal;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> retVal;\\n        if (words.size()<1 || s.size()<1) return retVal;\\n        // Hash all the words seperately then add them together to get a magic number\\n        std::hash<std::string> hash_fn;\\n        size_t magicNumber = 0;\\n        for (int i=0; i<words.size(); i++) {\\n            magicNumber += hash_fn(words[i]);\\n        }\\n        int wordLength = words[0].size();\\n        // Concatenated substring will be a given length\\n        int minimumSize = words.size()*wordLength;\\n        // We do a sliding window calculation for each \\'offset\\' a pattern might have\\n        // This is faster than re-hashing the entire window because we can just drop the least recently hashed value\\n        for (int startOffset=0; startOffset<wordLength; startOffset++) {\\n            int i;\\n            size_t hashSum = 0;\\n            int minimum = 0LL-minimumSize-startOffset+s.size();\\n            // This means that the requested offset does not leave us with enough characters in the string!\\n            if (minimum < 0) return retVal;\\n            for (i=s.size()-startOffset-wordLength; i>=minimum; i-=wordLength) {\\n                hashSum+=hash_fn(s.substr(i,wordLength));\\n            }\\n            if (hashSum==magicNumber) retVal.push_back(i+wordLength);\\n            for (;i>=0; i-=wordLength) {\\n                hashSum-=hash_fn(s.substr(i+minimumSize,wordLength));\\n                hashSum+=hash_fn(s.substr(i,wordLength));\\n                if (hashSum==magicNumber) retVal.push_back(i);\\n            }\\n        }        \\n        return retVal;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124256,
                "title": "clean-code-in-java-beats-100",
                "content": "```\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> indices = new ArrayList<>();\\n        if (words.length == 0) {\\n            return indices;\\n        }\\n        //Put each word into a HashMap and calculate word frequency\\n        Map<String, Integer> wordMap = new HashMap<>();\\n        for (String word : words) {\\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\\n        }\\n        int wordLength = words[0].length();\\n        int window = words.length * wordLength;\\n        for (int i = 0; i < wordLength; i++) {\\n            //move a word\\'s length each time\\n            for (int j = i; j + window <= s.length(); j = j + wordLength) {\\n                //get the subStr\\n                String subStr = s.substring(j, j + window);\\n                Map<String, Integer> map = new HashMap<>();\\n                //start from the last word\\n                for (int k = words.length - 1; k >= 0 ; k--) {\\n                    //get the word from subStr\\n                    String word = subStr.substring(k * wordLength, (k + 1)* wordLength);\\n                    int count = map.getOrDefault(word, 0) + 1;\\n                    //if the num of the word is greater than wordMap\\'s, move (k * wordLength) and break\\n                    if (count > wordMap.getOrDefault(word, 0)) {\\n                        j = j + k * wordLength;\\n                        break;\\n                    } else if (k == 0){\\n                        indices.add(j);\\n                    } else {\\n                        map.put(word, count);\\n                    }\\n                }\\n            }\\n\\n        }\\n        return indices;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> indices = new ArrayList<>();\\n        if (words.length == 0) {\\n            return indices;\\n        }\\n        //Put each word into a HashMap and calculate word frequency\\n        Map<String, Integer> wordMap = new HashMap<>();\\n        for (String word : words) {\\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\\n        }\\n        int wordLength = words[0].length();\\n        int window = words.length * wordLength;\\n        for (int i = 0; i < wordLength; i++) {\\n            //move a word\\'s length each time\\n            for (int j = i; j + window <= s.length(); j = j + wordLength) {\\n                //get the subStr\\n                String subStr = s.substring(j, j + window);\\n                Map<String, Integer> map = new HashMap<>();\\n                //start from the last word\\n                for (int k = words.length - 1; k >= 0 ; k--) {\\n                    //get the word from subStr\\n                    String word = subStr.substring(k * wordLength, (k + 1)* wordLength);\\n                    int count = map.getOrDefault(word, 0) + 1;\\n                    //if the num of the word is greater than wordMap\\'s, move (k * wordLength) and break\\n                    if (count > wordMap.getOrDefault(word, 0)) {\\n                        j = j + k * wordLength;\\n                        break;\\n                    } else if (k == 0){\\n                        indices.add(j);\\n                    } else {\\n                        map.put(word, count);\\n                    }\\n                }\\n            }\\n\\n        }\\n        return indices;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13697,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Substring with Concatenation of All Words** https://leetcode.com/problems/substring-with-concatenation-of-all-words/\\n\\n**Two Pointer Sliding Window**\\n* Say length of each word is wl and we have wc words. total_len of substring = wl * wc\\n* Two pointer sliding window solution. Initialize a window [start, end] = [0, total_len-1]\\n* Now we slide through s and capture every substring. We then test if this substring is valid and meets our conditions.\\n* We prepare a frequency map of input words. We call it ctr.\\n* We initialize a dictionary called seen.\\n* Now we pick every word (called next_word) sequentially in our window. Note there will be only wc words each of length wl.\\n* If next_word is not in ctr then we know the window is invalid. If it is, but the frequency in seen is already equal to the frequency in ctr, then we know we have an extra occurence of this word in the window and the window is invalid. Otherwise, we increment its frequency in seen.\\n* If every word in this window is valid, then the entire window is valid.\\n* Time complexity: (len(s) - wl * wc) * wc or number_of_windows * words_per_window\\n* Space complexity: O(wc) + O(wc)\\n```\\nfrom collections import Counter, defaultdict\\nclass Solution(object):\\n    def test(self, sub_str, word_len, ctr):\\n        i, seen = 0, defaultdict(int)\\n        while i < len(sub_str):\\n            next_word = sub_str[i:i+word_len]\\n            if next_word not in ctr or seen[next_word] == ctr[next_word]:\\n                return False\\n            seen[next_word], i = seen[next_word] + 1, i+word_len\\n        return True\\n    \\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        start, end, result = 0, len(words)*len(words[0])-1, []\\n        ctr = Counter(words)\\n        while end < len(s):\\n            if self.test(s[start:end+1], len(words[0]), ctr):\\n                result.append(start)\\n            start, end = start+1, end+1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter, defaultdict\\nclass Solution(object):\\n    def test(self, sub_str, word_len, ctr):\\n        i, seen = 0, defaultdict(int)\\n        while i < len(sub_str):\\n            next_word = sub_str[i:i+word_len]\\n            if next_word not in ctr or seen[next_word] == ctr[next_word]:\\n                return False\\n            seen[next_word], i = seen[next_word] + 1, i+word_len\\n        return True\\n    \\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        start, end, result = 0, len(words)*len(words[0])-1, []\\n        ctr = Counter(words)\\n        while end < len(s):\\n            if self.test(s[start:end+1], len(words[0]), ctr):\\n                result.append(start)\\n            start, end = start+1, end+1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13781,
                "title": "time-limit-exceed",
                "content": "    public class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (words == null || words.length == 0) {\\n                return result;\\n            }\\n            \\n            HashMap<String, Integer> wordLeft = new HashMap<String, Integer>();\\n            HashMap<String, Integer> wordFind = new HashMap<String, Integer>();\\n            \\n            for (String word : words) {\\n                if (!wordLeft.containsKey(word)) {\\n                    wordLeft.put(word, 1);\\n                }\\n                else {\\n                    wordLeft.put(word, wordLeft.get(word) + 1);\\n                }\\n            }\\n            \\n            int nWords = words.length, wordLength = words[0].length();\\n            for (int i = 0; i <= s.length() - nWords*wordLength; i++) {\\n                wordFind.clear();\\n                int j = 0;\\n                for (j = 0; j < nWords; j++) {\\n                    String sub = s.substring(i + j*wordLength, i + (j + 1)*wordLength);\\n                    if (!wordLeft.containsKey(sub)) break;\\n                    \\n                    if (!wordFind.containsKey(sub)) {\\n                        wordFind.put(sub,1);\\n                    }\\n                    else {\\n                        wordFind.put(sub, wordFind.get(sub) + 1);\\n                    }\\n                    \\n                    if (wordFind.get(sub) > wordLeft.get(sub)) break;\\n                }\\n                \\n                if (j == nWords) result.add(i);\\n            }\\n            \\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (words == null || words.length == 0) {\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13789,
                "title": "concise-c-o-kn-solution-with-explanation-68-ms",
                "content": "After realizing this problem is a variant of \"Longest Substring Without Repeating Characters\" and \"Minimum Window Substring\", I finally found this can be solved in the same way.\\n<br>Just replace the single character comparison with string comparison and original algorithm still works!\\n<br>Here is the algorithm.<br>\\n1. Maintain a sliding window and its start position.<br>\\n2. If the window is full of words, push start position to result vector and move start position to the right by one word length.<br>\\n3. Memorize each occurrence for each word. When adding a word to the window, check if the start position needs to be adjusted. If start position needs to be changed, use the memorized word position to update the start position. <br>\\nFor example, given input = (\"baa\", {\"a\", \"b\"}). When we encounter the second 'a', we know the start position should be moved to index 2 as the memorized occurrence indicates previous 'a' appears in the index 1.\\n<br>\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            vector<int> result;\\n            if (s.empty() || words.empty()) {\\n                return result;\\n            }\\n            const int wordlen = (int) words[0].length();\\n            const int offset = ((int) words.size() - 1) * wordlen;\\n            const int slen = (int) s.length();\\n            int start = -1;\\n            unordered_map<string, int> word_count;\\n            unordered_map<string, vector<int>> word_pos;\\n            for (string word : words) {\\n                word_count[word]++;\\n            }\\n            for (int i = 0; i < wordlen; ++i) {\\n                start = -1;\\n                word_pos.clear();\\n                for (int j = i; j <= slen - wordlen; j += wordlen) {\\n                    string candidate = s.substr(j, wordlen);\\n                    auto iter = word_count.find(candidate);\\n                    if (iter == word_count.end()) {\\n                        start = -1;\\n                        word_pos.clear();\\n                    } else {\\n                        if (-1 == start) {\\n                            start = j;\\n                        }\\n                        auto positer = word_pos.find(candidate);\\n                        if (positer == word_pos.end()) {\\n                            positer = word_pos.insert({candidate, vector<int>()}).first;\\n                        }\\n                        positer->second.push_back(j);\\n                        if (positer->second.size() > iter->second) {\\n                            if (positer->second[0] >= start) {\\n                                start = positer->second[0] + wordlen;\\n                            }\\n                            positer->second.erase(positer->second.begin());\\n                        }\\n                        if (offset == j - start) {\\n                            result.push_back(start);\\n                            start += wordlen;\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            vector<int> result;\\n            if (s.empty() || words.empty()) {\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13814,
                "title": "concise-c-solution",
                "content": "Idea is to store the occurrence of words in the dictionary in a hashtable and then try to construct a hashtable from the given string that will be equal to the constructed one from the dictionary\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& W) {\\n            vector<int> R;\\n            if (W.empty() || W[0].empty() || W[0].size() > s.size()) return R;\\n            int n = W[0].size();\\n            unordered_map<string, int> H;\\n            for (string w : W) H[w]++;\\n            for (int i = 0; i + n * W.size() <= s.size(); ++i) {\\n                string c = s.substr(i, n);\\n                if (H.count(c) != 0) {\\n                    unordered_map<string, int> C;\\n                    for (int j = 0; j < W.size(); ++j) {\\n                        c = s.substr(i + j * n, n);\\n                        if (H.count(c) != 0) C[c]++;\\n                        else break;\\n                    }\\n                    \\n                    bool equals = true;\\n                    for (auto p : H) equals &= (C.count(p.first) != 0) && (C[p.first] == p.second);\\n                    if (equals) R.push_back(i);\\n                }\\n            }\\n            \\n            return R;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& W) {\\n            vector<int> R;\\n            if (W.empty() || W[0].empty() || W[0].size() > s.size()) return R;\\n            int n = W[0].size();\\n            unordered_map<string, int> H;\\n            for (string w : W) H[w]++;\\n            for (int i = 0; i + n * W.size() <= s.size(); ++i) {\\n                string c = s.substr(i, n);\\n                if (H.count(c) != 0) {\\n                    unordered_map<string, int> C;\\n                    for (int j = 0; j < W.size(); ++j) {\\n                        c = s.substr(i + j * n, n);\\n                        if (H.count(c) != 0) C[c]++;\\n                        else break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3881353,
                "title": "other-posts-give-tle-sliding-window-hash-map-time-o-nw-space-o-mw2-beats-95-76-74-40",
                "content": "I notice that a lot of solutions given by the community is not optimal or even get TLE. So I am contributing my solution here.\\n\\n# Notation\\nLet $n$ be length of s, $w$ be length of a word, $m$ be the number of words.\\n\\n# Observation\\n- It\\'s obvious that this is a fix-length sliding window problem\\n- The string of appropriate length ending at $i$th character extends the string ending at the $i-w$th character\\n\\n# Intuition and Approach\\n- Maintain a dictionary for each coset (or say index shift) (i.e., $i \\\\to i+w \\\\to i+2w \\\\dots$)\\n- For each endpoint $i$\\n\\t- update the dictionary in $O(w)$, the code speaks for itself\\n\\t- check if the condition is satisfied in $O(1)$\\n  \\n# Complexity\\n- Time complexity: $O(nw)$\\n- Space complexity: $O(mw^2)$\\nIf we use rolling string hash, the complexity can be further reduced to Time $O(n)$, space $O(mw)$\\n\\n# Code\\n```\\n// by Maxwill Lin, O(w) time O(mw^2) space, beats 95.76%/74.40%\\n// can use rolling hash to optimize to O(n) tine O(m) space (and becomes probabilistic algorithm)\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int n = s.size(), m = words.size(), w = words[0].size();\\n        unordered_map<string, int> dict;\\n        vector<int> ans;\\n        vector<unordered_map<string, int>> dp(w);\\n        vector<int> passes(w);\\n        for(auto &word: words) ++dict[word];\\n        for(int i = 0; i < n; ++i) {\\n            auto& cur = dp[i%w];\\n            auto& pass = passes[i%w];\\n            // add new word\\n            if(i >= w-1) {\\n                string curS = s.substr(i-w+1, w);\\n                if(dict.contains(curS)) {\\n                    if(++cur[curS] == dict[curS]) ++pass;\\n                }\\n            }\\n            // remove old word\\n            if(i >= (m+1)*w-1) {\\n                string preS = s.substr(i-(m+1)*w+1, w);\\n                if(dict.contains(preS)) {\\n                    if(--cur[preS] == dict[preS]-1) --pass;\\n                }\\n            }\\n            // check if satisfied\\n            if(pass == dict.size()) ans.emplace_back(i-m*w+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// by Maxwill Lin, O(w) time O(mw^2) space, beats 95.76%/74.40%\\n// can use rolling hash to optimize to O(n) tine O(m) space (and becomes probabilistic algorithm)\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int n = s.size(), m = words.size(), w = words[0].size();\\n        unordered_map<string, int> dict;\\n        vector<int> ans;\\n        vector<unordered_map<string, int>> dp(w);\\n        vector<int> passes(w);\\n        for(auto &word: words) ++dict[word];\\n        for(int i = 0; i < n; ++i) {\\n            auto& cur = dp[i%w];\\n            auto& pass = passes[i%w];\\n            // add new word\\n            if(i >= w-1) {\\n                string curS = s.substr(i-w+1, w);\\n                if(dict.contains(curS)) {\\n                    if(++cur[curS] == dict[curS]) ++pass;\\n                }\\n            }\\n            // remove old word\\n            if(i >= (m+1)*w-1) {\\n                string preS = s.substr(i-(m+1)*w+1, w);\\n                if(dict.contains(preS)) {\\n                    if(--cur[preS] == dict[preS]-1) --pass;\\n                }\\n            }\\n            // check if satisfied\\n            if(pass == dict.size()) ans.emplace_back(i-m*w+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364752,
                "title": "python-sliding-window-solution-for-reference",
                "content": "1. First thing that comes in our minds is to generate all permutations\\nof the wordlist, store them in a hashmap, and do a sliding window on string \\'s\\'. This works but gives TLE . \\nHere is the code if anyone wants to take a look : \\n[BRUTE FORCE](https://leetcode.com/submissions/detail/925721567/) 151 / 178 test cases passed.\\n\\n3. But the act to generate all the permutations is suboptimal, \\nand will lead to T(n) ~ O(n!) or O(len(words)!)\\n\\n2. Now, since every word needs to be in our substring and every word has a same len. \\nFirst, we need to check every substing of \\'s\\'\\n2nd. This substring needs to have every word frm our wordlist\\n3rd. For this, we just count occurence of each word of our wordlist using a hashmap\\n4rd. In the substring , we check at the indexes in following order ( 0, wordlen, 2*wordlen, 3*wordlen ... ), because every word has the same length.\\n5th. And if we don\\'t have a word in  hashmap, the substring is invalid, if it is not invalid at any point, it was already totallen, so it contains all the occurence, we return True, and add the index to our result.\\n4. T(n) = O(len(s) * len(wordlist) )\\n( Every Substring of s )* \\n( Checking for each word in substring with slicing and hashing )\\n\\n5. Solution refernce [1](https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2418173/c-unordered-map-sliding-window-simple-easy-to-understand/)\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:  \\n        hmap = Counter(words)\\n        wlen =len(words[0]) \\n        tlen = len(words)*wlen\\n        def checksubstr(substr,hmap):\\n            # every word is of same len, so we skip that amount \\n            for i in range(0,len(substr),wlen):\\n                if(hmap[substr[i:i+wlen]] != 0 ):\\n                    hmap[substr[i:i+wlen]] -= 1\\n                else:\\n                    return False\\n            return True \\n        res = []\\n        start = 0 ;\\n        for i in range(tlen,len(s)+1):\\n            if( checksubstr(s[start:i] , copy.deepcopy(hmap) ) ):\\n                res.append(start)\\n            start += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:  \\n        hmap = Counter(words)\\n        wlen =len(words[0]) \\n        tlen = len(words)*wlen\\n        def checksubstr(substr,hmap):\\n            # every word is of same len, so we skip that amount \\n            for i in range(0,len(substr),wlen):\\n                if(hmap[substr[i:i+wlen]] != 0 ):\\n                    hmap[substr[i:i+wlen]] -= 1\\n                else:\\n                    return False\\n            return True \\n        res = []\\n        start = 0 ;\\n        for i in range(tlen,len(s)+1):\\n            if( checksubstr(s[start:i] , copy.deepcopy(hmap) ) ):\\n                res.append(start)\\n            start += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926750,
                "title": "java-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> answer = new ArrayList<>();\\n        \\n        int wordLength = words[0].length();\\n        int concatenatedStringLength = words.length * wordLength;\\n\\n        if(s.length() < concatenatedStringLength) return answer;\\n        \\n        Map<String, Integer> freqMap = new HashMap<>();\\n        for(String word: words) {\\n            freqMap.put(word, freqMap.getOrDefault(word, 0) + 1); \\n        }\\n\\n        for(int i=0;i<=s.length()-concatenatedStringLength;i++) {\\n            Map<String, Integer> tempMap = new HashMap<>();\\n            boolean found = true;\\n            for(int j=i; j < i + concatenatedStringLength; j+=wordLength) {\\n                String substr = s.substring(j, j+wordLength);\\n                if(!freqMap.containsKey(substr)) {\\n                    found = false;\\n                    break;\\n                }\\n                tempMap.put(substr, tempMap.getOrDefault(substr, 0) + 1);\\n            }\\n\\n            if(found) {\\n                for(Map.Entry<String, Integer> entry: tempMap.entrySet()) {\\n                    if(entry.getValue().intValue() != freqMap.get(entry.getKey()).intValue()) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if(found) answer.add(i);\\n        }\\n        return answer;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> answer = new ArrayList<>();\\n        \\n        int wordLength = words[0].length();\\n        int concatenatedStringLength = words.length * wordLength;\\n\\n        if(s.length() < concatenatedStringLength) return answer;\\n        \\n        Map<String, Integer> freqMap = new HashMap<>();\\n        for(String word: words) {\\n            freqMap.put(word, freqMap.getOrDefault(word, 0) + 1); \\n        }\\n\\n        for(int i=0;i<=s.length()-concatenatedStringLength;i++) {\\n            Map<String, Integer> tempMap = new HashMap<>();\\n            boolean found = true;\\n            for(int j=i; j < i + concatenatedStringLength; j+=wordLength) {\\n                String substr = s.substring(j, j+wordLength);\\n                if(!freqMap.containsKey(substr)) {\\n                    found = false;\\n                    break;\\n                }\\n                tempMap.put(substr, tempMap.getOrDefault(substr, 0) + 1);\\n            }\\n\\n            if(found) {\\n                for(Map.Entry<String, Integer> entry: tempMap.entrySet()) {\\n                    if(entry.getValue().intValue() != freqMap.get(entry.getKey()).intValue()) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if(found) answer.add(i);\\n        }\\n        return answer;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833905,
                "title": "java-hashmap-83-memory-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int len = 0, wordLength = words[0].length();\\n        for (String word : words) {\\n            if (map.containsKey(word)) {\\n                map.put(word, map.get(word) + 1);\\n            } else {\\n                map.put(word, 1);\\n            }\\n            len += word.length();\\n        }\\n\\n        List<Integer> indices = new ArrayList<>();\\n        int times = s.length() - len;\\n        for (int i = 0; i <= times; i++) {\\n            if (map.isEmpty()) {\\n                for (String word : words) {\\n                    if (map.containsKey(word)) {\\n                        map.put(word, map.get(word) + 1);\\n                    } else {\\n                        map.put(word, 1);\\n                    }\\n                }\\n            }\\n            String sub = s.substring(i, i + len);\\n            int count = 0;\\n            while (count < words.length) {\\n                String word = sub.substring(0, wordLength);\\n                Integer freq = map.get(word);\\n                if (freq != null && freq > 0) {\\n                    map.put(word, freq - 1);\\n                    sub = sub.substring(wordLength);\\n                    count++;\\n                } else break;\\n            }\\n            if (count == words.length) {\\n                indices.add(i);\\n            }\\n            map.clear();\\n        }\\n        return indices;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int len = 0, wordLength = words[0].length();\\n        for (String word : words) {\\n            if (map.containsKey(word)) {\\n                map.put(word, map.get(word) + 1);\\n            } else {\\n                map.put(word, 1);\\n            }\\n            len += word.length();\\n        }\\n\\n        List<Integer> indices = new ArrayList<>();\\n        int times = s.length() - len;\\n        for (int i = 0; i <= times; i++) {\\n            if (map.isEmpty()) {\\n                for (String word : words) {\\n                    if (map.containsKey(word)) {\\n                        map.put(word, map.get(word) + 1);\\n                    } else {\\n                        map.put(word, 1);\\n                    }\\n                }\\n            }\\n            String sub = s.substring(i, i + len);\\n            int count = 0;\\n            while (count < words.length) {\\n                String word = sub.substring(0, wordLength);\\n                Integer freq = map.get(word);\\n                if (freq != null && freq > 0) {\\n                    map.put(word, freq - 1);\\n                    sub = sub.substring(wordLength);\\n                    count++;\\n                } else break;\\n            }\\n            if (count == words.length) {\\n                indices.add(i);\\n            }\\n            map.clear();\\n        }\\n        return indices;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812038,
                "title": "c-simple-solution",
                "content": "\\n\\n# Code\\n```\\n    public class Solution\\n    {\\n        public IList<int> FindSubstring(string s, string[] words)\\n        {\\n            int oneWordLength = words[0].Length;\\n            int permLength = words.Length * oneWordLength;\\n            var result = new List<int>();\\n\\n            int sLength = s.Length;\\n\\n            for (int i = 0; i <= sLength - permLength; i++)\\n            {\\n                string temp = s.Substring(i, permLength);\\n                if (IsPerm(temp, words, oneWordLength, permLength))\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n            return result;\\n        }\\n\\n        private bool IsPerm(string s, string[] words, int oneWordLength, int permLength)\\n        {\\n            bool result = true;\\n            int num = permLength / oneWordLength;\\n            List<string> wordList = words.ToList();\\n\\n            for (int i = 0; i < num; i++)\\n            {\\n                int index = i * oneWordLength;\\n                string temp = s.Substring(index, oneWordLength);\\n                if (!wordList.Contains(temp))\\n                {\\n                    result = false;\\n                    break;\\n                }\\n                else\\n                {\\n                    wordList.Remove(temp);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public IList<int> FindSubstring(string s, string[] words)\\n        {\\n            int oneWordLength = words[0].Length;\\n            int permLength = words.Length * oneWordLength;\\n            var result = new List<int>();\\n\\n            int sLength = s.Length;\\n\\n            for (int i = 0; i <= sLength - permLength; i++)\\n            {\\n                string temp = s.Substring(i, permLength);\\n                if (IsPerm(temp, words, oneWordLength, permLength))\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n            return result;\\n        }\\n\\n        private bool IsPerm(string s, string[] words, int oneWordLength, int permLength)\\n        {\\n            bool result = true;\\n            int num = permLength / oneWordLength;\\n            List<string> wordList = words.ToList();\\n\\n            for (int i = 0; i < num; i++)\\n            {\\n                int index = i * oneWordLength;\\n                string temp = s.Substring(index, oneWordLength);\\n                if (!wordList.Contains(temp))\\n                {\\n                    result = false;\\n                    break;\\n                }\\n                else\\n                {\\n                    wordList.Remove(temp);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713095,
                "title": "using-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom functools import reduce\\nimport textwrap\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        # Dynamic Programming: Recursion, Memoize* & Bottom-Up Approach\\n\\n        # get the length of each word in `words`\\n        word_length = len(words[0])\\n        # get the total length of the concatenated words as `nth`\\n        total_words_length = word_length * len(words)\\n\\n        # word_dict = {}\\n\\n        # # make hashmap of words\\n        # for k in range(len(words)):\\n        #     word_dict[words[k]] = 0\\n\\n        # traverse through the string and get each `nt` clips:\\n\\n        result_indexes = []\\n\\n        memo = []\\n\\n        for i in range(len(s)):\\n            # divide them equally and check if everyone of them fit equally to words\\n            search = s[i:total_words_length+i]\\n\\n            if len(search) == total_words_length:\\n                # [Keep a hashmap of the count of each words, if not satifisfied, change all back to 0]\\n                if search in memo:\\n                    result_indexes.append(i)\\n                else:\\n                    # sorted `words`\\n                    _words = sorted(words)\\n                    _test_words = sorted(textwrap.wrap(search, word_length))\\n\\n                    if _words == _test_words:\\n                        memo.append(search)\\n                        result_indexes.append(i)\\n\\n        return result_indexes\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nimport textwrap\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        # Dynamic Programming: Recursion, Memoize* & Bottom-Up Approach\\n\\n        # get the length of each word in `words`\\n        word_length = len(words[0])\\n        # get the total length of the concatenated words as `nth`\\n        total_words_length = word_length * len(words)\\n\\n        # word_dict = {}\\n\\n        # # make hashmap of words\\n        # for k in range(len(words)):\\n        #     word_dict[words[k]] = 0\\n\\n        # traverse through the string and get each `nt` clips:\\n\\n        result_indexes = []\\n\\n        memo = []\\n\\n        for i in range(len(s)):\\n            # divide them equally and check if everyone of them fit equally to words\\n            search = s[i:total_words_length+i]\\n\\n            if len(search) == total_words_length:\\n                # [Keep a hashmap of the count of each words, if not satifisfied, change all back to 0]\\n                if search in memo:\\n                    result_indexes.append(i)\\n                else:\\n                    # sorted `words`\\n                    _words = sorted(words)\\n                    _test_words = sorted(textwrap.wrap(search, word_length))\\n\\n                    if _words == _test_words:\\n                        memo.append(search)\\n                        result_indexes.append(i)\\n\\n        return result_indexes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419625,
                "title": "c-hashmap-easy-to-follow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v;\\n        unordered_map<string,int> m;\\n        for(auto x:words)\\n            m[x]++;\\n        \\n        int l=words[0].length();\\n        int len=words.size()*l;\\n        len=s.length()-len;\\n        if(len<0)// none is possible\\n            return v;\\n        for(int i=0;i<=len;i++)\\n        {\\n            unordered_map<string,int> mp=m;\\n            int c=0;\\n            for(int j=i;j<s.size();j+=l)\\n            {\\n                string x=s.substr(j,l);\\n                if(mp[x]>0)\\n                {\\n                    c++;\\n                    mp[x]--;\\n                }\\n                else\\n                    break;\\n            }\\n            if(c==words.size())\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n\\nRecursive Method ( Faster then above ) : \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v;\\n        unordered_map<string,int> m;\\n        for(auto x:words)\\n            m[x]++;\\n        \\n        int l=words[0].length();\\n        int len=words.size()*l;\\n        int temp=s.length()-len;\\n        if(len<0)// none is possible\\n            return v;\\n        for(int i=0;i<=temp;i++)\\n        {\\n            int c=fun(s,m,i,i+len,l);\\n            if(c==words.size())\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n    int fun(string& s,unordered_map<string,int>& m,int i,int len,int l)\\n    {\\n        if(i==len)\\n            return 0;\\n        \\n        string x=s.substr(i,l);\\n        int t;\\n        if(m.find(x)!=m.end() && m[x]>0)\\n        {\\n            m[x]--;\\n            t=1+fun(s,m,i+l,len,l);\\n            m[x]++;\\n        }\\n        else\\n            t=0;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v;\\n        unordered_map<string,int> m;\\n        for(auto x:words)\\n            m[x]++;\\n        \\n        int l=words[0].length();\\n        int len=words.size()*l;\\n        len=s.length()-len;\\n        if(len<0)// none is possible\\n            return v;\\n        for(int i=0;i<=len;i++)\\n        {\\n            unordered_map<string,int> mp=m;\\n            int c=0;\\n            for(int j=i;j<s.size();j+=l)\\n            {\\n                string x=s.substr(j,l);\\n                if(mp[x]>0)\\n                {\\n                    c++;\\n                    mp[x]--;\\n                }\\n                else\\n                    break;\\n            }\\n            if(c==words.size())\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v;\\n        unordered_map<string,int> m;\\n        for(auto x:words)\\n            m[x]++;\\n        \\n        int l=words[0].length();\\n        int len=words.size()*l;\\n        int temp=s.length()-len;\\n        if(len<0)// none is possible\\n            return v;\\n        for(int i=0;i<=temp;i++)\\n        {\\n            int c=fun(s,m,i,i+len,l);\\n            if(c==words.size())\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n    int fun(string& s,unordered_map<string,int>& m,int i,int len,int l)\\n    {\\n        if(i==len)\\n            return 0;\\n        \\n        string x=s.substr(i,l);\\n        int t;\\n        if(m.find(x)!=m.end() && m[x]>0)\\n        {\\n            m[x]--;\\n            t=1+fun(s,m,i+l,len,l);\\n            m[x]++;\\n        }\\n        else\\n            t=0;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419096,
                "title": "c-hashmap-sliding-window",
                "content": "**Approach: Sliding Window + Hashmap**\\n**Steps:**\\n1. Insert the word counts into a hahsmap.\\n2. Iterate through every substring `str` in `s` with size `len`.\\n3. Use `l` and `r` to keep track on the starting and ending index.\\n4. If  `str` in `hashmap` is greater than 0,  `str` can be used for concatenation. Set `str` to in used by decreasing the count of `str` in hashmap. \\n3. If `str` in `hashmap` is 0, the `str` might be already in used. Remove the substring starting from `l` until the `str` is not in used. If still `str` in `hashmap` is 0, `str` is not a string in `words`. Move to next iteration.\\n5. Add `l` to the result when the window size `r - l` is equals to  `number of word * length of word`. \\n\\n**Example:**\\nIf the length of word is 3, we can iterate through every substring in 3 iterations by changing the starting index to `0, 1 and 2`. \\n\\n1st iteration:\\n![image](https://assets.leetcode.com/users/images/612a06de-d098-4c5e-b9a0-5137e3b5d242_1660380232.6132529.png)\\n\\n2nd iteration:\\n![image](https://assets.leetcode.com/users/images/3cc8e0ce-661a-4e5a-a749-238fa6ceb16c_1660380274.0505571.png)\\n\\n3rd iteration:\\n![image](https://assets.leetcode.com/users/images/105ab42a-6c17-462d-b205-09399988f2e8_1660380293.1976612.png)\\n\\n**Code**\\n\\n```\\nvector<int> findSubstring(string s, vector<string>& words) {\\n    int len = words.front().size();\\n\\n    vector<int> res;\\n    for (int i = 0; i < len; i++) {\\n        unordered_map<string, int> counter;\\n        for (const string& s: words) counter[s]++;\\n\\n        for (int l = i, r = i + len; r <= s.size(); r += len) {\\n            const string& str = s.substr(r - len, len);\\n            while (counter[str] == 0 && l < r - len) {\\n                counter[s.substr(l, len)]++;\\n                l += len;\\n            }\\n\\n            if (counter[str] == 0) {\\n                l += len;\\n                continue;\\n            }\\n\\n            counter[str]--;\\n\\n            if (r - l == words.size() * len) {\\n                res.push_back(l);\\n            }\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> findSubstring(string s, vector<string>& words) {\\n    int len = words.front().size();\\n\\n    vector<int> res;\\n    for (int i = 0; i < len; i++) {\\n        unordered_map<string, int> counter;\\n        for (const string& s: words) counter[s]++;\\n\\n        for (int l = i, r = i + len; r <= s.size(); r += len) {\\n            const string& str = s.substr(r - len, len);\\n            while (counter[str] == 0 && l < r - len) {\\n                counter[s.substr(l, len)]++;\\n                l += len;\\n            }\\n\\n            if (counter[str] == 0) {\\n                l += len;\\n                continue;\\n            }\\n\\n            counter[str]--;\\n\\n            if (r - l == words.size() * len) {\\n                res.push_back(l);\\n            }\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2418838,
                "title": "c-best-soln-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>res;\\n        unordered_map<string,int>wmap;\\n        int slen = s.size();           //lenght of string(18)\\n        int noOfWord = words.size();   //no of word in word vector(2)\\n        int wordLen = words[0].size(); //length of a single word(3)\\n        int TotalWSize = noOfWord*wordLen;  //total word size(6)\\n        \\n        if(TotalWSize > slen)      //if the total word size is more than slen (6>18)\\n            return res;\\n        \\n        //word map wth all entry wmap[\"foo\":1, \"bar\":1]\\n        for(auto it:words)        \\n            wmap[it]++;\\n        \\n        for(int i=0;i<=slen-TotalWSize;i++){   //i<slen-TotalWSize this means i<18-6 / i<12\\n            //count of a freq in give length\\n            unordered_map<string,int>wfreq;\\n            for(int j=i;j<i+TotalWSize;j+=wordLen){ //taking the length of wordlen to jump\\n                string str = s.substr(j,wordLen);  //cal the sub string\\n                if(wmap.find(str)==wmap.end())   //if sub str is not present then break\\n                    break;\\n                wfreq[str]++;\\n                if(wfreq[str]>wmap[str])       //if str cnt is more than break \\n                        break;\\n            }\\n            if(wfreq == wmap)        //if we get all value same then add the start index\\n                res.push_back(i);\\n        }       \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>res;\\n        unordered_map<string,int>wmap;\\n        int slen = s.size();           //lenght of string(18)\\n        int noOfWord = words.size();   //no of word in word vector(2)\\n        int wordLen = words[0].size(); //length of a single word(3)\\n        int TotalWSize = noOfWord*wordLen;  //total word size(6)\\n        \\n        if(TotalWSize > slen)      //if the total word size is more than slen (6>18)\\n            return res;\\n        \\n        //word map wth all entry wmap[\"foo\":1, \"bar\":1]\\n        for(auto it:words)        \\n            wmap[it]++;\\n        \\n        for(int i=0;i<=slen-TotalWSize;i++){   //i<slen-TotalWSize this means i<18-6 / i<12\\n            //count of a freq in give length\\n            unordered_map<string,int>wfreq;\\n            for(int j=i;j<i+TotalWSize;j+=wordLen){ //taking the length of wordlen to jump\\n                string str = s.substr(j,wordLen);  //cal the sub string\\n                if(wmap.find(str)==wmap.end())   //if sub str is not present then break\\n                    break;\\n                wfreq[str]++;\\n                if(wfreq[str]>wmap[str])       //if str cnt is more than break \\n                        break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2418758,
                "title": "c-easy-explanation-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int n = words[0].length(), ln = s.length();\\n        vector<int>m1(26, 0), m2(26, 0), ans;\\n        map<string, int>mapp;\\n        \\n        for(int i=0; i<words.size(); i++){\\n            string str = words[i];\\n            for(int j=0; j<n; j++){\\n                m1[str[j] - \\'a\\']++;   // just mapping all the character from words vector\\n            }\\n            mapp[str]++; // and also store just word into map\\n        } \\n        int k = n*words.size(); // length of the substring\\n        \\n        for(int i=0, j=0; i<ln; i++){\\n            m2[s[i] - \\'a\\']++;   //putting through the every character from s into m2 map\\n            \\n            if(i+1 >= k){\\n                if(m1 == m2){ // if the character map same  \\n                    string str = \"\";\\n                    map<string, int> mapp2;\\n                    for(int x = i-k+1; x<i+1; x++){ \\n                        str += s[x];\\n                        if(str.length() == n){ // then insert the word corresponding the m2 mapp with n(each word length) length\\n                            mapp2[str]++;\\n                            str.clear();\\n                        }\\n                    }\\n                    if(mapp == mapp2) ans.push_back(i-k+1); // then check if they are same or not\\n                }\\n                m2[s[j++] - \\'a\\']--; // every iteration removing the first character just slide the window\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int n = words[0].length(), ln = s.length();\\n        vector<int>m1(26, 0), m2(26, 0), ans;\\n        map<string, int>mapp;\\n        \\n        for(int i=0; i<words.size(); i++){\\n            string str = words[i];\\n            for(int j=0; j<n; j++){\\n                m1[str[j] - \\'a\\']++;   // just mapping all the character from words vector\\n            }\\n            mapp[str]++; // and also store just word into map\\n        } \\n        int k = n*words.size(); // length of the substring\\n        \\n        for(int i=0, j=0; i<ln; i++){\\n            m2[s[i] - \\'a\\']++;   //putting through the every character from s into m2 map\\n            \\n            if(i+1 >= k){\\n                if(m1 == m2){ // if the character map same  \\n                    string str = \"\";\\n                    map<string, int> mapp2;\\n                    for(int x = i-k+1; x<i+1; x++){ \\n                        str += s[x];\\n                        if(str.length() == n){ // then insert the word corresponding the m2 mapp with n(each word length) length\\n                            mapp2[str]++;\\n                            str.clear();\\n                        }\\n                    }\\n                    if(mapp == mapp2) ans.push_back(i-k+1); // then check if they are same or not\\n                }\\n                m2[s[j++] - \\'a\\']--; // every iteration removing the first character just slide the window\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2418466,
                "title": "finding-problem-statement-confusing-read-this",
                "content": "It took me some time to understand what exactly the problem meant.\\nSo adding some clarifications for anyone having similar confusion.\\n\\n_____________\\n\\n**Statement 1 :** You are given a string `s` and an array of strings `words` of the same length.\\n\\nThough \"you are given A & B of same length\" can mean lengths of A & B are same. It isn\\'t the case here.\\nThe \"same length\" in the statement means that all the words contained in `words` are of the same length.\\n\\n**Read it as :** You are given a string `s` and an array of strings `words` containing words of same lengths.\\n\\n_______________\\n\\n**Statement 2 :** Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters.\\n\\nBy \"concatenation of each word in `words`\", it means that the substring should have all the words present in `words`.\\nNot only each word in the substring should be from `words` but also every word in `words` should be present in the substring.\\n\\n**Read it as :** Return all starting indices of substring(s) in `s` that is a concatenation of all the words in `words` exactly once, in any order, and without any intervening characters.",
                "solutionTags": [],
                "code": "It took me some time to understand what exactly the problem meant.\\nSo adding some clarifications for anyone having similar confusion.\\n\\n_____________\\n\\n**Statement 1 :** You are given a string `s` and an array of strings `words` of the same length.\\n\\nThough \"you are given A & B of same length\" can mean lengths of A & B are same. It isn\\'t the case here.\\nThe \"same length\" in the statement means that all the words contained in `words` are of the same length.\\n\\n**Read it as :** You are given a string `s` and an array of strings `words` containing words of same lengths.\\n\\n_______________\\n\\n**Statement 2 :** Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters.\\n\\nBy \"concatenation of each word in `words`\", it means that the substring should have all the words present in `words`.\\nNot only each word in the substring should be from `words` but also every word in `words` should be present in the substring.\\n\\n**Read it as :** Return all starting indices of substring(s) in `s` that is a concatenation of all the words in `words` exactly once, in any order, and without any intervening characters.",
                "codeTag": "Unknown"
            },
            {
                "id": 2418397,
                "title": "c-strict-o-n-o-n-30-multiple-approaches-rolling-hash-sliding-window",
                "content": "Firstly we will see the O(N*30) approach and then later we will optimise it using rolling hash to get exact O(N) solution.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string> &w)\\n    {\\n        int len = w[0].size(), n = w.size();\\n        int k = n * len, l = 0, r = 0;\\n        unordered_map<string, int> mp;\\n        string sub[s.size()];\\n        for (int i = 0; i < w.size(); i++)\\n            mp[w[i]]++;// add all the strings of the given list in the unordered map\\n        for (int i = 0; i < s.size() - len + 1; i++)\\n            sub[i] = s.substr(i, len);\\n        vector<int> v;\\n        for (int i = 0; i < min((int)s.size(), len); i++) // we will only start with index<len as remaining index will be coveered by sliding window\\n        {\\n            int l = i, r = i, cn = mp.size();   // cn variable will denote the count of strings remaining to be matched\\n            unordered_map<string, int> mps;\\n            if (i + k > s.size())\\n                break;\\n            while (r + len <= s.size())\\n            {\\n                mps[sub[r]]++;\\n                if (mp.count(sub[r]))\\n                {\\n                    if (mps[sub[r]] == mp[sub[r]])\\n                        cn--; // decrease the count only when both map have equal count of strings\\n                    while (mps[sub[r]] > mp[sub[r]]) // remove occurence of string from left until count of string is greater in current map\\n                    {\\n                        if (mps[sub[l]] == mp[sub[l]])\\n                            cn++; // increment the count only when both maps have same count of current string\\n                        mps[sub[l]]--;\\n                        l += len;\\n                    }\\n                    if (cn == 0)\\n                        v.push_back(l);\\n                    r += len;\\n                }\\n                else\\n                {   // if the string is not found in the word list then we will start our search from r+len\\n                    // as all index before r+len will also contain this given string\\n                    mps.clear();\\n                    cn = mp.size();\\n                    r += len;\\n                    l = r;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\nNow to optimise it, we will use the hash value of the strings which will reduce our solution to O(N).\\n\\nIn the **sub** array we will add the hash value of all the string and rest code will be the same.\\n**34ms Accepted**\\n\\n\\n```\\nclass Solution\\n{\\npublic:\\n    long long mod = 1e9 + 7, base = 17;\\n    int get(string &s) // this function returns the hashed value of the string\\n    {\\n        long long h = 0;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            h *= base;\\n            h += (s[i] - \\'a\\');\\n            h %= mod;\\n        }\\n        return h;\\n    }\\n    vector<int> findSubstring(string s, vector<string> &w)\\n    {\\n        int len = w[0].size(), n = w.size();\\n        int k = n * len;\\n        unordered_map<int, int> mp;\\n        int sub[s.size()];\\n        for (int i = 0; i < w.size(); i++)\\n            mp[get(w[i])]++;\\n        string ss = s.substr(0, len);\\n        long long bb = 1;\\n        for (int i = 0; i < len - 1; i++)\\n            bb *= base, bb %= mod;\\n        sub[0] = get(ss);\\n        for (int i = 1; i < s.size() - len + 1; i++)\\n        {\\n            sub[i] = sub[i - 1];\\n            long long x = (s[i - 1] - \\'a\\') * bb; // removing the previous char from hash\\n            x %= mod;\\n            sub[i] -= x;\\n            if (sub[i] < 0)\\n                sub[i] += mod;\\n            long long y = sub[i];\\n            y *= base;\\n            y %= mod;\\n            sub[i] = y;\\n            sub[i] += (s[i + len - 1] - \\'a\\'); // adding current character in the hash\\n            sub[i] %= mod;\\n        }\\n\\n        // this part is same as above\\n        vector<int> v;\\n        for (int i = 0; i < min((int)s.size(), len); i++)\\n        {\\n            int l = i, r = i, cn = mp.size();\\n            unordered_map<int, int> mps;\\n            if (i + k > s.size())\\n                break;\\n            while (r + len <= s.size())\\n            {\\n                mps[sub[r]]++;\\n                if (mp.count(sub[r]))\\n                {\\n                    if (mps[sub[r]] == mp[sub[r]])\\n                        cn--;\\n                    while (mps[sub[r]] > mp[sub[r]])\\n                    {\\n                        if (mps[sub[l]] == mp[sub[l]])\\n                            cn++;\\n                        mps[sub[l]]--;\\n                        l += len;\\n                    }\\n                    if (cn == 0)\\n                        v.push_back(l);\\n                    r += len;\\n                }\\n                else\\n                {\\n                    mps.clear();\\n                    cn = mp.size();\\n                    r += len;\\n                    l = r;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string> &w)\\n    {\\n        int len = w[0].size(), n = w.size();\\n        int k = n * len, l = 0, r = 0;\\n        unordered_map<string, int> mp;\\n        string sub[s.size()];\\n        for (int i = 0; i < w.size(); i++)\\n            mp[w[i]]++;// add all the strings of the given list in the unordered map\\n        for (int i = 0; i < s.size() - len + 1; i++)\\n            sub[i] = s.substr(i, len);\\n        vector<int> v;\\n        for (int i = 0; i < min((int)s.size(), len); i++) // we will only start with index<len as remaining index will be coveered by sliding window\\n        {\\n            int l = i, r = i, cn = mp.size();   // cn variable will denote the count of strings remaining to be matched\\n            unordered_map<string, int> mps;\\n            if (i + k > s.size())\\n                break;\\n            while (r + len <= s.size())\\n            {\\n                mps[sub[r]]++;\\n                if (mp.count(sub[r]))\\n                {\\n                    if (mps[sub[r]] == mp[sub[r]])\\n                        cn--; // decrease the count only when both map have equal count of strings\\n                    while (mps[sub[r]] > mp[sub[r]]) // remove occurence of string from left until count of string is greater in current map\\n                    {\\n                        if (mps[sub[l]] == mp[sub[l]])\\n                            cn++; // increment the count only when both maps have same count of current string\\n                        mps[sub[l]]--;\\n                        l += len;\\n                    }\\n                    if (cn == 0)\\n                        v.push_back(l);\\n                    r += len;\\n                }\\n                else\\n                {   // if the string is not found in the word list then we will start our search from r+len\\n                    // as all index before r+len will also contain this given string\\n                    mps.clear();\\n                    cn = mp.size();\\n                    r += len;\\n                    l = r;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    long long mod = 1e9 + 7, base = 17;\\n    int get(string &s) // this function returns the hashed value of the string\\n    {\\n        long long h = 0;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            h *= base;\\n            h += (s[i] - \\'a\\');\\n            h %= mod;\\n        }\\n        return h;\\n    }\\n    vector<int> findSubstring(string s, vector<string> &w)\\n    {\\n        int len = w[0].size(), n = w.size();\\n        int k = n * len;\\n        unordered_map<int, int> mp;\\n        int sub[s.size()];\\n        for (int i = 0; i < w.size(); i++)\\n            mp[get(w[i])]++;\\n        string ss = s.substr(0, len);\\n        long long bb = 1;\\n        for (int i = 0; i < len - 1; i++)\\n            bb *= base, bb %= mod;\\n        sub[0] = get(ss);\\n        for (int i = 1; i < s.size() - len + 1; i++)\\n        {\\n            sub[i] = sub[i - 1];\\n            long long x = (s[i - 1] - \\'a\\') * bb; // removing the previous char from hash\\n            x %= mod;\\n            sub[i] -= x;\\n            if (sub[i] < 0)\\n                sub[i] += mod;\\n            long long y = sub[i];\\n            y *= base;\\n            y %= mod;\\n            sub[i] = y;\\n            sub[i] += (s[i + len - 1] - \\'a\\'); // adding current character in the hash\\n            sub[i] %= mod;\\n        }\\n\\n        // this part is same as above\\n        vector<int> v;\\n        for (int i = 0; i < min((int)s.size(), len); i++)\\n        {\\n            int l = i, r = i, cn = mp.size();\\n            unordered_map<int, int> mps;\\n            if (i + k > s.size())\\n                break;\\n            while (r + len <= s.size())\\n            {\\n                mps[sub[r]]++;\\n                if (mp.count(sub[r]))\\n                {\\n                    if (mps[sub[r]] == mp[sub[r]])\\n                        cn--;\\n                    while (mps[sub[r]] > mp[sub[r]])\\n                    {\\n                        if (mps[sub[l]] == mp[sub[l]])\\n                            cn++;\\n                        mps[sub[l]]--;\\n                        l += len;\\n                    }\\n                    if (cn == 0)\\n                        v.push_back(l);\\n                    r += len;\\n                }\\n                else\\n                {\\n                    mps.clear();\\n                    cn = mp.size();\\n                    r += len;\\n                    l = r;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418389,
                "title": "using-unordered-map-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool found(unordered_map<string, int> ump, string curr, int wordsize)\\n    {\\n        for(int i = 0 ; i < curr.size() ; i+=wordsize)\\n        {\\n            if(!ump[curr.substr(i, wordsize)]) return false;\\n            ump[curr.substr(i, wordsize)]--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>indexes;\\n        unordered_map<string, int>ump;\\n        int no_of_words = words.size();\\n        int len_of_words = no_of_words*words[0].length();\\n        if(s.size() < len_of_words) return {};\\n        for(auto it : words) ump[it]++;\\n        \\n        for(int i = 0 ; i <= s.size()-len_of_words ; i++)\\n        {\\n            if(found(ump, s.substr(i, len_of_words), words[0].size())) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool found(unordered_map<string, int> ump, string curr, int wordsize)\\n    {\\n        for(int i = 0 ; i < curr.size() ; i+=wordsize)\\n        {\\n            if(!ump[curr.substr(i, wordsize)]) return false;\\n            ump[curr.substr(i, wordsize)]--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>indexes;\\n        unordered_map<string, int>ump;\\n        int no_of_words = words.size();\\n        int len_of_words = no_of_words*words[0].length();\\n        if(s.size() < len_of_words) return {};\\n        for(auto it : words) ump[it]++;\\n        \\n        for(int i = 0 ; i <= s.size()-len_of_words ; i++)\\n        {\\n            if(found(ump, s.substr(i, len_of_words), words[0].size())) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418376,
                "title": "sliding-window-aditya-verma-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<char, int>mp;\\n        unordered_map<string, int>chk;\\n        int totSize = 0;\\n        for(auto it: words){\\n            chk[it]++;\\n            for(auto ele: it){\\n                mp[ele]++;\\n                totSize++;\\n            }\\n        }\\n        int wordSize = words[0].size();\\n        vector<int>ans;\\n        int cnt = mp.size(), i = 0, j = 0, n = s.size(), m = words.size();\\n        while(j<s.size()){\\n            if(mp.find(s[j]) != mp.end()){\\n                mp[s[j]]--;\\n                if(mp[s[j]] == 0){\\n                    cnt--;\\n                }\\n            }\\n            if(cnt == 0){\\n                while(cnt == 0){\\n                    if(mp.find(s[i]) != mp.end()){\\n                        mp[s[i]]++;\\n                            if(mp[s[i]] == 1){\\n                            cnt++;\\n                            int size = j-i+1, yo = chk.size();\\n                            for(int k = i; k<= j; k++){\\n                                string temp = s.substr(k, wordSize);\\n                                k+=wordSize-1;\\n                                if(chk.find(temp) != chk.end()){\\n                                    chk[temp]--;\\n                                    if(chk[temp] == 0){\\n                                        yo--;\\n                                    }\\n                                }\\n                            }\\n                            if(yo == 0 && size == totSize){\\n                                ans.push_back(i);\\n                            }\\n                            chk.clear();\\n                            for(auto it: words){\\n                                chk[it]++;\\n                            }\\n                        }\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<char, int>mp;\\n        unordered_map<string, int>chk;\\n        int totSize = 0;\\n        for(auto it: words){\\n            chk[it]++;\\n            for(auto ele: it){\\n                mp[ele]++;\\n                totSize++;\\n            }\\n        }\\n        int wordSize = words[0].size();\\n        vector<int>ans;\\n        int cnt = mp.size(), i = 0, j = 0, n = s.size(), m = words.size();\\n        while(j<s.size()){\\n            if(mp.find(s[j]) != mp.end()){\\n                mp[s[j]]--;\\n                if(mp[s[j]] == 0){\\n                    cnt--;\\n                }\\n            }\\n            if(cnt == 0){\\n                while(cnt == 0){\\n                    if(mp.find(s[i]) != mp.end()){\\n                        mp[s[i]]++;\\n                            if(mp[s[i]] == 1){\\n                            cnt++;\\n                            int size = j-i+1, yo = chk.size();\\n                            for(int k = i; k<= j; k++){\\n                                string temp = s.substr(k, wordSize);\\n                                k+=wordSize-1;\\n                                if(chk.find(temp) != chk.end()){\\n                                    chk[temp]--;\\n                                    if(chk[temp] == 0){\\n                                        yo--;\\n                                    }\\n                                }\\n                            }\\n                            if(yo == 0 && size == totSize){\\n                                ans.push_back(i);\\n                            }\\n                            chk.clear();\\n                            for(auto it: words){\\n                                chk[it]++;\\n                            }\\n                        }\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564822,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568692,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1575750,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 2016360,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568260,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1565448,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1716239,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568069,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1567322,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1574392,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1564822,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568692,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1575750,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 2016360,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568260,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1565448,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1716239,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568069,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1567322,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1574392,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1655036,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 2005832,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1892675,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1797665,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1670347,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1574127,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1572750,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1572399,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1571081,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1571082,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1573907,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 1576065,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2052213,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2049814,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2049221,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2043431,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2037178,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2027071,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2017979,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2016419,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2013854,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2005994,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2003621,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1999649,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1999303,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1994425,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1993064,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1990459,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1980032,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1976913,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1972336,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1959113,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1904416,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1890285,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1863723,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1849983,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1806068,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1799104,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1798495,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1797523,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            }
        ]
    }
]