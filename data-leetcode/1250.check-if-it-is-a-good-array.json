[
    {
        "title": "Prime Palindrome",
        "question_content": "Given an integer n, return the smallest prime palindrome greater than or equal to n.\nAn integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n\n\tFor example, 2, 3, 5, 7, 11, and 13 are all primes.\n\nAn integer is a palindrome if it reads the same from left to right as it does from right to left.\n\n\tFor example, 101 and 12321 are palindromes.\n\nThe test cases are generated so that the answer always exists and is in the range [2, 2 * 108].\n&nbsp;\nExample 1:\nInput: n = 6\nOutput: 7\nExample 2:\nInput: n = 8\nOutput: 11\nExample 3:\nInput: n = 13\nOutput: 101\n&nbsp;\nConstraints:\n\n\t1 <= n <= 108",
        "solutions": [
            {
                "id": 146798,
                "title": "java-c-python-all-even-length-palindrome-are-divisible-by-11",
                "content": "# **Intuition**\\nWrite some example, you find all even length palindromes are divisible by 11.\\nSo we need to search only palindrome with odd length.\\n\\nWe can prove as follow:\\n11 % 11 = 0\\n1111 % 11 = 0\\n111111 % 11 = 0\\n11111111 % 11 = 0\\n\\n**So:**\\n1001 % 11 = (1111 - 11 * 10) % 11 = 0\\n100001 % 11 = (111111 - 1111 * 10) % 11 = 0\\n10000001 % 11 = (11111111 - 111111 * 10) % 11 = 0\\n\\nFor any palindrome with even length:\\nabcddcba % 11\\n= (a * 10000001 + b * 100001 * 10 + c * 1001 * 100 + d * 11 * 1000) % 11\\n= 0\\n\\nAll palindrome with even length is multiple of `11`.\\nSo among them, 11 is the only one prime\\n`if (8 <= N <= 11) return 11`\\n\\nFor other cases, **we consider only palindrome with odd dights.**\\n<br>\\n\\n# More Generally\\nExplanation from @chuan-chih:\\nA number is divisible by 11 if `sum(even digits) - sum(odd digits)` is divisible by 11.\\n**Base case: 0**\\n**Inductive step:**\\nIf there is no carry when we add 11 to a number, both sums +1.\\nWhenever carry happens, one sum -10 and the other +1.\\nThe invariant holds in both cases.\\n<br>\\n\\n# **Time Complexity**\\n`O(10000)` to check all numbers 1 - 10000.\\n`isPrime` function is `O(sqrt(x))` in worst case.\\nBut only `sqrt(N)` worst cases for `1 <= x <= N`\\nIn general it\\'s `O(logx)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; ++x) {\\n            string s = to_string(x), r(s.rbegin(), s.rend());\\n            int y = stoi(s + r.substr(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n    bool isPrime(int num) {\\n        if (num < 2 || num % 2 == 0) return num == 2;\\n        for (int i = 3; i * i <= num; i += 2)\\n            if (num % i == 0) return false;\\n        return true;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n```\\n\\n\\n**Python:**\\n```py\\n    def primePalindrome(self, N):\\n        def isPrime(x):\\n            if x < 2 or x % 2 == 0: return x == 2\\n            for i in xrange(3, int(x**0.5) + 1, 2):\\n                if x % i == 0: return False\\n            return True\\n        if 8 <= N <= 11: return 11\\n        for x in xrange(10 ** (len(str(N)) / 2), 10**5):\\n            y = int(str(x) + str(x)[-2::-1])\\n            if y >= N and isPrime(y): return y\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; ++x) {\\n            string s = to_string(x), r(s.rbegin(), s.rend());\\n            int y = stoi(s + r.substr(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n    bool isPrime(int num) {\\n        if (num < 2 || num % 2 == 0) return num == 2;\\n        for (int i = 3; i * i <= num; i += 2)\\n            if (num % i == 0) return false;\\n        return true;\\n    }\\n```\n```java\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n```\n```py\\n    def primePalindrome(self, N):\\n        def isPrime(x):\\n            if x < 2 or x % 2 == 0: return x == 2\\n            for i in xrange(3, int(x**0.5) + 1, 2):\\n                if x % i == 0: return False\\n            return True\\n        if 8 <= N <= 11: return 11\\n        for x in xrange(10 ** (len(str(N)) / 2), 10**5):\\n            y = int(str(x) + str(x)[-2::-1])\\n            if y >= N and isPrime(y): return y\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 146766,
                "title": "c-o-1-0ms",
                "content": "base on exp, it should not be a big table; \\n\\n    class Solution {\\n    public:\\n        int primePalindrome(int N) {\\n            static vector<int> tab{\\n                2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, \\n                353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, \\n                10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, \\n                14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, \\n                18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, \\n                31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, \\n                35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, \\n                70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, \\n                74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, \\n                79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, \\n                94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, \\n                98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, \\n                1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, \\n                1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, \\n                1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, \\n                1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, \\n                1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, \\n                1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, \\n                1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, \\n                1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, \\n                1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, \\n                1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, \\n                1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, \\n                1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, \\n                1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, \\n                1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, \\n                1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, \\n                1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, \\n                1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, \\n                1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, \\n                1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, \\n                3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, \\n                3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, \\n                3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, \\n                3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, \\n                3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, \\n                3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, \\n                3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, \\n                3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, \\n                3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, \\n                3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, \\n                3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, \\n                3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, \\n                3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, \\n                3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, \\n                3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, \\n                3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, \\n                3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, \\n                7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, \\n                7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, \\n                7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, \\n                7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, \\n                7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, \\n                7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, \\n                7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, \\n                7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, \\n                7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, \\n                7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, \\n                7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, \\n                7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, \\n                7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, \\n                7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, \\n                7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, \\n                9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, \\n                9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, \\n                9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, \\n                9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, \\n                9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, \\n                9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, \\n                9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, \\n                9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, \\n                9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, \\n                9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, \\n                9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, \\n                9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, \\n                9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, \\n                9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, \\n                9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, \\n                100030001\\n            };\\n            return *lower_bound(tab.begin(), tab.end(), N);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int primePalindrome(int N) {\\n            static vector<int> tab{\\n                2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, \\n                353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, \\n                10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, \\n                14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, \\n                18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, \\n                31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, \\n                35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, \\n                70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, \\n                74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, \\n                79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, \\n                94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, \\n                98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, \\n                1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, \\n                1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, \\n                1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, \\n                1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, \\n                1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, \\n                1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, \\n                1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, \\n                1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, \\n                1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, \\n                1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, \\n                1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, \\n                1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, \\n                1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, \\n                1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, \\n                1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, \\n                1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, \\n                1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, \\n                1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, \\n                1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, \\n                3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, \\n                3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, \\n                3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, \\n                3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, \\n                3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, \\n                3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, \\n                3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, \\n                3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, \\n                3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, \\n                3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, \\n                3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, \\n                3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, \\n                3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, \\n                3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, \\n                3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, \\n                3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, \\n                3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, \\n                7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, \\n                7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, \\n                7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, \\n                7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, \\n                7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, \\n                7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, \\n                7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, \\n                7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, \\n                7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, \\n                7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, \\n                7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, \\n                7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, \\n                7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, \\n                7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, \\n                7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, \\n                9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, \\n                9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, \\n                9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, \\n                9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, \\n                9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, \\n                9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, \\n                9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, \\n                9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, \\n                9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, \\n                9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, \\n                9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, \\n                9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, \\n                9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, \\n                9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, \\n                9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, \\n                100030001\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 146788,
                "title": "getting-one-over-the-system-o-1-solution-in-java",
                "content": "So I spend 30 mins (and 5 bugs) trying to get my O(N^2) solution to work. It doesn\\'t. So I get mad and rage-generate an array of all the palindromic primes using 1553 ms. Next, I put them into my revenge array.\\n\\n```\\nclass Solution {\\n    private final int[] hehehe = new int[]{2, 3, 5, 7, 11, 101, 131, 151, 181, 191, \\n\\t\\t313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, \\n\\t\\t11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, \\n\\t\\t15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, \\n\\t\\t19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, \\n\\t\\t32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, \\n\\t\\t36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, \\n\\t\\t71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, \\n\\t\\t76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, \\n\\t\\t79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, \\n\\t\\t94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, \\n\\t\\t1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, \\n\\t\\t1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, \\n\\t\\t1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311...};\\n```\\nYou get the idea.\\nO(1) solution I got after brute-forcing all the primes I needed.\\n```\\n    public final int[] hehehe; //(see above)\\n    public int primePalindrome(int N) {\\n        //2lazE to implement binary search\\n        for(int i = 0; i < hehehe.length; i++){\\n            if(N <= hehehe[i]){\\n                return hehehe[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nIt didn\\'t nab me for memory usage LOL. Check out the C++ one also, its faster (coder used binary search) and was posted first.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private final int[] hehehe = new int[]{2, 3, 5, 7, 11, 101, 131, 151, 181, 191, \\n\\t\\t313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, \\n\\t\\t11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, \\n\\t\\t15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, \\n\\t\\t19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, \\n\\t\\t32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, \\n\\t\\t36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, \\n\\t\\t71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, \\n\\t\\t76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, \\n\\t\\t79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, \\n\\t\\t94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, \\n\\t\\t1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, \\n\\t\\t1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, \\n\\t\\t1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311...};\\n```\n```\\n    public final int[] hehehe; //(see above)\\n    public int primePalindrome(int N) {\\n        //2lazE to implement binary search\\n        for(int i = 0; i < hehehe.length; i++){\\n            if(N <= hehehe[i]){\\n                return hehehe[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158439,
                "title": "c-even-odd-length-palindrome-merge-sort-like-solution-interviewer-really-loves-it-kiss",
                "content": "```\\n#include <string>\\n#include <algorithm>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int evenPalindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1;\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    int oddPlaindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1.substr(0, str1.length() - 1);\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    bool isPrime(int num) {\\n        if (num == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= num; ++i) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        int even = 1;\\n        int odd = 1;\\n\\n        int cur = 0;\\n        do {\\n            int evenp = evenPalindrome(even);\\n            int oddp = oddPlaindrome(odd);\\n            cur = min(evenp, oddp);\\n            if (evenp < oddp) {\\n                ++even;\\n            } else {\\n                ++odd;\\n            }\\n        } while (!(cur >= N && isPrime(cur)));\\n\\n        return cur;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <string>\\n#include <algorithm>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int evenPalindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1;\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    int oddPlaindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1.substr(0, str1.length() - 1);\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    bool isPrime(int num) {\\n        if (num == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= num; ++i) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        int even = 1;\\n        int odd = 1;\\n\\n        int cur = 0;\\n        do {\\n            int evenp = evenPalindrome(even);\\n            int oddp = oddPlaindrome(odd);\\n            cur = min(evenp, oddp);\\n            if (evenp < oddp) {\\n                ++even;\\n            } else {\\n                ++odd;\\n            }\\n        } while (!(cur >= N && isPrime(cur)));\\n\\n        return cur;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 146950,
                "title": "python-3-construct-palindromes-first-and-then-check-if-prime",
                "content": "```python\\nclass Solution:\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ndigits = len(str(N))\\n        while True:\\n            for x in self.palindromes(ndigits):\\n                if x >= N and self.isPrime(x):\\n                    return x\\n            ndigits += 1\\n            \\n    def palindromes(self, n):\\n        if n == 1:\\n            for i in range(10):\\n                yield i\\n        elif n % 2 == 0:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                yield int(s + s[::-1])\\n        else:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n                    \\n    def isPrime(self, x):\\n        if x == 1:\\n            return False\\n        if x == 2:\\n            return True\\n        for i in range(2, int(x**0.5+1)):\\n            if x % i == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ndigits = len(str(N))\\n        while True:\\n            for x in self.palindromes(ndigits):\\n                if x >= N and self.isPrime(x):\\n                    return x\\n            ndigits += 1\\n            \\n    def palindromes(self, n):\\n        if n == 1:\\n            for i in range(10):\\n                yield i\\n        elif n % 2 == 0:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                yield int(s + s[::-1])\\n        else:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n                    \\n    def isPrime(self, x):\\n        if x == 1:\\n            return False\\n        if x == 2:\\n            return True\\n        for i in range(2, int(x**0.5+1)):\\n            if x % i == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212297,
                "title": "why-even-number-of-digit-prime-palindromes-are-not-possible",
                "content": "```\\nBecause even length prime digit numbers are divisible by 11 therefore are not prime.\\nIt\\'s a trick that has to do powers of 10 and mod 11.\\nEx: 10 = 10^1 mod 11 = -1 mod 11\\n      100 = 10^2 = 1 mod 11\\n      1000 = 10^3 = -1 mod 11\\n      10000 = 10^4 = 1 mod 11\\nSee the pattern? \\nEven exponent powers of 10 are 1 mod 11 \\nOdd exponent powers of 10 are -1 mod 11.\\n\\nWe also know decimal numbers are just base 10 expansion of the digits.\\n\\nSo   1225 = (10^3*)1 + 2*(10^2) + 2*(10^1) + 5*(10^0).\\n        using modular arithmetic we can say,\\n \\n        1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 - 2 + 5 = 4.\\n\\n        In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\\n\\nAnother example.\\n\\n    1323412 MOD 11 =   1 -3  +2 -3 +4 -1 +2 MOD 11 = 0. (x MOD 11 == 0) => 11 \\'divides\\' x\\nThen it becomes quite obvious why the above logic works for even palindromes.\\n\\nExample: \\n\\n321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0. All the numbers cancel out with each other.\\n\\n```",
                "solutionTags": [],
                "code": "```\\nBecause even length prime digit numbers are divisible by 11 therefore are not prime.\\nIt\\'s a trick that has to do powers of 10 and mod 11.\\nEx: 10 = 10^1 mod 11 = -1 mod 11\\n      100 = 10^2 = 1 mod 11\\n      1000 = 10^3 = -1 mod 11\\n      10000 = 10^4 = 1 mod 11\\nSee the pattern? \\nEven exponent powers of 10 are 1 mod 11 \\nOdd exponent powers of 10 are -1 mod 11.\\n\\nWe also know decimal numbers are just base 10 expansion of the digits.\\n\\nSo   1225 = (10^3*)1 + 2*(10^2) + 2*(10^1) + 5*(10^0).\\n        using modular arithmetic we can say,\\n \\n        1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 - 2 + 5 = 4.\\n\\n        In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\\n\\nAnother example.\\n\\n    1323412 MOD 11 =   1 -3  +2 -3 +4 -1 +2 MOD 11 = 0. (x MOD 11 == 0) => 11 \\'divides\\' x\\nThen it becomes quite obvious why the above logic works for even palindromes.\\n\\nExample: \\n\\n321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0. All the numbers cancel out with each other.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 146888,
                "title": "java-solution-building-closest-palindrome",
                "content": "Inspired by [564. Find the Closest Palindrome](https://leetcode.com/problems/find-the-closest-palindrome/description/)\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (N < Integer.MAX_VALUE) {\\n            N = nextPalin(\"\" + N);\\n            if (isPrime(N)) {\\n                return N;\\n            }\\n            N++;\\n        }\\n        return -1;\\n    }\\n    private int nextPalin(String n) {\\n        int l = n.length();\\n        List<Integer> cands = new LinkedList<>();\\n        int half = Integer.valueOf(n.substring(0, (l + 1) / 2));\\n        for (int i = half; i <= half + 1; i++) {\\n            String halfString = \"\" + i;\\n            if (l % 2 == 1) {\\n                halfString = halfString.substring(0, halfString.length() - 1);\\n            }\\n            String newString = \"\" + i + new StringBuilder(halfString).reverse().toString();\\n            cands.add(Integer.valueOf(newString));\\n        }\\n        int ori = Integer.valueOf(n), result = Integer.MAX_VALUE;\\n        for (int cand : cands) {\\n            if (cand >= ori && cand < result) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        long l = (long)n;\\n        for (long i = 2; i * i <= l; i++) {\\n            if (l % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (N < Integer.MAX_VALUE) {\\n            N = nextPalin(\"\" + N);\\n            if (isPrime(N)) {\\n                return N;\\n            }\\n            N++;\\n        }\\n        return -1;\\n    }\\n    private int nextPalin(String n) {\\n        int l = n.length();\\n        List<Integer> cands = new LinkedList<>();\\n        int half = Integer.valueOf(n.substring(0, (l + 1) / 2));\\n        for (int i = half; i <= half + 1; i++) {\\n            String halfString = \"\" + i;\\n            if (l % 2 == 1) {\\n                halfString = halfString.substring(0, halfString.length() - 1);\\n            }\\n            String newString = \"\" + i + new StringBuilder(halfString).reverse().toString();\\n            cands.add(Integer.valueOf(newString));\\n        }\\n        int ori = Integer.valueOf(n), result = Integer.MAX_VALUE;\\n        for (int cand : cands) {\\n            if (cand >= ori && cand < result) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        long l = (long)n;\\n        for (long i = 2; i * i <= l; i++) {\\n            if (l % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146835,
                "title": "java-solution-6ms",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N == 1 || N == 2) return 2;\\n        if (N % 2 == 0) N++;\\n        while (true) {\\n            if (isPalindrome(N) && isPrime(N)) return N;\\n            N += 2;\\n            if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int n) {\\n        if (n % 10 == 0 && n != 0) return false;\\n        int n1 = 0;\\n        while (n > n1) {\\n            n1 = n1 * 10 + (n % 10);\\n            n /= 10;\\n        }\\n        return n1 == n || n == n1 / 10;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = 3; i <= end; i += 2) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N == 1 || N == 2) return 2;\\n        if (N % 2 == 0) N++;\\n        while (true) {\\n            if (isPalindrome(N) && isPrime(N)) return N;\\n            N += 2;\\n            if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int n) {\\n        if (n % 10 == 0 && n != 0) return false;\\n        int n1 = 0;\\n        while (n > n1) {\\n            n1 = n1 * 10 + (n % 10);\\n            n /= 10;\\n        }\\n        return n1 == n || n == n1 / 10;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = 3; i <= end; i += 2) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146930,
                "title": "faster-way-to-find-palindrome-accepted-c-solution",
                "content": "My solution is based on Finding a palindrome number (`>=N`)first and then I will check it for a prime or not.\\nGiven a number `N`, I will check it for a palindrome, if not - then I find the closest palindrome (`>N`)\\nTo find the closest palindrome is the hardest part of this program. Here is the whole discussion. The discussion based on \"array int\" but I implemented the number considering a string.\\n\\nIf you have any **question** regarding my **code**, please **comment**. I will try to answer.\\n\\nFor example, if the input number is \\u201C2 3 5 4 5\\u201D, the output should be \\u201C2 3 6 3 2\\u201D. And if the input number is \\u201C9 9 9\\u201D, the output should be \\u201C1 0 0 1\\u201D.\\n\\nThere can be three different types of inputs that need to be handled separately.\\n\\n1) The input number has all 9s. For example \\u201C9 9 9\\u201D. Output should be \\u201C1 0 0 1\\u201D i, e., `answer = input+2`\\n\\n2) For input \\u201C1 2 3 4\\u201D. Output should be \\u201C1 3 3 1\\u201D\\n\\nHow to convert a given number to a greater palindrome? To understand the solution, let us first define the following two terms:\\nLeft Side: The left half of given number. Left side of \\u201C1 2 3 4 5 6\\u201D is \\u201C1 2 3\\u201D and left side of \\u201C1 2 3 4 5\\u201D is \\u201C1 2\\u201D\\nRight Side: The right half of given number. Right side of \\u201C1 2 3 4 5 6\\u201D is \\u201C4 5 6\\u201D and right side of \\u201C1 2 3 4 5\\u201D is \\u201C4 5\\u201D\\nTo convert to palindrome, we can either take the mirror of its left side or take mirror of its right side. However, if we take the mirror of the right side, then the palindrome so formed is not guaranteed to be next larger palindrome. So, we must take the mirror of left side and copy it to right side. But there are some cases that must be handled in different ways. See the following steps.\\n\\nWe will start with two indices i and j. i pointing to the two middle elements (or pointing to two elements around the middle element in case of n being odd). We one by one move i and j away from each other.\\n\\n\\nStep 1. Initially, ignore the part of left side which is same as the corresponding part of right side. For example, if the number is \\u201C8 3 4 2 2 4 6 9\\u2033, we ignore the middle four elements. i now points to element 3 and j now points to element 6.\\n\\nStep 2. After step 1, following cases arise:\\n\\nCase 1: Indices i & j cross the boundary.\\nThis case occurs when the input number is palindrome. In this case, we just add 1 to the middle digit (or digits in case n is even) propagate the carry towards MSB digit of left side and simultaneously copy mirror of the left side to the right side.\\nFor example, if the given number is \\u201C1 2 9 2 1\\u201D, we increment 9 to 10 and propagate the carry. So the number becomes \\u201C1 3 0 3 1\\u201D\\n\\nCase 2: There are digits left between left side and right side which are not same. So, we just mirror the left side to the right side & try to minimize the number formed to guarantee the next smallest palindrome.\\nIn this case, there can be two sub-cases.\\n\\n2.1) Copying the left side to the right side is sufficient, we don\\u2019t need to increment any digits and the result is just mirror of left side. Following are some examples of this sub-case.\\nNext palindrome for \\u201C7 8 3 3 2 2\\u2033 is \\u201C7 8 3 3 8 7\\u201D\\nNext palindrome for \\u201C1 2 5 3 2 2\\u2033 is \\u201C1 2 5 5 2 1\\u201D\\nNext palindrome for \\u201C1 4 5 8 7 6 7 8 3 2 2\\u2033 is \\u201C1 4 5 8 7 6 7 8 5 4 1\\u201D\\nHow do we check for this sub-case? All we need to check is the digit just after the ignored part in step 1. This digit is highlighted in above examples. If this digit is greater than the corresponding digit in right side digit, then copying the left side to the right side is sufficient and we don\\u2019t need to do anything else.\\n\\n2.2) Copying the left side to the right side is NOT sufficient. This happens when the above defined digit of left side is smaller. Following are some examples of this case.\\nNext palindrome for \\u201C7 1 3 3 2 2\\u2033 is \\u201C7 1 4 4 1 7\\u201D\\nNext palindrome for \\u201C1 2 3 4 6 2 8\\u2033 is \\u201C1 2 3 5 3 2 1\\u201D\\nNext palindrome for \\u201C9 4 1 8 7 9 7 8 3 2 2\\u2033 is \\u201C9 4 1 8 8 0 8 8 1 4 9\\u201D\\nWe handle this subcase like Case 1. We just add 1 to the middle digit (or digits in ase n is even) propagate the carry towards MSB digit of left side and simultaneously copy mirror of the left side to the right side.\\n\\nRef: www.geeksforgeeks.org.\\n\\nThis is the way to get **all palindrome** number. For this problem to solve you can consider only **odd palindrome** for fast result.\\n\\nHere is my implementation, \\n\\n```\\nclass Solution {\\n\\n    int getNextPalindrome( int nn )\\n    {\\n        string ss = to_string(nn);\\n        int i, j, len = ss.length();\\n\\n        for(i=0; i<len; i++) if(ss[i] != \\'9\\') break;\\n\\n        if(i==len) return (nn+2);       //  all are 9\\'s\\n\\n        //  when not all are 9\\'s\\n\\n        int mid = len/2;        // find the index of mid digit\\n\\n        // A bool variable to check if copy of left side to right is sufficient or not\\n        bool leftIsLess = false;\\n\\n        i = mid - 1;\\n\\n        if(len%2) j = mid+1;    //  for odd length palindrome\\n        else j = mid;           //  for even length palindrome\\n\\n        // Initially, ignore the middle same digits\\n        while (i >= 0 && ss[i] == ss[j]) i--,j++;\\n        \\n\\n        // Find if the middle digit(s) need to be incremented or not (or copying left\\n        // side is not sufficient)\\n        if ( i < 0 || ss[i] < ss[j]) leftIsLess = true;\\n        \\n        \\n        // Copy the mirror of left to right\\n    \\n        while (i >= 0) ss[j++] = ss[i--];\\n       \\n\\n        // Handle the case where middle digit(s) must be incremented.\\n        // This part of code is for CASE 1 and CASE 2.2\\n        \\n        if (leftIsLess == true)\\n        {\\n            int carry = 1;\\n            i = mid - 1;\\n\\n            // If there are odd digits, then increment\\n            // the middle digit and store the carry\\n            if (len%2 == 1)\\n            {\\n                j = mid+1;\\n                \\n                if(ss[mid]<=\\'8\\') {ss[mid]++; carry=0;}\\n                \\n                else ss[mid] = \\'0\\';               \\n            }\\n\\n            else j = mid;\\n         \\n            // Add 1 to the rightmost digit of the left side, propagate the carry\\n            // towards MSB digit and simultaneously copying mirror of the left side\\n            // to the right side.\\n            \\n            while (i >= 0 && carry)\\n            {\\n                if(ss[i]<=\\'8\\') {ss[i]++; ss[j++] = ss[i--]; break;} \\n\\n                else { \\n                    ss[i] = \\'0\\';     \\n                                    \\n                    ss[j++] = ss[i--]; \\n                }\\n            }\\n        }\\n        \\n        return stoi(ss);\\n}\\n\\nbool isprime(int num)\\n{\\n\\n    int j=sqrt((double)(num));\\n\\n    for(int i=2; i<=j; i++) if(!(num%i)) return false;\\n\\n    return true;\\n\\n}\\n   \\n    \\npublic:\\n       \\n    int primePalindrome(int N) {\\n\\n        if(N==1) return 2;\\n        \\n        \\n        string ss = to_string(N);\\n        int i, j, len = ss.length();\\n        \\n        int num=N;\\n        \\n        bool palindrome=true;\\n        \\n        for(i=0, j=len-1; i<j; i++, j--) if(ss[i]!=ss[j]) {palindrome=false; break;}\\n                   \\n        if(!palindrome) num = getNextPalindrome(num);\\n            \\n        while(!isprime(num)) num = getNextPalindrome(num);\\n            \\n\\n    return num;\\n}\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int getNextPalindrome( int nn )\\n    {\\n        string ss = to_string(nn);\\n        int i, j, len = ss.length();\\n\\n        for(i=0; i<len; i++) if(ss[i] != \\'9\\') break;\\n\\n        if(i==len) return (nn+2);       //  all are 9\\'s\\n\\n        //  when not all are 9\\'s\\n\\n        int mid = len/2;        // find the index of mid digit\\n\\n        // A bool variable to check if copy of left side to right is sufficient or not\\n        bool leftIsLess = false;\\n\\n        i = mid - 1;\\n\\n        if(len%2) j = mid+1;    //  for odd length palindrome\\n        else j = mid;           //  for even length palindrome\\n\\n        // Initially, ignore the middle same digits\\n        while (i >= 0 && ss[i] == ss[j]) i--,j++;\\n        \\n\\n        // Find if the middle digit(s) need to be incremented or not (or copying left\\n        // side is not sufficient)\\n        if ( i < 0 || ss[i] < ss[j]) leftIsLess = true;\\n        \\n        \\n        // Copy the mirror of left to right\\n    \\n        while (i >= 0) ss[j++] = ss[i--];\\n       \\n\\n        // Handle the case where middle digit(s) must be incremented.\\n        // This part of code is for CASE 1 and CASE 2.2\\n        \\n        if (leftIsLess == true)\\n        {\\n            int carry = 1;\\n            i = mid - 1;\\n\\n            // If there are odd digits, then increment\\n            // the middle digit and store the carry\\n            if (len%2 == 1)\\n            {\\n                j = mid+1;\\n                \\n                if(ss[mid]<=\\'8\\') {ss[mid]++; carry=0;}\\n                \\n                else ss[mid] = \\'0\\';               \\n            }\\n\\n            else j = mid;\\n         \\n            // Add 1 to the rightmost digit of the left side, propagate the carry\\n            // towards MSB digit and simultaneously copying mirror of the left side\\n            // to the right side.\\n            \\n            while (i >= 0 && carry)\\n            {\\n                if(ss[i]<=\\'8\\') {ss[i]++; ss[j++] = ss[i--]; break;} \\n\\n                else { \\n                    ss[i] = \\'0\\';     \\n                                    \\n                    ss[j++] = ss[i--]; \\n                }\\n            }\\n        }\\n        \\n        return stoi(ss);\\n}\\n\\nbool isprime(int num)\\n{\\n\\n    int j=sqrt((double)(num));\\n\\n    for(int i=2; i<=j; i++) if(!(num%i)) return false;\\n\\n    return true;\\n\\n}\\n   \\n    \\npublic:\\n       \\n    int primePalindrome(int N) {\\n\\n        if(N==1) return 2;\\n        \\n        \\n        string ss = to_string(N);\\n        int i, j, len = ss.length();\\n        \\n        int num=N;\\n        \\n        bool palindrome=true;\\n        \\n        for(i=0, j=len-1; i<j; i++, j--) if(ss[i]!=ss[j]) {palindrome=false; break;}\\n                   \\n        if(!palindrome) num = getNextPalindrome(num);\\n            \\n        while(!isprime(num)) num = getNextPalindrome(num);\\n            \\n\\n    return num;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018872,
                "title": "c-easy-to-understand-math",
                "content": "class Solution {\\npublic:\\n    \\n    bool isprime(int n)\\n    {\\n        if(n==1)\\n            return false;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool ispalindrom(int n)\\n    {\\n        int n1=n;\\n        int n2=0;\\n        while(n1>0){\\n            int a=n1%10;\\n            n2=n2*10+a;\\n            n1/=10;\\n        }\\n        if(n2==n)\\n            return true;\\n        return false;\\n    }\\n    int smallestno(int n)\\n    {\\n        if(ispalindrom(n))\\n            if(isprime(n))\\n                return n;\\n        return smallestno(n+1);\\n    }\\n\\n    int primePalindrome(int n) {\\n        \\n        if (1e7 <= n && n <= 1e8)\\n            return 100030001;\\n        int a=smallestno(n);\\n        return a;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isprime(int n)\\n    {\\n        if(n==1)\\n            return false;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1291185,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```\\nIF YOU LIKE THE SOLUTION, UPVOTE IT AND ENCOURAGE ME.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314332,
                "title": "python-code-summarizing-several-posts",
                "content": "Below code summarized several posts\\' algorithms: SolaAoi, EddieCarrillo, ivschukin.\\n\\nThe idea is we handle the case where return value is less than 100. \\n\\nThen all the rest of the cases, we only need to consider palindromes with lengths larger than 2.\\n\\nFrom SolaAoi\\'s post, we only need to generate odd-length palindromes.\\n\\nFrom EddieCarrillo\\'s, we can ensure the generated palindromes are sorted.\\n\\nAs we know the palindromes cannot end with even digits and \\'5\\', so we can only pick the seeds starting with \\'1\\',\\'3\\',\\'7\\',\\'9\\'.\\n\\nSince all palindromes ends with odd numbers, we only need to consider odd numbers starting from 3 to check if prime.\\n\\n```\\nclass Solution(object):\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        # Create a palindrome, then check prime\\n        \\n        # First digit and (last) can only be [1, 3, 7, 9]\\n        # Even-length palindromes (length longer than 2) are divisible by 11\\n        \\n        # Create a list of prime numbers\\n\\n        \\n        # Handle the case that returned value is less than 100\\n        \\n        if N >= 9989900:\\n            return 100030001\\n        if len(str(N)) <= 2:\\n            for c in [2,3,5,7,11]:\\n                if c >= N:\\n                    return c\\n        \\n                \\n        def isPrime(n):\\n            i = 3\\n            while i*i <= n:\\n                if n % i == 0:\\n                    return False\\n                i += 2\\n            return True\\n        \\n        # Generate odd-length (length > 2) palindrome\\n        def genOdd(seedint):\\n            seed = str(seedint)\\n            return int(seed + seed[:len(seed)-1][::-1])\\n        \\n        # Starting with length > 2 palindrome\\n        seed = 10\\n        \\n        while True:\\n            if str(seed)[0] in [\\'1\\',\\'3\\',\\'7\\',\\'9\\']:\\n                cur = genOdd(seed)\\n                if cur >= N and isPrime(cur):\\n                    return cur\\n            seed += 1\\n",
                "solutionTags": [],
                "code": "Below code summarized several posts\\' algorithms: SolaAoi, EddieCarrillo, ivschukin.\\n\\nThe idea is we handle the case where return value is less than 100. \\n\\nThen all the rest of the cases, we only need to consider palindromes with lengths larger than 2.\\n\\nFrom SolaAoi\\'s post, we only need to generate odd-length palindromes.\\n\\nFrom EddieCarrillo\\'s, we can ensure the generated palindromes are sorted.\\n\\nAs we know the palindromes cannot end with even digits and \\'5\\', so we can only pick the seeds starting with \\'1\\',\\'3\\',\\'7\\',\\'9\\'.\\n\\nSince all palindromes ends with odd numbers, we only need to consider odd numbers starting from 3 to check if prime.\\n\\n```\\nclass Solution(object):\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        # Create a palindrome, then check prime\\n        \\n        # First digit and (last) can only be [1, 3, 7, 9]\\n        # Even-length palindromes (length longer than 2) are divisible by 11\\n        \\n        # Create a list of prime numbers\\n\\n        \\n        # Handle the case that returned value is less than 100\\n        \\n        if N >= 9989900:\\n            return 100030001\\n        if len(str(N)) <= 2:\\n            for c in [2,3,5,7,11]:\\n                if c >= N:\\n                    return c\\n        \\n                \\n        def isPrime(n):\\n            i = 3\\n            while i*i <= n:\\n                if n % i == 0:\\n                    return False\\n                i += 2\\n            return True\\n        \\n        # Generate odd-length (length > 2) palindrome\\n        def genOdd(seedint):\\n            seed = str(seedint)\\n            return int(seed + seed[:len(seed)-1][::-1])\\n        \\n        # Starting with length > 2 palindrome\\n        seed = 10\\n        \\n        while True:\\n            if str(seed)[0] in [\\'1\\',\\'3\\',\\'7\\',\\'9\\']:\\n                cur = genOdd(seed)\\n                if cur >= N and isPrime(cur):\\n                    return cur\\n            seed += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 179678,
                "title": "a-fast-way-to-check-is-prime-python",
                "content": "```python\\ndef is_prime(n):\\n            if n < 2:\\n                return False\\n            if n in [2, 3]:\\n                return True\\n            if n % 6 != 5 and n % 6 != 1:\\n                return False\\n            for i in range(5, int(math.sqrt(n)) + 1, 6):\\n                if (n % i == 0) or (n % (i + 2) == 0):\\n                    return False\\n            return True\\n```",
                "solutionTags": [],
                "code": "```python\\ndef is_prime(n):\\n            if n < 2:\\n                return False\\n            if n in [2, 3]:\\n                return True\\n            if n % 6 != 5 and n % 6 != 1:\\n                return False\\n            for i in range(5, int(math.sqrt(n)) + 1, 6):\\n                if (n % i == 0) or (n % (i + 2) == 0):\\n                    return False\\n            return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 147065,
                "title": "javascript-solution-128ms",
                "content": "It\\'s tempted to **get stuck** in javascript when you only focus on how to find a prime quicker, because in that case your code will always **time out**. The only way to avoid time out when you focus on prime is to find all the solutions and then **save them as a const** to refer to.(then you\\'ll have no fun programming)\\n**The right way** to think of this problem is to `find the next palindrome`. There are big gaps between two close palindrome, and we can use those gaps to save time. So the key point of this solution lies in finding the next palindrome based on the palindrome we dealt before.\\n```\\nvar primePalindrome = function(N) {\\n\\tif(N<=2) return 2;\\n\\tlet cur = N;\\n\\twhile(!isPal(cur)) cur++;\\n\\twhile(true){\\n\\t\\tif(isPrime(cur)) return cur;\\n\\t\\tcur = nextPal(cur);\\n\\t}\\n};\\nfunction isPal(n){\\n\\treturn (\\'\\'+n)===(\\'\\'+n).split(\\'\\').reverse().join(\\'\\');\\n}\\nfunction nextPal(n){\\n\\tlet s = (\\'\\'+n), len = s.length, half = Math.ceil(len/2);\\n\\tlet left=s.slice(0,half);\\n\\tlet tmp = (+left+1)+\\'\\';\\n\\tif(half===len-half){\\n\\t\\treturn +(tmp+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\')); //66->77 99->101\\n\\t}else{\\n\\t\\tif(tmp.length===half) return +(tmp+tmp.slice(0,len-half).split(\\'\\').reverse().join(\\'\\'));// 888->898\\n\\t\\telse return +(tmp.slice(0,half)+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\'));// 999->1001\\n\\t}\\n}\\nfunction isPrime(n){\\n\\tif(n%2===0) return false;\\n\\tfor(let i=3; i*i<=n; i+=2){\\n\\t\\tif(n%i===0) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\\nThe part of my code to find the next palindrome is not elegant. I tried to cut the code but failed. If you have any good idea about making it shorter, please let me know. Thanks `:)`",
                "solutionTags": [],
                "code": "```\\nvar primePalindrome = function(N) {\\n\\tif(N<=2) return 2;\\n\\tlet cur = N;\\n\\twhile(!isPal(cur)) cur++;\\n\\twhile(true){\\n\\t\\tif(isPrime(cur)) return cur;\\n\\t\\tcur = nextPal(cur);\\n\\t}\\n};\\nfunction isPal(n){\\n\\treturn (\\'\\'+n)===(\\'\\'+n).split(\\'\\').reverse().join(\\'\\');\\n}\\nfunction nextPal(n){\\n\\tlet s = (\\'\\'+n), len = s.length, half = Math.ceil(len/2);\\n\\tlet left=s.slice(0,half);\\n\\tlet tmp = (+left+1)+\\'\\';\\n\\tif(half===len-half){\\n\\t\\treturn +(tmp+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\')); //66->77 99->101\\n\\t}else{\\n\\t\\tif(tmp.length===half) return +(tmp+tmp.slice(0,len-half).split(\\'\\').reverse().join(\\'\\'));// 888->898\\n\\t\\telse return +(tmp.slice(0,half)+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\'));// 999->1001\\n\\t}\\n}\\nfunction isPrime(n){\\n\\tif(n%2===0) return false;\\n\\tfor(let i=3; i*i<=n; i+=2){\\n\\t\\tif(n%i===0) return false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433138,
                "title": "easy-solution-full-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can divide it into 4 parts:-\\n    1.Find if the number is palindrome or not.\\n    2.Find if the number is prime or not.\\n    3.If it satisfy both prime and palindrome than we return n.\\n    4.Else while(true) -> If n satisfy both prime and Palindrome -> return n. Else -> n++.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlssssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        int r,s=0,c=x;\\n        while(x>0){\\n            r=x%10;\\n            s=(s*10)+r;\\n            x = x/10;\\n        }\\n        if(c==s) return true; \\n        else return false;\\n    }\\n    public static boolean isPrime(int num){\\n        boolean isPrime = true;\\n        if (num < 2) isPrime = false;\\n        else for (int i = 2; i <= Math.sqrt(num); i++) \\n               if (num % i == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n        if (isPrime) return true;\\n        else return false;\\n    }\\n    public int primePalindrome(int n) {\\n        if(isPrime(n) && isPalindrome(n)) return n;\\n        else{\\n            while(true){\\n                if(isPrime(n) && isPalindrome(n)) return n;\\n                n++;\\n                if (10_000_000 < n && n < 100_000_000) n = 100_000_000;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        int r,s=0,c=x;\\n        while(x>0){\\n            r=x%10;\\n            s=(s*10)+r;\\n            x = x/10;\\n        }\\n        if(c==s) return true; \\n        else return false;\\n    }\\n    public static boolean isPrime(int num){\\n        boolean isPrime = true;\\n        if (num < 2) isPrime = false;\\n        else for (int i = 2; i <= Math.sqrt(num); i++) \\n               if (num % i == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n        if (isPrime) return true;\\n        else return false;\\n    }\\n    public int primePalindrome(int n) {\\n        if(isPrime(n) && isPalindrome(n)) return n;\\n        else{\\n            while(true){\\n                if(isPrime(n) && isPalindrome(n)) return n;\\n                n++;\\n                if (10_000_000 < n && n < 100_000_000) n = 100_000_000;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158651,
                "title": "c-using-prime-sieve-and-palindromic-check",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359417,
                "title": "java-iterate-odd-length-palindromes-generate-next-palindrome-beats-100",
                "content": "**Iterate odd-length palindromes**\\n\\nPrerequisite knowledge: [Divisibility Rule of 11](https://en.wikipedia.org/wiki/Divisibility_rule)\\nA number is divisible by 11 iff difference between sum of its odd digits (i.e. digits at odd places) and sum of its even digits is divisible by 11.\\n\\nThis implies that all even-length palindromes are divisible by 11 since sum(odd digits) = sum(even digits). So even-length palindromes can not be primes except the number 11 itself.\\n\\nSo we skip even-length palindromes and iterate only over odd-length palindromes to look for primes. Iterating palindromes sequentially means iterating over their left half and appending the reverse of the left half as right half to construct the palindrome.\\n\\n```\\n// 5 ms. 99.03%\\nclass Solution {\\n    private int makePalindrome(int n) {\\n        int p = n;\\n        while((n /= 10) != 0)\\n            p = p * 10 + n % 10;\\n        return p;\\n    }\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N >= 8 && N <= 11) return 11;\\n        for(int i = 2; i < 100000; i++) {\\n            int p = makePalindrome(i);\\n            if(p >= N && isPrime(p)) return p;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Generate next palindrome**\\n\\nWe can borrow our knowledge from [564. Find the Closest Palindrome](https://leetcode.com/problems/find-the-closest-palindrome/discuss/960052/Find-previous-and-next-palindromes-detailed-explanation) to calculate next palindrome from a number. Another problem that can be solved using next palindrome idea: [906. Super Palindromes](https://leetcode.com/problems/super-palindromes/discuss/1198415/Java-Build-next-palindrome-Solve-2-Hards)\\n\\n```\\n// 1 ms. 100%\\nclass Solution {\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    private int next(int num) {\\n        char[] s = String.valueOf(num + 1).toCharArray();\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                increment(s, n - 1 - i);\\n            }\\n        }\\n        return Integer.parseInt(new String(s));\\n    }\\n    private void increment(char[] s, int i) {\\n        while(s[i] == \\'9\\') s[i--] = \\'0\\';\\n        s[i]++;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        int p = next(N - 1);\\n        while(!isPrime(p)) {\\n            if(10_000_000 <= p && p < 100_000_000)\\n                p = 100_000_000;\\n            p = next(p);\\n        }\\n        return p;\\n    }\\n}\\n```\\n\\nNote that ``` if(10_000_000 <= p && p < 100_000_000) p = 100_000_000; ``` is just an optimization to skip over even-length numbers of length 8. Even if we remove these lines, the code runs in ```8 ms. 97.10%``` which isn\\'t too bad.",
                "solutionTags": [],
                "code": "```\\n// 5 ms. 99.03%\\nclass Solution {\\n    private int makePalindrome(int n) {\\n        int p = n;\\n        while((n /= 10) != 0)\\n            p = p * 10 + n % 10;\\n        return p;\\n    }\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N >= 8 && N <= 11) return 11;\\n        for(int i = 2; i < 100000; i++) {\\n            int p = makePalindrome(i);\\n            if(p >= N && isPrime(p)) return p;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n// 1 ms. 100%\\nclass Solution {\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    private int next(int num) {\\n        char[] s = String.valueOf(num + 1).toCharArray();\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                increment(s, n - 1 - i);\\n            }\\n        }\\n        return Integer.parseInt(new String(s));\\n    }\\n    private void increment(char[] s, int i) {\\n        while(s[i] == \\'9\\') s[i--] = \\'0\\';\\n        s[i]++;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        int p = next(N - 1);\\n        while(!isPrime(p)) {\\n            if(10_000_000 <= p && p < 100_000_000)\\n                p = 100_000_000;\\n            p = next(p);\\n        }\\n        return p;\\n    }\\n}\\n```\n``` if(10_000_000 <= p && p < 100_000_000) p = 100_000_000; ```\n```8 ms. 97.10%```",
                "codeTag": "Java"
            },
            {
                "id": 147740,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354439,
                "title": "100-faster-c-improved-brute-force",
                "content": "## Improved Brute Force\\n\\n```C++\\n    bool isPrime(int n){\\n        if(n%2 == 0) return false;\\n        for(int i = 3; i <= pow(n, 0.5); i++){\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int n){\\n        int num = n,rev = 0;\\n        while(num > 0){\\n            rev  = rev*10 + num % 10;\\n            num /= 10;\\n        };\\n        return n==rev;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPalindrome(i) && isPrime(i)) return i;\\n            i += 2;     // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// all even pallindromes are divided by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\n    bool isPrime(int n){\\n        if(n%2 == 0) return false;\\n        for(int i = 3; i <= pow(n, 0.5); i++){\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int n){\\n        int num = n,rev = 0;\\n        while(num > 0){\\n            rev  = rev*10 + num % 10;\\n            num /= 10;\\n        };\\n        return n==rev;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPalindrome(i) && isPrime(i)) return i;\\n            i += 2;     // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// all even pallindromes are divided by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121912,
                "title": "python-100-faster-without-cheating-fully-commented",
                "content": "So there\\'s definitely a lot that can be improved here, but it\\'s late and I\\'m not going to. There are a few tricks here I want to explain though. \\n\\nThe first is that every palindromic number with an even length is a multiple of 11. This means that 11 is the only even-length palindromic prime. So rather than write code that can handle small values of N in general, I decided to write code that assumed that N > 11, and then I did use a lookup table for the smaller values. (The sample solutions for the top-speed all seem to use a lookup table which contains every prime palindrome less than 2*10^8, and then they lookup the answer with a binary search. So when I say I don\\'t use a lookup table what I\\'m really reffering to is that I didn\\'t just do that)\\n\\nThe second trick I used is that I though of the palindromes as vectors, which I could write using linear combinations of easilly-constructible basis vectors. For example, the basis vectors for 5-digit palindromic numbers are:\\n[10001, 01010, 00100] -> [10001, 1010, 100]\\nWe can construct every 5-digit palindrome with a linear combination of these vectors. So if the digits of N are abcba, then we note that:\\nN = a x 10001 + b x 1010 + c x 100\\nTo be 5-digits, \\'a\\' cannot be 0. Furthermore, for \\'N\\' to have a chance of being prime, it must end with one of the digits (1, 3, 7, 9). This means that when we\\'re generating palindromes which we want to be prime, we can restrict a to just those digits. (Notably, if the number \\'abcba\\' is greater than the number \\'xyzyx\\', then the number \\'abc\\' is greater than \\'xyz\\' and vice versa - this allowed me to easilly generate the palindromic numbers in ascending order)\\n\\nFinally, I did a little work to figure out lower bounds on where to start searching for palindromes. It\\'s not perfect, but it\\'s good enough to significantly reduce the computation time (mostly by not generating palindromes the same length as N that are way less than N).\\n\\n(also, I am fully aware that there\\'s a lot of code here; this is not my most elegant solution ever, but beating a binary search of hard-coded answers was difficult)\\n\\nBest Performance: 28 ms/14.3 MB : 100%/32%\\n\\n\\'\\'\\'\\n\\n    #Check if a Number is Prime (Trial Division - So this is definitely improvable)\\n    def isPrime(self, n:int) -> bool:\\n        #Check Edge Cases and Division by 2 and 3\\n        if n == 2 or n == 3:\\n            return True\\n        elif n < 2 or n%2 == 0 or n%3 == 0:\\n            return False\\n        else:\\n            #Check Division by Odd Numbers (6*k +/- 1)\\n            return all(n%p != 0 != n%(p + 2) for p in range(5, int(n**0.5) + 1, 6))\\n    \\n    #Generate Prime Palindromes of Length D (d initially equals D)\\n    def primePalindromes(self, D:int, d:int) -> int:\\n        #Check the Base/Recursive Cases\\n        if d == 1:\\n            #If this is the Highest Level, Only Yield Primes\\n            if D == 1:\\n                #Yield Primes\\n                yield from (p for p in [2,3,5,7])\\n            else:\\n                #Yield Every Digit\\n                yield from range(10)\\n        elif d == D:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Since this is the Top Level, Only Check Candidate Primes\\n            for n in (1, 3, 7, 9):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble the Palindrome\\n                    p = n*v + 10*p\\n                    \\n                    #Check if it\\'s Prime\\n                    if self.isPrime(p):\\n                        #Yield the Prime Palindrome\\n                        yield p\\n        else:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Try Every Digit\\n            for n in range(10):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble/Yield the Palindrome (This isn\\'t the top level, so it isn\\'t generally prime)\\n                    yield n*v + 10*p\\n    \\n    #Generate Odd Palindromes the Same Length as N Which are Greater than N\\n    def oddPalindromes(self, N:int) -> int:\\n        #Cast N to a String for Easier Digit Manipulation\\n        S = str(N)\\n        \\n        #Count the Number of Digits, and Compute the Number of Basis \"Vectors\" Required (Again, I know)\\n        d = len(S)\\n        D = d//2 + 1\\n        \\n        #Make the Basis Vectors (Ex: D = 5: basis = [10001, 01010, 00100])\\n        basis = []\\n        for i in range(D - 1):\\n            basis.append(10**(d - i - 1) + 10**(i))\\n        basis.append(10**(D - 1))\\n        \\n        #Yield Palindromes\\n        for i in range(int(S[:D]), 10**D):\\n            #Cast i to a String\\n            s = str(i)\\n            \\n            #Add Leading Zeros\\n            s = \\'0\\'*(D - len(s)) + s\\n            \\n            #Check if the Palindrome Might Be Prime\\n            if s[0] in (\\'1\\', \\'3\\', \\'7\\', \\'9\\'):\\n                #Assemble the Palindrome\\n                p = sum(b*int(c) for b, c in zip(basis, s))\\n                \\n                #Check the Size\\n                if p >= N:\\n                    yield p\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Check if N is Small (11 is Special Since All Even Palindromic Numbers are Multiples of 11)\\n        if N < 12:\\n            #Use a Lookup Table\\n            return [2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11][N]\\n        else:\\n            #Generate Odd Palindromes Until the Solution is Either Found or Not Found\\n            d = len(str(N))\\n            if d%2 == 1:\\n                for p in self.oddPalindromes(N):\\n                    #Check if it\\'s a Solution\\n                    if self.isPrime(p):\\n                        return p\\n            else:\\n                #Decrement d (So that it will be accurate when we increment it later)\\n                d -= 1\\n            \\n            #Keep Generating Longer and Longer Prime Palindromes Until a Solution is Found\\n            while True:\\n                #Increment the Length of the Palindromes\\n                d += 2\\n                \\n                #Generate Palindromes Greater than N\\n                for p in self.primePalindromes(d, d):\\n                    #Return the Solution\\n                    return p\\n\\'\\'\\'\\n\\nAlso, for what it\\'s worth, there\\'s actually a slightly faster cheating solution. Instead of organizing all the primes in a single list, you can organize then in buckets based on the number of digits they have (plus a sentinel from the next bucket up). I didn\\'t save a huge amount of time, but it\\'s still significant since the solutions were already so quick to begin with! It is possible that this could be further improved by checking if N is odd and bigger than the biggest length-d solution before doing the binary search, but I doubt that\\'d be enough to get the run time down to 20 ms, and I\\'m not going to bother trying it.\\n\\nBest Performance: 24 ms/14.5 MB : 100%/14%\\n\\n\\'\\'\\'\\n\\n\\t#All the Solution Arranged by the Number of Digits\\n    primes = {1:[2,3,5,7,11],\\n              2:[11,101],\\n              3:[101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301],\\n              4:[10301],\\n              5:[10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,\\n                 15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,\\n                 30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,\\n                 36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,\\n                 72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,\\n                 78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,\\n                 95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001],\\n              6:[1003001],\\n              7:[1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,\\n                 1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,\\n                 1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,\\n                 1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,\\n                 1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,\\n                 1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,\\n                 1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,\\n                 1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,\\n                 1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,\\n                 1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,\\n                 1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,\\n                 1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,\\n                 1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,\\n                 1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,\\n                 1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,\\n                 1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,\\n                 1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,\\n                 1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,\\n                 1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,\\n                 3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,\\n                 3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,\\n                 3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,\\n                 3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,\\n                 3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,\\n                 3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,\\n                 3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,\\n                 3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,\\n                 3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,\\n                 3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,\\n                 3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,\\n                 3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,\\n                 3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,\\n                 3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,\\n                 3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,\\n                 3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,\\n                 3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,\\n                 3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,\\n                 7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,\\n                 7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,\\n                 7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,\\n                 7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,\\n                 7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,\\n                 7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,\\n                 7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,\\n                 7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,\\n                 7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,\\n                 7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,\\n                 7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,\\n                 7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,\\n                 7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,\\n                 7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,\\n                 7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,\\n                 9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,\\n                 9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,\\n                 9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,\\n                 9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,\\n                 9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,\\n                 9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,\\n                 9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,\\n                 9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,\\n                 9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,\\n                 9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,\\n                 9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,\\n                 9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,\\n                 9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,\\n                 9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,\\n                 9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001],\\n              8:[100030001],\\n              9:[100030001]}\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Get the Number of Digits\\n        d = len(str(N))\\n        \\n        #Binary Search the Appropriate List\\n        return self.primes[d][bisect_left(self.primes[d], N)]\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "So there\\'s definitely a lot that can be improved here, but it\\'s late and I\\'m not going to. There are a few tricks here I want to explain though. \\n\\nThe first is that every palindromic number with an even length is a multiple of 11. This means that 11 is the only even-length palindromic prime. So rather than write code that can handle small values of N in general, I decided to write code that assumed that N > 11, and then I did use a lookup table for the smaller values. (The sample solutions for the top-speed all seem to use a lookup table which contains every prime palindrome less than 2*10^8, and then they lookup the answer with a binary search. So when I say I don\\'t use a lookup table what I\\'m really reffering to is that I didn\\'t just do that)\\n\\nThe second trick I used is that I though of the palindromes as vectors, which I could write using linear combinations of easilly-constructible basis vectors. For example, the basis vectors for 5-digit palindromic numbers are:\\n[10001, 01010, 00100] -> [10001, 1010, 100]\\nWe can construct every 5-digit palindrome with a linear combination of these vectors. So if the digits of N are abcba, then we note that:\\nN = a x 10001 + b x 1010 + c x 100\\nTo be 5-digits, \\'a\\' cannot be 0. Furthermore, for \\'N\\' to have a chance of being prime, it must end with one of the digits (1, 3, 7, 9). This means that when we\\'re generating palindromes which we want to be prime, we can restrict a to just those digits. (Notably, if the number \\'abcba\\' is greater than the number \\'xyzyx\\', then the number \\'abc\\' is greater than \\'xyz\\' and vice versa - this allowed me to easilly generate the palindromic numbers in ascending order)\\n\\nFinally, I did a little work to figure out lower bounds on where to start searching for palindromes. It\\'s not perfect, but it\\'s good enough to significantly reduce the computation time (mostly by not generating palindromes the same length as N that are way less than N).\\n\\n(also, I am fully aware that there\\'s a lot of code here; this is not my most elegant solution ever, but beating a binary search of hard-coded answers was difficult)\\n\\nBest Performance: 28 ms/14.3 MB : 100%/32%\\n\\n\\'\\'\\'\\n\\n    #Check if a Number is Prime (Trial Division - So this is definitely improvable)\\n    def isPrime(self, n:int) -> bool:\\n        #Check Edge Cases and Division by 2 and 3\\n        if n == 2 or n == 3:\\n            return True\\n        elif n < 2 or n%2 == 0 or n%3 == 0:\\n            return False\\n        else:\\n            #Check Division by Odd Numbers (6*k +/- 1)\\n            return all(n%p != 0 != n%(p + 2) for p in range(5, int(n**0.5) + 1, 6))\\n    \\n    #Generate Prime Palindromes of Length D (d initially equals D)\\n    def primePalindromes(self, D:int, d:int) -> int:\\n        #Check the Base/Recursive Cases\\n        if d == 1:\\n            #If this is the Highest Level, Only Yield Primes\\n            if D == 1:\\n                #Yield Primes\\n                yield from (p for p in [2,3,5,7])\\n            else:\\n                #Yield Every Digit\\n                yield from range(10)\\n        elif d == D:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Since this is the Top Level, Only Check Candidate Primes\\n            for n in (1, 3, 7, 9):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble the Palindrome\\n                    p = n*v + 10*p\\n                    \\n                    #Check if it\\'s Prime\\n                    if self.isPrime(p):\\n                        #Yield the Prime Palindrome\\n                        yield p\\n        else:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Try Every Digit\\n            for n in range(10):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble/Yield the Palindrome (This isn\\'t the top level, so it isn\\'t generally prime)\\n                    yield n*v + 10*p\\n    \\n    #Generate Odd Palindromes the Same Length as N Which are Greater than N\\n    def oddPalindromes(self, N:int) -> int:\\n        #Cast N to a String for Easier Digit Manipulation\\n        S = str(N)\\n        \\n        #Count the Number of Digits, and Compute the Number of Basis \"Vectors\" Required (Again, I know)\\n        d = len(S)\\n        D = d//2 + 1\\n        \\n        #Make the Basis Vectors (Ex: D = 5: basis = [10001, 01010, 00100])\\n        basis = []\\n        for i in range(D - 1):\\n            basis.append(10**(d - i - 1) + 10**(i))\\n        basis.append(10**(D - 1))\\n        \\n        #Yield Palindromes\\n        for i in range(int(S[:D]), 10**D):\\n            #Cast i to a String\\n            s = str(i)\\n            \\n            #Add Leading Zeros\\n            s = \\'0\\'*(D - len(s)) + s\\n            \\n            #Check if the Palindrome Might Be Prime\\n            if s[0] in (\\'1\\', \\'3\\', \\'7\\', \\'9\\'):\\n                #Assemble the Palindrome\\n                p = sum(b*int(c) for b, c in zip(basis, s))\\n                \\n                #Check the Size\\n                if p >= N:\\n                    yield p\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Check if N is Small (11 is Special Since All Even Palindromic Numbers are Multiples of 11)\\n        if N < 12:\\n            #Use a Lookup Table\\n            return [2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11][N]\\n        else:\\n            #Generate Odd Palindromes Until the Solution is Either Found or Not Found\\n            d = len(str(N))\\n            if d%2 == 1:\\n                for p in self.oddPalindromes(N):\\n                    #Check if it\\'s a Solution\\n                    if self.isPrime(p):\\n                        return p\\n            else:\\n                #Decrement d (So that it will be accurate when we increment it later)\\n                d -= 1\\n            \\n            #Keep Generating Longer and Longer Prime Palindromes Until a Solution is Found\\n            while True:\\n                #Increment the Length of the Palindromes\\n                d += 2\\n                \\n                #Generate Palindromes Greater than N\\n                for p in self.primePalindromes(d, d):\\n                    #Return the Solution\\n                    return p\\n\\'\\'\\'\\n\\nAlso, for what it\\'s worth, there\\'s actually a slightly faster cheating solution. Instead of organizing all the primes in a single list, you can organize then in buckets based on the number of digits they have (plus a sentinel from the next bucket up). I didn\\'t save a huge amount of time, but it\\'s still significant since the solutions were already so quick to begin with! It is possible that this could be further improved by checking if N is odd and bigger than the biggest length-d solution before doing the binary search, but I doubt that\\'d be enough to get the run time down to 20 ms, and I\\'m not going to bother trying it.\\n\\nBest Performance: 24 ms/14.5 MB : 100%/14%\\n\\n\\'\\'\\'\\n\\n\\t#All the Solution Arranged by the Number of Digits\\n    primes = {1:[2,3,5,7,11],\\n              2:[11,101],\\n              3:[101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301],\\n              4:[10301],\\n              5:[10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,\\n                 15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,\\n                 30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,\\n                 36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,\\n                 72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,\\n                 78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,\\n                 95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001],\\n              6:[1003001],\\n              7:[1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,\\n                 1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,\\n                 1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,\\n                 1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,\\n                 1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,\\n                 1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,\\n                 1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,\\n                 1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,\\n                 1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,\\n                 1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,\\n                 1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,\\n                 1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,\\n                 1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,\\n                 1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,\\n                 1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,\\n                 1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,\\n                 1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,\\n                 1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,\\n                 1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,\\n                 3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,\\n                 3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,\\n                 3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,\\n                 3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,\\n                 3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,\\n                 3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,\\n                 3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,\\n                 3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,\\n                 3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,\\n                 3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,\\n                 3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,\\n                 3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,\\n                 3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,\\n                 3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,\\n                 3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,\\n                 3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,\\n                 3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,\\n                 3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,\\n                 7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,\\n                 7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,\\n                 7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,\\n                 7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,\\n                 7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,\\n                 7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,\\n                 7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,\\n                 7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,\\n                 7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,\\n                 7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,\\n                 7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,\\n                 7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,\\n                 7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,\\n                 7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,\\n                 7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,\\n                 9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,\\n                 9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,\\n                 9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,\\n                 9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,\\n                 9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,\\n                 9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,\\n                 9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,\\n                 9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,\\n                 9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,\\n                 9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,\\n                 9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,\\n                 9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,\\n                 9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,\\n                 9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,\\n                 9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001],\\n              8:[100030001],\\n              9:[100030001]}\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Get the Number of Digits\\n        d = len(str(N))\\n        \\n        #Binary Search the Appropriate List\\n        return self.primes[d][bisect_left(self.primes[d], N)]\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 887035,
                "title": "fermat-s-little-theorem-to-check-odd-palindrome-for-prime-in-o-log-n-time",
                "content": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    int oddPal(int num){\\n        int n=num;\\n        n/=10;\\n        while (n){\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        return num;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        set<int> tab;\\n        for (int i=1;i<=2*1e4+7;i++){\\n            if (i==11){\\n                tab.insert(11);\\n                continue;\\n            }\\n            int p=oddPal(i);\\n            if (fermatPrime(p)) tab.insert(p);\\n        }\\n        auto idx=tab.lower_bound(N);\\n        return *idx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    int oddPal(int num){\\n        int n=num;\\n        n/=10;\\n        while (n){\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        return num;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        set<int> tab;\\n        for (int i=1;i<=2*1e4+7;i++){\\n            if (i==11){\\n                tab.insert(11);\\n                continue;\\n            }\\n            int p=oddPal(i);\\n            if (fermatPrime(p)) tab.insert(p);\\n        }\\n        auto idx=tab.lower_bound(N);\\n        return *idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767277,
                "title": "c",
                "content": "```c++\\n#define ll int\\nclass Solution {\\npublic:\\n    bool isPrime(ll n){\\n    if(n==1)return false;\\n    for(ll i=2;i*i<=n;i++)\\n        if(n%i==0)return false;\\n    return true;\\n    }\\n    int primePalindrome(int n) {\\n        if(n>=8 and n<=11){\\n            return 11;\\n        }\\n    for(ll i=1;i<=1000000;i++){\\n        string s=to_string(i);\\n        string r(s.rbegin(),s.rend());\\n        string y=s+r.substr(1);\\n        ll y1=stoi(y);\\n        if(y1>=n and isPrime(y1))\\n            return y1;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n#define ll int\\nclass Solution {\\npublic:\\n    bool isPrime(ll n){\\n    if(n==1)return false;\\n    for(ll i=2;i*i<=n;i++)\\n        if(n%i==0)return false;\\n    return true;\\n    }\\n    int primePalindrome(int n) {\\n        if(n>=8 and n<=11){\\n            return 11;\\n        }\\n    for(ll i=1;i<=1000000;i++){\\n        string s=to_string(i);\\n        string r(s.rbegin(),s.rend());\\n        string y=s+r.substr(1);\\n        ll y1=stoi(y);\\n        if(y1>=n and isPrime(y1))\\n            return y1;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475536,
                "title": "java-solution-beats-99-93-time",
                "content": "The idea is to maintain an array of the digits of N (actually only the first half of them) and increase them to form valid palindromes. Then we check if they are also a prime number.\\n\\nThe solution is arguably a bit convoluted because of all the low-level operations, but fast due to the fact that it doesn\\'t rely on string operations.\\n\\nI also added skipping even-digit palindromes after I read that they cannot be prime numbers ( -_-\\' ), which makes it even faster. \\n\\n````\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        if (N > 7 && N <= 11) return 11;\\n\\n        int digitsCount = (int)Math.floor(Math.log10(N)) + 1; // number of digits of N\\n        if (digitsCount % 2 == 0) { N = (int)Math.pow(10, digitsCount); digitsCount++; } // skip even-digits palindromes\\n        int[] digits = new int[(digitsCount + 1) / 2]; // array of half the length of the number of digits\\n        // put the first half of the digits of N in the array\\n        int n = N, count = 0;\\n        while (n > 0) {\\n            if (++count > (digitsCount + 1) / 2) digits[digitsCount - count] = n % 10;\\n            n /= 10;\\n        }\\n\\n        while (true) {\\n            // create a palindrome number based on the current digits and check if it\\'s a prime\\n            int number = 0;\\n            for (int i = 0; i < digitsCount; i++) {\\n                int index = i < digits.length ? i : digitsCount - i - 1;\\n                number = number * 10 + digits[index];\\n            }\\n            if (number >= N && isPrime(number)) return number;\\n            \\n            // if not, increment the digits to generate the next valid palindrome\\n            boolean increment = true;\\n            for (int i = digits.length - 1; increment && i >= 0; i--) {\\n                if (i == 0) {\\n                    if ((digits[0] & 1) != 1) digits[0]++;\\n                    else if (digits[0] == 9) {\\n                        digitsCount += 2;\\n                        digits = new int[(digitsCount + 1) / 2];\\n                        digits[0] = 1;\\n                    } else {\\n                        digits[0] += 2;\\n                    }\\n                } else if (digits[i] == 9) {\\n                    digits[i] = 0;\\n                    increment = true;\\n                } else {\\n                    digits[i] += 1;\\n                    increment = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        \\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        if (N > 7 && N <= 11) return 11;\\n\\n        int digitsCount = (int)Math.floor(Math.log10(N)) + 1; // number of digits of N\\n        if (digitsCount % 2 == 0) { N = (int)Math.pow(10, digitsCount); digitsCount++; } // skip even-digits palindromes\\n        int[] digits = new int[(digitsCount + 1) / 2]; // array of half the length of the number of digits\\n        // put the first half of the digits of N in the array\\n        int n = N, count = 0;\\n        while (n > 0) {\\n            if (++count > (digitsCount + 1) / 2) digits[digitsCount - count] = n % 10;\\n            n /= 10;\\n        }\\n\\n        while (true) {\\n            // create a palindrome number based on the current digits and check if it\\'s a prime\\n            int number = 0;\\n            for (int i = 0; i < digitsCount; i++) {\\n                int index = i < digits.length ? i : digitsCount - i - 1;\\n                number = number * 10 + digits[index];\\n            }\\n            if (number >= N && isPrime(number)) return number;\\n            \\n            // if not, increment the digits to generate the next valid palindrome\\n            boolean increment = true;\\n            for (int i = digits.length - 1; increment && i >= 0; i--) {\\n                if (i == 0) {\\n                    if ((digits[0] & 1) != 1) digits[0]++;\\n                    else if (digits[0] == 9) {\\n                        digitsCount += 2;\\n                        digits = new int[(digitsCount + 1) / 2];\\n                        digits[0] = 1;\\n                    } else {\\n                        digits[0] += 2;\\n                    }\\n                } else if (digits[i] == 9) {\\n                    digits[i] = 0;\\n                    increment = true;\\n                } else {\\n                    digits[i] += 1;\\n                    increment = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        \\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148253,
                "title": "straightforward-c-solutions-with-detailed-explanations",
                "content": "**Solution #1:** For small values of N less than or equal to ```11```, simply return the smallest prime value.  For values of N greater than ```11```, the next prime palindrome is ```101```.  Use the value ```i``` from ```[10:999999]``` to represent the first \"half\" of a candidate integer palindrome.  The value ```i``` is converted to a string order to construct the odd length palindrome ```101``` ( by pushing ```1``` onto the end of ```10``` ) and to construct the even length palindrome ```1001``` ( by pusing ```01``` onto the end of ```10``` ).  Always check if the odd length integer palindrome is prime first (since it has a smaller value than the even length integer palindrome) and check if the even length integer palindrome is prime second.  Return the integer value of the first found prime integer palindrome in this order.\\n\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N<12) return N<=2 ? 2 : N<4 ? 3 : N<6 ? 5 : N<8 ? 7 : 11;\\n        for (int i=10; i<1000000; ++i){\\n            string odd=to_string(i),even(odd+odd.back());\\n            for (int j=int(odd.size())-2; j>=0; --j){\\n                odd.push_back(odd[j]);\\n                even.push_back(odd[j]);\\n            }\\n            int p=stoi(odd),q=stoi(even);\\n            if (p>=N && isPrime(p))\\n                return p;\\n            if (q>=N && isPrime(q))\\n                return q;\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool isPrime(int x) {\\n        for (int i=2,M=(int)ceil(sqrt(x)); i<=M; ++i)\\n            if (x%i==0)\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**Note:** If this code looks strange, then just try stepping through the code for the first few values of ```i```.  As you can see, the integer value ```i``` is the first \"half\" of the palindrome:\\n\\n```i=10    odd=101    even=1001```\\n```i=11    odd=111    even=1111```\\n```i=12    odd=121    even=1221```\\n\\n```etc...```\\n\\n**Solution #2:** there are 782 prime palindrome (```PP```) candidates for the range ```1 <= N <= 10^8``` simply return the ```lower_bound``` of this ordered set ```PP```.  \\n**Note:** I printed this set as output from solution #1 above, so it is in ascending order.  I used ```iomanip``` to write to the ostream in hex left-padded with zeros so that the integer values are uniformly distributed along columns for enhanced readability.\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        return *lower_bound(PP.begin(),PP.end(),N);\\n    }\\nprivate:\\n    const set<int> PP{\\n 0x00000002,0x00000003,0x00000005,0x00000007,0x0000000b,0x00000065,0x00000083,0x00000097,0x000000b5,0x000000bf,\\n 0x00000139,0x00000161,0x00000175,0x0000017f,0x000002d7,0x000002f5,0x00000313,0x0000031d,0x00000397,0x000003a1,\\n 0x0000283d,0x00002905,0x00002969,0x00002c2f,0x00002c93,0x00003085,0x000031b1,0x00003215,0x00003413,0x00003607,\\n 0x0000366b,0x00003805,0x00003995,0x00003c5b,0x00003cbf,0x00003ebd,0x00003fe9,0x000040b1,0x00004115,0x0000443f,\\n 0x00004633,0x00004705,0x00004831,0x00004bbf,0x00004db3,0x00004e17,0x00007597,0x000075fb,0x000076c3,0x000077ef,\\n 0x00007853,0x00007925,0x00007b19,0x00007e43,0x00007ea7,0x000082fd,0x000086ef,0x0000881b,0x000088ed,0x00008951,\\n 0x00008a19,0x00008ba9,0x00008da7,0x00008ed3,0x00009199,0x000092c5,0x000094c3,0x00009527,0x0000977f,0x0000997d,\\n 0x0001123f,0x0001136b,0x000113cf,0x00011695,0x000118ed,0x00011a23,0x00011c17,0x00011d4d,0x00011e15,0x00011fa5,\\n 0x0001213f,0x000123fb,0x00012725,0x00012a4f,0x00012b7b,0x00012e41,0x00012ea5,0x00013099,0x00013297,0x000133c3,\\n 0x00013427,0x00013625,0x00013751,0x0001387d,0x00016255,0x0001638b,0x00016bd3,0x00016c37,0x00016e2b,0x00016f61,\\n 0x0001708d,0x000171b9,0x00017281,0x000172e5,0x000176d7,0x0001780d,0x000178d5,0x00017a01,0x00017c63,0x00017d2b,\\n 0x00017e57,0x00018055,0x00018181,0x000f4df9,0x000f6181,0x000f98f9,0x000fb069,0x000fcc25,0x000febc9,0x00101b0d,\\n 0x001036c9,0x00104281,0x0010660d,0x001085b1,0x00109169,0x0010ad25,0x0010b10d,0x0010ffff,0x00110bb7,0x001117d3,\\n 0x0011238b,0x00112f43,0x00113afb,0x00114ee7,0x00117a43,0x00118e2f,0x001199e7,0x0011b5a3,0x0011c15b,0x0011f09f,\\n 0x0011f86f,0x0011fc57,0x0012048b,0x00121043,0x00121bfb,0x00122bff,0x001237b7,0x0012436f,0x0012537d,0x00126ed5,\\n 0x00127ed9,0x00128a91,0x00129649,0x0012a265,0x0012d979,0x0012f535,0x0012f91d,0x001300ed,0x001314d9,0x00132091,\\n 0x00133031,0x0013441d,0x00135b8d,0x00136f79,0x00137b31,0x00138301,0x00138b35,0x00138f1d,0x0013a2a5,0x0013a68d,\\n 0x0013d63f,0x0013e1f7,0x0014019b,0x0014190b,0x0014407f,0x00144467,0x00145853,0x00146023,0x00146bdb,0x00147fc7,\\n 0x0014c2f7,0x0014cac7,0x0014ceaf,0x0014ee53,0x0014fa0b,0x00153953,0x00157841,0x00158011,0x00158845,0x00158c2d,\\n 0x0015b3a1,0x0015ee9d,0x00160a59,0x00161611,0x001629fd,0x0016399d,0x00164d89,0x00165559,0x00165941,0x00166cc9,\\n 0x0016aff9,0x0016bbb1,0x0016bffd,0x0016d76d,0x001702d3,0x001716bf,0x0017327b,0x001761bf,0x00176d77,0x00178933,\\n 0x0017a0a3,0x0017a8d7,0x0017acbf,0x0017c047,0x0017c42f,0x0017e3d3,0x0017ff8f,0x00181ae7,0x00181f33,0x00182aeb,\\n 0x0018425b,0x00185647,0x001861ff,0x001865e7,0x00186a3d,0x00188d65,0x00189599,0x0018a921,0x0018d865,0x0018e099,\\n 0x0018ec51,0x0019080d,0x001913c5,0x00191f7d,0x00193f21,0x00194ad9,0x00194ec1,0x001956f5,0x00197e69,0x0019b57d,\\n 0x0019b965,0x0019c51d,0x0019e0d9,0x0019fc9f,0x001a0c3f,0x001a202b,0x001a27fb,0x001a6743,0x001a76e3,0x001a829b,\\n 0x001aadf7,0x001ac9b3,0x001ae187,0x001aed3f,0x001b206b,0x001b5fb3,0x001b7f61,0x001b8b19,0x001bc679,0x001bd231,\\n 0x001bd619,0x001bdde9,0x001be9a1,0x001bf1d5,0x001bf5bd,0x001c1d31,0x001c40bd,0x001c488d,0x001c5445,0x001c77d1,\\n 0x001ca32d,0x001caafd,0x001caee5,0x001cb331,0x001cb719,0x001cbee9,0x001cc2d1,0x001cee2d,0x001d09f3,0x001d1d7b,\\n 0x001d2163,0x001d4107,0x001d5cc3,0x001d7497,0x001d8c07,0x001d9ff3,0x001dc767,0x001dcb4f,0x001dded7,0x001de2bf,\\n 0x001df6ab,0x001e0a33,0x001e0e1b,0x001e1267,0x001e29d7,0x001e3dc3,0x001e41ab,0x001e497b,0x001e5533,0x001e591b,\\n 0x001e6d07,0x001e74d7,0x001e808f,0x002dcaab,0x002dce93,0x002de21b,0x002e05a7,0x002e2d1b,0x002ec31b,0x002ec703,\\n 0x002ee2bf,0x002ee6a7,0x002eee77,0x002f0e1b,0x002f258b,0x002f2dbf,0x002f3d5f,0x002f5925,0x002f64dd,0x002fb7ad,\\n 0x002fd751,0x002feb3d,0x00302639,0x003031f1,0x00303a25,0x00305195,0x00308cf5,0x0030a465,0x0030bc39,0x0030c7f1,\\n 0x0030cfc1,0x0030ff73,0x0031035b,0x00311acb,0x00312acf,0x00312eb7,0x0031423f,0x0031562b,0x003161e3,0x003175cf,\\n 0x0031856f,0x0031a12b,0x0031b0cb,0x0031b89b,0x0031c0cf,0x0031dc27,0x0031f013,0x00321b6f,0x0032233f,0x00322727,\\n 0x00322ef7,0x00323b13,0x003242e3,0x00326a61,0x00326e49,0x00327619,0x00328235,0x003295bd,0x0032a55d,0x0032ad91,\\n 0x0032ccd1,0x0032d505,0x0032ec75,0x00330449,0x00332bbd,0x00334f49,0x00335719,0x00335b01,0x003366b9,0x00339661,\\n 0x0033c1bd,0x0033c5a5,0x0033e16b,0x00340cc7,0x00342437,0x00343ff3,0x003443db,0x00344bab,0x00347aef,0x00348323,\\n 0x00348af3,0x00348edb,0x00349a93,0x0034a263,0x0034ae7f,0x0034ce23,0x0034e593,0x0034f597,0x003518bf,0x00353093,\\n 0x00353863,0x003573cd,0x0035a311,0x0035aae1,0x0035d63d,0x003609cd,0x00363911,0x00364c99,0x00366085,0x003677f5,\\n 0x0036bb25,0x0036c6dd,0x0036cb29,0x0036cf11,0x0036dac9,0x0036f2a7,0x00370a17,0x00373573,0x0037418f,0x003758ff,\\n 0x003778a3,0x00379847,0x0037a3ff,0x003802eb,0x00380ea3,0x00382a5f,0x00384d87,0x00387113,0x003894a9,0x00389891,\\n 0x0038b44d,0x0038b835,0x0038c839,0x0038cc21,0x0038e391,0x0038f395,0x00391ef1,0x00392aa9,0x003969f1,0x00396dd9,\\n 0x003975a9,0x00398161,0x00398549,0x0039954d,0x00399935,0x0039b4f1,0x0039c0a9,0x0039e04d,0x0039e435,0x0039fba5,\\n 0x003a0bb3,0x003a1383,0x003a2b57,0x003a3327,0x003a626b,0x003a6e23,0x003a89df,0x003aa1b3,0x003acd0f,0x003ae097,\\n 0x003af483,0x003af86b,0x003b0423,0x003b0bf3,0x003b1427,0x003b2f7f,0x003b6adf,0x003b824f,0x003bb5e9,0x003bc1a1,\\n 0x003bc971,0x003be145,0x003becfd,0x003bfd01,0x003c1859,0x003c285d,0x003c37fd,0x003c3fcd,0x003c7f15,0x003c96e9,\\n 0x003cca15,0x003ce9b9,0x003cf571,0x003d0129,0x003d0511,0x006b06db,0x006b59ab,0x006b5d93,0x006b717f,0x006b8507,\\n 0x006bb063,0x006bd007,0x006bdfa7,0x006befab,0x006c071b,0x006c1337,0x006c1b07,0x006c26bf,0x006c3e93,0x006c4a4b,\\n 0x006c5671,0x006c8d85,0x006c916d,0x006c9d25,0x006cc881,0x006cdc6d,0x006ce43d,0x006cf829,0x006d07c9,0x006d2f3d,\\n 0x006d3325,0x006d3af5,0x006d3edd,0x006d85f5,0x006db985,0x006dc925,0x006e1817,0x006e4373,0x006e925b,0x006e9e13,\\n 0x006ea25f,0x006eb9cf,0x006ebdb7,0x006ecdbb,0x006ee52b,0x006f08b7,0x006f1087,0x006f4417,0x006f63c5,0x006f6b95,\\n 0x006f8b39,0x006f9ad9,0x006fc24d,0x006fce05,0x00701ced,0x007030d9,0x007038a9,0x0070584d,0x00706405,0x0070a34d,\\n 0x0070bea5,0x0070cea9,0x0070ee57,0x0070f627,0x00710d97,0x0071256b,0x0071706b,0x0071783b,0x007183f3,0x0071b783,\\n 0x0071db0f,0x0071ee97,0x0072066b,0x00721223,0x00723997,0x00723d7f,0x00724937,0x0072593b,0x00728c71,0x00729059,\\n 0x0072b7cd,0x0072bbb5,0x0072c3e9,0x0072db59,0x00730ee9,0x007365a1,0x00736d71,0x00739cb5,0x0073c429,0x0073dbfd,\\n 0x0073e3cd,0x0073f7c3,0x0074231f,0x0074425f,0x00744e7b,0x00746e1f,0x007475ef,0x0074a533,0x0074cca7,0x0074ec4b,\\n 0x0074f803,0x0074fbeb,0x007503bb,0x007507a3,0x00751b8f,0x0075374b,0x00755ad7,0x0075668f,0x00757247,0x0075b969,\\n 0x0075c521,0x0075d525,0x0075f07d,0x00760081,0x0076240d,0x00763795,0x007643b1,0x007662f1,0x00767ac5,0x00769a69,\\n 0x0076a239,0x0076b1d9,0x0076c1dd,0x0076c5c5,0x0076e569,0x0076f121,0x0077206f,0x00774fb3,0x007753ff,0x007757e7,\\n 0x00777f5b,0x00778343,0x00779ab3,0x0077ae9f,0x0077ca5b,0x0077e1cb,0x00780557,0x00780d27,0x0078110f,0x007824fb,\\n 0x00785057,0x00786c13,0x00788383,0x0078beed,0x0078caa5,0x0079021d,0x00790dd5,0x007915a5,0x0079215d,0x00792d79,\\n 0x00793549,0x00794cb9,0x00796c5d,0x00797045,0x00797879,0x0079bb45,0x0079d701,0x0079dae9,0x0079e2b9,0x007a0645,\\n 0x00895c19,0x00898f45,0x0089b2d1,0x0089e5fd,0x0089f9e9,0x0089fdd1,0x008a05a1,0x008a0989,0x008a1541,0x008a5c59,\\n 0x008a742d,0x008a7fe5,0x008a87b5,0x008abb45,0x008acae5,0x008ae6ab,0x008afe1b,0x008b0267,0x008b4533,0x008b491b,\\n 0x008b68bf,0x008b9beb,0x008bead3,0x008bfad7,0x008bfebf,0x008c1247,0x008c2a1b,0x008c5577,0x008c612f,0x008c619d,\\n 0x008c84c5,0x008c90e1,0x008ca469,0x008cb855,0x008cbc3d,0x008cd7f9,0x008cdbe1,0x008d3a69,0x008d717d,0x008d79b1,\\n 0x008d9121,0x008d9d3d,0x008db4ad,0x008dc065,0x008e2efb,0x008e372f,0x008e46cf,0x008e5a57,0x008e6673,0x008e7de3,\\n 0x008eb173,0x008ec8e3,0x008f0ffb,0x008f3387,0x008f66b3,0x008f6ef1,0x008fa605,0x008fb98d,0x008ff105,0x00900875,\\n 0x00900cc1,0x00902431,0x0090381d,0x0090831d,0x00909e75,0x0090d9d5,0x0090ddbd,0x0090e58d,0x0091053b,0x00912caf,\\n 0x00915bf3,0x009167ab,0x0091aec3,0x0091d24f,0x0091da1f,0x0091e63b,0x0092251f,0x00923cf3,0x009244c3,0x009248ab,\\n 0x0092802d,0x00928415,0x00928be5,0x0092a3b9,0x0092cb2d,0x0092dacd,0x0092e29d,0x0092fa71,0x00930241,0x00932d9d,\\n 0x00934189,0x00935ce1,0x00939071,0x0093cf55,0x009402ef,0x00942617,0x00942e4b,0x00943a03,0x00946177,0x00946d2f,\\n 0x0094811b,0x00948503,0x0094ac77,0x0094c3e7,0x0094d003,0x0094d7d3,0x0094e773,0x0094f777,0x0095171b,0x00952e8b,\\n 0x00953a43,0x00954277,0x0095465f,0x009559e7,0x00955dcf,0x0095798b,0x00958d81,0x0095a4f1,0x0095acc1,0x0095cc65,\\n 0x0095d04d,0x0095d881,0x0095e051,0x00961765,0x00961b4d,0x00963af1,0x009656ad,0x0096a1ad,0x0096e479,0x0096e861,\\n 0x0097041d,0x00971813,0x00972b9b,0x00972f83,0x00974f27,0x009756f7,0x00975adf,0x00976313,0x00976ae3,0x0097769b,\\n 0x00977a83,0x00978a87,0x00978e6f,0x00979a27,0x0097a5df,0x0097f0df,0x00981083,0x009843af,0x00984be3,0x00984fcb,\\n 0x00986f0b,0x05f65631,};\\n};\\n```",
                "solutionTags": [],
                "code": "```11```\n```11```\n```101```\n```i```\n```[10:999999]```\n```i```\n```101```\n```1```\n```10```\n```1001```\n```01```\n```10```\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N<12) return N<=2 ? 2 : N<4 ? 3 : N<6 ? 5 : N<8 ? 7 : 11;\\n        for (int i=10; i<1000000; ++i){\\n            string odd=to_string(i),even(odd+odd.back());\\n            for (int j=int(odd.size())-2; j>=0; --j){\\n                odd.push_back(odd[j]);\\n                even.push_back(odd[j]);\\n            }\\n            int p=stoi(odd),q=stoi(even);\\n            if (p>=N && isPrime(p))\\n                return p;\\n            if (q>=N && isPrime(q))\\n                return q;\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool isPrime(int x) {\\n        for (int i=2,M=(int)ceil(sqrt(x)); i<=M; ++i)\\n            if (x%i==0)\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```i```\n```i```\n```i=10    odd=101    even=1001```\n```i=11    odd=111    even=1111```\n```i=12    odd=121    even=1221```\n```etc...```\n```PP```\n```1 <= N <= 10^8```\n```lower_bound```\n```PP```\n```iomanip```\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        return *lower_bound(PP.begin(),PP.end(),N);\\n    }\\nprivate:\\n    const set<int> PP{\\n 0x00000002,0x00000003,0x00000005,0x00000007,0x0000000b,0x00000065,0x00000083,0x00000097,0x000000b5,0x000000bf,\\n 0x00000139,0x00000161,0x00000175,0x0000017f,0x000002d7,0x000002f5,0x00000313,0x0000031d,0x00000397,0x000003a1,\\n 0x0000283d,0x00002905,0x00002969,0x00002c2f,0x00002c93,0x00003085,0x000031b1,0x00003215,0x00003413,0x00003607,\\n 0x0000366b,0x00003805,0x00003995,0x00003c5b,0x00003cbf,0x00003ebd,0x00003fe9,0x000040b1,0x00004115,0x0000443f,\\n 0x00004633,0x00004705,0x00004831,0x00004bbf,0x00004db3,0x00004e17,0x00007597,0x000075fb,0x000076c3,0x000077ef,\\n 0x00007853,0x00007925,0x00007b19,0x00007e43,0x00007ea7,0x000082fd,0x000086ef,0x0000881b,0x000088ed,0x00008951,\\n 0x00008a19,0x00008ba9,0x00008da7,0x00008ed3,0x00009199,0x000092c5,0x000094c3,0x00009527,0x0000977f,0x0000997d,\\n 0x0001123f,0x0001136b,0x000113cf,0x00011695,0x000118ed,0x00011a23,0x00011c17,0x00011d4d,0x00011e15,0x00011fa5,\\n 0x0001213f,0x000123fb,0x00012725,0x00012a4f,0x00012b7b,0x00012e41,0x00012ea5,0x00013099,0x00013297,0x000133c3,\\n 0x00013427,0x00013625,0x00013751,0x0001387d,0x00016255,0x0001638b,0x00016bd3,0x00016c37,0x00016e2b,0x00016f61,\\n 0x0001708d,0x000171b9,0x00017281,0x000172e5,0x000176d7,0x0001780d,0x000178d5,0x00017a01,0x00017c63,0x00017d2b,\\n 0x00017e57,0x00018055,0x00018181,0x000f4df9,0x000f6181,0x000f98f9,0x000fb069,0x000fcc25,0x000febc9,0x00101b0d,\\n 0x001036c9,0x00104281,0x0010660d,0x001085b1,0x00109169,0x0010ad25,0x0010b10d,0x0010ffff,0x00110bb7,0x001117d3,\\n 0x0011238b,0x00112f43,0x00113afb,0x00114ee7,0x00117a43,0x00118e2f,0x001199e7,0x0011b5a3,0x0011c15b,0x0011f09f,\\n 0x0011f86f,0x0011fc57,0x0012048b,0x00121043,0x00121bfb,0x00122bff,0x001237b7,0x0012436f,0x0012537d,0x00126ed5,\\n 0x00127ed9,0x00128a91,0x00129649,0x0012a265,0x0012d979,0x0012f535,0x0012f91d,0x001300ed,0x001314d9,0x00132091,\\n 0x00133031,0x0013441d,0x00135b8d,0x00136f79,0x00137b31,0x00138301,0x00138b35,0x00138f1d,0x0013a2a5,0x0013a68d,\\n 0x0013d63f,0x0013e1f7,0x0014019b,0x0014190b,0x0014407f,0x00144467,0x00145853,0x00146023,0x00146bdb,0x00147fc7,\\n 0x0014c2f7,0x0014cac7,0x0014ceaf,0x0014ee53,0x0014fa0b,0x00153953,0x00157841,0x00158011,0x00158845,0x00158c2d,\\n 0x0015b3a1,0x0015ee9d,0x00160a59,0x00161611,0x001629fd,0x0016399d,0x00164d89,0x00165559,0x00165941,0x00166cc9,\\n 0x0016aff9,0x0016bbb1,0x0016bffd,0x0016d76d,0x001702d3,0x001716bf,0x0017327b,0x001761bf,0x00176d77,0x00178933,\\n 0x0017a0a3,0x0017a8d7,0x0017acbf,0x0017c047,0x0017c42f,0x0017e3d3,0x0017ff8f,0x00181ae7,0x00181f33,0x00182aeb,\\n 0x0018425b,0x00185647,0x001861ff,0x001865e7,0x00186a3d,0x00188d65,0x00189599,0x0018a921,0x0018d865,0x0018e099,\\n 0x0018ec51,0x0019080d,0x001913c5,0x00191f7d,0x00193f21,0x00194ad9,0x00194ec1,0x001956f5,0x00197e69,0x0019b57d,\\n 0x0019b965,0x0019c51d,0x0019e0d9,0x0019fc9f,0x001a0c3f,0x001a202b,0x001a27fb,0x001a6743,0x001a76e3,0x001a829b,\\n 0x001aadf7,0x001ac9b3,0x001ae187,0x001aed3f,0x001b206b,0x001b5fb3,0x001b7f61,0x001b8b19,0x001bc679,0x001bd231,\\n 0x001bd619,0x001bdde9,0x001be9a1,0x001bf1d5,0x001bf5bd,0x001c1d31,0x001c40bd,0x001c488d,0x001c5445,0x001c77d1,\\n 0x001ca32d,0x001caafd,0x001caee5,0x001cb331,0x001cb719,0x001cbee9,0x001cc2d1,0x001cee2d,0x001d09f3,0x001d1d7b,\\n 0x001d2163,0x001d4107,0x001d5cc3,0x001d7497,0x001d8c07,0x001d9ff3,0x001dc767,0x001dcb4f,0x001dded7,0x001de2bf,\\n 0x001df6ab,0x001e0a33,0x001e0e1b,0x001e1267,0x001e29d7,0x001e3dc3,0x001e41ab,0x001e497b,0x001e5533,0x001e591b,\\n 0x001e6d07,0x001e74d7,0x001e808f,0x002dcaab,0x002dce93,0x002de21b,0x002e05a7,0x002e2d1b,0x002ec31b,0x002ec703,\\n 0x002ee2bf,0x002ee6a7,0x002eee77,0x002f0e1b,0x002f258b,0x002f2dbf,0x002f3d5f,0x002f5925,0x002f64dd,0x002fb7ad,\\n 0x002fd751,0x002feb3d,0x00302639,0x003031f1,0x00303a25,0x00305195,0x00308cf5,0x0030a465,0x0030bc39,0x0030c7f1,\\n 0x0030cfc1,0x0030ff73,0x0031035b,0x00311acb,0x00312acf,0x00312eb7,0x0031423f,0x0031562b,0x003161e3,0x003175cf,\\n 0x0031856f,0x0031a12b,0x0031b0cb,0x0031b89b,0x0031c0cf,0x0031dc27,0x0031f013,0x00321b6f,0x0032233f,0x00322727,\\n 0x00322ef7,0x00323b13,0x003242e3,0x00326a61,0x00326e49,0x00327619,0x00328235,0x003295bd,0x0032a55d,0x0032ad91,\\n 0x0032ccd1,0x0032d505,0x0032ec75,0x00330449,0x00332bbd,0x00334f49,0x00335719,0x00335b01,0x003366b9,0x00339661,\\n 0x0033c1bd,0x0033c5a5,0x0033e16b,0x00340cc7,0x00342437,0x00343ff3,0x003443db,0x00344bab,0x00347aef,0x00348323,\\n 0x00348af3,0x00348edb,0x00349a93,0x0034a263,0x0034ae7f,0x0034ce23,0x0034e593,0x0034f597,0x003518bf,0x00353093,\\n 0x00353863,0x003573cd,0x0035a311,0x0035aae1,0x0035d63d,0x003609cd,0x00363911,0x00364c99,0x00366085,0x003677f5,\\n 0x0036bb25,0x0036c6dd,0x0036cb29,0x0036cf11,0x0036dac9,0x0036f2a7,0x00370a17,0x00373573,0x0037418f,0x003758ff,\\n 0x003778a3,0x00379847,0x0037a3ff,0x003802eb,0x00380ea3,0x00382a5f,0x00384d87,0x00387113,0x003894a9,0x00389891,\\n 0x0038b44d,0x0038b835,0x0038c839,0x0038cc21,0x0038e391,0x0038f395,0x00391ef1,0x00392aa9,0x003969f1,0x00396dd9,\\n 0x003975a9,0x00398161,0x00398549,0x0039954d,0x00399935,0x0039b4f1,0x0039c0a9,0x0039e04d,0x0039e435,0x0039fba5,\\n 0x003a0bb3,0x003a1383,0x003a2b57,0x003a3327,0x003a626b,0x003a6e23,0x003a89df,0x003aa1b3,0x003acd0f,0x003ae097,\\n 0x003af483,0x003af86b,0x003b0423,0x003b0bf3,0x003b1427,0x003b2f7f,0x003b6adf,0x003b824f,0x003bb5e9,0x003bc1a1,\\n 0x003bc971,0x003be145,0x003becfd,0x003bfd01,0x003c1859,0x003c285d,0x003c37fd,0x003c3fcd,0x003c7f15,0x003c96e9,\\n 0x003cca15,0x003ce9b9,0x003cf571,0x003d0129,0x003d0511,0x006b06db,0x006b59ab,0x006b5d93,0x006b717f,0x006b8507,\\n 0x006bb063,0x006bd007,0x006bdfa7,0x006befab,0x006c071b,0x006c1337,0x006c1b07,0x006c26bf,0x006c3e93,0x006c4a4b,\\n 0x006c5671,0x006c8d85,0x006c916d,0x006c9d25,0x006cc881,0x006cdc6d,0x006ce43d,0x006cf829,0x006d07c9,0x006d2f3d,\\n 0x006d3325,0x006d3af5,0x006d3edd,0x006d85f5,0x006db985,0x006dc925,0x006e1817,0x006e4373,0x006e925b,0x006e9e13,\\n 0x006ea25f,0x006eb9cf,0x006ebdb7,0x006ecdbb,0x006ee52b,0x006f08b7,0x006f1087,0x006f4417,0x006f63c5,0x006f6b95,\\n 0x006f8b39,0x006f9ad9,0x006fc24d,0x006fce05,0x00701ced,0x007030d9,0x007038a9,0x0070584d,0x00706405,0x0070a34d,\\n 0x0070bea5,0x0070cea9,0x0070ee57,0x0070f627,0x00710d97,0x0071256b,0x0071706b,0x0071783b,0x007183f3,0x0071b783,\\n 0x0071db0f,0x0071ee97,0x0072066b,0x00721223,0x00723997,0x00723d7f,0x00724937,0x0072593b,0x00728c71,0x00729059,\\n 0x0072b7cd,0x0072bbb5,0x0072c3e9,0x0072db59,0x00730ee9,0x007365a1,0x00736d71,0x00739cb5,0x0073c429,0x0073dbfd,\\n 0x0073e3cd,0x0073f7c3,0x0074231f,0x0074425f,0x00744e7b,0x00746e1f,0x007475ef,0x0074a533,0x0074cca7,0x0074ec4b,\\n 0x0074f803,0x0074fbeb,0x007503bb,0x007507a3,0x00751b8f,0x0075374b,0x00755ad7,0x0075668f,0x00757247,0x0075b969,\\n 0x0075c521,0x0075d525,0x0075f07d,0x00760081,0x0076240d,0x00763795,0x007643b1,0x007662f1,0x00767ac5,0x00769a69,\\n 0x0076a239,0x0076b1d9,0x0076c1dd,0x0076c5c5,0x0076e569,0x0076f121,0x0077206f,0x00774fb3,0x007753ff,0x007757e7,\\n 0x00777f5b,0x00778343,0x00779ab3,0x0077ae9f,0x0077ca5b,0x0077e1cb,0x00780557,0x00780d27,0x0078110f,0x007824fb,\\n 0x00785057,0x00786c13,0x00788383,0x0078beed,0x0078caa5,0x0079021d,0x00790dd5,0x007915a5,0x0079215d,0x00792d79,\\n 0x00793549,0x00794cb9,0x00796c5d,0x00797045,0x00797879,0x0079bb45,0x0079d701,0x0079dae9,0x0079e2b9,0x007a0645,\\n 0x00895c19,0x00898f45,0x0089b2d1,0x0089e5fd,0x0089f9e9,0x0089fdd1,0x008a05a1,0x008a0989,0x008a1541,0x008a5c59,\\n 0x008a742d,0x008a7fe5,0x008a87b5,0x008abb45,0x008acae5,0x008ae6ab,0x008afe1b,0x008b0267,0x008b4533,0x008b491b,\\n 0x008b68bf,0x008b9beb,0x008bead3,0x008bfad7,0x008bfebf,0x008c1247,0x008c2a1b,0x008c5577,0x008c612f,0x008c619d,\\n 0x008c84c5,0x008c90e1,0x008ca469,0x008cb855,0x008cbc3d,0x008cd7f9,0x008cdbe1,0x008d3a69,0x008d717d,0x008d79b1,\\n 0x008d9121,0x008d9d3d,0x008db4ad,0x008dc065,0x008e2efb,0x008e372f,0x008e46cf,0x008e5a57,0x008e6673,0x008e7de3,\\n 0x008eb173,0x008ec8e3,0x008f0ffb,0x008f3387,0x008f66b3,0x008f6ef1,0x008fa605,0x008fb98d,0x008ff105,0x00900875,\\n 0x00900cc1,0x00902431,0x0090381d,0x0090831d,0x00909e75,0x0090d9d5,0x0090ddbd,0x0090e58d,0x0091053b,0x00912caf,\\n 0x00915bf3,0x009167ab,0x0091aec3,0x0091d24f,0x0091da1f,0x0091e63b,0x0092251f,0x00923cf3,0x009244c3,0x009248ab,\\n 0x0092802d,0x00928415,0x00928be5,0x0092a3b9,0x0092cb2d,0x0092dacd,0x0092e29d,0x0092fa71,0x00930241,0x00932d9d,\\n 0x00934189,0x00935ce1,0x00939071,0x0093cf55,0x009402ef,0x00942617,0x00942e4b,0x00943a03,0x00946177,0x00946d2f,\\n 0x0094811b,0x00948503,0x0094ac77,0x0094c3e7,0x0094d003,0x0094d7d3,0x0094e773,0x0094f777,0x0095171b,0x00952e8b,\\n 0x00953a43,0x00954277,0x0095465f,0x009559e7,0x00955dcf,0x0095798b,0x00958d81,0x0095a4f1,0x0095acc1,0x0095cc65,\\n 0x0095d04d,0x0095d881,0x0095e051,0x00961765,0x00961b4d,0x00963af1,0x009656ad,0x0096a1ad,0x0096e479,0x0096e861,\\n 0x0097041d,0x00971813,0x00972b9b,0x00972f83,0x00974f27,0x009756f7,0x00975adf,0x00976313,0x00976ae3,0x0097769b,\\n 0x00977a83,0x00978a87,0x00978e6f,0x00979a27,0x0097a5df,0x0097f0df,0x00981083,0x009843af,0x00984be3,0x00984fcb,\\n 0x00986f0b,0x05f65631,};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553716,
                "title": "explained-fastest-solution-c-odd-length-palindromes",
                "content": "# Brute Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn brute force algorithm, we will iterate over all $i$ for $>=n$ && $<=2*10^8$ and check if that is prime and is palindrome or not. \\nAs soon as some i satisfies this equation, we will return the i.\\n\\nTime complexity to find if n is prime or not $O(sqrt(n))$\\nTime complexity to find if n is palindrome or not $O(log(n))$\\n\\nOverall this brute approach will take too much time complexity.\\n\\nThe optimized solution is deduced from one fact ------\\nAll even length palindrome are divisble by 11.\\nAnd among all even length palindrome only 11 is prime. \\nSo now we have to worry about only odd length palindrome.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow, we make such algorithm which only checks for odd length palindrome and checks if that is prime or not.\\n\\nThis question also teaches us how to print all odd length palindrome efficiently.\\n\\nBrute way would be to iterate over all possibilities and check if it is odd or not. \\n\\nThe optimised solution to get only odd length palindrome is by making odd length palindrome.\\n\\nNow we need to see that the answer lies between $[2,2*10^8]$. \\n200000000 ---It is of length 9.\\nSo the palindrome will be abcdedcba.\\nSo, if we iterate over all abcde, we can make a corresponding palindrome and it will be a odd length too.\\nSo by just iterating over abcde, i.e. 10^5. We can create all palindromes less than $2*10^8$ without iteration.\\n\\n# Individual Complexity\\n- Time complexity: $O(100000)*[O(log(i)) + O(log(i)) + O(2*log(i)-1) + sqrt(x)]$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere \\ni will be $1<=i<=1e5$\\nI checked time complexities of the inbuilt functions also ans \\nto_string(i)-------------------->$O(log(i))$\\nas there are $log(i)$ digits in integer $i$\\nreverse(s.begin(),s.end())-----> $O(log(i))$\\nstoi(s)-------------------------> $O(2*(log(i))-1)$ \\nas the total length will $log(i)+log(i)-1$\\nisprime(x)---------------------> $O(sqrt(x))$\\n\\n# Overall  Complexity\\nTime complexity: $O(100000)*[O(log(i)) + O(log(i)) + O(2*log(i)-1) + sqrt(x)]$\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    \\n    bool isprime(int n)\\n    {\\n        if(n==0 || n==1) return false;\\n        for(int i =2;i*i<=n;i++)\\n        {\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        if(n>=8 && n<=11) return 11;\\n        for(int i =1;i<=100000;i++)\\n        {\\n            string s = to_string(i); //convert int to string\\n            string r =s; \\n            reverse(r.begin(),r.end()); //reverse the string and store in r\\n            int y = stoi(s+r.substr(1)); //  adding r in s except first character and convering to integer\\n            if(y>=n && isprime(y)) return y; // checking if it is prime or not.\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    \\n    bool isprime(int n)\\n    {\\n        if(n==0 || n==1) return false;\\n        for(int i =2;i*i<=n;i++)\\n        {\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        if(n>=8 && n<=11) return 11;\\n        for(int i =1;i<=100000;i++)\\n        {\\n            string s = to_string(i); //convert int to string\\n            string r =s; \\n            reverse(r.begin(),r.end()); //reverse the string and store in r\\n            int y = stoi(s+r.substr(1)); //  adding r in s except first character and convering to integer\\n            if(y>=n && isprime(y)) return y; // checking if it is prime or not.\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3499365,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t(s.rbegin(), s.rend()) ;\\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n```\\n\\n```Java []\\nclass Solution {\\n    private int n;\\n    private int numDigits;\\n    private static ArrayList<Integer> primes;\\n    private static int lastChecked = 1;\\n    public int primePalindrome(int nInput) {\\n        n = nInput;\\n        if (n==1 || n==2){\\n            return 2;\\n        }\\n        if (n==4 || n==5){\\n            return 5;\\n        }\\n        if (primes == null){\\n            primes = new ArrayList<Integer>();\\n            primes.add(2);\\n        }\\n        numDigits = 1;\\n        while (n >= Math.pow(10, numDigits)){\\n            numDigits++;\\n        }\\n        if (numDigits%2 == 0 && n > 11){\\n            n = (int)Math.pow(10, numDigits)+1;\\n            numDigits++;\\n        }\\n        int msd = getDigit(numDigits);\\n        if (msd%2 == 0 || msd == 5){\\n            if (msd >= 4 && msd <= 6){\\n                msd = 7;\\n            } else {\\n                msd++;\\n            }\\n            n = msd;\\n            if (numDigits!=1){\\n                n+=msd * (int)Math.pow(10, numDigits-1);\\n            }\\n        } else {\\n            for (int i = (numDigits+1)/2; i > 0; i--){\\n                setDigit(i, getDigit(numDigits-i+1));\\n            }\\n            if (n < nInput){\\n                increment();\\n            }\\n        }\\n        while (!isPrime()){\\n            increment();\\n        }\\n        return n;\\n    }\\n    private int getDigit(int i) {\\n        return (n%(int)Math.pow(10, i))/(int)Math.pow(10, i-1);\\n    }\\n    private void setDigit(int i, int m) {\\n        int first = n-n%(int)Math.pow(10, numDigits-i+1);\\n        int middle = Math.max(0, n%(int)Math.pow(10, numDigits-i)\\n            - n%(int)Math.pow(10, i));\\n        int last = n%(int)Math.pow(10, i-1);\\n        n = first + middle + last + m*(int)Math.pow(10, i-1);\\n        if (i != numDigits-i+1){\\n            n += m*(int)Math.pow(10, numDigits-i);\\n        }\\n    }\\n    private void increment(){\\n        for (int i = (numDigits+1)/2; i > 0; i--){\\n            int curDigit = getDigit(i);\\n            if (i == 1 && curDigit == 9){\\n                if (numDigits == 1){\\n                    n = 11;\\n                    numDigits = 2;\\n                    return;\\n                } else {\\n                    n = (int)Math.pow(10, numDigits+1)+1;\\n                    numDigits+=2;\\n                    return;\\n                }\\n            } else if (curDigit == 9){\\n                setDigit(i, 0);\\n            } else {\\n                curDigit++;\\n                if (i == 1){\\n                    if (curDigit%2 == 0 || curDigit == 5){\\n                        if (curDigit >= 4 && curDigit <= 6){\\n                            curDigit = 7;\\n                        } else {\\n                            curDigit++;\\n                        }\\n                    }\\n                }\\n                setDigit(i, curDigit);\\n                return;\\n            }\\n        }\\n    }\\n    private boolean isPrime() {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = lastChecked+2; i <= end; i+=2){\\n            if (isPrimeLookup(i)){\\n                primes.add(i);\\n            }\\n            lastChecked = i;\\n        }\\n        return isPrimeLookup(n);\\n    }\\n    private boolean isPrimeLookup(int m){\\n        int end = (int)Math.sqrt(m);\\n        for (int i = 0; i < primes.size() && primes.get(i) <= end; i++){\\n            if (m%primes.get(i) == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t(s.rbegin(), s.rend()) ;\\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n```\n```Java []\\nclass Solution {\\n    private int n;\\n    private int numDigits;\\n    private static ArrayList<Integer> primes;\\n    private static int lastChecked = 1;\\n    public int primePalindrome(int nInput) {\\n        n = nInput;\\n        if (n==1 || n==2){\\n            return 2;\\n        }\\n        if (n==4 || n==5){\\n            return 5;\\n        }\\n        if (primes == null){\\n            primes = new ArrayList<Integer>();\\n            primes.add(2);\\n        }\\n        numDigits = 1;\\n        while (n >= Math.pow(10, numDigits)){\\n            numDigits++;\\n        }\\n        if (numDigits%2 == 0 && n > 11){\\n            n = (int)Math.pow(10, numDigits)+1;\\n            numDigits++;\\n        }\\n        int msd = getDigit(numDigits);\\n        if (msd%2 == 0 || msd == 5){\\n            if (msd >= 4 && msd <= 6){\\n                msd = 7;\\n            } else {\\n                msd++;\\n            }\\n            n = msd;\\n            if (numDigits!=1){\\n                n+=msd * (int)Math.pow(10, numDigits-1);\\n            }\\n        } else {\\n            for (int i = (numDigits+1)/2; i > 0; i--){\\n                setDigit(i, getDigit(numDigits-i+1));\\n            }\\n            if (n < nInput){\\n                increment();\\n            }\\n        }\\n        while (!isPrime()){\\n            increment();\\n        }\\n        return n;\\n    }\\n    private int getDigit(int i) {\\n        return (n%(int)Math.pow(10, i))/(int)Math.pow(10, i-1);\\n    }\\n    private void setDigit(int i, int m) {\\n        int first = n-n%(int)Math.pow(10, numDigits-i+1);\\n        int middle = Math.max(0, n%(int)Math.pow(10, numDigits-i)\\n            - n%(int)Math.pow(10, i));\\n        int last = n%(int)Math.pow(10, i-1);\\n        n = first + middle + last + m*(int)Math.pow(10, i-1);\\n        if (i != numDigits-i+1){\\n            n += m*(int)Math.pow(10, numDigits-i);\\n        }\\n    }\\n    private void increment(){\\n        for (int i = (numDigits+1)/2; i > 0; i--){\\n            int curDigit = getDigit(i);\\n            if (i == 1 && curDigit == 9){\\n                if (numDigits == 1){\\n                    n = 11;\\n                    numDigits = 2;\\n                    return;\\n                } else {\\n                    n = (int)Math.pow(10, numDigits+1)+1;\\n                    numDigits+=2;\\n                    return;\\n                }\\n            } else if (curDigit == 9){\\n                setDigit(i, 0);\\n            } else {\\n                curDigit++;\\n                if (i == 1){\\n                    if (curDigit%2 == 0 || curDigit == 5){\\n                        if (curDigit >= 4 && curDigit <= 6){\\n                            curDigit = 7;\\n                        } else {\\n                            curDigit++;\\n                        }\\n                    }\\n                }\\n                setDigit(i, curDigit);\\n                return;\\n            }\\n        }\\n    }\\n    private boolean isPrime() {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = lastChecked+2; i <= end; i+=2){\\n            if (isPrimeLookup(i)){\\n                primes.add(i);\\n            }\\n            lastChecked = i;\\n        }\\n        return isPrimeLookup(n);\\n    }\\n    private boolean isPrimeLookup(int m){\\n        int end = (int)Math.sqrt(m);\\n        for (int i = 0; i < primes.size() && primes.get(i) <= end; i++){\\n            if (m%primes.get(i) == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359291,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1>Check if n is a palindrome. If it is, check if it is a prime number. If it is, return n.\\n2>Otherwise, increment n by 1 and repeat step 1 until a palindrome prime is found.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm depends on the number of steps it takes to find a palindrome prime greater than or equal to n. The worst-case scenario is when n is a large prime number and the next palindrome prime is much large.\\n\\n- Space complexity:\\nThe space complexity of this algorithm is O(1) .\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n#1 best \\n        def is_palindrome(x):\\n            return str(x) == str(x)[::-1]\\n        \\n        def is_prime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, int(x ** 0.5) + 1):\\n                if x % i == 0:\\n                    return False\\n            return True\\n        \\n        while True:\\n            if is_palindrome(n) and is_prime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n        #2 TLE\\n        # def is_prime(number):\\n        #     if number > 1:\\n        #         for num in range(2, number):\\n        #             if number % num == 0:\\n        #                 return False\\n        #         return True\\n        #     return False\\n\\n        # n_str = str(n)\\n        # l = len(n_str)        \\n        # for k in range(max(0, l//2-1), 5):\\n        #     for i in range(10**k, 10**(k+1)):                            # odd length\\n        #         i_str = str(i)\\n        #         if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n        #         cur = i_str + i_str[-2::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n                \\n        #     for i in range(10**k, 10**(k+1)):                            # even length\\n        #         i_str = str(i)\\n        #         if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n        #         cur = i_str + i_str[::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n        # return -1\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #3 TLE\\n        # if 8 <= n <= 11: return 11\\n        # for x in range(10 ** (len(str(n))// 2), 10**5):\\n        #     y = int(str(x) + str(x)[-2::-1])\\n        #     if y >= n and is_prime(y): return y\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #4 it gives TLE\\n        # res=n\\n        # c=1\\n        # while c:\\n        #     if str(res)==str(res)[::-1] and is_prime(res)==True:\\n        #         c=0\\n        #     else:\\n        #         res+=1\\n        # return res\\n            \\n\\n     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n#1 best \\n        def is_palindrome(x):\\n            return str(x) == str(x)[::-1]\\n        \\n        def is_prime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, int(x ** 0.5) + 1):\\n                if x % i == 0:\\n                    return False\\n            return True\\n        \\n        while True:\\n            if is_palindrome(n) and is_prime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n        #2 TLE\\n        # def is_prime(number):\\n        #     if number > 1:\\n        #         for num in range(2, number):\\n        #             if number % num == 0:\\n        #                 return False\\n        #         return True\\n        #     return False\\n\\n        # n_str = str(n)\\n        # l = len(n_str)        \\n        # for k in range(max(0, l//2-1), 5):\\n        #     for i in range(10**k, 10**(k+1)):                            # odd length\\n        #         i_str = str(i)\\n        #         if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n        #         cur = i_str + i_str[-2::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n                \\n        #     for i in range(10**k, 10**(k+1)):                            # even length\\n        #         i_str = str(i)\\n        #         if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n        #         cur = i_str + i_str[::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n        # return -1\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #3 TLE\\n        # if 8 <= n <= 11: return 11\\n        # for x in range(10 ** (len(str(n))// 2), 10**5):\\n        #     y = int(str(x) + str(x)[-2::-1])\\n        #     if y >= n and is_prime(y): return y\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #4 it gives TLE\\n        # res=n\\n        # c=1\\n        # while c:\\n        #     if str(res)==str(res)[::-1] and is_prime(res)==True:\\n        #         c=0\\n        #     else:\\n        #         res+=1\\n        # return res\\n            \\n\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056719,
                "title": "intuitive-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n == 0 || n == 1) return 2;\\n        return helper(n); \\n    }\\n\\n    int helper(int n) {\\n        if (10_000_000 < n && n < 100_000_000) return helper(100_000_000);\\n        if(isPrime(n) && isPal(n)) return n;\\n        if(n % 2 == 0) {\\n            return helper(n+1);\\n        }else{\\n            return helper(n+2);\\n        }\\n    }\\n\\n    boolean isPrime(int n) {\\n\\n        for(int i = 2; i<=(int) Math.sqrt(n); i++) {\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n    boolean isPal(int n) {\\n        int rev = 0;\\n        int temp = n;\\n        while(n != 0) {\\n            int r = n%10;\\n            rev = rev*10+r;\\n            n = n/10;\\n        }\\n        return rev == temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n == 0 || n == 1) return 2;\\n        return helper(n); \\n    }\\n\\n    int helper(int n) {\\n        if (10_000_000 < n && n < 100_000_000) return helper(100_000_000);\\n        if(isPrime(n) && isPal(n)) return n;\\n        if(n % 2 == 0) {\\n            return helper(n+1);\\n        }else{\\n            return helper(n+2);\\n        }\\n    }\\n\\n    boolean isPrime(int n) {\\n\\n        for(int i = 2; i<=(int) Math.sqrt(n); i++) {\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n    boolean isPal(int n) {\\n        int rev = 0;\\n        int temp = n;\\n        while(n != 0) {\\n            int r = n%10;\\n            rev = rev*10+r;\\n            n = n/10;\\n        }\\n        return rev == temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783372,
                "title": "c-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416992,
                "title": "python-very-fast-solution",
                "content": "```\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283352,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution\\n{\\n    public int primePalindrome(int N)\\n    {\\n        int result = 0 ;\\n        if( N == 2 || N == 0 || N == 1 )\\n        {\\n            return 2 ;\\n        }\\n        if( N % 2 == 0 )\\n        {\\n            N++ ;\\n        }            \\n        while( true )\\n        {\\n            StringBuilder sb = new StringBuilder(Integer.toString(N));            \\n            if( N == Integer.parseInt( new String( sb.reverse()) ) && isPrime(N) )\\n            {\\n                return N ;\\n            }            \\n            N = N + 2 ;\\n            if( N > 11 && N < 100 )\\n            {\\n                N = 101 ;\\n            }\\n            if( N > 999 && N < 10000 )\\n            {\\n                N = 10001 ;\\n            }\\n            if( N > 99999 && N < 1000000 )\\n            {\\n                N = 1000001 ;\\n            }\\n            if( N > 9999999 && N < 100000000 )\\n            {\\n                N = 100000001 ;\\n            }\\n        }\\n    } \\n    boolean isPrime( int N )\\n    {\\n        int i ;                    \\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }                    \\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int primePalindrome(int N)\\n    {\\n        int result = 0 ;\\n        if( N == 2 || N == 0 || N == 1 )\\n        {\\n            return 2 ;\\n        }\\n        if( N % 2 == 0 )\\n        {\\n            N++ ;\\n        }            \\n        while( true )\\n        {\\n            StringBuilder sb = new StringBuilder(Integer.toString(N));            \\n            if( N == Integer.parseInt( new String( sb.reverse()) ) && isPrime(N) )\\n            {\\n                return N ;\\n            }            \\n            N = N + 2 ;\\n            if( N > 11 && N < 100 )\\n            {\\n                N = 101 ;\\n            }\\n            if( N > 999 && N < 10000 )\\n            {\\n                N = 10001 ;\\n            }\\n            if( N > 99999 && N < 1000000 )\\n            {\\n                N = 1000001 ;\\n            }\\n            if( N > 9999999 && N < 100000000 )\\n            {\\n                N = 100000001 ;\\n            }\\n        }\\n    } \\n    boolean isPrime( int N )\\n    {\\n        int i ;                    \\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }                    \\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216347,
                "title": "c-8-12-ms-with-5-8-5-9-mb",
                "content": "class Solution {\\npublic:\\n    int primePalindrome(int n)\\n    {        \\n        \\n\\t\\t// Used for iterating to see if it\\'s a prime number\\n        int x;\\n        // Used to store the current number, mirrored..as to check if it\\'s palindrome\\n        int mirroredNmb;\\n        // Temporary variable used for different calculations\\n        int temp;\\n        \\n        // Just in case, set to 2\\n        if(n <= 1)\\n        {\\n            n = 2;\\n        }\\n\\n        // Search until the prime palindrome is returned\\n        while(true)\\n        {         \\n            // Reset the mirrored nmb\\n            mirroredNmb = 0;\\n            // Set the current number which is to be checked if it\\'s palindrome\\n            temp = n;\\n\\n            // While there are digits to read...store them in mirroredNmb\\n            do\\n            {\\n                mirroredNmb = mirroredNmb * 10 + temp % 10;\\n                temp /= 10;\\n            }while(temp > 0);\\n            \\n            // Check if it\\'s a palindrome\\n            if(mirroredNmb == n)\\n            {\\n                // Store the limit to which the number the palindrome number can be checked if prime\\n                temp = sqrt(n);\\n                for(x=2;x<=temp;++x)\\n                {\\n                    // In case this is true then this number is not prime\\n                    if((n % x) == 0)\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                // If the iterator has gone above the limit then this is a prime\\n                if(x > temp)\\n                {\\n                    return n;    \\n                }                    \\n            }\\n            \\n            ++n;\\n            \\n            // After some time in which I couldn\\'t get it why the solution is not accepted...I\\'ve read their \\n\\t\\t\\t// solution and saw that in this interval there are no prime palindromes....\\n            // Therefore, set it to the next palindrome prime number :) All this I see it more like a hack...but whatevs\\n            if(n >= 10000000 && n <= 100000000)\\n            {\\n                n = 100030001;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int primePalindrome(int n)\\n    {        \\n        \\n\\t\\t// Used for iterating to see if it\\'s a prime number\\n        int x;\\n        // Used to store the current number, mirrored..as to check if it\\'s palindrome\\n        int mirroredNmb;\\n        // Temporary variable used for different calculations\\n        int temp;\\n        \\n        // Just in case, set to 2\\n        if(n <= 1)\\n        {\\n            n = 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1178225,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int x)\\n    {\\n        if (x <= 2)\\n        {\\n            return (x == 2);\\n        }\\n        int upper_limit = sqrt(x);\\n        for (int i = 2; i <= upper_limit; ++i)\\n        {\\n            if (x % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11)\\n        {\\n            return 11;\\n        }\\n        int res;\\n        for (int i = 1; i < 1e5; ++i)\\n        {\\n            std::string s = to_string(i);\\n            std::string t(s.rbegin(), s.rend());\\n            s += t.substr(1);\\n            int tmp_num = stoi(s);\\n            if (tmp_num >= N && isPrime(tmp_num))\\n            {\\n                res = tmp_num;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n1. \\u8D28\\u6570\\u7684\\u68C0\\u67E5\\uFF0C\\u53EA\\u68C0\\u67E5\\u4ECE2\\u5230sqrt(x)\\uFF0C\\u4F1A\\u4E0D\\u4F1A\\u6709\\u53EF\\u4EE5\\u6574\\u9664x\\u7684\\u6570\\u5B58\\u5728\\uFF0C\\u56E0\\u4E3A\\u540E\\u4E00\\u534A\\u80AF\\u5B9A\\u4E0D\\u4F1A\\uFF1B\\n2. \\u53EA\\u68C0\\u67E5\\u957F\\u5EA6\\u662F\\u5947\\u6570\\u7684\\u56DE\\u6587\\u6570\\uFF0C\\u56E0\\u4E3A\\u957F\\u5EA6\\u662F\\u5076\\u6570\\u7684\\u56DE\\u6587\\u6570\\u4E00\\u5B9A\\u4F1A\\u88AB11\\u6574\\u9664\\uFF1B\\n3. \\u7279\\u6B8A\\u60C5\\u51B5\\uFF1A\\u5728[8, 11]\\u8303\\u56F4\\u5185\\uFF0C\\u8FD4\\u56DE11\\uFF1B\\n4. \\u91C7\\u7528\\u5148\\u62FC\\u63A5\\u51FA\\u56DE\\u6587\\u6570\\uFF0C\\u518D\\u5224\\u65AD\\u662F\\u5426\\u6EE1\\u8DB3\\u8981\\u6C42\\uFF0C\\u4E0D\\u5C0F\\u4E8EN\\u4E14\\u662F\\u8D28\\u6570\\u3002",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int x)\\n    {\\n        if (x <= 2)\\n        {\\n            return (x == 2);\\n        }\\n        int upper_limit = sqrt(x);\\n        for (int i = 2; i <= upper_limit; ++i)\\n        {\\n            if (x % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11)\\n        {\\n            return 11;\\n        }\\n        int res;\\n        for (int i = 1; i < 1e5; ++i)\\n        {\\n            std::string s = to_string(i);\\n            std::string t(s.rbegin(), s.rend());\\n            s += t.substr(1);\\n            int tmp_num = stoi(s);\\n            if (tmp_num >= N && isPrime(tmp_num))\\n            {\\n                res = tmp_num;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845960,
                "title": "prime-palindrome",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def getPalindromes(n: int) -> int:\\n            length = n // 2\\n            for i in range(10**(length - 1), 10**length):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n\\n        def isPrime(num: int) -> bool:\\n            return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\\n\\n        if N <= 2:\\n            return 2\\n        if N == 3:\\n            return 3\\n        if N <= 5:\\n            return 5\\n        if N <= 7:\\n            return 7\\n        if N <= 11:\\n            return 11\\n\\n        n = len(str(N))\\n\\n        while True:\\n            for num in getPalindromes(n):\\n                if num >= N and isPrime(num):\\n                    return num\\n            n += 1\\n            \\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def getPalindromes(n: int) -> int:\\n            length = n // 2\\n            for i in range(10**(length - 1), 10**length):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n\\n        def isPrime(num: int) -> bool:\\n            return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\\n\\n        if N <= 2:\\n            return 2\\n        if N == 3:\\n            return 3\\n        if N <= 5:\\n            return 5\\n        if N <= 7:\\n            return 7\\n        if N <= 11:\\n            return 11\\n\\n        n = len(str(N))\\n\\n        while True:\\n            for num in getPalindromes(n):\\n                if num >= N and isPrime(num):\\n                    return num\\n            n += 1\\n            \\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 707393,
                "title": "python3-check-next-palindrome-prime-palindrome",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(N):\\n            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))\\n        \\n        # N must be a palindrome with odd number of digits.\\n        # The return value will have odd number of digits too.\\n        def nextPalindrome(N):\\n            if N in [999, 99999, 9999999]:\\n                return (N + 1) * 10 + 1\\n            n = str(N // 10 ** (len(str(N))//2) + 1)\\n            return int(n + n[-2::-1])\\n        \\n        if N <= 11: \\n            while not isPrime(N):\\n                N += 1\\n            return N\\n        \\n        if (digits := len(str(N))) % 2 == 0:\\n            N = 10 ** digits + 1\\n        else:\\n            n = str(N // 10 ** (len(str(N))//2))\\n            if (p := int(n + n[-2::-1])) >= N:\\n                N = p\\n            else:\\n                N = nextPalindrome(p)\\n                \\n        while not isPrime(N):\\n            N = nextPalindrome(N)\\n        return N\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(N):\\n            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))\\n        \\n        # N must be a palindrome with odd number of digits.\\n        # The return value will have odd number of digits too.\\n        def nextPalindrome(N):\\n            if N in [999, 99999, 9999999]:\\n                return (N + 1) * 10 + 1\\n            n = str(N // 10 ** (len(str(N))//2) + 1)\\n            return int(n + n[-2::-1])\\n        \\n        if N <= 11: \\n            while not isPrime(N):\\n                N += 1\\n            return N\\n        \\n        if (digits := len(str(N))) % 2 == 0:\\n            N = 10 ** digits + 1\\n        else:\\n            n = str(N // 10 ** (len(str(N))//2))\\n            if (p := int(n + n[-2::-1])) >= N:\\n                N = p\\n            else:\\n                N = nextPalindrome(p)\\n                \\n        while not isPrime(N):\\n            N = nextPalindrome(N)\\n        return N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706379,
                "title": "866-prime-palindrome-c-innovative-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n        return 0;\\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n        return 0;\\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662232,
                "title": "python3-cheating-solution-there-s-only-782-prime-palindromes-less-than-100030002",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        nums =[2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001]\\n        return nums[bisect_left(nums, N)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        nums =[2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001]\\n        return nums[bisect_left(nums, N)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464397,
                "title": "ultra-fast-solution-beat-99-no-string-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    char notprime[15000]={0};\\n    vector<int> primes;\\n    // pow10(i) == 10^i\\n    int pow10[9];\\n    \\n    Solution(){\\n        primes.push_back(2);\\n        for (int i=3;i < 15000;i+=2){\\n            if (notprime[i]) continue;\\n            primes.push_back(i);\\n            for (int j=i+i; j < 15000; j+=i)\\n                notprime[j] = 1;\\n        }\\n        \\n        for (int i=0, d=1;i<9;i++, d*=10){\\n            pow10[i]=d;\\n        }\\n    }\\n    \\n    int revdigits(int a, int ndigits){\\n        int b = 0;\\n        while (ndigits--){\\n            b = b*10 + a%10;\\n            a /= 10;\\n        }\\n        return b;\\n    }\\n    \\n    bool isprime(int a){\\n        int limit = ceil(sqrt(a));\\n        for (int i=0 ; i < primes.size() && primes[i] <=limit ;i++)\\n            if (a%primes[i] == 0)\\n                return false;\\n        return true;\\n    }\\n    \\n    inline int numdigits(int a){\\n        return floor(1+ log10(a));\\n    }\\n    \\n    // ndigits: number of digits in \"a\"\\n    inline int makepalin(int a,int ndigits, bool even){\\n         if (even){\\n             return a * pow10[ndigits] + revdigits(a,ndigits);\\n         }\\n         return a * pow10[ndigits-1] + revdigits(a/10,ndigits-1);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        \\n        for (int nd = numdigits(N); ; nd ++){\\n            int first = pow10[(nd-1)/2];\\n            int last = pow10[(nd-1)/2+1] ;\\n            for (int i= nd==numdigits(N)? N / pow10[nd/2] : first; i < last;i++){\\n                // check whether start with even digit, if so, \\n                // it will also end with even digit, hence skip to the next batch \\n                if ((i/first) % 2 == 0) {\\n                    i += first-1;\\n                    continue;\\n                }\\n                // make palindrome of length \"nd\"\\n                int palin=makepalin(i, (nd+1)/2, nd%2==0);\\n                if (palin >= N && isprime(palin)) return palin;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char notprime[15000]={0};\\n    vector<int> primes;\\n    // pow10(i) == 10^i\\n    int pow10[9];\\n    \\n    Solution(){\\n        primes.push_back(2);\\n        for (int i=3;i < 15000;i+=2){\\n            if (notprime[i]) continue;\\n            primes.push_back(i);\\n            for (int j=i+i; j < 15000; j+=i)\\n                notprime[j] = 1;\\n        }\\n        \\n        for (int i=0, d=1;i<9;i++, d*=10){\\n            pow10[i]=d;\\n        }\\n    }\\n    \\n    int revdigits(int a, int ndigits){\\n        int b = 0;\\n        while (ndigits--){\\n            b = b*10 + a%10;\\n            a /= 10;\\n        }\\n        return b;\\n    }\\n    \\n    bool isprime(int a){\\n        int limit = ceil(sqrt(a));\\n        for (int i=0 ; i < primes.size() && primes[i] <=limit ;i++)\\n            if (a%primes[i] == 0)\\n                return false;\\n        return true;\\n    }\\n    \\n    inline int numdigits(int a){\\n        return floor(1+ log10(a));\\n    }\\n    \\n    // ndigits: number of digits in \"a\"\\n    inline int makepalin(int a,int ndigits, bool even){\\n         if (even){\\n             return a * pow10[ndigits] + revdigits(a,ndigits);\\n         }\\n         return a * pow10[ndigits-1] + revdigits(a/10,ndigits-1);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        \\n        for (int nd = numdigits(N); ; nd ++){\\n            int first = pow10[(nd-1)/2];\\n            int last = pow10[(nd-1)/2+1] ;\\n            for (int i= nd==numdigits(N)? N / pow10[nd/2] : first; i < last;i++){\\n                // check whether start with even digit, if so, \\n                // it will also end with even digit, hence skip to the next batch \\n                if ((i/first) % 2 == 0) {\\n                    i += first-1;\\n                    continue;\\n                }\\n                // make palindrome of length \"nd\"\\n                int palin=makepalin(i, (nd+1)/2, nd%2==0);\\n                if (palin >= N && isprime(palin)) return palin;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421006,
                "title": "java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int primePalindrome(int N) {\\n\\t\\t\\tif (N == 1) return 2;\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tif (checkPalindrome(N) && checkPrime(N)) {\\n\\t\\t\\t\\t\\treturn N;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tN++;\\n\\t\\t\\t\\tif (10_000_000 < N && N < 100_000_000)\\n\\t\\t\\t\\t\\tN = 100_000_000;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic boolean checkPalindrome(int N) {\\n\\t\\t\\tchar[] arr = Integer.toString(N).toCharArray();\\n\\t\\t\\tint len = arr.length;\\n\\t\\t\\tint i;\\n\\t\\t\\tint j;\\n\\t\\t\\tint mid = len / 2;\\n\\t\\t\\tif (len % 2 == 0) {\\n\\t\\t\\t\\ti = mid - 1;\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ti = mid - 1;\\n\\t\\t\\t\\tj = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\twhile (i < j && i >= 0) {\\n\\t\\t\\t\\tif (arr[i--] != arr[j++]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// public int reverse(int x) {\\n\\t\\t//     int rev= 0;\\n\\t\\t//     while( x > 0){\\n\\t\\t//         rev= rev * 10 + x % 10;\\n\\t\\t//         x= x / 10;\\n\\t\\t//     }\\n\\t\\t//     return rev;\\n\\t\\t// }\\n\\n\\t\\tpublic boolean checkPrime(int N) {\\n\\t\\t\\tboolean flag = true;\\n\\t\\t\\tif (N < 2) return false;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int i = 2; i <= (int)Math.sqrt(N); i++) {\\n\\t\\t\\t\\t\\tif (N % i == 0) {\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn flag;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int primePalindrome(int N) {\\n\\t\\t\\tif (N == 1) return 2;\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tif (checkPalindrome(N) && checkPrime(N)) {\\n\\t\\t\\t\\t\\treturn N;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 407131,
                "title": "python-faster-than-99-22-and-memory-usage-less-than-100-00",
                "content": "```\\nfrom math import trunc\\nclass Solution:\\n    def primePalindrome(self, k: int) -> int:\\n\\t\"\"\"\\n\\tFind the closest root from the number and start from there rather than start from the first for all numbers\\n\\t\"\"\"\\n        if k < 12:\\n            for i in range(1, 12):\\n                if self.__is_prime(i) and i >= k:\\n                    return i\\n        else:\\n            string_k = str(k)\\n            string_length = len(string_k)\\n            if string_length % 2 == 0:\\n                starting_root = str(10**(string_length-trunc(string_length/2)))\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(starting_root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n            else:\\n                starting_root = string_k[:string_length-trunc(string_length/2)]\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n\\n\\n    def __is_prime(self, num):\\n        if num == 1:\\n            return False\\n        for i in range(2, int(num**0.5)+1):\\n            if num % i == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import trunc\\nclass Solution:\\n    def primePalindrome(self, k: int) -> int:\\n\\t\"\"\"\\n\\tFind the closest root from the number and start from there rather than start from the first for all numbers\\n\\t\"\"\"\\n        if k < 12:\\n            for i in range(1, 12):\\n                if self.__is_prime(i) and i >= k:\\n                    return i\\n        else:\\n            string_k = str(k)\\n            string_length = len(string_k)\\n            if string_length % 2 == 0:\\n                starting_root = str(10**(string_length-trunc(string_length/2)))\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(starting_root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n            else:\\n                starting_root = string_k[:string_length-trunc(string_length/2)]\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n\\n\\n    def __is_prime(self, num):\\n        if num == 1:\\n            return False\\n        for i in range(2, int(num**0.5)+1):\\n            if num % i == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395539,
                "title": "o-lgn-solution-joke",
                "content": "```\\nclass Solution {\\n    static boolean[] prime;\\n    public int primePalindrome(int n) {\\n       String str = \"2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001,100050001,100060001,100111001,100131001,100161001,100404001,100656001,100707001,100767001,100888001,100999001,101030101,101060101,101141101,101171101,101282101,101292101,101343101,101373101,101414101,101424101,101474101,101595101,101616101,101717101,101777101,101838101,101898101,101919101,101949101,101999101,102040201,102070201,102202201,102232201,102272201,102343201,102383201,102454201,102484201,102515201,102676201,102686201,102707201,102808201,102838201,103000301,103060301,103161301,103212301,103282301,103303301,103323301,103333301,103363301,103464301,103515301,103575301,103696301,103777301,103818301,103828301,103909301,103939301,104000401,104030401,104040401,104111401,104222401,104282401,104333401,104585401,104616401,104787401,104838401,104919401,104949401,105121501,105191501,105202501,105262501,105272501,105313501,105323501,105343501,105575501,105616501,105656501,105757501,105818501,105868501,105929501,106060601,106111601,106131601,106191601,106222601,106272601,106353601,106444601,106464601,106545601,106555601,106717601,106909601,106929601,107000701,107070701,107121701,107232701,107393701,107414701,107424701,107595701,107636701,107646701,107747701,107757701,107828701,107858701,107868701,107888701,107939701,107949701,108070801,108101801,108121801,108151801,108212801,108323801,108373801,108383801,108434801,108464801,108484801,108494801,108505801,108565801,108686801,108707801,108767801,108838801,108919801,108959801,109000901,109101901,109111901,109161901,109333901,109404901,109434901,109444901,109474901,109575901,109656901,109747901,109777901,109797901,109818901,109909901,109929901,110111011,110232011,110252011,110343011,110424011,110505011,110565011,110676011,110747011,110757011,110909011,110949011,110999011,111010111,111020111,111050111,111070111,111181111,111191111,111262111,111272111,111454111,111484111,111515111,111616111,111686111,111757111,111848111,112030211,112060211,112111211,112161211,112171211,112212211,112434211,112494211,112545211,112636211,112878211,112959211,112969211,112989211,113030311,113090311,113111311,113262311,113282311,113474311,113535311,113565311,113616311,113636311,113888311,113939311,114040411,114191411,114232411,114353411,114383411,114484411,114494411,114535411,114727411,114808411,114818411,114848411,114878411,114898411,115000511,115020511,115060511,115111511,115141511,115191511,115212511,115222511,115404511,115464511,115545511,115636511,115737511,115767511,115797511,115828511,115959511,116000611,116010611,116040611,116424611,116505611,116646611,116696611,116757611,116777611,116828611,116868611,116919611,117070711,117101711,117262711,117272711,117323711,117484711,117505711,117515711,117616711,117686711,117757711,117767711,117797711,117818711,117959711,118252811,118272811,118414811,118464811,118525811,118626811,118686811,118696811,118717811,118818811,118848811,118909811,118959811,119010911,119171911,119202911,119343911,119363911,119454911,119585911,119595911,119646911,119676911,119696911,119717911,119787911,119868911,119888911,119969911,120191021,120242021,120434021,120454021,120494021,120535021,120565021,120646021,120808021,120868021,120989021,121080121,121111121,121131121,121161121,121272121,121282121,121393121,121414121,121555121,121747121,121818121,121878121,121939121,121989121,122040221,122232221,122262221,122292221,122333221,122363221,122373221,122393221,122444221,122484221,122535221,122696221,122787221,122858221,122919221,123161321,123292321,123424321,123484321,123494321,123575321,123767321,123838321,123989321,124000421,124080421,124101421,124131421,124252421,124323421,124333421,124434421,124515421,124525421,124626421,124656421,124717421,124737421,124959421,124989421,125000521,125010521,125232521,125252521,125292521,125343521,125474521,125505521,125565521,125606521,125616521,125757521,125838521,125939521,125979521,125999521,126101621,126161621,126181621,126202621,126212621,126323621,126424621,126484621,126535621,126595621,126616621,126676621,126686621,126727621,126737621,126757621,126878621,127060721,127090721,127131721,127212721,127383721,127494721,127545721,127636721,127656721,127686721,127717721,127747721,127828721,127909721,127929721,128070821,128090821,128121821,128181821,128202821,128252821,128262821,128282821,128444821,128474821,128525821,128535821,128595821,128646821,128747821,128787821,128868821,128919821,128939821,129080921,129202921,129292921,129323921,129373921,129484921,129494921,129535921,129737921,129919921,129979921,130020031,130030031,130060031,130141031,130171031,130222031,130333031,130444031,130464031,130545031,130555031,130585031,130606031,130636031,130717031,130767031,130818031,130828031,130858031,130969031,131030131,131111131,131121131,131222131,131252131,131333131,131555131,131565131,131585131,131646131,131676131,131828131,132010231,132191231,132464231,132535231,132595231,132646231,132676231,132757231,133020331,133060331,133111331,133161331,133252331,133474331,133494331,133575331,133686331,133767331,133818331,133909331,134090431,134181431,134232431,134424431,134505431,134525431,134535431,134616431,134757431,134808431,134858431,134888431,134909431,134919431,134979431,135010531,135040531,135101531,135121531,135161531,135262531,135434531,135494531,135515531,135626531,135646531,135707531,135838531,135868531,135878531,135929531,135959531,135979531,136090631,136171631,136222631,136252631,136303631,136363631,136474631,136545631,136737631,136797631,136818631,136909631,136969631,137030731,137040731,137060731,137090731,137151731,137171731,137232731,137282731,137333731,137363731,137424731,137474731,137606731,137636731,137696731,137757731,137808731,137838731,137939731,137999731,138040831,138131831,138242831,138292831,138313831,138383831,138454831,138575831,138616831,138646831,138757831,138898831,138959831,138989831,139131931,139161931,139222931,139252931,139282931,139383931,139474931,139515931,139606931,139626931,139717931,139848931,139959931,139969931,139999931,140000041,140030041,140151041,140303041,140505041,140565041,140606041,140777041,140787041,140828041,140868041,140898041,141020141,141070141,141131141,141151141,141242141,141262141,141313141,141343141,141383141,141484141,141494141,141575141,141595141,141616141,141767141,141787141,141848141,142000241,142030241,142080241,142252241,142272241,142353241,142363241,142464241,142545241,142555241,142686241,142707241,142797241,142858241,142888241,143090341,143181341,143262341,143303341,143454341,143474341,143585341,143636341,143787341,143828341,143919341,143969341,144010441,144020441,144202441,144212441,144313441,144353441,144404441,144434441,144484441,144505441,144707441,144757441,144808441,144818441,144848441,144878441,144898441,144979441,144989441,145020541,145030541,145090541,145353541,145363541,145393541,145464541,145494541,145575541,145666541,145767541,146030641,146040641,146181641,146222641,146252641,146313641,146363641,146505641,146555641,146565641,146676641,146858641,146909641,147191741,147232741,147242741,147313741,147343741,147373741,147434741,147515741,147565741,147616741,147686741,147707741,147757741,147838741,147929741,148020841,148060841,148080841,148414841,148444841,148525841,148545841,148585841,148666841,148686841,148707841,148818841,148858841,148888841,148969841,149000941,149333941,149343941,149484941,149535941,149555941,149616941,149646941,149696941,149858941,149888941,149909941,149919941,149939941,150070051,150151051,150181051,150202051,150272051,150434051,150494051,150505051,150626051,150686051,150727051,150808051,150818051,150979051,151080151,151161151,151212151,151222151,151282151,151353151,151545151,151585151,151656151,151737151,151777151,151858151,151878151,151888151,151959151,151969151,151999151,152090251,152111251,152171251,152181251,152252251,152363251,152393251,152454251,152505251,152565251,152616251,152646251,152666251,152696251,152888251,152939251,153212351,153272351,153292351,153313351,153323351,153404351,153424351,153454351,153484351,153494351,153626351,153808351,153818351,153838351,153979351,154030451,154191451,154252451,154272451,154303451,154323451,154383451,154393451,154474451,154494451,154555451,154575451,154989451,155060551,155141551,155171551,155292551,155313551,155333551,155373551,155424551,155474551,155535551,155646551,155666551,155676551,155808551,155828551,155868551,156151651,156262651,156343651,156424651,156434651,156494651,156545651,156595651,156656651,156707651,156727651,156757651,156848651,156878651,156949651,157090751,157101751,157161751,157252751,157393751,157444751,157555751,157717751,157878751,157888751,157939751,157959751,157989751,158090851,158111851,158222851,158252851,158363851,158474851,158595851,158676851,158696851,158747851,158808851,158858851,158898851,158909851,159020951,159040951,159050951,159121951,159181951,159191951,159202951,159232951,159262951,159292951,159323951,159404951,159464951,159565951,159595951,159646951,159757951,159808951,159919951,159929951,159959951,160020061,160050061,160080061,160101061,160131061,160141061,160161061,160171061,160393061,160545061,160696061,160707061,160717061,160797061,160878061,161171161,161282161,161313161,161363161,161474161,161484161,161535161,161585161,161636161,161787161,161838161,161969161,162040261,162232261,162404261,162464261,162484261,162565261,162686261,162707261,162757261,162898261,162919261,162949261,162959261,162979261,162989261,163101361,163333361,163434361,163464361,163474361,163494361,163515361,163555361,163606361,163686361,163696361,163878361,163959361,164000461,164070461,164151461,164292461,164333461,164454461,164484461,164585461,164616461,164696461,164717461,164727461,164838461,165101561,165161561,165191561,165212561,165343561,165515561,165535561,165808561,165878561,165898561,165919561,165949561,166000661,166080661,166171661,166191661,166404661,166545661,166555661,166636661,166686661,166818661,166828661,166878661,166888661,166929661,167000761,167111761,167262761,167393761,167454761,167474761,167484761,167636761,167646761,167787761,167888761,167898761,167979761,168151861,168191861,168232861,168404861,168505861,168515861,168565861,168818861,168898861,168929861,168949861,169060961,169131961,169141961,169282961,169333961,169383961,169464961,169555961,169606961,169656961,169666961,169686961,169777961,169797961,169858961,169999961,170040071,170060071,170232071,170303071,170333071,170414071,170424071,170484071,170606071,170616071,170646071,170828071,170838071,170909071,170979071,171080171,171262171,171292171,171343171,171565171,171575171,171767171,171919171,171959171,172060271,172090271,172161271,172353271,172363271,172393271,172474271,172585271,172656271,172747271,172767271,172797271,172878271,172909271,172959271,173000371,173030371,173090371,173252371,173373371,173454371,173525371,173585371,173696371,173757371,173777371,173828371,173868371,173888371,173898371,173919371,174080471,174121471,174131471,174181471,174313471,174343471,174595471,174646471,174676471,174919471,174949471,174979471,174989471,175000571,175090571,175101571,175111571,175353571,175444571,175555571,175626571,175747571,175777571,175848571,175909571,176090671,176111671,176141671,176181671,176232671,176313671,176333671,176373671,176393671,176414671,176585671,176636671,176646671,176666671,176696671,176757671,176787671,176888671,176898671,176939671,177121771,177161771,177202771,177242771,177323771,177565771,177616771,177707771,177757771,177868771,178101871,178131871,178141871,178161871,178353871,178414871,178515871,178525871,178656871,178717871,178747871,178878871,178969871,178989871,178999871,179010971,179060971,179222971,179232971,179262971,179414971,179454971,179484971,179717971,179777971,179808971,179858971,179868971,179909971,179969971,179999971,180070081,180101081,180161081,180292081,180515081,180535081,180545081,180565081,180616081,180757081,180959081,181111181,181515181,181545181,181666181,181737181,181797181,181888181,182010281,182202281,182373281,182585281,182616281,182636281,182777281,182858281,182949281,183232381,183626381,183656381,183737381,183898381,183979381,183989381,184030481,184212481,184222481,184303481,184393481,184414481,184545481,184585481,184606481,184636481,184747481,184818481,184878481,185232581,185373581,185393581,185525581,185555581,185595581,185676581,185757581,185838581,185858581,185868581,185999581,186010681,186040681,186050681,186070681,186101681,186131681,186151681,186161681,186424681,186484681,186505681,186565681,186656681,186676681,186787681,186898681,187090781,187101781,187111781,187161781,187272781,187404781,187434781,187444781,187525781,187767781,187909781,187939781,187999781,188010881,188060881,188141881,188151881,188303881,188373881,188414881,188454881,188505881,188525881,188535881,188616881,188636881,188646881,188727881,188777881,188868881,188888881,188898881,188979881,189080981,189131981,189262981,189292981,189464981,189535981,189595981,189727981,189787981,189838981,189898981,189929981,190000091,190020091,190080091,190101091,190252091,190404091,190434091,190464091,190494091,190656091,190696091,190717091,190747091,190777091,190858091,190909091,191090191,191171191,191232191,191292191,191313191,191565191,191595191,191727191,191757191,191838191,191868191,191939191,191969191,192101291,192191291,192202291,192242291,192313291,192404291,192454291,192484291,192767291,192797291,192898291,193000391,193030391,193191391,193212391,193282391,193303391,193383391,193414391,193464391,193555391,193686391,193858391,193888391,194000491,194070491,194121491,194222491,194232491,194292491,194303491,194393491,194505491,194595491,194606491,194787491,194939491,194999491,195010591,195040591,195070591,195151591,195202591,195242591,195353591,195505591,195545591,195707591,195767591,195868591,195878591,195949591,195979591,196000691,196090691,196323691,196333691,196363691,196696691,196797691,196828691,196878691,197030791,197060791,197070791,197090791,197111791,197121791,197202791,197292791,197343791,197454791,197525791,197606791,197616791,197868791,197898791,197919791,198040891,198070891,198080891,198131891,198292891,198343891,198353891,198383891,198454891,198565891,198656891,198707891,198787891,198878891,198919891,199030991,199080991,199141991,199171991,199212991,199242991,199323991,199353991,199363991,199393991,199494991,199515991,199545991,199656991,199767991,199909991,199999991\";\\n\\t\\tString[] tr = str.split(\",\");\\n        int[] a = new int[tr.length];\\n        for(int i=0;i<a.length;i++) a[i] = Integer.parseInt(tr[i]);\\n        \\n        //find the first\\n        int lo=0;\\n        int hi = a.length;\\n        while(lo < hi){\\n            int mid = lo+hi>>1;\\n            if(a[mid] < n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return a[lo];\\n        \\n    }\\n    \\n    private boolean isPrime(int n){\\n        if( n <= 1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static boolean[] prime;\\n    public int primePalindrome(int n) {\\n       String str = \"2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001,100050001,100060001,100111001,100131001,100161001,100404001,100656001,100707001,100767001,100888001,100999001,101030101,101060101,101141101,101171101,101282101,101292101,101343101,101373101,101414101,101424101,101474101,101595101,101616101,101717101,101777101,101838101,101898101,101919101,101949101,101999101,102040201,102070201,102202201,102232201,102272201,102343201,102383201,102454201,102484201,102515201,102676201,102686201,102707201,102808201,102838201,103000301,103060301,103161301,103212301,103282301,103303301,103323301,103333301,103363301,103464301,103515301,103575301,103696301,103777301,103818301,103828301,103909301,103939301,104000401,104030401,104040401,104111401,104222401,104282401,104333401,104585401,104616401,104787401,104838401,104919401,104949401,105121501,105191501,105202501,105262501,105272501,105313501,105323501,105343501,105575501,105616501,105656501,105757501,105818501,105868501,105929501,106060601,106111601,106131601,106191601,106222601,106272601,106353601,106444601,106464601,106545601,106555601,106717601,106909601,106929601,107000701,107070701,107121701,107232701,107393701,107414701,107424701,107595701,107636701,107646701,107747701,107757701,107828701,107858701,107868701,107888701,107939701,107949701,108070801,108101801,108121801,108151801,108212801,108323801,108373801,108383801,108434801,108464801,108484801,108494801,108505801,108565801,108686801,108707801,108767801,108838801,108919801,108959801,109000901,109101901,109111901,109161901,109333901,109404901,109434901,109444901,109474901,109575901,109656901,109747901,109777901,109797901,109818901,109909901,109929901,110111011,110232011,110252011,110343011,110424011,110505011,110565011,110676011,110747011,110757011,110909011,110949011,110999011,111010111,111020111,111050111,111070111,111181111,111191111,111262111,111272111,111454111,111484111,111515111,111616111,111686111,111757111,111848111,112030211,112060211,112111211,112161211,112171211,112212211,112434211,112494211,112545211,112636211,112878211,112959211,112969211,112989211,113030311,113090311,113111311,113262311,113282311,113474311,113535311,113565311,113616311,113636311,113888311,113939311,114040411,114191411,114232411,114353411,114383411,114484411,114494411,114535411,114727411,114808411,114818411,114848411,114878411,114898411,115000511,115020511,115060511,115111511,115141511,115191511,115212511,115222511,115404511,115464511,115545511,115636511,115737511,115767511,115797511,115828511,115959511,116000611,116010611,116040611,116424611,116505611,116646611,116696611,116757611,116777611,116828611,116868611,116919611,117070711,117101711,117262711,117272711,117323711,117484711,117505711,117515711,117616711,117686711,117757711,117767711,117797711,117818711,117959711,118252811,118272811,118414811,118464811,118525811,118626811,118686811,118696811,118717811,118818811,118848811,118909811,118959811,119010911,119171911,119202911,119343911,119363911,119454911,119585911,119595911,119646911,119676911,119696911,119717911,119787911,119868911,119888911,119969911,120191021,120242021,120434021,120454021,120494021,120535021,120565021,120646021,120808021,120868021,120989021,121080121,121111121,121131121,121161121,121272121,121282121,121393121,121414121,121555121,121747121,121818121,121878121,121939121,121989121,122040221,122232221,122262221,122292221,122333221,122363221,122373221,122393221,122444221,122484221,122535221,122696221,122787221,122858221,122919221,123161321,123292321,123424321,123484321,123494321,123575321,123767321,123838321,123989321,124000421,124080421,124101421,124131421,124252421,124323421,124333421,124434421,124515421,124525421,124626421,124656421,124717421,124737421,124959421,124989421,125000521,125010521,125232521,125252521,125292521,125343521,125474521,125505521,125565521,125606521,125616521,125757521,125838521,125939521,125979521,125999521,126101621,126161621,126181621,126202621,126212621,126323621,126424621,126484621,126535621,126595621,126616621,126676621,126686621,126727621,126737621,126757621,126878621,127060721,127090721,127131721,127212721,127383721,127494721,127545721,127636721,127656721,127686721,127717721,127747721,127828721,127909721,127929721,128070821,128090821,128121821,128181821,128202821,128252821,128262821,128282821,128444821,128474821,128525821,128535821,128595821,128646821,128747821,128787821,128868821,128919821,128939821,129080921,129202921,129292921,129323921,129373921,129484921,129494921,129535921,129737921,129919921,129979921,130020031,130030031,130060031,130141031,130171031,130222031,130333031,130444031,130464031,130545031,130555031,130585031,130606031,130636031,130717031,130767031,130818031,130828031,130858031,130969031,131030131,131111131,131121131,131222131,131252131,131333131,131555131,131565131,131585131,131646131,131676131,131828131,132010231,132191231,132464231,132535231,132595231,132646231,132676231,132757231,133020331,133060331,133111331,133161331,133252331,133474331,133494331,133575331,133686331,133767331,133818331,133909331,134090431,134181431,134232431,134424431,134505431,134525431,134535431,134616431,134757431,134808431,134858431,134888431,134909431,134919431,134979431,135010531,135040531,135101531,135121531,135161531,135262531,135434531,135494531,135515531,135626531,135646531,135707531,135838531,135868531,135878531,135929531,135959531,135979531,136090631,136171631,136222631,136252631,136303631,136363631,136474631,136545631,136737631,136797631,136818631,136909631,136969631,137030731,137040731,137060731,137090731,137151731,137171731,137232731,137282731,137333731,137363731,137424731,137474731,137606731,137636731,137696731,137757731,137808731,137838731,137939731,137999731,138040831,138131831,138242831,138292831,138313831,138383831,138454831,138575831,138616831,138646831,138757831,138898831,138959831,138989831,139131931,139161931,139222931,139252931,139282931,139383931,139474931,139515931,139606931,139626931,139717931,139848931,139959931,139969931,139999931,140000041,140030041,140151041,140303041,140505041,140565041,140606041,140777041,140787041,140828041,140868041,140898041,141020141,141070141,141131141,141151141,141242141,141262141,141313141,141343141,141383141,141484141,141494141,141575141,141595141,141616141,141767141,141787141,141848141,142000241,142030241,142080241,142252241,142272241,142353241,142363241,142464241,142545241,142555241,142686241,142707241,142797241,142858241,142888241,143090341,143181341,143262341,143303341,143454341,143474341,143585341,143636341,143787341,143828341,143919341,143969341,144010441,144020441,144202441,144212441,144313441,144353441,144404441,144434441,144484441,144505441,144707441,144757441,144808441,144818441,144848441,144878441,144898441,144979441,144989441,145020541,145030541,145090541,145353541,145363541,145393541,145464541,145494541,145575541,145666541,145767541,146030641,146040641,146181641,146222641,146252641,146313641,146363641,146505641,146555641,146565641,146676641,146858641,146909641,147191741,147232741,147242741,147313741,147343741,147373741,147434741,147515741,147565741,147616741,147686741,147707741,147757741,147838741,147929741,148020841,148060841,148080841,148414841,148444841,148525841,148545841,148585841,148666841,148686841,148707841,148818841,148858841,148888841,148969841,149000941,149333941,149343941,149484941,149535941,149555941,149616941,149646941,149696941,149858941,149888941,149909941,149919941,149939941,150070051,150151051,150181051,150202051,150272051,150434051,150494051,150505051,150626051,150686051,150727051,150808051,150818051,150979051,151080151,151161151,151212151,151222151,151282151,151353151,151545151,151585151,151656151,151737151,151777151,151858151,151878151,151888151,151959151,151969151,151999151,152090251,152111251,152171251,152181251,152252251,152363251,152393251,152454251,152505251,152565251,152616251,152646251,152666251,152696251,152888251,152939251,153212351,153272351,153292351,153313351,153323351,153404351,153424351,153454351,153484351,153494351,153626351,153808351,153818351,153838351,153979351,154030451,154191451,154252451,154272451,154303451,154323451,154383451,154393451,154474451,154494451,154555451,154575451,154989451,155060551,155141551,155171551,155292551,155313551,155333551,155373551,155424551,155474551,155535551,155646551,155666551,155676551,155808551,155828551,155868551,156151651,156262651,156343651,156424651,156434651,156494651,156545651,156595651,156656651,156707651,156727651,156757651,156848651,156878651,156949651,157090751,157101751,157161751,157252751,157393751,157444751,157555751,157717751,157878751,157888751,157939751,157959751,157989751,158090851,158111851,158222851,158252851,158363851,158474851,158595851,158676851,158696851,158747851,158808851,158858851,158898851,158909851,159020951,159040951,159050951,159121951,159181951,159191951,159202951,159232951,159262951,159292951,159323951,159404951,159464951,159565951,159595951,159646951,159757951,159808951,159919951,159929951,159959951,160020061,160050061,160080061,160101061,160131061,160141061,160161061,160171061,160393061,160545061,160696061,160707061,160717061,160797061,160878061,161171161,161282161,161313161,161363161,161474161,161484161,161535161,161585161,161636161,161787161,161838161,161969161,162040261,162232261,162404261,162464261,162484261,162565261,162686261,162707261,162757261,162898261,162919261,162949261,162959261,162979261,162989261,163101361,163333361,163434361,163464361,163474361,163494361,163515361,163555361,163606361,163686361,163696361,163878361,163959361,164000461,164070461,164151461,164292461,164333461,164454461,164484461,164585461,164616461,164696461,164717461,164727461,164838461,165101561,165161561,165191561,165212561,165343561,165515561,165535561,165808561,165878561,165898561,165919561,165949561,166000661,166080661,166171661,166191661,166404661,166545661,166555661,166636661,166686661,166818661,166828661,166878661,166888661,166929661,167000761,167111761,167262761,167393761,167454761,167474761,167484761,167636761,167646761,167787761,167888761,167898761,167979761,168151861,168191861,168232861,168404861,168505861,168515861,168565861,168818861,168898861,168929861,168949861,169060961,169131961,169141961,169282961,169333961,169383961,169464961,169555961,169606961,169656961,169666961,169686961,169777961,169797961,169858961,169999961,170040071,170060071,170232071,170303071,170333071,170414071,170424071,170484071,170606071,170616071,170646071,170828071,170838071,170909071,170979071,171080171,171262171,171292171,171343171,171565171,171575171,171767171,171919171,171959171,172060271,172090271,172161271,172353271,172363271,172393271,172474271,172585271,172656271,172747271,172767271,172797271,172878271,172909271,172959271,173000371,173030371,173090371,173252371,173373371,173454371,173525371,173585371,173696371,173757371,173777371,173828371,173868371,173888371,173898371,173919371,174080471,174121471,174131471,174181471,174313471,174343471,174595471,174646471,174676471,174919471,174949471,174979471,174989471,175000571,175090571,175101571,175111571,175353571,175444571,175555571,175626571,175747571,175777571,175848571,175909571,176090671,176111671,176141671,176181671,176232671,176313671,176333671,176373671,176393671,176414671,176585671,176636671,176646671,176666671,176696671,176757671,176787671,176888671,176898671,176939671,177121771,177161771,177202771,177242771,177323771,177565771,177616771,177707771,177757771,177868771,178101871,178131871,178141871,178161871,178353871,178414871,178515871,178525871,178656871,178717871,178747871,178878871,178969871,178989871,178999871,179010971,179060971,179222971,179232971,179262971,179414971,179454971,179484971,179717971,179777971,179808971,179858971,179868971,179909971,179969971,179999971,180070081,180101081,180161081,180292081,180515081,180535081,180545081,180565081,180616081,180757081,180959081,181111181,181515181,181545181,181666181,181737181,181797181,181888181,182010281,182202281,182373281,182585281,182616281,182636281,182777281,182858281,182949281,183232381,183626381,183656381,183737381,183898381,183979381,183989381,184030481,184212481,184222481,184303481,184393481,184414481,184545481,184585481,184606481,184636481,184747481,184818481,184878481,185232581,185373581,185393581,185525581,185555581,185595581,185676581,185757581,185838581,185858581,185868581,185999581,186010681,186040681,186050681,186070681,186101681,186131681,186151681,186161681,186424681,186484681,186505681,186565681,186656681,186676681,186787681,186898681,187090781,187101781,187111781,187161781,187272781,187404781,187434781,187444781,187525781,187767781,187909781,187939781,187999781,188010881,188060881,188141881,188151881,188303881,188373881,188414881,188454881,188505881,188525881,188535881,188616881,188636881,188646881,188727881,188777881,188868881,188888881,188898881,188979881,189080981,189131981,189262981,189292981,189464981,189535981,189595981,189727981,189787981,189838981,189898981,189929981,190000091,190020091,190080091,190101091,190252091,190404091,190434091,190464091,190494091,190656091,190696091,190717091,190747091,190777091,190858091,190909091,191090191,191171191,191232191,191292191,191313191,191565191,191595191,191727191,191757191,191838191,191868191,191939191,191969191,192101291,192191291,192202291,192242291,192313291,192404291,192454291,192484291,192767291,192797291,192898291,193000391,193030391,193191391,193212391,193282391,193303391,193383391,193414391,193464391,193555391,193686391,193858391,193888391,194000491,194070491,194121491,194222491,194232491,194292491,194303491,194393491,194505491,194595491,194606491,194787491,194939491,194999491,195010591,195040591,195070591,195151591,195202591,195242591,195353591,195505591,195545591,195707591,195767591,195868591,195878591,195949591,195979591,196000691,196090691,196323691,196333691,196363691,196696691,196797691,196828691,196878691,197030791,197060791,197070791,197090791,197111791,197121791,197202791,197292791,197343791,197454791,197525791,197606791,197616791,197868791,197898791,197919791,198040891,198070891,198080891,198131891,198292891,198343891,198353891,198383891,198454891,198565891,198656891,198707891,198787891,198878891,198919891,199030991,199080991,199141991,199171991,199212991,199242991,199323991,199353991,199363991,199393991,199494991,199515991,199545991,199656991,199767991,199909991,199999991\";\\n\\t\\tString[] tr = str.split(\",\");\\n        int[] a = new int[tr.length];\\n        for(int i=0;i<a.length;i++) a[i] = Integer.parseInt(tr[i]);\\n        \\n        //find the first\\n        int lo=0;\\n        int hi = a.length;\\n        while(lo < hi){\\n            int mid = lo+hi>>1;\\n            if(a[mid] < n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return a[lo];\\n        \\n    }\\n    \\n    private boolean isPrime(int n){\\n        if( n <= 1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243195,
                "title": "20ms-c-solution",
                "content": "1. find the first palindrome number by N++;\\n2. return if prime, or generate the next palindrome\\n\\nhere is the way to generate number:\\n1. start from the inner position, like number `3` in `123321` and `12321`;\\n2. if the number<9, add it, like `123321` -> `124421` or `12321` -> `12421`;\\n3. find < 9 number, like `2` in  `12999921`and add it, remember calculate the step careful\\n4. if all is 9, like `9999`, just add `2` and get `10001`\\n\\nthe following is my code\\n```\\nclass Solution {\\npublic:\\n    bool isPal(int x) {\\n        int reverse = 0, src = x;\\n        while (x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return reverse == src;\\n    }\\n    \\n    int nextPal(int x) {\\n        int n = 0, m, tmp;\\n        while(pow(10, n) <= x) n ++;\\n        for (m = (n - 1) / 2; m >= 0; m --) {\\n            tmp = x / (int)pow(10, m) % 10;\\n            if (tmp < 9) {\\n                if (n % 2 && m == (n-1)/2) return x + pow(10, m);\\n                return x + pow(10, m+1) + pow(10, m);\\n            }\\n        }\\n        return x + 2;\\n    }\\n    \\n    bool isPrime(int x) {\\n        if (x < 2) return false;\\n        int s = sqrt(x);\\n        for (int i = 2; i <= s; i ++) {\\n            if (x % i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        while (!isPal(N)) N ++;\\n        while(!isPrime(N)) N = nextPal(N);\\n        return N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(int x) {\\n        int reverse = 0, src = x;\\n        while (x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return reverse == src;\\n    }\\n    \\n    int nextPal(int x) {\\n        int n = 0, m, tmp;\\n        while(pow(10, n) <= x) n ++;\\n        for (m = (n - 1) / 2; m >= 0; m --) {\\n            tmp = x / (int)pow(10, m) % 10;\\n            if (tmp < 9) {\\n                if (n % 2 && m == (n-1)/2) return x + pow(10, m);\\n                return x + pow(10, m+1) + pow(10, m);\\n            }\\n        }\\n        return x + 2;\\n    }\\n    \\n    bool isPrime(int x) {\\n        if (x < 2) return false;\\n        int s = sqrt(x);\\n        for (int i = 2; i <= s; i ++) {\\n            if (x % i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        while (!isPal(N)) N ++;\\n        while(!isPrime(N)) N = nextPal(N);\\n        return N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208246,
                "title": "c-20-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 146770,
                "title": "java-clear-solution-46ms",
                "content": "find the next Palindrome and check whether it\\'s Prime or not\\n\\nI find the next Palindrome code in https://stackoverflow.com/questions/7934519/a-better-algorithm-to-find-the-next-palindrome-of-a-number-string\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(N==1){\\n            return 2;\\n        }\\n        \\n        while(!isPalin(N)){\\n            N++;\\n        }\\n        \\n        if(isPrime(N)){\\n            return N;\\n        }\\n        \\n        while(true){\\n            N = Integer.parseInt(nextPalindrome(Integer.toString(N)));\\n            if(isPrime(N)){\\n                return N;\\n            }\\n        }\\n\\n    }\\n    \\n    public String nextPalindrome(String num) {\\n        int len = num.length();\\n        String left = num.substring(0, len / 2);\\n        String middle = num.substring(len / 2, len - len / 2);\\n        String right = num.substring(len - len / 2);\\n\\n        if (right.compareTo(reverse(left)) < 0)\\n            return left + middle + reverse(left);\\n\\n        String next = new BigInteger(left + middle).add(BigInteger.ONE).toString();\\n        return next.substring(0, left.length() + middle.length())\\n             + reverse(next).substring(middle.length());\\n    }\\n\\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n    \\n    private boolean isPalin(int num){\\n        if(num<10) return true;\\n        String str = Integer.toString(num);\\n        int i = 0;\\n        int j = str.length()-1;\\n        while(i<j){\\n            if(str.charAt(i)!=str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isPrime(int num){\\n        if(num==1) return false;\\n        if(num==2 || num==3 || num==5 || num==7) return true;\\n        for(int i = 2;i<(int)Math.sqrt(num)+1;i++){\\n            if(num%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(N==1){\\n            return 2;\\n        }\\n        \\n        while(!isPalin(N)){\\n            N++;\\n        }\\n        \\n        if(isPrime(N)){\\n            return N;\\n        }\\n        \\n        while(true){\\n            N = Integer.parseInt(nextPalindrome(Integer.toString(N)));\\n            if(isPrime(N)){\\n                return N;\\n            }\\n        }\\n\\n    }\\n    \\n    public String nextPalindrome(String num) {\\n        int len = num.length();\\n        String left = num.substring(0, len / 2);\\n        String middle = num.substring(len / 2, len - len / 2);\\n        String right = num.substring(len - len / 2);\\n\\n        if (right.compareTo(reverse(left)) < 0)\\n            return left + middle + reverse(left);\\n\\n        String next = new BigInteger(left + middle).add(BigInteger.ONE).toString();\\n        return next.substring(0, left.length() + middle.length())\\n             + reverse(next).substring(middle.length());\\n    }\\n\\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n    \\n    private boolean isPalin(int num){\\n        if(num<10) return true;\\n        String str = Integer.toString(num);\\n        int i = 0;\\n        int j = str.length()-1;\\n        while(i<j){\\n            if(str.charAt(i)!=str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isPrime(int num){\\n        if(num==1) return false;\\n        if(num==2 || num==3 || num==5 || num==7) return true;\\n        for(int i = 2;i<(int)Math.sqrt(num)+1;i++){\\n            if(num%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104344,
                "title": "c-fast-no-table-lookup-reduce-search-space",
                "content": "```\\nclass Solution {\\n  inline int generatePalindrome(int x) const {\\n    string str = to_string(x);\\n    string revStr = string(str.rbegin(), str.rend());\\n    return stoi(str + revStr.substr(1));\\n  }\\n  \\n  inline bool isPrime(int x) const {\\n    if (x < 2) return false;\\n    for (int i = 2; i*i <= x; i++)\\n      if (x % i == 0) \\n        return false;\\n    return true;\\n  } \\n  \\n  inline int ndigits(int x) const {\\n    int digits = 1;\\n    while (x /= 10)\\n      digits++;\\n    return digits;\\n  }\\n  \\n  inline int powi(int x, int k) const {\\n    if (k == 0) return 1;\\n    if (k == 1)\\n      return x;\\n    int res = powi(x, k / 2);\\n    res *= res;\\n    if (k & 1)\\n      res *= x;\\n    return res;\\n  }\\npublic:    \\n    int primePalindrome(int n) {\\n\\t // only palindrome with even length that is prime is 11\\n      if (n >= 8 && n <= 11) \\n        return 11;\\n      \\n      // Find a good starting point so we aren\\'t checking palindromes that are obviously too small\\n      int digits = ndigits(n), start;\\n      if (digits & 1) {\\n        start = n / powi(10, digits / 2);\\n      } else {\\n        // For example: n = 3044 -> the first possible palindrome that has 5 digits to check is 10001\\n        start = powi(10, digits / 2);\\n      }\\n\\n      for (int i = start; i < 1e5; ++i) {\\n        int palindrome = generatePalindrome(i);\\n        if (palindrome >= n && isPrime(palindrome)) \\n          return palindrome;\\n      }\\n\\n      return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  inline int generatePalindrome(int x) const {\\n    string str = to_string(x);\\n    string revStr = string(str.rbegin(), str.rend());\\n    return stoi(str + revStr.substr(1));\\n  }\\n  \\n  inline bool isPrime(int x) const {\\n    if (x < 2) return false;\\n    for (int i = 2; i*i <= x; i++)\\n      if (x % i == 0) \\n        return false;\\n    return true;\\n  } \\n  \\n  inline int ndigits(int x) const {\\n    int digits = 1;\\n    while (x /= 10)\\n      digits++;\\n    return digits;\\n  }\\n  \\n  inline int powi(int x, int k) const {\\n    if (k == 0) return 1;\\n    if (k == 1)\\n      return x;\\n    int res = powi(x, k / 2);\\n    res *= res;\\n    if (k & 1)\\n      res *= x;\\n    return res;\\n  }\\npublic:    \\n    int primePalindrome(int n) {\\n\\t // only palindrome with even length that is prime is 11\\n      if (n >= 8 && n <= 11) \\n        return 11;\\n      \\n      // Find a good starting point so we aren\\'t checking palindromes that are obviously too small\\n      int digits = ndigits(n), start;\\n      if (digits & 1) {\\n        start = n / powi(10, digits / 2);\\n      } else {\\n        // For example: n = 3044 -> the first possible palindrome that has 5 digits to check is 10001\\n        start = powi(10, digits / 2);\\n      }\\n\\n      for (int i = start; i < 1e5; ++i) {\\n        int palindrome = generatePalindrome(i);\\n        if (palindrome >= n && isPrime(palindrome)) \\n          return palindrome;\\n      }\\n\\n      return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050066,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981167,
                "title": "python-solution",
                "content": "```\\n    def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```\\n\\t\\t1.check only palindrome integers\\n\\t\\t2.time complexity is O(nXsqrt(n))\\n\\t\\t3.since constriant of n is 10^8 .return 100030001 if n>=9989900",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```",
                "codeTag": "Python3"
            },
            {
                "id": 3969487,
                "title": "golang-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Whatever lee215 said. Truly the legend of this website.](https://leetcode.com/problems/prime-palindrome/solutions/146798/java-c-python-all-even-length-palindrome-are-divisible-by-11/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\n\\tfor x := 3; x*x <= n; x += 2 {\\n\\t\\tif n%x == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\n\\nfunc reverseString(s string) string {\\n\\tr := []rune(s)\\n\\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tr[i], r[j] = r[j], r[i]\\n\\t}\\n\\treturn string(r)\\n}\\n\\nfunc primePalindrome(n int) int {\\n\\tif 8 <= n && n <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor x := 1; x < 100000; x++ {\\n\\t\\ts := strconv.Itoa(x)\\n\\t\\tr := reverseString(s)\\n\\t\\ty, _ := strconv.Atoi(s + r[1:])\\n\\t\\tif y >= n && isPrime(y) {\\n\\t\\t\\treturn y\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\n\\tfor x := 3; x*x <= n; x += 2 {\\n\\t\\tif n%x == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\n\\nfunc reverseString(s string) string {\\n\\tr := []rune(s)\\n\\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tr[i], r[j] = r[j], r[i]\\n\\t}\\n\\treturn string(r)\\n}\\n\\nfunc primePalindrome(n int) int {\\n\\tif 8 <= n && n <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor x := 1; x < 100000; x++ {\\n\\t\\ts := strconv.Itoa(x)\\n\\t\\tr := reverseString(s)\\n\\t\\ty, _ := strconv.Atoi(s + r[1:])\\n\\t\\tif y >= n && isPrime(y) {\\n\\t\\t\\treturn y\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942893,
                "title": "python-100-light",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import sqrt\\nclass Solution:\\n    def isPrime(self, num):\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            l = pow(10, len(str(n))//2)\\n        else:\\n            n_string = str(n)\\n            l = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(l), 20000):\\n            tr = int(str(i)+ str(i)[:-1][::-1])\\n            if tr >= n and self.isPrime(tr):\\n                return tr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import sqrt\\nclass Solution:\\n    def isPrime(self, num):\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            l = pow(10, len(str(n))//2)\\n        else:\\n            n_string = str(n)\\n            l = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(l), 20000):\\n            tr = int(str(i)+ str(i)[:-1][::-1])\\n            if tr >= n and self.isPrime(tr):\\n                return tr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928627,
                "title": "c-solution-using-basic-loops",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        for (long long i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isPali(int n) {\\n        string s = to_string(n);\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) {\\n             if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for (long long i = n; i < 1e8; i++) {\\n            if (isPrime(i)) {\\n                if (isPali(i)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        for (long long i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isPali(int n) {\\n        string s = to_string(n);\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) {\\n             if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for (long long i = n; i < 1e8; i++) {\\n            if (isPrime(i)) {\\n                if (isPali(i)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914488,
                "title": "by-prodonik-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def isPrime(num: int) -> bool:\\n            if num < 2:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n        def reversion(num: int) -> bool:\\n            return str(num)[::-1] == str(num)\\n        if n <= 2:\\n            return 2\\n        while True:\\n            if reversion(n) and isPrime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def isPrime(num: int) -> bool:\\n            if num < 2:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n        def reversion(num: int) -> bool:\\n            return str(num)[::-1] == str(num)\\n        if n <= 2:\\n            return 2\\n        while True:\\n            if reversion(n) and isPrime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888084,
                "title": "fastest-python-solution-using-a-bit-of-number-theory",
                "content": "# Intuition\\nThe difficulty with this problem was essentially to find a number that was both palindrome and prime. At this point I decided to divide the problem into 3 functions: one to form the palindrome number closest to n, one to create palindrome numbers that are bigger and closer to other palindromic numbers that have odd digits (to find out why I\\'ll write it later) and one to verify that they were prime numbers.\\n\\n# Approach\\nFirst I created a function which, taking n, returned a palindromic number that was the palindromic number immediately before n or immediately after. To do it was simple: I took the first half of the digits of n and flipped them to create a number. (it is not difficult to prove that this number is the largest but smallest palindrome with to n or the smallest but largest respect to n). This function is the def generate_special_palindrome(self, number). Then I created a function that took a plaindrome number and creates the one immediately following. If it was an even number however, it creates the smallest odd-digits palindrome bigger than the palindrome gave as input to the function. It does this because we know that every palindrome with even digits is divisible by 11 (see the divisibility test by 11 https://en.wikipedia.org/wiki/11_(number)#Divisibility_tests). To create the next palindrome with odd digits it takes the middle digit and it increases it by 1. if the middle digit becames 10 though, it just increas by 1 the mirror part and the middle digit becames 0. To see if our number is prime we can use a clever trick: for the people who studied a bit of number theory, we know that all the primes number (except 2 and 3), are 1 or 5 (modulo 6), (it\\'s just a fancy way to say that the residue of p/6 is either 1 or 5). So we can just verify that the number is 2 or 3, or not divisible by 2 or 3, and then we can just verify that all the numbers that are 1 or 5 (modulo 6) and that are less or equal to the sqrt(n) of the number, do not divide the number, and we know for sure that the number is prime. \\n# Complexity\\n- Time complexity:\\nUnfortunally, since we are working with primes, we can\\'t know for sure it\\'s time complexity, but we can set a lower bound!: Time complexity >= O(2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPrime(self, num):\\n        if num <= 1:\\n            return False\\n        if num <= 3:\\n            return True\\n\\n        if num % 2 == 0 or num % 3 == 0:\\n            return False\\n\\n        i = 5\\n        while i*i <= num:\\n            if num % i == 0 or num % (i + 2) == 0:\\n                return False\\n            i += 6\\n        \\n        return True\\n\\n    def generate_special_palindrome(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"-1\"\\n        else:\\n            middle_digit = num_str[leng // 2]\\n    \\n        first_half = num_str[:leng // 2]\\n        if middle_digit != \"-1\":\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        else:\\n            palindrome = int(first_half +\\n            first_half[::-1])\\n    \\n        return palindrome\\n\\n    def nextPal(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"0\"\\n            first_half = \"1\" + \"0\" * (leng/2 - 1)\\n        else:\\n            middle_digit = str(int(num_str[leng // 2]) + 1)\\n            first_half = num_str[:leng // 2]\\n\\n        if middle_digit == \"10\":\\n            middle_digit = \"0\"\\n            first_half = str(int(first_half) + 1)\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        \\n        palindrome = int(first_half + middle_digit +\\n        first_half[::-1])\\n\\n        return palindrome\\n\\n    def primePalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        z = self.generate_special_palindrome(n)\\n        if len(str(z)) == 1 or z == 10:\\n            while self.isPrime(z) == False:\\n                z += 1\\n            return z\\n        if z < n:\\n            z = self.nextPal(z)\\n        \\n        while self.isPrime(z) == False:\\n            z = self.nextPal(z)\\n        \\n        return z\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrime(self, num):\\n        if num <= 1:\\n            return False\\n        if num <= 3:\\n            return True\\n\\n        if num % 2 == 0 or num % 3 == 0:\\n            return False\\n\\n        i = 5\\n        while i*i <= num:\\n            if num % i == 0 or num % (i + 2) == 0:\\n                return False\\n            i += 6\\n        \\n        return True\\n\\n    def generate_special_palindrome(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"-1\"\\n        else:\\n            middle_digit = num_str[leng // 2]\\n    \\n        first_half = num_str[:leng // 2]\\n        if middle_digit != \"-1\":\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        else:\\n            palindrome = int(first_half +\\n            first_half[::-1])\\n    \\n        return palindrome\\n\\n    def nextPal(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"0\"\\n            first_half = \"1\" + \"0\" * (leng/2 - 1)\\n        else:\\n            middle_digit = str(int(num_str[leng // 2]) + 1)\\n            first_half = num_str[:leng // 2]\\n\\n        if middle_digit == \"10\":\\n            middle_digit = \"0\"\\n            first_half = str(int(first_half) + 1)\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        \\n        palindrome = int(first_half + middle_digit +\\n        first_half[::-1])\\n\\n        return palindrome\\n\\n    def primePalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        z = self.generate_special_palindrome(n)\\n        if len(str(z)) == 1 or z == 10:\\n            while self.isPrime(z) == False:\\n                z += 1\\n            return z\\n        if z < n:\\n            z = self.nextPal(z)\\n        \\n        while self.isPrime(z) == False:\\n            z = self.nextPal(z)\\n        \\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869484,
                "title": "next-largest-prime-palindrome-c-did-not-see-another-solution-so-posting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the next palindrome and check if its prime.\\n\\niterate from both sides, if end < start then make end and start index values same since that is a larger number.\\n\\nIf end > start then make them same but pass a carry of 1 left of end index, process carry and check again if its a palindrome. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFind next palindrome and check if its prime. Mostly we need to do some manipulation to find the next smallest palindrome\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nFind palindrome O(Length(num) * 9) = O(Length(num))\\n\\nCheck Palindrome O(Length(num))\\n\\nIsPrime(O(sqrt(num)))\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(Length(n))\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        int numAttempts = 1000000;\\n        int curr = IsPalindrome(n) ? n : NextPalindrome(n);\\n        while(numAttempts > 0){\\n            if(IsPrime(curr)){\\n                return curr;\\n            }\\n\\n            //Console.WriteLine(\"next palindrome \" + curr);\\n            curr = NextPalindrome(curr);\\n            numAttempts--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static bool IsPrime(int n ){\\n        int divisor = Convert.ToInt32(Math.Floor(Math.Sqrt((double)n)));\\n        for(int i = 2; i <= divisor; i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private static int NextPalindrome(int n){\\n        int nextNum = n + 1;\\n        string str = nextNum.ToString();\\n        char[] cArray = str.ToCharArray();\\n\\n        int pendingIndex = ConvertToPalindrome(cArray);\\n        int numAttempts = 1000;\\n        while(pendingIndex != -1 && numAttempts > 0){\\n            //Console.WriteLine($\"Failed : {new string(cArray)} at {pendingIndex}\");\\n            ProcessCarry(ref cArray, pendingIndex);\\n           // Console.WriteLine($\"checking : {new string(cArray)}\");\\n            pendingIndex = ConvertToPalindrome(cArray);\\n            numAttempts--;\\n             //Console.WriteLine($\"pending index : {new string(cArray)} is {pendingIndex}\");\\n        }\\n\\n        return int.Parse(new string(cArray));\\n    }\\n\\n    private static void ProcessCarry(ref char[] cArray, int index){\\n        while(index >= 0){\\n            int newVal = IntVal(cArray[index]) + 1;\\n            if(newVal < 10){\\n                cArray[index] = CharVal(newVal);\\n                return;\\n            }\\n\\n            newVal -= 10;\\n            cArray[index] = CharVal(newVal);\\n            index--;\\n        }\\n\\n        char[] newCArray = new char[cArray.Length + 1];\\n        newCArray[0] = \\'1\\';\\n        for(int i = 0; i < cArray.Length; i++){\\n            newCArray[i + 1] = cArray[i];\\n        }\\n\\n        cArray = newCArray;\\n    }\\n\\n    private static int ConvertToPalindrome(char[]  cArray){\\n        int start = 0;\\n        int end = cArray.Length - 1;\\n        while(start < end){\\n            \\n            if(cArray[start] == cArray[end]){\\n                start++;\\n                end--;\\n                continue;\\n            }\\n\\n            if((int)cArray[start] >= (int)cArray[end]){\\n                cArray[end] = cArray[start];\\n            }else {\\n                cArray[end] = cArray[start];\\n                return end - 1;\\n            }\\n\\n            start++;\\n            end--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static char CharVal(int v){\\n        return (char)(v + 48);\\n    }\\n    private static int IntVal(char c){\\n        return (int)c - 48;\\n    }\\n    private static bool IsPalindrome(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n\\n        string s = n.ToString();\\n        string reverse = new string(s.ToCharArray().Reverse().ToArray());\\n        return s.Equals(reverse);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        int numAttempts = 1000000;\\n        int curr = IsPalindrome(n) ? n : NextPalindrome(n);\\n        while(numAttempts > 0){\\n            if(IsPrime(curr)){\\n                return curr;\\n            }\\n\\n            //Console.WriteLine(\"next palindrome \" + curr);\\n            curr = NextPalindrome(curr);\\n            numAttempts--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static bool IsPrime(int n ){\\n        int divisor = Convert.ToInt32(Math.Floor(Math.Sqrt((double)n)));\\n        for(int i = 2; i <= divisor; i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private static int NextPalindrome(int n){\\n        int nextNum = n + 1;\\n        string str = nextNum.ToString();\\n        char[] cArray = str.ToCharArray();\\n\\n        int pendingIndex = ConvertToPalindrome(cArray);\\n        int numAttempts = 1000;\\n        while(pendingIndex != -1 && numAttempts > 0){\\n            //Console.WriteLine($\"Failed : {new string(cArray)} at {pendingIndex}\");\\n            ProcessCarry(ref cArray, pendingIndex);\\n           // Console.WriteLine($\"checking : {new string(cArray)}\");\\n            pendingIndex = ConvertToPalindrome(cArray);\\n            numAttempts--;\\n             //Console.WriteLine($\"pending index : {new string(cArray)} is {pendingIndex}\");\\n        }\\n\\n        return int.Parse(new string(cArray));\\n    }\\n\\n    private static void ProcessCarry(ref char[] cArray, int index){\\n        while(index >= 0){\\n            int newVal = IntVal(cArray[index]) + 1;\\n            if(newVal < 10){\\n                cArray[index] = CharVal(newVal);\\n                return;\\n            }\\n\\n            newVal -= 10;\\n            cArray[index] = CharVal(newVal);\\n            index--;\\n        }\\n\\n        char[] newCArray = new char[cArray.Length + 1];\\n        newCArray[0] = \\'1\\';\\n        for(int i = 0; i < cArray.Length; i++){\\n            newCArray[i + 1] = cArray[i];\\n        }\\n\\n        cArray = newCArray;\\n    }\\n\\n    private static int ConvertToPalindrome(char[]  cArray){\\n        int start = 0;\\n        int end = cArray.Length - 1;\\n        while(start < end){\\n            \\n            if(cArray[start] == cArray[end]){\\n                start++;\\n                end--;\\n                continue;\\n            }\\n\\n            if((int)cArray[start] >= (int)cArray[end]){\\n                cArray[end] = cArray[start];\\n            }else {\\n                cArray[end] = cArray[start];\\n                return end - 1;\\n            }\\n\\n            start++;\\n            end--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static char CharVal(int v){\\n        return (char)(v + 48);\\n    }\\n    private static int IntVal(char c){\\n        return (int)c - 48;\\n    }\\n    private static bool IsPalindrome(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n\\n        string s = n.ToString();\\n        string reverse = new string(s.ToCharArray().Reverse().ToArray());\\n        return s.Equals(reverse);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832207,
                "title": "ruby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nrequire \\'prime\\'\\n\\n# A palprime has only odd number of digits \\n# (otherwise it is divisible by 11)\\n@pals = [*\"0\"..\"9\"]\\n\\n4.times do # 1, 3, 5, 7, 9 digits\\n  nxt = @pals.dup\\n  (0..9).each do |digit|\\n    @pals.each do |pal|\\n      nxt << digit.to_s + pal + digit.to_s\\n    end\\n  end\\n  \\n  @pals = nxt\\nend\\n\\n@pals.insert(10, \"11\")\\n@pals = @pals.map(&:to_i).select(&:prime?)\\n\\ndef prime_palindrome(n)\\n  # Optimization 1\\n  n = 1e8 if 1e7 < n && n < 1e8\\n\\n  @pals.find do |pal|\\n    pal >= n\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nrequire \\'prime\\'\\n\\n# A palprime has only odd number of digits \\n# (otherwise it is divisible by 11)\\n@pals = [*\"0\"..\"9\"]\\n\\n4.times do # 1, 3, 5, 7, 9 digits\\n  nxt = @pals.dup\\n  (0..9).each do |digit|\\n    @pals.each do |pal|\\n      nxt << digit.to_s + pal + digit.to_s\\n    end\\n  end\\n  \\n  @pals = nxt\\nend\\n\\n@pals.insert(10, \"11\")\\n@pals = @pals.map(&:to_i).select(&:prime?)\\n\\ndef prime_palindrome(n)\\n  # Optimization 1\\n  n = 1e8 if 1e7 < n && n < 1e8\\n\\n  @pals.find do |pal|\\n    pal >= n\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3809835,
                "title": "typecript-easy-solution",
                "content": "# Code\\n```\\nfunction isPrime(n: number): boolean {\\n    for(let i = 2, s = Math.sqrt(n); i <= s; i++) {\\n        if(n % i === 0) return false;\\n    }\\n    return n > 1;\\n}\\n\\nfunction isPal(s: string): boolean {\\n    let l: number = 0\\n    let r: number = s.length - 1\\n    while (l < r) {\\n        if (s[l] !== s[r]) return false\\n        l++;\\n        r--;\\n    }\\n    return true\\n}\\n\\nfunction primePalindrome(n: number): number {\\n    if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n\\n    for(let i:number = n;i<1e8;i++) {\\n        if (isPrime(i) && isPal(i.toString())) {\\n            return i\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrime(n: number): boolean {\\n    for(let i = 2, s = Math.sqrt(n); i <= s; i++) {\\n        if(n % i === 0) return false;\\n    }\\n    return n > 1;\\n}\\n\\nfunction isPal(s: string): boolean {\\n    let l: number = 0\\n    let r: number = s.length - 1\\n    while (l < r) {\\n        if (s[l] !== s[r]) return false\\n        l++;\\n        r--;\\n    }\\n    return true\\n}\\n\\nfunction primePalindrome(n: number): number {\\n    if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n\\n    for(let i:number = n;i<1e8;i++) {\\n        if (isPrime(i) && isPal(i.toString())) {\\n            return i\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794047,
                "title": "easy-and-acceptable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool prime(int n)\\n    {\\n        if(n<=2)\\n            return true;\\n        for(int i=2; i<=sqrt(n); i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool palindrome(int n)\\n    {\\n        \\n        int x=n;\\n        int num=0;\\n        while(n)\\n        {\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        if(x==num)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(99899*1e2 <=n && n<=1e8)\\n            return 100030001;\\n        if(n==1)\\n            return 2;\\n        if(n==0)\\n            return 1;\\n        while(n<1e8)\\n        {\\n            if(prime(n) && palindrome(n))\\n                return n;\\n            n++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool prime(int n)\\n    {\\n        if(n<=2)\\n            return true;\\n        for(int i=2; i<=sqrt(n); i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool palindrome(int n)\\n    {\\n        \\n        int x=n;\\n        int num=0;\\n        while(n)\\n        {\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        if(x==num)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(99899*1e2 <=n && n<=1e8)\\n            return 100030001;\\n        if(n==1)\\n            return 2;\\n        if(n==0)\\n            return 1;\\n        while(n<1e8)\\n        {\\n            if(prime(n) && palindrome(n))\\n                return n;\\n            n++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709363,
                "title": "my-c-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isPrime(int n){\\n    if(n<2){\\n        return false;\\n    }\\n    for(int i=2;i*i<=n;i++){\\n        if(n%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n    int primePalindrome(int n) {\\n        int ans=0,rev=0;\\n        // if (1e7 <= n && n <= 1e8)\\n        // return 100030001;\\n        for(int i=n;i<10000000;i++){\\nif(isPrime(i)){\\n    ans=i;\\nint k=i;\\nwhile(k!=0){\\n    int rem=k%10;\\n    rev=rev*10+rem;\\n    k/=10;\\n}\\nif(rev==ans){\\n    return ans;\\n}\\nelse{\\n    rev=0;\\n}\\n        }\\n       }\\n        \\n        return 100030001;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isPrime(int n){\\n    if(n<2){\\n        return false;\\n    }\\n    for(int i=2;i*i<=n;i++){\\n        if(n%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n    int primePalindrome(int n) {\\n        int ans=0,rev=0;\\n        // if (1e7 <= n && n <= 1e8)\\n        // return 100030001;\\n        for(int i=n;i<10000000;i++){\\nif(isPrime(i)){\\n    ans=i;\\nint k=i;\\nwhile(k!=0){\\n    int rem=k%10;\\n    rev=rev*10+rem;\\n    k/=10;\\n}\\nif(rev==ans){\\n    return ans;\\n}\\nelse{\\n    rev=0;\\n}\\n        }\\n       }\\n        \\n        return 100030001;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696111,
                "title": "highly-efficient-concise-solution",
                "content": "# Intuition\\nThe brute-force method is just to check every integer after n. However, very few of these integers are palindromes. If we only check the palindromes, it will be much more efficient.\\n\\n# Approach\\nFor n<=100, we check from a very short list of prime palindromes. Otherwise, we generate palindromes for the bigger n values, and check if they are prime.\\n\\nAn important optimization is that we only need to check palindromes with an odd number of digits. Any palindrome with an even number of digits is a multiple of 11, per divisibility rules. They would all not be prime (except 11).\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            for f in range(2, int(n**0.5)+1):\\n                if n % f == 0:\\n                    return False\\n            return True\\n        \\n        if n <= 100:\\n            return min(i for i in [2, 3, 5, 7, 11, 101] if i >= n)\\n        \\n        for half_l in range(len(str(n))//2-1, 5):\\n            for h in range(10**half_l, 10**(half_l+1)):\\n                half = str(h)\\n                test_n = int(half + half[-2::-1])  # Construct palindrome\\n                if test_n >= n and is_prime(test_n):\\n                    return test_n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            for f in range(2, int(n**0.5)+1):\\n                if n % f == 0:\\n                    return False\\n            return True\\n        \\n        if n <= 100:\\n            return min(i for i in [2, 3, 5, 7, 11, 101] if i >= n)\\n        \\n        for half_l in range(len(str(n))//2-1, 5):\\n            for h in range(10**half_l, 10**(half_l+1)):\\n                half = str(h)\\n                test_n = int(half + half[-2::-1])  # Construct palindrome\\n                if test_n >= n and is_prime(test_n):\\n                    return test_n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694954,
                "title": "java",
                "content": "based on lee\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n<=11) {\\n            if (n<=2) return 2;\\n            if (n<=3) return 3;\\n            if (n<=5) return 5;\\n            if (n<=7) return 7;\\n            return 11;\\n        }\\n\\n        String s = \"\" + n; \\n        int guess = 1;\\n        while (true){\\n            for (char mid = \\'0\\' ; mid<=\\'9\\'; mid++){\\n                StringBuilder pal = (new StringBuilder(\"\" + guess)).append(mid).append((new StringBuilder(\"\" + guess)).reverse().toString());\\n                int cur = Integer.parseInt(pal.toString());\\n                if (cur >= n && isPrime(cur)) return cur;   \\n            }\\n            guess++;\\n        }\\n    }\\n\\n    private boolean isPrime(int n){\\n        for (int i=2; i<=Math.sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n<=11) {\\n            if (n<=2) return 2;\\n            if (n<=3) return 3;\\n            if (n<=5) return 5;\\n            if (n<=7) return 7;\\n            return 11;\\n        }\\n\\n        String s = \"\" + n; \\n        int guess = 1;\\n        while (true){\\n            for (char mid = \\'0\\' ; mid<=\\'9\\'; mid++){\\n                StringBuilder pal = (new StringBuilder(\"\" + guess)).append(mid).append((new StringBuilder(\"\" + guess)).reverse().toString());\\n                int cur = Integer.parseInt(pal.toString());\\n                if (cur >= n && isPrime(cur)) return cur;   \\n            }\\n            guess++;\\n        }\\n    }\\n\\n    private boolean isPrime(int n){\\n        for (int i=2; i<=Math.sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685475,
                "title": "beginners-friendly-code-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public static int primePalindrome(int p) {\\n        if(p<=9981899){\\n            while(true){            \\n            if(isPrime(p)==1 && palindrome(p)==1){\\n            return p;\\n        }\\n        p++;\\n    }\\n        }else{\\n            return 100030001;\\n        }\\n        \\n}\\n    static int palindrome(int p){\\n        String s =String.valueOf(p);\\n        String n = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            n= s.charAt(i)+n;\\n            int rev =Integer.parseInt(n);\\n            if(p==rev){\\n                return 1;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n    static int isPrime(int n) {  \\n        if (n <= 1) {  \\n            return 0;  \\n        }  \\n        for (int i = 2; i*i <= n; i++) {  \\n            if (n % i == 0) {  \\n                return 0;  \\n            }\\n            \\n        }\\n        return 1;  \\n        \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int primePalindrome(int p) {\\n        if(p<=9981899){\\n            while(true){            \\n            if(isPrime(p)==1 && palindrome(p)==1){\\n            return p;\\n        }\\n        p++;\\n    }\\n        }else{\\n            return 100030001;\\n        }\\n        \\n}\\n    static int palindrome(int p){\\n        String s =String.valueOf(p);\\n        String n = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            n= s.charAt(i)+n;\\n            int rev =Integer.parseInt(n);\\n            if(p==rev){\\n                return 1;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n    static int isPrime(int n) {  \\n        if (n <= 1) {  \\n            return 0;  \\n        }  \\n        for (int i = 2; i*i <= n; i++) {  \\n            if (n % i == 0) {  \\n                return 0;  \\n            }\\n            \\n        }\\n        return 1;  \\n        \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614274,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==1){\\n            return 2;\\n        }\\n    int i = n - 1;\\n    while (true) {\\n        i++;\\n        int temp = i;\\n        int rev = 0;\\n        while (temp > 0) {\\n            rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n        }\\n        if (rev == i) {\\n            int k = 2;\\n            int x = sqrt(i);\\n            while (k <= x) {\\n                if (i % k == 0) {\\n                    break;\\n                }\\n                k++;\\n            }\\n            if (k > x) {\\n                return i;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==1){\\n            return 2;\\n        }\\n    int i = n - 1;\\n    while (true) {\\n        i++;\\n        int temp = i;\\n        int rev = 0;\\n        while (temp > 0) {\\n            rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n        }\\n        if (rev == i) {\\n            int k = 2;\\n            int x = sqrt(i);\\n            while (k <= x) {\\n                if (i % k == 0) {\\n                    break;\\n                }\\n                k++;\\n            }\\n            if (k > x) {\\n                return i;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607188,
                "title": "2ms-96-39-5mb-73-iterate-only-palindrome-very-detailed-explanation",
                "content": "# Intuition\\nJust need to iterate only palindrome, so \\n1st step: find the bigger nearest palindrome\\n2nd step: generate next palindrome\\n3rd step: check is this palindrome is prime, else repeat from 2nd step\\n\\n# Implementation\\n- just hardcode for n <= 100\\n- Skip all even length palindrome, because its proved to be dividable by 11.\\n\\n\\n**1st Step:**\\n- Split n into left & right side, **example 435679328 (odd length of 9)**, split to **43567(left)** & **9328(right)**\\n- find the bigger nearest palindrome :\\n    **ignore the middle digit, which is 7**, and compare both side, for left side start from behind, for right side start from front:\\n\\ncompare 6 vs 9, if right side(9) is bigger, then increase the middle digit by 1 \\nand the **nearest parlindrom will be**\\nleftSide+1 concatenate reverse of leftSide.substring(0, leftSide.length-1) = \\n(43567+1) concatenate reverse of 4356 =\\n43568 concatenate 6534 = **435686534**\\n\\n**another example 754312609** , ignore the middle digit (1)\\ncompare 3 vs 2, if left side(3) is bigger, \\nthen **the nearest parlindrom will be**\\n75431 + reverse of 7543 = **754313457**\\n\\n**another example 961303782**, ignore the middle digit (0)\\nif both side are equal, compare the next digit\\ncompare 1(left) vs 7(right), if rightSide bigger, increase middle digit and you get the nearest parlindrom, else if leftSide is bigger, just concat leftSide & reverse of leftSide, if they are same again, compare next next digit, and so on... \\n**if all digits are same, then itself is palindrome.**\\n\\n\\n**2nd Step:**\\nOk, now we can start from the nearest palindrome we\\'ve found in step 1.\\nRemember we split number into leftSide and rightSide? But now we only need to increment leftSide by 1 , then it is the next nearest palindrome!! so discard rightSide, its useless now.\\n\\n**Using first example 435686534**, leftSide = 43568, \\nwhile true iteration :\\n\\ncheck if 435686534 is prime? \\nyes -> return;\\nno -> \\n    1. leftSide += 1 (43568 + 1 = 43569)\\n    2. form a new palindrome ( 435696534 )\\n\\nend while\\n\\n***Thats it!!***\\n\\n**Note**: Example n = 990, \\nleftSide = 99, palindrome = 99 concat 9, = 999\\nand when leftSide + 1 (=100)\\nsince we concat leftSide + reverse of leftSide.substring(0, leftSide.length-1), \\n= 100 concat 01 = 10001\\nthat means we are always concatenating evenLength + oddLength OR oddLength + evenLength, so it is always equal to oddLength (skipping evenLength palindrome.)\\n\\n# Complexity\\n- Time complexity:\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n <= 2) return 2;\\n        if(n <= 3) return 3;\\n        if(n <= 5) return 5;\\n        if(n <= 7) return 7;\\n        if(n <= 11) return 11;\\n        if(n <= 100) return 101;\\n\\n        int len = getNumLength(n);\\n        if(len % 2 == 0) \\n            n = (int)Math.pow(10, len++);   //  len increase 1 after this line\\n\\n        int startLeftPart, palindrome = 0;\\n        String vLeftPart;     //  reverse of startLeftPart, so it becomes rightPart\\n        startLeftPart = findFirstPalindrome(n, len);\\n        \\n        while(true){\\n            String tempLeft = String.valueOf(startLeftPart);\\n            vLeftPart = strReverse(tempLeft.substring(0, tempLeft.length()-1));\\n            palindrome = Integer.parseInt(tempLeft + vLeftPart);\\n            if( isPrime(palindrome) ) return palindrome;\\n            \\n            startLeftPart++;\\n        }\\n    }\\n\\n    int findFirstPalindrome(int n, int len){\\n        String leftPart = String.valueOf(n).substring( 0, ((len+1)/2) );\\n        String rightPart = String.valueOf(n).substring( ((len+1)/2), len);\\n\\n        for(int i=0; i<rightPart.length(); ++i)\\n            if(leftPart.charAt(leftPart.length()-2-i) > rightPart.charAt(i))\\n                break;\\n\\n            else if(leftPart.charAt(leftPart.length()-2-i) < rightPart.charAt(i)){\\n                leftPart = String.valueOf(Integer.parseInt(leftPart) + 1);\\n                break;\\n            }\\n\\n        return Integer.parseInt(leftPart);\\n    }\\n\\n    int getNumLength(int x){\\n        int length = 0;\\n        long temp = 1;\\n        while (temp <= x) {\\n            length++;\\n            temp *= 10;\\n        }\\n        return length;\\n    }\\n\\n    String strReverse(String s){\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n\\n    boolean isPrime(int x){\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n <= 2) return 2;\\n        if(n <= 3) return 3;\\n        if(n <= 5) return 5;\\n        if(n <= 7) return 7;\\n        if(n <= 11) return 11;\\n        if(n <= 100) return 101;\\n\\n        int len = getNumLength(n);\\n        if(len % 2 == 0) \\n            n = (int)Math.pow(10, len++);   //  len increase 1 after this line\\n\\n        int startLeftPart, palindrome = 0;\\n        String vLeftPart;     //  reverse of startLeftPart, so it becomes rightPart\\n        startLeftPart = findFirstPalindrome(n, len);\\n        \\n        while(true){\\n            String tempLeft = String.valueOf(startLeftPart);\\n            vLeftPart = strReverse(tempLeft.substring(0, tempLeft.length()-1));\\n            palindrome = Integer.parseInt(tempLeft + vLeftPart);\\n            if( isPrime(palindrome) ) return palindrome;\\n            \\n            startLeftPart++;\\n        }\\n    }\\n\\n    int findFirstPalindrome(int n, int len){\\n        String leftPart = String.valueOf(n).substring( 0, ((len+1)/2) );\\n        String rightPart = String.valueOf(n).substring( ((len+1)/2), len);\\n\\n        for(int i=0; i<rightPart.length(); ++i)\\n            if(leftPart.charAt(leftPart.length()-2-i) > rightPart.charAt(i))\\n                break;\\n\\n            else if(leftPart.charAt(leftPart.length()-2-i) < rightPart.charAt(i)){\\n                leftPart = String.valueOf(Integer.parseInt(leftPart) + 1);\\n                break;\\n            }\\n\\n        return Integer.parseInt(leftPart);\\n    }\\n\\n    int getNumLength(int x){\\n        int length = 0;\\n        long temp = 1;\\n        while (temp <= x) {\\n            length++;\\n            temp *= 10;\\n        }\\n        return length;\\n    }\\n\\n    String strReverse(String s){\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n\\n    boolean isPrime(int x){\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566299,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\nif( n <= 2) return 2; \\n\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\nif (n % 2 === 0 ){\\n    n ++;\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v = v + 2){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\nif( n <= 2) return 2; \\n\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\nif (n % 2 === 0 ){\\n    n ++;\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v = v + 2){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566230,
                "title": "easy-to-understand-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n\\n// there is no prime palindrome between this 1e7 & 1e8\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v ++){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n\\n// there is no prime palindrome between this 1e7 & 1e8\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v ++){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3512734,
                "title": "maybe-i-m-just-dumb-well-commented-solution-kind-of-sort-of-cheating-with-the-final-max-num",
                "content": "Picture of my cat to make everything better. \\n\\n![20211003_173451.jpg](https://assets.leetcode.com/users/images/0cadf77c-6d75-419d-83cb-0b445925a599_1683814982.5276306.jpeg)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI figured just creating one list of all the prime-palindromes would reduce re-work, setup the list on solution creation, then all calls to PrimePalindrome(int n) just need to do one lookup in Log(n) time right? \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Sieve of Eratosthenes and an Is Palindrome function to populate our memory cache of valid possible numbers. \\n\\nMy sieveRange is actually incorrect as that\\'s just the range of input N being checked, had to manually add the max possible num to the list as this solution timed out if I increased the range to include that prime palindrome. \\n\\nThat misunderstanding of the range caused a lot of pain debugging. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI should quit to become a sheep herder in the Alps. \\n\\nSieve of Eratosthenes is typically considreed O(n log log n) so final for this solution is something like O(n * (Log(Log(n))) + Log(m)),\\nwhere m is size of the primePalindromes list. and that\\'s ignoring the time of palindrome check, but I\\'m too damn dumb to get this exactly right.\\n \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nShould be something like O(n + m), where n is the sieveRange (for the primes array in the SieveOfEratosthenes function) and m is the size of the primePalindromes\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    // List to store prime palindromes\\n    List<int> primePalindromes = new List<int>();\\n    \\n    // The maximum number we will check for prime palindrome\\n    const int sieveRange = 10000000; \\n\\n    // Constructor: when a new solution object is created, it populates the primePalindromes list\\n    public Solution()\\n    {\\n        // Populate all primes in testing range\\n        SieveOfEratosthenes();\\n        // Max item that could be found within range\\n        // Honestly just found this in the editorial write up, times out if I try to calculate with sieve\\n        primePalindromes.Add(100030001);\\n    }\\n\\n    // Method to find all prime numbers up to sieveRange using the Sieve of Eratosthenes algorithm\\n    private void SieveOfEratosthenes()\\n    {\\n        // Boolean array to mark prime and composite numbers\\n        bool[] primes = new bool[sieveRange];\\n        \\n        // Initially set all numbers as prime\\n        Array.Fill(primes, true);\\n        \\n        // 0 and 1 are not prime\\n        primes[0] = primes[1] = false;\\n\\n        // Main loop to mark composites. If i is prime, then i*i to sieveRange are not prime.\\n        for (int i = 2; i * i < sieveRange; i++)\\n        {\\n            if (primes[i])\\n            {\\n                for (int j = i * i; j < sieveRange; j += i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n        // Loop through all numbers and add the primes that are also palindrome to primePalindromes list\\n        for (int i = 2; i < sieveRange; i++)\\n        {\\n            if (primes[i] && IsPalindrome(i))\\n            {\\n                primePalindromes.Add(i);\\n            }\\n        }\\n    }\\n\\n    // Method to check if a number is palindrome or not\\n    private bool IsPalindrome(int num)\\n    {\\n        // Single digit numbers are always palindrome\\n        if (num < 10) return true;\\n\\n        // Reverse the number\\n        int reversed = 0;\\n        int original = num;\\n\\n        while (num > 0)\\n        {\\n            int digit = num % 10;\\n            reversed = reversed * 10 + digit;\\n            num /= 10;\\n        }\\n\\n        // If the reversed number is same as original, it is a palindrome\\n        return original == reversed;\\n    }\\n\\n    public int PrimePalindrome(int n)\\n    {\\n        // Use binary search to find the index of the smallest prime palindrome >= n\\n        int idx = primePalindromes.BinarySearch(n);\\n        \\n        if (idx < 0)\\n        {\\n            // If the exact value is not found, BinarySearch returns the bitwise    complement of the index of the next larger element\\n            idx = ~idx;\\n        }     \\n        \\n        // Return the prime palindrome at the found index\\n        return primePalindromes[idx];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    // List to store prime palindromes\\n    List<int> primePalindromes = new List<int>();\\n    \\n    // The maximum number we will check for prime palindrome\\n    const int sieveRange = 10000000; \\n\\n    // Constructor: when a new solution object is created, it populates the primePalindromes list\\n    public Solution()\\n    {\\n        // Populate all primes in testing range\\n        SieveOfEratosthenes();\\n        // Max item that could be found within range\\n        // Honestly just found this in the editorial write up, times out if I try to calculate with sieve\\n        primePalindromes.Add(100030001);\\n    }\\n\\n    // Method to find all prime numbers up to sieveRange using the Sieve of Eratosthenes algorithm\\n    private void SieveOfEratosthenes()\\n    {\\n        // Boolean array to mark prime and composite numbers\\n        bool[] primes = new bool[sieveRange];\\n        \\n        // Initially set all numbers as prime\\n        Array.Fill(primes, true);\\n        \\n        // 0 and 1 are not prime\\n        primes[0] = primes[1] = false;\\n\\n        // Main loop to mark composites. If i is prime, then i*i to sieveRange are not prime.\\n        for (int i = 2; i * i < sieveRange; i++)\\n        {\\n            if (primes[i])\\n            {\\n                for (int j = i * i; j < sieveRange; j += i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n        // Loop through all numbers and add the primes that are also palindrome to primePalindromes list\\n        for (int i = 2; i < sieveRange; i++)\\n        {\\n            if (primes[i] && IsPalindrome(i))\\n            {\\n                primePalindromes.Add(i);\\n            }\\n        }\\n    }\\n\\n    // Method to check if a number is palindrome or not\\n    private bool IsPalindrome(int num)\\n    {\\n        // Single digit numbers are always palindrome\\n        if (num < 10) return true;\\n\\n        // Reverse the number\\n        int reversed = 0;\\n        int original = num;\\n\\n        while (num > 0)\\n        {\\n            int digit = num % 10;\\n            reversed = reversed * 10 + digit;\\n            num /= 10;\\n        }\\n\\n        // If the reversed number is same as original, it is a palindrome\\n        return original == reversed;\\n    }\\n\\n    public int PrimePalindrome(int n)\\n    {\\n        // Use binary search to find the index of the smallest prime palindrome >= n\\n        int idx = primePalindromes.BinarySearch(n);\\n        \\n        if (idx < 0)\\n        {\\n            // If the exact value is not found, BinarySearch returns the bitwise    complement of the index of the next larger element\\n            idx = ~idx;\\n        }     \\n        \\n        // Return the prime palindrome at the found index\\n        return primePalindromes[idx];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441070,
                "title": "208-ms",
                "content": "```ruby\\nrequire \\'prime\\'\\n\\n@r, b = Prime.each(11).to_a, 1\\nfor z in 1..3\\n    b *= 10\\n    for a in [1, 3, 5, 7, 9]\\n        for f in a * b...a.succ * b\\n            x = ((s = f.to_s) + s[0, z].reverse!).to_i\\n            @r << x if Prime.prime? x\\n        end\\n    end\\nend\\nf = 10_000\\nloop do\\n    x = ((s = f.to_s) + s[0, 4].reverse!).to_i\\n    next f += 1 unless Prime.prime? x\\n    @r << x\\n    break\\nend\\n\\ndef prime_palindrome(n) = @r.bsearch { _1 >= n }\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nrequire \\'prime\\'\\n\\n@r, b = Prime.each(11).to_a, 1\\nfor z in 1..3\\n    b *= 10\\n    for a in [1, 3, 5, 7, 9]\\n        for f in a * b...a.succ * b\\n            x = ((s = f.to_s) + s[0, z].reverse!).to_i\\n            @r << x if Prime.prime? x\\n        end\\n    end\\nend\\nf = 10_000\\nloop do\\n    x = ((s = f.to_s) + s[0, 4].reverse!).to_i\\n    next f += 1 unless Prime.prime? x\\n    @r << x\\n    break\\nend\\n\\ndef prime_palindrome(n) = @r.bsearch { _1 >= n }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3419172,
                "title": "prime-palindrome",
                "content": "---------------------- Easy C++ Solution -------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool isPrime(int n) {\\n        for(int i=2; i<=sqrt(n);i++) {\\n            if(n%i==0) return 0;\\n        }\\n        return 1;\\n    }\\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    \\n    int isPalindrome(int n){\\n        return n == reverse(n);\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if( n <= 2) return 2;\\n        \\n        if(n>=1e7 && n<=1e8) {\\n            n=100030001;\\n        }\\n        \\n        if(n%2==0) n++;\\n        \\n        for(int i=n; i>=n; i+=2){\\n            if(isPalindrome(i)) {\\n                if(isPrime(i)) return i;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool isPrime(int n) {\\n        for(int i=2; i<=sqrt(n);i++) {\\n            if(n%i==0) return 0;\\n        }\\n        return 1;\\n    }\\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    \\n    int isPalindrome(int n){\\n        return n == reverse(n);\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if( n <= 2) return 2;\\n        \\n        if(n>=1e7 && n<=1e8) {\\n            n=100030001;\\n        }\\n        \\n        if(n%2==0) n++;\\n        \\n        for(int i=n; i>=n; i+=2){\\n            if(isPalindrome(i)) {\\n                if(isPrime(i)) return i;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339781,
                "title": "easy-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319724,
                "title": "c",
                "content": "```\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t = s ;\\n            reverse(t.begin(),t.end());  \\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t = s ;\\n            reverse(t.begin(),t.end());  \\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306862,
                "title": "very-basic-approch-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int palindrome(int y){\\n        int sum=0;\\n        int x=y;\\n        while(y){\\n            int a=y%10;\\n            y=y/10;\\n            sum+=a;\\n            if(sum==x){\\n                \\n                return 1;\\n            }\\n            sum*=10;\\n        }\\n        return 0;\\n    }\\n    int prime(int y){\\n        for(int i=2;i<=sqrt(y);i++){\\n            if(y%i==0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int primePalindrome(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        else if(99899*1e2 <= n && n <= 1e8){\\n             return 100030001;\\n        }\\n        else if(n==1){\\n            return n+1;\\n        }\\n        else if(prime(n)&&palindrome(n)){\\n            return n;\\n        }\\n        else {\\n            if(n%2==0){\\n                n+=1;\\n                if(prime(n)&&palindrome(n)){\\n                    return n;\\n                }\\n            } \\n            while(!prime(n) || !palindrome(n)){\\n                if(prime(n+2)&&palindrome(n+2)){\\n                    return n+2;\\n                }\\n                else if(prime(n+4)&&palindrome(n+4)){\\n                    return n+4;\\n                }\\n                else if(prime(n+6)&&palindrome(n+6)){\\n                    return n+6;\\n                }\\n                n=n+8;\\n            }    \\n            \\n\\n        }\\n       \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int palindrome(int y){\\n        int sum=0;\\n        int x=y;\\n        while(y){\\n            int a=y%10;\\n            y=y/10;\\n            sum+=a;\\n            if(sum==x){\\n                \\n                return 1;\\n            }\\n            sum*=10;\\n        }\\n        return 0;\\n    }\\n    int prime(int y){\\n        for(int i=2;i<=sqrt(y);i++){\\n            if(y%i==0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int primePalindrome(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        else if(99899*1e2 <= n && n <= 1e8){\\n             return 100030001;\\n        }\\n        else if(n==1){\\n            return n+1;\\n        }\\n        else if(prime(n)&&palindrome(n)){\\n            return n;\\n        }\\n        else {\\n            if(n%2==0){\\n                n+=1;\\n                if(prime(n)&&palindrome(n)){\\n                    return n;\\n                }\\n            } \\n            while(!prime(n) || !palindrome(n)){\\n                if(prime(n+2)&&palindrome(n+2)){\\n                    return n+2;\\n                }\\n                else if(prime(n+4)&&palindrome(n+4)){\\n                    return n+4;\\n                }\\n                else if(prime(n+6)&&palindrome(n+6)){\\n                    return n+6;\\n                }\\n                n=n+8;\\n            }    \\n            \\n\\n        }\\n       \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301385,
                "title": "solution",
                "content": "# Intuition\\nTo solve this problem, we need to find the smallest prime palindrome greater than or equal to a given number n. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n One approach is to start checking numbers from n and incrementing by 1 until we find a number that is both a palindrome and a prime. We can use helper methods to check whether a number is a palindrome and a prime. Another approach is to exploit the patterns in the problem and optimize the algorithm, such as by narrowing down the search space to odd-digit palindromes and skipping even-length palindromes.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the input value n and the efficiency of the prime and palindrome checking algorithms. In the worst case, we may need to check all numbers up to 10^8, which would take O(10^8) time. However, with the optimizations mentioned earlier, we reduce the search space and improve the performance. The isPalindrome() method takes O(log n) time, since it checks each digit of the number. The isPrime() method takes O(sqrt(n)) time, since it checks all divisors up to the square root of n. Therefore, the overall time complexity is roughly O(n * sqrt(n)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1), since we only need to store a few integer variables. The space used by the helper methods is also O(1), since they don\\'t use any additional data structures.\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n <= 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n++;\\n        }\\n        while (true) {\\n            if (isPalindrome(n) && isPrime(n)) {\\n                return n;\\n            }\\n            n += 2; // only check odd numbers\\n            if (n > 10_000_000 && n < 100_000_000) { // skip even-length palindromes\\n                n = 100_000_001; // jump to next odd-length palindrome\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int num) {\\n        int reversed = 0, remainder, original = num;\\n        while (num != 0) {\\n            remainder = num % 10;\\n            reversed = reversed * 10 + remainder;\\n            num /= 10;\\n        }\\n        return reversed == original;\\n    }\\n    \\n    private boolean isPrime(int num) {\\n        if (num < 2) {\\n            return false;\\n        }\\n        int sqrt = (int) Math.sqrt(num);\\n        for (int i = 2; i <= sqrt; i++) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n <= 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n++;\\n        }\\n        while (true) {\\n            if (isPalindrome(n) && isPrime(n)) {\\n                return n;\\n            }\\n            n += 2; // only check odd numbers\\n            if (n > 10_000_000 && n < 100_000_000) { // skip even-length palindromes\\n                n = 100_000_001; // jump to next odd-length palindrome\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int num) {\\n        int reversed = 0, remainder, original = num;\\n        while (num != 0) {\\n            remainder = num % 10;\\n            reversed = reversed * 10 + remainder;\\n            num /= 10;\\n        }\\n        return reversed == original;\\n    }\\n    \\n    private boolean isPrime(int num) {\\n        if (num < 2) {\\n            return false;\\n        }\\n        int sqrt = (int) Math.sqrt(num);\\n        for (int i = 2; i <= sqrt; i++) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141927,
                "title": "iterating-over-palindromes-c-runtime-beats-100",
                "content": "# Intuition\\nSome points to note:\\n- Far fewer numbers are palindrome than not\\n- Palindromes can easily be generated from their first half (for palindromes of odd length, including their middle digit)\\n- The numerical order of (odd length) palindromes is equal to the order of their first halves. Therefore, it is easy to iterate over all palindromes in ascending order by iterating over their first halves.\\n\\n# Approach\\n`oddPalindrome` generates an odd-length palindrome from the integer representing its first half (inclunding middle digit) by adding the string representation and its reverse, excluding the duplicate middle digit. \\n`IsPrime` is used to check whether the generated number is a prime number.\\n\\n# Complexity\\n- Time complexity:\\nChecking primeness: $$O(\\\\sqrt{n})$$ \\nFinding prime palindrome: Unknown, as palindromes can not be regarded as random integers and therefore, the density of prime palindromes is not equal to that of primes in general.\\n\\n- Space complexity:\\n$$O(log(n))$$, the extra memory increases with the length of the result in decimal representation.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        string Reverse(string text) {\\n            char[] array = text.ToCharArray();\\n            Array.Reverse(array);\\n            return new String(array);\\n        }\\n        int oddPalindrome(int a) {\\n            return int.Parse(a.ToString() + Reverse(a.ToString()).Substring(1));\\n        }\\n        bool isPrime(int a) {\\n            if(a < 2 || a == 9)\\n                return false;\\n            if(a == 2 || a == 3 || a == 5 || a == 7)\\n                return true;\\n            int sqrt = (int)Math.Sqrt(a)+1;\\n            if(a%2 == 0)\\n                return false;\\n            for(int i = 3; i < sqrt; i+=2)\\n            {\\n                if(a%i==0)\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n        if(n >= 8 && n <= 11) // The only numbers resulting in 11, the only palindrome prime with an even number of digtis\\n            return 11;\\n\\n        int x = int.Parse(n.ToString().Substring(0,(n.ToString().Length + 1) / 2) );\\n        while(x < 100000) //some upper limit\\n        {\\n            int p = oddPalindrome(x);\\n            if(p >= n && isPrime(p))\\n                return p;\\n            x++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        string Reverse(string text) {\\n            char[] array = text.ToCharArray();\\n            Array.Reverse(array);\\n            return new String(array);\\n        }\\n        int oddPalindrome(int a) {\\n            return int.Parse(a.ToString() + Reverse(a.ToString()).Substring(1));\\n        }\\n        bool isPrime(int a) {\\n            if(a < 2 || a == 9)\\n                return false;\\n            if(a == 2 || a == 3 || a == 5 || a == 7)\\n                return true;\\n            int sqrt = (int)Math.Sqrt(a)+1;\\n            if(a%2 == 0)\\n                return false;\\n            for(int i = 3; i < sqrt; i+=2)\\n            {\\n                if(a%i==0)\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n        if(n >= 8 && n <= 11) // The only numbers resulting in 11, the only palindrome prime with an even number of digtis\\n            return 11;\\n\\n        int x = int.Parse(n.ToString().Substring(0,(n.ToString().Length + 1) / 2) );\\n        while(x < 100000) //some upper limit\\n        {\\n            int p = oddPalindrome(x);\\n            if(p >= n && isPrime(p))\\n                return p;\\n            x++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060479,
                "title": "kotlin-beats-100-simple-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\nfun primePalindrome(n: Int): Int {\\n            var i = n\\n\\n            while (!isPalindrome(i) || !isPrime(i)) {\\n                i++\\n\\n                if (i in 10000001..99999999)\\n                    i = 100_000_000\\n            }\\n\\n            return i\\n        }\\n\\n        private fun isPrime(number: Int): Boolean {\\n            if (number < 2) return false\\n            if (number <= 3) return true\\n            if (number % 2 == 0 || number % 3 == 0) return false\\n\\n            for (i in 2..Math.sqrt(number.toDouble()).toInt()) {\\n                if (number % i == 0) {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n\\n        private fun isPalindrome(number: Int): Boolean {\\n            return number.toString() == number.toString().reversed()\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\nfun primePalindrome(n: Int): Int {\\n            var i = n\\n\\n            while (!isPalindrome(i) || !isPrime(i)) {\\n                i++\\n\\n                if (i in 10000001..99999999)\\n                    i = 100_000_000\\n            }\\n\\n            return i\\n        }\\n\\n        private fun isPrime(number: Int): Boolean {\\n            if (number < 2) return false\\n            if (number <= 3) return true\\n            if (number % 2 == 0 || number % 3 == 0) return false\\n\\n            for (i in 2..Math.sqrt(number.toDouble()).toInt()) {\\n                if (number % i == 0) {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n\\n        private fun isPalindrome(number: Int): Boolean {\\n            return number.toString() == number.toString().reversed()\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993336,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isPalindrome_(int n)\\n    {\\n        if(n < 10)\\n        {\\n            return true;\\n        }\\n        string a=to_string(n);\\n        int i=0;\\n        int j=a.size()-1;\\n        while(i <= j )\\n        {\\n            if(a[i]!=a[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    bool isPrime(int n)\\n    {\\n        if(n <= 1)\\n        {\\n            return false;\\n        }\\n\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    int primePalindrome(int n) {\\n        if(n==1){return 2;}\\n        if (99899*1e2 <= n && n <= 1e8)\\n        {\\n             return 100030001;\\n        }\\n       \\n        for(long long i=n;i<1e7;i++)\\n        {\\n            if(isPrime(i) && isPalindrome_(i))\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isPalindrome_(int n)\\n    {\\n        if(n < 10)\\n        {\\n            return true;\\n        }\\n        string a=to_string(n);\\n        int i=0;\\n        int j=a.size()-1;\\n        while(i <= j )\\n        {\\n            if(a[i]!=a[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    bool isPrime(int n)\\n    {\\n        if(n <= 1)\\n        {\\n            return false;\\n        }\\n\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    int primePalindrome(int n) {\\n        if(n==1){return 2;}\\n        if (99899*1e2 <= n && n <= 1e8)\\n        {\\n             return 100030001;\\n        }\\n       \\n        for(long long i=n;i<1e7;i++)\\n        {\\n            if(isPrime(i) && isPalindrome_(i))\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983531,
                "title": "100-fastest-and-easiest-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (n == palindrome(n) && prime(n))\\n                return n;\\n            n++;\\n            if (10_000_000 < n && n < 100_000_000)\\n                n= 100_000_000;\\n        }\\n    }\\n    public boolean prime(int n) {\\n        if (n < 2)\\n        {\\n            return false;\\n        } \\n        int r = (int) Math.sqrt(n);\\n        for (int i = 2; i <= r; ++i)\\n        {\\n            if (n % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int palindrome(int n) {\\n        int r = 0;\\n        while (n > 0) \\n        {\\n            int c=n%10;\\n            r=r*10+c;\\n            n/= 10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (n == palindrome(n) && prime(n))\\n                return n;\\n            n++;\\n            if (10_000_000 < n && n < 100_000_000)\\n                n= 100_000_000;\\n        }\\n    }\\n    public boolean prime(int n) {\\n        if (n < 2)\\n        {\\n            return false;\\n        } \\n        int r = (int) Math.sqrt(n);\\n        for (int i = 2; i <= r; ++i)\\n        {\\n            if (n % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int palindrome(int n) {\\n        int r = 0;\\n        while (n > 0) \\n        {\\n            int c=n%10;\\n            r=r*10+c;\\n            n/= 10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965600,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn prime_palindrome(n: i32) -> i32 {\\n        fn is_prime(n: i32) -> bool {\\n            if n == 1 {\\n                return false;\\n            }\\n            for i in 2..=(n as f64).sqrt() as i32 {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        let n_str = n.to_string();\\n        let len = n_str.len() as i32;\\n\\n        for k in std::cmp::max(0, len / 2 - 1)..5 {\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if k > 0 && \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().skip(1).collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prime_palindrome(n: i32) -> i32 {\\n        fn is_prime(n: i32) -> bool {\\n            if n == 1 {\\n                return false;\\n            }\\n            for i in 2..=(n as f64).sqrt() as i32 {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        let n_str = n.to_string();\\n        let len = n_str.len() as i32;\\n\\n        for k in std::cmp::max(0, len / 2 - 1)..5 {\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if k > 0 && \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().skip(1).collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950329,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924931,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891591,
                "title": "java-it-s-easy-solution-but-low-speed-took-it-n-n-from-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic static boolean getPalindrome(String  candidateForSearch) {\\n        char[] charFromString = candidateForSearch.toCharArray();\\n        for (int i = 0; i < charFromString.length; i++) {\\n            if (charFromString[i] != charFromString[charFromString.length - 1 - i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static int primePalindrome(int n) {\\n        int secondNumber = n + 2;\\n        int countDivider = 0;\\n        boolean endNumber;\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n = n+1;\\n        }\\n\\n        for ( ; n <= secondNumber; n+=2 ) {\\n            if (10000000 < n && n < 100000000) {\\n                n = 99999999;\\n                secondNumber = n + 2;\\n            }\\n            String exchangeFromInteger = String.valueOf(n);\\n            endNumber = getPalindrome(exchangeFromInteger);\\n            if (!endNumber) {\\n                secondNumber+=2;\\n                continue;\\n            }\\n            for (int i = 3; i < n ; i+=2) {\\n                if (n % i == 0) {\\n                    countDivider++;\\n                    break;\\n                }\\n            }\\n            if (countDivider == 0) {\\n                return n; //\\n            }\\n\\n            countDivider = 0;\\n            secondNumber+=2;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic static boolean getPalindrome(String  candidateForSearch) {\\n        char[] charFromString = candidateForSearch.toCharArray();\\n        for (int i = 0; i < charFromString.length; i++) {\\n            if (charFromString[i] != charFromString[charFromString.length - 1 - i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static int primePalindrome(int n) {\\n        int secondNumber = n + 2;\\n        int countDivider = 0;\\n        boolean endNumber;\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n = n+1;\\n        }\\n\\n        for ( ; n <= secondNumber; n+=2 ) {\\n            if (10000000 < n && n < 100000000) {\\n                n = 99999999;\\n                secondNumber = n + 2;\\n            }\\n            String exchangeFromInteger = String.valueOf(n);\\n            endNumber = getPalindrome(exchangeFromInteger);\\n            if (!endNumber) {\\n                secondNumber+=2;\\n                continue;\\n            }\\n            for (int i = 3; i < n ; i+=2) {\\n                if (n % i == 0) {\\n                    countDivider++;\\n                    break;\\n                }\\n            }\\n            if (countDivider == 0) {\\n                return n; //\\n            }\\n\\n            countDivider = 0;\\n            secondNumber+=2;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831041,
                "title": "o-1-solution",
                "content": "# Intuition\\n##### We know there are pretty limited number of prim numbers in a  range, and palindromes are also rare , so , primepalindrome are even rarer...\\n##### we can just precompute the prime Palindromes and then Find the lowerbound of whatever number is asked in the testcase .\\n##### I have attached program I used to generate the list.\\n\\n# Code\\n```\\nclass Solution {\\npublic :\\nconst vector<int> pp = { 2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001} ;\\n\\n    int primePalindrome(int n) {\\n        auto lb = lower_bound(pp.begin() , pp.end() , n ) ;\\n        if( lb != pp.end()) return *lb ;\\n        return 0 ;\\n    }\\n};\\n```\\n# This is the code that I used to geneerate the primepalindrome list.\\n\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nbool isPalindrome(int n)\\n{\\n    string s = to_string(n);\\n    int l = 0, r = s.length() - 1;\\n    while (l <= r)\\n    {\\n        if (s[l] == s[r])\\n            l++, r--;\\n        else\\n            return false;\\n    }\\n    return true;\\n}\\nvoid generatePrimePalindrome()\\n{\\n    vector<int> primePalindromes;\\n    int rr = 2 * 1e8; // this range is not quite needed , as the next prime palindrome after 1e8 is 100030001. and there is no need to find more of them.\\n    vector<bool> notprime(rr + 1);\\n\\n    for (int i = 2; i * i <= rr; i++)\\n    {\\n        for (int j = 2; i * j <= rr; j++)\\n        {\\n            notprime[i * j] = true;\\n        }\\n    }\\n\\n    for (int i = 2; i <= rr; i++)\\n    {\\n        if (!notprime[i] and isPalindrome(i))\\n            primePalindromes.push_back(i);\\n    }\\n    for (auto pp : primePalindromes)\\n    {\\n        cout << pp << \",\";\\n    }\\n\\n}\\n\\nint main()\\n{\\n    generatePrimePalindrome();\\n    return 0;\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic :\\nconst vector<int> pp = { 2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001} ;\\n\\n    int primePalindrome(int n) {\\n        auto lb = lower_bound(pp.begin() , pp.end() , n ) ;\\n        if( lb != pp.end()) return *lb ;\\n        return 0 ;\\n    }\\n};\\n```\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nbool isPalindrome(int n)\\n{\\n    string s = to_string(n);\\n    int l = 0, r = s.length() - 1;\\n    while (l <= r)\\n    {\\n        if (s[l] == s[r])\\n            l++, r--;\\n        else\\n            return false;\\n    }\\n    return true;\\n}\\nvoid generatePrimePalindrome()\\n{\\n    vector<int> primePalindromes;\\n    int rr = 2 * 1e8; // this range is not quite needed , as the next prime palindrome after 1e8 is 100030001. and there is no need to find more of them.\\n    vector<bool> notprime(rr + 1);\\n\\n    for (int i = 2; i * i <= rr; i++)\\n    {\\n        for (int j = 2; i * j <= rr; j++)\\n        {\\n            notprime[i * j] = true;\\n        }\\n    }\\n\\n    for (int i = 2; i <= rr; i++)\\n    {\\n        if (!notprime[i] and isPalindrome(i))\\n            primePalindromes.push_back(i);\\n    }\\n    for (auto pp : primePalindromes)\\n    {\\n        cout << pp << \",\";\\n    }\\n\\n}\\n\\nint main()\\n{\\n    generatePrimePalindrome();\\n    return 0;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2710531,
                "title": "easy-java-solution-all-even-length-pallindrome-are-divisble-by-11",
                "content": "class Solution {\\n    public Boolean isPrime(int n){\\n          if(n < 2 || n % 2 == 0){\\n            return n == 2;\\n        }\\n        for(int i = 3;i*i <= n;i++){\\n            if(n % i == 0)\\n               return false;\\n        }\\n        return true;\\n    }\\n    public int primePalindrome(int n) {\\n        if(n >= 8 && n <= 11)\\n            return 11;\\n         for (int i = 1; i < 100000; i++) {\\n            String s = Integer.toString(i);\\n            String r = new StringBuilder(s).reverse().toString(); \\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= n && isPrime(y)) \\n                return y;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public Boolean isPrime(int n){\\n          if(n < 2 || n % 2 == 0){\\n            return n == 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2699888,
                "title": "python3-generating-palindromes-neglecting-4-6-8-digit-palindromes-checking-for-prime",
                "content": "class Solution:\\n\\n    def primePalindrome(self, n: int) -> int:\\n        def nextPalindrome(x):\\n            lenX = len(x)\\n            n = lenX//2\\n            for i in range(n,lenX):\\n                if int(x[i])+1<10:\\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for j in range(n,i):\\n                        x[j] = x[~j] = \\'0\\'\\n                    return x\\n            return [\\'1\\']+[\\'0\\']*(lenX-1)+[\\'1\\']               \\n        \\n        def isPrime(x):\\n            if x == 1:\\n                return False\\n            if x == 2:\\n                return True\\n            ul = int(sqrt(x)) + 1\\n            for i in range(2,ul):\\n                if x%i==0:\\n                    return False\\n            return True\\n        \\n        x = [\"0\"]\\n        invalidLengths = {4,6,8}\\n        \\n        while True:\\n            x = nextPalindrome(x)\\n            intX = int(\\'\\'.join(x))\\n            if len(x) not in invalidLengths and intX>=n:\\n                if isPrime(intX):\\n                    return intX",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def primePalindrome(self, n: int) -> int:\\n        def nextPalindrome(x):\\n            lenX = len(x)\\n            n = lenX//2\\n            for i in range(n,lenX):\\n                if int(x[i])+1<10:\\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for j in range(n,i):\\n                        x[j] = x[~j] = \\'0\\'\\n                    return x\\n            return [\\'1\\']+[\\'0\\']*(lenX-1)+[\\'1\\']               \\n        \\n        def isPrime(x):\\n            if x == 1:\\n                return False\\n            if x == 2:\\n                return True\\n            ul = int(sqrt(x)) + 1\\n            for i in range(2,ul):\\n                if x%i==0:\\n                    return False\\n            return True\\n        \\n        x = [\"0\"]\\n        invalidLengths = {4,6,8}",
                "codeTag": "Java"
            },
            {
                "id": 2673013,
                "title": "my-simple-python3-solution",
                "content": "For me, the main insight that fixed the excessive computation time for my code was this line: if 10\\\\**7 < n < 10**8 (which was taken from the formal solution). \\n\\nRuntime: 644 ms  (Beats 15%)\\nMemory : 13.9 MB (Beats 77.14%)\\n\\n# Code\\n```\\ndef isPalindrome(m:int) -> bool:\\n    mstr = list(str(m))\\n    return mstr == mstr[::-1]\\n\\ndef isPrime(m:int):\\n    if 1==m:\\n        return False\\n    elif 2==m:\\n        return True\\n        \\n    for k in range(2, 1+int(m**0.5)):\\n        if 0 == m % k:\\n            return False\\n    return True\\n\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n                \\n        OK = True\\n        while OK:\\n            if 10**7 < n < 10**8:  \\n                # Any even length palindrome must be divisble by 11\\n                # so we will skip numbers N = [10,000,000, 99,999,999]                \\n                n = 10**8\\n                                \\n            if (isPalindrome(n) and isPrime(n)):\\n                OK = False\\n            else:\\n                n = n + 1\\n\\n        return int(n)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(m:int) -> bool:\\n    mstr = list(str(m))\\n    return mstr == mstr[::-1]\\n\\ndef isPrime(m:int):\\n    if 1==m:\\n        return False\\n    elif 2==m:\\n        return True\\n        \\n    for k in range(2, 1+int(m**0.5)):\\n        if 0 == m % k:\\n            return False\\n    return True\\n\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n                \\n        OK = True\\n        while OK:\\n            if 10**7 < n < 10**8:  \\n                # Any even length palindrome must be divisble by 11\\n                # so we will skip numbers N = [10,000,000, 99,999,999]                \\n                n = 10**8\\n                                \\n            if (isPalindrome(n) and isPrime(n)):\\n                OK = False\\n            else:\\n                n = n + 1\\n\\n        return int(n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618816,
                "title": "o-n-time-o-1-space-clear-explanation-only-odd-palindromes",
                "content": "![image](https://assets.leetcode.com/users/images/a5d25f3f-530d-455d-8405-a2a6127c40ec_1664034864.259861.png)\\n\\n\\n    def primePalindrome(self, n: int) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        if n <= 1:\\n            return 2 # 2 is the first prime number\\n\\n        if 8 <= n <= 11:\\n            return 11 # 11 is only one even palindrome\\n\\n        for i in range(1, 90000):\\n            if (j := int(str(i)[:-1] + str(i)[::-1])) >= n and not any(j % d == 0 for d in range(2, math.isqrt(j) + 1)):\\n                return j",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/a5d25f3f-530d-455d-8405-a2a6127c40ec_1664034864.259861.png)\\n\\n\\n    def primePalindrome(self, n: int) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        if n <= 1:\\n            return 2 # 2 is the first prime number\\n\\n        if 8 <= n <= 11:\\n            return 11 # 11 is only one even palindrome\\n\\n        for i in range(1, 90000):\\n            if (j := int(str(i)[:-1] + str(i)[::-1])) >= n and not any(j % d == 0 for d in range(2, math.isqrt(j) + 1)):\\n                return j",
                "codeTag": "Python3"
            },
            {
                "id": 2567161,
                "title": "php-solution",
                "content": "```\\nclass Solution\\n{\\n    /**\\n     * @param int $n\\n     * @return int\\n     */\\n    function primePalindrome(int $n): int {\\n        while (true) {\\n            if ($n > 11 && strlen((string)$n) % 2 === 0) {\\n                $n = pow(10, ceil(log10($n + 1)));\\n                continue;\\n            }\\n\\n            if ($this->isPalindrome($n) && $this->isPrime($n)) {\\n                break;\\n            }\\n\\n            $n++;\\n        }\\n\\n        return $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPalindrome(int $n): bool\\n    {\\n        return (int)strrev((string)$n) === $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPrime(int $n): bool {\\n        if ($n <= 3) {\\n            if ($n <= 1) {\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        if ($n % 2 === 0 || $n % 3 === 0) {\\n            return false;\\n        }\\n\\n        for ($i = 3;  pow($i, 2) <= $n; $i += 2) {\\n            if ($n % $i === 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n    /**\\n     * @param int $n\\n     * @return int\\n     */\\n    function primePalindrome(int $n): int {\\n        while (true) {\\n            if ($n > 11 && strlen((string)$n) % 2 === 0) {\\n                $n = pow(10, ceil(log10($n + 1)));\\n                continue;\\n            }\\n\\n            if ($this->isPalindrome($n) && $this->isPrime($n)) {\\n                break;\\n            }\\n\\n            $n++;\\n        }\\n\\n        return $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPalindrome(int $n): bool\\n    {\\n        return (int)strrev((string)$n) === $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPrime(int $n): bool {\\n        if ($n <= 3) {\\n            if ($n <= 1) {\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        if ($n % 2 === 0 || $n % 3 === 0) {\\n            return false;\\n        }\\n\\n        for ($i = 3;  pow($i, 2) <= $n; $i += 2) {\\n            if ($n % $i === 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519791,
                "title": "c-ispalindrome-and-prime-check-easy",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        bool isPrime(int n)\\n        {\\n            if (n <= 1) return false;\\n            if (n <= 3) return true;\\n            if (n % 2 == 0 || n % 3 == 0) return false;\\n            for (int i = 5; i * i <= n; i = i + 6)\\n                if (n % i == 0 || n % (i + 2) == 0) return false;\\n            return true;\\n        }\\n\\n    bool isPalindrome(string S)\\n    {\\n        string P = S;\\n        reverse(P.begin(), P.end());\\n        if (S == P)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int primePalindrome(int n)\\n    {\\n        if (99899 * 1e2 <= n && n <= 1e8)\\n            return 100030001;\\n        for (int j = n; j < 1e8; j++)\\n        {\\n            if (isPrime(j))\\n            {\\n                if (isPalindrome(to_string(j)))\\n                    {\\n                        return j;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n    };\\n```\\n**If helpful Please Like Or Upvoke**",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool isPrime(int n)\\n        {\\n            if (n <= 1) return false;\\n            if (n <= 3) return true;\\n            if (n % 2 == 0 || n % 3 == 0) return false;\\n            for (int i = 5; i * i <= n; i = i + 6)\\n                if (n % i == 0 || n % (i + 2) == 0) return false;\\n            return true;\\n        }\\n\\n    bool isPalindrome(string S)\\n    {\\n        string P = S;\\n        reverse(P.begin(), P.end());\\n        if (S == P)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int primePalindrome(int n)\\n    {\\n        if (99899 * 1e2 <= n && n <= 1e8)\\n            return 100030001;\\n        for (int j = n; j < 1e8; j++)\\n        {\\n            if (isPrime(j))\\n            {\\n                if (isPalindrome(to_string(j)))\\n                    {\\n                        return j;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465618,
                "title": "javascript-easy-solution",
                "content": "\\n\\n```\\nvar primePalindrome = function(n) {\\n    let i ;\\n    if (n == 1 || n ==2) return 2;\\n    if(n%2 == 0) i = n+1;\\n    else         i=n;\\n    while (true) {\\n        if ( isPalind(i) && isPrime(i) ) {\\n            return i;\\n        }\\n        i+=2\\n        if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n        if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n        if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n        if(i > 11 && i < 100) i = 101;\\n    }\\n    return -1;\\n};//9989900\\n\\n\\n\\nfunction isPrime(num) {\\n    for ( var i = 2; i < num; i++ ) {\\n        if ( num % i === 0 ) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nfunction isPalind(n){\\n    return  n.toString() === n.toString().split(\"\").reverse().join(\"\");\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar primePalindrome = function(n) {\\n    let i ;\\n    if (n == 1 || n ==2) return 2;\\n    if(n%2 == 0) i = n+1;\\n    else         i=n;\\n    while (true) {\\n        if ( isPalind(i) && isPrime(i) ) {\\n            return i;\\n        }\\n        i+=2\\n        if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n        if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n        if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n        if(i > 11 && i < 100) i = 101;\\n    }\\n    return -1;\\n};//9989900\\n\\n\\n\\nfunction isPrime(num) {\\n    for ( var i = 2; i < num; i++ ) {\\n        if ( num % i === 0 ) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nfunction isPalind(n){\\n    return  n.toString() === n.toString().split(\"\").reverse().join(\"\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464988,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPal(int n){\\n        int rev = 0;\\n        int temp = n;\\n        while(temp!=0){\\n            int ld = temp%10;\\n            rev = rev*10+ld;\\n            temp /=10;\\n        }\\n        return (rev==n);\\n    }\\n    \\n    bool isPrime(int n){\\n        if(n==1) return false;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPal(i) and isPrime(i)) \\n                return i;\\n            i += 2; // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// Any even length palindrome must be divisble by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(int n){\\n        int rev = 0;\\n        int temp = n;\\n        while(temp!=0){\\n            int ld = temp%10;\\n            rev = rev*10+ld;\\n            temp /=10;\\n        }\\n        return (rev==n);\\n    }\\n    \\n    bool isPrime(int n){\\n        if(n==1) return false;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPal(i) and isPrime(i)) \\n                return i;\\n            i += 2; // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// Any even length palindrome must be divisble by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423771,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    \\n    int count_digits(int N){\\n        int count = 0;\\n        do{\\n            N /= 10;\\n            count++;\\n        }while(N);\\n        return count;\\n    }\\n    \\n    int is_prime(int N){\\n        int i = 2;\\n        while(i * i <= N){\\n            if(N % i == 0) return false;\\n            ++i;\\n        }\\n        return i;\\n    }\\n    \\n    void gen(string& str, int idx, int min){\\n        if(idx > str.size()/2){\\n            int val = stoi(str);\\n            if(val >= min && is_prime(val)) ans = val;\\n            return;\\n        };\\n        for(int i = 0; i <= 9 && ans == -1; ++i){\\n            str[idx] = str[str.size() - idx - 1] = (\\'0\\' + i);\\n            gen(str, idx + 1, min);\\n        }\\n    }\\n    int primePalindrome(int N) {\\n        N = max(2, N);  \\n        int cd = count_digits(N);\\n        while(ans == -1){\\n            string s(cd, \\' \\');\\n            gen(s, 0, N);\\n            cd++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    \\n    int count_digits(int N){\\n        int count = 0;\\n        do{\\n            N /= 10;\\n            count++;\\n        }while(N);\\n        return count;\\n    }\\n    \\n    int is_prime(int N){\\n        int i = 2;\\n        while(i * i <= N){\\n            if(N % i == 0) return false;\\n            ++i;\\n        }\\n        return i;\\n    }\\n    \\n    void gen(string& str, int idx, int min){\\n        if(idx > str.size()/2){\\n            int val = stoi(str);\\n            if(val >= min && is_prime(val)) ans = val;\\n            return;\\n        };\\n        for(int i = 0; i <= 9 && ans == -1; ++i){\\n            str[idx] = str[str.size() - idx - 1] = (\\'0\\' + i);\\n            gen(str, idx + 1, min);\\n        }\\n    }\\n    int primePalindrome(int N) {\\n        N = max(2, N);  \\n        int cd = count_digits(N);\\n        while(ans == -1){\\n            string s(cd, \\' \\');\\n            gen(s, 0, N);\\n            cd++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326905,
                "title": "c-100",
                "content": "```\\npublic class Solution {\\npublic int PrimePalindrome(int n)\\n    {\\n       int result = 0;\\n        int flag1 = 1;\\n        int flag2 = 1;\\n        int max1stList = 1;\\n        int max2ndList = 1;\\n        for (int j = 0; j < 2; j++)\\n        {\\n            result = 0;\\n            int i = 1;\\n            do\\n            {\\n                result = CreatePalindrome(i++, 10, j % 2);\\n                if (result >= n)\\n                {\\n                    if (j == 0)\\n                    {\\n                        max1stList = result;\\n                        flag1 = i - 1;\\n                    }\\n                    if (j == 1)\\n                    {\\n                        max2ndList = result;\\n                        flag2 = i - 1;\\n                    }\\n                    break;\\n                }\\n            } while (true);\\n        }\\n\\n        for (int j = 0; j < 2; j++)\\n        {\\n            do\\n            {\\n                if (max1stList > max2ndList)\\n                {\\n                    int l = flag2;\\n                    while ((result = CreatePalindrome(l++, 10, 1)) < max1stList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max1stList)) return max1stList;\\n                }\\n                else if (max1stList < max2ndList)\\n                {\\n                    int l = flag1;\\n                    while ((result = CreatePalindrome(l++, 10, 0)) < max2ndList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max2ndList)) return max2ndList;\\n                }\\n                \\n                if (j == 0)\\n                {\\n                    result = CreatePalindrome(++flag1, 10, j % 2);\\n                    max1stList = result;\\n                }\\n                if (j == 1)\\n                {\\n                    result = CreatePalindrome(++flag2, 10, j % 2);\\n                    max2ndList = result;\\n                    j = -1;\\n                }\\n                break;\\n            } while (true);\\n        }\\n        return 0;\\n    }\\n    \\n    public bool IsPrime(int n)\\n    {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n\\n        // This is checked so that we can skip\\n        // middle five numbers in below loop\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0) return false;\\n\\n        return true;\\n    }\\n    \\n    public int CreatePalindrome(int input, int b, int isOdd)\\n    {\\n        int n = input;\\n        int palin = input;\\n\\n        if (isOdd == 1)\\n            n /= b;\\n\\n        // Creates palindrome by just appending\\n        // reverse of number to itself\\n        while (n > 0)\\n        {\\n            palin = palin * b + (n % b);\\n            n /= b;\\n        }\\n        return palin;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\npublic int PrimePalindrome(int n)\\n    {\\n       int result = 0;\\n        int flag1 = 1;\\n        int flag2 = 1;\\n        int max1stList = 1;\\n        int max2ndList = 1;\\n        for (int j = 0; j < 2; j++)\\n        {\\n            result = 0;\\n            int i = 1;\\n            do\\n            {\\n                result = CreatePalindrome(i++, 10, j % 2);\\n                if (result >= n)\\n                {\\n                    if (j == 0)\\n                    {\\n                        max1stList = result;\\n                        flag1 = i - 1;\\n                    }\\n                    if (j == 1)\\n                    {\\n                        max2ndList = result;\\n                        flag2 = i - 1;\\n                    }\\n                    break;\\n                }\\n            } while (true);\\n        }\\n\\n        for (int j = 0; j < 2; j++)\\n        {\\n            do\\n            {\\n                if (max1stList > max2ndList)\\n                {\\n                    int l = flag2;\\n                    while ((result = CreatePalindrome(l++, 10, 1)) < max1stList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max1stList)) return max1stList;\\n                }\\n                else if (max1stList < max2ndList)\\n                {\\n                    int l = flag1;\\n                    while ((result = CreatePalindrome(l++, 10, 0)) < max2ndList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max2ndList)) return max2ndList;\\n                }\\n                \\n                if (j == 0)\\n                {\\n                    result = CreatePalindrome(++flag1, 10, j % 2);\\n                    max1stList = result;\\n                }\\n                if (j == 1)\\n                {\\n                    result = CreatePalindrome(++flag2, 10, j % 2);\\n                    max2ndList = result;\\n                    j = -1;\\n                }\\n                break;\\n            } while (true);\\n        }\\n        return 0;\\n    }\\n    \\n    public bool IsPrime(int n)\\n    {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n\\n        // This is checked so that we can skip\\n        // middle five numbers in below loop\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0) return false;\\n\\n        return true;\\n    }\\n    \\n    public int CreatePalindrome(int input, int b, int isOdd)\\n    {\\n        int n = input;\\n        int palin = input;\\n\\n        if (isOdd == 1)\\n            n /= b;\\n\\n        // Creates palindrome by just appending\\n        // reverse of number to itself\\n        while (n > 0)\\n        {\\n            palin = palin * b + (n % b);\\n            n /= b;\\n        }\\n        return palin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282027,
                "title": "no-math-all-logic-python",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n<3:return 2\\n\\t\\t#generating palindrome less than 10**8\\n        l=[\"\"]+[*\"1234567890\"]\\n        for i in l:\\n            if len(i)<7:\\n                for j in \"1234567890\":\\n                    l+=[j+i+j]\\n\\t\\t#finding prime from generated palindrome\\n        q=[]\\n        for i in l[2:]:\\n            if i[0]!=\"0\":\\n                i=int(i)\\n                t=i%2\\n                if t:\\n                    for j in range(3,int(i**.5)+1,2):\\n                        if i%j==0:\\n                            t=0\\n                            break\\n                if t:q+=[i]\\n        q.sort()\\n        q+=[100030001]\\n        return q[bisect_left(q,n)]",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n<3:return 2\\n\\t\\t#generating palindrome less than 10**8\\n        l=[\"\"]+[*\"1234567890\"]\\n        for i in l:\\n            if len(i)<7:\\n                for j in \"1234567890\":\\n                    l+=[j+i+j]\\n\\t\\t#finding prime from generated palindrome\\n        q=[]\\n        for i in l[2:]:\\n            if i[0]!=\"0\":\\n                i=int(i)\\n                t=i%2\\n                if t:\\n                    for j in range(3,int(i**.5)+1,2):\\n                        if i%j==0:\\n                            t=0\\n                            break\\n                if t:q+=[i]\\n        q.sort()\\n        q+=[100030001]\\n        return q[bisect_left(q,n)]",
                "codeTag": "Java"
            },
            {
                "id": 2259031,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int n) \\n    {\\n       while(true)\\n       {\\n            if(palindrome(n) && prime(n))\\n            {\\n                return n;\\n            }\\n            n++;\\n            if (n > 10_000_000  && n < 100_000_000)\\n            {\\n                n = 100_000_001;\\n            }\\n       }  \\n    }\\n    \\n    public static boolean prime(int no)\\n    {\\n        boolean flag = false;\\n        if(no == 0 || no == 1)\\n        {\\n            return flag;\\n        }\\n        for(int i = 2 ; i <= no / 2 ; i++)\\n        {\\n            if(no % i == 0)\\n            {\\n                return flag;\\n            }\\n        }\\n        if(!flag)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public static boolean palindrome(int no)\\n    {\\n        int rem = 0 ;\\n        int rev = 0 ;\\n        int temp = no;\\n        while(no != 0)\\n        {\\n            rem = no % 10 ;\\n            rev = (rev * 10) + rem ;\\n            no = no / 10;\\n        }\\n        if(temp == rev)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) \\n    {\\n       while(true)\\n       {\\n            if(palindrome(n) && prime(n))\\n            {\\n                return n;\\n            }\\n            n++;\\n            if (n > 10_000_000  && n < 100_000_000)\\n            {\\n                n = 100_000_001;\\n            }\\n       }  \\n    }\\n    \\n    public static boolean prime(int no)\\n    {\\n        boolean flag = false;\\n        if(no == 0 || no == 1)\\n        {\\n            return flag;\\n        }\\n        for(int i = 2 ; i <= no / 2 ; i++)\\n        {\\n            if(no % i == 0)\\n            {\\n                return flag;\\n            }\\n        }\\n        if(!flag)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public static boolean palindrome(int no)\\n    {\\n        int rem = 0 ;\\n        int rev = 0 ;\\n        int temp = no;\\n        while(no != 0)\\n        {\\n            rem = no % 10 ;\\n            rev = (rev * 10) + rem ;\\n            no = no / 10;\\n        }\\n        if(temp == rev)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207599,
                "title": "2-different-java-solution",
                "content": "### 68ms runtime.\\n\\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n### Time Limit Exceeded.\\n\\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (isPrime(n) && isPalindrome(n)) {\\n                return n;\\n            }\\n            n++;\\n        }       \\n    }\\n    private boolean isPrime(int n) {\\n        if (n == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPalindrome(int n) {\\n        String s = String.valueOf(n);\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (isPrime(n) && isPalindrome(n)) {\\n                return n;\\n            }\\n            n++;\\n        }       \\n    }\\n    private boolean isPrime(int n) {\\n        if (n == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPalindrome(int n) {\\n        String s = String.valueOf(n);\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190884,
                "title": "prime-palindrome-java-easy-solution-brute-force",
                "content": "class Solution {\\n    public int primePalindrome(int n) {\\n        //corner case :)\\n        if(n >= 9989900 && n < 100030001){\\n            return 100030001;\\n        }\\n        for(int i = n;i <= (int)2*Math.pow(10,8);i++){\\n            if(isPrime(i) && isPalindrome(i)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        if (n == 2) {\\n            return true;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n) + 1; i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPalindrome(int n)\\n    {\\n          \\n        // Find reverse of n\\n        int rev = 0;\\n        for (int i = n; i > 0; i /= 10)\\n            rev = rev * 10 + i % 10;\\n              \\n        // If n and rev are same, \\n        // then n is palindrome\\n        return(n == rev) ? true : false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int primePalindrome(int n) {\\n        //corner case :)\\n        if(n >= 9989900 && n < 100030001){\\n            return 100030001;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2161839,
                "title": "javascript-easy-to-understand-explained-in-comments",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function (n) {\\n  if (n < 3) return 2\\n\\n  // iterator for next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\u7684\\u8FED\\u4EE3\\u5668\\n  let it = nextPalindrome(n)\\n\\n  while (true) {\\n    let num = it.next().value // next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n    if (isPrime(num)) return num // is prime and return | \\u5982\\u679C\\u662F\\u8D28\\u6570\\u5219\\u8FD4\\u56DE\\n  }\\n\\n  /**\\n   * is prime | \\u5224\\u65AD\\u8D28\\u6570\\n   * @param {number} n \\n   * @returns {boolean} \\n   */\\n  function isPrime(n) {\\n    if (n % 2 === 0) return false\\n    for (let i = 3; i < n / 2; i += 2) {\\n      if (n % i === 0) return false\\n    }\\n    return true\\n  }\\n\\n  /**\\n   * next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n   * @param {number} n\\n   */\\n  function* nextPalindrome(n) {\\n    // \\u627E\\u5230\\u4E00\\u534A\\u957F\\u5EA6\\u7684\\u6570\\u5B57\\uFF0C371=>37, 3772=>7, find first half number \\n    let length = (\\'\\' + n).length \\n    let halfLength = Math.floor(length / 2) \\n    let halfNum = Math.floor(n / Math.pow(10, halfLength))\\n\\n    // \\u53EF\\u80FDn\\u5C31\\u662F\\u5BF9\\u79F0\\u7684 | case n is palindrome\\n    let first = half2full(halfNum, halfLength)\\n    if (first >= n) yield first\\n\\n    // \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n    while (true) yield nextNum()\\n\\n    /**\\n     * \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n     * @returns {number}\\n     */\\n    function nextNum() {\\n      // 37(3)=>38(3)\\uFF0C37(73)=>38(83)\\n      halfNum++\\n\\n      // 9=>11 (9=>10(/10)=>1=>1(1))\\n      // 99=>1001 (9=>10=>10(01))\\n      if (Math.log10(halfNum) % 1 === 0) {\\n        if (length % 2) halfNum /= 10\\n        length++\\n        halfLength = Math.floor(length / 2)\\n      }\\n\\n      // 37=>373 | 37=>3773  \\n      return half2full(halfNum, halfLength)\\n    }\\n\\n    function half2full(halfNum, halfLength) {\\n      return halfNum * Math.pow(10, halfLength) + getReversed(halfNum, halfLength)\\n\\n      function getReversed(num, length) {\\n        let arr = []\\n        while (num) {\\n          let v = num % 10\\n          num -= v\\n          num /= 10\\n          arr.push(v)\\n        }\\n        let rtn = 0\\n        for (let i = 0; i < length; i++) {\\n          rtn *= 10\\n          rtn += arr[arr.length - length + i]\\n        }\\n        return rtn\\n      }\\n    }\\n  }\\n};\\n\\nconsole.log(primePalindrome(1)) //2\\nconsole.log(primePalindrome(2)) //2\\nconsole.log(primePalindrome(3)) //3\\nconsole.log(primePalindrome(4)) //5\\n\\nconsole.log(primePalindrome(6)) //7\\nconsole.log(primePalindrome(8)) //11\\nconsole.log(primePalindrome(13)) //101\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function (n) {\\n  if (n < 3) return 2\\n\\n  // iterator for next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\u7684\\u8FED\\u4EE3\\u5668\\n  let it = nextPalindrome(n)\\n\\n  while (true) {\\n    let num = it.next().value // next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n    if (isPrime(num)) return num // is prime and return | \\u5982\\u679C\\u662F\\u8D28\\u6570\\u5219\\u8FD4\\u56DE\\n  }\\n\\n  /**\\n   * is prime | \\u5224\\u65AD\\u8D28\\u6570\\n   * @param {number} n \\n   * @returns {boolean} \\n   */\\n  function isPrime(n) {\\n    if (n % 2 === 0) return false\\n    for (let i = 3; i < n / 2; i += 2) {\\n      if (n % i === 0) return false\\n    }\\n    return true\\n  }\\n\\n  /**\\n   * next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n   * @param {number} n\\n   */\\n  function* nextPalindrome(n) {\\n    // \\u627E\\u5230\\u4E00\\u534A\\u957F\\u5EA6\\u7684\\u6570\\u5B57\\uFF0C371=>37, 3772=>7, find first half number \\n    let length = (\\'\\' + n).length \\n    let halfLength = Math.floor(length / 2) \\n    let halfNum = Math.floor(n / Math.pow(10, halfLength))\\n\\n    // \\u53EF\\u80FDn\\u5C31\\u662F\\u5BF9\\u79F0\\u7684 | case n is palindrome\\n    let first = half2full(halfNum, halfLength)\\n    if (first >= n) yield first\\n\\n    // \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n    while (true) yield nextNum()\\n\\n    /**\\n     * \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n     * @returns {number}\\n     */\\n    function nextNum() {\\n      // 37(3)=>38(3)\\uFF0C37(73)=>38(83)\\n      halfNum++\\n\\n      // 9=>11 (9=>10(/10)=>1=>1(1))\\n      // 99=>1001 (9=>10=>10(01))\\n      if (Math.log10(halfNum) % 1 === 0) {\\n        if (length % 2) halfNum /= 10\\n        length++\\n        halfLength = Math.floor(length / 2)\\n      }\\n\\n      // 37=>373 | 37=>3773  \\n      return half2full(halfNum, halfLength)\\n    }\\n\\n    function half2full(halfNum, halfLength) {\\n      return halfNum * Math.pow(10, halfLength) + getReversed(halfNum, halfLength)\\n\\n      function getReversed(num, length) {\\n        let arr = []\\n        while (num) {\\n          let v = num % 10\\n          num -= v\\n          num /= 10\\n          arr.push(v)\\n        }\\n        let rtn = 0\\n        for (let i = 0; i < length; i++) {\\n          rtn *= 10\\n          rtn += arr[arr.length - length + i]\\n        }\\n        return rtn\\n      }\\n    }\\n  }\\n};\\n\\nconsole.log(primePalindrome(1)) //2\\nconsole.log(primePalindrome(2)) //2\\nconsole.log(primePalindrome(3)) //3\\nconsole.log(primePalindrome(4)) //5\\n\\nconsole.log(primePalindrome(6)) //7\\nconsole.log(primePalindrome(8)) //11\\nconsole.log(primePalindrome(13)) //101\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111308,
                "title": "javascript-iterate-palindromes-clean-and-simple-code-faster-than-90",
                "content": "High-level explanation:\\n\\n- This is an implementation of the \"iterate palindromes\" solution\\n- At the top level, we will iterate over the number of digits in the palindrome, starting with the number of digits in n (if n = 13, digits = 2, 3, 4, ...)\\n- Inside the loop, we will iterate palindromes (1001, 1111, 1221, ..., 9999). To do this, we generate the first half of the palindrome and double it.\\n- There are special cases depending on whether digits is even or odd (palindrome = 1001, 1111, ... vs palindrome = 10001, 10101, ...)\\n\\n```\\nconst isPrime = (n) => {\\n  if (n <= 1) {\\n    return false;\\n  }\\n\\n  if (n === 2) {\\n    return true;\\n  }\\n\\n  // we are doing this up front so we can increment by 2\\n  if (n % 2 === 0) {\\n    return false;\\n  }\\n\\n  // check up to and include the square root of the number\\n  // if we ever passed the square root, we would have already\\n  // seen that divisor up to and including the square root\\n  for (let i = 3; i * i <= n; i += 2) {\\n    // we found a divisor\\n    if (n % i === 0) {\\n      return false;\\n    }\\n  }\\n\\n  // we did not find a divisor\\n  return true;\\n};\\n\\nconst reverseStr = (s) => {\\n  return s.split(\"\").reverse().join(\"\");\\n};\\n\\nconst getPalindromeWithDigits = ({ digits, n }) => {\\n  // for digits=4, we want to generate palindromes from 1001 to 9999 inclusive\\n  // let\\'s generate the first half of the palindrome\\n  // even case (digits=4): genDigits=2\\n  // odd case (digits=5): genDigits=3\\n  const genDigits = Math.floor((digits + 1) / 2);\\n\\n  const start = Math.pow(10, genDigits - 1);\\n  const end = 10 * start - 1;\\n  \\n  for (let i = start; i <= end; i++) {\\n    let palindromeStr;\\n    if (digits % 2 === 0) {\\n      // even case\\n      // double the string\\n      palindromeStr = `${`${i}`}${reverseStr(`${i}`)}`;\\n    } else {\\n      // odd case\\n      // we want to keep the middle digit from the first part,\\n      // and exclude the middle digit from the second part\\n      palindromeStr = `${`${i}`.slice(0, genDigits)}${reverseStr(\\n        `${i}`.slice(0, genDigits - 1)\\n      )}`;\\n    }\\n    const palindrome = parseInt(palindromeStr, 10);\\n\\n    // check if prime palindrome\\n    if (palindrome >= n && isPrime(palindrome)) {\\n      return palindrome;\\n    }\\n  }\\n  return null;\\n};\\n\\nconst primePalindrome = (n) => {\\n  const digits = `${n}`.length;\\n\\n  // check for palindromes of length i\\n  let i = digits;\\n  while (true) {\\n    if (i >= 10) {\\n      throw new Error(\"max digits exceeded\");\\n    }\\n\\n    const palindrome = getPalindromeWithDigits({ digits: i, n });\\n    if (palindrome) {\\n      return palindrome;\\n    }\\n    i++;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPrime = (n) => {\\n  if (n <= 1) {\\n    return false;\\n  }\\n\\n  if (n === 2) {\\n    return true;\\n  }\\n\\n  // we are doing this up front so we can increment by 2\\n  if (n % 2 === 0) {\\n    return false;\\n  }\\n\\n  // check up to and include the square root of the number\\n  // if we ever passed the square root, we would have already\\n  // seen that divisor up to and including the square root\\n  for (let i = 3; i * i <= n; i += 2) {\\n    // we found a divisor\\n    if (n % i === 0) {\\n      return false;\\n    }\\n  }\\n\\n  // we did not find a divisor\\n  return true;\\n};\\n\\nconst reverseStr = (s) => {\\n  return s.split(\"\").reverse().join(\"\");\\n};\\n\\nconst getPalindromeWithDigits = ({ digits, n }) => {\\n  // for digits=4, we want to generate palindromes from 1001 to 9999 inclusive\\n  // let\\'s generate the first half of the palindrome\\n  // even case (digits=4): genDigits=2\\n  // odd case (digits=5): genDigits=3\\n  const genDigits = Math.floor((digits + 1) / 2);\\n\\n  const start = Math.pow(10, genDigits - 1);\\n  const end = 10 * start - 1;\\n  \\n  for (let i = start; i <= end; i++) {\\n    let palindromeStr;\\n    if (digits % 2 === 0) {\\n      // even case\\n      // double the string\\n      palindromeStr = `${`${i}`}${reverseStr(`${i}`)}`;\\n    } else {\\n      // odd case\\n      // we want to keep the middle digit from the first part,\\n      // and exclude the middle digit from the second part\\n      palindromeStr = `${`${i}`.slice(0, genDigits)}${reverseStr(\\n        `${i}`.slice(0, genDigits - 1)\\n      )}`;\\n    }\\n    const palindrome = parseInt(palindromeStr, 10);\\n\\n    // check if prime palindrome\\n    if (palindrome >= n && isPrime(palindrome)) {\\n      return palindrome;\\n    }\\n  }\\n  return null;\\n};\\n\\nconst primePalindrome = (n) => {\\n  const digits = `${n}`.length;\\n\\n  // check for palindromes of length i\\n  let i = digits;\\n  while (true) {\\n    if (i >= 10) {\\n      throw new Error(\"max digits exceeded\");\\n    }\\n\\n    const palindrome = getPalindromeWithDigits({ digits: i, n });\\n    if (palindrome) {\\n      return palindrome;\\n    }\\n    i++;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045085,
                "title": "c-code-100",
                "content": "```\\nint primePalindrome(int N){    \\n    unsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;    \\n    if(N==1) return 2;\\n    for(i=N;;i++){\\n        s=0;\\n        rev=0;\\n        rem=0;\\n        dummy=i;\\n        if(dummy<=11||\\n           dummy%2!=0 && \\n           dummy%3!=0 && \\n           dummy%5!=0 &&\\n           dummy%7!=0 &&\\n           dummy%11!=0){\\n            while(dummy>0){\\n                rem = dummy%10;\\n                s = s + rem;\\n                rev = rev*10 + rem;\\n                dummy = dummy/10;\\n            }\\n            if(rev == i){\\n                s=0;\\n                for(j=2;j<=sqrt(i);j++){\\n                    if(i%j == 0){\\n                        ++s;\\n                        break;\\n                    }\\n                }  \\n                if(s == 0){\\n                    return i;\\n                }\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint primePalindrome(int N){    \\n    unsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;    \\n    if(N==1) return 2;\\n    for(i=N;;i++){\\n        s=0;\\n        rev=0;\\n        rem=0;\\n        dummy=i;\\n        if(dummy<=11||\\n           dummy%2!=0 && \\n           dummy%3!=0 && \\n           dummy%5!=0 &&\\n           dummy%7!=0 &&\\n           dummy%11!=0){\\n            while(dummy>0){\\n                rem = dummy%10;\\n                s = s + rem;\\n                rev = rev*10 + rem;\\n                dummy = dummy/10;\\n            }\\n            if(rev == i){\\n                s=0;\\n                for(j=2;j<=sqrt(i);j++){\\n                    if(i%j == 0){\\n                        ++s;\\n                        break;\\n                    }\\n                }  \\n                if(s == 0){\\n                    return i;\\n                }\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980487,
                "title": "python-my-ugly-solution",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        val = \\'\\'.join([\\'1\\'] + [\\'0\\'] * (len(str(n)) - 2) + [\\'1\\'])\\n        if n < 10: val = str(n)\\n        \\n        while not self.isPrime(int(val)) or int(val) < n:\\n            val = self.getNextPalindrome(val)\\n        \\n        return int(val)\\n        \\n    def getNextPalindrome(self, cur):\\n        cur = list(cur)\\n        int_val = int(\\'\\'.join(cur[:(len(cur)+1)//2]))\\n        nex = list(str(int_val+1))\\n        \\n        if len(cur) % 2 == 1:\\n            if set(str(int_val)) == {\\'9\\'}:\\n                return \\'\\'.join(nex[:-1] + nex[::-1][1:])\\n            else:\\n                return \\'\\'.join(nex + nex[::-1][1:])\\n        else:\\n            if set(str(int_val)) == {\\'9\\'}:\\n                return \\'\\'.join(nex[:-1] + nex[::-1])\\n            else:\\n                return \\'\\'.join(nex + nex[::-1])\\n    \\n    def isPrime(self, n):\\n        if n == 1: return False\\n        for i in range(2, int(sqrt(n))+1):\\n            if n % i == 0:\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "class Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        val = \\'\\'.join([\\'1\\'] + [\\'0\\'] * (len(str(n)) - 2) + [\\'1\\'])\\n        if n < 10: val = str(n)\\n        \\n        while not self.isPrime(int(val)) or int(val) < n:\\n            val = self.getNextPalindrome(val)\\n        \\n        return int(val)\\n        \\n    def getNextPalindrome(self, cur):\\n        cur = list(cur)\\n        int_val = int(\\'\\'.join(cur[:(len(cur)+1)//2]))\\n        nex = list(str(int_val+1))\\n        \\n        if len(cur) % 2 == 1:\\n            if set(str(int_val)) == {\\'9\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1930920,
                "title": "c-solution-a-discussion",
                "content": "Well, the multiplicative inverse for 10 (mod 11) is -1, because 1 = 11 * 1 - 10 * 1, \\nwhich means 1 (mod 11) = (0) (mod 11) - 1 * 10 (mod 11)\\nso, 1 = -1 * (10) (mod 11)\\nso, 10^-1 = -1 (#_#)/\\n\\nTherefore, for 8-digit palindrome, the equation of summation of ai(10^(7-i) + 10^i) can be replaced by -1 (mod 11)... skip all those 8-digit palindrome...\\n\\n... and in here, there is a way to check primality:\\n1. if n == 1, not prime\\n2. else if n < 4, prime\\n3. else if n % 2 == 0, not prime...\\n4. else if n < 9, prime\\n5. else if n % 3 == 0, not prime...\\n6. else\\n7. set f as next prime after 2, 3 = 5, upper bound = sqrt(n), while f <= upper bound do,\\n\\t8. if n % f == 0, there exist a factor, nope\\n\\t9. if n % (f + 2) == 0, nope\\n\\t10. f += 6 (so, all the multiples of 2, 3 = ignore)\\n\\nSo, that\\'s it...\\n\\n```cpp\\ntypedef long long int lld;\\n\\nclass Solution {\\npublic:\\n    lld revI(int v) {\\n        lld val = 0;\\n        while (v > 0) {\\n            val *= 10;\\n            val += v % 10;\\n            v /= 10;\\n        }\\n        return val;\\n    }\\n    \\n    bool isP(int v) {\\n        if (v == 1)\\n            return false;\\n        if (v < 4)\\n            return true;\\n        if ((v % 2) == 0)\\n            return false;\\n        if (v < 9)\\n            return true;\\n        if ((v % 3) == 0)\\n            return false;\\n        else {\\n            int r = sqrt(v);\\n            int f = 5;\\n            while (f <= r) {\\n                if ((v % f) == 0)\\n                    return false;\\n                if ((v % (f + 2)) == 0)\\n                    return false;\\n                f = f + 6;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // well, precompute = time-consuming\\n    int primePalindrome(int n) {\\n        while (1) {\\n            if ((lld)n == (lld)revI(n) && isP(n)) {\\n                return n;\\n            }\\n            n++;\\n            if (10000000 < n && n <= 99999999) {\\n                n = 100000000;  // just skip to 9 digits.\\n            }\\n        }\\n    }\\n};\\n```\\n*Side-notes: I always feel like I cannot do mathy problems, it always sounds like an act of logical thinking only... the ability to connecting the dots, connecting different pieces of information together is important... that means \\'talent\\' right... the faster you can think, more talented you are right... yea, in this regard, I am average (or slightly below average). Nonetheless, I enjoyed my time doing all these stuff        \\\\\\\\(^_^)/*",
                "solutionTags": [],
                "code": "```cpp\\ntypedef long long int lld;\\n\\nclass Solution {\\npublic:\\n    lld revI(int v) {\\n        lld val = 0;\\n        while (v > 0) {\\n            val *= 10;\\n            val += v % 10;\\n            v /= 10;\\n        }\\n        return val;\\n    }\\n    \\n    bool isP(int v) {\\n        if (v == 1)\\n            return false;\\n        if (v < 4)\\n            return true;\\n        if ((v % 2) == 0)\\n            return false;\\n        if (v < 9)\\n            return true;\\n        if ((v % 3) == 0)\\n            return false;\\n        else {\\n            int r = sqrt(v);\\n            int f = 5;\\n            while (f <= r) {\\n                if ((v % f) == 0)\\n                    return false;\\n                if ((v % (f + 2)) == 0)\\n                    return false;\\n                f = f + 6;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // well, precompute = time-consuming\\n    int primePalindrome(int n) {\\n        while (1) {\\n            if ((lld)n == (lld)revI(n) && isP(n)) {\\n                return n;\\n            }\\n            n++;\\n            if (10000000 < n && n <= 99999999) {\\n                n = 100000000;  // just skip to 9 digits.\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921422,
                "title": "python3-brute-force",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n <= 2:\\n            return 2\\n        if n <= 3:\\n            return 3\\n        if n <= 5:\\n            return 5\\n        if n <= 7:\\n            return 7\\n        if n <= 11:\\n            return 11\\n        string = str(n)\\n        length = len(string)\\n        \\n        low = 10 ** (length // 2)\\n        for i in range(low, 2 * 10**4 + 1):\\n            string = str(i)\\n            reversestring = string[:len(string) - 1]\\n            reversestring = reversestring[::-1]\\n            newstring = string + reversestring\\n            newnumber = int(newstring)\\n            \\n            if newnumber >= n and self.isPrime(newnumber):\\n                return newnumber\\n            \\n        return -1\\n    \\n    \\n    def isPrime(self,number):\\n        if number % 2 == 0:\\n            return number == 2\\n        for i in range(3, int(sqrt(number)) + 1, 2):\\n            if number % i == 0:\\n                return False\\n            \\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n <= 2:\\n            return 2\\n        if n <= 3:\\n            return 3\\n        if n <= 5:\\n            return 5\\n        if n <= 7:\\n            return 7\\n        if n <= 11:\\n            return 11\\n        string = str(n)\\n        length = len(string)\\n        \\n        low = 10 ** (length // 2)\\n        for i in range(low, 2 * 10**4 + 1):\\n            string = str(i)\\n            reversestring = string[:len(string) - 1]\\n            reversestring = reversestring[::-1]\\n            newstring = string + reversestring\\n            newnumber = int(newstring)\\n            \\n            if newnumber >= n and self.isPrime(newnumber):\\n                return newnumber\\n            \\n        return -1\\n    \\n    \\n    def isPrime(self,number):\\n        if number % 2 == 0:\\n            return number == 2\\n        for i in range(3, int(sqrt(number)) + 1, 2):\\n            if number % i == 0:\\n                return False\\n            \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1830732,
                "title": "python-very-easy-solution",
                "content": "```\\nclass Solution:\\n    def nextPalindrome(self,N):\\n        num = [int(x) for x in str(N)]\\n        n = len(num)\\n        mid = n//2\\n        i = mid-1\\n        j = mid+1 if n%2 else mid\\n        leftsmaller = False\\n        while i>=0 and num[i] == num[j]:\\n            i-=1\\n            j+=1\\n        if i<0 or num[i] < num[j]:leftsmaller = True\\n        while i>=0:\\n            num[j] = num[i]\\n            i-=1\\n            j+=1\\n        if leftsmaller == True:\\n            i = mid-1\\n            carry=1\\n            if n%2==0:\\n                j = mid\\n            else:\\n                num[mid] += 1\\n                carry = 1 if num[mid] == 10 else 0\\n                num[mid]%=10\\n                j = mid+1\\n            while i>=0:\\n                if carry==0:break\\n                num[i]+=carry\\n                carry = 1 if num[i]==10 else 0\\n                num[i]%=10\\n                num[j]=num[i]\\n                i-=1\\n                j+=1\\n        if num[0] == 0:\\n            num.insert(0,1)\\n            num[-1] = 1\\n        ans = 0\\n        for i in num:ans = ans*10+i\\n        return ans\\n            \\n    def primePalindrome(self, N: int) -> int:\\n        N=N-1\\n        while True:\\n            N = self.nextPalindrome(N)\\n            lt = int(N**0.5)+1\\n            if N==1:continue\\n            flag = True\\n            for i in range(2,lt):\\n                if N%i == 0:\\n                    flag = False\\n                    break\\n            if flag:return N\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def nextPalindrome(self,N):\\n        num = [int(x) for x in str(N)]\\n        n = len(num)\\n        mid = n//2\\n        i = mid-1\\n        j = mid+1 if n%2 else mid\\n        leftsmaller = False\\n        while i>=0 and num[i] == num[j]:\\n            i-=1\\n            j+=1\\n        if i<0 or num[i] < num[j]:leftsmaller = True\\n        while i>=0:\\n            num[j] = num[i]\\n            i-=1\\n            j+=1\\n        if leftsmaller == True:\\n            i = mid-1\\n            carry=1\\n            if n%2==0:\\n                j = mid\\n            else:\\n                num[mid] += 1\\n                carry = 1 if num[mid] == 10 else 0\\n                num[mid]%=10\\n                j = mid+1\\n            while i>=0:\\n                if carry==0:break\\n                num[i]+=carry\\n                carry = 1 if num[i]==10 else 0\\n                num[i]%=10\\n                num[j]=num[i]\\n                i-=1\\n                j+=1\\n        if num[0] == 0:\\n            num.insert(0,1)\\n            num[-1] = 1\\n        ans = 0\\n        for i in num:ans = ans*10+i\\n        return ans\\n            \\n    def primePalindrome(self, N: int) -> int:\\n        N=N-1\\n        while True:\\n            N = self.nextPalindrome(N)\\n            lt = int(N**0.5)+1\\n            if N==1:continue\\n            flag = True\\n            for i in range(2,lt):\\n                if N%i == 0:\\n                    flag = False\\n                    break\\n            if flag:return N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764561,
                "title": "c-solution-prime-palindrome",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    bool isPrime(int N) {\\n    if (N < 2) return false;\\n    int R = (int)sqrt(N);\\n    for (int d = 2; d <= R; ++d)\\n        if (N % d == 0) return false;\\n    return true;\\n    }\\n\\npublic:\\n    int reverse(int N) {\\n    int ans = 0;\\n    while (N > 0) {\\n        ans = 10 * ans + (N % 10);\\n           N /= 10;\\n        }\\n    return ans;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        while (true) {\\n            if (n == reverse(n) && isPrime(n))\\n                return n;\\n            n++;\\n            \\n            // Any even length palindrome must be divisble by 11\\n            // so we will skip numbers N = [10,000,000, 99,999,999]\\n            if (10000000 < n && n < 100000000)\\n                n = 100000000;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    bool isPrime(int N) {\\n    if (N < 2) return false;\\n    int R = (int)sqrt(N);\\n    for (int d = 2; d <= R; ++d)\\n        if (N % d == 0) return false;\\n    return true;\\n    }\\n\\npublic:\\n    int reverse(int N) {\\n    int ans = 0;\\n    while (N > 0) {\\n        ans = 10 * ans + (N % 10);\\n           N /= 10;\\n        }\\n    return ans;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        while (true) {\\n            if (n == reverse(n) && isPrime(n))\\n                return n;\\n            n++;\\n            \\n            // Any even length palindrome must be divisble by 11\\n            // so we will skip numbers N = [10,000,000, 99,999,999]\\n            if (10000000 < n && n < 100000000)\\n                n = 100000000;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704938,
                "title": "simple-solution-c",
                "content": "# Following is my approach :\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(long long x){\\n        if(x==0||x==1)\\n            return false;\\n        if(x==2||x==3)\\n            return true;\\n        if(x%2==0||x%3==0)\\n            return false;\\n        for(long long i=5;i*i<=x;i=i+6){\\n            if(x%i==0||x%(i+2)==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool pal(long long x){\\n        long long num=0;\\n        long long n=x;\\n        while(n){\\n        num=num*10+(n%10);\\n            n=n/10;\\n        }\\n        if(x==num)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n>9989899)\\n            return 100030001;\\n        for(long long i=n;;i++){\\n            if(pal(i)&&isPrime(i)){\\n                return i;\\n            }\\n        }\\n    }\\n};\\n```\\n#  Please upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(long long x){\\n        if(x==0||x==1)\\n            return false;\\n        if(x==2||x==3)\\n            return true;\\n        if(x%2==0||x%3==0)\\n            return false;\\n        for(long long i=5;i*i<=x;i=i+6){\\n            if(x%i==0||x%(i+2)==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool pal(long long x){\\n        long long num=0;\\n        long long n=x;\\n        while(n){\\n        num=num*10+(n%10);\\n            n=n/10;\\n        }\\n        if(x==num)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n>9989899)\\n            return 100030001;\\n        for(long long i=n;;i++){\\n            if(pal(i)&&isPrime(i)){\\n                return i;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694137,
                "title": "c-simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrime(int n){\\n        if(n<=1)\\n            return 0;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)\\n                return 0;//means n is not prime\\n        }\\n        return 1;//means n is prime\\n    }\\n    int reverse(int n){\\n        long long rev1=0;\\n        while(n>0){\\n            int a=n%10;\\n            // if(rev1>INT_MAX/10||rev1<INT_MIN/10)\\n            //     return 0;\\n            rev1=rev1*10+a;\\n            n/=10;\\n        }\\n        return rev1;\\n    }\\n    int isPalindrome(int n){\\n        return n==reverse(n);\\n    }\\n    int primePalindrome(int n) {\\n        if (1e7 <= n and n <= 1e8)\\n            n = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(true){\\n            while(isPalindrome(n)==false)\\n                n++;\\n            \\n            \\n                if(isPrime(n))\\n                    return n;\\n            n++;\\n            \\n            \\n        }\\n        //return n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrime(int n){\\n        if(n<=1)\\n            return 0;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)\\n                return 0;//means n is not prime\\n        }\\n        return 1;//means n is prime\\n    }\\n    int reverse(int n){\\n        long long rev1=0;\\n        while(n>0){\\n            int a=n%10;\\n            // if(rev1>INT_MAX/10||rev1<INT_MIN/10)\\n            //     return 0;\\n            rev1=rev1*10+a;\\n            n/=10;\\n        }\\n        return rev1;\\n    }\\n    int isPalindrome(int n){\\n        return n==reverse(n);\\n    }\\n    int primePalindrome(int n) {\\n        if (1e7 <= n and n <= 1e8)\\n            n = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(true){\\n            while(isPalindrome(n)==false)\\n                n++;\\n            \\n            \\n                if(isPrime(n))\\n                    return n;\\n            n++;\\n            \\n            \\n        }\\n        //return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646496,
                "title": "0ms-c-faster-than-100",
                "content": "```\\n    vector<int> prime{\\n2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001\\n};\\n    \\n\\n    public:\\n    \\n    int primePalindrome(int n) {\\n        \\n        \\n        int idx = lower_bound(prime.begin() , prime.end() , n) - prime.begin();\\n        return prime[idx];\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    vector<int> prime{\\n2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001\\n};\\n    \\n\\n    public:\\n    \\n    int primePalindrome(int n) {\\n        \\n        \\n        int idx = lower_bound(prime.begin() , prime.end() , n) - prime.begin();\\n        return prime[idx];\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546567,
                "title": "easy-java-solution",
                "content": "```\\n    public int primePalindrome(int n) {\\n         boolean flag=false;\\n        while(flag==false){\\n\\n            if(isPalindrome(n)){\\n\\n                if(isPrime(n)){\\n                    flag=true;\\n                    return n;\\n                }\\n            }\\n            else\\n                flag=false;\\n                n++;\\n        }\\n\\n        return n;\\n    }\\n      public static boolean isPrime(int n){\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n\\n            if(n%i==0)count++;\\n        }\\n\\n        return count==2;\\n    }  \\n     public static boolean isPalindrome(int n) {\\n        int rev = 0;\\n        int temp=n;\\n        while (temp > 0){\\n           rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n    }\\n        return rev==n;\\n    }   \\n        \\n        \\n        \\n        \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int primePalindrome(int n) {\\n         boolean flag=false;\\n        while(flag==false){\\n\\n            if(isPalindrome(n)){\\n\\n                if(isPrime(n)){\\n                    flag=true;\\n                    return n;\\n                }\\n            }\\n            else\\n                flag=false;\\n                n++;\\n        }\\n\\n        return n;\\n    }\\n      public static boolean isPrime(int n){\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n\\n            if(n%i==0)count++;\\n        }\\n\\n        return count==2;\\n    }  \\n     public static boolean isPalindrome(int n) {\\n        int rev = 0;\\n        int temp=n;\\n        while (temp > 0){\\n           rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n    }\\n        return rev==n;\\n    }   \\n        \\n        \\n        \\n        \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522120,
                "title": "table-generation-concept",
                "content": "```\\n\\nOnly One time calculating the entire table and then its log(n).\\n\\nvector<int> V;\\nbool flag = false;\\nclass Solution {\\npublic:\\n \\nbool isPrime(int num){\\n     if(num<=3) return num>1;\\n     if(num % 2 == 0 || num % 3 == 0) return false;\\n     int i = 5;\\n     while(i*i <=num){\\n           if(num % i == 0 || num % (i+2) == 0) return false;\\n           i += 6;\\n     }\\n     return true;\\n}\\n    \\n    \\nvoid gen(string s,int i,bool flag,string t=\"\"){\\n    \\n     if(i == s.size()){\\n           int i = 0;\\n           while(i<s.size() && t[i]==\\'0\\')\\n                  i++;\\n\\n           t =string(t.begin()+i,t.end());\\n           string tr= t;\\n           reverse(tr.begin(),tr.end());\\n           \\n            if(isPrime(atoi((t + tr).c_str()))){\\n                  V.push_back(atoi((t + tr).c_str()));\\n            }\\n\\n           for(int i = 0;i<=9;i++)\\n            if(isPrime(atoi((t + to_string(i) + tr).c_str())))\\n                  V.push_back(atoi((t + to_string(i) + tr).c_str()));\\n\\n           return;\\n     }\\n\\n     int limit  = flag ? (s[i]-\\'0\\'):9;\\n     for(int num = 0;num<=limit;num++){\\n         flag = ( limit!=9 && num ==limit);\\n         t += to_string(num);\\n         gen(s,i+1,flag,t);\\n         t.pop_back();\\n     }\\n}\\n      \\n    int primePalindrome(int n) {\\n        if(!flag){\\n            gen(\"2001\",0,true);\\n            flag = true;\\n        }   \\n        return *(lower_bound(V.begin(),V.end(),n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nOnly One time calculating the entire table and then its log(n).\\n\\nvector<int> V;\\nbool flag = false;\\nclass Solution {\\npublic:\\n \\nbool isPrime(int num){\\n     if(num<=3) return num>1;\\n     if(num % 2 == 0 || num % 3 == 0) return false;\\n     int i = 5;\\n     while(i*i <=num){\\n           if(num % i == 0 || num % (i+2) == 0) return false;\\n           i += 6;\\n     }\\n     return true;\\n}\\n    \\n    \\nvoid gen(string s,int i,bool flag,string t=\"\"){\\n    \\n     if(i == s.size()){\\n           int i = 0;\\n           while(i<s.size() && t[i]==\\'0\\')\\n                  i++;\\n\\n           t =string(t.begin()+i,t.end());\\n           string tr= t;\\n           reverse(tr.begin(),tr.end());\\n           \\n            if(isPrime(atoi((t + tr).c_str()))){\\n                  V.push_back(atoi((t + tr).c_str()));\\n            }\\n\\n           for(int i = 0;i<=9;i++)\\n            if(isPrime(atoi((t + to_string(i) + tr).c_str())))\\n                  V.push_back(atoi((t + to_string(i) + tr).c_str()));\\n\\n           return;\\n     }\\n\\n     int limit  = flag ? (s[i]-\\'0\\'):9;\\n     for(int num = 0;num<=limit;num++){\\n         flag = ( limit!=9 && num ==limit);\\n         t += to_string(num);\\n         gen(s,i+1,flag,t);\\n         t.pop_back();\\n     }\\n}\\n      \\n    int primePalindrome(int n) {\\n        if(!flag){\\n            gen(\"2001\",0,true);\\n            flag = true;\\n        }   \\n        return *(lower_bound(V.begin(),V.end(),n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488677,
                "title": "python-3-brute-force-math-pruning-explanation",
                "content": "### Explanation\\n- Filtering out palindrome is very simple, but instead of filtering, we need to make up palindrome in order, so that we don\\'t waste on trying definitely useless numbers.\\n\\t- Make sure odd digits palindrome and even digits palindrome are both included.\\n- Other than making up palindrome, we can use **math** to filter values, below are not prime for sure\\n\\t- Have factor `5`: `5xxx5`, `5xx5`, everything start with `5`\\n\\t- Have factor `2`: `2xx2`, `4xx4`, `6xx6`, `8xx8` everything starts with `2, 4, 6, 8`\\n### Implementation\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458153,
                "title": "python3-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11: return 11 # edge case \\n        \\n        def fn(n): \\n            \"\"\"Return next palindromic number greater than x.\"\"\"\\n            digits = [int(x) for x in str(n)]\\n            for i in reversed(range(len(digits)//2+1)): \\n                if digits[i] < 9: break \\n            else: return 10*n + 11\\n            digits[i] = digits[~i] = digits[i] + 1\\n            for ii in range(i): \\n                digits[~ii] = digits[ii]\\n            for ii in range(i+1, len(digits)//2+1): \\n                digits[ii] = digits[~ii] = 0\\n            return int(\"\".join(map(str, digits)))\\n        \\n        def isprime(x): \\n            \"\"\"Return True if x is prime.\"\"\"\\n            if x <= 1: return False \\n            if x % 2 == 0: return x == 2\\n            for k in range(3, int(sqrt(x))+1, 2): \\n                if x % k == 0: return False\\n            return True \\n        \\n        nn = n \\n        k = 0\\n        while nn: \\n            nn //= 10\\n            k += 1\\n            \\n        if not k&1: n = 10**k + 1\\n        elif str(n) != str(n)[::-1]: n = fn(n)\\n        \\n        while True: \\n            if isprime(n): return n\\n            n = fn(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11: return 11 # edge case \\n        \\n        def fn(n): \\n            \"\"\"Return next palindromic number greater than x.\"\"\"\\n            digits = [int(x) for x in str(n)]\\n            for i in reversed(range(len(digits)//2+1)): \\n                if digits[i] < 9: break \\n            else: return 10*n + 11\\n            digits[i] = digits[~i] = digits[i] + 1\\n            for ii in range(i): \\n                digits[~ii] = digits[ii]\\n            for ii in range(i+1, len(digits)//2+1): \\n                digits[ii] = digits[~ii] = 0\\n            return int(\"\".join(map(str, digits)))\\n        \\n        def isprime(x): \\n            \"\"\"Return True if x is prime.\"\"\"\\n            if x <= 1: return False \\n            if x % 2 == 0: return x == 2\\n            for k in range(3, int(sqrt(x))+1, 2): \\n                if x % k == 0: return False\\n            return True \\n        \\n        nn = n \\n        k = 0\\n        while nn: \\n            nn //= 10\\n            k += 1\\n            \\n        if not k&1: n = 10**k + 1\\n        elif str(n) != str(n)[::-1]: n = fn(n)\\n        \\n        while True: \\n            if isprime(n): return n\\n            n = fn(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345879,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool ispal(int n){\\n        string s=to_string(n);\\n        int low=0,high=s.length()-1;\\n        while(low<high){\\n            if(s[low]!=s[high]){\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPrime(int n) {   \\n    if (n <= 1) return false;\\n    for (int i = 2; i <= sqrt(n); i++)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}\\n    \\n    int primePalindrome(int n) {\\n        for(int i=n;i<10000000;i++){\\n            if(isPrime(i) && ispal(i)){\\n                return i;\\n            }\\n        }\\n        return 100030001;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool ispal(int n){\\n        string s=to_string(n);\\n        int low=0,high=s.length()-1;\\n        while(low<high){\\n            if(s[low]!=s[high]){\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPrime(int n) {   \\n    if (n <= 1) return false;\\n    for (int i = 2; i <= sqrt(n); i++)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}\\n    \\n    int primePalindrome(int n) {\\n        for(int i=n;i<10000000;i++){\\n            if(isPrime(i) && ispal(i)){\\n                return i;\\n            }\\n        }\\n        return 100030001;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308204,
                "title": "find-next-palindrome",
                "content": "The idea is simple, for given n, we first find a palindrom p greater than n, then we check whether it\\'s prime, if it\\'s a prime, we get the result, otherwise, we find next palindrome greater than p\\n\\nfor example\\n```python\\nn = 723\\nthen it will iterately generate following palindromes until getting one prime palindrome\\n747   # first palindrome greater than n\\n757 # second palindrome greater than n, and this is also a prime number\\n```\\n```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(n):\\n            if n<=2 or n&1==0:\\n                return n==2\\n            for i in range(3, int(n**0.5)+1, 2):\\n                if n%i==0:return False\\n            return True\\n        \\n        def nextPalindrome(n):\\n            s = str(n)\\n            l = len(s)\\n            if n < 10:\\n                return n+1\\n            # 123 12+1 ->131\\n\\t\\t\\t# if left half is smaller than right half, increase left help by one\\n            if s[:l//2]<=s[(l+1)//2:]:\\n                head = str(int(s[:(l+1)//2])+1)\\n            else:\\n                head = s[:(l+1)//2]\\n            ans = head+head[:l//2][::-1]\\n\\t\\t\\t# if the palindrom is the same, increase left halp by 1\\n            if ans==str(n):\\n                head = str(int(s[:(l+1)//2])+1)\\n                ans = head+head[:l//2][::-1]\\n            return int(ans)\\n\\t\\t# in case N is already a result, we start with N-1\\n        n = N-1\\n        while True:\\n            p = nextPalindrome(n)\\n            if isPrime(p):\\n                return p\\n            else:\\n                n = p\\n",
                "solutionTags": [],
                "code": "```python\\nn = 723\\nthen it will iterately generate following palindromes until getting one prime palindrome\\n747   # first palindrome greater than n\\n757 # second palindrome greater than n, and this is also a prime number\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306489,
                "title": "js-faster-than-98",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar primePalindrome = function(N) {\\n    if (N <= 2) return 2\\n    if (N <= 3)  return 3\\n    if (N <= 5) return 5\\n    if (N <= 7) return 7\\n    \\n    \\n    const tails = [1, 3, 7, 9]\\n    function isPrime(num) {\\n        for (let modMe = 2, sq = Math.sqrt(num);\\n            modMe <= sq; modMe++) {\\n            if (num % modMe === 0)  return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    \\n    for (let digitC = Math.max(String(N).length, 2); ; digitC++) {\\n        const halfC = digitC >> 1\\n        const isOdd = Boolean(digitC & 1)\\n        const anyC = -1 + halfC\\n        const valLimit = 10 ** anyC\\n        \\n        let midFrom = 0, midTo = 9\\n        if (!isOdd) {\\n            midTo = 0\\n        }\\n        \\n        for (const tail of tails.values()) {\\n            for (let val = 0; val < valLimit; val++) {\\n                let valStr = String(val)\\n                valStr = valStr.padStart(anyC, \\'0\\')\\n                const sub = [...valStr]\\n                const subReverse = [...sub].reverse()\\n                \\n                for (let mid = midFrom; mid <= midTo; mid++) {\\n                    const chs = [tail]\\n                    \\n                    if (anyC !== 0) chs.push(...sub)\\n                    if (isOdd)  chs.push(mid)\\n                    if (anyC !== 0) chs.push(...subReverse)\\n                    chs.push(tail)\\n                    \\n                    const str = chs.join(\\'\\')\\n                    const num = Number(str)\\n                    if (num < N)    continue\\n                    \\n                    if (isPrime(num)) return num\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar primePalindrome = function(N) {\\n    if (N <= 2) return 2\\n    if (N <= 3)  return 3\\n    if (N <= 5) return 5\\n    if (N <= 7) return 7\\n    \\n    \\n    const tails = [1, 3, 7, 9]\\n    function isPrime(num) {\\n        for (let modMe = 2, sq = Math.sqrt(num);\\n            modMe <= sq; modMe++) {\\n            if (num % modMe === 0)  return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    \\n    for (let digitC = Math.max(String(N).length, 2); ; digitC++) {\\n        const halfC = digitC >> 1\\n        const isOdd = Boolean(digitC & 1)\\n        const anyC = -1 + halfC\\n        const valLimit = 10 ** anyC\\n        \\n        let midFrom = 0, midTo = 9\\n        if (!isOdd) {\\n            midTo = 0\\n        }\\n        \\n        for (const tail of tails.values()) {\\n            for (let val = 0; val < valLimit; val++) {\\n                let valStr = String(val)\\n                valStr = valStr.padStart(anyC, \\'0\\')\\n                const sub = [...valStr]\\n                const subReverse = [...sub].reverse()\\n                \\n                for (let mid = midFrom; mid <= midTo; mid++) {\\n                    const chs = [tail]\\n                    \\n                    if (anyC !== 0) chs.push(...sub)\\n                    if (isOdd)  chs.push(mid)\\n                    if (anyC !== 0) chs.push(...subReverse)\\n                    chs.push(tail)\\n                    \\n                    const str = chs.join(\\'\\')\\n                    const num = Number(str)\\n                    if (num < N)    continue\\n                    \\n                    if (isPrime(num)) return num\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238364,
                "title": "javascript-faster-than-100",
                "content": "Although the memory efficiency could be better, but the speed was very good. Here it is. If there is any room for improvement, please comment below\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n    \\n    while (true){\\n        let str = String(n)\\n        if (String(n).length % 2 == 0 && n > 11){\\n\\t\\t\\tn = Math.pow(10, Math.ceil(Math.log10(n+1)))\\n\\t\\t\\t// or n = 1 + Array(str.length).fill(0).join(\"\")\\n            continue\\n        }\\n        if (!isPalindrome(str)) {\\n            n++\\n            continue\\n        }\\n        if (isPrime(n)) return n\\n        n++\\n    }\\n    \\n};\\n\\nfunction isPrime(n){\\n    if (n <= 1) return false\\n    if (n <= 3) return true\\n    if (n % 2 == 0 || n % 3 == 0) return false\\n    \\n    for (let i = 3; i <= Math.floor(Math.sqrt(n)) + 1;i+=2){\\n        if (n % i == 0) return false      \\n    }\\n    return true\\n}\\n\\nfunction isPalindrome(str){\\n    let l = 0, r = str.length-1\\n    while (l < r){\\n        if (str[l] != str[r]) return false\\n        l++\\n        r--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n    \\n    while (true){\\n        let str = String(n)\\n        if (String(n).length % 2 == 0 && n > 11){\\n\\t\\t\\tn = Math.pow(10, Math.ceil(Math.log10(n+1)))\\n\\t\\t\\t// or n = 1 + Array(str.length).fill(0).join(\"\")\\n            continue\\n        }\\n        if (!isPalindrome(str)) {\\n            n++\\n            continue\\n        }\\n        if (isPrime(n)) return n\\n        n++\\n    }\\n    \\n};\\n\\nfunction isPrime(n){\\n    if (n <= 1) return false\\n    if (n <= 3) return true\\n    if (n % 2 == 0 || n % 3 == 0) return false\\n    \\n    for (let i = 3; i <= Math.floor(Math.sqrt(n)) + 1;i+=2){\\n        if (n % i == 0) return false      \\n    }\\n    return true\\n}\\n\\nfunction isPalindrome(str){\\n    let l = 0, r = str.length-1\\n    while (l < r){\\n        if (str[l] != str[r]) return false\\n        l++\\n        r--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174370,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        n=N\\n        def prime(n):\\n            if n <= 1:\\n                return False\\n            if n == 2:\\n                return True\\n            if n > 2 and n % 2 == 0:\\n                return False\\n \\n            max_div = math.floor(math.sqrt(n))\\n            for i in range(3, 1 + max_div, 2):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        def reverse(n):\\n            n=str(n)\\n            return (n==n[::-1])\\n        while True:\\n            if prime(n) and reverse(n):\\n                return n\\n                \\n            n+=1\\n            if 10**7 < n < 10**8:\\n                n=10**8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        n=N\\n        def prime(n):\\n            if n <= 1:\\n                return False\\n            if n == 2:\\n                return True\\n            if n > 2 and n % 2 == 0:\\n                return False\\n \\n            max_div = math.floor(math.sqrt(n))\\n            for i in range(3, 1 + max_div, 2):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        def reverse(n):\\n            n=str(n)\\n            return (n==n[::-1])\\n        while True:\\n            if prime(n) and reverse(n):\\n                return n\\n                \\n            n+=1\\n            if 10**7 < n < 10**8:\\n                n=10**8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161034,
                "title": "python3-easy-solution-with-explanation-and-comments-100-faster",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2}",
                "codeTag": "Java"
            },
            {
                "id": 1158279,
                "title": "swift-236ms",
                "content": "```\\nclass Solution {\\n    func primePalindrome(_ N: Int) -> Int {\\n        let str = String(N)\\n        var digits = str.count\\n        \\n        if isPrime(N) && isPalindrome(N) {\\n            return N\\n        }\\n        \\n        var found = -1\\n        while found == -1 {\\n            palindromes(digits, N, &found)\\n            digits += 1\\n        }\\n        return found\\n    }\\n    \\n    func isPalindrome(_ num: Int) -> Bool {\\n        let str = String(num)\\n        return str == String(str.reversed())\\n    }\\n    \\n    func isPrime(_ num: Int) -> Bool {\\n        if num == 1 { return false }\\n        var division = 2\\n        while true {\\n            if division * division > num {\\n                // we checked all candidates\\n                return true\\n            }\\n            \\n            if num % division == 0 {\\n                return false\\n            }\\n            division += 1\\n        }\\n        return false\\n    }\\n    \\n    func palindromes(_ digit: Int, _ N: Int, _ found: inout Int) -> [String] {\\n        let nums = (0...9).map { String($0) }\\n        if digit == 0 { return [\"\"] }\\n        if digit == 1 {\\n            for i in 1...9 where i >= N && isPrime(i) {\\n                found = i\\n                break\\n            }\\n            return nums\\n        }\\n        \\n        var results = [String]()\\n        let prev = palindromes(digit-2, N, &found)\\n        \\n        for num in nums {\\n            for val in prev {\\n                let str = num+val+num\\n                results.append(str)\\n                \\n                if num != \"0\", let int_val = Int(str), int_val >= N, isPrime(int_val) {\\n                    found = int_val\\n                    return results\\n                }\\n            }\\n        }\\n        return results\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func primePalindrome(_ N: Int) -> Int {\\n        let str = String(N)\\n        var digits = str.count\\n        \\n        if isPrime(N) && isPalindrome(N) {\\n            return N\\n        }\\n        \\n        var found = -1\\n        while found == -1 {\\n            palindromes(digits, N, &found)\\n            digits += 1\\n        }\\n        return found\\n    }\\n    \\n    func isPalindrome(_ num: Int) -> Bool {\\n        let str = String(num)\\n        return str == String(str.reversed())\\n    }\\n    \\n    func isPrime(_ num: Int) -> Bool {\\n        if num == 1 { return false }\\n        var division = 2\\n        while true {\\n            if division * division > num {\\n                // we checked all candidates\\n                return true\\n            }\\n            \\n            if num % division == 0 {\\n                return false\\n            }\\n            division += 1\\n        }\\n        return false\\n    }\\n    \\n    func palindromes(_ digit: Int, _ N: Int, _ found: inout Int) -> [String] {\\n        let nums = (0...9).map { String($0) }\\n        if digit == 0 { return [\"\"] }\\n        if digit == 1 {\\n            for i in 1...9 where i >= N && isPrime(i) {\\n                found = i\\n                break\\n            }\\n            return nums\\n        }\\n        \\n        var results = [String]()\\n        let prev = palindromes(digit-2, N, &found)\\n        \\n        for num in nums {\\n            for val in prev {\\n                let str = num+val+num\\n                results.append(str)\\n                \\n                if num != \"0\", let int_val = Int(str), int_val >= N, isPrime(int_val) {\\n                    found = int_val\\n                    return results\\n                }\\n            }\\n        }\\n        return results\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146586,
                "title": "c-without-generating-prime-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool prime(long n)\\n    {\\n        if(n%2==0)\\n            return 0;\\n        for(long i=3;i*i<=n;i+=2)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        \\n        if(N==3 or N==2 or N==5 or N==7)\\n            return N;\\n        if(N==1) return 2;\\n        if(N==4) return 5;\\n        if(N==6) return 7;\\n        if(N<=11) return 11;\\n            \\n        \\n        string s=to_string(N);\\n        string sn;\\n        int len=s.length();\\n       \\n        sn=s.substr(0,ceil(len/2.0));\\n        int k=len/2;\\n        \\n        \\n        while(1)\\n        {\\n            string temp;\\n            if(sn.length()>k)\\n                temp=sn.substr(0,sn.length()-1);\\n            else\\n                temp=sn;\\n            \\n            reverse(temp.begin(),temp.end());\\n            \\n            long n=stol(sn+temp);\\n            if(prime(n) and n>=N)\\n                return n;\\n            if(sn[sn.length()-1]<57)\\n                sn[sn.length()-1]+=1;\\n            else\\n            {\\n                long l=stoll(sn)+1;\\n                sn=to_string(l);  \\n            }  \\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prime(long n)\\n    {\\n        if(n%2==0)\\n            return 0;\\n        for(long i=3;i*i<=n;i+=2)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        \\n        if(N==3 or N==2 or N==5 or N==7)\\n            return N;\\n        if(N==1) return 2;\\n        if(N==4) return 5;\\n        if(N==6) return 7;\\n        if(N<=11) return 11;\\n            \\n        \\n        string s=to_string(N);\\n        string sn;\\n        int len=s.length();\\n       \\n        sn=s.substr(0,ceil(len/2.0));\\n        int k=len/2;\\n        \\n        \\n        while(1)\\n        {\\n            string temp;\\n            if(sn.length()>k)\\n                temp=sn.substr(0,sn.length()-1);\\n            else\\n                temp=sn;\\n            \\n            reverse(temp.begin(),temp.end());\\n            \\n            long n=stol(sn+temp);\\n            if(prime(n) and n>=N)\\n                return n;\\n            if(sn[sn.length()-1]<57)\\n                sn[sn.length()-1]+=1;\\n            else\\n            {\\n                long l=stoll(sn)+1;\\n                sn=to_string(l);  \\n            }  \\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136411,
                "title": "simplest-algorithm-but-without-primes-generator",
                "content": "it\\'s working on small range of numbers but i need to complete it with primes generator that got accepted without run time error\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        \\n        primes.append(n)\\n        primes = sorted(primes)\\n\\n        primes.index(n)\\n\\n        return primes[primes.index(n)+1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        \\n        primes.append(n)\\n        primes = sorted(primes)\\n\\n        primes.index(n)\\n\\n        return primes[primes.index(n)+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046663,
                "title": "swift-solution-with-comments",
                "content": "According to one of the 11\\'s divisibility rule, form the alternating sum of the digits.\\nIf the result can be divisible by 11, the original number must be 11\\'s multiple. \\nex. 2486 => 2 - 4 + 8 - 6 = 0 * 11\\n\\nSo we can know: **any palindrome with even number of digits must be divisible by 11**\\nex. abba => a - b + b - a = 0 * 11\\n\\nThat is, any palindrome with even number of digits is not a prime. Then we can skip them.\\n\\n```\\nfunc primePalindrome(_ N: Int) -> Int {\\n\\t// edge case (11 is the only prime palindrome with even number of digits)\\n\\tif 8 <= N && N <= 11 { return 11 }\\n\\n\\tvar _N = N\\n\\twhile true {\\n\\t\\tif isPrime(_N) && isPalindrome(String(_N)) { return _N }\\n\\t\\tlet digits = String(_N).count\\n\\t\\t_N = digits % 2 == 0 ? Int(pow(10, Double(digits)) + 1) : _N + 1\\n\\t}\\n}\\n\\nfunc isPrime(_ n: Int) -> Bool {\\n\\tguard n > 1 else { return false }\\n\\tguard n != 2 else { return true }\\n\\tguard n % 2 != 0 else { return false }\\n\\n\\tvar i = 3\\n\\twhile i * i <= n {\\n\\t\\tif n % i == 0 { return false }\\n\\t\\ti += 1\\n\\t}\\n\\treturn true\\n}\\n        \\nfunc isPalindrome(_ s: String) -> Bool {\\n\\treturn s == String(s.reversed())\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc primePalindrome(_ N: Int) -> Int {\\n\\t// edge case (11 is the only prime palindrome with even number of digits)\\n\\tif 8 <= N && N <= 11 { return 11 }\\n\\n\\tvar _N = N\\n\\twhile true {\\n\\t\\tif isPrime(_N) && isPalindrome(String(_N)) { return _N }\\n\\t\\tlet digits = String(_N).count\\n\\t\\t_N = digits % 2 == 0 ? Int(pow(10, Double(digits)) + 1) : _N + 1\\n\\t}\\n}\\n\\nfunc isPrime(_ n: Int) -> Bool {\\n\\tguard n > 1 else { return false }\\n\\tguard n != 2 else { return true }\\n\\tguard n % 2 != 0 else { return false }\\n\\n\\tvar i = 3\\n\\twhile i * i <= n {\\n\\t\\tif n % i == 0 { return false }\\n\\t\\ti += 1\\n\\t}\\n\\treturn true\\n}\\n        \\nfunc isPalindrome(_ s: String) -> Bool {\\n\\treturn s == String(s.reversed())\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037653,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n     if(N==1 ||N==2)\\n         return 2;\\n     \\n    if(N%2==0)\\n        N=N+1;\\n        \\n     while(true){\\n           if( palindrome(N) && prime(N) ){\\n               return N;\\n           } \\n         N+=2;\\n         \\n         if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n     }  \\n    }\\n    \\n    \\n    public boolean palindrome(int N){\\n        if(N%10==0 && N!=0)\\n            return false;\\n        \\n        int reverseNumber=0;\\n        int num=N;\\n        while(num>0){\\n            reverseNumber=reverseNumber*10+num%10;\\n            num/=10;    \\n        }\\n        return reverseNumber==N || N== reverseNumber / 10;\\n    }\\n    \\n    \\n    \\n    public boolean prime(int N){\\n        if(N%2==0) return false;\\n        \\n        for(int i=3;i<N/2+1; i+=2)\\n              if(N%i==0)\\n                  return false;\\n          \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n     if(N==1 ||N==2)\\n         return 2;\\n     \\n    if(N%2==0)\\n        N=N+1;\\n        \\n     while(true){\\n           if( palindrome(N) && prime(N) ){\\n               return N;\\n           } \\n         N+=2;\\n         \\n         if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n     }  \\n    }\\n    \\n    \\n    public boolean palindrome(int N){\\n        if(N%10==0 && N!=0)\\n            return false;\\n        \\n        int reverseNumber=0;\\n        int num=N;\\n        while(num>0){\\n            reverseNumber=reverseNumber*10+num%10;\\n            num/=10;    \\n        }\\n        return reverseNumber==N || N== reverseNumber / 10;\\n    }\\n    \\n    \\n    \\n    public boolean prime(int N){\\n        if(N%2==0) return false;\\n        \\n        for(int i=3;i<N/2+1; i+=2)\\n              if(N%i==0)\\n                  return false;\\n          \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028591,
                "title": "java-solution-with-comments",
                "content": "```\\n\\n  public int primePalindrome(int N) {\\n    // Even digits palindrome number is divisible by 11, so they are not prime, exception is 11.\\n    if (8 <= N && N <= 11) return 11;\\n    // Odd digit palindrome number. checking by root.\\n    //  \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n    //   so use endless loop and break once find the answer\\n    for (int r = getInitialRoot(N); ; r++) { // let r start from 1 is okay\\n      String l = String.valueOf(r);\\n      StringBuilder sb = new StringBuilder(l);\\n      for (int index = l.length() - 2; 0 <= index; index--) {\\n        sb.append(l.charAt(index));\\n      }\\n\\n      // odd digits palindrome number\\n      int n = Integer.valueOf(sb.toString());\\n      if (N <= n && isPrime(n)) {\\n        return n;\\n      }\\n    }\\n  }\\n\\n  // \\'1 <= N <= 10^8\\'\\n  // \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n  //  so use int array is enough\\n  // root of minimum palindrome number of odd digits i\\n  static int[] mRoot = new int[10];\\n\\n  static {\\n    mRoot[1] = 1;\\n    mRoot[3] = 10; // 101\\n    mRoot[5] = 100; // 10001\\n    mRoot[7] = 1000; // 1000001\\n    mRoot[9] = 10000; // 100000001\\n  }\\n\\n  private static int getInitialRoot(int N) {\\n    int l = String.valueOf(N).length();\\n    if ((l & 1) == 0) {\\n      l++;\\n    }\\n    // even N is one of the minimum palindrome number, it could not be prime\\n    return mRoot[l];\\n  }\\n  // assume i is positive integer\\n  public static boolean isPrime(int N) {\\n    if (N < 2) return false;\\n    if (N == 2) return true;\\n    // N > 2\\n    if (N % 2 == 0) return false;\\n    int to = (int) Math.pow(N, 0.5);\\n    for (int i = 3; i <= to; i += 2) {\\n      if (N % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n  public int primePalindrome(int N) {\\n    // Even digits palindrome number is divisible by 11, so they are not prime, exception is 11.\\n    if (8 <= N && N <= 11) return 11;\\n    // Odd digit palindrome number. checking by root.\\n    //  \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n    //   so use endless loop and break once find the answer\\n    for (int r = getInitialRoot(N); ; r++) { // let r start from 1 is okay\\n      String l = String.valueOf(r);\\n      StringBuilder sb = new StringBuilder(l);\\n      for (int index = l.length() - 2; 0 <= index; index--) {\\n        sb.append(l.charAt(index));\\n      }\\n\\n      // odd digits palindrome number\\n      int n = Integer.valueOf(sb.toString());\\n      if (N <= n && isPrime(n)) {\\n        return n;\\n      }\\n    }\\n  }\\n\\n  // \\'1 <= N <= 10^8\\'\\n  // \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n  //  so use int array is enough\\n  // root of minimum palindrome number of odd digits i\\n  static int[] mRoot = new int[10];\\n\\n  static {\\n    mRoot[1] = 1;\\n    mRoot[3] = 10; // 101\\n    mRoot[5] = 100; // 10001\\n    mRoot[7] = 1000; // 1000001\\n    mRoot[9] = 10000; // 100000001\\n  }\\n\\n  private static int getInitialRoot(int N) {\\n    int l = String.valueOf(N).length();\\n    if ((l & 1) == 0) {\\n      l++;\\n    }\\n    // even N is one of the minimum palindrome number, it could not be prime\\n    return mRoot[l];\\n  }\\n  // assume i is positive integer\\n  public static boolean isPrime(int N) {\\n    if (N < 2) return false;\\n    if (N == 2) return true;\\n    // N > 2\\n    if (N % 2 == 0) return false;\\n    int to = (int) Math.pow(N, 0.5);\\n    for (int i = 3; i <= to; i += 2) {\\n      if (N % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011850,
                "title": "go",
                "content": "```\\nfunc primePalindrome(N int) int {\\n    a := getPaliFromN(N)\\n    for {\\n        if !isPrime(a) {\\n            a = nextPali(a)\\n        } else {\\n            break\\n        }\\n    }\\n    return a\\n}\\n\\nfunc getPaliFromN(n int) int {\\n    a := strconv.Itoa(n)    \\n    b := a[:(len(a) + 1) / 2]\\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        b += string(a[i])\\n    }\\n    m, _ := strconv.Atoi(b)\\n    if m >= n {\\n        return m\\n    } else {\\n        return nextPali(m)\\n    }\\n}\\n\\nfunc nextPali(n int) int {\\n    a := strconv.Itoa(n)\\n    b := a[:(len(a) + 1) / 2]\\n    bnum, _ := strconv.Atoi(b)\\n    bnum++\\n    bs := strconv.Itoa(bnum)\\n    if len(bs) != len(b) {\\n        bs := \"1\"\\n        for i := 0; i < len(a) - 1; i++ {\\n            bs += \"0\"\\n        }\\n        bs += \"1\"\\n        res, _ := strconv.Atoi(bs)\\n        return res\\n    }\\n    \\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        bs += string(bs[i])\\n    }\\n    res, _ := strconv.Atoi(bs)\\n    return res\\n}\\n\\nfunc isPrime(n int) bool {\\n    if n <= 1 {\\n        return false\\n    }\\n    for i := 2; i * i <= n; i++ {\\n        if n % i == 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n    a := getPaliFromN(N)\\n    for {\\n        if !isPrime(a) {\\n            a = nextPali(a)\\n        } else {\\n            break\\n        }\\n    }\\n    return a\\n}\\n\\nfunc getPaliFromN(n int) int {\\n    a := strconv.Itoa(n)    \\n    b := a[:(len(a) + 1) / 2]\\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        b += string(a[i])\\n    }\\n    m, _ := strconv.Atoi(b)\\n    if m >= n {\\n        return m\\n    } else {\\n        return nextPali(m)\\n    }\\n}\\n\\nfunc nextPali(n int) int {\\n    a := strconv.Itoa(n)\\n    b := a[:(len(a) + 1) / 2]\\n    bnum, _ := strconv.Atoi(b)\\n    bnum++\\n    bs := strconv.Itoa(bnum)\\n    if len(bs) != len(b) {\\n        bs := \"1\"\\n        for i := 0; i < len(a) - 1; i++ {\\n            bs += \"0\"\\n        }\\n        bs += \"1\"\\n        res, _ := strconv.Atoi(bs)\\n        return res\\n    }\\n    \\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        bs += string(bs[i])\\n    }\\n    res, _ := strconv.Atoi(bs)\\n    return res\\n}\\n\\nfunc isPrime(n int) bool {\\n    if n <= 1 {\\n        return false\\n    }\\n    for i := 2; i * i <= n; i++ {\\n        if n % i == 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995044,
                "title": "python3-find-palindromes-first-and-then-check-if-it-s-prime",
                "content": "```\\nclass Solution:\\n    primes = [2]\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        # Find palindrome number first, then check it is a prime number.\\n        \\n        # Elimiate special case 2 and 11.\\n        if N < 3: return 2\\n        elif 7 < N <= 11: return 11\\n\\n        # Record the number of digits.\\n        num, digitLen = N, 0\\n        while num > 0:\\n            num = num // 10\\n            digitLen += 1\\n\\n        # Even length palindromes are divisible by 11,\\n        # it will be non-prime number except for 11 itself.\\n        if digitLen % 2 == 0:\\n            return self.primePalindrome(10**(digitLen))\\n        else:\\n            halfDigitLen = digitLen//2\\n            # All number which length is one, is palindrome number.\\n            if halfDigitLen == 0:\\n                for num in range(N, 10):\\n                    if self.isPrime(num):\\n                        return num\\n            # If length is bigger than one.\\n            # Split the palindrome number into three part, left, middle, right\\n            # We need to find palindrome number in ascending way.\\n            # So first decide left side number then middle number.(right number don\\'t matter if it\\'s palindrome number)\\n            else:\\n                # first digit of left side number has to be 1, otherwise it would not be the same number of digits.\\n                # If 7 digits number => left side number is 100 ~ 999\\n                leftSideNum = 10**(halfDigitLen-1)\\n                while leftSideNum < 10**halfDigitLen:\\n\\n                    # Caculate right side number\\n                    rightSideNum = 0\\n                    for digit in range(halfDigitLen):\\n                        rightSideNum += (leftSideNum%(10**(digit+1))//(10**digit))*(10**(halfDigitLen-digit-1))\\n                    \\n                    # middle number is 0 ~ 9\\n                    for middleNum in range(10):\\n                        num = rightSideNum + leftSideNum*(10**(halfDigitLen+1)) + middleNum*(10**halfDigitLen)\\n                        if num >= N:\\n                            if self.isPrime(num): \\n                                return num\\n\\n                    leftSideNum += 1\\n                    # The while statement just to elimiate last digit is multiple of 2 or 5\\n                    # which definitely not the prime number.\\n                    firstNum = leftSideNum//(10**(halfDigitLen-1))\\n                    while firstNum % 2 == 0 or firstNum % 5 == 0:\\n                        leftSideNum += 10**(halfDigitLen-1)\\n                        firstNum = leftSideNum//(10**(halfDigitLen-1))\\n\\n                # If can not find prime with current length \\n                # then add 2 to length. 999 -> 10000 (3->5)\\n                return self.primePalindrome(10**(digitLen+1))\\n\\n    def isPrime(self, x: int) -> bool:\\n        notEnoughPrime = True\\n        for prime in self.primes:\\n            if prime*prime > x: \\n                notEnoughPrime = False\\n                break\\n            if x % prime == 0: \\n                return False\\n            \\n        if notEnoughPrime:\\n            num = self.primes[-1] + 1\\n            while num*num <= x:\\n                if self.isPrime(num):\\n                    self.primes.append(num)\\n                num += 1\\n            for prime in self.primes:\\n                if x % prime == 0: \\n                    return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    primes = [2]\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        # Find palindrome number first, then check it is a prime number.\\n        \\n        # Elimiate special case 2 and 11.\\n        if N < 3: return 2\\n        elif 7 < N <= 11: return 11\\n\\n        # Record the number of digits.\\n        num, digitLen = N, 0\\n        while num > 0:\\n            num = num // 10\\n            digitLen += 1\\n\\n        # Even length palindromes are divisible by 11,\\n        # it will be non-prime number except for 11 itself.\\n        if digitLen % 2 == 0:\\n            return self.primePalindrome(10**(digitLen))\\n        else:\\n            halfDigitLen = digitLen//2\\n            # All number which length is one, is palindrome number.\\n            if halfDigitLen == 0:\\n                for num in range(N, 10):\\n                    if self.isPrime(num):\\n                        return num\\n            # If length is bigger than one.\\n            # Split the palindrome number into three part, left, middle, right\\n            # We need to find palindrome number in ascending way.\\n            # So first decide left side number then middle number.(right number don\\'t matter if it\\'s palindrome number)\\n            else:\\n                # first digit of left side number has to be 1, otherwise it would not be the same number of digits.\\n                # If 7 digits number => left side number is 100 ~ 999\\n                leftSideNum = 10**(halfDigitLen-1)\\n                while leftSideNum < 10**halfDigitLen:\\n\\n                    # Caculate right side number\\n                    rightSideNum = 0\\n                    for digit in range(halfDigitLen):\\n                        rightSideNum += (leftSideNum%(10**(digit+1))//(10**digit))*(10**(halfDigitLen-digit-1))\\n                    \\n                    # middle number is 0 ~ 9\\n                    for middleNum in range(10):\\n                        num = rightSideNum + leftSideNum*(10**(halfDigitLen+1)) + middleNum*(10**halfDigitLen)\\n                        if num >= N:\\n                            if self.isPrime(num): \\n                                return num\\n\\n                    leftSideNum += 1\\n                    # The while statement just to elimiate last digit is multiple of 2 or 5\\n                    # which definitely not the prime number.\\n                    firstNum = leftSideNum//(10**(halfDigitLen-1))\\n                    while firstNum % 2 == 0 or firstNum % 5 == 0:\\n                        leftSideNum += 10**(halfDigitLen-1)\\n                        firstNum = leftSideNum//(10**(halfDigitLen-1))\\n\\n                # If can not find prime with current length \\n                # then add 2 to length. 999 -> 10000 (3->5)\\n                return self.primePalindrome(10**(digitLen+1))\\n\\n    def isPrime(self, x: int) -> bool:\\n        notEnoughPrime = True\\n        for prime in self.primes:\\n            if prime*prime > x: \\n                notEnoughPrime = False\\n                break\\n            if x % prime == 0: \\n                return False\\n            \\n        if notEnoughPrime:\\n            num = self.primes[-1] + 1\\n            while num*num <= x:\\n                if self.isPrime(num):\\n                    self.primes.append(num)\\n                num += 1\\n            for prime in self.primes:\\n                if x % prime == 0: \\n                    return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990925,
                "title": "time-limit-exceeded",
                "content": "The following code runs fine in my pc with build time of around 700-900ms but leetcode says time limit exceeded.\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        int result = N;\\n        for(int i=N; i>=N; i++){\\n            //System.out.print(i);\\n            if(isPrime(i) && isPalindrome(i)){\\n                //System.out.println(\"   \"+isPrime(i)+\"   \"+isPalindrome(i));\\n                result = i;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    static boolean isPrime(int N){\\n        boolean isPrime = true;\\n        if(N==2) return true;\\n        else if(N==1 || N==0) return false;\\n        for(int i=2; i<=Math.ceil((Math.sqrt(N))); i++){\\n            if(N%i == 0){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n        return isPrime;\\n    }\\n\\n    static boolean isPalindrome(int num){\\n        String numText = String.valueOf(num);\\n        boolean isPalindrome = true;\\n        for(int i=0, j=numText.length()-1; i<numText.length(); i++, j--){\\n            if(numText.charAt(i) == numText.charAt(j)){\\n                continue;\\n            }else{\\n                isPalindrome = false;\\n                break;\\n            }\\n        }\\n        return isPalindrome;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        int result = N;\\n        for(int i=N; i>=N; i++){\\n            //System.out.print(i);\\n            if(isPrime(i) && isPalindrome(i)){\\n                //System.out.println(\"   \"+isPrime(i)+\"   \"+isPalindrome(i));\\n                result = i;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    static boolean isPrime(int N){\\n        boolean isPrime = true;\\n        if(N==2) return true;\\n        else if(N==1 || N==0) return false;\\n        for(int i=2; i<=Math.ceil((Math.sqrt(N))); i++){\\n            if(N%i == 0){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n        return isPrime;\\n    }\\n\\n    static boolean isPalindrome(int num){\\n        String numText = String.valueOf(num);\\n        boolean isPalindrome = true;\\n        for(int i=0, j=numText.length()-1; i<numText.length(); i++, j--){\\n            if(numText.charAt(i) == numText.charAt(j)){\\n                continue;\\n            }else{\\n                isPalindrome = false;\\n                break;\\n            }\\n        }\\n        return isPalindrome;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886996,
                "title": "fermat-s-little-theorem-and-euler-theorem",
                "content": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    bool pal(int n){\\n        int num=n;\\n        int ret=0;\\n        while (num){\\n            int rem=num%10;\\n            ret=ret*10+rem;\\n            num/=10;\\n        }\\n        return ret==n;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        for (int i=N;i<=1e9;i++){\\n            if (pal(i) and fermatPrime(i)) return i;\\n            if (i>1e7 and i<1e8) i=1e8;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    bool pal(int n){\\n        int num=n;\\n        int ret=0;\\n        while (num){\\n            int rem=num%10;\\n            ret=ret*10+rem;\\n            num/=10;\\n        }\\n        return ret==n;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        for (int i=N;i<=1e9;i++){\\n            if (pal(i) and fermatPrime(i)) return i;\\n            if (i>1e7 and i<1e8) i=1e8;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881250,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(reverse(N) == N && isPrime(N))\\n            return N;\\n        int next = N;\\n        while (true) {\\n            String nextString = findNext(next);\\n            next = Integer.parseInt(nextString);\\n            if(next == 11)\\n                return next;\\n            if(nextString.length()%2 == 0){\\n                int length = nextString.length();\\n                nextString = \"1\";\\n                while(length-- > 0)\\n                    nextString += \"0\";\\n                next = Integer.parseInt(nextString);\\n            }\\n            else if(isPrime(next))\\n                return next;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n    private String findNext(int num){\\n        String s = Integer.toString(num);\\n        char [] n = s.toCharArray();\\n        int start = 0;\\n        int end = n.length - 1;\\n        boolean reverse = true;\\n        while(start <= end){\\n            if(n[start] < n[end]){\\n                n[end] = n[start];\\n                reverse = true;\\n            }\\n            else if(n[start] > n[end]){\\n                n[end] = n[start];\\n                reverse = false;\\n            }\\n            start++;\\n            end --;\\n        }\\n        if(!reverse)\\n            return new String(n);\\n        start--;\\n        end++;\\n        while(start >=0 && n[start] == \\'9\\'){\\n            n[start] = \\'0\\';\\n            n[end] = \\'0\\';\\n            start--;\\n            end++;\\n        }\\n        if(start < 0){\\n            n[end-1] = \\'1\\';\\n            return \"1\"+new String(n);\\n        }\\n        else{\\n            char temp  = (char)(n[start] +1);\\n            n[start] = temp;\\n            n[end] = temp;\\n            return new String(n);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(reverse(N) == N && isPrime(N))\\n            return N;\\n        int next = N;\\n        while (true) {\\n            String nextString = findNext(next);\\n            next = Integer.parseInt(nextString);\\n            if(next == 11)\\n                return next;\\n            if(nextString.length()%2 == 0){\\n                int length = nextString.length();\\n                nextString = \"1\";\\n                while(length-- > 0)\\n                    nextString += \"0\";\\n                next = Integer.parseInt(nextString);\\n            }\\n            else if(isPrime(next))\\n                return next;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n    private String findNext(int num){\\n        String s = Integer.toString(num);\\n        char [] n = s.toCharArray();\\n        int start = 0;\\n        int end = n.length - 1;\\n        boolean reverse = true;\\n        while(start <= end){\\n            if(n[start] < n[end]){\\n                n[end] = n[start];\\n                reverse = true;\\n            }\\n            else if(n[start] > n[end]){\\n                n[end] = n[start];\\n                reverse = false;\\n            }\\n            start++;\\n            end --;\\n        }\\n        if(!reverse)\\n            return new String(n);\\n        start--;\\n        end++;\\n        while(start >=0 && n[start] == \\'9\\'){\\n            n[start] = \\'0\\';\\n            n[end] = \\'0\\';\\n            start--;\\n            end++;\\n        }\\n        if(start < 0){\\n            n[end-1] = \\'1\\';\\n            return \"1\"+new String(n);\\n        }\\n        else{\\n            char temp  = (char)(n[start] +1);\\n            n[start] = temp;\\n            n[end] = temp;\\n            return new String(n);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868157,
                "title": "python-creating-palindrome-list",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isprime(x):\\n            if x <= 1:\\n                return False\\n            i = 2\\n            while i*i <= x:\\n                if x%i == 0:\\n                    return False\\n                i += 1\\n            return True\\n        \\n        pals = [[] for i in range(9)]\\n        pals[0] = [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n        pals[1] =[\\'00\\',\\'11\\',\\'22\\',\\'33\\',\\'44\\',\\'55\\',\\'66\\',\\'77\\',\\'88\\',\\'99\\']\\n        for i in range(2,8):\\n            pals[i] = [x[0]+y+x[1] for y in pals[i-2] for x in pals[1]]\\n        pals[8] = [\\'1\\'+y+\\'1\\' for y in pals[6]]\\n        nums = sorted(int(x) for y in pals for x in y)\\n        for x in nums[bisect.bisect_left(nums,N):]:\\n            if isprime(x):\\n                return(x)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isprime(x):\\n            if x <= 1:\\n                return False\\n            i = 2\\n            while i*i <= x:\\n                if x%i == 0:\\n                    return False\\n                i += 1\\n            return True\\n        \\n        pals = [[] for i in range(9)]\\n        pals[0] = [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n        pals[1] =[\\'00\\',\\'11\\',\\'22\\',\\'33\\',\\'44\\',\\'55\\',\\'66\\',\\'77\\',\\'88\\',\\'99\\']\\n        for i in range(2,8):\\n            pals[i] = [x[0]+y+x[1] for y in pals[i-2] for x in pals[1]]\\n        pals[8] = [\\'1\\'+y+\\'1\\' for y in pals[6]]\\n        nums = sorted(int(x) for y in pals for x in y)\\n        for x in nums[bisect.bisect_left(nums,N):]:\\n            if isprime(x):\\n                return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803639,
                "title": "go-0ms-solution",
                "content": "```go\\nfunc primePalindrome(N int) int {\\n\\tnumberInStr := strconv.Itoa(N)\\n\\tnumberInBytes := []byte(numberInStr)\\n\\tfor i := 0; i < len(numberInBytes)/2; i++ {\\n\\t\\tnumberInBytes[len(numberInBytes)-1-i] = numberInBytes[i]\\n\\t}\\n\\tif string(numberInBytes) < numberInStr {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tfor !isPrime(string(numberInBytes)) {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tv, _ := strconv.Atoi(string(numberInBytes))\\n\\treturn v\\n}\\n\\nfunc next(number []byte) []byte {\\n\\tm := len(number) / 2\\n\\tif len(number)%2 == 0 {\\n\\t\\tm--\\n\\t}\\n\\tfor m >= 0 {\\n\\t\\tif number[m] != \\'9\\' {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tm--\\n\\t}\\n\\tif m < 0 {\\n\\t\\tnumber[0] = \\'1\\'\\n\\t\\tfor i := 1; i < len(number); i++ {\\n\\t\\t\\tnumber[i] = \\'0\\'\\n\\t\\t}\\n\\t\\tnumber = append(number, \\'1\\')\\n\\t\\treturn number\\n\\t}\\n\\tnumber[m]++\\n\\tif len(number)-1-m != m {\\n\\t\\tnumber[len(number)-1-m]++\\n\\t}\\n\\tfor i := m + 1; i < len(number)/2; i++ {\\n\\t\\tnumber[i] = \\'0\\'\\n\\t\\tnumber[len(number)-1-i] = \\'0\\'\\n\\t}\\n\\tif len(number)%2 != 0 {\\n\\t\\tif m != len(number)/2 {\\n\\t\\t\\tnumber[len(number)/2] = \\'0\\'\\n\\t\\t}\\n\\t}\\n\\treturn number\\n}\\n\\nfunc isPrime(v string) bool {\\n\\tif v == \"1\" {\\n\\t\\treturn false\\n\\t}\\n\\tif v == \"2\" {\\n\\t\\treturn true\\n\\t}\\n\\tvi, _ := strconv.Atoi(v)\\n\\tif vi%2 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tm := int(math.Sqrt(float64(vi)))\\n\\tfor i := 3; i <= m; i += 2 {\\n\\t\\tif vi%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc primePalindrome(N int) int {\\n\\tnumberInStr := strconv.Itoa(N)\\n\\tnumberInBytes := []byte(numberInStr)\\n\\tfor i := 0; i < len(numberInBytes)/2; i++ {\\n\\t\\tnumberInBytes[len(numberInBytes)-1-i] = numberInBytes[i]\\n\\t}\\n\\tif string(numberInBytes) < numberInStr {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tfor !isPrime(string(numberInBytes)) {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tv, _ := strconv.Atoi(string(numberInBytes))\\n\\treturn v\\n}\\n\\nfunc next(number []byte) []byte {\\n\\tm := len(number) / 2\\n\\tif len(number)%2 == 0 {\\n\\t\\tm--\\n\\t}\\n\\tfor m >= 0 {\\n\\t\\tif number[m] != \\'9\\' {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tm--\\n\\t}\\n\\tif m < 0 {\\n\\t\\tnumber[0] = \\'1\\'\\n\\t\\tfor i := 1; i < len(number); i++ {\\n\\t\\t\\tnumber[i] = \\'0\\'\\n\\t\\t}\\n\\t\\tnumber = append(number, \\'1\\')\\n\\t\\treturn number\\n\\t}\\n\\tnumber[m]++\\n\\tif len(number)-1-m != m {\\n\\t\\tnumber[len(number)-1-m]++\\n\\t}\\n\\tfor i := m + 1; i < len(number)/2; i++ {\\n\\t\\tnumber[i] = \\'0\\'\\n\\t\\tnumber[len(number)-1-i] = \\'0\\'\\n\\t}\\n\\tif len(number)%2 != 0 {\\n\\t\\tif m != len(number)/2 {\\n\\t\\t\\tnumber[len(number)/2] = \\'0\\'\\n\\t\\t}\\n\\t}\\n\\treturn number\\n}\\n\\nfunc isPrime(v string) bool {\\n\\tif v == \"1\" {\\n\\t\\treturn false\\n\\t}\\n\\tif v == \"2\" {\\n\\t\\treturn true\\n\\t}\\n\\tvi, _ := strconv.Atoi(v)\\n\\tif vi%2 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tm := int(math.Sqrt(float64(vi)))\\n\\tfor i := 3; i <= m; i += 2 {\\n\\t\\tif vi%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792259,
                "title": "get-the-set-of-palindromes-first-and-filter-out-non-prime-and-smaller-ones",
                "content": "With one optimization that cuts the search space by removing the even palindrome\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N <= 11) {\\n            for (int i = 2; i <= 11; ++i) {\\n                if (i >= N && (i == 2 || i == 3 || i == 5 || i == 7 || i == 11)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        for (int i = 10; i < 100000; ++i) {\\n            string leftAndMid = to_string(i);\\n            string right = to_string(i / 10);\\n            right = string(rbegin(right), rend(right));\\n            int palindrome = stoi(leftAndMid + right);\\n            if (palindrome >= N && isPrime(palindrome)) {\\n                return palindrome;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nprivate:\\n    bool isPrime(int palindrome) {\\n        for (int i = 2; i <= int(sqrt(palindrome)); ++i) {\\n            if (palindrome % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N <= 11) {\\n            for (int i = 2; i <= 11; ++i) {\\n                if (i >= N && (i == 2 || i == 3 || i == 5 || i == 7 || i == 11)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        for (int i = 10; i < 100000; ++i) {\\n            string leftAndMid = to_string(i);\\n            string right = to_string(i / 10);\\n            right = string(rbegin(right), rend(right));\\n            int palindrome = stoi(leftAndMid + right);\\n            if (palindrome >= N && isPrime(palindrome)) {\\n                return palindrome;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nprivate:\\n    bool isPrime(int palindrome) {\\n        for (int i = 2; i <= int(sqrt(palindrome)); ++i) {\\n            if (palindrome % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774233,
                "title": "go-100-8ms",
                "content": "```\\nfunc primePalindrome(N int) int {\\n    if N<=2{\\n        return 2\\n    }\\n    number:=N\\n    for {\\n        adjustNumber(&number)\\n        if isPalindrome(number) && isPrime(number){\\n           return number\\n        }\\n        number+=2\\n    }\\n    return -1\\n}\\n\\nfunc adjustNumber(number *int){\\n    /* \\n\\t   Even digits palindrome property:  Always divisible by 11\\n\\t   \\n\\t   1st digit(odd th) == last digit(even th)\\n\\t   2nd digit(even th) == last 2nd digit(odd th)\\n\\t   \\n\\t   11 Divisibility Test : <https://www.math.hmc.edu/funfacts>.\\n\\t   \\n\\t   Take the alternating sum of the digits in the number, read from left to right. \\n\\t   If that is divisible by  11, so is the original number\\n\\t   \\n\\t   22 --> 2-2 = 0\\n\\t   1221 --> 1-2+2-1 = 0 \\n\\t   134431 --> 1-3+4-4+3-1=0\\n\\t   \\n\\t   Now since 11 is a prime number itself ; it will qualify but others will not\\n\\t*/\\n\\t\\n\\t// 11 divisibility test and adjustment\\n    inputNumber:=*number\\n    digits:=0\\n    for inputNumber>0{\\n        digits++\\n        inputNumber/=10\\n    }\\n    if digits%2==0 && *number>11{\\n        newNumber:=1\\n        for i:=0;i<digits;i++{\\n            newNumber*=10\\n        }\\n        *number=newNumber+1\\n    }\\n    // 2 divisibility test and adjustment\\n    if *number%2==0{\\n        *number++\\n    }\\n\\t\\n\\t//Note : Can probably add tests and adjustments for other prime numbers but need draw a line somewhere\\n}\\n\\nfunc isPrime(number int)bool{\\n    root:=int(math.Sqrt(float64(number)))\\n    for i:=2; i<=root;i++{\\n        if number%i==0{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc isPalindrome(number int)bool{\\n    s:=strconv.Itoa(number)\\n    i:=0\\n    j:=len(s)-1\\n    for i<j{\\n        if s[i]!=s[j]{\\n            return false\\n        }\\n        i++\\n        j--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n    if N<=2{\\n        return 2\\n    }\\n    number:=N\\n    for {\\n        adjustNumber(&number)\\n        if isPalindrome(number) && isPrime(number){\\n           return number\\n        }\\n        number+=2\\n    }\\n    return -1\\n}\\n\\nfunc adjustNumber(number *int){\\n    /* \\n\\t   Even digits palindrome property:  Always divisible by 11\\n\\t   \\n\\t   1st digit(odd th) == last digit(even th)\\n\\t   2nd digit(even th) == last 2nd digit(odd th)\\n\\t   \\n\\t   11 Divisibility Test : <https://www.math.hmc.edu/funfacts>.\\n\\t   \\n\\t   Take the alternating sum of the digits in the number, read from left to right. \\n\\t   If that is divisible by  11, so is the original number\\n\\t   \\n\\t   22 --> 2-2 = 0\\n\\t   1221 --> 1-2+2-1 = 0 \\n\\t   134431 --> 1-3+4-4+3-1=0\\n\\t   \\n\\t   Now since 11 is a prime number itself ; it will qualify but others will not\\n\\t*/\\n\\t\\n\\t// 11 divisibility test and adjustment\\n    inputNumber:=*number\\n    digits:=0\\n    for inputNumber>0{\\n        digits++\\n        inputNumber/=10\\n    }\\n    if digits%2==0 && *number>11{\\n        newNumber:=1\\n        for i:=0;i<digits;i++{\\n            newNumber*=10\\n        }\\n        *number=newNumber+1\\n    }\\n    // 2 divisibility test and adjustment\\n    if *number%2==0{\\n        *number++\\n    }\\n\\t\\n\\t//Note : Can probably add tests and adjustments for other prime numbers but need draw a line somewhere\\n}\\n\\nfunc isPrime(number int)bool{\\n    root:=int(math.Sqrt(float64(number)))\\n    for i:=2; i<=root;i++{\\n        if number%i==0{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc isPalindrome(number int)bool{\\n    s:=strconv.Itoa(number)\\n    i:=0\\n    j:=len(s)-1\\n    for i<j{\\n        if s[i]!=s[j]{\\n            return false\\n        }\\n        i++\\n        j--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770493,
                "title": "c-solution-using-next-palindrome-method",
                "content": "Idea is to generate the next smallest palindrome in O(length(N)) time and then check if it is a prime number or not.\\n\\n```\\nclass Solution {\\npublic:\\n    int nextpalin(int t)\\n    {\\n        vector<int> nums;\\n        bool an=true;\\n        while(t)\\n        {\\n            nums.push_back(t%10);\\n            t/=10;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=9)\\n            {\\n                an=false;\\n                break;\\n            }\\n        }\\n        if(an)\\n        {\\n            string temp=\"1\";\\n            for(int i=0;i<nums.size()-1;i++)\\n                temp+=\\'0\\';\\n            temp+=\\'1\\';\\n            return stoi(temp);\\n        }\\n        reverse(nums.begin(),nums.end());\\n        int size=nums.size();\\n        int mid=size/2;\\n        int i=mid-1,j;\\n        if(size%2!=0)\\n        j=mid+1;\\n        else\\n        j=mid;\\n        while(i>=0 and j<size and nums[i]==nums[j])\\n        {\\n            i--;\\n            j++;\\n        }\\n        if(i<0 or nums[i]<nums[j])\\n        {\\n            int i=mid-1,j,k;\\n            int carry=1;\\n            if(size%2)\\n            {\\n                k=size/2;\\n                nums[k]+=carry;\\n                carry=nums[k]/10;\\n                nums[k]%=10;\\n                j=mid+1;\\n            }\\n            else\\n                j=mid;\\n            while (i >= 0) \\n            { \\n            nums[i] += carry; \\n            carry = nums[i] / 10; \\n            nums[i] %= 10; \\n            nums[j++] = nums[i--]; \\n            } \\n        }\\n        else\\n        {\\n        while(i>=0)\\n        nums[j++]=nums[i--];\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n        }\\n        return stoi(ans);\\n    }\\npublic:\\n    bool ispalin(int num)\\n    {\\n        string g=to_string(num);\\n        int l=0,h=g.length()-1;\\n        while(l<h)\\n        {\\n            if(g[l]!=g[h])\\n                return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isprime(int num)\\n    {\\n        if(num==1)return false;\\n        int s=sqrt(num);\\n        for(int i=2;i<=s;i++)\\n        {\\n            if(num%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(ispalin(N) and isprime(N))\\n            return N;\\n        int ans=-1;\\n        while(true)\\n        {   \\n            int np=nextpalin(N);\\n            // cout<<\"Next palindrome \"<<np<<endl;\\n            if(isprime(np))\\n            {\\n                ans=np;\\n                break;\\n            }\\n            N=np;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextpalin(int t)\\n    {\\n        vector<int> nums;\\n        bool an=true;\\n        while(t)\\n        {\\n            nums.push_back(t%10);\\n            t/=10;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=9)\\n            {\\n                an=false;\\n                break;\\n            }\\n        }\\n        if(an)\\n        {\\n            string temp=\"1\";\\n            for(int i=0;i<nums.size()-1;i++)\\n                temp+=\\'0\\';\\n            temp+=\\'1\\';\\n            return stoi(temp);\\n        }\\n        reverse(nums.begin(),nums.end());\\n        int size=nums.size();\\n        int mid=size/2;\\n        int i=mid-1,j;\\n        if(size%2!=0)\\n        j=mid+1;\\n        else\\n        j=mid;\\n        while(i>=0 and j<size and nums[i]==nums[j])\\n        {\\n            i--;\\n            j++;\\n        }\\n        if(i<0 or nums[i]<nums[j])\\n        {\\n            int i=mid-1,j,k;\\n            int carry=1;\\n            if(size%2)\\n            {\\n                k=size/2;\\n                nums[k]+=carry;\\n                carry=nums[k]/10;\\n                nums[k]%=10;\\n                j=mid+1;\\n            }\\n            else\\n                j=mid;\\n            while (i >= 0) \\n            { \\n            nums[i] += carry; \\n            carry = nums[i] / 10; \\n            nums[i] %= 10; \\n            nums[j++] = nums[i--]; \\n            } \\n        }\\n        else\\n        {\\n        while(i>=0)\\n        nums[j++]=nums[i--];\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n        }\\n        return stoi(ans);\\n    }\\npublic:\\n    bool ispalin(int num)\\n    {\\n        string g=to_string(num);\\n        int l=0,h=g.length()-1;\\n        while(l<h)\\n        {\\n            if(g[l]!=g[h])\\n                return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isprime(int num)\\n    {\\n        if(num==1)return false;\\n        int s=sqrt(num);\\n        for(int i=2;i<=s;i++)\\n        {\\n            if(num%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(ispalin(N) and isprime(N))\\n            return N;\\n        int ans=-1;\\n        while(true)\\n        {   \\n            int np=nextpalin(N);\\n            // cout<<\"Next palindrome \"<<np<<endl;\\n            if(isprime(np))\\n            {\\n                ans=np;\\n                break;\\n            }\\n            N=np;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 748585,
                "title": "scalable-and-comprehensible-solution-in-python-construct-palindrome",
                "content": "This solution is constructing palindrome, checking whether it is prime, and tail recurse with 1 more digit. Skip numbers with even digits, because lee215 proved that all palindrome with even length is multiple of 11. This is scalable when the number larger than 10 ** 8, as it iterate only on palindromes.\\n\\n```\\nclass Solution:\\n    def isPrime(self, n: int) -> bool:\\n        return n > 1 and all(n % i != 0 for i in range(2, int(n ** 0.5 + 1)))\\n    \\n    def primePalindrome(self, N: int) -> int:\\n        length = len(strN := str(N))\\n        firstHalf = strN[: int((length + 1) / 2)]\\n        firstHalfLength = len(firstHalf)\\n                \\n        # All palindrome with even length is multiple of 11\\n        if 8 <= N <= 11:\\n            return 11\\n        if length > 2 and length % 2 == 0:\\n            return self.primePalindrome(10 ** length)\\n        \\n        while len(firstHalf) <= firstHalfLength:\\n            pali = int(firstHalf + firstHalf[-2::-1]) # construct palindrome\\n            if pali >= N and self.isPrime(pali):\\n                return pali\\n            firstHalf = str(int(firstHalf) + 1)\\n        else:\\n            return self.primePalindrome(10 ** length)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrime(self, n: int) -> bool:\\n        return n > 1 and all(n % i != 0 for i in range(2, int(n ** 0.5 + 1)))\\n    \\n    def primePalindrome(self, N: int) -> int:\\n        length = len(strN := str(N))\\n        firstHalf = strN[: int((length + 1) / 2)]\\n        firstHalfLength = len(firstHalf)\\n                \\n        # All palindrome with even length is multiple of 11\\n        if 8 <= N <= 11:\\n            return 11\\n        if length > 2 and length % 2 == 0:\\n            return self.primePalindrome(10 ** length)\\n        \\n        while len(firstHalf) <= firstHalfLength:\\n            pali = int(firstHalf + firstHalf[-2::-1]) # construct palindrome\\n            if pali >= N and self.isPrime(pali):\\n                return pali\\n            firstHalf = str(int(firstHalf) + 1)\\n        else:\\n            return self.primePalindrome(10 ** length)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744904,
                "title": "standard-java-solution",
                "content": "### Theory\\nSo apparently for some reason we can exclude 8 digit numbers. We can start from N, and scan our way up to a valid palindrome. Its important we check for palindrome competency first, vs doing the heavy lifting to determine if the candidate number is prime.\\n\\n### Solution\\n```\\n    public int primePalindrome(int N) {\\n        while (true) {\\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n            if (10000000 < N && N < 100000000) N = 100000000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        for (int i = 2; i * i <= N; i++) {\\n            if (N % i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int num = 0;\\n        while (N > 0) {\\n            num = 10 * num + (N % 10);\\n            N /= 10;\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int primePalindrome(int N) {\\n        while (true) {\\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n            if (10000000 < N && N < 100000000) N = 100000000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        for (int i = 2; i * i <= N; i++) {\\n            if (N % i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int num = 0;\\n        while (N > 0) {\\n            num = 10 * num + (N % 10);\\n            N /= 10;\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 730083,
                "title": "rust-translated",
                "content": "Runtime: 24 ms, faster than 100.00% of Rust online submissions for Prime Palindrome.\\nMemory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Prime Palindrome.\\n\\n```rust\\nimpl Solution {\\n    pub fn prime_palindrome(mut n: i32) -> i32 {\\n        fn sqrt(x: i32) -> i32 {\\n            if x < 2 {\\n                return x;\\n            };\\n            let mut left = 1;\\n            let mut right = x;\\n            let mut middle = 1;\\n            loop {\\n                middle = (left + right) / 2;\\n                if middle > x / middle {\\n                    right = middle - 1;\\n                } else {\\n                    left = middle + 1;\\n                    if left > x / left {\\n                        return middle;\\n                    }\\n                }\\n            }\\n        }\\n\\n        fn is_prime(n: i32) -> bool {\\n            if n < 2 {\\n                return false;\\n            } else if n == 2 {\\n                return true;\\n            }\\n            if n % 2 == 0 {\\n                return false;\\n            }\\n            for i in (3..sqrt(n) + 1).step_by(2) {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        match n {\\n            1 => 2,\\n            2 => 2,\\n            3 => 3,\\n            4 => 5,\\n            5 => 5,\\n            6 => 7,\\n            7 => 7,\\n            8..=11 => 11,\\n            _ => {\\n                for x in 1..100000 {\\n                    let mut s = x.to_string();\\n                    let len = s.len();\\n                    let r = s.chars().rev().skip(1).collect::<String>();\\n                    s.push_str(&r);\\n                    let y = s.parse::<i32>().unwrap();\\n                    if y >= n && is_prime(y) {\\n                        return y;\\n                    }\\n                }\\n                std::i32::MIN // unreachable!()\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_prime_palindrome() {\\n        assert_eq!(Solution::prime_palindrome(6), 7)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_02() {\\n        assert_eq!(Solution::prime_palindrome(8), 11)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_03() {\\n        assert_eq!(Solution::prime_palindrome(13), 101)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_04() {\\n        assert_eq!(Solution::prime_palindrome(45887963), 100030001)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn prime_palindrome(mut n: i32) -> i32 {\\n        fn sqrt(x: i32) -> i32 {\\n            if x < 2 {\\n                return x;\\n            };\\n            let mut left = 1;\\n            let mut right = x;\\n            let mut middle = 1;\\n            loop {\\n                middle = (left + right) / 2;\\n                if middle > x / middle {\\n                    right = middle - 1;\\n                } else {\\n                    left = middle + 1;\\n                    if left > x / left {\\n                        return middle;\\n                    }\\n                }\\n            }\\n        }\\n\\n        fn is_prime(n: i32) -> bool {\\n            if n < 2 {\\n                return false;\\n            } else if n == 2 {\\n                return true;\\n            }\\n            if n % 2 == 0 {\\n                return false;\\n            }\\n            for i in (3..sqrt(n) + 1).step_by(2) {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        match n {\\n            1 => 2,\\n            2 => 2,\\n            3 => 3,\\n            4 => 5,\\n            5 => 5,\\n            6 => 7,\\n            7 => 7,\\n            8..=11 => 11,\\n            _ => {\\n                for x in 1..100000 {\\n                    let mut s = x.to_string();\\n                    let len = s.len();\\n                    let r = s.chars().rev().skip(1).collect::<String>();\\n                    s.push_str(&r);\\n                    let y = s.parse::<i32>().unwrap();\\n                    if y >= n && is_prime(y) {\\n                        return y;\\n                    }\\n                }\\n                std::i32::MIN // unreachable!()\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_prime_palindrome() {\\n        assert_eq!(Solution::prime_palindrome(6), 7)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_02() {\\n        assert_eq!(Solution::prime_palindrome(8), 11)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_03() {\\n        assert_eq!(Solution::prime_palindrome(13), 101)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_04() {\\n        assert_eq!(Solution::prime_palindrome(45887963), 100030001)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726410,
                "title": "solution-based-on-mapping-numbers-to-odd-and-even-length-palindromes",
                "content": "Every number can be used to construct two palindromes.\\n\\n1. Odd-length palindrome by concating the sequence of digits in the number with the reverse of the digits in the quotient from dividing the number by 10, e.g., \"897\" + \"98\" = \"89798\"\\n2. Even-length palindrome by concating the sequence of digits in the number with the reverse of the same sequence, e.g., \"897\" + \"798\" = \"897798\".\\n\\nThe special cases can help simplify the logic in the main loop.\\n\\n```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        def is_prime(n: int) -> bool:\\n            import math\\n            \\n            return n > 1 and all(n%i for i in range(2, int(math.sqrt(n))+1))\\n\\n        def palindromes(n: int) -> int:\\n            import itertools\\n            \\n\\t\\t\\t# Special odd-length cases\\n            yield from range(10)  \\n\\t\\t\\t\\n\\t\\t\\t# Since there is no corresponding odd-length cases to generate in the loop, extract these even-length cases out of the loop\\n            yield from range(11, 100, 11) \\n            \\n            for half_length in itertools.count(2):\\n                halves = range(int(10**(half_length-1)), int(10**half_length))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# odd length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[-2::-1])\\n                    \\n\\t\\t\\t\\t# even length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[::-1])\\n                \\n        for i in palindromes(N):\\n            if i >= N and is_prime(i):\\n                return i\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        def is_prime(n: int) -> bool:\\n            import math\\n            \\n            return n > 1 and all(n%i for i in range(2, int(math.sqrt(n))+1))\\n\\n        def palindromes(n: int) -> int:\\n            import itertools\\n            \\n\\t\\t\\t# Special odd-length cases\\n            yield from range(10)  \\n\\t\\t\\t\\n\\t\\t\\t# Since there is no corresponding odd-length cases to generate in the loop, extract these even-length cases out of the loop\\n            yield from range(11, 100, 11) \\n            \\n            for half_length in itertools.count(2):\\n                halves = range(int(10**(half_length-1)), int(10**half_length))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# odd length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[-2::-1])\\n                    \\n\\t\\t\\t\\t# even length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[::-1])\\n                \\n        for i in palindromes(N):\\n            if i >= N and is_prime(i):\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698063,
                "title": "bruteforce-approach",
                "content": "class Solution {\\npublic:\\n    int digit_count(int N){\\n        int temp=0;\\n        while(N){\\n        N=N/10;\\n            temp++;\\n    }\\n        return temp;\\n    }\\n    bool isPrime(int N){\\n        if(N<2) return false;\\n        for(int i=2;i*i<=N;i++){\\n            if(N%i==0) return false; \\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int N){\\n        long long int ans=0;\\n        int p=N;\\n        if(N<10) return true;\\n        while(N>0){\\n            int rem=N%10;\\n            ans=ans*10+rem;\\n                N=N/10;\\n        }\\n        if(p==ans) return true;\\n            else return false;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        while(true){\\n            if(N>=8 && N<=11) return 11;\\n        if(isPrime(N)&&isPalindrome(N)){\\n            return N;\\n        }\\n        int count=digit_count(N);\\n            if(count & 1){\\n                N++;\\n            }\\n            else{\\n                N=pow(10,count)+1;\\n            }\\n        \\n    }\\n        return N;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int digit_count(int N){\\n        int temp=0;\\n        while(N){\\n        N=N/10;\\n            temp++;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 683142,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is_palin(string str) {\\n        int len = str.length();\\n        int count = 0;\\n        for (int i = 0; i < len / 2; i++) {\\n            if (str[i] == str[len - i - 1]) count++;\\n            else   break;\\n        }\\n        if (count == (len / 2)) return true;\\n        return false;\\n    }\\n    int primePalindrome(int N) {\\n        int val, i = N;\\n        if (N <= 2) return 2;\\n        while(i <= INT_MAX) {\\n            //cout << i << endl;\\n            int start;\\n            if (i % 2)  start = 3;\\n            else    start = 2;\\n            bool prime = true;\\n            if (10000000 < i && i < 100000000)\\n                i = 100000000;\\n            if (!is_palin(to_string(i)))  {\\n                i++;\\n                continue;\\n            }\\n            for (int j = start; j < sqrt(i) + 1; j += 2) {\\n                if (i != j && i % j == 0) {\\n                    prime = false;\\n                    break;\\n                }\\n            }\\n            if (prime) {\\n                val = i;\\n                break;\\n            }\\n            i++;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_palin(string str) {\\n        int len = str.length();\\n        int count = 0;\\n        for (int i = 0; i < len / 2; i++) {\\n            if (str[i] == str[len - i - 1]) count++;\\n            else   break;\\n        }\\n        if (count == (len / 2)) return true;\\n        return false;\\n    }\\n    int primePalindrome(int N) {\\n        int val, i = N;\\n        if (N <= 2) return 2;\\n        while(i <= INT_MAX) {\\n            //cout << i << endl;\\n            int start;\\n            if (i % 2)  start = 3;\\n            else    start = 2;\\n            bool prime = true;\\n            if (10000000 < i && i < 100000000)\\n                i = 100000000;\\n            if (!is_palin(to_string(i)))  {\\n                i++;\\n                continue;\\n            }\\n            for (int j = start; j < sqrt(i) + 1; j += 2) {\\n                if (i != j && i % j == 0) {\\n                    prime = false;\\n                    break;\\n                }\\n            }\\n            if (prime) {\\n                val = i;\\n                break;\\n            }\\n            i++;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 681686,
                "title": "pre-calculated-all-the-palindromes-in-a-list",
                "content": "```\\npublic int primePalindrome(int N) {\\n        List<Integer> list[] = new ArrayList[10];\\n        for(int i=1;i<10;i++){\\n            list[i] = new ArrayList();\\n        }\\n        for(int i=1;i<=9;i++){\\n            list[1].add(i);\\n            list[2].add(10*i + i);\\n        }\\n        int ten = 10;\\n        for(int i=3;i<=9;i++){\\n            if(i % 2 == 1){\\n                for(int j=0;j<list[i-1].size();j++){\\n                    int val = list[i-1].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 10 + k * ten + val % ten);\\n                    }\\n                }\\n            }else{\\n                for(int j=0;j<list[i-2].size();j++){\\n                    int val = list[i-2].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 100 + (10 * k + k) * ten + val % ten);\\n                    }\\n                }\\n                ten *= 10;\\n            }\\n        }\\n        for(int i=1;i<=9;i++){\\n            for(int j=0;j<list[i].size();j++){\\n                if(list[i].get(j) >= N && isPrime(list[i].get(j))){\\n                    return list[i].get(j);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n        for(int i=2;i*i<=n;i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int primePalindrome(int N) {\\n        List<Integer> list[] = new ArrayList[10];\\n        for(int i=1;i<10;i++){\\n            list[i] = new ArrayList();\\n        }\\n        for(int i=1;i<=9;i++){\\n            list[1].add(i);\\n            list[2].add(10*i + i);\\n        }\\n        int ten = 10;\\n        for(int i=3;i<=9;i++){\\n            if(i % 2 == 1){\\n                for(int j=0;j<list[i-1].size();j++){\\n                    int val = list[i-1].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 10 + k * ten + val % ten);\\n                    }\\n                }\\n            }else{\\n                for(int j=0;j<list[i-2].size();j++){\\n                    int val = list[i-2].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 100 + (10 * k + k) * ten + val % ten);\\n                    }\\n                }\\n                ten *= 10;\\n            }\\n        }\\n        for(int i=1;i<=9;i++){\\n            for(int j=0;j<list[i].size();j++){\\n                if(list[i].get(j) >= N && isPrime(list[i].get(j))){\\n                    return list[i].get(j);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n        for(int i=2;i*i<=n;i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643102,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if (n<12){\\n            for (int i=n; i<12; i++){\\n                if (prime(i)) return i;\\n            }\\n        }\\n        vector<int> origin = num2vec(n);\\n        int l = origin.size();\\n        int i = l/2-1;\\n        bool changed = false;\\n        for (int i=0; i<l/2; i++){\\n            if (origin[l-1-i]>origin[i]){\\n                origin[i] = origin[l-1-i];\\n                changed = true;\\n            }else{\\n                origin[l-1-i] = origin[i];\\n            }\\n        }\\n        if (l%2==1){\\n            origin[l/2] = 0;\\n        }\\n        int res = vec2num(origin);\\n        while (!prime(res)){\\n            next(origin, l);\\n            res = vec2num(origin);\\n        }\\n        return res;\\n    }\\n    \\n    int findfirst(vector<int> res, int l){\\n        bool changed = false;\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]<res[l-1-i]){\\n                if (changed){\\n                    res[l-1-i] = res[i];\\n                }else{\\n                    res[i] = res[l-i-1];\\n                    changed = true;   \\n                }\\n            }else if (changed){\\n                \\n            }\\n        }\\n    }\\n    \\n    void next(vector<int>& res, int& l){\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]==9){\\n                res[i] = 0; res[l-i-1] = 0;\\n            }else{\\n                res[i]++; res[l-i-1]++; return;\\n            }\\n        }\\n        res[l/2] = 0;\\n        res.push_back(1);\\n        res[0] = 1;\\n        l++;\\n    }\\n    \\n    bool prime(int n){\\n        for (int i=2; i<=sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> num2vec(int n){\\n        vector<int> res;\\n        while (n>0){\\n            res.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    int vec2num(vector<int> res){\\n        int n = 0;\\n        for (int r:res){\\n            n = 10*n + r;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if (n<12){\\n            for (int i=n; i<12; i++){\\n                if (prime(i)) return i;\\n            }\\n        }\\n        vector<int> origin = num2vec(n);\\n        int l = origin.size();\\n        int i = l/2-1;\\n        bool changed = false;\\n        for (int i=0; i<l/2; i++){\\n            if (origin[l-1-i]>origin[i]){\\n                origin[i] = origin[l-1-i];\\n                changed = true;\\n            }else{\\n                origin[l-1-i] = origin[i];\\n            }\\n        }\\n        if (l%2==1){\\n            origin[l/2] = 0;\\n        }\\n        int res = vec2num(origin);\\n        while (!prime(res)){\\n            next(origin, l);\\n            res = vec2num(origin);\\n        }\\n        return res;\\n    }\\n    \\n    int findfirst(vector<int> res, int l){\\n        bool changed = false;\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]<res[l-1-i]){\\n                if (changed){\\n                    res[l-1-i] = res[i];\\n                }else{\\n                    res[i] = res[l-i-1];\\n                    changed = true;   \\n                }\\n            }else if (changed){\\n                \\n            }\\n        }\\n    }\\n    \\n    void next(vector<int>& res, int& l){\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]==9){\\n                res[i] = 0; res[l-i-1] = 0;\\n            }else{\\n                res[i]++; res[l-i-1]++; return;\\n            }\\n        }\\n        res[l/2] = 0;\\n        res.push_back(1);\\n        res[0] = 1;\\n        l++;\\n    }\\n    \\n    bool prime(int n){\\n        for (int i=2; i<=sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> num2vec(int n){\\n        vector<int> res;\\n        while (n>0){\\n            res.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    int vec2num(vector<int> res){\\n        int n = 0;\\n        for (int r:res){\\n            n = 10*n + r;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621473,
                "title": "cheap-solution-faster-than-100-and-less-memory-than-100-python-3",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        legalprimes = [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001]\\n        for p in legalprimes:\\n            if p >= N:\\n                return p\\n\\'\\'\\'\\nbrute forced with a sieve and a palindrome checker\\nmore of a project euler style solution\\nI think its interesting to note that all prime palindromes seem to have an odd number of digits with the only exception being 11.\\nevery other even repunit is divisible by eleven but i would be interested to see a proof as to why only odd digit prime palindromes seem to exist, if there is a proof.\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        legalprimes = [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001]\\n        for p in legalprimes:\\n            if p >= N:\\n                return p\\n\\'\\'\\'\\nbrute forced with a sieve and a palindrome checker\\nmore of a project euler style solution\\nI think its interesting to note that all prime palindromes seem to have an odd number of digits with the only exception being 11.\\nevery other even repunit is divisible by eleven but i would be interested to see a proof as to why only odd digit prime palindromes seem to exist, if there is a proof.\\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 587818,
                "title": "ultra-simple-c-solution-suggestions-for-optimization-are-welcomed-100",
                "content": "Runtime: 884 ms, faster than 100.00% of C online submissions \\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions\\n\\n```\\nint primePalindrome(int N){\\n\\n    \\nunsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;\\n    \\nif(N==1)\\nreturn 2;\\n\\n\\nfor(i=N;;i++)\\n{\\n\\ns=0;\\nrev=0;\\nrem=0;\\n    \\ndummy=i;\\nif(dummy<=11||dummy%2!=0&&dummy%3!=0&&dummy%5!=0&&dummy%7!=0&&dummy%11!=0)\\n{\\nwhile(dummy>0)\\n{\\nrem=dummy%10;\\ns=s+rem;\\nrev=rev*10+rem;\\ndummy=dummy/10;\\n}\\n    \\nif(rev==i)\\n{   \\ns=0;\\nfor(j=2;j<=sqrt(i);j++)\\n{\\nif(i%j==0)\\n{\\n++s;\\nbreak;\\n}\\n}  \\nif(s==0)\\nreturn i;\\n}\\n}\\n}\\nreturn 0;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint primePalindrome(int N){\\n\\n    \\nunsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;\\n    \\nif(N==1)\\nreturn 2;\\n\\n\\nfor(i=N;;i++)\\n{\\n\\ns=0;\\nrev=0;\\nrem=0;\\n    \\ndummy=i;\\nif(dummy<=11||dummy%2!=0&&dummy%3!=0&&dummy%5!=0&&dummy%7!=0&&dummy%11!=0)\\n{\\nwhile(dummy>0)\\n{\\nrem=dummy%10;\\ns=s+rem;\\nrev=rev*10+rem;\\ndummy=dummy/10;\\n}\\n    \\nif(rev==i)\\n{   \\ns=0;\\nfor(j=2;j<=sqrt(i);j++)\\n{\\nif(i%j==0)\\n{\\n++s;\\nbreak;\\n}\\n}  \\nif(s==0)\\nreturn i;\\n}\\n}\\n}\\nreturn 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578941,
                "title": "c-solution-faster-than-89-and-space-less-than-100",
                "content": "```\\nstatic auto func = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    bool is_prime(int n)\\n    {\\n        if(n<2)\\n            return 0;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int reverse(int n)\\n    {\\n        int ret = 0;\\n        int tmp = n;\\n        while(tmp)\\n        {\\n            int rem = tmp%10;\\n            ret = ret*10 + rem;\\n            tmp /= 10;\\n        }\\n        return ret;\\n    }\\n    int digit_count(int n)\\n    {\\n        int ret = 0;\\n        while(n)\\n        {\\n            n/=10;\\n            ret++;\\n        }\\n        return ret;\\n    }\\n    int primePalindrome(int N) {\\n        while(true)\\n        {\\n            if(N>=8 && N<=11)\\n                return 11;\\n            if(reverse(N)==N && is_prime(N))\\n                return N;\\n            int cnt = digit_count(N);\\n            if(cnt&1)\\n                N++;\\n            else\\n                N = pow(10,cnt)+1;\\n        }\\n        return N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto func = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    bool is_prime(int n)\\n    {\\n        if(n<2)\\n            return 0;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int reverse(int n)\\n    {\\n        int ret = 0;\\n        int tmp = n;\\n        while(tmp)\\n        {\\n            int rem = tmp%10;\\n            ret = ret*10 + rem;\\n            tmp /= 10;\\n        }\\n        return ret;\\n    }\\n    int digit_count(int n)\\n    {\\n        int ret = 0;\\n        while(n)\\n        {\\n            n/=10;\\n            ret++;\\n        }\\n        return ret;\\n    }\\n    int primePalindrome(int N) {\\n        while(true)\\n        {\\n            if(N>=8 && N<=11)\\n                return 11;\\n            if(reverse(N)==N && is_prime(N))\\n                return N;\\n            int cnt = digit_count(N);\\n            if(cnt&1)\\n                N++;\\n            else\\n                N = pow(10,cnt)+1;\\n        }\\n        return N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553261,
                "title": "faster-than-81-50-of-java-online-submissions",
                "content": "# Runtime: 29 ms, faster than 81.50% of Java online submissions for Prime Palindrome.\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (true) {\\n             \\n            if(N%2==0 && N>2){\\n               ++ N;\\n            }\\n         \\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n           // all 8 digit palindromes are not prime\\n           if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (true) {\\n             \\n            if(N%2==0 && N>2){\\n               ++ N;\\n            }\\n         \\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n           // all 8 digit palindromes are not prime\\n           if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537994,
                "title": "this-is-an-tricky-question-not-good-for-interview",
                "content": "```\\nclass Solution {\\n    // pali must be odd, since even pali can be devided by 11, if it is not 11.\\n    public int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11) return 11;\\n        for (int i = 1; i < 100000; i++) {\\n            String l = String.valueOf(i), r = new StringBuilder(l).reverse().toString();\\n            String cand = l + r.substring(1);\\n            int n = Integer.parseInt(cand);\\n            if (n >= N && isPrime(n)) return n;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        if (n % 2 == 0) return n == 2;\\n        for (int i = 3; i * i <= n; i++) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nRef: https://leetcode.com/problems/prime-palindrome/discuss/146798/JavaC%2B%2BPython-All-Even-Length-Palindrome-are-Divisible-by-11\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // pali must be odd, since even pali can be devided by 11, if it is not 11.\\n    public int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11) return 11;\\n        for (int i = 1; i < 100000; i++) {\\n            String l = String.valueOf(i), r = new StringBuilder(l).reverse().toString();\\n            String cand = l + r.substring(1);\\n            int n = Integer.parseInt(cand);\\n            if (n >= N && isPrime(n)) return n;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        if (n % 2 == 0) return n == 2;\\n        for (int i = 3; i * i <= n; i++) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518737,
                "title": "solution-c-faster-than-66-and-space-less-than-100",
                "content": "```\\n/*\\n   Allah always watching\\n*/\\nclass Solution {\\npublic:\\nbool prime(int n){\\n              n = abs(n);\\n              if(n < 2) return false;\\n              if(n == 2) return true;\\n              if(n%2 == 0) return false;\\n              for(int i = 3;i<(sqrt(n)+1);i+=2){\\n                            if(n%i == 0) return false;\\n              }\\n              return true;\\n}\\nint cmp(string && s1,string && s2){\\n              if(s1.length() > s2.length()) return 1;\\n              if(s1.length() < s2.length()) return -1;\\n              for(int i = 0;i<s1.length();++i){\\n                            if(s1[i] > s2[i]) return 1;\\n                            if(s1[i] < s2[i]) return -1;\\n              }\\n              return 0;\\n}\\nstring jack(string s,string ss){\\n              if(s.length() == 1){\\n                            while(s[0] <= \\'9\\'){\\n                                          //cout<<s<<endl;\\n                                          if(prime(stoi(s))){\\n                                                        if(cmp(move(s),move(ss)) >= 0)  return s;\\n                                          }\\n                                          s[0] += 1;\\n                            }\\n              }\\n              s = \"11\";\\n              //cout<<s<<endl;\\n              if(cmp(move(s),move(ss)) >= 0)  return s;\\n              while(s.length() < 20){\\n                            int middle = s.length()/2,\\n                                left,\\n                                right;\\n                            if(s.length()%2 == 0){\\n                                       if(s[middle] == \\'9\\'){\\n                                                 s[middle] = \\'0\\';\\n                                                 s[middle-1] = \\'0\\';\\n                                                 left = middle-2;\\n                                                 right = middle+1;\\n                                                 while(left > -1){\\n                                                               if(s[left] != \\'9\\'){\\n                                                                             s[left] += 1;\\n                                                                             s[right] += 1;\\n                                                                             break;\\n                                                               }else{\\n                                                                             s[left] = \\'0\\';\\n                                                                             s[right] = \\'0\\';\\n                                                               }\\n                                                               --left;\\n                                                               ++right;\\n                                                 }\\n                                                 if(left <= -1){\\n                                                               int n = s.length()+1;\\n                                                               s = \"\";\\n                                                               for(int i = 0;i<n;++i){\\n                                                                             if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                             else s+=\\'0\\';\\n                                                               }\\n                                                 }\\n                                       }else{\\n                                                     s[middle]+=1;\\n                                                     s[middle-1]+=1;\\n                                       }\\n                            }else{\\n                                       if(s[middle] == \\'9\\'){\\n                                                     s[middle] = \\'0\\';\\n                                                     left = middle-1;\\n                                                     right = middle+1;\\n                                                     while(left > -1){\\n                                                                   if(s[left] != \\'9\\'){\\n                                                                                 s[left] += 1;\\n                                                                                 s[right] += 1;\\n                                                                                 break;\\n                                                                   }else{\\n                                                                                 s[left] = \\'0\\';\\n                                                                                 s[right] = \\'0\\';\\n                                                                   }\\n                                                                   --left;\\n                                                                   ++right;\\n                                                     }\\n                                                     if(left <= -1){\\n                                                                   int n = s.length()+1;\\n                                                                   s = \"\";\\n                                                                   for(int i = 0;i<n;++i){\\n                                                                                 if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                                 else s+=\\'0\\';\\n                                                                   }\\n                                                     }\\n                                       }else{\\n                                                s[middle] += 1;\\n                                       }\\n                            }\\n                            //cout<<s<<endl;\\n                            if(prime(stoi(s))){\\n                                          if(cmp(move(s),move(ss)) >= 0)  return s;\\n                            }\\n              }\\n              return \"0\";\\n}\\nint primePalindrome(int r) {\\n      string s = to_string(r),\\n             ss;\\n      for(int i = 0;i<s.length();++i) ss += \\'1\\';\\n      return stoi(jack(ss,s));\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n   Allah always watching\\n*/\\nclass Solution {\\npublic:\\nbool prime(int n){\\n              n = abs(n);\\n              if(n < 2) return false;\\n              if(n == 2) return true;\\n              if(n%2 == 0) return false;\\n              for(int i = 3;i<(sqrt(n)+1);i+=2){\\n                            if(n%i == 0) return false;\\n              }\\n              return true;\\n}\\nint cmp(string && s1,string && s2){\\n              if(s1.length() > s2.length()) return 1;\\n              if(s1.length() < s2.length()) return -1;\\n              for(int i = 0;i<s1.length();++i){\\n                            if(s1[i] > s2[i]) return 1;\\n                            if(s1[i] < s2[i]) return -1;\\n              }\\n              return 0;\\n}\\nstring jack(string s,string ss){\\n              if(s.length() == 1){\\n                            while(s[0] <= \\'9\\'){\\n                                          //cout<<s<<endl;\\n                                          if(prime(stoi(s))){\\n                                                        if(cmp(move(s),move(ss)) >= 0)  return s;\\n                                          }\\n                                          s[0] += 1;\\n                            }\\n              }\\n              s = \"11\";\\n              //cout<<s<<endl;\\n              if(cmp(move(s),move(ss)) >= 0)  return s;\\n              while(s.length() < 20){\\n                            int middle = s.length()/2,\\n                                left,\\n                                right;\\n                            if(s.length()%2 == 0){\\n                                       if(s[middle] == \\'9\\'){\\n                                                 s[middle] = \\'0\\';\\n                                                 s[middle-1] = \\'0\\';\\n                                                 left = middle-2;\\n                                                 right = middle+1;\\n                                                 while(left > -1){\\n                                                               if(s[left] != \\'9\\'){\\n                                                                             s[left] += 1;\\n                                                                             s[right] += 1;\\n                                                                             break;\\n                                                               }else{\\n                                                                             s[left] = \\'0\\';\\n                                                                             s[right] = \\'0\\';\\n                                                               }\\n                                                               --left;\\n                                                               ++right;\\n                                                 }\\n                                                 if(left <= -1){\\n                                                               int n = s.length()+1;\\n                                                               s = \"\";\\n                                                               for(int i = 0;i<n;++i){\\n                                                                             if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                             else s+=\\'0\\';\\n                                                               }\\n                                                 }\\n                                       }else{\\n                                                     s[middle]+=1;\\n                                                     s[middle-1]+=1;\\n                                       }\\n                            }else{\\n                                       if(s[middle] == \\'9\\'){\\n                                                     s[middle] = \\'0\\';\\n                                                     left = middle-1;\\n                                                     right = middle+1;\\n                                                     while(left > -1){\\n                                                                   if(s[left] != \\'9\\'){\\n                                                                                 s[left] += 1;\\n                                                                                 s[right] += 1;\\n                                                                                 break;\\n                                                                   }else{\\n                                                                                 s[left] = \\'0\\';\\n                                                                                 s[right] = \\'0\\';\\n                                                                   }\\n                                                                   --left;\\n                                                                   ++right;\\n                                                     }\\n                                                     if(left <= -1){\\n                                                                   int n = s.length()+1;\\n                                                                   s = \"\";\\n                                                                   for(int i = 0;i<n;++i){\\n                                                                                 if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                                 else s+=\\'0\\';\\n                                                                   }\\n                                                     }\\n                                       }else{\\n                                                s[middle] += 1;\\n                                       }\\n                            }\\n                            //cout<<s<<endl;\\n                            if(prime(stoi(s))){\\n                                          if(cmp(move(s),move(ss)) >= 0)  return s;\\n                            }\\n              }\\n              return \"0\";\\n}\\nint primePalindrome(int r) {\\n      string s = to_string(r),\\n             ss;\\n      for(int i = 0;i<s.length();++i) ss += \\'1\\';\\n      return stoi(jack(ss,s));\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 513998,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\nprivate:\\n    int createPalindrome(int i, bool odd, int m) {\\n       stringstream ss;\\n       ss << i;\\n       string s = ss.str();\\n       reverse(s.begin(),s.end());\\n       if(odd) \\n           ss << m;\\n       ss << s;\\n       return stoi(ss.str()); \\n    }\\n    \\n    bool isPrime(int N) {\\n        if (N == 1)\\n            return false;\\n        for (int i=2; i<N; i++) {\\n            if (N % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <10)\\n            for(int i=N; i<10;i++) {\\n                if(isPrime(i))\\n                    return i;\\n            }\\n        \\n        for(int i=1; i<=N;i++) {\\n            int p = createPalindrome(i, false, 0);\\n            if(p >= N && isPrime(p))\\n                return p;\\n            \\n            for (int j=0; j<=9; j++) {\\n                int f = createPalindrome(i, true, j);\\n                if(f >= N && isPrime(f))\\n                    return f;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int createPalindrome(int i, bool odd, int m) {\\n       stringstream ss;\\n       ss << i;\\n       string s = ss.str();\\n       reverse(s.begin(),s.end());\\n       if(odd) \\n           ss << m;\\n       ss << s;\\n       return stoi(ss.str()); \\n    }\\n    \\n    bool isPrime(int N) {\\n        if (N == 1)\\n            return false;\\n        for (int i=2; i<N; i++) {\\n            if (N % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <10)\\n            for(int i=N; i<10;i++) {\\n                if(isPrime(i))\\n                    return i;\\n            }\\n        \\n        for(int i=1; i<=N;i++) {\\n            int p = createPalindrome(i, false, 0);\\n            if(p >= N && isPrime(p))\\n                return p;\\n            \\n            for (int j=0; j<=9; j++) {\\n                int f = createPalindrome(i, true, j);\\n                if(f >= N && isPrime(f))\\n                    return f;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484821,
                "title": "accepted-straightforward-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private bool IsPrime(int num)\\n        {\\n            if (num <= 1)\\n            {\\n                return false;\\n            }\\n\\n            for (int i = 2; i * i <= num; i++)\\n            {\\n                if (num % i == 0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        private int Helper(List<int> nDigits, int n, int idx)\\n        {\\n            checked\\n            {\\n                if (idx > (nDigits.Count - 1) / 2)\\n                {\\n                    int number = 0;\\n                    foreach (var nDigit in nDigits)\\n                    {\\n                        number *= 10;\\n                        number += nDigit;\\n                    }\\n\\n                    if (number >= n && IsPrime(number))\\n                    {\\n                        return number;\\n                    }\\n\\n                    return -1;\\n                }\\n\\n\\n                int start = nDigits[idx];\\n                for (int i = start; i <= 9; i++)\\n                {\\n                    nDigits[idx] = i;\\n                    nDigits[nDigits.Count - 1 - idx] = i;\\n                    var res = Helper(nDigits, n, idx + 1);\\n                    if (res > 0)\\n                    {\\n                        return res;\\n                    }\\n                }\\n\\n                nDigits[idx] = 0;\\n                nDigits[nDigits.Count - 1 - idx] = 0;\\n                return -1;\\n            }\\n        }\\n\\n        public int PrimePalindrome(int n)\\n        {\\n            List<int> nDigits = new List<int>((int)Math.Floor(Math.Log10(n))+1);\\n            var num = n;\\n            while (n != 0)\\n            {\\n                nDigits.Add(n % 10);\\n                n /= 10;\\n            }\\n            nDigits.Reverse();\\n\\n            for (int i = 0; i <= (nDigits.Count - 1) / 2; i++)\\n            {\\n                nDigits[nDigits.Count - 1 - i] = nDigits[i];\\n            }\\n\\n            do\\n            {\\n                var res = Helper(nDigits, num, 0);\\n\\n                if (res > 0)\\n                {\\n                    return res;\\n                }\\n\\n                for (int i = 0; i < nDigits.Count; i++)\\n                {\\n                    nDigits[i] = 0;\\n                }\\n                nDigits[0] = 1;\\n                nDigits.Add(1);\\n\\n            } while (true);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private bool IsPrime(int num)\\n        {\\n            if (num <= 1)\\n            {\\n                return false;\\n            }\\n\\n            for (int i = 2; i * i <= num; i++)\\n            {\\n                if (num % i == 0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        private int Helper(List<int> nDigits, int n, int idx)\\n        {\\n            checked\\n            {\\n                if (idx > (nDigits.Count - 1) / 2)\\n                {\\n                    int number = 0;\\n                    foreach (var nDigit in nDigits)\\n                    {\\n                        number *= 10;\\n                        number += nDigit;\\n                    }\\n\\n                    if (number >= n && IsPrime(number))\\n                    {\\n                        return number;\\n                    }\\n\\n                    return -1;\\n                }\\n\\n\\n                int start = nDigits[idx];\\n                for (int i = start; i <= 9; i++)\\n                {\\n                    nDigits[idx] = i;\\n                    nDigits[nDigits.Count - 1 - idx] = i;\\n                    var res = Helper(nDigits, n, idx + 1);\\n                    if (res > 0)\\n                    {\\n                        return res;\\n                    }\\n                }\\n\\n                nDigits[idx] = 0;\\n                nDigits[nDigits.Count - 1 - idx] = 0;\\n                return -1;\\n            }\\n        }\\n\\n        public int PrimePalindrome(int n)\\n        {\\n            List<int> nDigits = new List<int>((int)Math.Floor(Math.Log10(n))+1);\\n            var num = n;\\n            while (n != 0)\\n            {\\n                nDigits.Add(n % 10);\\n                n /= 10;\\n            }\\n            nDigits.Reverse();\\n\\n            for (int i = 0; i <= (nDigits.Count - 1) / 2; i++)\\n            {\\n                nDigits[nDigits.Count - 1 - i] = nDigits[i];\\n            }\\n\\n            do\\n            {\\n                var res = Helper(nDigits, num, 0);\\n\\n                if (res > 0)\\n                {\\n                    return res;\\n                }\\n\\n                for (int i = 0; i < nDigits.Count; i++)\\n                {\\n                    nDigits[i] = 0;\\n                }\\n                nDigits[0] = 1;\\n                nDigits.Add(1);\\n\\n            } while (true);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468244,
                "title": "python-recursive-method",
                "content": "class Solution:\\n    def primePalindrome(self, n):\\n        if Solution().palindrome(n) == True:\\n            if Solution().prime(n) == True:\\n                return n\\n            else:\\n                Solution().primePalindrome(n+1)\\n        else:\\n            Solution().primePalindrome(n + 1)\\n\\n    def prime(self,n):\\n        for i in range(2,n-1):\\n            if n%i == 0:\\n                return False\\n        return True\\n\\n    def palindrome(self,n):\\n        if str(n)== str(n)[::-1]:\\n            return True\\n        else:\\n            return False\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def primePalindrome(self, n):\\n        if Solution().palindrome(n) == True:\\n            if Solution().prime(n) == True:\\n                return n\\n            else:\\n                Solution().primePalindrome(n+1)\\n        else:\\n            Solution().primePalindrome(n + 1)\\n\\n    def prime(self,n):\\n        for i in range(2,n-1):\\n            if n%i == 0:\\n                return False\\n        return True\\n\\n    def palindrome(self,n):\\n        if str(n)== str(n)[::-1]:\\n            return True\\n        else:\\n            return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 457047,
                "title": "go-build-odd-length-prime-solution",
                "content": "```\\nfunc primePalindrome(N int) int {\\n\\tif N >= 8 && N <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor i := 1; i <= 20000; i++ {\\n\\t\\tnumStr := strconv.Itoa(i)\\n\\t\\tnumStr += reverseStr(numStr)[1:]\\n\\t\\tnum, _ := strconv.Atoi(numStr)\\n\\t\\tif num >= N && isPrime(num) {\\n\\t\\t\\treturn num\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc reverseStr(s string) string {\\n\\tstr := []byte(s)\\n\\tfor i := 0; i < len(str)/2; i++ {\\n\\t\\tstr[i], str[len(str)-i-1] = str[len(str)-i-1], str[i]\\n\\t}\\n\\treturn string(str)\\n}\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\tfor i := 3; i*i <= n; i++ {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n\\tif N >= 8 && N <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor i := 1; i <= 20000; i++ {\\n\\t\\tnumStr := strconv.Itoa(i)\\n\\t\\tnumStr += reverseStr(numStr)[1:]\\n\\t\\tnum, _ := strconv.Atoi(numStr)\\n\\t\\tif num >= N && isPrime(num) {\\n\\t\\t\\treturn num\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc reverseStr(s string) string {\\n\\tstr := []byte(s)\\n\\tfor i := 0; i < len(str)/2; i++ {\\n\\t\\tstr[i], str[len(str)-i-1] = str[len(str)-i-1], str[i]\\n\\t}\\n\\treturn string(str)\\n}\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\tfor i := 3; i*i <= n; i++ {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442570,
                "title": "c-first-palindrome-next-palindrome",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N);\\n    bool isPrime(int n);\\n    bool isPalindrome(int n);\\n    int nextPalindrome(int n);\\n    int firstPalindrome(int n);\\n};\\n\\nbool Solution::isPrime(int n)\\n{\\n\\tfor (int i = 2; i*i <= n; i++) {\\n\\t\\tif (n % i == 0) \\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nbool Solution::isPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\tint i = 0, j = str.size()-1;\\n\\twhile (i < j) {\\n\\t\\tif (str[i++] != str[j--])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nint Solution::nextPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[i] = str[j] = \\'0\\';\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tstr[j] = str[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\tif (i < 0) {\\n\\t\\tstr += \\'1\\';\\n\\t\\tstr[0] = \\'1\\';\\n\\t}\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::firstPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i > 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[j++] = str[i--] = \\'0\\';\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\t\\n\\t}\\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tstr[j] = str[i];\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::primePalindrome(int N)\\n{\\n\\tint n = N;\\n\\tif (n == 1)  n = 2;\\n\\t\\n\\tif (!isPalindrome(n)) \\n\\t\\tn = firstPalindrome(n);\\n\\t\\t\\n\\twhile (true) {\\n\\t\\t//cout << n << endl;\\n\\t\\tif (n >= N)\\n\\t\\t\\tif (isPrime(n))\\n\\t\\t\\t\\tbreak;\\n\\t\\tn = nextPalindrome(n);\\n\\t}\\n\\t\\n\\treturn n;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N);\\n    bool isPrime(int n);\\n    bool isPalindrome(int n);\\n    int nextPalindrome(int n);\\n    int firstPalindrome(int n);\\n};\\n\\nbool Solution::isPrime(int n)\\n{\\n\\tfor (int i = 2; i*i <= n; i++) {\\n\\t\\tif (n % i == 0) \\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nbool Solution::isPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\tint i = 0, j = str.size()-1;\\n\\twhile (i < j) {\\n\\t\\tif (str[i++] != str[j--])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nint Solution::nextPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[i] = str[j] = \\'0\\';\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tstr[j] = str[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\tif (i < 0) {\\n\\t\\tstr += \\'1\\';\\n\\t\\tstr[0] = \\'1\\';\\n\\t}\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::firstPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i > 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[j++] = str[i--] = \\'0\\';\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\t\\n\\t}\\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tstr[j] = str[i];\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::primePalindrome(int N)\\n{\\n\\tint n = N;\\n\\tif (n == 1)  n = 2;\\n\\t\\n\\tif (!isPalindrome(n)) \\n\\t\\tn = firstPalindrome(n);\\n\\t\\t\\n\\twhile (true) {\\n\\t\\t//cout << n << endl;\\n\\t\\tif (n >= N)\\n\\t\\t\\tif (isPrime(n))\\n\\t\\t\\t\\tbreak;\\n\\t\\tn = nextPalindrome(n);\\n\\t}\\n\\t\\n\\treturn n;\\n}\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1907331,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 1868032,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 2069858,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 1926163,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check If It Is a Good Array",
        "question_content": "<p>Given an array <code>nums</code> of&nbsp;positive integers. Your task is to select some subset of <code>nums</code>, multiply each element by an integer and add all these numbers.&nbsp;The array is said to be&nbsp;<strong>good&nbsp;</strong>if you can obtain a sum of&nbsp;<code>1</code>&nbsp;from the array by any possible subset and multiplicand.</p>\n\n<p>Return&nbsp;<code>True</code>&nbsp;if the array is <strong>good&nbsp;</strong>otherwise&nbsp;return&nbsp;<code>False</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,5,7,23]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Pick numbers 5 and 7.\n5*3 + 7*(-2) = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [29,6,10]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Pick numbers 29, 6 and 10.\n29*1 + 6*(-3) + 10*(-1) = 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 419368,
                "title": "java-c-python-chinese-remainder-theorem",
                "content": "## **Intuition**\\nThis problem is realated a Chinese theorem:\\nChinese remainder theorem, created in 5th centry.\\nAlso well known as Hanson Counting.\\n<br>\\n\\n## **Explanation**\\nIf `a % x = 0` and `b % x = 0`,\\nappareantly we have `(pa + qb) % x == 0`\\nIf `x > 1`, making it impossible `pa + qb = 1`.\\n\\nWell, I never heard of Bezout\\'s identity.\\nEven though the intuition only proves the necessary condition,\\nit\\'s totally enough.\\n\\nThe process of gcd,\\nis exactly the process to get the factor.\\nThe problem just doesn\\'t ask this part.\\n<br>\\n\\n## **Complexity**\\nOf course you can return true as soon as `gcd = 1`\\nI take gcd calculate as `O(1)`.\\n\\nTime `O(N)`\\uFF0C\\nSpace `O(1)`\\n\\n<br>\\n\\n**Java:**\\n```java\\n    public boolean isGoodArray(int[] A) {\\n        int x = A[0], y;\\n        for (int a: A) {\\n            while (a > 0) {\\n                y = x % a;\\n                x = a;\\n                a = y;\\n            }\\n        }\\n        return x == 1;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool isGoodArray(vector<int>& A) {\\n        int res = A[0];\\n        for (int a: A)\\n            res = gcd(res, a);\\n        return res == 1;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def isGoodArray(self, A):\\n        gcd = A[0]\\n        for a in A:\\n            while a:\\n                gcd, a = a, gcd % a\\n        return gcd == 1\\n```\\n\\n**Python, 1-line using fractions**\\n```python\\nimport fractions\\nclass Solution(object):\\n    def isGoodArray(self, A):\\n        return reduce(fractions.gcd, A) < 2\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean isGoodArray(int[] A) {\\n        int x = A[0], y;\\n        for (int a: A) {\\n            while (a > 0) {\\n                y = x % a;\\n                x = a;\\n                a = y;\\n            }\\n        }\\n        return x == 1;\\n    }\\n```\n```cpp\\n    bool isGoodArray(vector<int>& A) {\\n        int res = A[0];\\n        for (int a: A)\\n            res = gcd(res, a);\\n        return res == 1;\\n    }\\n```\n```python\\n    def isGoodArray(self, A):\\n        gcd = A[0]\\n        for a in A:\\n            while a:\\n                gcd, a = a, gcd % a\\n        return gcd == 1\\n```\n```python\\nimport fractions\\nclass Solution(object):\\n    def isGoodArray(self, A):\\n        return reduce(fractions.gcd, A) < 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419324,
                "title": "bezout-s-identity",
                "content": "Read (https://brilliant.org/wiki/bezouts-identity/, https://en.wikipedia.org/wiki/B\\xE9zout%27s_identity)\\n\\nThe basic idea is that for integers a and b, if gcd(a,b) = d, then there exist integers x and y, s.t  a * x + b * y = d;\\n\\nThis can be generalized for (n >= 2) .  e.g.  if gcd(a,b,c) = d, then there exist integers x, y, and z, s.t, a* x + b*y + c * z = d.\\n\\nNow this problem is just asking if gcd(x1, ......, xn) = 1\\n\\n```\\nclass Solution {\\n\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if (nums.size() == 1) return nums[0] == 1;\\n        \\n        int a = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (__gcd(a, nums[i]) == 1) return true;\\n            a = __gcd(a, nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if (nums.size() == 1) return nums[0] == 1;\\n        \\n        int a = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (__gcd(a, nums[i]) == 1) return true;\\n            a = __gcd(a, nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422624,
                "title": "the-whole-logic",
                "content": "The solution should be clear at this point. Here I\\'d like to tidy up the whole logic to have a better understanding of the solution.\\n1. \"B\\xE9zout\\'s identity:  (the GCD of a and b) is the smallest positive linear combination of non-zero a and b\"[1]\\n2.  For this problem, if we can find any subset, which can generate gcd(subset) = 1, it is true. Otherwise, the gcd will be greater than 1, it is obvious that it is false.\\n3.  If **any subset** of the whole nums list has a gcd(subset)=1, then gcd(nums)=1 as:\\n    a) The gcd is a commutative function: gcd(a, b) = gcd(b, a) [2]\\n    b) The gcd is an associative function: gcd(a, gcd(b, c)) = gcd(gcd(a, b), c). [2]\\n    c) If none of a1, a2, . . . , ar is zero, then gcd( a1, a2, . . . , ar ) = gcd( gcd( a1, a2, . . . , ar-1 ), ar ) [2]\\n    d) It should be trival that gcd(1, n) where n is a non negative interger to be 1.\\n4. based on 3, we change check \\'whether we have gcd of **any subset** to be 1\\' to \\'check whether the gcd of the whole nums list is 1\\' as: if we have a subset {**a, e, f**} and gcd(a, e, f)=1, and the whole list contains {**a,** b, c, d, **e, f**}. Based on 3a), we will have gcd(a, b, c) = gcd( gcd(a,b), c)  based on 3b)  gcd(a,gcd(b,c))=gcd(gcd(a,b),c). Based on 3a)and 3b) gcd(gcd(a,b),c) = gcd(c, gcd(a,b)) = gcd(gd(c, a), b). We can get general assocation by changing gcd(**a,** b, c, d, **e, f**)  to gcd(gcd(b,c,d), gcd(a,e,f))=1.\\n\\n**Reference**\\n[1] https://eli.thegreenplace.net/2009/07/10/the-gcd-and-linear-combinations\\n[2] https://en.wikipedia.org/wiki/Greatest_common_divisor",
                "solutionTags": [],
                "code": "The solution should be clear at this point. Here I\\'d like to tidy up the whole logic to have a better understanding of the solution.\\n1. \"B\\xE9zout\\'s identity:  (the GCD of a and b) is the smallest positive linear combination of non-zero a and b\"[1]\\n2.  For this problem, if we can find any subset, which can generate gcd(subset) = 1, it is true. Otherwise, the gcd will be greater than 1, it is obvious that it is false.\\n3.  If **any subset** of the whole nums list has a gcd(subset)=1, then gcd(nums)=1 as:\\n    a) The gcd is a commutative function: gcd(a, b) = gcd(b, a) [2]\\n    b) The gcd is an associative function: gcd(a, gcd(b, c)) = gcd(gcd(a, b), c). [2]\\n    c) If none of a1, a2, . . . , ar is zero, then gcd( a1, a2, . . . , ar ) = gcd( gcd( a1, a2, . . . , ar-1 ), ar ) [2]\\n    d) It should be trival that gcd(1, n) where n is a non negative interger to be 1.\\n4. based on 3, we change check \\'whether we have gcd of **any subset** to be 1\\' to \\'check whether the gcd of the whole nums list is 1\\' as: if we have a subset {**a, e, f**} and gcd(a, e, f)=1, and the whole list contains {**a,** b, c, d, **e, f**}. Based on 3a), we will have gcd(a, b, c) = gcd( gcd(a,b), c)  based on 3b)  gcd(a,gcd(b,c))=gcd(gcd(a,b),c). Based on 3a)and 3b) gcd(gcd(a,b),c) = gcd(c, gcd(a,b)) = gcd(gd(c, a), b). We can get general assocation by changing gcd(**a,** b, c, d, **e, f**)  to gcd(gcd(b,c,d), gcd(a,e,f))=1.\\n\\n**Reference**\\n[1] https://eli.thegreenplace.net/2009/07/10/the-gcd-and-linear-combinations\\n[2] https://en.wikipedia.org/wiki/Greatest_common_divisor",
                "codeTag": "Unknown"
            },
            {
                "id": 419619,
                "title": "c-3-lines",
                "content": "```\\nbool isGoodArray(vector<int>& nums) {\\n    auto gcd = nums[0];\\n    for (auto n : nums) gcd = __gcd(gcd, n);\\n    return gcd == 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isGoodArray(vector<int>& nums) {\\n    auto gcd = nums[0];\\n    for (auto n : nums) gcd = __gcd(gcd, n);\\n    return gcd == 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 438263,
                "title": "trivial-is-the-new-hard",
                "content": "```\\ndef is_good_array(nums)\\n  nums.reduce(:gcd) == 1\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_good_array(nums)\\n  nums.reduce(:gcd) == 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2072260,
                "title": "rigorous-proof-for-solving-the-problem",
                "content": "Note: In this proof, a notable amount of subscript is used. However since it is not exactly feasible to properly format the subscript, instead array index is used in place of subscript. For example, `t[i]` will be used instead of t<sub>i</sub>.\\n \\n **Foundation**\\n ___\\n\\nTo begin, the foundation for the proof is to be laid out. First, the congruence relation (`\\u2261`) and some of its properties are presented\\n\\n**Definition:** `a \\u2261 r (mod d)` is an expression equivalent to the equation `a = qd + r` where:\\n- `q` (quotient) is an integer that follows `q = floor(a / d)`,\\n- `d` (divisor) is a variable integer\\n- `r` (remainder) is an integer that follows `r = a modulo d`, `0 \\u2264 r, < d`\\n- `a` is variable integer, particularly serves as dividend.\\n\\nThis expression and equation stems from a division operation: `a / d`.\\n\\n**Example:** Suppose a division operation is given as follows:\\n```c\\n29 / 8\\n```\\nBy definition, the quotient and remainder can be found:\\n```c\\nq = floor(29 / 8)\\nq = 3\\n\\nr = 29 modulo 8\\nr = 5\\n```\\nEquivalently, this can be represented as:\\n```c\\n29 = 3(q) * 8(d) + 5(r)\\n```\\nor\\n```\\n29 \\u2261 5 (mod 8)\\n```\\n\\n**Definition:** Addition, subtraction, and multiplication operation on integers preserves their congruence relation.\\n\\n**Example:** Addition. Suppose the following equation in a congruence system of 4 (i.e. `... \\u2261 ... (mod 4)`:\\n```c\\n5 + 10\\n```\\nThe congruence relation of the equation\\'s outcome is equal to adding each of the element\\'s congruence in the equation.\\n```\\nThe congruence relation of the equation\\'s outcome\\n5 + 10 = 15\\n15 \\u2261 3 (mod 4)\\n\\nAdding each of the element\\'s congruence\\n5 \\u2261 1 (mod 4)\\n10 \\u2261 2 (mod 4)\\n1 (mod 4) + 2 (mod 4) = 3 (mod 4)\\n```\\n\\n**Example:** Subtraction. Suppose the following equation in a congruence system of 7 i.e. (`... \\u2261 ... (mod 7)`:\\n```c\\n16 - 3\\n```\\nThe congruence relation of the equation\\'s outcome is equal to subtracting the element\\'s congruence in the equation.\\n```\\nThe congruence relation of the equation\\'s outcome\\n16 - 3 = 13\\n13 \\u2261 6 (mod 7)\\n\\nSubtracting each of the element\\'s congruence\\n16 \\u2261 2 (mod 7)\\n3 \\u2261 3 (mod 7)\\n2 (mod 7) - 3 (mod 7) = -1 (mod 7)\\n2 (mod 7) - 3 (mod 7) = 6 (mod 7)\\n```\\nIn the last line, the equation underflows back to positive because `r` is limited to be `0 \\u2264 r < d`.\\n\\n**Example:** Multiplication. Suppose the following equation in a congruence system of 9 i.e. (... \\u2261 ... (mod 9)`):\\n```c\\n20 * 16\\n```\\nThe congruence relation of the equation\\'s outcome is equal to multiplying each of the element\\'s congruence in the equation.\\n```c\\nThe congruence relation of the equation\\'s outcome\\n20 * 16 = 320\\n320 \\u2261 5 (mod 9)\\n\\nMultiplying each of the element\\'s congruence in the equation.\\n20 \\u2261 2 (mod 9)\\n16 \\u2261 7 (mod 9)\\n2 (mod 9) * 7 (mod 9) = 14 (mod 9)\\n2 (mod 9) * 7 (mod 9) = 5 (mod 9)\\n```\\nIn the last line, the answer is reduced down so that 14 is under 9, because `r` is limited to be `0 \\u2264 r < d)`.\\n\\n**Theorem I: Bezout Identity (special case, reworded).** There exists some pair of integer `(p, q)` such that given two integer `a` and `b` where both are coprime (i.e. `gcd(a, b) = 1`), the equation `1 = ab + pq` can be made. [1, with modification]\\n\\n*Proof*\\nFirst, the following equation is formally presented, By definition,\\n```\\ngcd(a, b) = 1\\n1 = ab + pq, for some integer pair (p, q)\\n```\\nTherefore,\\n```\\ngcd(a, b) = ab + pq, for some integer pair (p, q)    -- (1)\\n```\\nThe only time two positive integers namely `a` and `b`, and for the sake of proof, `a > b`, can result in 1 by following the equation `ap + bq` for some variable `p` and `q`, is when `a` and `b` are coprime i.e. `gcd(a, b) = 1`. It is impossible to create 1 if this condition is not met, because when `g = gcd(a, b)` and `g != 1` that means `a \\u2261 0 (mod g)` and `b \\u2261 0 (mod g)`. It follows that when a number `n \\u2261 0 (mod g)`, its multiple will also be `0 (mod g)` i.e.\\n\\n```\\nn \\u2261 0 (mod g)\\nn * x \\u2261 0 * x (mod g), for some integer x\\nnx \\u2261 0 (mod g), for some integer x\\n```\\nTherefore both `a` and `b` will not have any multiple that when divided by `g` will result in some remainder.\\n\\nAdding (and subtracting) `a` and `b` will also result in `0 (mod g)` i.e.\\n\\n```\\na + b \\u2261 (0 + 0) (mod g)\\na + b \\u2261 0 (mod g)\\n```\\n```\\na - b \\u2261 (0 - 0) (mod g)\\na - b \\u2261 0 (mod g)\\n```\\nAll of this lead to the conclusion that all arithmetical operation except division using `a` and `b` all will result in a number multiple of `g`. This implies that it is impossible to generate a number other than `g` and its multiple. And since `g != 1` it is impossible to generate an integer 1 altogether. Therefore, it is necessary for `g = 1`, where `g = gcd(a, b)`, holds true to generate 1. \\u25A0\\n\\n**Proof**\\n___\\n\\n**Hypothesis I:** Solving for `gcd` function(s) is equivalent to solving the problem.\\n\\n*Proof*\\nThe `gcd` of any two number can be used in the process of determining if it is possible to reach an integer 1 i.e. it is possible to do something along the line of\\n```\\nv = c[1] * a + c[2] * gcd(m, n)    -- (2)\\n```\\nwhere `c` are free variable. This is allowed because that expression can be expanded to the expression stated in the problem i.e. \"multiply each element by an integer and add all these numbers.\" which when formulated can be represented as follows:\\n\\n**Problem Function Statement**\\n```\\nv = c[1] * i[1] + c[2] * i[2] + ... + c[n] * i[n]\\nv = sum(c[x] * i[x]) for 1 \\u2264 x \\u2264 n    -- (3)\\n```\\nwhere `c` are free variables and `i` are some selected number from `nums`.\\n\\nThe expansion of equation (2) follows the equations below.\\n```\\nv = c[1] * a + c[2] * gcd(m, n)\\nv = c[1] * a + c[2] * (mp + nq)   -- (applying (1))\\nv = c[1] * a + (p * c[2]) * m + (q * c[2]) * n\\nv = c[1] * a + p\\' * m + q\\' * n    -- (4)\\n```\\nwhere `c`, `p`, `q` are some free variables and `p\\' = p * c[2]` and `q\\' = q * c[2]`. Both `p\\'` and `q\\'` are actually free variables too as both can be manipulated such that `p\\'` and `q\\'` are determined first, then `p`, `q`, and `c[2]` is determined to suit the equation. It can be seen easily that equation (4) follows the form of problem function statement (equation (3)).\\n\\nThe `gcd` of some numbers can be used as input to `gcd` function when finding the solution i.e.\\n\\n```\\nv = gcd(gcd(m, n), gcd(o, p))\\nv = gcd((c[m] * m + c[n] * n),(c[o] * o, c[p] * p))    -- (applying(1))\\nv = c[mn] * (c[m] * m + c[n] * n) + c[op] * (c[o] * o + c[p] * p) -- (applying (1))\\nv = c[mn] * c[m] * m + c[mn] * c[n] * n + c[op] * c[o] * o + c[op] * c[p] * p\\nv = (c[mn] * c[m]) * m + (c[mn] * c[n]) * n + (c[op] * c[o]) * o + (c[op] * c[p]) * p\\nv = c[mn,m] * m + c[mn,n] * n + c[op,o] * o + c[op,p] * p    -- (5)\\n```\\nwhere `c[x]` is a free variable. Once again, equation (5) follows the form of problem function statement (equation (2)). This shows that solving `gcd(gcd(a, b), gcd(c, d))` for some `a`, `b`, `c`, and `d` is equivalent to solving the problem function statement (equation (2)). Therefore, arriving to the solution in the problem function statement can be done by using `gcd` function, which proves the hypothesis true. \\u25A0\\n\\n**Corollary I:** The variant where one of the parameter in the outer `gcd` function is an integer (instead of `gcd` function) e.g. `gcd(a, gcd(b, c))` follows the same process and therefore the conclusion also holds in this variation.\\n\\n**Corollary II:** `gcd` of two number can be used as an intermediary value for some next iteration of `gcd` function when solving the problem.\\n\\nIt has been established that the solution to the problem can be reduced to whether it is possible to find any set of number in `nums` such that their `gcd` is 1. From previous explanation it should be relatively easy to intuitively deduce that the value `v` from equation (5) is in fact the `gcd` to all input in question. For the sake of completeness of the proof along with providing the correctness of the algorithm that can be used to solve the problem, the next section will discuss the correctness of the following hypothesis.\\n\\n**Hypothesis II:** `gcd` function with more than two parameters can be built on `gcd` function with two parameters.\\n\\n*Proof*\\nThe hypothesis will be proved using two lemmata:\\n\\n*Lemma I: Given `w = gcd(gcd(a, b), c)`, `w` divides `a`, `b`, and `c`.*\\n\\nPreviously it has been stated that the `gcd` of two input can be used as the input of another `gcd` function. This finding can be utilized to find the `gcd` of a set of number, instead of only two.  Consider the following equation.\\n```\\ngcd(a, b) = v\\n```\\nBy definition, this means that:\\n(1) `v|a` (read: `v` divides `a`)\\n(2) `v \\u2264 a` as direct consequence of (1)\\n(3) `v|b` (read: `v` divides `b`)\\n(4) `v \\u2264 b` as direct consequence of (2)\\n(5) There is no `n > v` such that `n|a` and `n|b`\\n\\nNext, consider the following equation.\\n```\\ngcd(v, c) = w\\n```\\nBy definition, this means that:\\n(6) `w|v`\\n(7) `w \\u2264 v` as direct consequence of (6)\\n(8) `w|c`\\n(9) `w \\u2264 c` as direct conseuquence of (9)\\n(10) There is no `m > w` such that `m|v` and `m|c`\\n\\nOne property of divisibility states that if `x|y` and `y|z`, that means `x|z` (for additional reading material, see [2]). Returning to the previous findings,\\n\\n(6) `w|v` + (1) `v|a` \\u2192 (11) `w|a`\\n(6) `w|v` + (3) `v|b` \\u2192 (12) `w|b`\\n\\nCombining (8), (11) and (12) shows that `w = gcd(v, c)` where `v = gcd(a, b)`, `w` divides all the input namely `a`, `b`, and `c`. This proves that `w` is a common divisor of `a`, `b`, and `c`.\\n\\n*Lemma II: Given `w = gcd(gcd(a, b), c)`, there can be no `x > w` such that `x` divides `a`, `b`, and `c`.*\\n\\nWhat is left to do now is to show that `w` is in fact the greatest value possible for `a`, `b`, and `c`. This easily follows using the definition of `gcd`:\\n\\n(5) There is no `n > v` such that `n|a` and `n|b` (from `v = gcd(a, b)`)\\n(7) `w \\u2264 v` as direct consequence of (6) (from `w = gcd(v, c)`)\\n(10) There is no `m > w` such that `m|v` and `m|c` (from `w = gcd(v, c)`)\\n\\nThese statement holds true by definition. Using these statements, the following premises can be derived:\\n\\n- Applying the boundary in (7) to (5) gives: (13) There is no `n > w` such that `n|a` and `n|b`\\n- Combining premise (13) with (10) gives: (14) **There is no `m > w` such that `m|v`, `m|a`, `m|b`, and `m|c`**\\n\\nTherefore, `w` is in fact the biggest value possible that can factor `a`, `b`, and `c`. \\u25A0\\n\\nBy combining the two lemma:\\nLemma I: Given `w = gcd(gcd(a, b), c)`, `w` divides `a`, `b`, and `c`.\\nLemma II: Given `w = gcd(gcd(a, b), c)`, there can be no `x > w` such that `x` divides `a`, `b`, and `c`.\\nit can be concluded that chaining 2-ary `gcd` function will output the greatest common divisor for all the input in question. That is,\\n\\n```\\ngcd(a, b, c, ...) = gcd(gcd(a, b), c, ...)\\n```\\n\\nUsing Hypothesis II, the core algorithm to solve the problem can be constructed by means of the following pseudocode,\\n\\n```c++\\nInput: nums - an array of integers\\n\\nlet hcf \\u2190 gcd(nums[1], nums[2])\\nfor i from 3 to nums.length:\\n\\thcf \\u2190 gcd(hcf, nums[i])\\nif hcf equal to 1:\\n\\treturn true\\nelse:\\n\\treturn false\\n```\\nVariation can be made, for example, to quit early when at one point it has been established that `hcf` is 1. The `gcd` function implementation can use the Euclidean Algorithm [4].\\n\\nReference:\\n[1] Bezout\\'s Identity, https://en.wikipedia.org/wiki/B\\xE9zout%27s_identity (accessed at 24th May 2022)\\n[2] Properties of Divisibility, https://ccssmathanswers.com/properties-of-divisibility/ (accessed at 24th May 2022)\\n[3] Greatest Common Divisor, https://en.wikipedia.org/wiki/Greatest_common_divisor (accessed at 25th May 2022)\\n[4] Euclidean Algorithm, https://en.wikipedia.org/wiki/Euclidean_algorithm#Procedure (accessed at 25th May 2022)\\n\\n<small>Here\\'s hoping for LaTeX typesetting support</small>",
                "solutionTags": [],
                "code": "```c\\n29 / 8\\n```\n```c\\nq = floor(29 / 8)\\nq = 3\\n\\nr = 29 modulo 8\\nr = 5\\n```\n```c\\n29 = 3(q) * 8(d) + 5(r)\\n```\n```\\n29 \\u2261 5 (mod 8)\\n```\n```c\\n5 + 10\\n```\n```\\nThe congruence relation of the equation\\'s outcome\\n5 + 10 = 15\\n15 \\u2261 3 (mod 4)\\n\\nAdding each of the element\\'s congruence\\n5 \\u2261 1 (mod 4)\\n10 \\u2261 2 (mod 4)\\n1 (mod 4) + 2 (mod 4) = 3 (mod 4)\\n```\n```c\\n16 - 3\\n```\n```\\nThe congruence relation of the equation\\'s outcome\\n16 - 3 = 13\\n13 \\u2261 6 (mod 7)\\n\\nSubtracting each of the element\\'s congruence\\n16 \\u2261 2 (mod 7)\\n3 \\u2261 3 (mod 7)\\n2 (mod 7) - 3 (mod 7) = -1 (mod 7)\\n2 (mod 7) - 3 (mod 7) = 6 (mod 7)\\n```\n```c\\n20 * 16\\n```\n```c\\nThe congruence relation of the equation\\'s outcome\\n20 * 16 = 320\\n320 \\u2261 5 (mod 9)\\n\\nMultiplying each of the element\\'s congruence in the equation.\\n20 \\u2261 2 (mod 9)\\n16 \\u2261 7 (mod 9)\\n2 (mod 9) * 7 (mod 9) = 14 (mod 9)\\n2 (mod 9) * 7 (mod 9) = 5 (mod 9)\\n```\n```\\ngcd(a, b) = 1\\n1 = ab + pq, for some integer pair (p, q)\\n```\n```\\ngcd(a, b) = ab + pq, for some integer pair (p, q)    -- (1)\\n```\n```\\nn \\u2261 0 (mod g)\\nn * x \\u2261 0 * x (mod g), for some integer x\\nnx \\u2261 0 (mod g), for some integer x\\n```\n```\\na + b \\u2261 (0 + 0) (mod g)\\na + b \\u2261 0 (mod g)\\n```\n```\\na - b \\u2261 (0 - 0) (mod g)\\na - b \\u2261 0 (mod g)\\n```\n```\\nv = c[1] * a + c[2] * gcd(m, n)    -- (2)\\n```\n```\\nv = c[1] * i[1] + c[2] * i[2] + ... + c[n] * i[n]\\nv = sum(c[x] * i[x]) for 1 \\u2264 x \\u2264 n    -- (3)\\n```\n```\\nv = c[1] * a + c[2] * gcd(m, n)\\nv = c[1] * a + c[2] * (mp + nq)   -- (applying (1))\\nv = c[1] * a + (p * c[2]) * m + (q * c[2]) * n\\nv = c[1] * a + p\\' * m + q\\' * n    -- (4)\\n```\n```\\nv = gcd(gcd(m, n), gcd(o, p))\\nv = gcd((c[m] * m + c[n] * n),(c[o] * o, c[p] * p))    -- (applying(1))\\nv = c[mn] * (c[m] * m + c[n] * n) + c[op] * (c[o] * o + c[p] * p) -- (applying (1))\\nv = c[mn] * c[m] * m + c[mn] * c[n] * n + c[op] * c[o] * o + c[op] * c[p] * p\\nv = (c[mn] * c[m]) * m + (c[mn] * c[n]) * n + (c[op] * c[o]) * o + (c[op] * c[p]) * p\\nv = c[mn,m] * m + c[mn,n] * n + c[op,o] * o + c[op,p] * p    -- (5)\\n```\n```\\ngcd(a, b) = v\\n```\n```\\ngcd(v, c) = w\\n```\n```\\ngcd(a, b, c, ...) = gcd(gcd(a, b), c, ...)\\n```\n```c++\\nInput: nums - an array of integers\\n\\nlet hcf \\u2190 gcd(nums[1], nums[2])\\nfor i from 3 to nums.length:\\n\\thcf \\u2190 gcd(hcf, nums[i])\\nif hcf equal to 1:\\n\\treturn true\\nelse:\\n\\treturn false\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419532,
                "title": "b-zout-s-identity-gcd-calculation",
                "content": "Based on [B\\xE9zout\\'s identity](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity),\\nFor ints a and b, if gcd(a,b) = d, then there exists some x, y with a * x + b * y = d;\\n\\n```csharp\\npublic bool IsGoodArray(int[] nums) \\n{\\n\\tif(nums == null || nums.Length == 0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif(nums.Length == 1)\\n\\t{\\n\\t\\treturn nums[0] == 1;\\n\\t}\\n\\n\\tint gcdResult = nums[0];        \\n\\tfor(int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\tgcdResult = gcd(nums[i], gcdResult);\\n\\t\\tif(gcdResult == 1)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;        \\n}\\n\\nint gcd(int a, int b)\\n{\\n\\twhile(b != 0)\\n\\t{\\n\\t\\tint t = b;\\n\\t\\tb = a % b;\\n\\t\\ta = t;            \\n\\t}\\n\\n\\treturn a;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic bool IsGoodArray(int[] nums) \\n{\\n\\tif(nums == null || nums.Length == 0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif(nums.Length == 1)\\n\\t{\\n\\t\\treturn nums[0] == 1;\\n\\t}\\n\\n\\tint gcdResult = nums[0];        \\n\\tfor(int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\tgcdResult = gcd(nums[i], gcdResult);\\n\\t\\tif(gcdResult == 1)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;        \\n}\\n\\nint gcd(int a, int b)\\n{\\n\\twhile(b != 0)\\n\\t{\\n\\t\\tint t = b;\\n\\t\\tb = a % b;\\n\\t\\ta = t;            \\n\\t}\\n\\n\\treturn a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314149,
                "title": "python-diophantine-equation",
                "content": "This is a multivariate linear [Diophantine equation](https://en.wikipedia.org/wiki/Diophantine_equation) with 1 on the right hand side. It has solution if and only if the gcd of all the numbers in nums divides 1, which means it must be 1. See [this math stack exchange post](https://math.stackexchange.com/questions/145346/diophantine-equations-with-multiple-variables) for detailed proof.\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return gcd(*nums) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return gcd(*nums) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071677,
                "title": "simple-c-with-explanation",
                "content": "According to Euclid\\'s Theorem,\\n***If the GCD of two integers (a,b) is d, then there exists two integers x and y such that ax + by = d.***\\n\\nIf a,b,c... are the elements of the array we are calculating ax + by + cz...which gives hint that we have to use the above theorem.\\n\\nNow in this problem the d is given to be 1, which means the GCD should be 1.\\nSo instead of checking for all posiible subsets of the given array it is enough to check every pair (a,b).\\n***\"Does the array contain two integers a and b such that ax + by = 1 for some integers x,y ?\"***\\nOr the same question can be asked as\\n***\"Does the array contain two co-prime integers?\"***\\n\\nBut checking all pairs will have quadratic time complexity. We have to optimize it.\\n\\nNow what happens if we calculate the GCD of all the integers in the array ?\\nIf the array contains co-prime integers then the GCD of those two will become 1 and the GCD of 1 with the remaining n-2 integers will be 1 only.\\nBut if the array does not contain coprime integers then the GCD of all the integers will be greater than 1.\\n\\nSo the question reduces to\\n***\"Is the GCD of all the number in the array equal to 1?\"***\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums)\\n    {\\n        int GCD = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            GCD = __gcd(GCD, nums[i]);\\n        }\\n        \\n        return GCD == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums)\\n    {\\n        int GCD = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            GCD = __gcd(GCD, nums[i]);\\n        }\\n        \\n        return GCD == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420523,
                "title": "c-explained-briefly",
                "content": "```\\nclass Solution {\\npublic:\\n /*   \\n    Read (https://brilliant.org/wiki/bezouts-identity/, https://en.wikipedia.org/wiki/B\\xE9zout\\'s_identity)\\n\\nThe basic idea is that for integers a and b, if gcd(a,b) = d, then there exist integers x and y, s.t a * x + b * y = d;\\n\\nThis can be generalized for (n >= 2) . e.g. if gcd(a,b,c) = d, then there exist integers x, y, and z, s.t, a* x + b*y + c * z = d.\\n\\nNow this problem is just asking if gcd(x1, ......, xn) = 1\\n */   \\n     bool isGoodArray(vector<int>& A) {\\n        int res = A[0];\\n        for (int a: A)\\n            res = gcd(res, a);\\n        return res == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n /*   \\n    Read (https://brilliant.org/wiki/bezouts-identity/, https://en.wikipedia.org/wiki/B\\xE9zout\\'s_identity)\\n\\nThe basic idea is that for integers a and b, if gcd(a,b) = d, then there exist integers x and y, s.t a * x + b * y = d;\\n\\nThis can be generalized for (n >= 2) . e.g. if gcd(a,b,c) = d, then there exist integers x, y, and z, s.t, a* x + b*y + c * z = d.\\n\\nNow this problem is just asking if gcd(x1, ......, xn) = 1\\n */   \\n     bool isGoodArray(vector<int>& A) {\\n        int res = A[0];\\n        for (int a: A)\\n            res = gcd(res, a);\\n        return res == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718093,
                "title": "java-gcd-solution",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1170548,
                "title": "c-explained-faster-than-90",
                "content": "In order to solve the problem, we need to search more about the **first** hint:\\n```\\nEq. ax+by=1 has solution x, y if gcd(a,b) = 1.\\n```\\nif we found **ANY two numbers** that has a ` gcd(a,b)=1`, then ANY added numbers won\\'t change the fact that gcd will results at max of 1! \\nthat is :`gcd(a,b,c,d,e)=1 if gcd(a,e)=1`\\nSo find If that\\'s possible and **return if that\\'s possible**.\\n```\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n        return b;\\n    return gcd(b%a, a);\\n}\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int prevGCD=nums[0];\\n        for(int i=1;i<n;i++)\\n        {prevGCD=gcd(prevGCD,nums[i]);\\n        }\\n        return prevGCD==1;\\n    }\\n```\\nIf you **like** my explanation, **hit** the **Upvote**  button and If you **don\\'t**, **hit** the **Downvote** \\uD83E\\uDD73\\nand If you have ANY questions, feel free to ask them down below \\uD83D\\uDC47",
                "solutionTags": [],
                "code": "```\\nEq. ax+by=1 has solution x, y if gcd(a,b) = 1.\\n```\n```\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n        return b;\\n    return gcd(b%a, a);\\n}\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int prevGCD=nums[0];\\n        for(int i=1;i<n;i++)\\n        {prevGCD=gcd(prevGCD,nums[i]);\\n        }\\n        return prevGCD==1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3621142,
                "title": "return-gcd-nums-1-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = 0;\\n        for(auto &i: nums){\\n            g = __gcd(i,g);\\n            if(g==1)return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = 0;\\n        for(auto &i: nums){\\n            g = __gcd(i,g);\\n            if(g==1)return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716855,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n                result=GCD(nums[i],result);\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```\\n**Please upvote if u like it**",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n                result=GCD(nums[i],result);\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554007,
                "title": "math-fact-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return gcd(b, a%b);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        // if there are 2 integers, a and b such that gcd(a, b) = d, then there exists integers x, y, such that a*x + b*y = d;\\n        int g = nums[0];\\n        for(auto it:nums)\\n            g = gcd(g, it);\\n        return g == 1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return gcd(b, a%b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2393710,
                "title": "c-solution-simple-and-easy",
                "content": "class Solution {\\npublic:\\n\\n    // if we choose any two elements from the array:\\n\\t// if the gcd is 1 then the required condition is true and\\n\\t// if gcd is not equal to 1 then the condition will never satisfy\\n\\t// its an observation, so don\\'t get confused ( like an AXIOM )\\n\\t// you can dry run the given test cases to confirm\\n\\t\\n    int gcd(int a, int b){\\n        while (a%b != 0){\\n            int rem=a%b;\\n            a=b;\\n            b=rem;\\n        }\\n        return b;\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int a = 0;\\n        for(int i=0; i<n; i++){\\n            a = gcd(a,nums[i]);\\n            if(a==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // if we choose any two elements from the array:\\n\\t// if the gcd is 1 then the required condition is true and\\n\\t// if gcd is not equal to 1 then the condition will never satisfy\\n\\t// its an observation, so don\\'t get confused ( like an AXIOM )\\n\\t// you can dry run the given test cases to confirm\\n\\t\\n    int gcd(int a, int b){\\n        while (a%b != 0){\\n            int rem=a%b;\\n            a=b;\\n            b=rem;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1387290,
                "title": "solution-with-derivation-and-explaination",
                "content": "consider ax + by = 1\\nAssuming integer solution exists then \\n\\nwe can take out the common divisor of a and b. \\nThe gcf is the greatest common divisor of a and b.\\n\\ntherefor ax + by = gcf(a,b) * ( (a/gcf) * x + (b/gcf) * y ) = 1\\n\\nsince gcf divides a we can rewrite a as a = gcf * a1 .. where a1 is some integer\\nsimilarly b = gcf * b1.. where b1 is some integer\\n\\nso ax + by = gcf * ( a1 * x + b1 * y ) = 1\\n\\ndividing both sides by gcf we get\\n\\na1 * x + b1 * y = 1 / gcf\\n\\nNow LHS is a integer because (a1, b1, x, y ) are all integer values. and LHS = RHS. Therefore 1/gcf should also be an integer. This is only possible when gcf = 1. For all other values 1/gcf will not be an integer.\\nAlso if (x,y) integer solutions don\\'t exist the condition won\\' t be valid.\\n\\nTherefor ax + by = 1 only if gcf(a,b) = 1\\n\\nFor n variables as given in the question similar logic can be used to take out gcf( a, b, c , d .... ) common from LHS and we get gcf(a,b,c,d ... ) = 1 as the condition.\\n\\nOne must realise that the subarray simply means taking the 0 as the multiplicative coefficients for number not included.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcd = nums[0];\\n        for( auto e : nums ){\\n            gcd = __gcd( gcd, e );\\n        }\\n        \\n        return gcd == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcd = nums[0];\\n        for( auto e : nums ){\\n            gcd = __gcd( gcd, e );\\n        }\\n        \\n        return gcd == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376227,
                "title": "c-simple-soln-4-lines",
                "content": "```\\n  //aX + bY = k has __integer solution__ (X, Y) if k is multiple of gcd(a, b)\\n    //here k=1 so __gcd should be 1\\n    //Subset has gcd 1 == whole array should have 1\\n    bool isGoodArray(vector<int>& nums) {\\n        int k=nums[0];\\n        for(auto i:nums){\\n            k=__gcd(k,i);\\n        }\\n        return k==1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  //aX + bY = k has __integer solution__ (X, Y) if k is multiple of gcd(a, b)\\n    //here k=1 so __gcd should be 1\\n    //Subset has gcd 1 == whole array should have 1\\n    bool isGoodArray(vector<int>& nums) {\\n        int k=nums[0];\\n        for(auto i:nums){\\n            k=__gcd(k,i);\\n        }\\n        return k==1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309095,
                "title": "1250-true-if-gcd-array-is-1-use-co-primes-existence-for-early-exit",
                "content": "---\\n\\nHard to see at first, and its pure math\\nA long one coming, below :)\\n\\n---\\n\\n**Algo**\\n\\n- `1 <= nums[i] <= 10^9` So array elements are always +ve\\n- For `[1]` or `[1,2,3]` or `[1,5,10,15,20]` array is good\\n  - because we have  subset as `[ 1 ]` & multiplicand as `1`, so our sum (after multiplying with each element of array with some multiplicand is `1*1`) is `1`\\n- For `[5,10,15,20]`, array is not good\\n  - because we dont have 1 as element\\n  - so some of elements must have `-ve` numbers as `multiplicand`\\n    - but even after having them, for example `5*-2 + 10*1`, it comes to `0`\\n    - this is because they are all multiples of a number (`5` in this case)\\n      - but we need `1`\\n      - so picking multiples of number won\\'t help\\n      - and picking `co-primes` will help\\n  - Now we know `co-primes` will help\\n   - Some exampels are `[5,7]` , `[5,11]` , `[7,37]`\\n     - It\\'s easy to see that the gcd of 1st two is `1`, also it is also for last one\\n       - But is it working really? `5*3 + 7*-2 = 1`, `5*-2 + 11*1 = 1`, `-7*21 + 4*37 = 1`, yes, it is working\\n  - So, we know that if `gcd` is 1 then it is working\\n- But what about `[5,10,15,20, 7]`?\\n  - Here there some numbers are multiples of `5`, also `5 & 7` are `co-prime`\\n    - Since we can take subset, we can take `[5,7]` and they are co-prime (`gcd = 1`), we its good\\n      - How? Same as above `5*3 + 7*-2 = 1`\\n      - So, effectively both `[5,10,15,20, 7]` and `[5,7]` are same\\n        - In other words, if we have 2 prime numbers, then we are done, or if we have two co-primes we are good\\n        - Is `[5,7]` is good - yes, why? `5 & 7 are co-prime` (that is `gcd = 1`)\\n        - Is `[3,4]` is good - yes, why? `3 & 4 are co-prime` (that is `gcd = 1`)\\n        - Is `[10,8]` is good - No, why? `10 & 8 are Not co-prime`, because they have a prime number `2` as common factor (that is `gcd = 2`)\\n- So can I stop going ahead once I found 2 co-primes? yes\\n  - `[8,9,100,200,300,400,500,600]` is same as `[8,9]`, as 8 & 9 are co-prime we don\\'t need to look at `100, 200..`\\n  - [9,100,200,300,400,500,600] is same as `[9,100]` yes they are `3*3` and `2*2*5*5` but there are no common factors with each other (`co-prime`), their only common factor is `1` (`gcd=1`), (`gcf=hcf=gcd=1`)\\n    - So we can exit as soon as we find `two co-primes` (`gcd=1`)\\n      - see last solution below for early exit\\n- Why is `[6,10,15]` a kind of special test case?\\n    - But `6*1 + 10*-2 + 15*1 = 1`\\n    - gcd of 6, 10, and 15 is 1\\n    - but there are no `co-primes`\\n      - `co-primes` if present then good, but may not present too but good array for our question\\n      - so `gcd is 1` can be trusted always, use and `co-primes` existence can be used for early exit\\n- Want more? :)\\n  - Check gcd properties here - https://en.wikipedia.org/wiki/Greatest_common_divisor#Properties\\n    - Especially, see the closest one - 2nd property in above link - `B\\xE9zout\\'s identity`\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n    return A.reduce((g, n) => gcd(g, n)) === 1;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/78b5db46-0a7e-4363-8dcc-c8a64de61bcc_1625144278.6591823.png)\\n\\n---\\n\\n```\\nvar isGoodArray = function (A) {\\n    return A.reduce((gcd = (a, b) => (b ? gcd(b, a % b) : a))) === 1;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c3f41dd7-ca8a-4da5-9663-5b428cb47bbd_1625144313.7914488.png)\\n\\n---\\n\\n```\\nvar isGoodArray = (A) => A.reduce((gcd = (a, b) => (b ? gcd(b, a % b) : a))) === 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/93ab86ee-88be-4323-8f1a-6c8ac1e948ba_1625144355.069614.png)\\n\\n---\\n\\n```\\nvar isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n\\n    let g = A[0];\\n    for (let n of A) {\\n        g = gcd(g, n);\\n        if (g === 1)\\n            return true;    // early exit\\n    }\\n    return false;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/aafe287e-a5ce-43e1-be5a-86fd66a49161_1625146895.2639222.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n    return A.reduce((g, n) => gcd(g, n)) === 1;\\n};\\n```\n```\\nvar isGoodArray = function (A) {\\n    return A.reduce((gcd = (a, b) => (b ? gcd(b, a % b) : a))) === 1;\\n};\\n```\n```\\nvar isGoodArray = (A) => A.reduce((gcd = (a, b) => (b ? gcd(b, a % b) : a))) === 1;\\n```\n```\\nvar isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n\\n    let g = A[0];\\n    for (let n of A) {\\n        g = gcd(g, n);\\n        if (g === 1)\\n            return true;    // early exit\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 669614,
                "title": "java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int t = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            t = gcd(nums[i], t);\\n            if (t == 1)\\n                return true;\\n            \\n        }\\n        return false;\\n    }\\n\\n    public int gcd(int a, int b) {\\n        if (a < b)\\n            return gcd(b, a);\\n        return a % b == 0 ? b : gcd(b, a % b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int t = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            t = gcd(nums[i], t);\\n            if (t == 1)\\n                return true;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 665035,
                "title": "c-simple-gcd-solution-60",
                "content": "Uses inbuilt GCD function and checks if the gcd of array is 1 or not.\\n```\\nbool isGoodArray(vector<int>& nums) {\\n        if (nums.size() == 0) return false;\\n        else {\\n            int g = nums[0];\\n            for(int i=1; i<nums.size(); i++) {\\n                g = __gcd(g, nums[i]);\\n            }\\n            if (g == 1) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isGoodArray(vector<int>& nums) {\\n        if (nums.size() == 0) return false;\\n        else {\\n            int g = nums[0];\\n            for(int i=1; i<nums.size(); i++) {\\n                g = __gcd(g, nums[i]);\\n            }\\n            if (g == 1) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418220,
                "title": "hand-written-easy-explanation-with-b-zout-s-lemma",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/71d340ad-c7ae-4256-940b-799a2ffd6ae5_1681532564.9413595.png)\\n![image.png](https://assets.leetcode.com/users/images/4a52e4c5-59ed-4bed-9e2d-557a9669e1ae_1681532580.7018669.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        ans=nums[0]\\n        for i in range (1,len(nums)):\\n            ans=math.gcd(ans,nums[i])\\n        return ans==1\\n```\\n\\nPlease Upvote the solution is you like it.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        ans=nums[0]\\n        for i in range (1,len(nums)):\\n            ans=math.gcd(ans,nums[i])\\n        return ans==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864105,
                "title": "java-solution-easy-to-understand-code",
                "content": "\\nSimple gcd calculation program.\\n\\n\\n```\\nclass Solution {\\n    static int gcd(int n,int m){\\n        if(m==0)\\n            return n;\\n        else\\n            return gcd(m,n%m);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n            res=gcd(res,nums[i]);\\n        return res==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int gcd(int n,int m){\\n        if(m==0)\\n            return n;\\n        else\\n            return gcd(m,n%m);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n            res=gcd(res,nums[i]);\\n        return res==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689665,
                "title": "java-sol-using-bezout-s-identity",
                "content": "# Explanation:\\n\\n*Bezout\\'s Identity*\\n        \\n        let a and b be integers with greatest common divisor as d\\n        then there exist integers x and y such that ax + by = d\\n        \\n        In Example 1,\\n\\n        a=5, x=3, b=7, y=-2\\n        So, 5*3 + 7*(-2) = 1\\n        \\n        \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       \\n\\n        //Basically check for GCD and return true if its 1\\n\\n        int x = nums[0], y;\\n        for(int a : nums){\\n        while(a > 0){\\n          y = x%a;\\n          x = a;\\n          a = y;\\n         }\\n    }\\n\\n        return x == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       \\n\\n        //Basically check for GCD and return true if its 1\\n\\n        int x = nums[0], y;\\n        for(int a : nums){\\n        while(a > 0){\\n          y = x%a;\\n          x = a;\\n          a = y;\\n         }\\n    }\\n\\n        return x == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473760,
                "title": "linear-diophantine-equation",
                "content": "Read the first answer and you can solve this problem.\\nhttps://math.stackexchange.com/questions/145346/diophantine-equations-with-multiple-variables\\n\\nAs a side note, this equation is also used in the two water jars problem (https://leetcode.com/problems/water-and-jug-problem/). Also, this is one of the most frequently used mathematics concept (along with sieve) in Codeforces/coding contests in general, so it\\'s worth learning. \\n\\n```\\nbool isGoodArray(vector<int>& nums) {\\n        int hcf = nums[0];\\n        for (auto x: nums)\\n            hcf = gcd(x, hcf);\\n        return hcf == 1;\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nbool isGoodArray(vector<int>& nums) {\\n        int hcf = nums[0];\\n        for (auto x: nums)\\n            hcf = gcd(x, hcf);\\n        return hcf == 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2080282,
                "title": "not-to-worry-about",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& a) \\n    {\\n        int g=0;\\n        for(int i=0;i<(int)a.size();i++)\\n            g=__gcd(g,a[i]);\\n        if(g>1) return 0;\\n        else return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& a) \\n    {\\n        int g=0;\\n        for(int i=0;i<(int)a.size();i++)\\n            g=__gcd(g,a[i]);\\n        if(g>1) return 0;\\n        else return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851649,
                "title": "c-one-line-o-n-bezout-s-lemma",
                "content": "We just need to check that GCD of all numbers is 1 (follows from Bezout\\'s Lemma).\\n```C++\\nbool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, [] (int a, int b) {return __gcd(a, b);}) == 1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```C++\\nbool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, [] (int a, int b) {return __gcd(a, b);}) == 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1797525,
                "title": "java-solution-gcd-approach",
                "content": "```\\nclass Solution {\\n    \\n    public int gcd(int a, int b) {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    \\n    public boolean isGoodArray(int[] nums) {\\n        int ans = nums[0];\\n        for (int element: nums){\\n            ans = gcd(ans, element);\\n            if(ans == 1){\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int gcd(int a, int b) {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    \\n    public boolean isGoodArray(int[] nums) {\\n        int ans = nums[0];\\n        for (int element: nums){\\n            ans = gcd(ans, element);\\n            if(ans == 1){\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638131,
                "title": "simple-explanation-for-noobs-like-me",
                "content": "in this problem i simply thought that we have to select some elements and after some interger multipication my result should be 1  now let say we have selected some elements\\n\\n\\n\\n\\n\\nnow we have 2 cases\\ncase1: -hcf of selected elements==1\\n\\ncase2:- hcf of selected elements!=1\\n\\nin case 2 we can take some intezer common let set we select \\n(a,b,c,d)\\nafter taking hcf common let say h\\nh(a1,b1,c1,d1)   here h !=1(case2) \\'\\nwe can easily say that whatever multiplication(with int) we make on a1,b1,c1,d1 we can\\'t make it a fraction (as the result  is always intezer) so the expression we can,t make it 1 as h>1 \\n\\nlow let say we are given an arr\\narr={ 6, 8, 12, 14, 3,  9, 15}\\'\\n\\'\\nnow let say we select element 6 8 and 12 we can easily see hcf is 2\\nso we can write it as  2( 3 , 4,  6) now whatever operation we make on 3,4,6  we can,t make it 1/2 for sure so we can\\'t make the expression as 1\\n\\n\\n\\n\\nbut in case 1 we can make it 1 i don\\'t know the reason for this !!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int hcf(int a,int b)\\n    {\\n        if(a==0)return b;\\n        \\n        if(a>b)return hcf(b,a);\\n        \\n        return hcf(b%a,a);   \\n    }\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n       \\n        bool ans=false;\\n        \\n        if(nums.size()==1)\\n        {\\n            return nums[0]==1;\\n        }\\n        \\n        \\n        \\n        \\n        int h=hcf(nums[0],nums[1]);\\n        \\n        if(h==1)return true;\\n        \\n        for(int i=2;i<nums.size();i++)\\n        {\\n            h=hcf(h,nums[i]);\\n            \\n            if(h==1)\\n            {\\n                ans=true;\\n                break;\\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int hcf(int a,int b)\\n    {\\n        if(a==0)return b;\\n        \\n        if(a>b)return hcf(b,a);\\n        \\n        return hcf(b%a,a);   \\n    }\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n       \\n        bool ans=false;\\n        \\n        if(nums.size()==1)\\n        {\\n            return nums[0]==1;\\n        }\\n        \\n        \\n        \\n        \\n        int h=hcf(nums[0],nums[1]);\\n        \\n        if(h==1)return true;\\n        \\n        for(int i=2;i<nums.size();i++)\\n        {\\n            h=hcf(h,nums[i]);\\n            \\n            if(h==1)\\n            {\\n                ans=true;\\n                break;\\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577844,
                "title": "c-o-n-with-explanations",
                "content": "Since the GCD is an associative function, we have\\n* gcd(a<sub>0</sub>, a<sub>1</sub>,...,a<sub>n - 1</sub>) = gcd(a<sub>0</sub>, gcd(a<sub>1</sub>,...,a<sub>n-1</sub>) = gcd(gcd(a<sub>0</sub>, a<sub>1</sub>), gcd(a<sub>2</sub>,...,a<sub>n-1</sub>)) = ...\\n\\nand so on, every possible combination is included. So we just have to iterate through `nums` until we find a gcd of `1`. In other world, if gcd(a<sub>0</sub>, a<sub>1</sub>,...,a<sub>n - 1</sub>) = 1, there exist a subsequence a<sub>i<sub>j</sub></sub> with #{a<sub>i<sub>0</sub></sub>,...,a<sub>i<sub>k</sub></sub>} = k, 1 <= k <= n, that give a gcd of `1.`\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size() == 1 and nums[0] == 1) return true;\\n        int gcd = 0;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(i == 0) gcd = nums[i];\\n            else {\\n                gcd = __gcd(gcd, nums[i]);\\n                if(gcd == 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size() == 1 and nums[0] == 1) return true;\\n        int gcd = 0;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(i == 0) gcd = nums[i];\\n            else {\\n                gcd = __gcd(gcd, nums[i]);\\n                if(gcd == 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489417,
                "title": "this-problem-is-about-chinese-remainder-theorem",
                "content": "If gcd(a1, a2, ..., an) =1, there exist integers x1, ..., xn such that a1*x1 + .... + an *xn = 1\\nhttps://en.wikipedia.org/wiki/Chinese_remainder_theorem\\n\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        import math \\n        n = len(nums)\\n        if n ==1:\\n            return nums[0] ==1\\n        d = math.gcd(nums[0], nums[1])\\n        for i in range(n):\\n            d = math.gcd(nums[i], d)\\n        return d ==1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        import math \\n        n = len(nums)\\n        if n ==1:\\n            return nums[0] ==1\\n        d = math.gcd(nums[0], nums[1])\\n        for i in range(n):\\n            d = math.gcd(nums[i], d)\\n        return d ==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081527,
                "title": "solution-in-java-100-faster",
                "content": "hint - Finding gcd of numbers in the given array, if (gcd==1) then return true.(i.e. it is a good array); else return false.\\n```\\nclass Solution {\\n    public int gcd(int a, int b){\\n        if(a==0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        if(nums.length==1){\\n            if(nums[0]!=1)\\n                return false;\\n            else\\n                return true;\\n        }\\n        int res=gcd(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            res=gcd(res,nums[i]);\\n        }\\n        return (res==1)?true:false;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int gcd(int a, int b){\\n        if(a==0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        if(nums.length==1){\\n            if(nums[0]!=1)\\n                return false;\\n            else\\n                return true;\\n        }\\n        int res=gcd(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            res=gcd(res,nums[i]);\\n        }\\n        return (res==1)?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526154,
                "title": "python-sol-by-g-c-d-b-zout-lemma-90-w-hint",
                "content": "Python sol by Greatest Common Divisor & B\\xE9zout Lemma\\n\\n---\\n\\n**Hint**:\\n\\nRecall that for integer a, b\\naX + bY = k has integer solution (X, Y) if k is multiple of gcd(a, b) from **[B\\xE9zout lemma](https://proofwiki.org/wiki/B\\xE9zout\\'s_Lemma)**\\n\\nIn addition, [description](https://leetcode.com/problems/check-if-it-is-a-good-array/) sets k = 1, which means gcd(a,b) | 1.\\ngcd(a,b) | 1\\n=> gcd(a,b) = 1\\n=> **a, b** is **co-prime**.\\n\\nNow, back to question itself.\\n\\nIf **gcd( all integers in given array) = 1**, then there exist at least one subset (a, b) satisfies aX + bY = 1. \\nTherefore, input is a **good array**.\\n\\nOtherwise, there is no solution.\\nAnd input is Not a good Array.\\n\\n---\\n\\n**Bezout Lemma**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583116964.png)\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        \\n        # ax + by = 1 has integer solution only when gcd(a, b) == 1\\n        \\n        x = nums[0]\\n        \\n\\t\\t# compute the greatest common divisor for all input integers\\n        for number in nums:\\n            \\n            x = gcd(x, number)\\n            \\n        \\n        return x == 1\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki Proof: B\\xE9zout\\'s Lemma](https://proofwiki.org/wiki/B\\xE9zout\\'s_Lemma)\\n\\n[2] [Python official docs about math.gcd()](https://docs.python.org/3/library/math.html?highlight=gcd#math.gcd)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        \\n        # ax + by = 1 has integer solution only when gcd(a, b) == 1\\n        \\n        x = nums[0]\\n        \\n\\t\\t# compute the greatest common divisor for all input integers\\n        for number in nums:\\n            \\n            x = gcd(x, number)\\n            \\n        \\n        return x == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268418,
                "title": "java-beginner-friendly-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        //gcd of numbers\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        //gcd of numbers\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930567,
                "title": "easiest-one-liner-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the GCD of all the elements of the array is equal to 1, return **True**\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return True if math.gcd(*nums)==1 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return True if math.gcd(*nums)==1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496784,
                "title": "c-gcd-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        //using diophantine equation approach\\n        //we have to select subset which has gcd of 1\\n        //so we have to give only whether we are able to select such subset that has gcd=1\\n        //so if such subset has gcd = 1 so the all element has also gcd having 1. if all element having gcd than only can return true otherwise return false\\n        int g = nums[0];\\n        for(auto i:nums){\\n            g = __gcd(g,i);\\n        }\\n        if(g==1) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        //using diophantine equation approach\\n        //we have to select subset which has gcd of 1\\n        //so we have to give only whether we are able to select such subset that has gcd=1\\n        //so if such subset has gcd = 1 so the all element has also gcd having 1. if all element having gcd than only can return true otherwise return false\\n        int g = nums[0];\\n        for(auto i:nums){\\n            g = __gcd(g,i);\\n        }\\n        if(g==1) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250203,
                "title": "c-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            n = __gcd(n,nums[i]);\\n            if(n == 1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            n = __gcd(n,nums[i]);\\n            if(n == 1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243805,
                "title": "fully-explained-gcd-co-prime-cpp",
                "content": "Intuition here is to get a set from nums whose gcd=1 as if gcd(a,b)==1 then there exist atleast one multiple of a & b whose difference is 1:)\\n\\nSo in order to check this, we can simply check the gcd of whole list because if there exist a single co-prime pair then gcd of list will be 1.\\n\\nPFB my code for your reference:\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n \\xA0 \\xA0 \\xA0 \\xA0/// if(n==1) return nums[0]==1;\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n            ans=__gcd(ans,nums[i]);\\n        return ans==1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n \\xA0 \\xA0 \\xA0 \\xA0/// if(n==1) return nums[0]==1;\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n            ans=__gcd(ans,nums[i]);\\n        return ans==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179378,
                "title": "bezout-s-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //bezout\\'s algorithm\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()==1 && nums[0]==1){\\n            return true;\\n        }\\n        int num = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            num = __gcd(num,nums[i]);\\n            if(num==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //bezout\\'s algorithm\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()==1 && nums[0]==1){\\n            return true;\\n        }\\n        int num = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            num = __gcd(num,nums[i]);\\n            if(num==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957874,
                "title": "java-best-approach",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n    int gcd=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            gcd=gcd(gcd, nums[i]);\\n            if(gcd==1)return true;\\n        }\\n        return gcd==1;\\n}\\n        public int gcd(int a, int b) {\\n   if (b==0) return a;\\n   return gcd(b,a%b);\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n    int gcd=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            gcd=gcd(gcd, nums[i]);\\n            if(gcd==1)return true;\\n        }\\n        return gcd==1;\\n}\\n        public int gcd(int a, int b) {\\n   if (b==0) return a;\\n   return gcd(b,a%b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713329,
                "title": "linear-combination-possible-if-subset-with-gcd-1-exists",
                "content": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        curr = nums[0]\\n        for i in range(1, n):\\n            curr = self.gcd(curr, nums[i])\\n            if curr == 1:\\n                return True\\n        return curr == 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        curr = nums[0]\\n        for i in range(1, n):\\n            curr = self.gcd(curr, nums[i])\\n            if curr == 1:\\n                return True\\n        return curr == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648447,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    // O(N) Time | O(1) Space\\n    // If GCD of all the elements is 1, the array is a good array\\n    \\n    public boolean isGoodArray(int[] nums) {\\n        int result = 0;\\n        for (int element: nums){\\n            result = gcd(result, element);\\n            if(result == 1)\\n            {\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // O(N) Time | O(1) Space\\n    // If GCD of all the elements is 1, the array is a good array\\n    \\n    public boolean isGoodArray(int[] nums) {\\n        int result = 0;\\n        for (int element: nums){\\n            result = gcd(result, element);\\n            if(result == 1)\\n            {\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629347,
                "title": "python3-one-liner",
                "content": "The minimum difference that can be created by manipulating two numbers in a way given by the question is equal to the greatest common divisor of the two numbers. \\n\\nFor example : \\n```\\nnums = [12,18]\\ngcd(12,18) = 6\\n```\\nTherefore the minimum difference after manipulating the numbers would be 6.\\n\\nFor this problem, we need to find whether the gcd of any two numbers in `nums`  is 1\\n--> gcd(nums) == 1\\n\\n**Python3 One Liner:**\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd,nums) == 1\\n```",
                "solutionTags": [],
                "code": "```\\nnums = [12,18]\\ngcd(12,18) = 6\\n```\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd,nums) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459690,
                "title": "c-easy-solution-space-lesser-than-97",
                "content": "We know there exists a solution for `ax+by =1` when there exists a , b such that their hcf is 1.\\nIf we find 2 nums whose hcf is 1 we `return true;` else `return false;` .\\n```\\nbool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        if(!n) return false;\\n        int hcf=nums[0];\\n\\t\\t\\n        for(int i=1;i<n;i++){\\n            hcf=__gcd(hcf,nums[i]);\\n        }\\n\\t\\t\\n        return hcf==1;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "We know there exists a solution for `ax+by =1` when there exists a , b such that their hcf is 1.\\nIf we find 2 nums whose hcf is 1 we `return true;` else `return false;` .\\n```\\nbool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        if(!n) return false;\\n        int hcf=nums[0];\\n\\t\\t\\n        for(int i=1;i<n;i++){\\n            hcf=__gcd(hcf,nums[i]);\\n        }\\n\\t\\t\\n        return hcf==1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1008334,
                "title": "c-1-line",
                "content": "```\\n    bool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), nums[0], gcd<int,int>) == 1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    bool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), nums[0], gcd<int,int>) == 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 980100,
                "title": "python-3-9-solution",
                "content": "Python 3.9 allows math.gcd() to take an iterable: \\nmath.gcd(*integers)\\nReturn the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0.\\n\\nNew in version 3.5.\\nChanged in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.\\n\\nLeetcode has been using Python 3.9 since 2020-10-20.\\n\\nSo, Python 3.9 solution is the simplest code that you may have for a \"hard\" problem:\\n```\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return math.gcd(*nums) == 1\\n```",
                "solutionTags": [],
                "code": "```\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return math.gcd(*nums) == 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 928490,
                "title": "go-gcd",
                "content": "Runtime: 36 ms, faster than 100.00% of Go online submissions for Check If It Is a Good Array.\\nMemory Usage: 8.8 MB, less than 100.00% of Go online submissions for Check If It Is a Good Array.\\n\\n```\\nfunc isGoodArray(nums []int) bool {\\n    t := nums[0]\\n    \\n    for _, num := range nums{\\n        t = gcd(num, t)\\n        if t == 1{\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc gcd (a,b int) int{\\n    if a < b{\\n        return gcd(b,a)\\n    }\\n    \\n    if a % b == 0{\\n        return b\\n    }\\n    \\n    return gcd(b, a%b)\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "Runtime: 36 ms, faster than 100.00% of Go online submissions for Check If It Is a Good Array.\\nMemory Usage: 8.8 MB, less than 100.00% of Go online submissions for Check If It Is a Good Array.\\n\\n```\\nfunc isGoodArray(nums []int) bool {\\n    t := nums[0]\\n    \\n    for _, num := range nums{\\n        t = gcd(num, t)\\n        if t == 1{\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc gcd (a,b int) int{\\n    if a < b{\\n        return gcd(b,a)\\n    }\\n    \\n    if a % b == 0{\\n        return b\\n    }\\n    \\n    return gcd(b, a%b)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 895652,
                "title": "c-just-find-two-co-primes-bezout-s-identity-explained",
                "content": "```\\n// Bezout\\'s identity\\n// Let a and b be integers with greatest common divisor d.\\n// Then, there exist integers x and y such that ax + by = d.\\n// In our case, we just have two find two numbers such that they are co-prime, i.e. their gcd=1\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int g=nums[0];\\n        for (int i=1;i<n;i++){\\n            g=__gcd(g,nums[i]);\\n\\t\\t\\t// If there are two co-primes then the entire array is co-prime\\n            if (g==1) return true;\\n        }\\n        return g==1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Bezout\\'s identity\\n// Let a and b be integers with greatest common divisor d.\\n// Then, there exist integers x and y such that ax + by = d.\\n// In our case, we just have two find two numbers such that they are co-prime, i.e. their gcd=1\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int g=nums[0];\\n        for (int i=1;i<n;i++){\\n            g=__gcd(g,nums[i]);\\n\\t\\t\\t// If there are two co-primes then the entire array is co-prime\\n            if (g==1) return true;\\n        }\\n        return g==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665610,
                "title": "very-easy-solution-c-with-explanation",
                "content": "Firstly if we have a subset with gcd 1 then we can find the proper multiplicand which will make that subset equal to 1, so we need to check whether there exists a subset with gcd equal to 1 or not... Now if a subset has gcd 1 then if we add an element to it, it\\'s gcd remains 1  so that means if a subset has gcd 1 then whole array has also gcd 1,  so check the gcd of whole array if it\\'s 1 then possible otherwise not possible..\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        if(!nums.size()) return false;\\n        if(nums.size()==1) return nums[0]==1;\\n        int g=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            g=gcd(g,nums[i]);\\n        }\\n        return g==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        if(!nums.size()) return false;\\n        if(nums.size()==1) return nums[0]==1;\\n        int g=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            g=gcd(g,nums[i]);\\n        }\\n        return g==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590623,
                "title": "javascript-and-c-solutions",
                "content": "**Thoughts and Intuition:**\\n\\nWhen I first read this problem, I thought there\\'s no way I can check every possible combination without TLE.  So I started looking for a pattern for a potential math solution.  I first noticed example 1 results in `true` with prime numbers `5` and `7` as input, and example 3 results in `false` with non-prime numbers `3` and `6` as input.  However, example 2 results in `true` with non-prime numbers also.  So I thought maybe GCD would work, and indeed it did!  After I solved this problem, I read about [Bezout\\'s Identity in this post](https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419324/Bezout\\'s-Identity).\\n\\n---\\n\\n*Javascript*\\n```\\nlet isGoodArray = (A, gcd = (a, b) => !b ? a : gcd(b, a % b)) => {\\n    let x = A.shift();\\n    A.forEach(y => x = gcd(x, y));\\n    return x == 1;\\n};\\n```\\n\\n---\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool isGoodArray(VI& A, bool good = false) {\\n        auto x = A.back(); A.pop_back();\\n        for_each(A.begin(), A.end(), [&](auto y) { x = gcd(x, y); });\\n        return x == 1;\\n    }\\nprivate:\\n    int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet isGoodArray = (A, gcd = (a, b) => !b ? a : gcd(b, a % b)) => {\\n    let x = A.shift();\\n    A.forEach(y => x = gcd(x, y));\\n    return x == 1;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool isGoodArray(VI& A, bool good = false) {\\n        auto x = A.back(); A.pop_back();\\n        for_each(A.begin(), A.end(), [&](auto y) { x = gcd(x, y); });\\n        return x == 1;\\n    }\\nprivate:\\n    int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538995,
                "title": "java-100-time-and-space-with-solution-explanation",
                "content": "Let a[] be the array of values and b[] be the array of constants such that\\nsigma( a[i]*b[i] ) =1 for 0 <= i < n.\\n\\nThis is equivalent to solving gcd( a[0], a[1] )*Y + sigma( a[i]*b[i]) = 1 for 2 <= i < n for some constant Y.\\n\\nWe simply reduced the problem from N to N-1. You can apply this recursively to solve the problem.\\n\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] a) {\\n        int ans=a[0];\\n        for(int t : a){\\n            if(ans==1) break;\\n            ans = gcd(ans, t);\\n        }\\n        return ans==1 ? true: false;\\n    }\\n    \\n    private int gcd( int a, int b) {\\n        if( a < b) return gcd(b,a);\\n        if( b == 0 ) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] a) {\\n        int ans=a[0];\\n        for(int t : a){\\n            if(ans==1) break;\\n            ans = gcd(ans, t);\\n        }\\n        return ans==1 ? true: false;\\n    }\\n    \\n    private int gcd( int a, int b) {\\n        if( a < b) return gcd(b,a);\\n        if( b == 0 ) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489065,
                "title": "scala-explained-by-by-chinese-remainder-theorem-additive-property",
                "content": "Additive property: if a==f (mod d), b==f (mod d), then it must be true that (x*a + y*b)==f (mod d)\\n\\nSo when we think of (x*a + y*b) mod d, and set the f ==0, then, there must be k=[1...d-1] ranges, which can map (x*a + y*b)/k to this range. Thus there must be a (x\\'*a + y\\'*b)==1 always existed. \\n\\n\\n```\\n  def isGoodArray(nums: Array[Int]): Boolean = {\\n    var res = nums(0)\\n\\n    def gcd(a: Int, b: Int): Int = {\\n      if (b == 0) return a\\n      gcd(b, a % b)\\n    }\\n\\n    for (i <- 1 to nums.length - 1) res = gcd(res, nums(i))\\n    res == 1\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def isGoodArray(nums: Array[Int]): Boolean = {\\n    var res = nums(0)\\n\\n    def gcd(a: Int, b: Int): Int = {\\n      if (b == 0) return a\\n      gcd(b, a % b)\\n    }\\n\\n    for (i <- 1 to nums.length - 1) res = gcd(res, nums(i))\\n    res == 1\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 422940,
                "title": "java",
                "content": "```\\n// O(n)\\n// O(1)\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0 || nums == null) {\\n            return false;\\n        }\\n        \\n        int k = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            k = GCD(k, nums[i]);\\n            if (k == 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int GCD(int m, int n) {\\n        if (m < n) {\\n            return GCD(n, m);\\n        }\\n        \\n        while (n != 0) {\\n            int k = m % n;\\n            m = n;\\n            n = k;        \\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// O(n)\\n// O(1)\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0 || nums == null) {\\n            return false;\\n        }\\n        \\n        int k = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            k = GCD(k, nums[i]);\\n            if (k == 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int GCD(int m, int n) {\\n        if (m < n) {\\n            return GCD(n, m);\\n        }\\n        \\n        while (n != 0) {\\n            int k = m % n;\\n            m = n;\\n            n = k;        \\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420007,
                "title": "python3-one-line",
                "content": "Calculate the GCD of all numbers in this array.\\n```\\nfrom math import gcd\\nfrom functools import reduce\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd, nums) == 1\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nfrom functools import reduce\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd, nums) == 1\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419415,
                "title": "c-gcd-of-all-numbers",
                "content": "[Small Improvement] As long as we the gcd becomes 1, we can return true.\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g(nums[0]);\\n        for (const int& n: nums)\\n            if ((g = gcd(g, n)) == 1)\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g(nums[0]);\\n        for (const int& n: nums)\\n            if ((g = gcd(g, n)) == 1)\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419329,
                "title": "o-n-solution",
                "content": "Any linear combination of some subset of numbers is divisible by their greatest common divisor and GCD can be obtained as some linear combination. Thus, an array is good if and only if GCD of its values is 1.\\n\\n\\n```\\n    bool isGoodArray(vector<int>& nums)\\n    {\\n        if (nums.empty()) return false;\\n        int d = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            d = gcd(d, nums[i]);\\n        return d == 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isGoodArray(vector<int>& nums)\\n    {\\n        if (nums.empty()) return false;\\n        int d = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            d = gcd(d, nums[i]);\\n        return d == 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057149,
                "title": "recursively",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        //gcd of numbers\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        //gcd of numbers\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025478,
                "title": "simple-approach-using-gcd-property",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom gcd property we know , ax + by = gcd(a,b) ,  if a and b are coprime then gcd(a,b) == 1.\\nNow in this arry we need to find a subset whose gcd is equal to 1 , and it is always optimal to check the gcd of whole array , if we have the gcd equal to 1 then its possible otherwise its not possilbe\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N log(max(nums)))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        from math import gcd\\n        gc = 0\\n        for num in nums:\\n            gc = gcd(gc,num)\\n            if gc == 1:\\n                return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        from math import gcd\\n        gc = 0\\n        for num in nums:\\n            gc = gcd(gc,num)\\n            if gc == 1:\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025328,
                "title": "easy-to-understand-c-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf GCD of all numbers != 1, the answer is false\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind GCD of 2 numbers at a time and use that value to check for GCD of the rest of the array\\n\\nIf the GCD ever becomes 1, you return true, else you keep going\\nafter loop is finished you check if gcd is 1, if not you return false\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n Logn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    int Gcd(int a, int b) {\\n        if (a == 0)\\n            return b;\\n        return Gcd(b%a, a);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        int size = nums.size();        \\n        int gcd = nums[0];\\n        for (int i = 1; i < size; i++)\\n        {\\n            gcd = Gcd(gcd, nums[i]);        \\n            if(gcd == 1) {\\n                return 1;\\n            }\\n        }\\n        return (gcd==1);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int Gcd(int a, int b) {\\n        if (a == 0)\\n            return b;\\n        return Gcd(b%a, a);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        int size = nums.size();        \\n        int gcd = nums[0];\\n        for (int i = 1; i < size; i++)\\n        {\\n            gcd = Gcd(gcd, nums[i]);        \\n            if(gcd == 1) {\\n                return 1;\\n            }\\n        }\\n        return (gcd==1);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020882,
                "title": "python-gcd-sum-simple",
                "content": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        if len(nums)<2:return nums[0]==1\\n        g=gcd(nums[0],nums[1])\\n        for i in range(2,len(nums)):\\n            g=gcd(g,nums[i])\\n            if g==1:return True\\n        return g==1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        if len(nums)<2:return nums[0]==1\\n        g=gcd(nums[0],nums[1])\\n        for i in range(2,len(nums)):\\n            g=gcd(g,nums[i])\\n            if g==1:return True\\n        return g==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019428,
                "title": "simple-gcd-based-solution-in-o-n-time-and-o-1-space",
                "content": "# Intuition\\nIf there are two co-primes found in the list, then it\\'s possible to multiply by integer followed by sum to produce outcome of 1.\\n\\n# Approach\\nCompute the gcd value of the list. If it\\'s 1, then you found atleast two integers that are co-primes. Return true if the gcd value of the list is 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * math.gcd O())$$ - \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        gcd_val = nums[0]\\n        for n in nums:\\n            gcd_val = math.gcd(gcd_val, n)\\n        return gcd_val == 1\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        gcd_val = nums[0]\\n        for n in nums:\\n            gcd_val = math.gcd(gcd_val, n)\\n        return gcd_val == 1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009049,
                "title": "very-easy-gcd-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Leetcode Hint\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O[n*log(min(a,b))]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O[1]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int gcd(int a, int b)\\n    {\\n        if (b==0) return a;\\n\\n        if (a>b)\\n        return gcd(b , a%b);\\n\\n        else \\n        return gcd(a, b%a);\\n    }\\n\\n\\n    public boolean isGoodArray(int[] nums) {\\n        \\n        int result = nums[0];\\n\\n        for (int i=1;i<nums.length;i++)\\n        {\\n            if (result==1) return true;\\n\\n            else result = gcd(result, nums[i]);\\n        }\\n\\n        if (result==1) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int gcd(int a, int b)\\n    {\\n        if (b==0) return a;\\n\\n        if (a>b)\\n        return gcd(b , a%b);\\n\\n        else \\n        return gcd(a, b%a);\\n    }\\n\\n\\n    public boolean isGoodArray(int[] nums) {\\n        \\n        int result = nums[0];\\n\\n        for (int i=1;i<nums.length;i++)\\n        {\\n            if (result==1) return true;\\n\\n            else result = gcd(result, nums[i]);\\n        }\\n\\n        if (result==1) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006162,
                "title": "unbelievable-java-solution-beats-100-explained-in-comments",
                "content": "# Complexity\\n- Time complexity:$$O(n * log(min(a, b)))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // \\uD83D\\uDE80 Super-efficient algorithm that BEATS 100% of the competition! \\uD83C\\uDF89\\n    public boolean isGoodArray(int[] nums) {\\n        // \\uD83D\\uDCA1 Initialize \\'answer\\' with the first element of \\'nums\\'.\\n        int answer = nums[0];\\n        \\n        // \\uD83D\\uDD04 Loop through the array starting from the second element.\\n        for (int i = 1; i < nums.length; i++) {\\n            // \\u2728 If \\'answer\\' is already 1, return true immediately since GCD can\\'t be less than 1.\\n            if (answer == 1) {\\n                return true;\\n            } else {\\n                // \\uD83D\\uDD0D Calculate the GCD of \\'answer\\' and the current element in \\'nums\\'.\\n                answer = gcd(answer, nums[i]);\\n            }\\n        }\\n        \\n        // \\uD83C\\uDFC6 Check if \\'answer\\' is 1 and return true, otherwise return false.\\n        return answer == 1;\\n    }\\n    \\n    // \\uD83D\\uDCAA This method calculates the greatest common divisor (GCD) of two integers \\'a\\' and \\'b\\'.\\n    public int gcd(int a, int b) {\\n        // \\uD83E\\uDDEE Using Euclidean algorithm to calculate GCD recursively.\\n        if (b == 0) {\\n            return a;\\n        }\\n        if (a > b) {\\n            return gcd(b, a % b);\\n        } else {\\n            return gcd(a, b % a);\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // \\uD83D\\uDE80 Super-efficient algorithm that BEATS 100% of the competition! \\uD83C\\uDF89\\n    public boolean isGoodArray(int[] nums) {\\n        // \\uD83D\\uDCA1 Initialize \\'answer\\' with the first element of \\'nums\\'.\\n        int answer = nums[0];\\n        \\n        // \\uD83D\\uDD04 Loop through the array starting from the second element.\\n        for (int i = 1; i < nums.length; i++) {\\n            // \\u2728 If \\'answer\\' is already 1, return true immediately since GCD can\\'t be less than 1.\\n            if (answer == 1) {\\n                return true;\\n            } else {\\n                // \\uD83D\\uDD0D Calculate the GCD of \\'answer\\' and the current element in \\'nums\\'.\\n                answer = gcd(answer, nums[i]);\\n            }\\n        }\\n        \\n        // \\uD83C\\uDFC6 Check if \\'answer\\' is 1 and return true, otherwise return false.\\n        return answer == 1;\\n    }\\n    \\n    // \\uD83D\\uDCAA This method calculates the greatest common divisor (GCD) of two integers \\'a\\' and \\'b\\'.\\n    public int gcd(int a, int b) {\\n        // \\uD83E\\uDDEE Using Euclidean algorithm to calculate GCD recursively.\\n        if (b == 0) {\\n            return a;\\n        }\\n        if (a > b) {\\n            return gcd(b, a % b);\\n        } else {\\n            return gcd(a, b % a);\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993707,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n\\n        for(int i=0; i<n; i++){\\n            num = solve(num, nums[i]);\\n            if(num == 1)\\n                return true;\\n        }   \\n        return false;\\n    }\\n\\n    int solve(int a, int b){\\n        while(a % b != 0){\\n            int rem = a % b;\\n            a = b;\\n            b = rem;\\n        }\\n        return b;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/0bb48aee-c53f-463a-99c4-32d40955bb7a_1692653715.6692786.png)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n\\n        for(int i=0; i<n; i++){\\n            num = solve(num, nums[i]);\\n            if(num == 1)\\n                return true;\\n        }   \\n        return false;\\n    }\\n\\n    int solve(int a, int b){\\n        while(a % b != 0){\\n            int rem = a % b;\\n            a = b;\\n            b = rem;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927548,
                "title": "calculating-gcd-of-array-bezout-s-theorem",
                "content": "# Intuition\\n    Bezout\\'s Identity Theorem\\n\\n# Approach\\n    if g = gcd(a, b) then \\n        ax + by = g \\n        (for any (x, y) pairs)\\n\\n    so required g is 1\\n    so if whole array gcd is 1 then its True else False\\n\\n# Complexity\\n- Time complexity:\\n    0(n*log(min(a, b)))\\n    n for traversing array and log(min(a, b)) for calculating gcd of two numbers\\n\\n- Space complexity:\\n    0(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        g = nums[0]\\n        for i in range(1, n):\\n            g = gcd(g, nums[i])\\n        \\n        return True if g == 1 else False\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        g = nums[0]\\n        for i in range(1, n):\\n            g = gcd(g, nums[i])\\n        \\n        return True if g == 1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894403,
                "title": "smalled-positive-linear-combination",
                "content": "```\\nTheorem: Let a and b be two integers (not both zero). Then any linear combination of a\\nand b is a multiple of gcd(a, b). In particular, splc(a, b) \\u2265 gcd(a, b).\\nProof: (Michael) Let d = gcd(a, b). Then a = dp and b = dq for some integers p and\\nq. Let m be a linear combination of a and b. Then m = ax + by for some x, y \\u2208 Z. Then\\nm = ax + by = dpx + dqy = d(px + qy), which shows d divides m. This proves the first\\nstatement. For the second statement, since splc(a, b) is a linear combination of a and b, the\\nfirst statement says that splc(a, b) is a multiple of d. Since the smallest positive multiple of\\nd is d, this shows that splc(a, b) \\u2265 d\\n```\\nI got this by reading: https://www.cmi.ac.in/~prajakta/courses/f2017/notes.pdf\\n\\n**Time: O(n), assuming gcd operation is O(1)\\nSpace: O(1)**\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        splc = nums[0]\\n        for n in nums:\\n            splc = gcd(splc, n)\\n            if splc == 1: return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nTheorem: Let a and b be two integers (not both zero). Then any linear combination of a\\nand b is a multiple of gcd(a, b). In particular, splc(a, b) \\u2265 gcd(a, b).\\nProof: (Michael) Let d = gcd(a, b). Then a = dp and b = dq for some integers p and\\nq. Let m be a linear combination of a and b. Then m = ax + by for some x, y \\u2208 Z. Then\\nm = ax + by = dpx + dqy = d(px + qy), which shows d divides m. This proves the first\\nstatement. For the second statement, since splc(a, b) is a linear combination of a and b, the\\nfirst statement says that splc(a, b) is a multiple of d. Since the smallest positive multiple of\\nd is d, this shows that splc(a, b) \\u2265 d\\n```\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        splc = nums[0]\\n        for n in nums:\\n            splc = gcd(splc, n)\\n            if splc == 1: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866093,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            x=gcd(nums[i],x);\\n            if(x==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            x=gcd(nums[i],x);\\n            if(x==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840761,
                "title": "gcd-python3",
                "content": "```\\nimport math\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        x = nums[0]\\n        for num in nums:\\n            x = math.gcd(x,num)\\n        return x==1\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        x = nums[0]\\n        for num in nums:\\n            x = math.gcd(x,num)\\n        return x==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801964,
                "title": "basic-maths-solved-using-c-better-approach-and-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI used this approach to solve this problem if the gcd of any subarray is 1 then it\\'s a good array because according to Bezout\\'s identity gcd(a,b) =d then\\nax+by=d.\\naccording to this,if gcd(a,b)=1 then ax+by=1\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=gcd(ans,nums[i]);\\n            if(ans==1)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=gcd(ans,nums[i]);\\n            if(ans==1)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792294,
                "title": "beginners-level-question-very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=gcd(ans,nums[i]);\\n            if(ans==1)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=gcd(ans,nums[i]);\\n            if(ans==1)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701102,
                "title": "python-one-line",
                "content": "# Intuition\\ngcd all numbers and if 1 you are good\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, A: List[int]) -> bool:\\n        return reduce(gcd, A) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, A: List[int]) -> bool:\\n        return reduce(gcd, A) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649906,
                "title": "short-sweet-swift",
                "content": "```\\nclass Solution {\\n    func isGoodArray(_ nums: [Int]) -> Bool {\\n        nums.reduce(0, { gcd($0, $1) }) == 1\\n    }\\n    func gcd(_ a: Int, _ b: Int) -> Int {\\n        b == 0 ? a : gcd(b, a % b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isGoodArray(_ nums: [Int]) -> Bool {\\n        nums.reduce(0, { gcd($0, $1) }) == 1\\n    }\\n    func gcd(_ a: Int, _ b: Int) -> Int {\\n        b == 0 ? a : gcd(b, a % b)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610733,
                "title": "easiest-solution-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return nums[0]==1\\n        div = gcd(nums[0], nums[1])\\n\\n        if len(nums) == 2:\\n            return div==1\\n\\n        for i in range(1, len(nums) - 1):\\n            div = gcd(div, nums[i + 1])\\n        return div == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return nums[0]==1\\n        div = gcd(nums[0], nums[1])\\n\\n        if len(nums) == 2:\\n            return div==1\\n\\n        for i in range(1, len(nums) - 1):\\n            div = gcd(div, nums[i + 1])\\n        return div == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592869,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif the gcd of any subarray is 1 then the gcd of entire array is also 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used this approach to solve this problem if the gcd of any subarray is 1 then it\\'s a good array because according to Bezout\\'s identity gcd(a,b) =d then \\nax+by=d.\\naccording to this,if  gcd(a,b)=1 then ax+by=1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {  \\n    int gcd(int a,int b){   \\n        int maximum= max(a,b);\\n        int minimum= min(a,b);\\n        if(minimum==0){\\n            return maximum;\\n        }\\n        while(maximum%minimum!=0){    \\n            int temp = maximum;    \\n            maximum=minimum;\\n            minimum = temp%minimum;\\n        }\\n        return minimum;\\n    } \\npublic:\\n    bool isGoodArray(vector<int>& nums) {   \\n        if(nums.size()==1){\\n            if(nums[0]==1){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int GCD = gcd(nums[0],nums[1]);\\n        for(int i =2;i<nums.size();i++){\\n            GCD=gcd(GCD,nums[i]);\\n        }\\n        if(GCD==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {  \\n    int gcd(int a,int b){   \\n        int maximum= max(a,b);\\n        int minimum= min(a,b);\\n        if(minimum==0){\\n            return maximum;\\n        }\\n        while(maximum%minimum!=0){    \\n            int temp = maximum;    \\n            maximum=minimum;\\n            minimum = temp%minimum;\\n        }\\n        return minimum;\\n    } \\npublic:\\n    bool isGoodArray(vector<int>& nums) {   \\n        if(nums.size()==1){\\n            if(nums[0]==1){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int GCD = gcd(nums[0],nums[1]);\\n        for(int i =2;i<nums.size();i++){\\n            GCD=gcd(GCD,nums[i]);\\n        }\\n        if(GCD==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592217,
                "title": "fastest-java-solution-easiest-approach-most-easily-understandable",
                "content": "# Intuition\\nBy looking at the test case I got to find out that if every number are propotional to each other than it is always false\\n\\n# Approach\\nTo find whether all the elements are proportional to each other we calculate all of thier gcd.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);    \\n        \\n    \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);    \\n        \\n    \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582484,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n        {\\n            return nums[0]==1 ? true : false;\\n        }\\n        int a = nums[0];\\n        int b = nums[1];\\n        int g = gcd(a,b);\\n        int i = 2;\\n        while(g!=1&&i<n)\\n        {\\n            g = gcd(g, nums[i]);\\n            i++;\\n        }\\n        return g==1 ? true : false;\\n    }\\n};\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        from math import gcd\\n        from functools import reduce\\n\\n        array_gcd = reduce(gcd, nums)\\n        \\n        return array_gcd == 1\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            result=GCD(nums[i],result);\\n            if (result==1) return true;\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n        {\\n            return nums[0]==1 ? true : false;\\n        }\\n        int a = nums[0];\\n        int b = nums[1];\\n        int g = gcd(a,b);\\n        int i = 2;\\n        while(g!=1&&i<n)\\n        {\\n            g = gcd(g, nums[i]);\\n            i++;\\n        }\\n        return g==1 ? true : false;\\n    }\\n};\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```\n```Python3 []\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        from math import gcd\\n        from functools import reduce\\n\\n        array_gcd = reduce(gcd, nums)\\n        \\n        return array_gcd == 1\\n```\n```Java []\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            result=GCD(nums[i],result);\\n            if (result==1) return true;\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570915,
                "title": "simple-solution-gcd-o-1-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo satisfy the condition the greatest common factor(gcd) of the array should be one.Also if any two number has gcd 1 then also we can return true because overall gcd become 1.\\nIf only one element in array then if it is one then true else false. \\n\\n# Complexity\\n- Time complexity:O(nLogA) , A = shows the element of array . LogA is because gcd function will give result in LogA \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int overallgcd=0;\\n     if(nums.length==1)\\n           {\\n           if(nums[0]==1)return true;\\n           return false;\\n            }\\n        overallgcd=gcd(nums[0],nums[1]);\\n        for(int t=2;t<nums.length;t++)\\n        {\\n          overallgcd=gcd(nums[t],overallgcd);\\n        }\\n        if(overallgcd==1)return true;\\n        return false;\\n    }\\n    int gcd(int t,int k){\\n        if(t==0)return k;\\n        return gcd(k%t,t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int overallgcd=0;\\n     if(nums.length==1)\\n           {\\n           if(nums[0]==1)return true;\\n           return false;\\n            }\\n        overallgcd=gcd(nums[0],nums[1]);\\n        for(int t=2;t<nums.length;t++)\\n        {\\n          overallgcd=gcd(nums[t],overallgcd);\\n        }\\n        if(overallgcd==1)return true;\\n        return false;\\n    }\\n    int gcd(int t,int k){\\n        if(t==0)return k;\\n        return gcd(k%t,t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565465,
                "title": "java-solution-by-recursive-method-0-ms-time-complexity",
                "content": "# Intuition\\ncalling the function goodCount recursively \\n\\n# Approach\\nRecursive Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {     \\n    public boolean isGoodArray(int[] nums) {\\n            if(nums.length == 0) return false; \\n            int ans = nums[0];         \\n            for(int i = 1 ; i< nums.length ; i++){             \\n                    ans = goodCount(ans , nums[i]);         \\n            }         \\n            if(ans == 1) return true;         \\n            else return false;     \\n        }      \\n    public int goodCount(int a, int b){        \\n        if(a == 0){           \\n             return b;           \\n        }         \\n        return goodCount(b%a , a);     \\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {     \\n    public boolean isGoodArray(int[] nums) {\\n            if(nums.length == 0) return false; \\n            int ans = nums[0];         \\n            for(int i = 1 ; i< nums.length ; i++){             \\n                    ans = goodCount(ans , nums[i]);         \\n            }         \\n            if(ans == 1) return true;         \\n            else return false;     \\n        }      \\n    public int goodCount(int a, int b){        \\n        if(a == 0){           \\n             return b;           \\n        }         \\n        return goodCount(b%a , a);     \\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563471,
                "title": "check-weather-the-array-is-a-good-array-or-not-beginner-friendly-java-solution",
                "content": "# Intuition:-\\nThe intuition behind this problem is that by if the GCD of all the elements of the array comes out to be 1 then it is said that the array is a good array.\\n\\n# Approach\\nFlow of the code:-\\n1. If the length of the array is 0 then return false.\\n2. Now we will make a function for calculating the GCD.\\n3. We will initialise an integer flag to nums[0].\\n4. Now we will execute a for loop from i = 1 to i < nums.length.\\n5. When the loop will be getting executed then we will call our function gcd where one input will be flag and nums[i].\\n6. At the last when the loop will be executed the flag will give its output.\\n7. If this output turns out to be equal to one then boolean true will be returned otherwise false will  be returned.\\n8. This is the very best explanation that you are looking for, no complex bezout lemma just pure and simple solution.\\n9. Please upvote my solution. \\n# Complexity\\n- Time complexity:\\nThe time complexity for this solution  is O(N).\\n\\n- Space complexity:\\nThe space complexity for this solution is 0(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n           if(nums.length == 0){\\n            return false;\\n        }\\n        int flag = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            flag = gcd(flag, nums[i]);\\n        }\\n        if(flag == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n           if(nums.length == 0){\\n            return false;\\n        }\\n        int flag = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            flag = gcd(flag, nums[i]);\\n        }\\n        if(flag == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555844,
                "title": "discrete-math-ftw-bezout-s-identity",
                "content": "# Intuition\\nWe learned about this in Discrete Math I (shoutout Dr. Bereg). Basically, Bezout\\'s identity states that for any pair of numbers x, y, it is possible to always get solutions (a, b) such that ax + by = GCD(x, y) (and nothing smaller).\\n\\n# Approach\\nAll we do is check if we can get a GCD of 1 from any given pair.\\n\\n# Complexity\\nThe time complexity of this problem is O(N), as evidenced by the single for loop. This is kind of like a nested GCD as we traverse across which looks something like GCD(xn, GCD(xn-1, GCD(... , GCD(x0)))). As long as we hit 1, we know that the number we hit is relatively prime with some other number that came before it, and we don\\'t care which one. All we need to do is return a boolean, so we\\'re done.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if (nums.length == 1) {\\n            return (nums[0] == 1 || nums[0] == -1);\\n        } else {\\n            int gee = nums[0];\\n            for (int i = 1; i < nums.length; i++) {\\n                gee = gcd(gee, nums[i]);\\n            }\\n            return gee==1;\\n        }\\n    }\\n\\n    static int gcd(int a, int b) {\\n        while (b != 0) {\\n            int t = a;\\n            a = b;\\n            b = t % b;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if (nums.length == 1) {\\n            return (nums[0] == 1 || nums[0] == -1);\\n        } else {\\n            int gee = nums[0];\\n            for (int i = 1; i < nums.length; i++) {\\n                gee = gcd(gee, nums[i]);\\n            }\\n            return gee==1;\\n        }\\n    }\\n\\n    static int gcd(int a, int b) {\\n        while (b != 0) {\\n            int t = a;\\n            a = b;\\n            b = t % b;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519562,
                "title": "c-solution-using-gcd",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N log max)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public bool IsGoodArray(int[] nums) {\\n        int gcd(int a,int b) => (a == 0) ? b : gcd(b % a, a);\\n        int curGcd = nums[0];\\n        for(int i = 1; i < nums.Length;i++){\\n            curGcd = gcd(curGcd,nums[i]);\\n            if(curGcd == 1) return true;\\n        } \\n        return curGcd == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsGoodArray(int[] nums) {\\n        int gcd(int a,int b) => (a == 0) ? b : gcd(b % a, a);\\n        int curGcd = nums[0];\\n        for(int i = 1; i < nums.Length;i++){\\n            curGcd = gcd(curGcd,nums[i]);\\n            if(curGcd == 1) return true;\\n        } \\n        return curGcd == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466331,
                "title": "chinese-remainder-theorem",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def isGoodArray(self, A):\\n        gcd = A[0]\\n        for a in A:\\n            while a: gcd, a = a, gcd % a\\n        return gcd == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isGoodArray(self, A):\\n        gcd = A[0]\\n        for a in A:\\n            while a: gcd, a = a, gcd % a\\n        return gcd == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425548,
                "title": "euclid-s-algorithm-gcd-easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Java code defines a class named \"Solution\" with a method \"isGoodArray\" that takes an integer array \"nums\" as input and returns a boolean value. The method calculates the greatest common divisor (GCD) of all the elements in the array using a recursive \"gcd\" function and stores the result in the variable \"ans\". If the value of \"ans\" is equal to 1, the method returns true; otherwise, it returns false.\\n\\nThe \"gcd\" function uses the Euclidean algorithm to calculate the GCD of two numbers \"a\" and \"b\" by finding the remainder of \"b\" divided by \"a\" and recursively calling itself with the arguments \"b%a\" and \"a\" until \"a\" becomes zero. If \"a\" is zero, the function returns \"b\".\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we define a class named \"Solution\" with a method \"isGoodArray\" that takes an integer array \"nums\" as input and returns a boolean value.\\n\\n2. We initialize two variables, \"n\" to hold the length of the array \"nums\", and \"ans\" to hold the first element of the array.\\n\\n3. We then loop through the remaining elements of the array, starting from the second element, and calculate the GCD of each element with the previous GCD value stored in the \"ans\" variable, using the \"gcd\" function.\\n\\n4. Finally, we check if the value of \"ans\" is equal to 1, and return true if it is, and false otherwise.\\n\\n$$Conclusion:$$\\nThe given code is used to determine if an array is \"good\" or not. An array is considered \"good\" if there exists a non-empty subarray (consecutive elements of the array) such that the GCD of all the elements in the subarray is equal to 1. The code achieves this by calculating the GCD of all the elements in the array and checking if the final GCD value is equal to 1. The GCD calculation is performed using the recursive \"gcd\" function, which uses the Euclidean algorithm to compute the GCD of two numbers.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       int n = nums.length;\\n       int ans = nums[0] ;\\n\\n       for( int i = 1; i < n; i++) {\\n           ans = gcd( ans, nums[i] );\\n       }\\n\\n       return ans == 1;\\n    }\\n\\n    //  greatest common divisor (gcd) function\\n    public int gcd( int a, int b ) {\\n        // check\\n        if( a == 0 ) {\\n            return b;\\n        }\\n\\n        return gcd( b%a, a );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       int n = nums.length;\\n       int ans = nums[0] ;\\n\\n       for( int i = 1; i < n; i++) {\\n           ans = gcd( ans, nums[i] );\\n       }\\n\\n       return ans == 1;\\n    }\\n\\n    //  greatest common divisor (gcd) function\\n    public int gcd( int a, int b ) {\\n        // check\\n        if( a == 0 ) {\\n            return b;\\n        }\\n\\n        return gcd( b%a, a );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416472,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums):\\n        return reduce(gcd,nums) == 1\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums):\\n        return reduce(gcd,nums) == 1\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406634,
                "title": "python3-o-n-complexity",
                "content": "# Intuition\\nWe are trying to obtain a sum of 1 using a subset of nums and multiplying each element by an integer, we need to find out if the GCD of the numbers in the array is 1. If the GCD is 1, that means there is a combination of elements in the array that can be multiplied by some integers and added together to give a sum of 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfrom math import gcd\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:   \\n        if len(nums) == 0:\\n            return False\\n\\n        current_gcd = nums[0]\\n\\n        for num in nums:\\n            current_gcd = gcd(current_gcd, num)\\n            if current_gcd == 1:\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:   \\n        if len(nums) == 0:\\n            return False\\n\\n        current_gcd = nums[0]\\n\\n        for num in nums:\\n            current_gcd = gcd(current_gcd, num)\\n            if current_gcd == 1:\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397829,
                "title": "easy-100-100-ruby-solution-using-gcd",
                "content": "# Intuition\\nAny two relatively prime numbers can be used to make one, so any array is \"good\" unless all numbers share a prime factor.\\n\\n# Approach\\nFind the greatest common factor of all numbers in the array and check if it\\'s 1.\\n\\n# Complexity\\n- Time complexity:\\nI think $$O(n)$$, but I\\'m not sure about the time complexity of repeated GCD.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Boolean}\\ndef is_good_array(nums)\\n    return nums[0] == 1 if nums.length == 1\\n    current = nums.shift\\n    until nums.empty?\\n        current = current.gcd(nums.shift)\\n    end\\n    current == 1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Boolean}\\ndef is_good_array(nums)\\n    return nums[0] == 1 if nums.length == 1\\n    current = nums.shift\\n    until nums.empty?\\n        current = current.gcd(nums.shift)\\n    end\\n    current == 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3346863,
                "title": "c-solution",
                "content": "Eq. ax+by=1 has solution x, y if gcd(a,b) = 1.\\nB\\xE9zout\\'s lemma\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool isGoodArray(vector<int>& nums) \\n    {\\n        int gcd=nums[0];\\n        for(int x=1; x<nums.size(); x++) gcd=__gcd(gcd,nums[x]);\\n        return gcd==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isGoodArray(vector<int>& nums) \\n    {\\n        int gcd=nums[0];\\n        for(int x=1; x<nums.size(); x++) gcd=__gcd(gcd,nums[x]);\\n        return gcd==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319854,
                "title": "check-if-it-is-a-good-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        int n= nums.length;\\n        for(int num : nums){\\n            gcd = gcd(gcd,num);\\n            if(gcd==1){\\n                return true;\\n            }\\n        }\\n        return gcd==1;\\n\\n    }\\n\\n    public static int gcd(int a, int b){\\n        while(b!=0){\\n            int temp =b;\\n            b = a%b;\\n            a=temp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        int n= nums.length;\\n        for(int num : nums){\\n            gcd = gcd(gcd,num);\\n            if(gcd==1){\\n                return true;\\n            }\\n        }\\n        return gcd==1;\\n\\n    }\\n\\n    public static int gcd(int a, int b){\\n        while(b!=0){\\n            int temp =b;\\n            b = a%b;\\n            a=temp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313047,
                "title": "very-easy-solution-just-gcd",
                "content": "# Intuition\\nWe do not have to to check all subsequnces we just have to check if the the GCD of all elements of the array is 1 or not\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd_all(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int cur = nums[0];\\n        for (int i = 1; i < n; i++)\\n        {\\n            cur = gcd(cur, nums[i]);\\n        }\\n        return cur;\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        return gcd_all(nums) == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd_all(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int cur = nums[0];\\n        for (int i = 1; i < n; i++)\\n        {\\n            cur = gcd(cur, nums[i]);\\n        }\\n        return cur;\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        return gcd_all(nums) == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307004,
                "title": "fastest-java-solution-with-3lines-of-code",
                "content": "\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i:nums){\\n            gcd = GCD(i,gcd);\\n        }\\n        return gcd==1;\\n    }\\n    int GCD(int x, int y)\\n    {\\n        if (y == 0)\\n            return x;\\n        return GCD(y, x % y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i:nums){\\n            gcd = GCD(i,gcd);\\n        }\\n        return gcd==1;\\n    }\\n    int GCD(int x, int y)\\n    {\\n        if (y == 0)\\n            return x;\\n        return GCD(y, x % y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301332,
                "title": "java-ax-by-1-using-hint",
                "content": "# Intuition\\nWe can think of each element in the array as a factor that we can use to obtain the desired sum of 1. to obtain a sum of 1, we need to find a combination of factors , to do this is to choose a subset of the factors whose greatest common divisor is 1, and then multiply each element in the subset by an integer such that the sum of the resulting products is 1. ( credit hint ) \\n\\n        ************----------------****************\\n                            \\nThe reason why we choose a subset of factors whose greatest common divisor is 1 is that if the greatest common divisor is not 1, then the factors have a common factor other than 1, which means that we cannot obtain a sum of 1 using only integer multiplication of the factors. This is because any integer multiplication of the factors would also include the common factor, which would prevent us from obtaining a sum of 1.\\n\\n# Approach\\nInitialize a variable gcd to the first element of the array.\\n\\nIterate over the rest of the elements in the array, and for each element num, compute the GCD of gcd and num using the Euclidean algorithm. Update gcd to the resulting GCD.\\n\\nAfter iterating over all the elements in the array, check if gcd is equal to 1. If gcd is equal to 1, then the array is good and we return true, otherwise it is not good and we return false.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n          int gcd = nums[0]; // Greatest common factor \\n    for (int i = 1; i < nums.length; i++) {\\n        gcd = gcd(gcd, nums[i]);\\n    }\\n    return gcd == 1;\\n    }\\n    public static int gcd(int a, int b) {\\n    if (b == 0) {\\n        return a;\\n    } else {\\n        return gcd(b, a % b);\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n          int gcd = nums[0]; // Greatest common factor \\n    for (int i = 1; i < nums.length; i++) {\\n        gcd = gcd(gcd, nums[i]);\\n    }\\n    return gcd == 1;\\n    }\\n    public static int gcd(int a, int b) {\\n    if (b == 0) {\\n        return a;\\n    } else {\\n        return gcd(b, a % b);\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255640,
                "title": "python-math-solution",
                "content": "# Intuition\\nif a,b,c, .. are elements of array we need to find if equation \\nax+by+cz+...= 1 is solvable.\\n\\nWe know ax+by=1 is solvable only if a & b are co-prime by Bezout\\'s identity theorem. Can we extend it to solve it ?\\n\\n# Approach\\nax+by=1 is solvable only if a & b are co-prime by Bezout\\'s identity theorem (ax+by=GCD(a,b)). Can we extend it to solve it ?\\n\\nLet\\'s check if we can extend to more than one coefficient i.e. ax+by+cz=1\\nIs ax+by=1 => ax+by+cz=1 true ?\\n    \\n    ax+by=1 => n(ax+by) = n where n is any integer\\n    a(nx) + b(ny) = n => ax`+by` = n , so I can choose ax`+by` \\n        expression to be any integer\\n    if I choose ax+by = (-cz+1) (x` and y` are arbitrary values similar to \\n            x and y) \\n    => ax+by+cz = (-cz+1)+cz = 1\\n    => ax+by+cz = 1\\n\\nI can extend this argument to any number of coefficients \\ni.e. ax+by+cz+.... = 1\\n\\nSolution:\\nif there are two numbers in array (a, b, c, ..) which are co-prime then the array is good.\\nWe can find all the pairs in the array in order to check it, Time complexity - O(n^2). Can we do better than that ?\\n\\nGiven GCD(a, b) = 1 then GCD(a, b, c) should be 1 because 1 is the lowest common factor. if we can find the GCD of the array and if its equal to 1 then the array is good\\n\\n    GCD(a, b, c, d, ....) = GCD(GCD(GCD(GCD(a,b), c),d)....\\n\\nPseudocode:\\n\\n    g = nums[0]\\n    for n in nums starting at position 1:\\n        g = GCD(g, n)\\n    if g==1:\\n        then array is good\\n    else:\\n        array is not good.\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    GCD function takes logx(m) where m is max of two numbers\\n    $$O(nlogx(m))$$ where m is max number in array and n is length of array.\\n\\n\\n- Space complexity:\\n$$O(1)$$ - constant space\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        g = nums[0]\\n        for i in range(1, len(nums)):\\n            g = math.gcd(nums[i], g)\\n        if g == 1:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        g = nums[0]\\n        for i in range(1, len(nums)):\\n            g = math.gcd(nums[i], g)\\n        if g == 1:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205019,
                "title": "check-if-it-is-a-good-array-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& num) {\\n        int gk = num[0];\\n                for(auto i:num){\\n                            gk = __gcd(gk,i);\\n                                    }\\n                                            if(gk==1) return true;\\n                                                    else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& num) {\\n        int gk = num[0];\\n                for(auto i:num){\\n                            gk = __gcd(gk,i);\\n                                    }\\n                                            if(gk==1) return true;\\n                                                    else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203080,
                "title": "bezout-s-identity",
                "content": "Essentially, this is an application of Bezout\\'s identity: \\n**Lemma**: $$\\\\displaystyle\\\\sum_{i=0}^{n} c_i x_i = k\\\\gcd(x_0, x_1, ...x_n)$$\\n**Proof**: \\n(1) When $$n = 1$$, this is Bezout\\'s identity.\\n(2) Assume this is true for $n$, then \\n\\n$$\\\\displaystyle\\\\sum_{i=0}^{n+1} c_i x_i = \\\\displaystyle\\\\sum_{i=0}^{n} c_i x_i + c_{n+1}x_{n+1} = k\\\\gcd(x_0, ...,x_n) + c_{n+1}x_{n+1} = k\\'\\\\gcd(\\\\gcd(x_0, ..., x_n), x_{n+1}) = k\\'\\\\gcd(x_0, ..., x_{n+1})$$\\n\\nTherefore, the array is good iff the GCD of some subset is $$1$$, which is true iff the GCD of the entire array is $$1$$.",
                "solutionTags": [
                    "C++"
                ],
                "code": "Essentially, this is an application of Bezout\\'s identity: \\n**Lemma**: $$\\\\displaystyle\\\\sum_{i=0}^{n} c_i x_i = k\\\\gcd(x_0, x_1, ...x_n)$$\\n**Proof**: \\n(1) When $$n = 1$$, this is Bezout\\'s identity.\\n(2) Assume this is true for $n$, then \\n\\n$$\\\\displaystyle\\\\sum_{i=0}^{n+1} c_i x_i = \\\\displaystyle\\\\sum_{i=0}^{n} c_i x_i + c_{n+1}x_{n+1} = k\\\\gcd(x_0, ...,x_n) + c_{n+1}x_{n+1} = k\\'\\\\gcd(\\\\gcd(x_0, ..., x_n), x_{n+1}) = k\\'\\\\gcd(x_0, ..., x_{n+1})$$\\n\\nTherefore, the array is good iff the GCD of some subset is $$1$$, which is true iff the GCD of the entire array is $$1$$.",
                "codeTag": "Unknown"
            },
            {
                "id": 3189040,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n      int ans=nums[0];\\n      for(int i=1;i<nums.size();i++){\\n          ans=__gcd(ans,nums[i]);\\n      }   \\n      if(ans==1) return true;\\n      return false;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n      int ans=nums[0];\\n      for(int i=1;i<nums.size();i++){\\n          ans=__gcd(ans,nums[i]);\\n      }   \\n      if(ans==1) return true;\\n      return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186966,
                "title": "lc-1250-h-python3-one-liner",
                "content": "If `gcd(*nums) == 1`, then there exists a subset `s` of `nums` such that `gcd(*s) == 1`. By the generailzed B\\xE9zout\\'s identity for multiple integers, we know that `nums` is a good array.\\n\\n```python3 []\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return True if gcd(*nums) == 1 else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return True if gcd(*nums) == 1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169532,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int x = nums[0], y;\\n        for(int a : nums){\\n            while(a > 0){\\n                y = x%a;\\n                x = a;\\n                a = y;\\n            }\\n         }\\n        return x == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int x = nums[0], y;\\n        for(int a : nums){\\n            while(a > 0){\\n                y = x%a;\\n                x = a;\\n                a = y;\\n            }\\n         }\\n        return x == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155541,
                "title": "easiest-solution-for-hard-problem-c-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n    int n = nums.size();\\n    int a = 0;\\n    for(int i=0; i<n; i++){\\n        a = gcd(a,nums[i]);\\n        if(a==1)\\n            return true;\\n    }\\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n    int n = nums.size();\\n    int a = 0;\\n    for(int i=0; i<n; i++){\\n        a = gcd(a,nums[i]);\\n        if(a==1)\\n            return true;\\n    }\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152455,
                "title": "simple-solution-using-gcd-using-b-zout-s-identity-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI first thought if we have 2 prime numbers then we can have a solution then i thought what else i can do if we have other numbers then i came to know about B\\xE9zout\\'s identity theorem . This question is example of this theorem .\\nWe only have to check for all numbers gcd and see if we get 1 if we get 1 then we can have a multiple that can make total sum = 1 .\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int no = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            no = gcd(no,nums[i]);\\n            if(no == 1) return 1;\\n        }\\n        return no == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int no = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            no = gcd(no,nums[i]);\\n            if(no == 1) return 1;\\n        }\\n        return no == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115621,
                "title": "scala-2-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def isGoodArray(nums: Array[Int]): Boolean = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        nums.reduce(gcd) == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def isGoodArray(nums: Array[Int]): Boolean = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        nums.reduce(gcd) == 1\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3074590,
                "title": "python-solution-beats-99-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition\\nMy first thought on how to solve this problem is to use the concept of greatest common divisor (GCD) to check if all the elements in the given array have a GCD of 1. If so, then it is a good array as per the problem statement.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use the built-in function gcd() from the math module to calculate the GCD of all the elements in the given array. I will use the reduce() function from the functools module to iterate through the array and calculate the GCD of all the elements in one go. I will then compare the calculated GCD with 1 and return True if they are equal, False otherwise.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd, nums) == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd, nums) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068769,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_good_array(nums: Vec<i32>) -> bool {\\n        let mut res = nums[0];\\n        for i in nums.iter() {\\n            res = Self::gcd(res, *i);\\n        }\\n        res == 1\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        if b == 0 {\\n            a\\n        } else {\\n            Self::gcd(b, a % b)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_good_array(nums: Vec<i32>) -> bool {\\n        let mut res = nums[0];\\n        for i in nums.iter() {\\n            res = Self::gcd(res, *i);\\n        }\\n        res == 1\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        if b == 0 {\\n            a\\n        } else {\\n            Self::gcd(b, a % b)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3067037,
                "title": "check-if-it-is-a-good-array-c-4lines-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe array will be good only if there exists a subset whose gcd is 1.\\n\\n# Approach\\nWe find the gcd of the whole array. If the gcd is 1 we can say that there exist a subset whose gcd is 1. For that subset it is always possible to have a number such that final number is 1.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gd=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        gd=__gcd(nums[i],gd);\\n        return (gd==1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gd=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        gd=__gcd(nums[i],gd);\\n        return (gd==1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051254,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n                result=GCD(nums[i],result);\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n                result=GCD(nums[i],result);\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046759,
                "title": "c-1-liner-easy",
                "content": "By bezout\\'s lemma, if 2 numbers x and y are co prime, then we can find integers m and n such that mx + ny = 1, so the problems boils to checking if there is a co-prime pair in the array or not. This is always true if the GCD of the  entire array is 1.\\n\\nMy code below:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, [&](const int &x, const int &y) {\\n            return __gcd(x, y);\\n        }) == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, [&](const int &x, const int &y) {\\n            return __gcd(x, y);\\n        }) == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014387,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014386,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008301,
                "title": "c-gcd",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        int ans=nums[0];\\n\\n        for(int i=1; i<n; i++){\\n            ans=__gcd(ans,nums[i]);\\n        }\\n       \\n       return ans==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        int ans=nums[0];\\n\\n        for(int i=1; i<n; i++){\\n            ans=__gcd(ans,nums[i]);\\n        }\\n       \\n       return ans==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007805,
                "title": "fastest-java-solution-gcd-greedy-100-time-and-99-25-space",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(res==1){\\n                return true;\\n            }\\n            else{\\n                res=gcd(res,nums[i]);\\n            }\\n        }\\n        if(res==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public static int gcd(int n1,int n2){\\n\\t    if(n2==0){\\n\\t        return n1;\\n\\t    }\\n\\t    if(n1>n2){\\n\\t        return gcd(n2,n1%n2);\\n\\t    }\\n\\t    else{\\n\\t        return gcd(n1,n2%n1);\\n\\t    }\\n\\t    \\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(res==1){\\n                return true;\\n            }\\n            else{\\n                res=gcd(res,nums[i]);\\n            }\\n        }\\n        if(res==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public static int gcd(int n1,int n2){\\n\\t    if(n2==0){\\n\\t        return n1;\\n\\t    }\\n\\t    if(n1>n2){\\n\\t        return gcd(n2,n1%n2);\\n\\t    }\\n\\t    else{\\n\\t        return gcd(n1,n2%n1);\\n\\t    }\\n\\t    \\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999871,
                "title": "java-beats-almost-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    static int gcd(int n,int m){\\n        if(m==0)\\n            return n;\\n        else\\n            return gcd(m,n%m);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n            res=gcd(res,nums[i]);\\n        return res==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int gcd(int n,int m){\\n        if(m==0)\\n            return n;\\n        else\\n            return gcd(m,n%m);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n            res=gcd(res,nums[i]);\\n        return res==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968527,
                "title": "easy-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n         int valid = nums[0];\\n     \\n     // get GCD between all elements in Vector\\n       for(auto& i : nums )\\n            valid= __gcd( valid , i) ;\\n       \\n       return valid==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n         int valid = nums[0];\\n     \\n     // get GCD between all elements in Vector\\n       for(auto& i : nums )\\n            valid= __gcd( valid , i) ;\\n       \\n       return valid==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941830,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)* O(log(a+b))\\nO(n) : Since we are traversing the array once.\\nO(log(a + b)): Since we are computing gcd.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int a = nums[0];\\n        for (int i=1; i<n; i++)\\n            a =__gcd(a, nums[i]); // __gcd() is C++17 feature\\n        return a == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int a = nums[0];\\n        for (int i=1; i<n; i++)\\n            a =__gcd(a, nums[i]); // __gcd() is C++17 feature\\n        return a == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941083,
                "title": "easy-python-1-liner-using-bezout-s-lemma-faster-than-70",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI applied Bezout\\'s Lemma: https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity. It\\'s easy once you know about it.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return gcd(*nums) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return gcd(*nums) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931442,
                "title": "c-is-equation-diophantine-bezout-s-lemma-o-n-logm-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nAn equation \\n$$a_1x_1+a_2x_2+...a_kx_k=d$$\\n\\nHas integer solutions $x_1\\\\in \\\\mathbb{Z}, x_2\\\\in \\\\mathbb{Z},...x_k\\\\in\\\\mathbb{Z}$ if and only if $d$ divides $gcd(a_1,a_2,...a_k)$.\\n\\nSince here in this case $d=1$, then it is equivalent to asking is \\n$$gcd(a_1,a_2,...a_k) = 1$$ \\n(since only 1 divides 1).\\n\\nNow, the gcd can only ever get smaller when you add more numbers to the set of numbers to analyze the gcd() of. I.e.\\n\\n$$gcd(a_1,a_2,...a_{k-1}) \\\\geq gcd(a_1,a_2,...a_k)$$\\n\\nSo, although the questions asks for if there are any *subsets* of the provided array that fulfil the above property, the easier thing to do actually is to just, take the gcd() of the entire array in a rolling-basis, and return true the moment that rolling gcd() is equal to 1.\\n\\nWe don\\'t need to individually trial each possible subset, because of the property above that the gcd() only gets smaller with each element added. So, effectively, the gcd() of the whole array is the *minimum possible gcd* of the entire array. \\n\\nSo, if even *that* doesn\\'t get us down to 1, then the answer return should be false.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of a gcd operations is O(log(min(a, b))), for some gcd(a,b) operation. Since we analyze the gcd across all elements in the vector, the time complexity is in the order of O(n logm), with m being the average \\'magnitude\\' of the numbers of the array, of size n.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant space O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        /* linear diophantine equations */\\n\\n        if (nums.size() == 1) return (nums[0] == 1);\\n\\n        int currgcd = nums[0];\\n        if (currgcd == 1) return true;\\n\\n        for (int i=1;i<nums.size();i++){\\n            currgcd = __gcd(currgcd, nums[i]);\\n            if (currgcd == 1) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        /* linear diophantine equations */\\n\\n        if (nums.size() == 1) return (nums[0] == 1);\\n\\n        int currgcd = nums[0];\\n        if (currgcd == 1) return true;\\n\\n        for (int i=1;i<nums.size();i++){\\n            currgcd = __gcd(currgcd, nums[i]);\\n            if (currgcd == 1) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895910,
                "title": "c-simple-solution",
                "content": "# Intuition\\nTo use the concept of Linear Diophantine Equation.\\n\\n# Approach\\nLinear Diophantine Equation is a equation that can be written in the form ax + by = c  where c is the gcd of a and b.\\nSo as per the question we just need to check if the gcd of two numbers leads to 1 (any two) then after any array element with gcd 1 will give 1 so the overall is 1.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(Log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ans = __gcd(ans, nums[i]);\\n        }\\n        if(ans == 1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ans = __gcd(ans, nums[i]);\\n        }\\n        if(ans == 1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869969,
                "title": "1250-check-for-good-array-c-easiest-solution",
                "content": "**If You Like, Please Upvote.**\\n\\n![image](https://assets.leetcode.com/users/images/71223fda-af0c-4be5-ab0a-f7af5d5365bc_1669989430.722525.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "**If You Like, Please Upvote.**\\n\\n![image](https://assets.leetcode.com/users/images/71223fda-af0c-4be5-ab0a-f7af5d5365bc_1669989430.722525.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2815805,
                "title": "c-solution-easy-explaination-short-and-simple-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        // Bezout Lemma\\n        // If GCD(a,b) = d\\n        // Then there will exist x,y such that (ax + by = d)\\n\\n        int gc = 0;\\n        for(int i=0;i<nums.size();i++){\\n            gc = gcd(gc,nums[i]);\\n            if(gc == 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        // Bezout Lemma\\n        // If GCD(a,b) = d\\n        // Then there will exist x,y such that (ax + by = d)\\n\\n        int gc = 0;\\n        for(int i=0;i<nums.size();i++){\\n            gc = gcd(gc,nums[i]);\\n            if(gc == 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803451,
                "title": "easy-approach-with-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif ax+by = 1 where x and y are integer. then gcd(a,b) = 1.\\nthen for n numbers gcd(a,b,c,d, ......., n) = 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncalculate gcd for every element in nums array.\\nif that is 1 return true.\\n\\n# Complexity\\n- Time complexity:O(nlog(min(a,nums[i]))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int a = 0;\\n\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            a = __gcd(a,nums[i]);\\n        }\\n        return a == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int a = 0;\\n\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            a = __gcd(a,nums[i]);\\n        }\\n        return a == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777568,
                "title": "python-easy-solution-using-euclidean-algorithm",
                "content": "-approch: finding the gcd of the whole numbers of the array check if it is 1 return True\\n```\\nclass Solution:\\n    def gcd(self,a,b):\\n        while a%b != 0:\\n            mod = a%b\\n            a = b\\n            b = mod \\n        return b\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        gc = nums[0]\\n        for i in range(1,len(nums)):\\n            gc = self.gcd(gc,nums[i])\\n        return True if gc == 1 else False\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self,a,b):\\n        while a%b != 0:\\n            mod = a%b\\n            a = b\\n            b = mod \\n        return b\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        gc = nums[0]\\n        for i in range(1,len(nums)):\\n            gc = self.gcd(gc,nums[i])\\n        return True if gc == 1 else False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773745,
                "title": "easiest-ever-of-all-solutions-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int a=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            a=__gcd(a,nums[i]);\\n            \\n        }\\n        if(a==1)\\n            return true;\\n        else\\n            return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int a=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            a=__gcd(a,nums[i]);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2773604,
                "title": "easy-to-understand-3-line-python-solution-math",
                "content": "\"\"\" In order for two numbers to be multiplied by any number and give a sum of 1 they must have no common factor except one \"\"\"\\n\\nclass Solution: \\n\\tdef isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        cur = nums[0]\\n        for i in range(1, len(nums)):\\n           cur = math.gcd(cur, nums[i])\\n        \\n        return cur == 1",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "\"\"\" In order for two numbers to be multiplied by any number and give a sum of 1 they must have no common factor except one \"\"\"\\n\\nclass Solution: \\n\\tdef isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        cur = nums[0]\\n        for i in range(1, len(nums)):\\n           cur = math.gcd(cur, nums[i])\\n        \\n        return cur == 1",
                "codeTag": "Java"
            },
            {
                "id": 2739714,
                "title": "python-easy-and-well-explain-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:nlogx(m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        #note: math.gcd function only used in Python3\\n        #Using *nums we can pass full array as a argument \\n        if math.gcd(*nums) == 1:\\n            return True\\n        else:\\n            return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        #note: math.gcd function only used in Python3\\n        #Using *nums we can pass full array as a argument \\n        if math.gcd(*nums) == 1:\\n            return True\\n        else:\\n            return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717864,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        a = nums[0]\\n        for i in range(len(nums)):\\n            while nums[i]:\\n                a, nums[i] =nums[i], a % nums[i]\\n        return a == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        a = nums[0]\\n        for i in range(len(nums)):\\n            while nums[i]:\\n                a, nums[i] =nums[i], a % nums[i]\\n        return a == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697627,
                "title": "easy-solution-python-clear-code-gcd",
                "content": "Check this easy solution by using GCD=>\\n\\n\\'\\'\\'\\nclass Solution:\\n     def isGoodArray(self, nums: List[int]) -> bool:\\n        def gcd(a,b):\\n            while a:\\n                a, b = b%a, a\\n            return b\\n        return reduce(gcd,nums)==1\\n\\t\\t\\'\\'\\'\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "Check this easy solution by using GCD=>\\n\\n\\'\\'\\'\\nclass Solution:\\n     def isGoodArray(self, nums: List[int]) -> bool:\\n        def gcd(a,b):\\n            while a:\\n                a, b = b%a, a\\n            return b\\n        return reduce(gcd,nums)==1\\n\\t\\t\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 2672439,
                "title": "java-solution-simple-and-easy",
                "content": "Just an observartion :\\n\\nStart finding gcd of all the elements as you traverse the array ****(gcd_till_now : gcd from 0th index to ith index)****, if at any point **gcd_till_now becomes 1 return true**.\\n\\n**Otherwise return false**.\\n\\n**JAVA**\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n\\n        int n=nums.length;\\n        int gcd_till_now=0;\\n        for(int i=0;i<n;i++){\\n            gcd_till_now=gcd(gcd_till_now,nums[i]);\\n            if(gcd_till_now==1) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    static int gcd(int a, int b){\\n\\n        //Euclid Algo to find GCD of two numbers\\n        if(b==0) return a;\\n\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n\\n        int n=nums.length;\\n        int gcd_till_now=0;\\n        for(int i=0;i<n;i++){\\n            gcd_till_now=gcd(gcd_till_now,nums[i]);\\n            if(gcd_till_now==1) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    static int gcd(int a, int b){\\n\\n        //Euclid Algo to find GCD of two numbers\\n        if(b==0) return a;\\n\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650425,
                "title": "very-nice-question",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0] == 1;\\n        return f(nums) == 1;\\n    }\\n    private int gcd(int a, int b){\\n        if(a%b==0) return b;\\n        return gcd(b,a%b);\\n    }\\n    private int f(int[] nums){\\n        int g = gcd(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            if(g == 1) return 1;\\n            g = gcd(nums[i],g);\\n        }\\n        return g;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0] == 1;\\n        return f(nums) == 1;\\n    }\\n    private int gcd(int a, int b){\\n        if(a%b==0) return b;\\n        return gcd(b,a%b);\\n    }\\n    private int f(int[] nums){\\n        int g = gcd(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            if(g == 1) return 1;\\n            g = gcd(nums[i],g);\\n        }\\n        return g;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635347,
                "title": "c-solution-gcd",
                "content": "Eq. ax+by=1 has solution x, y if gcd(a,b) = 1.\\nCan you generalize the formula?. Check B\\xE9zout\\'s lemma.\\n\\nSolution : ax + by + cz + ... = d\\nso gcd(a,b,c,...) = d\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n    while (a%b != 0){\\n        int rem=a%b;\\n        a=b;\\n        b=rem;\\n    }\\n    return b;\\n}\\n\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcds = 0;\\n        for(int i= 0; i < nums.size();i++){\\n            gcds = gcd(gcds,nums[i]);\\n        }\\n        return gcds==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n    while (a%b != 0){\\n        int rem=a%b;\\n        a=b;\\n        b=rem;\\n    }\\n    return b;\\n}\\n\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcds = 0;\\n        for(int i= 0; i < nums.size();i++){\\n            gcds = gcd(gcds,nums[i]);\\n        }\\n        return gcds==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629091,
                "title": "java-using-gcd-method-o-n",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       int g = nums[0];\\n        if(nums.length == 0)\\n            return true;\\n        if(nums.length == 1 && nums[0] == 1)\\n            return true;\\n        for(int  i = 1 ;i < nums.length ;i++)\\n        {\\n            g = Gcd(g,nums[i]);\\n            if(g == 1)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public int Gcd(int num1,int num2){\\n        while(num1 % num2 != 0){\\n            int remainder = num1 % num2;\\n            num1 = num2;\\n            num2 = remainder;\\n        }\\n        return num2;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       int g = nums[0];\\n        if(nums.length == 0)\\n            return true;\\n        if(nums.length == 1 && nums[0] == 1)\\n            return true;\\n        for(int  i = 1 ;i < nums.length ;i++)\\n        {\\n            g = Gcd(g,nums[i]);\\n            if(g == 1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2614668,
                "title": "simple-math-problem-c",
                "content": "The key idea is **B\\xE9zout\\'s identity**.\\n\\n[check wikipedia](https://en.wikipedia.org/wiki/B\\xE9zout%27s_identity)\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = 0;\\n        for (auto & e : nums){\\n            g = __gcd(g, e);    \\n        }\\n        return (g == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = 0;\\n        for (auto & e : nums){\\n            g = __gcd(g, e);    \\n        }\\n        return (g == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543689,
                "title": "c-easy-solution-math-dp-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<int>&nums,int index, int curr,vector<int>&dp){\\n        if(index==nums.size()){\\n            return 0;\\n        }\\n        if(__gcd(curr,nums[index])==1){\\n            return dp[index]=1;\\n        }\\n        if(dp[index]!=-1)return dp[index];\\n        return dp[index]=fun(nums,index+1,__gcd(curr,nums[index]),dp)|fun(nums,index+1,curr,dp);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        if(nums.size()==1)return 0;\\n        vector<int>dp(nums.size()+1,-1);\\n        return fun(nums,1,nums[0],dp);\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<int>&nums,int index, int curr,vector<int>&dp){\\n        if(index==nums.size()){\\n            return 0;\\n        }\\n        if(__gcd(curr,nums[index])==1){\\n            return dp[index]=1;\\n        }\\n        if(dp[index]!=-1)return dp[index];\\n        return dp[index]=fun(nums,index+1,__gcd(curr,nums[index]),dp)|fun(nums,index+1,curr,dp);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        if(nums.size()==1)return 0;\\n        vector<int>dp(nums.size()+1,-1);\\n        return fun(nums,1,nums[0],dp);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519436,
                "title": "simple-solution-using-loops-bezout-s-identity",
                "content": "public boolean isGoodArray(int[] nums) {\\n        \\n        // this the base case\\n        if(nums.length == 0 || nums == null) return true;\\n        if(nums.length == 1) return nums[0] == 1;\\n        \\n        int gcdResult = nums[0];\\n        \\n        // storing GCD of two numbers and then finding new GCD with GCD of previous two numbers and next number and so on.\\n        //And where we find GCD = 1 we return true and if we not we just return false.\\n        for(int i = 1; i < nums.length; i++){\\n            gcdResult = gcd(gcdResult, nums[i]);\\n            if(gcdResult == 1) return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    //method to find GCD of two numbers\\n    public int gcd(int num1, int num2){\\n    \\n            while(num1 % num2 != 0){\\n                int remainder = num1 % num2;\\n                num1 = num2;\\n                num2 = remainder;\\n            }\\n            return num2;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public boolean isGoodArray(int[] nums) {\\n        \\n        // this the base case\\n        if(nums.length == 0 || nums == null) return true;\\n        if(nums.length == 1) return nums[0] == 1;\\n        \\n        int gcdResult = nums[0];\\n        \\n        // storing GCD of two numbers and then finding new GCD with GCD of previous two numbers and next number and so on.\\n        //And where we find GCD = 1 we return true and if we not we just return false.\\n        for(int i = 1; i < nums.length; i++){\\n            gcdResult = gcd(gcdResult, nums[i]);\\n            if(gcdResult == 1) return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    //method to find GCD of two numbers\\n    public int gcd(int num1, int num2){\\n    \\n            while(num1 % num2 != 0){\\n                int remainder = num1 % num2;\\n                num1 = num2;\\n                num2 = remainder;\\n            }\\n            return num2;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2481750,
                "title": "c-number-theory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()<=2){\\n            if(nums.size()==1){\\n                if(nums[0]==1)return true;\\n                else return false;\\n            }\\n            if(__gcd(nums[0],nums[1])==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        else{\\n            int x=__gcd(nums[0],nums[1]);\\n            for(int i=2;i<nums.size();i++){\\n                x=__gcd(x,nums[i]);\\n            }\\n            if(x==1)return true;\\n            else return false;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()<=2){\\n            if(nums.size()==1){\\n                if(nums[0]==1)return true;\\n                else return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2435203,
                "title": "c-easy-to-understand",
                "content": "~~~\\nclass Solution {\\npublic:\\n   \\nint gcd(int a,int b){\\n    if(a<b){\\n        swap(a,b);\\n    }\\n    if(b==0){\\n        return a;\\n    }\\n    return gcd(b,a%b);\\n}\\nbool isGoodArray(vector<int> nums) {\\n    int ans=0;\\n    for(auto i:nums)\\n    {\\n        ans=gcd(i,ans);\\n    }\\n    return ans==1;\\n}\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\nint gcd(int a,int b){\\n    if(a<b){\\n        swap(a,b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2416970,
                "title": "c-explained-beginner",
                "content": "Extended Eucild theorem:  **ax+by = gcd(a,b)**\\nTo get ax+by=1 , we need to get two integer a , b in array such that their gcd(Greatest common divisor) is equal to 1. \\n**GCD(a,b)=1**\\n\\n\\tint gcd(int a , int b)\\n    {\\n        if (b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    int gcd_arr(vector<int> & v1)\\n    {\\n        int ans=v1[0];\\n        for (int i=0;i<v1.size();i++)\\n        {\\n            ans=gcd(v1[i],ans);\\n        }\\n        return ans;\\n    }\\n    bool isGoodArray(vector<int>& nums) \\n    {\\n        return gcd_arr(nums)==1 ? true:false;\\n    }",
                "solutionTags": [],
                "code": "Extended Eucild theorem:  **ax+by = gcd(a,b)**\\nTo get ax+by=1 , we need to get two integer a , b in array such that their gcd(Greatest common divisor) is equal to 1. \\n**GCD(a,b)=1**\\n\\n\\tint gcd(int a , int b)\\n    {\\n        if (b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    int gcd_arr(vector<int> & v1)\\n    {\\n        int ans=v1[0];\\n        for (int i=0;i<v1.size();i++)\\n        {\\n            ans=gcd(v1[i],ans);\\n        }\\n        return ans;\\n    }\\n    bool isGoodArray(vector<int>& nums) \\n    {\\n        return gcd_arr(nums)==1 ? true:false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2329587,
                "title": "fundamental-approach-c-gcd-math",
                "content": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = nums[0];\\n        for(auto i:nums) {\\n            g = gcd(g, i);\\n        }\\n        return (g == 1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = nums[0];\\n        for(auto i:nums) {\\n            g = gcd(g, i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2317234,
                "title": "check-if-its-a-good-array",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i =1; i<nums.length; i++){\\n           gcd = GCD(gcd, nums[i]);\\n            if (gcd==1)\\n                return true;\\n        }\\n        return gcd ==1;\\n        \\n    }\\n    int GCD(int a, int b){\\n        if(b==0){\\n            return a;\\n        }\\n        else{\\n            return GCD(b, a%b);\\n        }\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i =1; i<nums.length; i++){\\n           gcd = GCD(gcd, nums[i]);\\n            if (gcd==1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2307248,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int x = nums[0];\\n        if(nums.length == 1 && x==1)\\n            return true;\\n        for(int y : nums)\\n        {\\n            if (GCD(x,y)==1)\\n                return true;\\n            x = GCD(x,y);\\n        }\\n        return false;\\n    }\\n    public int GCD(int x,int y)\\n    {\\n        if(x==0)\\n            return y;\\n        return GCD(y%x,x);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int x = nums[0];\\n        if(nums.length == 1 && x==1)\\n            return true;\\n        for(int y : nums)\\n        {\\n            if (GCD(x,y)==1)\\n                return true;\\n            x = GCD(x,y);\\n        }\\n        return false;\\n    }\\n    public int GCD(int x,int y)\\n    {\\n        if(x==0)\\n            return y;\\n        return GCD(y%x,x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305986,
                "title": "easy-to-understand-4-line-c-code",
                "content": "**The only reason I\\'m posting this is because I solved my 2nd hard problem of the day.**\\nSo, something that I was able to deduce from the testcases was the prevalance of prime numbers in the solution array. And an array of composite numbers will automatically yield a \\'false\\' output.\\nProof-  Input array- [a,b]. Let\\'s assume a and b are composite in nature\\n\\t\\t\\ttherefore a=GCD*x and b=GCD*y\\n\\t\\t\\tsum= m*a + n*b = m*GCD*x + n*GCD*y = GCD(m*x + n*y)\\n\\t\\t\\tThe only way sum=1 is if GCD=1 (and m*x + n*y=1). Else sum=0 or some other value.\\n\\t\\t\\t***This contradicts our assumption of a and b being composite is nature, hence they must be prime i.e GCD=1***\\n\\t\\t\\t\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcd=0;\\n        for(int i=0; i<nums.size(); i++){\\n            gcd=__gcd(gcd,nums[i]);\\n        }return gcd==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcd=0;\\n        for(int i=0; i<nums.size(); i++){\\n            gcd=__gcd(gcd,nums[i]);\\n        }return gcd==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304951,
                "title": "python-gcd-100-memory-usage",
                "content": "def isGoodArray(self, nums):\\n\\n        if len(nums) == 1:\\n            return nums[0] == 1\\n\\t\\t\\t\\n        def gcd(a, b):\\n            if a == 0 :\\n                return b\\n\\n            return gcd(b%a, a)\\n        \\n        for i in range(1,len(nums)):\\n            greatest_denom = gcd(nums[i-1],nums[i])\\n            if greatest_denom == 1:\\n                return True\\n            nums[i] = greatest_denom\\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "def isGoodArray(self, nums):\\n\\n        if len(nums) == 1:\\n            return nums[0] == 1\\n\\t\\t\\t\\n        def gcd(a, b):\\n            if a == 0 :\\n                return b\\n\\n            return gcd(b%a, a)\\n        \\n        for i in range(1,len(nums)):\\n            greatest_denom = gcd(nums[i-1],nums[i])\\n            if greatest_denom == 1:\\n                return True\\n            nums[i] = greatest_denom\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2281234,
                "title": "python-for-beginners-with-explanation",
                "content": "```\\nfrom math import gcd\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd,nums)==1\\n\\n    # Reduce function is used to apply a particular function passed in its argument to all of the list elements mentioned in the sequence passed along\\n    \"\"\"\\n    Working:\\n    (1)At first step, first two elements of sequence are picked and the result is obtained.\\n    (2)Next step is to apply the same function to the previously attained result and the number just succeeding the second element and the result is again stored.\\n    (3)This process continues till no more elements are left in the container.\\n    \\n    To find Highest Common Factor (H.C.F) python has built-in functions (GCD) \\n    \"\"\"\\n           \\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd,nums)==1\\n\\n    # Reduce function is used to apply a particular function passed in its argument to all of the list elements mentioned in the sequence passed along\\n    \"\"\"\\n    Working:\\n    (1)At first step, first two elements of sequence are picked and the result is obtained.\\n    (2)Next step is to apply the same function to the previously attained result and the number just succeeding the second element and the result is again stored.\\n    (3)This process continues till no more elements are left in the container.\\n    \\n    To find Highest Common Factor (H.C.F) python has built-in functions (GCD) \\n    \"\"\"\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186811,
                "title": "easy-explaination",
                "content": "If we can find a subset with gcd as 1, it would be possible to attain the answer. \\n\\n```\\nclass Solution {\\n    int gcd(int a, int b){\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    \\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currGcd = nums[0];\\n        for(int i=1;i<n;i++){\\n            currGcd = gcd(currGcd, nums[i]);\\n        }\\n        return currGcd == 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int gcd(int a, int b){\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    \\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currGcd = nums[0];\\n        for(int i=1;i<n;i++){\\n            currGcd = gcd(currGcd, nums[i]);\\n        }\\n        return currGcd == 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181400,
                "title": "check-common-divisor",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    int gcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    \\n    bool isGoodArray(vector<int>& nums){\\n        \\n        sort(nums.begin(),nums.end());\\n        int num = nums[0];\\n        if(nums.size() == 1) return nums[0] == 1;\\n        \\n        // finding the divisor of nums[0];\\n        int g = nums[0];\\n        for(int i = 1;i < nums.size() ; i++){\\n             g = gcd(g,nums[i]);\\n        }\\n        if(g == 1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int gcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    \\n    bool isGoodArray(vector<int>& nums){\\n        \\n        sort(nums.begin(),nums.end());\\n        int num = nums[0];\\n        if(nums.size() == 1) return nums[0] == 1;\\n        \\n        // finding the divisor of nums[0];\\n        int g = nums[0];\\n        for(int i = 1;i < nums.size() ; i++){\\n             g = gcd(g,nums[i]);\\n        }\\n        if(g == 1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139601,
                "title": "euler-s-theorem",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gd = nums[0];\\n        for (int i = 1, ed = nums.size(); i < ed; i ++) {\\n            gd = __gcd(gd, nums[i]);\\n        }\\n        return gd == 1;\\n    }\\n};\\n```\\n\\nEuler\\'s theorem: for every two numbers **a** and **b** where gcd(a, b) = 1, a^(\\u03C6(b)) = 1 (mod b), where \\u03C6(b) is the number of integers coprime to b in [1, b-1]. Therefore, only if there exists coprime numbers in nums, there has answer",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gd = nums[0];\\n        for (int i = 1, ed = nums.size(); i < ed; i ++) {\\n            gd = __gcd(gd, nums[i]);\\n        }\\n        return gd == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117457,
                "title": "java-easy-solution-check-if-it-is-a-good-array",
                "content": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n    int gcd=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            gcd=gcd(gcd, nums[i]);\\n          \\n        }\\n        return gcd==1;\\n}\\n        public int gcd(int n1, int n2) {\\n   if (n2==0) return n1;\\n   return gcd(n2,n1%n2);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n    int gcd=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            gcd=gcd(gcd, nums[i]);\\n          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2096387,
                "title": "simple-javascript-solution-easy-to-understand",
                "content": "```\\nfunction isGoodArray(n, ans = n.shift()) {\\n    for (let i of n) {\\n        while (i) [ans, i] = [i, ans % i]\\n    }\\n    return ans === 1\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isGoodArray(n, ans = n.shift()) {\\n    for (let i of n) {\\n        while (i) [ans, i] = [i, ans % i]\\n    }\\n    return ans === 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087411,
                "title": "simple-java-solution",
                "content": "Basically, 1 can be achieved if the numbers do not have common divisors, so their greatest common divisor must be 1. C++ gives an inbuilt function to find gcd, but for java we gotta do it ourselves.\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if (nums.length == 1 && nums[0] == 1)\\n            return true;\\n        \\n        int gcd = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            \\n            int a = (nums[i] > gcd) ? nums[i] : gcd;\\n            int b = (nums[i] < gcd) ? nums[i] : gcd;\\n            int r = b;\\n            while (a % b != 0) {\\n                r = a % b;\\n                a = b;\\n                b = r;\\n            }\\n            \\n            gcd = r;\\n            if (gcd == 1) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if (nums.length == 1 && nums[0] == 1)\\n            return true;\\n        \\n        int gcd = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            \\n            int a = (nums[i] > gcd) ? nums[i] : gcd;\\n            int b = (nums[i] < gcd) ? nums[i] : gcd;\\n            int r = b;\\n            while (a % b != 0) {\\n                r = a % b;\\n                a = b;\\n                b = r;\\n            }\\n            \\n            gcd = r;\\n            if (gcd == 1) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082496,
                "title": "5-lines-python-solution-beats-93",
                "content": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        def gcd(a,b):\\n            while a:\\n                a, b = b%a, a\\n            return b\\n        return reduce(gcd,nums)==1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        def gcd(a,b):\\n            while a:\\n                a, b = b%a, a\\n            return b\\n        return reduce(gcd,nums)==1",
                "codeTag": "Java"
            },
            {
                "id": 2068849,
                "title": "c-solution-using-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size() == 1 && nums[0] == 1) return true;\\n        \\n        int tmp = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            tmp = __gcd(tmp, nums[i]);\\n            if(tmp == 1) return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size() == 1 && nums[0] == 1) return true;\\n        \\n        int tmp = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            tmp = __gcd(tmp, nums[i]);\\n            if(tmp == 1) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1985871,
                "title": "javascript-simple-and-direct-solution",
                "content": "```\\nvar isGoodArray = function(nums) {\\n    let gcd = nums[0]\\n    \\n    for(let n of nums){while(n){[gcd, n] = [n, gcd % n]}}\\n    \\n    return (gcd === 1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isGoodArray = function(nums) {\\n    let gcd = nums[0]\\n    \\n    for(let n of nums){while(n){[gcd, n] = [n, gcd % n]}}\\n    \\n    return (gcd === 1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1984412,
                "title": "simple-gcd-approach-java",
                "content": "The diffrence can only be 1 if and only if there are 2  numbers whose GCD is 1 \\neg 2 4 7 11\\ngcd of (2,4)=2\\ngcd of(2,7)=1 \\nso it is possible 2*(-3)-7*(-1)=1\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n=nums.length;\\n        if(n==1&&nums[0]==1)\\n            return true;\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=fnGcd(ans,nums[i]);\\n            if(ans==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n    public int fnGcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return fnGcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n=nums.length;\\n        if(n==1&&nums[0]==1)\\n            return true;\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=fnGcd(ans,nums[i]);\\n            if(ans==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n    public int fnGcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return fnGcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565240,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1565996,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1566586,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1566585,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1569672,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1781708,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1573164,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 2045382,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 2012469,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1930957,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1565240,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1565996,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1566586,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1566585,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1569672,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1781708,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1573164,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 2045382,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 2012469,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1930957,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            }
        ]
    }
]