[
    {
        "title": "Minimize String Length",
        "question_content": "Given a 0-indexed string s, repeatedly perform the following operation any number of times:\n\n\tChoose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the left of i (if any) and the closest occurrence of c to the right of i (if any).\n\nYour task is to minimize the length of s by performing the above operation any number of times.\nReturn an integer denoting the length of the minimized string.\n&nbsp;\nExample 1:\n\nInput: s = \"aaabc\"\nOutput: 3\nExplanation: In this example, s is \"aaabc\". We can start by selecting the character 'a' at index 1. We then remove the closest 'a' to the left of index 1, which is at index 0, and the closest 'a' to the right of index 1, which is at index 2. After this operation, the string becomes \"abc\". Any further operation we perform on the string will leave it unchanged. Therefore, the length of the minimized string is 3.\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: 3\nExplanation: For this we can start with character 'b' at index 1. There is no occurrence of 'b' to the left of index 1, but there is one to the right at index 2, so we delete the 'b' at index 2. The string becomes \"cbd\" and further operations will leave it unchanged. Hence, the minimized length is 3.&nbsp;\n\nExample 3:\n\nInput: s = \"dddaaa\"\nOutput: 2\nExplanation: For this, we can start with the character 'd' at index 1. The closest occurrence of a 'd' to its left is at index 0, and the closest occurrence of a 'd' to its right is at index 2. We delete both index 0 and 2, so the string becomes \"daaa\". In the new string, we can select the character 'a' at index 2. The closest occurrence of an 'a' to its left is at index 1, and the closest occurrence of an 'a' to its right is at index 3. We delete both of them, and the string becomes \"da\". We cannot minimize this further, so the minimized length is 2.\n\n&nbsp;\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 100\n\ts contains only lowercase English letters",
        "solutions": [
            {
                "id": 3616312,
                "title": "one-line-code-for-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set((s)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set((s)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595131,
                "title": "find-unique-character-very-simple-and-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution </b>\\nIt can be observed that the we can remove all the duplicate of a character except the last one. So basically we just need to find number of unique character we have in the string as the answer.\\n\\n# Code\\n```\\nint minimizedStringLength(string s) {\\n    unordered_set<char> st;\\n    for(auto c: s) st.insert(c);\\n    return st.size();\\n}\\n```\\n\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimizedStringLength(string s) {\\n    unordered_set<char> st;\\n    for(auto c: s) st.insert(c);\\n    return st.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595387,
                "title": "one-line-solution-c-java-python",
                "content": "# Intuition\\nJust count the number of distinct characters.\\n\\n# Approach\\nJust count the number of distinct characters.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        return unordered_set<char>(s.begin(), s.end()).size();\\n    }\\n};\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n}\\n```\\n\\nPython\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        return unordered_set<char>(s.begin(), s.end()).size();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594946,
                "title": "hashset",
                "content": "We can remove all occurances of `c` except the last one.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len({*s})\\n```\\n\\n**C++**\\n```cpp\\nint minimizedStringLength(string s) {\\n    return unordered_set(begin(s), end(s)).size();\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len({*s})\\n```\n```cpp\\nint minimizedStringLength(string s) {\\n    return unordered_set(begin(s), end(s)).size();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594961,
                "title": "java-easy-solution-6-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimizedStringLength(String s) {\\n    var map = new boolean[26];\\n    var ans = 0;\\n    \\n    for (var c : s.toCharArray())\\n      map[c - \\'a\\'] = true;\\n\\n    for (var c : map) if (c) ans++;\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minimizedStringLength(String s) {\\n    var map = new boolean[26];\\n    var ans = 0;\\n    \\n    for (var c : s.toCharArray())\\n      map[c - \\'a\\'] = true;\\n\\n    for (var c : map) if (c) ans++;\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594910,
                "title": "use-new-set-2-lines",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = function(s) {\\n    const u = new Set(s)\\n    return u.size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = function(s) {\\n    const u = new Set(s)\\n    return u.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596066,
                "title": "python-3-1-line-w-explanation-t-m-98-46",
                "content": "The problem can be reduced to this:\\n\\nIf a character occurs more than once in`s`, then we may remove at least one of those characters with each move. If exactly one of a character is present, then it may not be removed. Hence, the answer is the count of distinct\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(s))\\n```\\n[https://leetcode.com/problems/minimize-string-length/submissions/963522297/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1) in which *N* ~ count of distinct characters.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595507,
                "title": "java-c-python-hashset",
                "content": "# **Explanation**\\nFor all same character, at least one will be left.\\nSo we only need to know,\\nahow many different characters in the input `s`\\nWe can use a hash set to find this.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(26)`\\n<br>\\n\\n**Java**\\nUse `distinct`\\n```java\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimizedStringLength(string s) {\\n        return unordered_set(s.begin(), s.end()).size();\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n```\n```cpp\\n    int minimizedStringLength(string s) {\\n        return unordered_set(s.begin(), s.end()).size();\\n    }\\n```\n```py\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3625803,
                "title": "easy-solution-in-java-0ms-100-beats",
                "content": "# Approach\\nThe approach to solving the problem is as follows:\\n\\n1. A method named `minimizedStringLength` is defined, which takes a string parameter `s`.\\n2. Inside the method, an integer array `arr` of size 26 is created to store the count of each letter in the alphabet.\\n3. The method iterates through each character `c` in the string `s` using a for-each loop.\\n4. For each character, the count at the corresponding index in the `arr` array is incremented by 1. This step counts the occurrences of each letter in the string.\\n5. After counting the occurrences of each letter, a variable `count` is initialized to 0.\\n6. The method iterates through each element `n` in the `arr` array.\\n7. For each element, if it is not zero (indicating that the letter is present in the string), the `count` variable is incremented by 1.\\n8. Finally, the value of `count` is returned, which represents the number of distinct letters present in the string `s`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595845,
                "title": "count-disticnt-no-of-chars-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> v(26,0);\\n        int ans = 0;\\n        for(auto &i: s){\\n            if(!v[i-\\'a\\']){\\n                ans++;\\n                v[i-\\'a\\'] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> v(26,0);\\n        int ans = 0;\\n        for(auto &i: s){\\n            if(!v[i-\\'a\\']){\\n                ans++;\\n                v[i-\\'a\\'] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595137,
                "title": "c-very-easy-solution-using-map-stl",
                "content": "# Intuition\\nAt first glance, we can clearly see that we have to count all unique characters in given string.\\n\\n# Approach\\nThe code uses a map data structure, count, to keep track of the frequency of each character in the string. It iterates over the characters in the string using a for loop and updates the count for each character. After counting all the characters, the size of the map is returned, which represents the number of distinct characters in the string.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input string. As the code iterates over each character in the string once\\n\\n- Space complexity:\\nO(n), as the map will store n key-value pairs, where n is the length of the input string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        \\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        \\n        return count.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        \\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        \\n        return count.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959846,
                "title": "very-easy-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a hashset of type characters \\n- Iterate all the characters of the string and add those characters in the hashset\\n- Hashset do not allow duplicate elememts \\n- return the size of the hashset\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set=new HashSet();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set=new HashSet();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924430,
                "title": "4-lines-solution-java-hashset",
                "content": "# Intuition\\nThe problem is all about removing all duplicates.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo, use hashSet and return the size of the set.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n            set.add(c);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n            set.add(c);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786530,
                "title": "java-faster-then-100-1-liner",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Codes :\\n### **1st method : 100% faster**\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean map[] = new boolean[26];\\n        int ans = 0;\\n        for(char c : s.toCharArray()) \\n            map[c - \\'a\\'] = true;\\n        for(boolean b : map)\\n            if(b == true) ans ++;\\n        return ans;\\n    }\\n}\\n```\\n### **2nd method : 1 liner**\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int)s.chars().distinct().count();\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean map[] = new boolean[26];\\n        int ans = 0;\\n        for(char c : s.toCharArray()) \\n            map[c - \\'a\\'] = true;\\n        for(boolean b : map)\\n            if(b == true) ans ++;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int)s.chars().distinct().count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606038,
                "title": "c-java-count-number-of-unique-characters",
                "content": "Given the problem that asks us to select an index `i` within a string and then delete the nearest instances of that character to the left and right of `i`, we can infer that we should remove all duplicate occurrences of each character, leaving only one occurrence of each. Therefore, the problem can be simplified to determining the count of unique characters within the string.\\n\\nWe can solve this problem using a hashset, but this method might be too time-consuming. As an optimization, we can use a boolean array instead. The first time we encounter a character, we increment a count. This count, maintained throughout the iteration of the string, serves as the final solution.\\n\\nC++:\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598133,
                "title": "python-elegant-short-1-line-hash-set-size",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597498,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597086,
                "title": "c-solution-stack-beginner-friendly-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        stack<char> stk;\\n        map<char, int> mp;\\n        for (int i=0;i<s.length(); i++) {\\n            if ((!stk.empty() && s[i] == stk.top()) or (!stk.empty() && mp.find(s[i]) != mp.end())) {\\n                // \\n            } else {\\n                stk.push(s[i]);\\n                mp.insert({s[i], i});\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        stack<char> stk;\\n        map<char, int> mp;\\n        for (int i=0;i<s.length(); i++) {\\n            if ((!stk.empty() && s[i] == stk.top()) or (!stk.empty() && mp.find(s[i]) != mp.end())) {\\n                // \\n            } else {\\n                stk.push(s[i]);\\n                mp.insert({s[i], i});\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595303,
                "title": "o-n-easy-to-understand-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Check if the result contains the character or not. If the result contains\\n    the character then do not add it, else add that charcter to the resultant\\n    string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if(!result.contains(String.valueOf(s.charAt(i)))) {\\n                result += String.valueOf(s.charAt(i));\\n            }\\n        }\\n        return result.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if(!result.contains(String.valueOf(s.charAt(i)))) {\\n                result += String.valueOf(s.charAt(i));\\n            }\\n        }\\n        return result.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595248,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int len = s.length();\\n        int charIndex = 0;\\n        while(charIndex < 26) {\\n            int i=0;\\n            while(i < s.length() && s.charAt(i) != (char) (\\'a\\' + charIndex))\\n                i++;\\n            int end = i+1;\\n            int count = 0;\\n            while(end < s.length()) {\\n                if(s.charAt(end) == (char)(\\'a\\' + charIndex))\\n                    count++;\\n                if(count == 2) {\\n                    len -= 2;\\n                    count = 0;\\n                }\\n                end++;\\n            }\\n            if(count > 0)\\n                len -= 1;\\n            charIndex++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int len = s.length();\\n        int charIndex = 0;\\n        while(charIndex < 26) {\\n            int i=0;\\n            while(i < s.length() && s.charAt(i) != (char) (\\'a\\' + charIndex))\\n                i++;\\n            int end = i+1;\\n            int count = 0;\\n            while(end < s.length()) {\\n                if(s.charAt(end) == (char)(\\'a\\' + charIndex))\\n                    count++;\\n                if(count == 2) {\\n                    len -= 2;\\n                    count = 0;\\n                }\\n                end++;\\n            }\\n            if(count > 0)\\n                len -= 1;\\n            charIndex++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595149,
                "title": "just-2-lines-c-easiest-problem",
                "content": "CODE\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<int>set(s.begin(),s.end());\\n        return set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<int>set(s.begin(),s.end());\\n        return set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925129,
                "title": "easy-understanding-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] counts = new int[26];\\n        int result =0;\\n        for(char c: chars){\\n            counts[c-\\'a\\']++;\\n        }\\n        for(int i:counts){\\n            if(i>0){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] counts = new int[26];\\n        int result =0;\\n        for(char c: chars){\\n            counts[c-\\'a\\']++;\\n        }\\n        for(int i:counts){\\n            if(i>0){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908437,
                "title": "super-easy-python3-solution-beats-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = []\\n        for i in s:\\n            res.append(i)\\n        news=set(res)\\n        return len(news)\\n```\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(res))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = []\\n        for i in s:\\n            res.append(i)\\n        news=set(res)\\n        return len(news)\\n```\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838984,
                "title": "can-you-optimize-it-c-solution-beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string ans =\"\";\\n        sort(s.begin(),s.end());\\n        for(int i = 1 ; i<s.length();i++ ){\\n            if(s[i]!=s[i-1]){\\n                ans+=s[i];\\n            }\\n        }\\n        return ans.length()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string ans =\"\";\\n        sort(s.begin(),s.end());\\n        for(int i = 1 ; i<s.length();i++ ){\\n            if(s[i]!=s[i-1]){\\n                ans+=s[i];\\n            }\\n        }\\n        return ans.length()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704884,
                "title": "c-easy-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/2fe5698a-d0e5-4549-8638-57aecfff5a34_1688226708.6732652.png)\\n\\n# Intuition\\nJust return the number of different chars.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        return new HashSet<char>(s).Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        return new HashSet<char>(s).Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619491,
                "title": "python3-one-liner-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf at every character, we are allowed to remove its left and right occurrences then basically we can remove all its duplicate occurrences.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can just return the length of the set of given string as, the set object in python removes all duplicate occurrences of all the elements present in the iterative object passed to it. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the length of s\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612504,
                "title": "simple-c-code",
                "content": "# Code\\n\\n## Code 1 : Using Unordered Set\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set <char> us;\\n        for(auto &it:s)\\n            us.insert(it);\\n        return us.size();\\n    }\\n};\\n```\\n\\n## Code 2: Using Unordered Map\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map <char,bool> ump;\\n        for(auto &it:s)\\n            ump[it]=1;\\n        return ump.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set <char> us;\\n        for(auto &it:s)\\n            us.insert(it);\\n        return us.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map <char,bool> ump;\\n        for(auto &it:s)\\n            ump[it]=1;\\n        return ump.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597035,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596812,
                "title": "one-liner-solution-as-simple-as-it-can-get",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set st(s.begin(),s.end());\\n        return st.size();       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set st(s.begin(),s.end());\\n        return st.size();       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596319,
                "title": "minimize-string-length",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>hs = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            hs.add(c);\\n        }\\n        return hs.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>hs = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            hs.add(c);\\n        }\\n        return hs.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595430,
                "title": "c-python-java-easy-solution-w-intuition-code",
                "content": "# Intuition\\nIn this problem, you can prove that only one occurance of any character will remain by the end of all operation.\\nConsider the string s=\"abcdabacd\"\\n```html\\nindex  - 0 1 2 3 4 5 6 7 8 9\\nstring - a b c d a b a c d a\\n```\\nWe\\'ll consider the index to be unchanged after removal for simplicity of explanation.\\n\\nAt i=0, the \"a\" present at i=4 will be removed.\\nAt i=6, the \"a\" present at i=0 and i=9 will be removed.\\n\\nSimilarly, at each occurance of \"a\", at least 1 other \"a\" will be removed(if any exist). This way only one occurance of every character will remain. \\n\\n# Approach\\nSince we know that we just have to count the number of distinct character, the approach is as simple as using a hashset to get the number of distinct characters.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> cset;\\n        for(char c: s)\\n            cset.insert(c);\\n        return cset.size();\\n    }\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```\\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for(int i=0; i<s.length(); i++)\\n            hs.add(s.charAt(i));\\n        return hs.size();\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> hs(26, false);\\n        for(char c: s)\\n            hs[c-\\'a\\'] = true;\\n        int res{0};\\n        for(bool c: hs)\\n            res += c;\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$\\nSince we\\'re traversing the entire string once.\\n\\n- Space complexity: $$O(n)$$ \\nBecause we are storing all the characters of `s` in the Hash Set. In this specific case, the constraint \"*`s` contains only lowercase English letters*\" makes it $$O(26)$$.\\n\\n>### Note\\n>- Upvote if you liked my solution\\n>- Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```html\\nindex  - 0 1 2 3 4 5 6 7 8 9\\nstring - a b c d a b a c d a\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> cset;\\n        for(char c: s)\\n            cset.insert(c);\\n        return cset.size();\\n    }\\n};\\n```\n```python []\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for(int i=0; i<s.length(); i++)\\n            hs.add(s.charAt(i));\\n        return hs.size();\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> hs(26, false);\\n        for(char c: s)\\n            hs[c-\\'a\\'] = true;\\n        int res{0};\\n        for(bool c: hs)\\n            res += c;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595420,
                "title": "return-len-set-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595322,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        unordered_map<char, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n            mp[ch].push_back(i);\\n        }\\n        \\n        return mp.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        unordered_map<char, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n            mp[ch].push_back(i);\\n        }\\n        \\n        return mp.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595317,
                "title": "python3-solution-one-linear",
                "content": "# Intuition\\nWe can delete any letters as much if its duplicate exist. So we need to count the number of all different characters in the string.\\n\\n# Approach\\nBy using Counter in python we can achieve the above. the len of the counter is the number of different characters in the string.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(26)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(Counter(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(Counter(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595313,
                "title": "c-o-n-simple-solution",
                "content": "# Intuition\\nJust return the number of different chars.\\n\\n# Approach\\nAt first count number of each char:\\n```\\nprivate Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n```\\nThen return the number of different chars:\\n```\\nvar dic = CreateMinimizedStringLengt(s);\\nreturn dic.Count;\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is the length of s\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        var dic = CreateMinimizedStringLengt(s);\\n        return dic.Count;\\n    }\\n    private Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n    {\\n        var rs = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (!rs.ContainsKey(s[i]))\\n            {\\n                rs.Add(s[i], 1);\\n            }\\n            else\\n            {\\n                rs[s[i]]++;\\n            }\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n```\n```\\nvar dic = CreateMinimizedStringLengt(s);\\nreturn dic.Count;\\n```\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        var dic = CreateMinimizedStringLengt(s);\\n        return dic.Count;\\n    }\\n    private Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n    {\\n        var rs = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (!rs.ContainsKey(s[i]))\\n            {\\n                rs.Add(s[i], 1);\\n            }\\n            else\\n            {\\n                rs[s[i]]++;\\n            }\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595246,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto it:s) st.insert(it);\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto it:s) st.insert(it);\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595098,
                "title": "easy-java-6-line-hashset",
                "content": "```\\nclass Solution {\\n   public static int minimizedStringLength(String s) {\\n      char str[]=s.toCharArray();\\n      HashSet<Character> hs=new HashSet<>();\\n      for(int i=0;i<s.length();i++){\\n        hs.add(s.charAt(i));\\n      }\\n      return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static int minimizedStringLength(String s) {\\n      char str[]=s.toCharArray();\\n      HashSet<Character> hs=new HashSet<>();\\n      for(int i=0;i<s.length();i++){\\n        hs.add(s.charAt(i));\\n      }\\n      return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595088,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n    We need to count unique char in the string\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m) \\n    m = number of unique char, max value is 26\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = (s) => {\\n    const uniqueChars = new Set([...s]);\\n    return uniqueChars.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = (s) => {\\n    const uniqueChars = new Set([...s]);\\n    return uniqueChars.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595082,
                "title": "python3-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a hashmap to store each character in the string. If the character is already inside the hashmap, skip it or just increment its count by 1.\\nWe then can return the length of the hashmap which will only include distinct characters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), we visit each character inside s only once. n is the length of s.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) Worst case, every character is distinct and we have to store all of them inside the hashmap.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Use a hashmap. If character already inside map, don\\'t add. Then return length of hashmap\\n        duplicate = {}\\n\\n        if len(s) == 1:\\n            return 1\\n        for c in s:\\n            if c not in duplicate:\\n                duplicate[c] = 1\\n            duplicate[c] += 1\\n        \\n        return len(duplicate)\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Use a hashmap. If character already inside map, don\\'t add. Then return length of hashmap\\n        duplicate = {}\\n\\n        if len(s) == 1:\\n            return 1\\n        for c in s:\\n            if c not in duplicate:\\n                duplicate[c] = 1\\n            duplicate[c] += 1\\n        \\n        return len(duplicate)\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595065,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a map to count the occurrence of each character in the string. By iterating over the map and incrementing a counter variable, it effectively counts the number of unique characters in the string. The final count represents the minimum length of the string after removing duplicate characters.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a map<int,int> called m to store the count of each character in the input string s.\\n\\nThe for loop iterates through each character it in the string s and increments its count in the map m.\\n\\nAfter counting all the characters, the variable ans is initialized to 0.\\n\\nThe second for loop iterates through each key-value pair it in the map m.\\n\\nIn each iteration, the variable ans is incremented by 1, effectively counting the number of unique characters in the string.\\n\\nFinally, the value of ans is returned as the minimum length of the string after removing duplicates.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the input string s. This is because the code iterates over each character in the string to count their occurrences and then iterates over the map to count the number of unique characters. Both iterations have a linear time complexity with respect to the length of the string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the input string s. This is because the map m stores the count of each character, which can be at most the length of the string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n     \\n    map<int,int> m; // Create a map to store character counts\\n    for(auto it:s) m[it]++; // Count the occurrence of each character in the input string\\n    int ans=0; // Initialize a variable to store the count of unique characters\\n    for(auto it:m) {\\n        ans++; // Increment the count for each unique character in the map\\n    }\\n    return ans; // Return the count of unique characters\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n     \\n    map<int,int> m; // Create a map to store character counts\\n    for(auto it:s) m[it]++; // Count the occurrence of each character in the input string\\n    int ans=0; // Initialize a variable to store the count of unique characters\\n    for(auto it:m) {\\n        ans++; // Increment the count for each unique character in the map\\n    }\\n    return ans; // Return the count of unique characters\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595056,
                "title": "groupby",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) \\n    {\\n        return s.Select(x=>x).GroupBy(x=>x).Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) \\n    {\\n        return s.Select(x=>x).GroupBy(x=>x).Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595039,
                "title": "c-easy-solution-hashmap",
                "content": "The given code is a C++ solution for the problem of finding the length of the minimized string after performing a specific operation on a given string.\\n\\nA loop is used to iterate over each character in the string s. For each character, it is inserted into the mp unordered map with a value of true. This effectively removes any duplicate characters from the map since keys in an unordered map are unique.\\n```\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n         int n = s.size();\\n        unordered_map<char, bool> mp;\\n\\n        for (int i = 0; i < n; i++) {\\n            mp[s[i]] = true;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n         int n = s.size();\\n        unordered_map<char, bool> mp;\\n\\n        for (int i = 0; i < n; i++) {\\n            mp[s[i]] = true;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3595036,
                "title": "stack-and-dict-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s):\\n        cnt = defaultdict(int)\\n        for i in s:\\n            cnt[i] += 1\\n        cnt = dict(sorted(cnt.items(), key=lambda x:x[1], reverse=True))\\n        st = []\\n        for i in s:\\n            #only append if cnt is 1. else decrease cnt \\n            if cnt[i] == 1: st.append(i)\\n            else: cnt[i] -= 1\\n        return len(st)\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s):\\n        cnt = defaultdict(int)\\n        for i in s:\\n            cnt[i] += 1\\n        cnt = dict(sorted(cnt.items(), key=lambda x:x[1], reverse=True))\\n        st = []\\n        for i in s:\\n            #only append if cnt is 1. else decrease cnt \\n            if cnt[i] == 1: st.append(i)\\n            else: cnt[i] -= 1\\n        return len(st)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595029,
                "title": "python3-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595022,
                "title": "3-line-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> st;\\n        for(auto ch:s)\\n            st.insert(ch);\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> st;\\n        for(auto ch:s)\\n            st.insert(ch);\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594991,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(string s) \\n    {\\n        set<char> st;\\n        for(auto ch: s) st.insert(ch);\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(string s) \\n    {\\n        set<char> st;\\n        for(auto ch: s) st.insert(ch);\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594974,
                "title": "short-simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<String> set = new HashSet();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i)+\"\");\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<String> set = new HashSet();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i)+\"\");\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091256,
                "title": "simple-with-unit-tests",
                "content": "## Follow Vaclav Kosar for more software and machine learning at https://vaclavkosar.com/\\n\\n\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \"\"\"\\n        Given a string `s`.\\n        Operation: select position `i` with character `c`, delete closest occurent of `c` to the left if any and right if any.\\n        Repeat Operation any number of times to minimize length of string `s`.\\n        Return length of the minimized string.\\n\\n        The operation above, allows us to deduplicate characters in the string.\\n        While removing the middle duplicates lead to faster results, because we can remove the characters in pairs.\\n\\n        >>> Solution().minimizedStringLength(\"aikadua\")\\n        5\\n\\n        # Explanation: I would select the middle \"a\" to remove. len(\"ikadu\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"aaabc\")\\n        3\\n\\n        # len(\"abc\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"cbbd\")\\n        3\\n\\n\\n        >>> Solution().minimizedStringLength(\"dddaaa\")\\n        2\\n\\n        # len(\"abc\")\\n\\n\\n        Another opportunity is ability to find the duplicate characters quickly.\\n        Perhaps one option would be to index them with for example dictionary.\\n\\n        Let me index the string into dictionary by character.\\n        Then deduplicate within that index.\\n        Then return remaining length.\\n\\n        Now to save time, I can just use set to get the right answer already and get the same result.\\n\\n        \"\"\"\\n\\n        # char_index = defaultdict(list)\\n        # for i, c in enumerate(s):\\n        #    char_index[c].append(i)\\n        # for c in char_index:\\n        #   indexes = char_index[c]\\n        #   indexes.pop(0); indexes.pop(-1)\\n        #\\n        # ...\\n\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \"\"\"\\n        Given a string `s`.\\n        Operation: select position `i` with character `c`, delete closest occurent of `c` to the left if any and right if any.\\n        Repeat Operation any number of times to minimize length of string `s`.\\n        Return length of the minimized string.\\n\\n        The operation above, allows us to deduplicate characters in the string.\\n        While removing the middle duplicates lead to faster results, because we can remove the characters in pairs.\\n\\n        >>> Solution().minimizedStringLength(\"aikadua\")\\n        5\\n\\n        # Explanation: I would select the middle \"a\" to remove. len(\"ikadu\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"aaabc\")\\n        3\\n\\n        # len(\"abc\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"cbbd\")\\n        3\\n\\n\\n        >>> Solution().minimizedStringLength(\"dddaaa\")\\n        2\\n\\n        # len(\"abc\")\\n\\n\\n        Another opportunity is ability to find the duplicate characters quickly.\\n        Perhaps one option would be to index them with for example dictionary.\\n\\n        Let me index the string into dictionary by character.\\n        Then deduplicate within that index.\\n        Then return remaining length.\\n\\n        Now to save time, I can just use set to get the right answer already and get the same result.\\n\\n        \"\"\"\\n\\n        # char_index = defaultdict(list)\\n        # for i, c in enumerate(s):\\n        #    char_index[c].append(i)\\n        # for c in char_index:\\n        #   indexes = char_index[c]\\n        #   indexes.pop(0); indexes.pop(-1)\\n        #\\n        # ...\\n\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085382,
                "title": "minimize-string-length-js-as-short-as-possible",
                "content": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s).size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s).size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082545,
                "title": "python-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        dic = {}\\n        for i in s:\\n            if i in dic:\\n                dic[i] += 1\\n            else:\\n                dic[i] = 1\\n        count = 0\\n        for i in dic:\\n            count += 1\\n        return count \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        dic = {}\\n        for i in s:\\n            if i in dic:\\n                dic[i] += 1\\n            else:\\n                dic[i] = 1\\n        count = 0\\n        for i in dic:\\n            count += 1\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081844,
                "title": "best-solution-using-hash-map-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map <char, int> mp;\\n        for(auto i : s) {\\n            mp[i]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map <char, int> mp;\\n        for(auto i : s) {\\n            mp[i]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079835,
                "title": "simple-hashtable-as-boolean-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] lowers = new boolean[\\'z\\' - \\'a\\' + 1];\\n        int size = 0;\\n\\n        for(int i = 0; i < s.length(); i ++) {\\n            char ch = s.charAt(i);\\n\\n            if(!lowers[ch - \\'a\\']) {\\n                size ++;\\n                lowers[ch - \\'a\\'] = true;\\n            }\\n        }\\n\\n\\n        return size;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] lowers = new boolean[\\'z\\' - \\'a\\' + 1];\\n        int size = 0;\\n\\n        for(int i = 0; i < s.length(); i ++) {\\n            char ch = s.charAt(i);\\n\\n            if(!lowers[ch - \\'a\\']) {\\n                size ++;\\n                lowers[ch - \\'a\\'] = true;\\n            }\\n        }\\n\\n\\n        return size;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077975,
                "title": "python-one-line-solution-easy-solution",
                "content": "# Intuition\\nuse set: it store only non repeted values and then return the length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076864,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[27];\\n        for (char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i : arr) {\\n            if (i > 0) {\\n                arr[26]++;\\n            }\\n        }\\n        return --arr[26];        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[27];\\n        for (char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i : arr) {\\n            if (i > 0) {\\n                arr[26]++;\\n            }\\n        }\\n        return --arr[26];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073422,
                "title": "c-straightforward-approach-with-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            for (int j = i + 1; j < s.Length;)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    s = s.Remove(j, 1);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        return s.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            for (int j = i + 1; j < s.Length;)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    s = s.Remove(j, 1);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        return s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072370,
                "title": "return-size-of-hashmap",
                "content": "# Intuition\\nthere will be only 1 key for repeated chars, so return len of keys.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashMap<Character,Integer> mapple = new HashMap<>();\\n        for (int i = 0; i <s.length(); i++) {\\n            mapple.put(s.charAt(i),1);\\n        }\\n        return mapple.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashMap<Character,Integer> mapple = new HashMap<>();\\n        for (int i = 0; i <s.length(); i++) {\\n            mapple.put(s.charAt(i),1);\\n        }\\n        return mapple.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069635,
                "title": "simple-c-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nusign map STL\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069478,
                "title": "2716-minimize-string-length-easy-simple-solutions",
                "content": "# Code\\n```Python []\\n\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        # Using built-in function: `return len(set(s))`\\n        res = \"\"\\n        for i in s:\\n            if i not in res:\\n                res += i\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python []\\n\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        # Using built-in function: `return len(set(s))`\\n        res = \"\"\\n        for i in s:\\n            if i not in res:\\n                res += i\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068678,
                "title": "4-line-code",
                "content": "# Intuition\\nuse a HashSet to prevent the entry of duplicates and return the size of the HashSet\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> len=new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n            len.add(s.charAt(i));\\n        return len.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> len=new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n            len.add(s.charAt(i));\\n        return len.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068238,
                "title": "simple-and-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean visit[] = new boolean[26];\\n        int ans =0;\\n        for(char c:s.toCharArray()){\\n            if(!visit[c-\\'a\\']){\\n                ans++;\\n                visit[c-\\'a\\'] =true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean visit[] = new boolean[26];\\n        int ans =0;\\n        for(char c:s.toCharArray()){\\n            if(!visit[c-\\'a\\']){\\n                ans++;\\n                visit[c-\\'a\\'] =true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066711,
                "title": "using-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(s) {\\n    var obj={};\\n    for(var i=0;i<s.length;i++)\\n    {\\n        if(obj[s[i]]==undefined)\\n        {\\n           obj[s[i]]=1;\\n        }\\n        else\\n        {\\n            obj[s[i]]++;\\n        }\\n    }\\n    var ky=Object.keys(obj);\\n    return ky.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(s) {\\n    var obj={};\\n    for(var i=0;i<s.length;i++)\\n    {\\n        if(obj[s[i]]==undefined)\\n        {\\n           obj[s[i]]=1;\\n        }\\n        else\\n        {\\n            obj[s[i]]++;\\n        }\\n    }\\n    var ky=Object.keys(obj);\\n    return ky.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062189,
                "title": "one-line-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051607,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n        int count = 0;\\n       //To store repeated character at one place\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n       //To count same char only once \\n          for(int i=0;i<26;i++){\\n              if(arr[i] > 0)\\n              count++;\\n          }\\n          return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n        int count = 0;\\n       //To store repeated character at one place\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n       //To count same char only once \\n          for(int i=0;i<26;i++){\\n              if(arr[i] > 0)\\n              count++;\\n          }\\n          return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049269,
                "title": "one-line-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimplest way is to make a set out of string \\'s\\' in order to find all unique elements from the string and return its length\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049001,
                "title": "very-easy-to-understand-beats-100-java",
                "content": "\\n# Here\\'s how the code works:\\n\\n1. It initializes a variable ```count``` to 0, which will be used to count the unique letters.\\n2. It creates a ```boolean array flag``` with 26 elements, representing the 26 lowercase letters of the English alphabet. Each element is initially set to ```false```.\\n3. It then iterates over the characters in the input string s.\\nFor each character c in the string, it calculates its position in the array flag by subtracting \\'a\\' from it. This effectively maps ```\\'a\\'``` to ```index 0```, ```\\'b\\'``` to ```index 1```, and so on.\\n4. It sets the corresponding element in the flag array to true to indicate that the letter has been encountered.\\n5. After processing all characters in the input ```string```, it iterates over the ```flag array``` to count how many letters have been marked as ```true```.\\n6. The count of unique letters is stored in the ```count``` variable, which is then returned as the result.\\nIn the end, this code returns the count of unique lowercase letters in the input ```string s```. A simple and efficient way to achieve this task.\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count=0;\\n        boolean[] flag=new boolean[26];\\n        for(int i=0;i<s.length();i++){\\n            flag[s.charAt(i)-\\'a\\'] = true;\\n        }\\n        for(int i=0;i<flag.length;i++){\\n            if(flag[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```count```\n```boolean array flag```\n```false```\n```\\'a\\'```\n```index 0```\n```\\'b\\'```\n```index 1```\n```string```\n```flag array```\n```true```\n```count```\n```string s```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count=0;\\n        boolean[] flag=new boolean[26];\\n        for(int i=0;i<s.length();i++){\\n            flag[s.charAt(i)-\\'a\\'] = true;\\n        }\\n        for(int i=0;i<flag.length;i++){\\n            if(flag[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048360,
                "title": "java-solution-beats-86-85",
                "content": "\\n# Approach\\n1) Every character must occur minimum times.\\n2) The least no of times that a character occurs has to be 1.\\n3) Let\\'s make a string str of characters from \\'a\\' to \\'z\\'.\\n4) Check if each separate character in str is present in s.\\n5) The count of the string will start to minimise because only individual characters will be counted i.e only once.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s)\\n    {\\n        String str=\"abcdefghijklmnopqrstuvwxyz\";\\n        int min_len=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(s.indexOf(str.charAt(i))!=-1)\\n               min_len++;\\n        }\\n       return min_len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s)\\n    {\\n        String str=\"abcdefghijklmnopqrstuvwxyz\";\\n        int min_len=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(s.indexOf(str.charAt(i))!=-1)\\n               min_len++;\\n        }\\n       return min_len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044087,
                "title": "easy-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Hashset\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<String> h1 = new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            h1.add(s.substring(i,i+1));\\n        }\\n        System.out.println(\"h1 is \"+h1);\\n        return h1.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<String> h1 = new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            h1.add(s.substring(i,i+1));\\n        }\\n        System.out.println(\"h1 is \"+h1);\\n        return h1.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043328,
                "title": "100-runtime-beats-99-40-memory-beats-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int arr[]=new int[26];\\n        int count=0;\\n        for(char c : s.toCharArray()){\\n            arr[c-\\'a\\']++;\\n        }\\n        for(int n:arr){\\n            if(n!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int arr[]=new int[26];\\n        int count=0;\\n        for(char c : s.toCharArray()){\\n            arr[c-\\'a\\']++;\\n        }\\n        for(int n:arr){\\n            if(n!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042765,
                "title": "python-1-line-solution-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040820,
                "title": "c-o-1-memory-complexity",
                "content": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        sort(s.begin(),s.end());\\n        int cnt=1;\\n        \\n        for(int i=1;i<s.size();i++){\\n            \\n            if(s[i]!=s[i-1]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        sort(s.begin(),s.end());\\n        int cnt=1;\\n        \\n        for(int i=1;i<s.size();i++){\\n            \\n            if(s[i]!=s[i-1]){\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4040329,
                "title": "python-beat-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n      res = 0\\n      st = set(s)\\n      for i in st:\\n        res += 1\\n      return res\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n      res = 0\\n      st = set(s)\\n      for i in st:\\n        res += 1\\n      return res\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036551,
                "title": "c-easy-and-readable-solution-faster-than-62",
                "content": "![image.png](https://assets.leetcode.com/users/images/02707d73-80c2-425c-814c-d8783e5284d5_1694538701.2099478.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        Dictionary<char, int> dc = new ();\\n        for (int i = 0; i < s.Length; i++)\\n            if (!dc.ContainsKey(s[i]))\\n                dc.Add(s[i], 1);\\n            else\\n                dc[s[i]]++;\\n        return dc.Count;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        Dictionary<char, int> dc = new ();\\n        for (int i = 0; i < s.Length; i++)\\n            if (!dc.ContainsKey(s[i]))\\n                dc.Add(s[i], 1);\\n            else\\n                dc[s[i]]++;\\n        return dc.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031544,
                "title": "easiest-solution-o-n-beat-90",
                "content": "\\n# Complexity\\n- Time complexity:\\n ```\\nO(N)\\n```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        if(s.length()==1)\\n        return 1;\\n         string str;\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(str.length()>0)\\n            { if(s[i]==str[str.length()-1])\\n            {\\n                continue;\\n            }\\n            else\\n            { str+=s[i];\\n\\n            }\\n\\n            }\\n            else\\n            {\\n                str+=s[i];\\n            }\\n        }\\n        return str.length();\\n    }\\n};\\n```\\n\\nhope you found it useful....btw i didnt get leetcode submit algorithm \\uD83D\\uDE05...when i submit first time this code beats 98% takes only 8ms hahaha",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(N)\\n```\n```\\nO(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        if(s.length()==1)\\n        return 1;\\n         string str;\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(str.length()>0)\\n            { if(s[i]==str[str.length()-1])\\n            {\\n                continue;\\n            }\\n            else\\n            { str+=s[i];\\n\\n            }\\n\\n            }\\n            else\\n            {\\n                str+=s[i];\\n            }\\n        }\\n        return str.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025324,
                "title": "one-line-code-with-no-extra-space-and-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)** ---> Set can be Constructed of Size(26) Worst Case Possible. So it is Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022345,
                "title": "easy-to-understand-python-solution-1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016358,
                "title": "elixir-mapset-rust-hashset-solutions",
                "content": "### Elixir\\n\\n```\\ndefmodule Solution do\\n  @spec minimized_string_length(s :: String.t()) :: integer\\n  def minimized_string_length(s) do\\n    s |> String.graphemes() |> MapSet.new() |> MapSet.size()\\n  end\\nend\\n\\n```\\n\\n### Rust\\n\\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let st: HashSet<u8> = HashSet::from_iter(s.bytes().into_iter());\\n        st.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec minimized_string_length(s :: String.t()) :: integer\\n  def minimized_string_length(s) do\\n    s |> String.graphemes() |> MapSet.new() |> MapSet.size()\\n  end\\nend\\n\\n```\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let st: HashSet<u8> = HashSet::from_iter(s.bytes().into_iter());\\n        st.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4015125,
                "title": "accepted-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014349,
                "title": "javascript-1-liner",
                "content": "# Code\\n```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s.split(\\'\\')).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s.split(\\'\\')).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013784,
                "title": "beats-100-in-time-space",
                "content": "# Approach - Use int array and store as 1 for the character is present\\n\\nThen calculate the total by iterating over the loop\\nThis beats the Set and HashMap solution flat out doubled the time\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] alpha = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            alpha[s.charAt(i)-\\'a\\'] = 1;\\n        }\\n        int total = 0;\\n        for(int num:alpha){\\n            total+=num;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] alpha = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            alpha[s.charAt(i)-\\'a\\'] = 1;\\n        }\\n        int total = 0;\\n        for(int num:alpha){\\n            total+=num;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013281,
                "title": "simple-c-program-answer",
                "content": "# Intuition\\nSOLUTION IN C PROGRAM .\\n\\n# Approach\\nBY SORTING THE CHARACTER INSIDE THE STRING AND COUNTING THE INDIVIUAL CHARACTER \\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n\\n   int length = strlen(s); \\n   int count = 0;\\n   \\n   char temp;\\n   for(int i=0;i<length;i++){\\n       for(int j=i+1;j<length;j++){\\n           if(s[i] > s[j]){\\n               temp = s[i];\\n               s[i] = s[j];\\n               s[j] = temp;\\n           } \\n       }\\n   }\\n\\n   for(int i=1; i<length; i++){\\n       if(s[i] != s[count]){\\n           count++;\\n           s[count] = s[i];\\n       }\\n   }\\n\\n   return count + 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n\\n   int length = strlen(s); \\n   int count = 0;\\n   \\n   char temp;\\n   for(int i=0;i<length;i++){\\n       for(int j=i+1;j<length;j++){\\n           if(s[i] > s[j]){\\n               temp = s[i];\\n               s[i] = s[j];\\n               s[j] = temp;\\n           } \\n       }\\n   }\\n\\n   for(int i=1; i<length; i++){\\n       if(s[i] != s[count]){\\n           count++;\\n           s[count] = s[i];\\n       }\\n   }\\n\\n   return count + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010143,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean alphabets[] = new boolean[26];\\n        int ans = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(!alphabets[c - \\'a\\']){\\n                ans++;\\n                alphabets[c - \\'a\\'] = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean alphabets[] = new boolean[26];\\n        int ans = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(!alphabets[c - \\'a\\']){\\n                ans++;\\n                alphabets[c - \\'a\\'] = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009932,
                "title": "2lines-code-easy-code-java-string",
                "content": "\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (ch[i] != ch[i + 1]) {\\n                count++;\\n            }\\n        }\\n        // Increment count for the last unique character\\n        count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (ch[i] != ch[i + 1]) {\\n                count++;\\n            }\\n        }\\n        // Increment count for the last unique character\\n        count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005654,
                "title": "o-n-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnce you have analysed, the goal is to find the unique elements in the string\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Using a set, try to insert all the elements in the set\\n2. Return the size of the set\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set <char> ans;\\n        for(auto x : s) {\\n            ans.insert(x);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set <char> ans;\\n        for(auto x : s) {\\n            ans.insert(x);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002535,
                "title": "two-types-of-code-array-and-string-method-both",
                "content": "\\n```\\nfunction minimizedStringLength(s: string): number {\\n    //  let strArr = [...s];\\n    // let count = 0;\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     for (let j = i + 1; j < strArr.length; j++) {\\n    //         if (strArr[i] === strArr[j]) {\\n    //             strArr[j] = \".\";\\n    //         }\\n    //     }\\n    // }\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     if (strArr[i] != \".\") {\\n    //         count++;\\n    //     }\\n    // }\\n\\n    // return count;\\n\\n     let str = \"\";\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (!str.includes(s[i])) {\\n            str += s[i];\\n        }\\n    }\\n\\n    return str.length;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction minimizedStringLength(s: string): number {\\n    //  let strArr = [...s];\\n    // let count = 0;\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     for (let j = i + 1; j < strArr.length; j++) {\\n    //         if (strArr[i] === strArr[j]) {\\n    //             strArr[j] = \".\";\\n    //         }\\n    //     }\\n    // }\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     if (strArr[i] != \".\") {\\n    //         count++;\\n    //     }\\n    // }\\n\\n    // return count;\\n\\n     let str = \"\";\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (!str.includes(s[i])) {\\n            str += s[i];\\n        }\\n    }\\n\\n    return str.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001122,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\nclass Solution {\\n    public:\\n    int minimizedStringLength(string s) {\\n        int n=s.size();\\n        for (int i=0;i<n;){\\n            char ch=s[i];\\n            int j=i+1;\\n            while(j<n){\\n                if (s[j]==ch){\\n                    s.erase(j,1);\\n                    n--;\\n                }\\n                else j++;\\n            }\\n            i++;\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\nclass Solution {\\n    public:\\n    int minimizedStringLength(string s) {\\n        int n=s.size();\\n        for (int i=0;i<n;){\\n            char ch=s[i];\\n            int j=i+1;\\n            while(j<n){\\n                if (s[j]==ch){\\n                    s.erase(j,1);\\n                    n--;\\n                }\\n                else j++;\\n            }\\n            i++;\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3992806,
                "title": "trick-solution-easy-solution-using-set-4-line-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought was breaking the solution but it seemed too much work so I tried reading the question again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter reading it again I suspected a trick solution might work.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> res = new HashSet<>();\\n        for(char c : s.toCharArray())\\n            res.add(c);\\n        return res.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> res = new HashSet<>();\\n        for(char c : s.toCharArray())\\n            res.add(c);\\n        return res.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992235,
                "title": "minimize-string-length",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    We just have to return the number of unique character in String\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(k) where k is the number of unique element. \\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Map<Character,Integer> map = new HashMap<>(); \\n        \\n        int ans = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            if(map.containsKey(ch)) continue;\\n            else{\\n                map.put(ch,1);\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Map<Character,Integer> map = new HashMap<>(); \\n        \\n        int ans = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            if(map.containsKey(ch)) continue;\\n            else{\\n                map.put(ch,1);\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988060,
                "title": "c-2-line-easy-solution",
                "content": "# C++ | 2 Line | easy solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        sort(s.begin(),s.end());\\n        s.erase(unique(s.begin(),s.end()),s.end());\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        sort(s.begin(),s.end());\\n        s.erase(unique(s.begin(),s.end()),s.end());\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985282,
                "title": "typescript-solution",
                "content": "```\\nfunction minimizedStringLength(s: string): number {\\n    const chars: string[] = [...new Set(s.split(\\'\\'))];\\n    return chars.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minimizedStringLength(s: string): number {\\n    const chars: string[] = [...new Set(s.split(\\'\\'))];\\n    return chars.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983548,
                "title": "solution-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFist I was thinking that I will leave string \"absba\"\\nBut after carfully reading the task I understod that I neeed only distince letters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981569,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>h=new HashSet();\\n        for(int i=0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n        return h.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>h=new HashSet();\\n        for(int i=0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n        return h.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980359,
                "title": "best-explained-and-easiest-solution",
                "content": "# Intuition\\nBasicaly the question is to return the size of substring in a given string which has no duplicate characters,so if you think about it the easiest way to solve this problem is to use set data structure,because set doesnt contain duplicates.\\n\\n# Approach\\n-Traverse through the string and insert every character to set.\\n-In the end return the size of a set.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    set<char>st;\\n    for(char c:s){\\n      st.insert(c);\\n    }    \\n    return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    set<char>st;\\n    for(char c:s){\\n      st.insert(c);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3979931,
                "title": "python-one-line-solution",
                "content": "The only challenge here was to not misinterpret the description and sample cases\\n\\nthe final string will contain no duplicates\\n# Solution\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978878,
                "title": "simple-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(String.valueOf(s.charAt(i)));\\n        }\\n        return set.size();\\n\\n\\n        // StringBuilder sb = new StringBuilder(s);\\n        // for(int i=0; i<sb.length()-1; i++){\\n        //     for(int j=0; j<sb.length()-1; j++){\\n        //         if(sb.charAt(j)==sb.charAt(j+1)){\\n        //             sb.deleteCharAt(j);\\n        //         }\\n        //     }\\n        // }\\n        // String str = sb.toString();\\n        // return str.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(String.valueOf(s.charAt(i)));\\n        }\\n        return set.size();\\n\\n\\n        // StringBuilder sb = new StringBuilder(s);\\n        // for(int i=0; i<sb.length()-1; i++){\\n        //     for(int j=0; j<sb.length()-1; j++){\\n        //         if(sb.charAt(j)==sb.charAt(j+1)){\\n        //             sb.deleteCharAt(j);\\n        //         }\\n        //     }\\n        // }\\n        // String str = sb.toString();\\n        // return str.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978609,
                "title": "go-beats-100",
                "content": "# Intuition\\nf the input string contains only lowercase English letters, you can use an array of size 26 to count the frequency of each letter in the string\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc minimizedStringLength(s string) int {\\n    freq := [26]int{}\\n\\n    for _, c := range s {\\n        freq[c-\\'a\\']++\\n    }\\n\\n    count := 0\\n    for _, f := range freq {\\n        if f > 0 {\\n            count++\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimizedStringLength(s string) int {\\n    freq := [26]int{}\\n\\n    for _, c := range s {\\n        freq[c-\\'a\\']++\\n    }\\n\\n    count := 0\\n    for _, f := range freq {\\n        if f > 0 {\\n            count++\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973020,
                "title": "easy-java-solution-by-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> h = new HashSet<>();\\n        for(int i =0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n\\n    return h.size();}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> h = new HashSet<>();\\n        for(int i =0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n\\n    return h.size();}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972899,
                "title": "solution-with-constant-time-and-memory",
                "content": "\\n# Approach\\nWe need the number of the unique characters. If a character appears\\nmore than 1 time, it can be reduced to 1 apparition. Instead of \\nusing set or map (which occupies a lot memory), use a 26 sized-array(\\nwe are working with small letters) like a map of <int, int> or like a set.\\n![image.png](https://assets.leetcode.com/users/images/e8fc8a39-f97c-4101-9999-1b3d6a3a387c_1693244183.0110075.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //s contains only lowercase English letters\\n        int arr[26] = {0};\\n        for (auto c : s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n        int nr = 0;\\n        for (int c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            if (arr [c - \\'a\\'] >= 1)\\n            {\\n                nr ++;\\n            }\\n        }\\n        return nr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //s contains only lowercase English letters\\n        int arr[26] = {0};\\n        for (auto c : s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n        int nr = 0;\\n        for (int c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            if (arr [c - \\'a\\'] >= 1)\\n            {\\n                nr ++;\\n            }\\n        }\\n        return nr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972775,
                "title": "hash-map-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> mp;\\n\\n        for (int i=0;i<s.size();i++) {\\n            mp[s[i]]++;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> mp;\\n\\n        for (int i=0;i<s.size();i++) {\\n            mp[s[i]]++;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955894,
                "title": "ruby-one-line-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {String} s\\n# @return {Integer}\\ndef minimized_string_length(s)\\n    return s.split(\"\").tally.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {Integer}\\ndef minimized_string_length(s)\\n    return s.split(\"\").tally.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3951560,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951308,
                "title": "c-bits-manipulation-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int mask = 0;\\n        for(char &ele:s){\\n            mask |= (1<<(ele-\\'a\\'));\\n        }\\n        int res = 0;\\n        while(mask){\\n            res += (mask&1);\\n            mask = mask>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int mask = 0;\\n        for(char &ele:s){\\n            mask |= (1<<(ele-\\'a\\'));\\n        }\\n        int res = 0;\\n        while(mask){\\n            res += (mask&1);\\n            mask = mask>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949226,
                "title": "minimize-string-length-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i =0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i =0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946369,
                "title": "js-hashmap-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(arr) {\\n    let map = new Map();\\n\\n\\n    for(let i=0; i<arr.length; i++){\\n        if(!map.has(arr[i])) map.set(arr[i], 1)\\n    }\\n\\n    return map.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(arr) {\\n    let map = new Map();\\n\\n\\n    for(let i=0; i<arr.length; i++){\\n        if(!map.has(arr[i])) map.set(arr[i], 1)\\n    }\\n\\n    return map.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943656,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(NLogN)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int j = 0;\\n        int resultCount = 1;\\n        char[] tmp = s.toCharArray();\\n\\n        Arrays.sort(tmp);\\n\\n        for (int i = 1; i < tmp.length; i++) {\\n            if (tmp[i] != tmp[j]) {\\n                resultCount++;\\n                j = i;\\n            }\\n        }\\n\\n        return resultCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int j = 0;\\n        int resultCount = 1;\\n        char[] tmp = s.toCharArray();\\n\\n        Arrays.sort(tmp);\\n\\n        for (int i = 1; i < tmp.length; i++) {\\n            if (tmp[i] != tmp[j]) {\\n                resultCount++;\\n                j = i;\\n            }\\n        }\\n\\n        return resultCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942288,
                "title": "easy-code-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string temp=\"\";\\n        sort(s.begin(),s.end());\\n        temp.push_back(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(temp.back()!=s[i])\\n            {\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string temp=\"\";\\n        sort(s.begin(),s.end());\\n        temp.push_back(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(temp.back()!=s[i])\\n            {\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941177,
                "title": "simple-solution-4-lines-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> sb = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            sb.add(c);\\n        }\\n        return sb.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> sb = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            sb.add(c);\\n        }\\n        return sb.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939092,
                "title": "clean-golang-solution",
                "content": "# Code\\n```\\nfunc minimizedStringLength(s string) int {\\n    set := make(map[rune]struct{},0)\\n    for _,v := range s {\\n        set[v] = struct{}{}\\n    }\\n    return len(set)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimizedStringLength(s string) int {\\n    set := make(map[rune]struct{},0)\\n    for _,v := range s {\\n        set[v] = struct{}{}\\n    }\\n    return len(set)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937649,
                "title": "2716-minimize-string-length-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(N);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //taking the int variables i,j \\n        int i=0,j=0;\\n        //taking the one string variable\\n        string st=\"\";\\n        //using the sort method to sort the string \\n        sort(s.begin(), s.end());\\n        while(i<s.length()){\\n            st+=s[i];\\n            if(s[i]==s[i+1]){\\n                st.pop_back();\\n            }\\n            else{\\n                j++;\\n                st+=s[i];\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //taking the int variables i,j \\n        int i=0,j=0;\\n        //taking the one string variable\\n        string st=\"\";\\n        //using the sort method to sort the string \\n        sort(s.begin(), s.end());\\n        while(i<s.length()){\\n            st+=s[i];\\n            if(s[i]==s[i+1]){\\n                st.pop_back();\\n            }\\n            else{\\n                j++;\\n                st+=s[i];\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3932732,
                "title": "easy-solution-2-lines-using-set",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n       return st.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n       return st.size();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931847,
                "title": "one-word-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928205,
                "title": "easy-to-understand-c-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926241,
                "title": "simple-java-solution-single-loop",
                "content": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder r = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (r.indexOf(String.valueOf(c)) == -1) {\\n                r.append(c);\\n            }\\n        }\\n        return r.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder r = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (r.indexOf(String.valueOf(c)) == -1) {\\n                r.append(c);\\n            }\\n        }\\n        return r.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925031,
                "title": "easy-python-solution-for-minimize-the-string-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = \\'\\'\\n        for i in s:\\n            if i not in res:\\n                res += i\\n            else:\\n                pass\\n        return len(res)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = \\'\\'\\n        for i in s:\\n            if i not in res:\\n                res += i\\n            else:\\n                pass\\n        return len(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923048,
                "title": "short-and-easy-solution-using-set-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nintuition is simple to take unique elements from strings\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso i think about set as it stors only unique elements\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC is O(N)\\n\\n- Space complexity:\\n- O(N) as we took set  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto c:s)\\n        {\\n            st.insert(c);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto c:s)\\n        {\\n            st.insert(c);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921937,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) \\n        {\\n            if (sb.indexOf(String.valueOf(c)) == -1) \\n            {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.length();\\n         }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) \\n        {\\n            if (sb.indexOf(String.valueOf(c)) == -1) \\n            {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.length();\\n         }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921726,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(const string& s)\\n    {\\n        int freq[26] = {0};\\n        for (char c : s)\\n        {\\n            freq[c - \\'a\\']++;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (freq[i] > 0)\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(const string& s)\\n    {\\n        int freq[26] = {0};\\n        for (char c : s)\\n        {\\n            freq[c - \\'a\\']++;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (freq[i] > 0)\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921046,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        int[] arr = new int[26];\\n        for(char c:s.toCharArray()){\\n            if(arr[c - \\'a\\'] == 0){\\n                count++;\\n                arr[c - \\'a\\'] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        int[] arr = new int[26];\\n        for(char c:s.toCharArray()){\\n            if(arr[c - \\'a\\'] == 0){\\n                count++;\\n                arr[c - \\'a\\'] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919817,
                "title": "just-count-the-unique-characters-o-n-beats-100",
                "content": "# intuition\\nfor any character having more than one occurence, it can be deleted from left or right of chosen pivot character.\\nonly the pivot character can\\'t be deleted.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] distincts = new boolean[26];\\n        for(char ch: s.toCharArray()) {\\n            distincts[ch-97] = true;\\n        }\\n        int sum = 0;\\n        for(boolean b: distincts) {\\n            sum += b?1:0;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] distincts = new boolean[26];\\n        for(char ch: s.toCharArray()) {\\n            distincts[ch-97] = true;\\n        }\\n        int sum = 0;\\n        for(boolean b: distincts) {\\n            sum += b?1:0;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917891,
                "title": "dart-solution-in-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minimizedStringLength(String s) {\\n      return s.split(\\'\\').toSet().length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minimizedStringLength(String s) {\\n      return s.split(\\'\\').toSet().length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917314,
                "title": "go-simple-solution",
                "content": "# Code\\n```go\\nfunc minimizedStringLength(s string) (l int) {\\n    // recommended slices more than map which is slower\\n    v := make([]bool, 26)\\n    for _, b := range s {\\n        if v[b-\\'a\\'] {\\n            continue\\n        }\\n        v[b-\\'a\\'] = true \\n        l++\\n    }\\n    return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimizedStringLength(s string) (l int) {\\n    // recommended slices more than map which is slower\\n    v := make([]bool, 26)\\n    for _, b := range s {\\n        if v[b-\\'a\\'] {\\n            continue\\n        }\\n        v[b-\\'a\\'] = true \\n        l++\\n    }\\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916820,
                "title": "easy-understanding",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(m) where m isthe unique charecters in the string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int count = 0;\\n        char ch = s[0];\\n        int n = s.size();\\n        unordered_map<int, int> umap;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(umap.find(s[i]) != umap.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                umap[s[i]]++;\\n            }\\n        }\\n        return umap.size();\\n        // for(int i=1;i<n;i++)\\n        // {\\n        //     if(s[i] == ch)\\n        //     {\\n        //         continue;\\n        //     }\\n        //     else\\n        //     {\\n        //         count++;\\n        //         ch = s[i];\\n        //     }\\n        // }\\n        // return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int count = 0;\\n        char ch = s[0];\\n        int n = s.size();\\n        unordered_map<int, int> umap;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(umap.find(s[i]) != umap.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                umap[s[i]]++;\\n            }\\n        }\\n        return umap.size();\\n        // for(int i=1;i<n;i++)\\n        // {\\n        //     if(s[i] == ch)\\n        //     {\\n        //         continue;\\n        //     }\\n        //     else\\n        //     {\\n        //         count++;\\n        //         ch = s[i];\\n        //     }\\n        // }\\n        // return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916506,
                "title": "96-with-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<int> arr(26,0);\\n        int ans=0;\\n        for(auto i:s){\\n            arr[i-\\'a\\']++;\\n            if(arr[i-\\'a\\']==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<int> arr(26,0);\\n        int ans=0;\\n        for(auto i:s){\\n            arr[i-\\'a\\']++;\\n            if(arr[i-\\'a\\']==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916035,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] table = new boolean[26];\\n        int count = 0;\\n\\n        for(char c : s.toCharArray())\\n           table[c -\\'a\\'] = true;\\n        \\n        for(int i = 0; i < 26; i++)\\n           if(table[i]) count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] table = new boolean[26];\\n        int count = 0;\\n\\n        for(char c : s.toCharArray())\\n           table[c -\\'a\\'] = true;\\n        \\n        for(int i = 0; i < 26; i++)\\n           if(table[i]) count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914310,
                "title": "easy-solution-using-set-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910404,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just removing the duplicate here.\\nSo just remove the duplicate string elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        List<Character> list=new ArrayList<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(!list.contains(s.charAt(i)))\\n            {\\n                list.add(s.charAt(i));\\n            }\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        List<Character> list=new ArrayList<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(!list.contains(s.charAt(i)))\\n            {\\n                list.add(s.charAt(i));\\n            }\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907841,
                "title": "using-map-in-c-very-easy-solution",
                "content": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        //Time and space com = O(n);\\n        unordered_map<char,int> mp;\\n        for(char ch : s)\\n        {\\n            mp[ch]++;\\n        }\\n        \\n        return mp.size();\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        //Time and space com = O(n);\\n        unordered_map<char,int> mp;\\n        for(char ch : s)\\n        {\\n            mp[ch]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3902678,
                "title": "o-n-simple-solution-using-mapping-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust use pigeonhole sort principle\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n    int arr[26] = {0};\\n    for(int i = 0;i < strlen(s);i++){\\n        arr[s[i] - \\'a\\']++;\\n    }\\n    int p = 0;\\n    for(int i = 0;i < 26;i++){\\n        if(arr[i] > 0){\\n            p++;\\n        }\\n    }\\n    return(p);\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n    int arr[26] = {0};\\n    for(int i = 0;i < strlen(s);i++){\\n        arr[s[i] - \\'a\\']++;\\n    }\\n    int p = 0;\\n    for(int i = 0;i < 26;i++){\\n        if(arr[i] > 0){\\n            p++;\\n        }\\n    }\\n    return(p);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901474,
                "title": "simple-approach-is-using-set",
                "content": "\\n# Approach\\nSince any characher from left or right has to be deleted\\nTherefore any dublicate will be removed in the end.\\nso, the question boils down to count of unique elements.\\n\\n\\n\\n# Code\\n```\\n    int minimizedStringLength(string s) {\\n        set<char>se;\\n        for(char ch:s)se.insert(ch);\\n        return se.size();\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minimizedStringLength(string s) {\\n        set<char>se;\\n        for(char ch:s)se.insert(ch);\\n        return se.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3898481,
                "title": "one-line-solution-with-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function (s) {\\n\\n    // remove same character from string s using Set() and convert into string from array using join() and find length of string using .length property and return it\\n    return [...new Set([...s])].join(\\'\\').length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function (s) {\\n\\n    // remove same character from string s using Set() and convert into string from array using join() and find length of string using .length property and return it\\n    return [...new Set([...s])].join(\\'\\').length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895120,
                "title": "very-easy-to-understand-just-go-and-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ntraverse every character of set and add it to hashset; lastly return set size;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> A = new HashSet<>();\\n        for(int i =0;i<s.length(); i++){\\n            if(!A.contains(s.charAt(i))){\\n                A.add(s.charAt(i));\\n            }\\n        }\\n        return A.size();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> A = new HashSet<>();\\n        for(int i =0;i<s.length(); i++){\\n            if(!A.contains(s.charAt(i))){\\n                A.add(s.charAt(i));\\n            }\\n        }\\n        return A.size();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894988,
                "title": "python3-and-python-100-simple-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = [i for i in set(s)]\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = [i for i in set(s)]\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894144,
                "title": "beginner-friendly-hashset-sol",
                "content": "# Intuition\\nThe answer string consist of only distinct characters\\n\\n# Approach\\nHashSet\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for(char c : s.toCharArray()) {\\n            if(!set.add(c)) continue;\\n            else set.add(c);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```\\n\\nPLEASE UPVOTE(if you\\'re not gay)",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for(char c : s.toCharArray()) {\\n            if(!set.add(c)) continue;\\n            else set.add(c);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893003,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    int i = 1;\\n    while (i < s.length()) {\\n        cout << s << endl;\\n        \\n        int left = i - 1;\\n        while (left >= 0 && s[left] != s[i]) {\\n            left--;\\n        }\\n        if (left >= 0) {\\n            s.erase(left, 1);\\n            i--;\\n        }\\n\\n        int right = i + 1;\\n        while (right < s.length() && s[right] != s[i]) {\\n            right++;\\n        }\\n        if (right < s.length()) {\\n            s.erase(right, 1);\\n        }\\n\\n        i++;\\n    }\\n    return s.length();\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    int i = 1;\\n    while (i < s.length()) {\\n        cout << s << endl;\\n        \\n        int left = i - 1;\\n        while (left >= 0 && s[left] != s[i]) {\\n            left--;\\n        }\\n        if (left >= 0) {\\n            s.erase(left, 1);\\n            i--;\\n        }\\n\\n        int right = i + 1;\\n        while (right < s.length() && s[right] != s[i]) {\\n            right++;\\n        }\\n        if (right < s.length()) {\\n            s.erase(right, 1);\\n        }\\n\\n        i++;\\n    }\\n    return s.length();\\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3881800,
                "title": "3-lines-solution-incl-return-statement",
                "content": "# Intuition\\nRead between the lines. No need to search for similar chars inside of a string. All you are asked for is a count of unique chars.\\n\\n# Approach\\n- sort it\\n- remove duplicates\\n\\nerase(unique) idiom works just fine\\n\\n# Complexity\\n- Time complexity:\\n$$O(NlogN)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        std::sort(s.begin(), s.end());\\n        s.erase(std::unique(s.begin(), s.end()), s.end() );\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        std::sort(s.begin(), s.end());\\n        s.erase(std::unique(s.begin(), s.end()), s.end() );\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879996,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> mp;\\n\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> mp;\\n\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873211,
                "title": "in-1-line",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        s = set(s)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        s = set(s)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872551,
                "title": "two-line-code-using-counter-function-runtime-45ms-beat-98-in-runtime",
                "content": "# Intuition\\n-> count the number of distinct character in string and return that count\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n->count the occurances of characters in string using counter function and return the number of distinct keys using len and keys function\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        c=Counter(s)\\n        return len(c.keys())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        c=Counter(s)\\n        return len(c.keys())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864868,
                "title": "python-one-liner-faster-than",
                "content": "# Intuition\\nThis problem is nothing more than a roundabout way of counting the number of unique characters in a string.  There are a number of ways to do this.\\n\\n# Approach\\nMy approach focuses on a \"real-world\" solution to this, which means convenient for the author.  For that reason, this solution is a one-liner.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**: We iterate through a string of length `n` once, performing constant time operations each iteration.  This solution beat 98.55% submissions.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**: We store potentially `n` characters in a set.  While one might be tempted to say this is O(1) space as the constraints specify the input characters are lowercase English letters, the proper abstraction applies to any range of character inputs.  This solution beat 70.97% of submissions.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        #this is literally just returning the number of unique characters\\n        return len({i for i in s})\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        #this is literally just returning the number of unique characters\\n        return len({i for i in s})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862849,
                "title": "easy-to-understand-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let mut unique: HashSet<char> = HashSet::new();\\n    \\n        for char in s.chars() {\\n            unique.insert(char);\\n        }\\n\\n        unique.len() as i32 //.try_into().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let mut unique: HashSet<char> = HashSet::new();\\n    \\n        for char in s.chars() {\\n            unique.insert(char);\\n        }\\n\\n        unique.len() as i32 //.try_into().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859841,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # for i, c in enumerate(s):\\n        #     p = s[i::].find(c)\\n        #     s[p].replace(s[p], \" \")\\n        #     q = s[:i].find(c)\\n        #     s[q].replace(s[q], \" \")\\n        # return len(s)\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # for i, c in enumerate(s):\\n        #     p = s[i::].find(c)\\n        #     s[p].replace(s[p], \" \")\\n        #     q = s[:i].find(c)\\n        #     s[q].replace(s[q], \" \")\\n        # return len(s)\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858325,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857964,
                "title": "simple-solution-for-beginner-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        l1=[]\\n        l2=[]\\n        for i in s:\\n            if i not in l1:\\n                l1.append(i)\\n            else:\\n                l2.append(i)\\n        return len(l1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        l1=[]\\n        l2=[]\\n        for i in s:\\n            if i not in l1:\\n                l1.append(i)\\n            else:\\n                l2.append(i)\\n        return len(l1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855703,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(strlen(s))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) as it does not depend on strlen but it \\'26\\'+\\'1\\' extra space used. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n    int ans[\\'z\\'-64]={0};\\n    int count=0;\\n   for(int i=0;i<strlen(s);i++)\\n   {\\n       if(ans[s[i]-65]==0)\\n       {\\n           count++;\\n           ans[s[i]-65]++;\\n       }\\n       else\\n       continue;\\n   }\\n   return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n    int ans[\\'z\\'-64]={0};\\n    int count=0;\\n   for(int i=0;i<strlen(s);i++)\\n   {\\n       if(ans[s[i]-65]==0)\\n       {\\n           count++;\\n           ans[s[i]-65]++;\\n       }\\n       else\\n       continue;\\n   }\\n   return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853728,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>ss;\\n        for(auto i:s){\\n            ss.insert(i);\\n        }\\n\\n        return ss.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>ss;\\n        for(auto i:s){\\n            ss.insert(i);\\n        }\\n\\n        return ss.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853714,
                "title": "java-easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849099,
                "title": "using-hashmap-one-line-solution",
                "content": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Using Hashmap\\n        # hash_ = {}\\n        # for i in s:\\n        #     if i not in hash_:\\n        #         hash_[i] = 1\\n        #     hash_[i] += 1\\n        # return len(hash_)\\n        \\n        # One line.\\n        return len(set(s))\\n```\\n\\nThanks for reading :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Using Hashmap\\n        # hash_ = {}\\n        # for i in s:\\n        #     if i not in hash_:\\n        #         hash_[i] = 1\\n        #     hash_[i] += 1\\n        # return len(hash_)\\n        \\n        # One line.\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846026,
                "title": "beginner-friendly-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character>set=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character>set=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845826,
                "title": "java-3ms-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // HashSet + StringBuilder strategy: 8ms Beats 79.21%\\n    // boolean[123] + StringBuilder strategy: 4ms Beats 99.80%\\n    // boolean[123] + int numChars strategy: 3ms Beats 100.00%\\n\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] skipForever = new boolean[123];\\n        int numChars = 0;  // what we\\'ll return\\n\\n        for (char c : s.toCharArray()) {\\n            if (!skipForever[c]) {\\n                ++numChars;\\n                skipForever[c] = true;\\n            }\\n        }\\n\\n        return numChars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // HashSet + StringBuilder strategy: 8ms Beats 79.21%\\n    // boolean[123] + StringBuilder strategy: 4ms Beats 99.80%\\n    // boolean[123] + int numChars strategy: 3ms Beats 100.00%\\n\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] skipForever = new boolean[123];\\n        int numChars = 0;  // what we\\'ll return\\n\\n        for (char c : s.toCharArray()) {\\n            if (!skipForever[c]) {\\n                ++numChars;\\n                skipForever[c] = true;\\n            }\\n        }\\n\\n        return numChars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845701,
                "title": "c-efficient-concise",
                "content": "# Intuition\\nThe problem description is a bit confusing, but it boils down to a count of unique characters.\\n# Approach\\nUse a set to count unique characters.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)\\n\\n- Space complexity:\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string& s) {\\n        unordered_set<char> t(s.begin(), s.end());\\n        return t.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string& s) {\\n        unordered_set<char> t(s.begin(), s.end());\\n        return t.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844318,
                "title": "c-easy-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> ump;\\n        for(auto i : s) ump[i]++;\\n        \\n        int extra = 0;\\n        for(auto i : ump) {\\n            if(i.second > 1) extra += i.second - 1;\\n        }\\n        return s.size() - extra;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> ump;\\n        for(auto i : s) ump[i]++;\\n        \\n        int extra = 0;\\n        for(auto i : ump) {\\n            if(i.second > 1) extra += i.second - 1;\\n        }\\n        return s.size() - extra;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1916536,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916041,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916139,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916884,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2069258,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2054998,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1980052,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1975797,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1931513,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1921418,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916536,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916041,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916139,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916884,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2069258,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2054998,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1980052,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1975797,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1931513,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1921418,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Semi-Ordered Permutation",
        "question_content": "<p>You are given a <strong>0-indexed</strong> permutation of <code>n</code> integers <code>nums</code>.</p>\n\n<p>A permutation is called <strong>semi-ordered</strong> if the first number equals <code>1</code> and the last number equals <code>n</code>. You can perform the below operation as many times as you want until you make <code>nums</code> a <strong>semi-ordered</strong> permutation:</p>\n\n<ul>\n\t<li>Pick two adjacent elements in <code>nums</code>, then swap them.</li>\n</ul>\n\n<p>Return <em>the minimum number of operations to make </em><code>nums</code><em> a <strong>semi-ordered permutation</strong></em>.</p>\n\n<p>A <strong>permutation</strong> is a sequence of integers from <code>1</code> to <code>n</code> of length <code>n</code> containing each number exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,4,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can make the permutation semi-ordered using these sequence of operations: \n1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,1,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can make the permutation semi-ordered using these sequence of operations:\n1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].\n2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,4,2,5]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The permutation is already a semi-ordered permutation.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i]&nbsp;&lt;= 50</code></li>\n\t<li><code>nums is a permutation.</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3595297,
                "title": "java-c-python-index-of-1-and-n",
                "content": "# **Explanation**\\nIf index of `1` is `i`,\\n`1` needs `i` swaps to be the first.\\n\\nIf index of `n` is `j`,\\n`n` needs `n - 1 - j` swaps to be the first.\\n\\nIf `i < j`,\\n`res` is `i + (n - 1 - j)`.\\n\\nIf `i > j`,\\n`res` is `i + (n - 1 - j) - 1`,\\nsave one swap when swap `1` and `n`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int semiOrderedPermutation(int[] A) {\\n        int n = A.length, i = 0, j = 0;\\n        for (int k = 0; k < n; k++) {\\n            if (A[k] == 1) i = k;\\n            if (A[k] == A.length) j = k;\\n        }\\n        return i + n - 1 - j - (i > j ? 1 : 0);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size(), i = find(A.begin(), A.end(), 1) - A.begin(), j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def semiOrderedPermutation(self, A: List[int]) -> int:\\n        n = len(A)\\n        i, j = A.index(1), A.index(n)\\n        return i + n - 1 - j - (i > j)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int semiOrderedPermutation(int[] A) {\\n        int n = A.length, i = 0, j = 0;\\n        for (int k = 0; k < n; k++) {\\n            if (A[k] == 1) i = k;\\n            if (A[k] == A.length) j = k;\\n        }\\n        return i + n - 1 - j - (i > j ? 1 : 0);\\n    }\\n```\n```cpp\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size(), i = find(A.begin(), A.end(), 1) - A.begin(), j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n```\n```py\\n    def semiOrderedPermutation(self, A: List[int]) -> int:\\n        n = len(A)\\n        i, j = A.index(1), A.index(n)\\n        return i + n - 1 - j - (i > j)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3595215,
                "title": "explained-iteration-very-simple-and-easy-to-understand",
                "content": "## Approach\\n1. Find the ith index of min val 1 => we need to do i operation to move 1 to first position\\n2. Find the ith index of the max val n => we need to do (n - i - 1) operation to take it to last position\\n3. Take the sum of above two as the answer. Only corner case is when the ith index of 1 is larger than ith index of n - in this case we need to reduce the ans by 1 as the 1 & n cna be swapped at the same time so that we count it as 1 operation in place of 2.\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int imin = 0, imax = nums.size(), n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] == 1) imin = i;\\n            if(nums[i] == n) imax = i;\\n        }\\n        if(imin < imax) return (imin + n - imax - 1);\\n        return (imin + n - imax - 1) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int imin = 0, imax = nums.size(), n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] == 1) imin = i;\\n            if(nums[i] == n) imax = i;\\n        }\\n        if(imin < imax) return (imin + n - imax - 1);\\n        return (imin + n - imax - 1) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594901,
                "title": "find-positions",
                "content": "**C++**\\n```cpp\\nint semiOrderedPermutation(vector<int>& n) {\\n    int first = find(begin(n), end(n), 1) - begin(n);\\n    int last = find(begin(n), end(n), n.size()) - begin(n);\\n    return first + (n.size() - last - 1) - (first > last);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint semiOrderedPermutation(vector<int>& n) {\\n    int first = find(begin(n), end(n), 1) - begin(n);\\n    int last = find(begin(n), end(n), n.size()) - begin(n);\\n    return first + (n.size() - last - 1) - (first > last);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594970,
                "title": "long-but-easy-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function (nums) {\\n    const n = nums.length\\n    if (nums[0] === 1 && nums[n - 1] === n) return 0\\n    \\n    let cn = 0\\n    \\n    let i = nums.indexOf(1)\\n    while (nums[0] !== 1 && i >= 0) {\\n        const curr = nums[i - 1]\\n        \\n        nums[i - 1] = nums[i]\\n        nums[i] = curr\\n        \\n        i -= 1\\n        cn += 1\\n    }\\n    \\n    if (nums[0] === 1 && nums[n - 1] === n) return cn\\n    i = nums.indexOf(n)\\n    while (nums[n - 1] !== n && i < n) {\\n        const curr = nums[i]\\n        \\n        nums[i] = nums[i + 1]\\n        nums[i + 1] = curr\\n        \\n        i += 1\\n        cn += 1\\n    }\\n    \\n    return cn\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function (nums) {\\n    const n = nums.length\\n    if (nums[0] === 1 && nums[n - 1] === n) return 0\\n    \\n    let cn = 0\\n    \\n    let i = nums.indexOf(1)\\n    while (nums[0] !== 1 && i >= 0) {\\n        const curr = nums[i - 1]\\n        \\n        nums[i - 1] = nums[i]\\n        nums[i] = curr\\n        \\n        i -= 1\\n        cn += 1\\n    }\\n    \\n    if (nums[0] === 1 && nums[n - 1] === n) return cn\\n    i = nums.indexOf(n)\\n    while (nums[n - 1] !== n && i < n) {\\n        const curr = nums[i]\\n        \\n        nums[i] = nums[i + 1]\\n        nums[i + 1] = curr\\n        \\n        i += 1\\n        cn += 1\\n    }\\n    \\n    return cn\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597749,
                "title": "python-3-2-lines-w-brief-explanation-t-m-96-97",
                "content": "We first determine the indices `mn`and`mx`of two numbers being migrated to the ends of the list. Second, we count the number of steps required to move each, which are`mn`and`n-mx-1`. We check whether`mn > mx`, in which casethe two migrations share a step and we then correct by decrementing the sum by one. We return this sum.\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        mn, mx = nums.index(1) , nums.index(n:= len(nums))     \\n        return mn - mx + n - 1 - (mn > mx)\\n```\\n[https://leetcode.com/problems/semi-ordered-permutation/submissions/991660777/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        mn, mx = nums.index(1) , nums.index(n:= len(nums))     \\n        return mn - mx + n - 1 - (mn > mx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595007,
                "title": "java-easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int semiOrderedPermutation(int[] nums) {\\n    int n = nums.length, a = 0, b = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (nums[i] == 1) a = i;\\n      if (nums[i] == n) b = i;\\n    }\\n    return a + (n-1-b) - (a > b ? 1 : 0);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public int semiOrderedPermutation(int[] nums) {\\n    int n = nums.length, a = 0, b = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (nums[i] == 1) a = i;\\n      if (nums[i] == n) b = i;\\n    }\\n    return a + (n-1-b) - (a > b ? 1 : 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595866,
                "title": "get-index-of-1-n-c",
                "content": "get index 1 and n\\na = index of 1;\\nb = index of n\\nif(index of 1 < index of n)\\n    than return a+n-1-b;\\nelse return a+n-1-b-n//there is we substracte previous ans by 1 because here one case is possible that we swap(1,n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int a,b,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(nums[i]==1)a = i;\\n            else if(nums[i]==n)b = i;\\n        }\\n        if(a<b){\\n            return a+n-1-b;\\n        }else{\\n            return a+n-1-b-1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int a,b,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(nums[i]==1)a = i;\\n            else if(nums[i]==n)b = i;\\n        }\\n        if(a<b){\\n            return a+n-1-b;\\n        }else{\\n            return a+n-1-b-1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594930,
                "title": "find-c",
                "content": "# Intuition\\n**Find Position of ```1``` and ```n```**\\n**```Result = ind_one + (n - ind_n + 1)```** (Calculating Swaps)\\n**But if ind_one is on left of ind_n, it means you one swap operation will be common for both i.e ```swap(1, n)``` so will do ```Result - 1```**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int ind_One = find(nums.begin(), nums.end(), 1) - nums.begin(), ind_N = find(nums.begin(), nums.end(), n) - nums.begin();\\n        int Result = ind_One + n - (ind_N + 1);\\n        if(ind_One > ind_N)    // One on left of N\\n            return Result - 1;\\n        return Result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```1```\n```n```\n```Result = ind_one + (n - ind_n + 1)```\n```swap(1, n)```\n```Result - 1```\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int ind_One = find(nums.begin(), nums.end(), 1) - nums.begin(), ind_N = find(nums.begin(), nums.end(), n) - nums.begin();\\n        int Result = ind_One + n - (ind_N + 1);\\n        if(ind_One > ind_N)    // One on left of N\\n            return Result - 1;\\n        return Result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597044,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)\\n        j=nums.index(n)\\n        ans=i+n-1-j-(i>j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)\\n        j=nums.index(n)\\n        ans=i+n-1-j-(i>j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595606,
                "title": "c-easy-o-n-solution-w-intuition-code-finding-index",
                "content": "# Intuition\\nMy intuition for this problem was to know the number of swaps to change the position of a number. Our task is to move the smallest number to the start and the largest number to the end of the array.\\nTo move a number from index `i=5` to `j=0`, we need `i-j` swaps. So to move the minimum number from any index to the `0th index` we need as many number of swaps as the index of the min. number.\\nNow we need `n-1-i` swaps to move the largest number(positioned at $$i^{th}$$ index) to the `n-1 index` but there\\'s a catch if we do this after moving the min number.\\n\\nWe need to consider the fact that the largest number can come before the smallest number and that moving the smallest number has moved the largest number towards it\\'s desired location. So if the largest number\\'s index comes before the minimum number\\'s index, we use `n-1-i - 1` to indicate that it has to do one less swap itself. \\n\\n# Approach\\nThe approach is simple, we just find:\\n- index of minimum number `minIdx`\\n- index of maximum number `maxIdx`\\n\\nAnd use what we derived above:\\n- Swaps for moving minimum number, `smin`: `minIdx`\\n- Swaps for moving maximum number, `smax`: \\n1. `n-1-maxIdx` if `minIdx<maxIdx`\\n2. `n-1-maxIdx - 1` if `minIdx>maxIdx`\\n\\nSo,  Total number of swaps (our answer): `smin + smax`\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int minIdx{0};\\n        int maxIdx{0};\\n        for(int i=0; i<nums.size(); i++) {\\n            if (nums[i] < nums[minIdx])\\n                minIdx = i;\\n            if (nums[i] > nums[maxIdx])\\n                maxIdx = i;\\n        }\\n        int res{0};\\n        res += minIdx;\\n        res += nums.size()-1-maxIdx-(maxIdx<minIdx);\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nBecause we\\'re traversing the array once to find the indices of the minimum and the maximum number.\\n- Space complexity: $$O(1)$$\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int minIdx{0};\\n        int maxIdx{0};\\n        for(int i=0; i<nums.size(); i++) {\\n            if (nums[i] < nums[minIdx])\\n                minIdx = i;\\n            if (nums[i] > nums[maxIdx])\\n                maxIdx = i;\\n        }\\n        int res{0};\\n        res += minIdx;\\n        res += nums.size()-1-maxIdx-(maxIdx<minIdx);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595196,
                "title": "python-3-easy-solution-compare-min-and-max-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\\n            return 0\\n        \\n        op = 0\\n        min_idx = nums.index(min(nums))\\n        max_idx = nums.index(max(nums))\\n        if min_idx < max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx)\\n        if min_idx > max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\\n        \\n        return op\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\\n            return 0\\n        \\n        op = 0\\n        min_idx = nums.index(min(nums))\\n        max_idx = nums.index(max(nums))\\n        if min_idx < max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx)\\n        if min_idx > max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\\n        \\n        return op\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872501,
                "title": "java-beginner-friendly-solution-100-beats-fully-explained",
                "content": "# Approach\\n\\nTo convert the given permutation `nums` into a semi-ordered permutation, we need to perform swaps to move the number `1` to the first position and the number `n` to the last position. We can achieve this by finding the indices of `1` and `n` in the array and then calculating the number of operations required to move `1` to the first position and `n` to the last position.\\n\\n**Logic:**\\n1. Initialize two variables `count` and `idx` to keep track of the number of operations and the index of `1` in the array, respectively.\\n2. Loop through the array to find the index of the number `1`. Set `idx` to this index.\\n3. Calculate the number of operations required to move `1` to the first position. Set `count` to `idx`.\\n4. While the number at the first position is not `1`, swap the elements at indices `idx` and `idx-1` to move `1` towards the first position. Decrement `idx` by 1 after each swap.\\n5. Loop through the array again to find the index of the number `n`. Set `idx` to this index.\\n6. Calculate the number of operations required to move `n` to the last position. Return `count + n - idx - 1`, which represents the total number of operations needed to make `nums` a semi-ordered permutation.\\n\\n**Pseudocode:**\\n```plaintext\\nFunction semiOrderedPermutation(nums):\\n    n = length of nums\\n    count = 0\\n    idx = 0\\n    \\n    # Find the index of 1 in nums\\n    for i = 0 to n-1:\\n        if nums[i] == 1:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move 1 to the first position\\n    count = idx\\n    \\n    # Move 1 to the first position using swaps\\n    while nums[0] != 1:\\n        swap nums[idx] and nums[idx-1]\\n        idx = idx - 1\\n    \\n    # Find the index of n in nums\\n    for i = 0 to n-1:\\n        if nums[i] == n:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move n to the last position\\n    return count + n - idx - 1\\n```\\n\\n**Final Remarks:**\\nThe provided solution follows the above approach and logic to solve the problem. It efficiently moves the number `1` to the first position and the number `n` to the last position, minimizing the number of swaps needed. The solution is clear and concise, making it easy for beginners to understand and implement.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        int idx = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        count = idx;\\n\\n        while (nums[0] != 1) {\\n            nums[idx] = nums[idx - 1];\\n            nums[idx - 1] = 1;\\n            idx--;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == n) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        return count + n - idx - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```plaintext\\nFunction semiOrderedPermutation(nums):\\n    n = length of nums\\n    count = 0\\n    idx = 0\\n    \\n    # Find the index of 1 in nums\\n    for i = 0 to n-1:\\n        if nums[i] == 1:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move 1 to the first position\\n    count = idx\\n    \\n    # Move 1 to the first position using swaps\\n    while nums[0] != 1:\\n        swap nums[idx] and nums[idx-1]\\n        idx = idx - 1\\n    \\n    # Find the index of n in nums\\n    for i = 0 to n-1:\\n        if nums[i] == n:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move n to the last position\\n    return count + n - idx - 1\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        int idx = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        count = idx;\\n\\n        while (nums[0] != 1) {\\n            nums[idx] = nums[idx - 1];\\n            nums[idx - 1] = 1;\\n            idx--;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == n) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        return count + n - idx - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606110,
                "title": "c-java-determining-the-positions-of-1-and-n",
                "content": "\\nDetermine the locations of `1` and `N`, labelled as `one_index` and `n_index` respectively. The number of swaps needed to reposition `1` at the start is equivalent to `one_index`, and similarly, to move `N` to the final position, `N - 1 - n_index` swaps are required. \\n\\nHowever, should `1` be located to the right of `N`, then as `1` is moved towards the 0th position, it would swap places with `N`, thereby bringing `N` a step closer to its desired final position. This would therefore require one less swap, i.e., `N - 1 - n_index - 1` to relocate `N` to the end. Consequently, if `1` is to the right of `N`, we need to subtract 1 from the total swap count.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int one_index = 0, n_index = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) one_index = i;\\n            else if (nums[i] == n) n_index = i;\\n        }\\n        return one_index + n - 1 - n_index - (one_index < n_index ? 0 : 1);\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = 0, nIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) oneIndex = i;\\n            else if (nums[i] == n) nIndex = i;\\n        }\\n        return oneIndex + n - 1 - nIndex - (oneIndex < nIndex ? 0 : 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int one_index = 0, n_index = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) one_index = i;\\n            else if (nums[i] == n) n_index = i;\\n        }\\n        return one_index + n - 1 - n_index - (one_index < n_index ? 0 : 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = 0, nIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) oneIndex = i;\\n            else if (nums[i] == n) nIndex = i;\\n        }\\n        return oneIndex + n - 1 - nIndex - (oneIndex < nIndex ? 0 : 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600932,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the position of 1 and the n in the nums which will take o(n)\\ni have used find but simple iteration can also be done to find the pos of both the elements \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the pos of both the element using simple iteration or find \\n2. Their are only two case which we have to see now \\n             i.pos_1 < pos_2\\n             ii. pos_1 > pos_2\\n3. For case i we simple add the no of swaps need for both the element to reach their respective position \\n4. for case ii we do the same as for case i but subtract 1 from it as when we were swaping elements for 1 as the pos_2 < pos_1 then the n element must have shifted by one toward its destination so -1 to the ans\\n# Complexity\\n- Time complexity:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int pos_1 = find(nums.begin(),nums.end(),1) - nums.begin();\\n        int pos_2 = find(nums.begin(),nums.end(),n) - nums.begin();\\n        return (pos_1<pos_2) ?(pos_1 +  n-1-pos_2):(pos_1 + (n-1 - pos_2) - (1));\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int pos_1 = find(nums.begin(),nums.end(),1) - nums.begin();\\n        int pos_2 = find(nums.begin(),nums.end(),n) - nums.begin();\\n        return (pos_1<pos_2) ?(pos_1 +  n-1-pos_2):(pos_1 + (n-1 - pos_2) - (1));\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599250,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int mini=0;\\n        int maxi=0;\\n        int n=nums.size();\\n        for(int i=0 ; i < n ; i++){\\n            if(nums[i]==1){\\n                mini=i;\\n            }\\n            else if(nums[i]==n){\\n                maxi=i;\\n            }\\n        }\\n        if(mini>maxi){\\n            maxi=(n-1)-(maxi+1);\\n        }\\n        else{\\n            maxi=(n-1)-maxi;\\n        }\\n        return mini+maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int mini=0;\\n        int maxi=0;\\n        int n=nums.size();\\n        for(int i=0 ; i < n ; i++){\\n            if(nums[i]==1){\\n                mini=i;\\n            }\\n            else if(nums[i]==n){\\n                maxi=i;\\n            }\\n        }\\n        if(mini>maxi){\\n            maxi=(n-1)-(maxi+1);\\n        }\\n        else{\\n            maxi=(n-1)-maxi;\\n        }\\n        return mini+maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595395,
                "title": "simple-java-o-n-solution",
                "content": "# Approach\\n- Get the index of 1 and N\\n- Number of swaps would be sum of difference between index of 1 and 0 and difference between index of N and last index.\\n- If position of N is before 1, then we require 1 less swap\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int indexOne = -1;\\n        int indexN = -1;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 1)\\n                indexOne = i;\\n            if(nums[i] == nums.length)\\n                indexN = i;\\n        }\\n        \\n        int count = 0;\\n        if(indexOne > indexN)\\n            count--;\\n        \\n        count += indexOne + (nums.length - 1 - indexN);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int indexOne = -1;\\n        int indexN = -1;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 1)\\n                indexOne = i;\\n            if(nums[i] == nums.length)\\n                indexN = i;\\n        }\\n        \\n        int count = 0;\\n        if(indexOne > indexN)\\n            count--;\\n        \\n        count += indexOne + (nums.length - 1 - indexN);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595158,
                "title": "o-n-very-easy-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Just find the idex of 1 and the index of maximum number. \\n    If the index of 1 > index of max number, it will take one swap less \\n    if(idx1>idx){\\n        idx1=idx1-1;\\n        }\\n    The answer will be (nums.length-1-idx) + idx1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int idx=0,idx1=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n                idx=i;\\n            }\\n            if(nums[i]==1){\\n                idx1=i;\\n            }\\n        }\\n        if(idx1>idx){\\n            idx1=idx1-1;\\n        }\\n        return (nums.length-1-idx) + idx1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int idx=0,idx1=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n                idx=i;\\n            }\\n            if(nums[i]==1){\\n                idx1=i;\\n            }\\n        }\\n        if(idx1>idx){\\n            idx1=idx1-1;\\n        }\\n        return (nums.length-1-idx) + idx1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594957,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int opr = 0, j = 0;\\n//         finding 1\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == 1)    j = i;\\n//         operating 1 to start index\\n        while(j > 0){\\n            nums[j] = nums[j-1];\\n            nums[j-1] = 1;\\n            opr++;\\n            j--;\\n        }\\n//         finding n\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == nums.length)    j = i;\\n//         operating n to last index\\n        while(j < nums.length-1){\\n            nums[j] = nums[j+1];\\n            nums[j+1] = nums.length;\\n            opr++;\\n            j++;\\n        }   \\n        return opr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int opr = 0, j = 0;\\n//         finding 1\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == 1)    j = i;\\n//         operating 1 to start index\\n        while(j > 0){\\n            nums[j] = nums[j-1];\\n            nums[j-1] = 1;\\n            opr++;\\n            j--;\\n        }\\n//         finding n\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == nums.length)    j = i;\\n//         operating n to last index\\n        while(j < nums.length-1){\\n            nums[j] = nums[j+1];\\n            nums[j+1] = nums.length;\\n            opr++;\\n            j++;\\n        }   \\n        return opr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909979,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the given 0-indexed array, we are allowed to perform swap on any two adjacent elements unit we make array nums a semi-ordered permutation.\\nwe can perform swap on element valued 1 till it reaches index 0.\\nSimilarly, we perform swap on element valued n (which is also the size of the array nums) till it reaches the last index that is (n-1).\\nWe return the number of swaps required in this process.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int cnt=0;\\n        bool f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                       swap(nums[i],nums[i+1]);\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                       swap(nums[i], nums[i-1]);\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int cnt=0;\\n        bool f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                       swap(nums[i],nums[i+1]);\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                       swap(nums[i], nums[i-1]);\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672706,
                "title": "2-c-solutions-beginner-friendly-approach-with-and-without-vector-find",
                "content": "\\n# Code\\n```\\n// Soution 1 (With find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size();\\n        int i = find(A.begin(), A.end(), 1) - A.begin(); \\n        int j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n}\\n\\n// Solution 2 (Without find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size(), count=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1){\\n                count+=i;\\n                for(int j=i; j>0; j--)\\n                    swap(nums[j], nums[j-1]); // we swap the numbers so that the later considering the case when 1 comes after n-1 because count will get repeated for such cases\\n                break;\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==n){ \\n                count+=(n-1)-i;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Soution 1 (With find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size();\\n        int i = find(A.begin(), A.end(), 1) - A.begin(); \\n        int j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n}\\n\\n// Solution 2 (Without find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size(), count=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1){\\n                count+=i;\\n                for(int j=i; j>0; j--)\\n                    swap(nums[j], nums[j-1]); // we swap the numbers so that the later considering the case when 1 comes after n-1 because count will get repeated for such cases\\n                break;\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==n){ \\n                count+=(n-1)-i;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672586,
                "title": "simple-code-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int start,end;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] == 1)\\n                start = i;\\n            if(nums[i] == n)\\n                end = i;\\n        }\\n        if(start > end)\\n            return start + n - end - 2;\\n        else \\n            return start + n - end-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int start,end;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] == 1)\\n                start = i;\\n            if(nums[i] == n)\\n                end = i;\\n        }\\n        if(start > end)\\n            return start + n - end - 2;\\n        else \\n            return start + n - end-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672114,
                "title": "c-2-pointer-solution-7ms-46-3mb",
                "content": "For this problem we have to just find the indexes of `1` and the value matching length of `nums`, then check how far they are from being in the first and in the last position - with a caveat: if the first position is `>` than the last one, when we start swapping one of the indexes we will put the latter closer to its position, so we need to take that into account.\\n\\nNow, to code our solution, let\\'s start with declaring our support variables:\\n* `len` will store the length of `nums`;\\n* `p1` and `p2` will be where we store the positions of the values `1` and `len` respectively, both initially set to be `-1`.\\n\\nWe will then loop with `i` across all the positions in `nums` until we have found both pointers (ie: `p1 == -1 || p2 == -1`) and:\\n* store `nums[i]` in `n`;\\n* if `n == 1`, we will set `p1` to be `i`;\\n* otherwise, if `n == len`, we will set `p2` to be `i`.\\n\\nOnce done, we will `return` the sum of the distances of `p1` from the first position (ie: `p1 - 0`) and `p2` from the last position (ie: `len - p2 - 1`), adjusted by `-1` as we mentioned in our incipit if `p1 > p2`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), p1 = -1, p2 = -1;\\n        // parsing nums\\n        for (int i = 0, n; p1 == -1 || p2 == -1; i++) {\\n            n = nums[i];\\n            if (n == 1) p1 = i;\\n            else if (n == len) p2 = i;\\n        }\\n        return (p1 > p2 ? -1 : 0) + p1 + len - p2 - 1;\\n    }\\n};\\n```\\n\\nAlternative version of that logic, working directly with a variable result `res` and a boolean flag `foundOne` to check if we had already found the other index before. Notice that now we need to do one less check at each loop iteration and that we use `foundOne` in the `else if` clause to decrease the value of `res` by `1` if we had found `1` before `len`; overall, this version seemed to perform a bit better:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        bool foundOne = false;\\n        // parsing nums\\n        for (int i = 0, n; ; i++) {\\n            n = nums[i];\\n            if (n == 1) {\\n                res += i;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n            else if (n == len) {\\n                res += len - i - 1 - !foundOne;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), p1 = -1, p2 = -1;\\n        // parsing nums\\n        for (int i = 0, n; p1 == -1 || p2 == -1; i++) {\\n            n = nums[i];\\n            if (n == 1) p1 = i;\\n            else if (n == len) p2 = i;\\n        }\\n        return (p1 > p2 ? -1 : 0) + p1 + len - p2 - 1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        bool foundOne = false;\\n        // parsing nums\\n        for (int i = 0, n; ; i++) {\\n            n = nums[i];\\n            if (n == 1) {\\n                res += i;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n            else if (n == len) {\\n                res += len - i - 1 - !foundOne;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626499,
                "title": "simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        for (int x = 0; x<n; x++) {\\n            if (nums[x] == 1) i = x;\\n            if (nums[x] == n) j = x;\\n        }\\n\\n        if (j < i) return i + n-j-2;\\n        return i + n-j-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        for (int x = 0; x<n; x++) {\\n            if (nums[x] == 1) i = x;\\n            if (nums[x] == n) j = x;\\n        }\\n\\n        if (j < i) return i + n-j-2;\\n        return i + n-j-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624244,
                "title": "formula-based-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int mx=0, mxidx=0;\\n        int mn=INT_MAX, mnidx;\\n        int count=0;\\n\\n        for(int i=0; i<n; i++){\\n            mx=max(mx, nums[i]);\\n            if(nums[i]==mx) mxidx=i;\\n\\n            mn=min(mn, nums[i]);\\n            if(nums[i]==mn) mnidx=i;\\n        }\\n        \\n        count=n+mnidx-mxidx-1;\\n        if(mnidx<mxidx) return count;\\n        return --count;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int mx=0, mxidx=0;\\n        int mn=INT_MAX, mnidx;\\n        int count=0;\\n\\n        for(int i=0; i<n; i++){\\n            mx=max(mx, nums[i]);\\n            if(nums[i]==mx) mxidx=i;\\n\\n            mn=min(mn, nums[i]);\\n            if(nums[i]==mn) mnidx=i;\\n        }\\n        \\n        count=n+mnidx-mxidx-1;\\n        if(mnidx<mxidx) return count;\\n        return --count;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600574,
                "title": "super-easy-solution-with-simple-logic-store-positions",
                "content": "# Intuition\\nSince we have to swap adjacent numbers to fulfil the given condition ,we will store the psoiton of 1 and the last number by iterating through loop. After the answer will be total number of swaps,hence we will add the number of swaps with the help of their positions.\\nBut if the last number i.e. n is present before the number 1 both of the them reach their destinantion simultaneously ,hence we will decrease the answer by 1.\\n\\n# Approach\\n- We will store the two psoitons in variables f and l.\\n- We will store the answer i.e. total number of swaps in variable\\n```\\nint ans=f+(n-1-l);\\n```\\n- We will check for the condition (mentioned in Intuiton above) and decrement answer by 1 if it is there.\\n```\\nif(l<f)\\n{\\n    ans=ans-1;\\n}\\n```\\n- Return the answer.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:It will be O(n) because of for loop.\\n\\n\\n- Space complexity:It wil be O(1) .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int f=0,l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                f=i;\\n            }\\n            if(nums[i]==n)\\n            {\\n                l=i;\\n            }\\n        }\\n        int ans=f+(n-1-l);\\n        if(l<f)\\n        {\\n            ans=ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if it helps!",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nint ans=f+(n-1-l);\\n```\n```\\nif(l<f)\\n{\\n    ans=ans-1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int f=0,l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                f=i;\\n            }\\n            if(nums[i]==n)\\n            {\\n                l=i;\\n            }\\n        }\\n        int ans=f+(n-1-l);\\n        if(l<f)\\n        {\\n            ans=ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597605,
                "title": "java-solution-beats-100-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int semiOrder(int nums[], int count) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length) {\\n            return count;\\n        }\\n        else if(nums[0]==1) {\\n            for(int i=0; i<nums.length-1; i++) {\\n                if(nums[i]==nums.length) {\\n                    nums[i]=nums[i+1];\\n                    nums[i+1]=nums.length;\\n                    break;\\n                }\\n            }\\n        }\\n        else {\\n            for(int i=1; i<nums.length; i++) {\\n                if(nums[i]==1) {\\n                    nums[i]=nums[i-1];\\n                    nums[i-1]=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return semiOrder(nums,count+1);\\n    }\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        return semiOrder(nums, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int semiOrder(int nums[], int count) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length) {\\n            return count;\\n        }\\n        else if(nums[0]==1) {\\n            for(int i=0; i<nums.length-1; i++) {\\n                if(nums[i]==nums.length) {\\n                    nums[i]=nums[i+1];\\n                    nums[i+1]=nums.length;\\n                    break;\\n                }\\n            }\\n        }\\n        else {\\n            for(int i=1; i<nums.length; i++) {\\n                if(nums[i]==1) {\\n                    nums[i]=nums[i-1];\\n                    nums[i-1]=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return semiOrder(nums,count+1);\\n    }\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        return semiOrder(nums, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596789,
                "title": "easiest-implementation",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx1,idxN;\\n        for(int i=0 ; i<n ; i++) {\\n            if(nums[i] == 1) idx1 = i;\\n            if(nums[i] == n) idxN = i;\\n        }\\n        \\n        int ans = idx1 + n-1-idxN;\\n        if(idxN < idx1) ans--; // one common swap\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx1,idxN;\\n        for(int i=0 ; i<n ; i++) {\\n            if(nums[i] == 1) idx1 = i;\\n            if(nums[i] == n) idxN = i;\\n        }\\n        \\n        int ans = idx1 + n-1-idxN;\\n        if(idxN < idx1) ans--; // one common swap\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596433,
                "title": "step-by-step-explanation-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**We just need to find the index of both the elements min element=1\\nand maxelement=nums.size();**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# There are two cases only\\n1. If location of max element  is right to location of minimum  element like **[2,3,1,7,6,5,4]** *here 7 is at right of 1*\\nin this case answer is **n-maxIndex+minindex** i.e \\n**Index of 7 is 3 index of 1 is 2 and n=6 (last index of array)**\\n    6-3+2=5\\n\\n\\n2. If location of max is left of location of minimum like **[2,3,7,4,5,1,6]**\\nin this case answer is **n-maxIndex+minIndex-1** i.e \\n**Index of 7 is 2 index of 1 is 5 and n=6 (last index of array)**\\n 6-2+5-1=8\\n\\n### here 1 is subtracted because when we swap max element with elements to put it at right place it will be swapped once with min elelment\\n**[2,3,7,4,5,1,6]**\\nhere ist swap **[2,3,4,7,5,1,6]**\\nhere 2nd swap **[2,3,4,5,7,1,6]**\\nhere 3rd swap **[2,3,4,5,1,7,6]**\\n**Now look here the minimum element is changing it\\'s postion\\nSo -1 is done to count this** \\n\\n\\n\\n\\n**Here 7 is max element\\n 1 is min element**\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$  Constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n               int min=-1,max=-1,ans;\\n               int n=nums.size()-1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==1)\\n                        {\\n                min=i;\\n                        } //if\\n            if(nums[i]==nums.size())\\n                       {\\n                        max=i;\\n                            }//if\\n                \\n        if(min!=-1&&max!=-1){break;}//to break the loop \\n        }//for\\n        ans=min+(n-max);\\n        if(max<min) \\n             {\\n             return ans-1;\\n             }\\n    \\n     return ans; \\n        \\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        int indexMin=0;\\n        int indexMax=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indexMin=i;\\n            }\\n            if(nums[i]==max){\\n                indexMax=i;\\n            }\\n        }\\n        if(indexMax<indexMin){\\n            return indexMin + nums.length-1 -indexMax-1;\\n        }\\n        else{\\n            return indexMin + nums.length-1 -indexMax;\\n        }\\n        \\n    }\\n}\\n```\\n# UPVOTE IF IT\\'S HELPFUL\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n               int min=-1,max=-1,ans;\\n               int n=nums.size()-1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==1)\\n                        {\\n                min=i;\\n                        } //if\\n            if(nums[i]==nums.size())\\n                       {\\n                        max=i;\\n                            }//if\\n                \\n        if(min!=-1&&max!=-1){break;}//to break the loop \\n        }//for\\n        ans=min+(n-max);\\n        if(max<min) \\n             {\\n             return ans-1;\\n             }\\n    \\n     return ans; \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        int indexMin=0;\\n        int indexMax=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indexMin=i;\\n            }\\n            if(nums[i]==max){\\n                indexMax=i;\\n            }\\n        }\\n        if(indexMax<indexMin){\\n            return indexMin + nums.length-1 -indexMax-1;\\n        }\\n        else{\\n            return indexMin + nums.length-1 -indexMax;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596035,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        a=nums.index(min(nums))\\n        b=nums.index(max(nums))\\n        if b<a:\\n            return a+(len(nums)-1-b)-1\\n        else:\\n            return a+(len(nums)-1-b)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        a=nums.index(min(nums))\\n        b=nums.index(max(nums))\\n        if b<a:\\n            return a+(len(nums)-1-b)-1\\n        else:\\n            return a+(len(nums)-1-b)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595718,
                "title": "c-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int l = 0 , r = n - 1;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i] == 1) l = i;\\n\\n            if(nums[i] == n) r = i; \\n        }\\n\\n        if(r < l){\\n            return l + (n-1-r) - 1;\\n        }\\n\\n        return l + (n-1-r);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int l = 0 , r = n - 1;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i] == 1) l = i;\\n\\n            if(nums[i] == n) r = i; \\n        }\\n\\n        if(r < l){\\n            return l + (n-1-r) - 1;\\n        }\\n\\n        return l + (n-1-r);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595687,
                "title": "positions-solution-for-c-explanation-complexity",
                "content": "# Approach\\nThe idea is to find the positions of the element with a value 1 and the element with a value n.\\n* The first position is the number of iterations needed to move an element from its current position to the zero position.\\n* The (nums.length - second position) is the number of iterations needed to move an element from its current position to the last position.\\n\\nThe corner case is when the first position is larger than the second one. So, we use one swap to change both elements at once.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic int SemiOrderedPermutation(int[] nums)\\n{\\n    var leftIndex = -1;\\n    var rightIndex = -1;\\n\\n    // Find positions\\n    for (var i = 0; i < nums.Length; i++)\\n    {\\n        if (nums[i] == 1)\\n        {\\n            leftIndex = i;\\n        }\\n        else if (nums[i] == nums.Length)\\n        {\\n            rightIndex = i;\\n        }\\n        else if (leftIndex != -1 && rightIndex != -1)\\n        {\\n            break;\\n        }\\n    }\\n\\n    // Check if already semi-ordered\\n    if (leftIndex == 0 && rightIndex == nums.Length - 1)\\n    {\\n        return 0;\\n    }\\n\\n    // Calc number of iterations\\n    return leftIndex + (nums.Length - rightIndex - 1) + (leftIndex > rightIndex ? -1 : 0);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int SemiOrderedPermutation(int[] nums)\\n{\\n    var leftIndex = -1;\\n    var rightIndex = -1;\\n\\n    // Find positions\\n    for (var i = 0; i < nums.Length; i++)\\n    {\\n        if (nums[i] == 1)\\n        {\\n            leftIndex = i;\\n        }\\n        else if (nums[i] == nums.Length)\\n        {\\n            rightIndex = i;\\n        }\\n        else if (leftIndex != -1 && rightIndex != -1)\\n        {\\n            break;\\n        }\\n    }\\n\\n    // Check if already semi-ordered\\n    if (leftIndex == 0 && rightIndex == nums.Length - 1)\\n    {\\n        return 0;\\n    }\\n\\n    // Calc number of iterations\\n    return leftIndex + (nums.Length - rightIndex - 1) + (leftIndex > rightIndex ? -1 : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595436,
                "title": "easy-understanding-with-intuition-and-approach-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI got to reach the solution with the help of some examples\\nYou may understand with the help of:-\\nexample 1: arr1=[2,1,4,3]\\n- first thing to observe is that the position of 1 and n are such that 1 appears before n\\n- we see that we have to swap the elements [((n-1)-position of n)+(position of first-0)]number of times\\n\\nexample 2: arr2=[2,4,1,3]\\n- first thing to observe is that the position of 1 and n are such that 1 appears after n\\n- we see that we have to swap the elements [((n-1)-position of n)+(position of first-0)]number of times\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. store the index of 1 and n\\n2. let us say index of 1 = first and n=last\\n3. the value of ans will be=((n-1)-last)+(first-0)\\n4. check if first > last\\n5. if so then decrease the value of answer(because we can see that we will be swapping once less as there will be a condition when 1 and n will be swapped,so need to count this just once)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& arr) {\\n        int n=arr.size();\\n        int first=-1,last=-1;\\n        //first store the index of 1 and n\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==n)last=i;\\n            if(arr[i]==1)first=i;\\n        }\\n        //now when we observe the solution with a few examples we get to know that there are two cases\\n        int ans=-1;\\n        if(last<first){\\n            ans=((n-1)-last)+(first-0);\\n            ans--;\\n        }\\n        else{\\n            ans=((n-1)-last)+(first-0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& arr) {\\n        int n=arr.size();\\n        int first=-1,last=-1;\\n        //first store the index of 1 and n\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==n)last=i;\\n            if(arr[i]==1)first=i;\\n        }\\n        //now when we observe the solution with a few examples we get to know that there are two cases\\n        int ans=-1;\\n        if(last<first){\\n            ans=((n-1)-last)+(first-0);\\n            ans--;\\n        }\\n        else{\\n            ans=((n-1)-last)+(first-0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595386,
                "title": "python3-solution-find-position",
                "content": "# Intuition\\nFind the position of 1 and n in the nums let say l and r resp., no. of swaps required to make l the first-number is `l` since we need to swap all the elements with 1 from index l to 0, Similarly for n be the last-number we required `n - r - 1` swaps.\\nBut there\\'s a catch if the index of n is less than 1 than we need to `subtract 1` from ans, as 1 swap is counted twice. When 1 and n are adjacent to each other after some operation\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = nums.index(1), nums.index(n)\\n        return l + n - r - 1 - (1 if r < l else 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = nums.index(1), nums.index(n)\\n        return l + n - r - 1 - (1 if r < l else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595368,
                "title": "2-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums.index(len(nums))<nums.index(1):return (len(nums)-1-nums.index(len(nums)))+nums.index(1)-1\\n        else:return (len(nums)-1-nums.index(len(nums)))+nums.index(1)\\n       \\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums.index(len(nums))<nums.index(1):return (len(nums)-1-nums.index(len(nums)))+nums.index(1)-1\\n        else:return (len(nums)-1-nums.index(len(nums)))+nums.index(1)\\n       \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595310,
                "title": "easy-c-solution-observation-based",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(nums[0] == 1 and nums[nums.size() - 1] == nums.size()) {\\n            return 0;\\n        }\\n        \\n        int pos1 = -1;\\n        int pos2 = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 1) {\\n                pos1 = i;\\n            }\\n            if(nums[i] == n) {\\n                pos2 = i;\\n            }\\n        }\\n        int ans = 0;\\n        if(pos1 < pos2) {\\n           ans = pos1 + (n - 1 - pos2); \\n        }\\n        \\n        if(pos1 > pos2) {\\n            int temp = pos1 - pos2;\\n            pos1 = pos2;\\n            pos2 = pos1 + 1;\\n            \\n            ans = pos1 + (n-1-pos2) + temp;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(nums[0] == 1 and nums[nums.size() - 1] == nums.size()) {\\n            return 0;\\n        }\\n        \\n        int pos1 = -1;\\n        int pos2 = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 1) {\\n                pos1 = i;\\n            }\\n            if(nums[i] == n) {\\n                pos2 = i;\\n            }\\n        }\\n        int ans = 0;\\n        if(pos1 < pos2) {\\n           ans = pos1 + (n - 1 - pos2); \\n        }\\n        \\n        if(pos1 > pos2) {\\n            int temp = pos1 - pos2;\\n            pos1 = pos2;\\n            pos2 = pos1 + 1;\\n            \\n            ans = pos1 + (n-1-pos2) + temp;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595300,
                "title": "simplest-solution-in-java-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int c=0;\\n        while(nums[0]!=1){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        while(nums[nums.length-1]!=nums.length){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==nums.length){\\n                int t=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        return c;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int c=0;\\n        while(nums[0]!=1){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        while(nums[nums.length-1]!=nums.length){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==nums.length){\\n                int t=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        return c;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595277,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx,idx2;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==1) idx=i;\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        int ans=0;\\n        for(int i = idx;i>=0;i--){\\n            if(i==0) break;\\n            swap(nums[i],nums[i-1]);\\n            ans++;\\n        }\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        for(int i = idx2;i<nums.size();i++){\\n            if(i==nums.size()-1) break;\\n            swap(nums[i],nums[i+1]);\\n            ans++;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx,idx2;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==1) idx=i;\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        int ans=0;\\n        for(int i = idx;i>=0;i--){\\n            if(i==0) break;\\n            swap(nums[i],nums[i-1]);\\n            ans++;\\n        }\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        for(int i = idx2;i<nums.size();i++){\\n            if(i==nums.size()-1) break;\\n            swap(nums[i],nums[i+1]);\\n            ans++;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595229,
                "title": "explained-cpp-solution",
                "content": "Certainly! Here\\'s an explanation of the code with comments:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();  // Get the size of the input vector\\n        int s = 0;  // Initialize variable s to store the index of value 1\\n        int e = 0;  // Initialize variable e to store the index of value n\\n\\n        // Loop through each element of the vector\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];  // Get the current element\\n\\n            // Check if the current element is equal to 1 or n\\n            if (val == 1 || val == n) {\\n                if (val == 1) {\\n                    s = i;  // If the element is 1, update s with the current index\\n                } else {\\n                    e = i;  // If the element is n, update e with the current index\\n                }\\n            }\\n        }\\n\\n        int diff = n - e;  // Calculate the difference between n and e\\n        diff--;  // Subtract 1 from diff\\n\\n        int ans = s + diff;  // Calculate ans by adding s and diff\\n\\n        // If s is greater than e, subtract 1 from ans\\n        if (s > e) {\\n            ans--;\\n        }\\n\\n        return ans;  // Return the final ans value\\n    }\\n};\\n```\\n\\nI hope this helps! Let me know if you have any further questions.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();  // Get the size of the input vector\\n        int s = 0;  // Initialize variable s to store the index of value 1\\n        int e = 0;  // Initialize variable e to store the index of value n\\n\\n        // Loop through each element of the vector\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];  // Get the current element\\n\\n            // Check if the current element is equal to 1 or n\\n            if (val == 1 || val == n) {\\n                if (val == 1) {\\n                    s = i;  // If the element is 1, update s with the current index\\n                } else {\\n                    e = i;  // If the element is n, update e with the current index\\n                }\\n            }\\n        }\\n\\n        int diff = n - e;  // Calculate the difference between n and e\\n        diff--;  // Subtract 1 from diff\\n\\n        int ans = s + diff;  // Calculate ans by adding s and diff\\n\\n        // If s is greater than e, subtract 1 from ans\\n        if (s > e) {\\n            ans--;\\n        }\\n\\n        return ans;  // Return the final ans value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595214,
                "title": "semi-order-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        int i=0;\\n        while(i<n){\\n            if(nums[0]==1){\\n                break;\\n            }\\n            if(nums[i]==1&&i!=0){\\n                swap(nums[i],nums[i-1]);\\n                count++;\\n                i--;\\n            }\\n            else i++;\\n        }\\n        int value=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==n)value=i;\\n        }\\n        return count+n-value-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        int i=0;\\n        while(i<n){\\n            if(nums[0]==1){\\n                break;\\n            }\\n            if(nums[i]==1&&i!=0){\\n                swap(nums[i],nums[i-1]);\\n                count++;\\n                i--;\\n            }\\n            else i++;\\n        }\\n        int value=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==n)value=i;\\n        }\\n        return count+n-value-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595139,
                "title": "o-n-approach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0] == 1 && nums[n-1] == n)\\n            return 0;\\n        int lo = 0, hi = n-1;\\n        for(int i = 0;i  < n; i++){\\n            if(nums[i] == 1){\\n                lo = i;\\n            }\\n            if(nums[i] == n){\\n                hi = i;\\n            }\\n        }\\n        int ans;\\n        if(lo > hi){\\n            ans = lo + abs(n-1-hi-1);\\n        }\\n        else{\\n            ans = lo + abs(n-1-hi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0] == 1 && nums[n-1] == n)\\n            return 0;\\n        int lo = 0, hi = n-1;\\n        for(int i = 0;i  < n; i++){\\n            if(nums[i] == 1){\\n                lo = i;\\n            }\\n            if(nums[i] == n){\\n                hi = i;\\n            }\\n        }\\n        int ans;\\n        if(lo > hi){\\n            ans = lo + abs(n-1-hi-1);\\n        }\\n        else{\\n            ans = lo + abs(n-1-hi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595108,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code works based on the intuition that for a semi-ordered permutation, we need to bring the number 1 to the front of the array and the maximum number to the end. The number of elements between these two positions represents the elements that need to be rearranged. By finding the positions of 1 and the maximum number, the code calculates the answer accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses two pointers, l and r, to keep track of the positions of specific numbers in the array.\\n\\nIt iterates over the elements of the array to find the last occurrences of the numbers 1 and the maximum number.\\n\\nIt calculates the answer by adding the position of the last occurrence of 1 (l) and the number of elements between the right pointer (r) and the end of the array.\\n\\nIf there are duplicate elements between the two pointers (l > r), it adjusts the answer by decrementing it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the size of the input array nums. This is because the code iterates over the array once to find the positions of 1 and the maximum number. The time taken is directly proportional to the size of the input array. Therefore, the time complexity is linear with respect to the input size.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1), as it uses a constant amount of extra space to store the left pointer (l), the right pointer (r), and the answer. The space usage does not depend on the size of the input array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int semiOrderedPermutation(vector<int>& nums) {\\n    int l = 0, r = 0;\\n    for(int i = 0; i < nums.size(); i++) {\\n        if(nums[i] == 1)\\n            l = i; // Update the left pointer if the current number is 1\\n        if(nums[i] == nums.size())\\n            r = i; // Update the right pointer if the current number is equal to the size of the array\\n    }\\n    int ans = l + (nums.size() - 1 - r); // Calculate the answer by adding the left pointer position and the number of elements between the right pointer and the end of the array\\n    if(l > r)\\n        ans--; // Adjust the answer if the left pointer is greater than the right pointer\\n    return ans; // Return the calculated answer\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int semiOrderedPermutation(vector<int>& nums) {\\n    int l = 0, r = 0;\\n    for(int i = 0; i < nums.size(); i++) {\\n        if(nums[i] == 1)\\n            l = i; // Update the left pointer if the current number is 1\\n        if(nums[i] == nums.size())\\n            r = i; // Update the right pointer if the current number is equal to the size of the array\\n    }\\n    int ans = l + (nums.size() - 1 - r); // Calculate the answer by adding the left pointer position and the number of elements between the right pointer and the end of the array\\n    if(l > r)\\n        ans--; // Adjust the answer if the left pointer is greater than the right pointer\\n    return ans; // Return the calculated answer\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595053,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(nums[0]==1 && nums[n-1]==n) return 0;\\n        int swaps=0;\\n        int i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) break;\\n        }\\n        for(int x=i; x>=1; x--)\\n        {\\n            swap(nums[x],nums[x-1]);\\n            swaps++;\\n        }\\n        i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==n) break;\\n        }\\n        for(int x=i; x<n-1; x++)\\n        {\\n            swap(nums[x],nums[x+1]);\\n            swaps++;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(nums[0]==1 && nums[n-1]==n) return 0;\\n        int swaps=0;\\n        int i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) break;\\n        }\\n        for(int x=i; x>=1; x--)\\n        {\\n            swap(nums[x],nums[x-1]);\\n            swaps++;\\n        }\\n        i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==n) break;\\n        }\\n        for(int x=i; x<n-1; x++)\\n        {\\n            swap(nums[x],nums[x+1]);\\n            swaps++;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595005,
                "title": "easy-java-fast-brute-force",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n int count=0;\\n        if(nums[0]==1&& nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int indst=0;\\n        int indend=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indst =i;\\n            }\\n            if(nums[i]==nums.length){\\n                indend=i;\\n            }\\n        }\\n        if(indst>indend){\\n            count+=indst+(nums.length-2-indend);\\n        }\\n        else{\\n            count+=indst+nums.length-1-indend;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n int count=0;\\n        if(nums[0]==1&& nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int indst=0;\\n        int indend=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indst =i;\\n            }\\n            if(nums[i]==nums.length){\\n                indend=i;\\n            }\\n        }\\n        if(indst>indend){\\n            count+=indst+(nums.length-2-indend);\\n        }\\n        else{\\n            count+=indst+nums.length-1-indend;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594979,
                "title": "index-of-1-and-n-simple-solution-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int first = 0, last = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n           if(nums[i]==1){\\n               first=i;\\n           }\\n            if(nums[i]==n){\\n                last=i;\\n            }\\n        }\\n        int min = 0;\\n        if(first<last)\\n            min = (first + (n-last-1));\\n        else\\n            min = (first + (n-last-2));\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int first = 0, last = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n           if(nums[i]==1){\\n               first=i;\\n           }\\n            if(nums[i]==n){\\n                last=i;\\n            }\\n        }\\n        int min = 0;\\n        if(first<last)\\n            min = (first + (n-last-1));\\n        else\\n            min = (first + (n-last-2));\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594936,
                "title": "c-easy-solution",
                "content": "The given code represents a solution in C++ for the problem of finding the number of operations required to transform a given permutation of integers into a semi-ordered permutation.\\nThe variable n is assigned the size of the nums vector, which represents the length of the permutation.\\n\\nThe variables s and e are initialized to 0. These variables will track the indices of the first occurrence of 1 and the last occurrence of n, respectively\\n\\nAfter the loop, the variable diff is calculated as the difference between the total length of the permutation n and the index of the last occurrence of n e. This represents the number of elements that need to be moved to the left to transform the permutation into a semi-ordered permutation.\\n\\nThe variable diff is decremented by 1 to exclude the element at index e from the count of operations since it is already in its correct position.\\n\\nThe variable ans is calculated by adding the index of the first occurrence of 1 s and the adjusted diff. This represents the final position of the last element in the semi-ordered permutation.\\n\\nIf s is greater than e, it means that the first occurrence of 1 appears after the last occurrence of n. In this case, ans is decremented by 1 to account for this overlap between the two elements.\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n        int s=0;\\n        int e=0;\\n        for (int i = 0 ; i<n;i++){\\n            int val = nums[i];\\n            if(val ==1 ||val==n){\\n                if (val == 1){\\n                    s = i;\\n                }\\n                else {\\n                    e  = i;\\n                }\\n            }\\n        }\\n        int diff = n - e;\\n        diff--;\\n        int ans = s + diff;\\n        if(s>e){\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n        int s=0;\\n        int e=0;\\n        for (int i = 0 ; i<n;i++){\\n            int val = nums[i];\\n            if(val ==1 ||val==n){\\n                if (val == 1){\\n                    s = i;\\n                }\\n                else {\\n                    e  = i;\\n                }\\n            }\\n        }\\n        int diff = n - e;\\n        diff--;\\n        int ans = s + diff;\\n        if(s>e){\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078796,
                "title": "java-solution-100-faster-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int maxInd = 0;\\n        int minInd = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n                maxInd = i;\\n            }\\n            if(min > nums[i]){\\n                min = nums[i];\\n                minInd = i;\\n            }\\n        }\\n\\n        int count = minInd + nums.length-maxInd-1;\\n\\n        if(minInd > maxInd)\\n            count--;\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int maxInd = 0;\\n        int minInd = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n                maxInd = i;\\n            }\\n            if(min > nums[i]){\\n                min = nums[i];\\n                minInd = i;\\n            }\\n        }\\n\\n        int count = minInd + nums.length-maxInd-1;\\n\\n        if(minInd > maxInd)\\n            count--;\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058631,
                "title": "easier-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMax(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()-1];\\n    }\\n    int findMin(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n    int findInd(int no, vector<int> nums){\\n        for(int i=0;i<=nums.size()-1;i++){\\n            if(nums[i]==no){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int si=nums.size();\\n        int min=findMin(nums);\\n        int max=findMax(nums);\\n        int minInd=findInd(min, nums);\\n        int maxInd=findInd(max, nums);\\n        if(minInd<maxInd){\\n           return minInd + (si-maxInd) - 1;\\n        }\\n        return minInd + (si-maxInd) - 2;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMax(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()-1];\\n    }\\n    int findMin(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n    int findInd(int no, vector<int> nums){\\n        for(int i=0;i<=nums.size()-1;i++){\\n            if(nums[i]==no){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int si=nums.size();\\n        int min=findMin(nums);\\n        int max=findMax(nums);\\n        int minInd=findInd(min, nums);\\n        int maxInd=findInd(max, nums);\\n        if(minInd<maxInd){\\n           return minInd + (si-maxInd) - 1;\\n        }\\n        return minInd + (si-maxInd) - 2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027981,
                "title": "php-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function semiOrderedPermutation($nums) {\\n        $min = min($nums);\\n        $max = max($nums);\\n        $ln = count($nums);\\n        \\n        if ($nums[0] === $min && $nums[$ln - 1] === $max) {\\n            return 0;\\n        }\\n\\n        $minIndex = array_search($min, $nums);\\n        $maxIndex = array_search($max, $nums);\\n        $n = $minIndex > $maxIndex? 2: 1;\\n\\n        return $minIndex + $ln - $maxIndex - $n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function semiOrderedPermutation($nums) {\\n        $min = min($nums);\\n        $max = max($nums);\\n        $ln = count($nums);\\n        \\n        if ($nums[0] === $min && $nums[$ln - 1] === $max) {\\n            return 0;\\n        }\\n\\n        $minIndex = array_search($min, $nums);\\n        $maxIndex = array_search($max, $nums);\\n        $n = $minIndex > $maxIndex? 2: 1;\\n\\n        return $minIndex + $ln - $maxIndex - $n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020620,
                "title": "python-3-solution-beats-60-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse while loops and count the swaps\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - Worst case scenario\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        smallest = min(nums)\\n        largest = max(nums)\\n\\n        count = 0\\n\\n        while nums[0] != smallest:\\n            small_index = nums.index(smallest)\\n            nums[small_index], nums[small_index - 1] = nums[small_index - 1], nums[small_index]\\n            count += 1        \\n        \\n        while nums[-1] != largest:\\n            large_index = nums.index(largest)\\n            nums[large_index], nums[large_index + 1] = nums[large_index + 1], nums[large_index]\\n            count += 1\\n\\n        return count        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        smallest = min(nums)\\n        largest = max(nums)\\n\\n        count = 0\\n\\n        while nums[0] != smallest:\\n            small_index = nums.index(smallest)\\n            nums[small_index], nums[small_index - 1] = nums[small_index - 1], nums[small_index]\\n            count += 1        \\n        \\n        while nums[-1] != largest:\\n            large_index = nums.index(largest)\\n            nums[large_index], nums[large_index + 1] = nums[large_index + 1], nums[large_index]\\n            count += 1\\n\\n        return count        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007684,
                "title": "java-100-o-n-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int indexOfOne = -1;\\n        int indexOfN = -1;\\n        for(int i = 0; i < n; i++){\\n            if(indexOfOne != -1 && indexOfN != -1) break;\\n            if(indexOfOne == -1 && nums[i] == 1) indexOfOne = i;\\n            if(indexOfN == -1 && nums[i] == n) indexOfN = i;\\n        }\\n        if(indexOfN < indexOfOne) return indexOfOne + (n-1 - indexOfN) - 1;\\n        return indexOfOne + (n-1 - indexOfN);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int indexOfOne = -1;\\n        int indexOfN = -1;\\n        for(int i = 0; i < n; i++){\\n            if(indexOfOne != -1 && indexOfN != -1) break;\\n            if(indexOfOne == -1 && nums[i] == 1) indexOfOne = i;\\n            if(indexOfN == -1 && nums[i] == n) indexOfN = i;\\n        }\\n        if(indexOfN < indexOfOne) return indexOfOne + (n-1 - indexOfN) - 1;\\n        return indexOfOne + (n-1 - indexOfN);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992262,
                "title": "semi-ordered-permutation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    find the index of 1 and n in the given array.\\n    based on the index value of 1 and n we just need to find the \\n    number of swap required to take 1 and n to the 0th and n-1th index\\n    \\n    for 1 the number of swap required to bring it to 0th index is\\n    same as the index at which it was found. ( you can try it out)\\n\\n    for n the number of swap required to bring it to n-1th index is \\n    equal to (n-i-index_max). where index_max is the index where n \\n    was found.\\n    hence return the total of swap for 1 and n. \\n\\n    but there is one exception if the index_max < index_min then we \\n    must return total - 1 because one swap will be counted twice \\n    one during swapping of 1 and one during swapping of n. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max_index = -1;\\n        int min_index = -1;\\n        \\n        for(int i = 0; i< nums.length; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                min_index = i;\\n            }\\n            if(nums[i] == nums.length)\\n            {\\n                max_index = i;\\n            }\\n            if(max_index != -1 && min_index != -1) break;\\n        }\\n        \\n        if(max_index > min_index) {\\n            return min_index + nums.length-1 - max_index; \\n        }else{\\n             return min_index + nums.length-2 - max_index;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max_index = -1;\\n        int min_index = -1;\\n        \\n        for(int i = 0; i< nums.length; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                min_index = i;\\n            }\\n            if(nums[i] == nums.length)\\n            {\\n                max_index = i;\\n            }\\n            if(max_index != -1 && min_index != -1) break;\\n        }\\n        \\n        if(max_index > min_index) {\\n            return min_index + nums.length-1 - max_index; \\n        }else{\\n             return min_index + nums.length-2 - max_index;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983842,
                "title": "c-solution-o-n-s-1",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int idx_1 = 0;\\n        int idx_n = 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                idx_1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                idx_n = i;\\n            }\\n        }\\n\\n        int res = 0;\\n        res -= (idx_n < idx_1);\\n\\n        res += idx_1;\\n        res += nums.size() - idx_n - 1;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int idx_1 = 0;\\n        int idx_n = 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                idx_1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                idx_n = i;\\n            }\\n        }\\n\\n        int res = 0;\\n        res -= (idx_n < idx_1);\\n\\n        res += idx_1;\\n        res += nums.size() - idx_n - 1;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976732,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-99-memory",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int output = 0;\\n        int t = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                output += i;\\n                t = i;\\n                i = nums.length;\\n            }\\n            while (t > 0) {\\n                int temp = nums[t-1];\\n                nums[t] = temp;\\n                nums[--t] = 1;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == nums.length) {\\n                output += nums.length - 1 - i;\\n                break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int output = 0;\\n        int t = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                output += i;\\n                t = i;\\n                i = nums.length;\\n            }\\n            while (t > 0) {\\n                int temp = nums[t-1];\\n                nums[t] = temp;\\n                nums[--t] = 1;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == nums.length) {\\n                output += nums.length - 1 - i;\\n                break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960477,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l = nums.index(min(nums))\\n        count = 0\\n\\n        while l >= 1:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            count += 1\\n        \\n        r = nums.index(max(nums))\\n\\n        while r < len(nums) - 1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            count += 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l = nums.index(min(nums))\\n        count = 0\\n\\n        while l >= 1:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            count += 1\\n        \\n        r = nums.index(max(nums))\\n\\n        while r < len(nums) - 1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956485,
                "title": "easy-python-pointer-solution-beats-97-64-11-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we find where \\'1\\' and \\'n\\' are and grab their indices. Then we bubble \\'1\\' to the first of the array counting passes as we go. Then we bubble \\'n\\' to the end of the array counting passes as we go.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        res = 0\\n        l = nums.index(1)\\n        while l != 0:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            res += 1\\n        r = nums.index(len(nums))\\n        while r != len(nums)-1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            res += 1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        res = 0\\n        l = nums.index(1)\\n        while l != 0:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            res += 1\\n        r = nums.index(len(nums))\\n        while r != len(nums)-1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917935,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n       int i1=0,i2=0;\\n    \\tint n=nums.length;\\n    \\t\\n    \\tfor(int i=0;i<n;i++) {\\n    \\t\\tif(nums[i]==1) {\\n    \\t\\t\\ti1=i;\\n    \\t\\t}\\n    \\t\\tif(nums[i]==n) {\\n    \\t\\t\\ti2=i;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tif(i1<i2) {\\n    \\t\\treturn i1+(n-1)-i2;\\n    \\t}else {\\n    \\t\\treturn i1+(n-2)-i2;\\n    \\t} \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n       int i1=0,i2=0;\\n    \\tint n=nums.length;\\n    \\t\\n    \\tfor(int i=0;i<n;i++) {\\n    \\t\\tif(nums[i]==1) {\\n    \\t\\t\\ti1=i;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3910195,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the given 0-indexed array, we are allowed to perform swap on any two adjacent elements unit we make array nums a semi-ordered permutation.\\nwe can perform swap on element valued 1 to make it reach index 0.\\nSimilarly, we perform swap on element valued n (which is also the size of the array nums) till it reaches the last index that is (n-1).\\nWe return the number of swaps required in this process.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n          int n=nums.length;\\n        int cnt=0;\\n        boolean f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                      int temp= nums[i];\\n                      nums[i]=nums[i+1];\\n                      nums[i+1]=temp;\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                     int temp= nums[i-1];\\n                     nums[i-1]=nums[i];\\n                     nums[i]=temp;\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n          int n=nums.length;\\n        int cnt=0;\\n        boolean f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                      int temp= nums[i];\\n                      nums[i]=nums[i+1];\\n                      nums[i+1]=temp;\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                     int temp= nums[i-1];\\n                     nums[i-1]=nums[i];\\n                     nums[i]=temp;\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892012,
                "title": "c-solution-using-only-for-loops",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n      int one=0;\\n      int last=0;\\n      int ans=0;\\n      int n=nums.size();\\n      if(nums[0]!=1){\\n          for(int i=0; i<n; i++){\\n              if(nums[i]==1){\\n                 one=i;\\n                  break;\\n              }\\n          }\\n          for(int i=one; i>0; i--){\\n              nums[i]=nums[i-1];\\n              ans++;\\n          }\\n          nums[0]=1;\\n      }\\n\\n      if(nums[n-1]!=n){\\n           for(int i=0; i<n; i++){\\n              if(nums[i]==n){\\n                   last=i;\\n                  break;\\n              }\\n      }\\n       for(int i=last; i<n-1; i++){\\n              nums[i]=nums[i+1];\\n              ans++;\\n          }\\n          nums[n-1]=n;\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n      int one=0;\\n      int last=0;\\n      int ans=0;\\n      int n=nums.size();\\n      if(nums[0]!=1){\\n          for(int i=0; i<n; i++){\\n              if(nums[i]==1){\\n                 one=i;\\n                  break;\\n              }\\n          }\\n          for(int i=one; i>0; i--){\\n              nums[i]=nums[i-1];\\n              ans++;\\n          }\\n          nums[0]=1;\\n      }\\n\\n      if(nums[n-1]!=n){\\n           for(int i=0; i<n; i++){\\n              if(nums[i]==n){\\n                   last=i;\\n                  break;\\n              }\\n      }\\n       for(int i=last; i<n-1; i++){\\n              nums[i]=nums[i+1];\\n              ans++;\\n          }\\n          nums[n-1]=n;\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889234,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int max = 0; \\n        int min = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) min = i;\\n            if(nums[i] == n) max = i;\\n        }\\n\\n        return (min <  max) ? n - 1 - max + min :  n - 1 - max + min - 1;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int max = 0; \\n        int min = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) min = i;\\n            if(nums[i] == n) max = i;\\n        }\\n\\n        return (min <  max) ? n - 1 - max + min :  n - 1 - max + min - 1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865059,
                "title": "simple-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function(nums) {\\n  const length = nums.length;\\n  const positionOf1 = nums.indexOf(1);\\n  const positionOfMaxNum = nums.indexOf(length);\\n  const minimumSwap = positionOf1 + (length - positionOfMaxNum - 1);\\n\\n  return (positionOf1 < positionOfMaxNum) ? minimumSwap : minimumSwap - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function(nums) {\\n  const length = nums.length;\\n  const positionOf1 = nums.indexOf(1);\\n  const positionOfMaxNum = nums.indexOf(length);\\n  const minimumSwap = positionOf1 + (length - positionOfMaxNum - 1);\\n\\n  return (positionOf1 < positionOfMaxNum) ? minimumSwap : minimumSwap - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864561,
                "title": "java-1ms-beats-100-00",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int idxOf1 = -1;\\n        int idxOfN = -1;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == 1) {\\n                idxOf1 = i;\\n            } else if (nums[i] == n) {\\n                idxOfN = i;\\n            }\\n        }\\n\\n        if (idxOf1 < idxOfN) {\\n            return idxOf1 + (n - idxOfN - 1);\\n        } else {  // idxOf1 > idxOfN\\n            return idxOf1 + (n - idxOfN - 2);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int idxOf1 = -1;\\n        int idxOfN = -1;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == 1) {\\n                idxOf1 = i;\\n            } else if (nums[i] == n) {\\n                idxOfN = i;\\n            }\\n        }\\n\\n        if (idxOf1 < idxOfN) {\\n            return idxOf1 + (n - idxOfN - 1);\\n        } else {  // idxOf1 > idxOfN\\n            return idxOf1 + (n - idxOfN - 2);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864057,
                "title": "semi-ordered-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums[0]==1 and nums[-1]==len(nums):\\n            return 0\\n        num=0\\n        while nums[-1]!=len(nums):\\n            nummax=nums.index(len(nums))\\n            nums[nummax],nums[nummax+1]=nums[nummax+1],len(nums)\\n            num+=1\\n        while nums[0]!=1:\\n            nummin=nums.index(1)\\n            nums[nummin],nums[nummin-1]=nums[nummin-1],1\\n            num+=1\\n        return num\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums[0]==1 and nums[-1]==len(nums):\\n            return 0\\n        num=0\\n        while nums[-1]!=len(nums):\\n            nummax=nums.index(len(nums))\\n            nums[nummax],nums[nummax+1]=nums[nummax+1],len(nums)\\n            num+=1\\n        while nums[0]!=1:\\n            nummin=nums.index(1)\\n            nums[nummin],nums[nummin-1]=nums[nummin-1],1\\n            num+=1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862667,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        \\n        let f = nums.firstIndex(of: 1)!\\n        let l = nums.firstIndex(of: nums.count)!\\n        \\n        var res = f + (nums.count - l - 1)\\n\\n        if l < f { res -= 1 }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        \\n        let f = nums.firstIndex(of: 1)!\\n        let l = nums.firstIndex(of: nums.count)!\\n        \\n        var res = f + (nums.count - l - 1)\\n\\n        if l < f { res -= 1 }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857591,
                "title": "best-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1&&nums[n-1]==n) return 0;\\n        int a,b;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) a=i;\\n            if(nums[i]==n) b=i;\\n        }\\n        if(a>b){\\n            return a+(n-1)-b-1;\\n        }\\n        else\\n            return a+(n-1)-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1&&nums[n-1]==n) return 0;\\n        int a,b;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) a=i;\\n            if(nums[i]==n) b=i;\\n        }\\n        if(a>b){\\n            return a+(n-1)-b-1;\\n        }\\n        else\\n            return a+(n-1)-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853758,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplementation\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=0;\\n        int pos1=-1,pos2=-1;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==1)pos1=i;\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==nums.size())pos2=i;\\n        }\\n\\n        int n=nums.size();\\n        ++pos1,++pos2;\\n\\n        ans=abs(1-pos1)+abs(pos2-n);\\n        if(pos1>pos2)--ans;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=0;\\n        int pos1=-1,pos2=-1;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==1)pos1=i;\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==nums.size())pos2=i;\\n        }\\n\\n        int n=nums.size();\\n        ++pos1,++pos2;\\n\\n        ans=abs(1-pos1)+abs(pos2-n);\\n        if(pos1>pos2)--ans;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841295,
                "title": "brutefoce-easiest-approac-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[0]!=1){\\n                for(int j=1;j<nums.length;j++){\\n                    if(nums[j]==1){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j-1];\\n                        nums[j-1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        \\n        }\\n        int last=nums.length-1;\\n        int acc=nums.length;\\n\\n        for(int i=last;i>=0;i--){\\n            if(nums[last]!=nums.length){\\n                for(int j=last-1;j>=0;j--){\\n                    if(nums[j]==acc){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j+1];\\n                        nums[j+1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            System.out.print(nums[i]+\" \");\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[0]!=1){\\n                for(int j=1;j<nums.length;j++){\\n                    if(nums[j]==1){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j-1];\\n                        nums[j-1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        \\n        }\\n        int last=nums.length-1;\\n        int acc=nums.length;\\n\\n        for(int i=last;i>=0;i--){\\n            if(nums[last]!=nums.length){\\n                for(int j=last-1;j>=0;j--){\\n                    if(nums[j]==acc){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j+1];\\n                        nums[j+1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            System.out.print(nums[i]+\" \");\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837038,
                "title": "c-simple-iteration-easy-and-understandable-clean-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind index of 1 and n let x is index of 1 and y is index of n then \\n\\nlets tae an example\\n\\n     [2, 6 , 7 , 8 , 9 , 1 , 4 , 10 , 5 , 15 , 12 , 13 , 14 , 11 , 3 ]\\n\\n\\n\\nhere x = 5 and y = 9 \\n\\n\\nif x < y so in this case to move 1 to the 0th position we need x operation and to move 15 to 14th position we need 14 -9 or  n-1-y\\n\\n\\n\\nnow another case \\n\\n\\nnow if  x > y\\n\\n     [2, 6 , 7 , 8 , 9 , 15 , 4 , 10 , 5 , 1 , 12 , 13 , 14 , 11 , 3 ]\\n\\nhere x = 9  and y = 5 \\n\\nnow first we move 1 to 0th position  so array will be \\n\\n    [1, 2 , 6 , 7 , 8 , 9 , 15 , 4 , 10 , 5 , 12 , 13 , 14 , 11 , 3 ]\\n\\nnow value of y is chaneged  y = 5 to y =6 means in this need 14 -6 = 8 operations\\n\\nmeas if  x > y then we need 1 operation less than if x<y\\n\\n\\n\\n\\n\\nfinal \\n\\nif(x>y) return   return  x  + n-2 - y ;\\nif(x<y) return  return  x  + n-1 - y ;\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Iteration\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n.\\n.\\n.\\n.\\n.\\n\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\n\\n.\\n.\\n.\\n.\\n.\\n\\n# Code\\n\\n\\n\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n = nums.size() ;\\n        int x = 0 ,  y  = 0 ;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) x = i ;\\n            else if(nums[i]==n) y = i ;\\n        }\\n        if(x > y) return  x  + n-2 - y ;\\n        return x  + n-1 - y ;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n = nums.size() ;\\n        int x = 0 ,  y  = 0 ;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) x = i ;\\n            else if(nums[i]==n) y = i ;\\n        }\\n        if(x > y) return  x  + n-2 - y ;\\n        return x  + n-1 - y ;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826272,
                "title": "48ms-beats-100-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of swaps depends on the initial positions of the lowest and highest values in the array.\\n\\nIf the index of the maximum value is lower than the index of the minimum value, you can swap both of their places in one swap, thus we need to take this into account by subtracting 1 if this is the case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the index of the max and min values\\n2. Calculate how far the max is from the end (from `nums.length - 1`)\\n3. Calculate how far the min is from the start (Basically just the index of the min value)\\n4. Add these 2 values from steps 2 and 3 to get the answer, but if the index of the max value is lower than the index of the min value, subtract 1\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const maximum = nums.indexOf(Math.max(...nums))\\n    const minimum = nums.indexOf(Math.min(...nums))\\n\\n    return maximum < minimum ? (nums.length - 1 - maximum) + minimum - 1 : (nums.length - 1 - maximum) + minimum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const maximum = nums.indexOf(Math.max(...nums))\\n    const minimum = nums.indexOf(Math.min(...nums))\\n\\n    return maximum < minimum ? (nums.length - 1 - maximum) + minimum - 1 : (nums.length - 1 - maximum) + minimum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803742,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        \\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == 1){\\n                nums.erase(nums.begin() + i);\\n                ans += i;\\n                break;\\n            }\\n        }\\n\\n        nums.insert(nums.begin() , 1);\\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == n){\\n                ans += n-1-i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        \\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == 1){\\n                nums.erase(nums.begin() + i);\\n                ans += i;\\n                break;\\n            }\\n        }\\n\\n        nums.insert(nums.begin() , 1);\\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == n){\\n                ans += n-1-i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793561,
                "title": "swift-simple-solution-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var l = -1\\n        var r = -1\\n        var pointer = 0\\n        \\n        while l == -1 || r == -1 {\\n            if nums[pointer] == 1 {\\n                l = pointer\\n            } else if nums[pointer] == nums.count {\\n                r = pointer\\n            }\\n            pointer += 1\\n        }\\n        \\n        let count = l + nums.count - 1 - r\\n\\n        return l < r ? count : count - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var l = -1\\n        var r = -1\\n        var pointer = 0\\n        \\n        while l == -1 || r == -1 {\\n            if nums[pointer] == 1 {\\n                l = pointer\\n            } else if nums[pointer] == nums.count {\\n                r = pointer\\n            }\\n            pointer += 1\\n        }\\n        \\n        let count = l + nums.count - 1 - r\\n\\n        return l < r ? count : count - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786054,
                "title": "esay",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i1 = nums.index(1)\\n        i2 = nums.index(n)\\n        c = i1+(n-i2-1)\\n        if i2<i1:\\n            c-=1 \\n        return c\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i1 = nums.index(1)\\n        i2 = nums.index(n)\\n        c = i1+(n-i2-1)\\n        if i2<i1:\\n            c-=1 \\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784381,
                "title": "cpp-very-easy-beginner-lvl-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int index=0;\\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == 1 ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int op = 0;\\n        if( index != 0){\\n            for( int i = index ; i > 0 ; i--){\\n                swap(nums[i],nums[i-1]);\\n                op++;\\n            }\\n        }\\n        \\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == nums.size() ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if( index != nums.size()-1 ){\\n            for( int i = index ; i<nums.size()-1 ;i++){\\n                swap(nums[i] , nums[i+1]);\\n                op++;\\n            }\\n        }\\n        \\n        return op;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int index=0;\\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == 1 ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int op = 0;\\n        if( index != 0){\\n            for( int i = index ; i > 0 ; i--){\\n                swap(nums[i],nums[i-1]);\\n                op++;\\n            }\\n        }\\n        \\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == nums.size() ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if( index != nums.size()-1 ){\\n            for( int i = index ; i<nums.size()-1 ;i++){\\n                swap(nums[i] , nums[i+1]);\\n                op++;\\n            }\\n        }\\n        \\n        return op;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777106,
                "title": "easy-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        // Get the indexes of 1 and n as p1 and p2\\n        int p1= 0;\\n        int p2 = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] ==1){\\n                p1 = i;\\n            }\\n            else if(nums[i] == n){\\n                p2 = i;\\n            }\\n        }\\n        /*if 1 is before n then simply 1 and n will swap without altering each other\\'s coordinates*/ \\n        int temp = p1 + (n-1-p2);\\n        /*else if n is before 1 then we will encounter n thus swapping and taking n an index close to its final position thereby reducing moves required by 1*/\\n        if(p1>p2){\\n            return temp-1;\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        // Get the indexes of 1 and n as p1 and p2\\n        int p1= 0;\\n        int p2 = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] ==1){\\n                p1 = i;\\n            }\\n            else if(nums[i] == n){\\n                p2 = i;\\n            }\\n        }\\n        /*if 1 is before n then simply 1 and n will swap without altering each other\\'s coordinates*/ \\n        int temp = p1 + (n-1-p2);\\n        /*else if n is before 1 then we will encounter n thus swapping and taking n an index close to its final position thereby reducing moves required by 1*/\\n        if(p1>p2){\\n            return temp-1;\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775782,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    let min = 0;\\n    let max = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) min = i;\\n        if (nums[i] === nums.length) max = i;\\n    }\\n    let result = min + (nums.length - max - 1)\\n    return min < max ? result : result-1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    let min = 0;\\n    let max = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) min = i;\\n        if (nums[i] === nums.length) max = i;\\n    }\\n    let result = min + (nums.length - max - 1)\\n    return min < max ? result : result-1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770810,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn semi_ordered_permutation(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let first = nums.iter().position(|&x| x == 1).unwrap();\\n        let last = nums.iter().position(|&x| x == n as i32).unwrap();\\n\\n        if first < last {\\n            (first + n - last - 1) as _\\n        } else {\\n            (first + n - last - 2) as _\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn semi_ordered_permutation(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let first = nums.iter().position(|&x| x == 1).unwrap();\\n        let last = nums.iter().position(|&x| x == n as i32).unwrap();\\n\\n        if first < last {\\n            (first + n - last - 1) as _\\n        } else {\\n            (first + n - last - 2) as _\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3769993,
                "title": "semiorderedpermutation",
                "content": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int min = nums.Min();\\n        int max = nums.Max();\\n\\n        int indexOfMin = Array.IndexOf(nums, min);\\n        int indexOfMax = Array.IndexOf(nums, max);\\n\\n        int swaps = 0;\\n       \\n        if(indexOfMin == 0 && indexOfMax + 1 == nums.Length) return 0;\\n        if(nums.Length == 2) return swaps = (indexOfMin == 0) ? 0:1;\\n\\n        swaps += indexOfMin;\\n        swaps += nums.Length - (indexOfMax+1);\\n        if(indexOfMax < indexOfMin) swaps-=1;\\n\\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int min = nums.Min();\\n        int max = nums.Max();\\n\\n        int indexOfMin = Array.IndexOf(nums, min);\\n        int indexOfMax = Array.IndexOf(nums, max);\\n\\n        int swaps = 0;\\n       \\n        if(indexOfMin == 0 && indexOfMax + 1 == nums.Length) return 0;\\n        if(nums.Length == 2) return swaps = (indexOfMin == 0) ? 0:1;\\n\\n        swaps += indexOfMin;\\n        swaps += nums.Length - (indexOfMax+1);\\n        if(indexOfMax < indexOfMin) swaps-=1;\\n\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766730,
                "title": "very-easy-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int fir = -1, last = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 1){\\n                fir = i;\\n                break;\\n            }\\n        }\\n\\n        if(fir != 0){\\n            for(int i=fir; i>=1; i--){\\n                swap(nums[i], nums[i-1]);\\n                count++;\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == n){\\n                last = i;\\n                break;\\n            }\\n        }\\n\\n        if(last != n-1){\\n            for(int i=last; i<n-1; i++){\\n                swap(nums[i], nums[i+1]);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int fir = -1, last = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 1){\\n                fir = i;\\n                break;\\n            }\\n        }\\n\\n        if(fir != 0){\\n            for(int i=fir; i>=1; i--){\\n                swap(nums[i], nums[i-1]);\\n                count++;\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == n){\\n                last = i;\\n                break;\\n            }\\n        }\\n\\n        if(last != n-1){\\n            for(int i=last; i<n-1; i++){\\n                swap(nums[i], nums[i+1]);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746225,
                "title": "java-o-n-100-faster",
                "content": "In the end, **b** shows the distance between largest number and the end of the array.\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 1, b = nums.length, idxA = 0, idxB = 0, res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == a) idxA = i;\\n            if (nums[i] == b) idxB = i;\\n        }\\n        b = b - idxB - 1;\\n        return idxB < idxA ? idxA + b - 1 : idxA + b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 1, b = nums.length, idxA = 0, idxB = 0, res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == a) idxA = i;\\n            if (nums[i] == b) idxB = i;\\n        }\\n        b = b - idxB - 1;\\n        return idxB < idxA ? idxA + b - 1 : idxA + b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732498,
                "title": "find-position-1-and-n-c",
                "content": "\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int x = 0, y = 0, swp = 0, n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) x = i;\\n            if(nums[i] == n) y = n - i - 1;\\n            if(y && x == 0 && nums[0] != 1) swp = 1;\\n        }\\n        return x + y - swp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int x = 0, y = 0, swp = 0, n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) x = i;\\n            if(nums[i] == n) y = n - i - 1;\\n            if(y && x == 0 && nums[0] != 1) swp = 1;\\n        }\\n        return x + y - swp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729288,
                "title": "javascript-bubblesort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    return bubbleSort(nums)\\n};\\n\\nfunction bubbleSort(arr) {\\n  \\n    var i, j;\\n    var len = arr.length;\\n    let count = 0;\\n  \\n    var isSwapped = false;\\n  \\n    for (i = 0; i < len; i++) {\\n  \\n        isSwapped = false;\\n  \\n        for (j = 0; j < len; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                var temp = arr[j]\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n                isSwapped = true;\\n\\n                if (\\n                    (arr[j] == 1 || arr[j+1] == len) ||\\n                    (arr[j+1] == 1 || arr[j] == len)\\n                )\\n                count++;\\n            }\\n        }\\n  \\n        if (!isSwapped) {\\n            break;\\n        }\\n    }\\n  \\n    //return arr\\n    return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    return bubbleSort(nums)\\n};\\n\\nfunction bubbleSort(arr) {\\n  \\n    var i, j;\\n    var len = arr.length;\\n    let count = 0;\\n  \\n    var isSwapped = false;\\n  \\n    for (i = 0; i < len; i++) {\\n  \\n        isSwapped = false;\\n  \\n        for (j = 0; j < len; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                var temp = arr[j]\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n                isSwapped = true;\\n\\n                if (\\n                    (arr[j] == 1 || arr[j+1] == len) ||\\n                    (arr[j+1] == 1 || arr[j] == len)\\n                )\\n                count++;\\n            }\\n        }\\n  \\n        if (!isSwapped) {\\n            break;\\n        }\\n    }\\n  \\n    //return arr\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3725988,
                "title": "basic-c-solution-easy-to-understand-explained-beats-90-runtime-and-memory-beginner",
                "content": "# Intuition\\nSure! Let me explain the code in first person and discuss its complexity.\\n\\nIn this code, I see a class named `Solution` with a member function `semiOrderedPermutation`. This function takes a reference to a vector of integers `nums` as input and calculates a count value based on certain conditions.\\n\\n# Approach\\n\\nNow, let\\'s go through the code step by step:\\n\\n1. First, there is an `if` condition that checks if the first element of `nums` is `1` and the last element is equal to the size of `nums`. If this condition is true, it means that the vector is already a semi-ordered permutation, and there is no need to perform any operations. In this case, the function returns `0`.\\n\\n2. If the condition in the previous step is not met, the code initializes a variable `count` to `0`. This variable will be used to keep track of the count value.\\n\\n3. The code then enters a `for` loop that iterates over the elements of the `nums` vector. Inside this loop:\\n   - It checks if the current element is equal to `1`.\\n   - If the condition is true, it means that we have found the first element of the permutation. We update the `count` by adding the current index `i` to it. This is because we want to count the number of swaps required to bring the first element (`1`) to its correct position.\\n   - Next, there is a nested `while` loop that performs the actual swapping of elements. Starting from the current index `j = i`, it iterates backwards and swaps `nums[j]` with `nums[j-1]` until `j` becomes `0`. This effectively moves the first element to the front of the vector.\\n\\n4. After the first loop finishes, the code enters another `for` loop that iterates over the elements of `nums` once again. Inside this loop:\\n   - It checks if the current element is equal to the size of `nums`. If the condition is true, it means we have found the last element of the permutation. We update the `count` by adding the difference between `(nums.size() - 1)` and the current index `i` to it. This accounts for the number of swaps required to bring the last element to its correct position.\\n\\n5. Finally, the function returns the calculated `count` value, representing the number of swaps needed to obtain a semi-ordered permutation of `nums`.\\n\\n# Complexity\\n- Time complexity : The code runs two nested loops, each iterating over the elements of `nums`, so the time complexity is O(n^2), where n is the size of the vector.\\n\\n- Space complexity : The space complexity of the code is O(1) as it only uses a constant amount of additional space, regardless of the input size.\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/decbf26e-0058-4c78-9c8f-144a49fed944_1688628814.790765.gif)\\n\\n# Do upvote if you like the solution , happy leetcoding\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] == 1 && nums[nums.size()-1] == nums.size())\\n        {\\n            return 0;\\n        }\\n            int count = 0;\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == 1)\\n                {\\n                    count = count + i;\\n                    int j = i;\\n                    while(j>0)\\n                    {\\n                        int temp = nums[j];\\n                        nums[j] = nums[j-1];\\n                        nums[j-1] = temp;\\n                        j--;\\n                    }\\n                }\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == nums.size())\\n                {\\n                    count = count + ((nums.size()-1)-i);\\n                }\\n            }\\n            return count;    \\n    }\\n}; //Please Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] == 1 && nums[nums.size()-1] == nums.size())\\n        {\\n            return 0;\\n        }\\n            int count = 0;\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == 1)\\n                {\\n                    count = count + i;\\n                    int j = i;\\n                    while(j>0)\\n                    {\\n                        int temp = nums[j];\\n                        nums[j] = nums[j-1];\\n                        nums[j-1] = temp;\\n                        j--;\\n                    }\\n                }\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == nums.size())\\n                {\\n                    count = count + ((nums.size()-1)-i);\\n                }\\n            }\\n            return count;    \\n    }\\n}; //Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722194,
                "title": "find-indexof-1-and-lastindexof-n",
                "content": "# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  const firstOne = nums.indexOf(1);\\n  const lastN = nums.lastIndexOf(nums.length);\\n  return firstOne > lastN\\n    ? nums.length - lastN - 2 + firstOne\\n    : nums.length - lastN - 1 + firstOne;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  const firstOne = nums.indexOf(1);\\n  const lastN = nums.lastIndexOf(nums.length);\\n  return firstOne > lastN\\n    ? nums.length - lastN - 2 + firstOne\\n    : nums.length - lastN - 1 + firstOne;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722031,
                "title": "array-manipulation-to-find-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int total_score=0;\\n        int index1=0,index2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n                break;\\n            }\\n        }\\n        nums.erase(nums.begin()+index1);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                index2=i;\\n                break;\\n            }\\n        }\\n        total_score=index1+(nums.size()-1-index2);\\n        return total_score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int total_score=0;\\n        int index1=0,index2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n                break;\\n            }\\n        }\\n        nums.erase(nums.begin()+index1);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                index2=i;\\n                break;\\n            }\\n        }\\n        total_score=index1+(nums.size()-1-index2);\\n        return total_score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714726,
                "title": "python-3-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l  = len(nums)\\n        if nums.index(l) < nums.index(1):\\n            return l - 2 -nums.index(l) + nums.index(1)\\n        if nums.index(l) > nums.index(1):\\n            return l - 1  -nums.index(l) + nums.index(1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l  = len(nums)\\n        if nums.index(l) < nums.index(1):\\n            return l - 2 -nums.index(l) + nums.index(1)\\n        if nums.index(l) > nums.index(1):\\n            return l - 1  -nums.index(l) + nums.index(1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711226,
                "title": "very-simple-short-solution-with-explanation-c",
                "content": "# Intuition\\nThe problem asks for the minimum number of swaps required to transform a given array into a semi-ordered permutation. A semi-ordered permutation is defined as an array where the first element is 1, the last element is n, and all other elements are in increasing order. \\n\\nTo solve this problem, we can find the positions of the elements 1 and n in the given array. Depending on their relative positions, we can determine the minimum number of swaps required to transform the array into a semi-ordered permutation.\\n\\n# Approach\\n1. Find the positions of the elements 1 and n in the given array.\\n2. Calculate the distance of the element 1 from the beginning of the array (`posOne`) and the distance of the element n from the end of the array (`posN`).\\n3. If `posOne` is greater than `posN`, it means that the element 1 is located after the element n in the array. In this case, we need to swap the positions of the elements 1 and n, as well as adjust the positions `posOne` and `posN` accordingly.\\n4. Calculate the minimum number of swaps required by adding `posOne` and `posN` together and subtracting 1 (since we don\\'t need to swap the element 1 with itself).\\n5. If `posOne` is less than or equal to `posN`, it means that the element 1 is located before the element n in the array. In this case, we don\\'t need to swap any elements, so the minimum number of swaps required is equal to `posOne` + `posN`.\\n6. Return the minimum number of swaps as the result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the input array. The algorithm iterates through the array once to find the positions of the elements 1 and n.\\n- Space complexity: O(1). The algorithm uses a constant amount of extra space to store the positions `posOne` and `posN`.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        auto oneFind = find(nums.begin(), nums.end(), 1);\\n        auto nFind = find(nums.begin(), nums.end(), n);\\n\\n        int posOne = distance(nums.begin(), oneFind);\\n        int posN = distance(nums.begin(), nFind);\\n\\n        if (posOne > posN) {\\n            posN = n - posN - 1;\\n            return posOne + posN - 1;\\n        }\\n        \\n        posN = n - posN - 1;\\n        return posOne + posN;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        auto oneFind = find(nums.begin(), nums.end(), 1);\\n        auto nFind = find(nums.begin(), nums.end(), n);\\n\\n        int posOne = distance(nums.begin(), oneFind);\\n        int posN = distance(nums.begin(), nFind);\\n\\n        if (posOne > posN) {\\n            posN = n - posN - 1;\\n            return posOne + posN - 1;\\n        }\\n        \\n        posN = n - posN - 1;\\n        return posOne + posN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697442,
                "title": "java-1000-accurate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n            int one  = 0;\\n        int n = 0;\\n        int ans = 0;\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!( nums[nums.length-1] == nums.length)){\\n            ans++;\\n            int temp = nums[n+1];\\n            nums[n+1] = nums[n];\\n            nums[n] = temp;\\n            n++;\\n        }\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!(nums[0] == 1 )){\\n            ans++;\\n\\n            int temp = nums[one-1];\\n            nums[one-1] = nums[one];\\n            nums[one] = temp;\\n            one--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n            int one  = 0;\\n        int n = 0;\\n        int ans = 0;\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!( nums[nums.length-1] == nums.length)){\\n            ans++;\\n            int temp = nums[n+1];\\n            nums[n+1] = nums[n];\\n            nums[n] = temp;\\n            n++;\\n        }\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!(nums[0] == 1 )){\\n            ans++;\\n\\n            int temp = nums[one-1];\\n            nums[one-1] = nums[one];\\n            nums[one] = temp;\\n            one--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697333,
                "title": "permutation-js-min-max-indexes-89-93-88-ms",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    a = 1\\n    b = nums.length\\n\\n    x = nums.indexOf(a)\\n    y = nums.indexOf(b)\\n\\n    return x < y ? (b - 1) - y + x : (b - 1) - y + x - 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    a = 1\\n    b = nums.length\\n\\n    x = nums.indexOf(a)\\n    y = nums.indexOf(b)\\n\\n    return x < y ? (b - 1) - y + x : (b - 1) - y + x - 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3693002,
                "title": "very-easy-ts-js-solution-by-just-swapping-elements",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur goal is to bring the smallest element that is 1 to the start of the array and N i.e nums.length to the end of the array. \\nSo we create two functions let say swapFirstIndex() which swaps elements starting from the index where 1 is present, untill 1 comes to the start of the array. \\nThen we create another function swapLastIndex() which elements starting from the index where n is present, untill n comes to the end of the array.\\n\\nAnd every time we do the swap we increase the counter in both the functions. \\n\\n**Note** - To find the index of 1 and n we use indexOf() function.\\n\\n**If you find my solution easy to understand and helpful, please upvote. It motivates me to post more solutions**\\n**Happy Coding !!**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let count = 0\\n    let n = nums.length\\n    if(nums[0] == 1 && nums[n-1] == n){\\n        return count\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] == n){\\n        return swapFirstIndex(nums,count)\\n    }\\n\\n    if(nums[0] == 1 && nums[n-1] !== n){\\n        return swapLastIndex(nums,count,n)\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] !== n){\\n        return swapFirstIndex(nums,count) + swapLastIndex(nums,count,n)\\n    }\\n};\\n\\nfunction swapFirstIndex(nums,count){\\n    while(!(nums[0] == 1)){\\n        let indexOne = nums.indexOf(1)\\n        let right = indexOne\\n        let left = right - 1\\n            \\n        let temp = nums[right]\\n        nums[right] = nums[left]\\n        nums[left] = temp\\n        count ++\\n    }\\n    return count\\n}\\n\\nfunction swapLastIndex(nums,count,n){\\n    while(!(nums[n-1] == n)){\\n        let indexOne = nums.indexOf(n)\\n        let left = indexOne\\n        let right = left + 1\\n        \\n        let temp = nums[left]\\n        nums[left] = nums[right]\\n        nums[right] = temp\\n        \\n        count ++\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let count = 0\\n    let n = nums.length\\n    if(nums[0] == 1 && nums[n-1] == n){\\n        return count\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] == n){\\n        return swapFirstIndex(nums,count)\\n    }\\n\\n    if(nums[0] == 1 && nums[n-1] !== n){\\n        return swapLastIndex(nums,count,n)\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] !== n){\\n        return swapFirstIndex(nums,count) + swapLastIndex(nums,count,n)\\n    }\\n};\\n\\nfunction swapFirstIndex(nums,count){\\n    while(!(nums[0] == 1)){\\n        let indexOne = nums.indexOf(1)\\n        let right = indexOne\\n        let left = right - 1\\n            \\n        let temp = nums[right]\\n        nums[right] = nums[left]\\n        nums[left] = temp\\n        count ++\\n    }\\n    return count\\n}\\n\\nfunction swapLastIndex(nums,count,n){\\n    while(!(nums[n-1] == n)){\\n        let indexOne = nums.indexOf(n)\\n        let left = indexOne\\n        let right = left + 1\\n        \\n        let temp = nums[left]\\n        nums[left] = nums[right]\\n        nums[right] = temp\\n        \\n        count ++\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691144,
                "title": "video-walkthrough",
                "content": "https://youtu.be/jdyrzn5KGqI",
                "solutionTags": [
                    "C++"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3685238,
                "title": "a-math-asb-solution",
                "content": "# Approach\\nCheck if the permutation is already semi-ordered. If so, return 0. If not, continue on to get the index of 1 and `n`. Return the sum of the distance of 1 from the 0-index and the distance of `n` from the (n-1)-index, which represents the path each value must take to its semi-ordered position. If these paths overlap (the index of `n` is less than the index of 1), then reduce this sum by one. This is because they will eventually end up being swapped with each other, moving both one index closer to the positions with only one move. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        if (nums[0] == 1 && nums[n - 1] == n) return 0;\\n\\n        int pos1 = -1, posN = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) pos1 = i;\\n            else if (nums[i] == n) posN = i;\\n            if (pos1 != -1 && posN != -1) break;\\n        }\\n\\n        int overlap = posN < pos1 ? -1 : 0;\\n        return Math.abs(0 - pos1) + Math.abs(n - 1 - posN) + overlap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        if (nums[0] == 1 && nums[n - 1] == n) return 0;\\n\\n        int pos1 = -1, posN = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) pos1 = i;\\n            else if (nums[i] == n) posN = i;\\n            if (pos1 != -1 && posN != -1) break;\\n        }\\n\\n        int overlap = posN < pos1 ? -1 : 0;\\n        return Math.abs(0 - pos1) + Math.abs(n - 1 - posN) + overlap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675679,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0]==1 and nums[n-1]==n) return 0;\\n        int low=0;\\n        int high=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) low=i;\\n            if(nums[i]==n) high=i;\\n        }\\n\\n        if(low>high){\\n            return (low-0) + (n-1-high) -1;\\n        }\\n        else return (low-0) + (n-1-high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0]==1 and nums[n-1]==n) return 0;\\n        int low=0;\\n        int high=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) low=i;\\n            if(nums[i]==n) high=i;\\n        }\\n\\n        if(low>high){\\n            return (low-0) + (n-1-high) -1;\\n        }\\n        else return (low-0) + (n-1-high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670489,
                "title": "beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int index1=-1;\\n        int indexN=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1=i;\\n            }\\n            else if(nums[i]==nums.length){\\n                indexN=i;\\n            }\\n        }\\n        return index1+(nums.length-1-indexN)-(index1 > indexN ? 1 : 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int index1=-1;\\n        int indexN=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1=i;\\n            }\\n            else if(nums[i]==nums.length){\\n                indexN=i;\\n            }\\n        }\\n        return index1+(nums.length-1-indexN)-(index1 > indexN ? 1 : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657263,
                "title": "java-easy-solution-beats-100",
                "content": "# Complexity\\n- Time complexity:- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 0;\\n        int b = 0;\\n        int n = nums.length;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1)\\n                a = i;\\n            if(nums[i] == n)\\n                b = i;\\n        }\\n        if(a > b)\\n            b++;\\n        b = n - b - 1;\\n        return a+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 0;\\n        int b = 0;\\n        int n = nums.length;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1)\\n                a = i;\\n            if(nums[i] == n)\\n                b = i;\\n        }\\n        if(a > b)\\n            b++;\\n        b = n - b - 1;\\n        return a+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655641,
                "title": "java-simple-explained",
                "content": "**Idea:** \\n* Keep swapping 1 and n to their left and right neighbors respectively. \\n* You\\'ll notice that the number of swaps required (S) = distance of 1 from start + distance of n from end (but there\\'s a condition)\\n* If 1 is to the left of n, then the above formulat is correct\\n* Else if 1 is to the right of n, then in order to come to the 0th index 1 will swap itself with n, thus bringing down the swap count for n by 1, so anwer here will be S - 1\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int semiOrderedPermutation(int[] nums) {\\n\\tvar oneIdx = -1;\\n\\tvar nIdx = -1;\\n\\tvar n = nums.length;\\n\\n\\tfor (var i = 0; i < n && (oneIdx == -1 || nIdx == -1) ; i++)\\n\\t\\tif (nums[i] == 1)\\n\\t\\t\\toneIdx = i;\\n\\t\\telse if (nums[i] == n)\\n\\t\\t\\tnIdx = i;\\n\\n\\tvar swaps = oneIdx + (n - 1 - nIdx);\\n\\treturn oneIdx < nIdx ? swaps : --swaps;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int semiOrderedPermutation(int[] nums) {\\n\\tvar oneIdx = -1;\\n\\tvar nIdx = -1;\\n\\tvar n = nums.length;\\n\\n\\tfor (var i = 0; i < n && (oneIdx == -1 || nIdx == -1) ; i++)\\n\\t\\tif (nums[i] == 1)\\n\\t\\t\\toneIdx = i;\\n\\t\\telse if (nums[i] == n)\\n\\t\\t\\tnIdx = i;\\n\\n\\tvar swaps = oneIdx + (n - 1 - nIdx);\\n\\treturn oneIdx < nIdx ? swaps : --swaps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650284,
                "title": "simple-java-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] arr) {\\n        int idx1=0;\\n        int idx2=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n            idx1=i;\\n            if(arr[i]==n)\\n            idx2=i;\\n        }\\n        return idx1<idx2 ? idx1+(n-1-idx2) : idx1+(n-1-idx2)-1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] arr) {\\n        int idx1=0;\\n        int idx2=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n            idx1=i;\\n            if(arr[i]==n)\\n            idx2=i;\\n        }\\n        return idx1<idx2 ? idx1+(n-1-idx2) : idx1+(n-1-idx2)-1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648318,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1 and nums[n-1]==n){\\n            return 0;\\n        }\\n       int st,en;\\n       for(int i=0;i<n;i++){\\n         \\n         if(nums[i]==1){\\n             st=i;\\n         }\\n         if(nums[i]==n){\\n             en=i;\\n         }\\n       }\\n      if(st>en)return st+n-en-2;\\n      return st+n-1-en;\\n     \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1 and nums[n-1]==n){\\n            return 0;\\n        }\\n       int st,en;\\n       for(int i=0;i<n;i++){\\n         \\n         if(nums[i]==1){\\n             st=i;\\n         }\\n         if(nums[i]==n){\\n             en=i;\\n         }\\n       }\\n      if(st>en)return st+n-en-2;\\n      return st+n-1-en;\\n     \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648077,
                "title": "simple-solution-by-swapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var c = 0\\n        var temp = 0\\n        var nums = nums\\n        while(true){\\n            if(nums[0] == 1 && nums[nums.count-1] == nums.count){\\n                return c\\n            }else{\\n                for i in 0..<nums.count{\\n                    if(nums[i] == 1 && i != 0){\\n                        temp = nums[i-1]\\n                        nums[i-1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                if(nums[0] == 1){\\n                    for i in 0..<nums.count{\\n                    if(nums[i] == nums.count && i != nums.count-1){\\n                        temp = nums[i+1]\\n                        nums[i+1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var c = 0\\n        var temp = 0\\n        var nums = nums\\n        while(true){\\n            if(nums[0] == 1 && nums[nums.count-1] == nums.count){\\n                return c\\n            }else{\\n                for i in 0..<nums.count{\\n                    if(nums[i] == 1 && i != 0){\\n                        temp = nums[i-1]\\n                        nums[i-1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                if(nums[0] == 1){\\n                    for i in 0..<nums.count{\\n                    if(nums[i] == nums.count && i != nums.count-1){\\n                        temp = nums[i+1]\\n                        nums[i+1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647548,
                "title": "ts-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  let minIndex = 0;\\n  let maxIndex = nums.length - 1\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 1) {\\n      minIndex = i\\n    } else if (nums[i] === nums.length) {\\n      maxIndex = i\\n    }\\n  }\\n  return minIndex + nums.length - 1 - maxIndex - (minIndex > maxIndex ? 1 : 0)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  let minIndex = 0;\\n  let maxIndex = nums.length - 1\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 1) {\\n      minIndex = i\\n    } else if (nums[i] === nums.length) {\\n      maxIndex = i\\n    }\\n  }\\n  return minIndex + nums.length - 1 - maxIndex - (minIndex > maxIndex ? 1 : 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3647435,
                "title": "java-100-beats-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {int c= 0,j=0,k=0;\\n    if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n    {\\n        return 0;\\n    }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                j=i;\\n            }\\n            if(nums[i]==nums.length)\\n            {\\n                k=i;\\n            }\\n        }\\n        if(j<k)\\n        {\\n            c=(j-0)+(nums.length-1-k);\\n        }\\n        if(k<j)\\n        {\\n             c=(j-0)+(nums.length-1-k)-1;\\n        }\\n  return c;  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {int c= 0,j=0,k=0;\\n    if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n    {\\n        return 0;\\n    }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                j=i;\\n            }\\n            if(nums[i]==nums.length)\\n            {\\n                k=i;\\n            }\\n        }\\n        if(j<k)\\n        {\\n            c=(j-0)+(nums.length-1-k);\\n        }\\n        if(k<j)\\n        {\\n             c=(j-0)+(nums.length-1-k)-1;\\n        }\\n  return c;  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647048,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int count =0;\\n        int max = nums.Max();\\n        int maxIndex = Array.IndexOf(nums, max);\\n        int min = nums.Min();\\n        int minIndex = Array.IndexOf(nums, min);\\n        if(minIndex>maxIndex){\\n            maxIndex++;\\n        }\\n        count = minIndex + nums.Length-maxIndex-1;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int count =0;\\n        int max = nums.Max();\\n        int maxIndex = Array.IndexOf(nums, max);\\n        int min = nums.Min();\\n        int minIndex = Array.IndexOf(nums, min);\\n        if(minIndex>maxIndex){\\n            maxIndex++;\\n        }\\n        count = minIndex + nums.Length-maxIndex-1;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646155,
                "title": "eazy-to-understand-c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) check if they are at there desired positions if yes ? return 0.\\n2) find position of 1 (oneIsAt), define a counter (count).\\n3) swap 1 to its desired position and count no.of swaps.\\n4) find the position of n, check whether the last element(n) is at its position if yes return count.\\n> step 4 is important because if we do not check this then n+1 in our next step would throw error \"Array Index Out Of Bound\".\\n5) Swap the n to its place and count no of swaps.\\n6) Return count.\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N) -> worst case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return 0;\\n        }\\n        int oneIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                oneIsAt = i;\\n            }\\n        }\\n       \\n        int count = 0;\\n        while(nums[0] != 1){\\n            swap(nums[oneIsAt] , nums[oneIsAt-1]);\\n            oneIsAt--;\\n            count ++;\\n        }\\n         int nIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == nums.size()){\\n                nIsAt = i;\\n            }\\n        }\\n         if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return count;\\n        }\\n        while(nums[nums.size()-1] != nums.size()){\\n            swap(nums[nIsAt] , nums[nIsAt+1]);\\n            nIsAt++;\\n            count ++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return 0;\\n        }\\n        int oneIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                oneIsAt = i;\\n            }\\n        }\\n       \\n        int count = 0;\\n        while(nums[0] != 1){\\n            swap(nums[oneIsAt] , nums[oneIsAt-1]);\\n            oneIsAt--;\\n            count ++;\\n        }\\n         int nIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == nums.size()){\\n                nIsAt = i;\\n            }\\n        }\\n         if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return count;\\n        }\\n        while(nums[nums.size()-1] != nums.size()){\\n            swap(nums[nIsAt] , nums[nIsAt+1]);\\n            nIsAt++;\\n            count ++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645742,
                "title": "python-3-code-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need to count swaps think like that...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Case 1*:**\\nFirst check is there any need to swap or not.\\n\\n***case 2*:**\\nCheck for *`nums[0] == 1`* if not find the index of` 1 `and store it to `i`(current index) just swap the previous index element with the current index because in question only we need to swap with adjacent element now every swap increase the count by `1`do this until `n` comes in into position.\\n\\n*****case 3***:**\\nCheck for *`nums[len(nums)-1] == len(nums)`* if not find the index of *`len(nums)`* and store it to `i`(current index) just swap the next index element with the current index because in question only we need to swap with adjacent element now every swap increase the count by `1` do this until `n` comes in into position.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        count = 0\\n\\n        #case 1\\n        if nums[0] == 1 and nums[len(nums)-1] == len(nums):\\n            return 0\\n\\n        #case 2\\n        if nums[0] != 1:  \\n            while nums[0] != 1:\\n                i = nums.index(1)                       #finding index\\n                nums[i],nums[i-1] = nums[i-1],nums[i]   # swapping previous index with current index\\n                count += 1\\n\\n        #case 3\\n        if nums[len(nums)-1] != len(nums):  \\n            while nums[len(nums)-1] != len(nums):\\n                i = nums.index(len(nums))                   #finding index\\n                nums[i],nums[i+1] = nums[i+1],nums[i]       # swapping next index with current index\\n                count += 1\\n        \\n        return count\\n\\n```\\n\\nIf there is any mistake/suggestion please let me know below...\\uD83D\\uDC47",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        count = 0\\n\\n        #case 1\\n        if nums[0] == 1 and nums[len(nums)-1] == len(nums):\\n            return 0\\n\\n        #case 2\\n        if nums[0] != 1:  \\n            while nums[0] != 1:\\n                i = nums.index(1)                       #finding index\\n                nums[i],nums[i-1] = nums[i-1],nums[i]   # swapping previous index with current index\\n                count += 1\\n\\n        #case 3\\n        if nums[len(nums)-1] != len(nums):  \\n            while nums[len(nums)-1] != len(nums):\\n                i = nums.index(len(nums))                   #finding index\\n                nums[i],nums[i+1] = nums[i+1],nums[i]       # swapping next index with current index\\n                count += 1\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640995,
                "title": "easy-to-understand-solution-just-3-lines",
                "content": "## Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        first, n_th = nums.index(1), nums.index(n)\\n        return first + n - 1 - n_th - (first > n_th)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        first, n_th = nums.index(1), nums.index(n)\\n        return first + n - 1 - n_th - (first > n_th)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640484,
                "title": "100-beat-java-beginner-friendly-solution",
                "content": "#\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n     int n = nums.length;\\n     int a=0,b=0,c=0;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==1){\\n             a = i;\\n         }\\n     }\\n         while(nums[0]!=1){\\n             int temp = nums[a-1];\\n             nums[a-1] = nums[a];\\n             nums[a] = temp;\\n             a = a-1;\\n             c++;\\n         }\\n         for(int j=0;j<n;j++){\\n         if(nums[j]==n){\\n             b = j;\\n         }\\n     }\\n         while(nums[n-1]!=n && b+1<n){\\n             int t = nums[b+1];\\n             nums[b+1] = nums[b];\\n             nums[b] = t;\\n             b = b+1;\\n             c++;\\n         }\\n     return c;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n     int n = nums.length;\\n     int a=0,b=0,c=0;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==1){\\n             a = i;\\n         }\\n     }\\n         while(nums[0]!=1){\\n             int temp = nums[a-1];\\n             nums[a-1] = nums[a];\\n             nums[a] = temp;\\n             a = a-1;\\n             c++;\\n         }\\n         for(int j=0;j<n;j++){\\n         if(nums[j]==n){\\n             b = j;\\n         }\\n     }\\n         while(nums[n-1]!=n && b+1<n){\\n             int t = nums[b+1];\\n             nums[b+1] = nums[b];\\n             nums[b] = t;\\n             b = b+1;\\n             c++;\\n         }\\n     return c;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639729,
                "title": "c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int firstElIndex = -1;\\n        int lastElIndex = -1;\\n\\n        for(int i=0; i<nums.Length; i++){\\n            if(nums[i] == 1){\\n                firstElIndex = i;\\n            }\\n\\n            if(nums[i] == nums.Length){\\n                lastElIndex = i;\\n            }\\n        }\\n\\n        int numberOfSwaps = firstElIndex + nums.Length - lastElIndex - 1;\\n        return firstElIndex > lastElIndex ? numberOfSwaps - 1 : numberOfSwaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int firstElIndex = -1;\\n        int lastElIndex = -1;\\n\\n        for(int i=0; i<nums.Length; i++){\\n            if(nums[i] == 1){\\n                firstElIndex = i;\\n            }\\n\\n            if(nums[i] == nums.Length){\\n                lastElIndex = i;\\n            }\\n        }\\n\\n        int numberOfSwaps = firstElIndex + nums.Length - lastElIndex - 1;\\n        return firstElIndex > lastElIndex ? numberOfSwaps - 1 : numberOfSwaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639093,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        const auto index1 = find(begin(nums), end(nums), 1);\\n        const auto indexN = find(begin(nums), end(nums), nums.size());\\n        return distance(begin(nums), index1) + distance(indexN, end(nums)) - 1 - (indexN < index1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        const auto index1 = find(begin(nums), end(nums), 1);\\n        const auto indexN = find(begin(nums), end(nums), nums.size());\\n        return distance(begin(nums), index1) + distance(indexN, end(nums)) - 1 - (indexN < index1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629006,
                "title": "java-easy-solution-100-faster-o-n-time-complexity-o-1-space",
                "content": "# Intuition\\nFind total shifts needed to shift 1 and n to correct posiitons.\\n\\n# Approach\\nIf n is present before 1, we would need one less shift, as they both can be shifted once when they cross the path and it would count as 1 operation instead of 2.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = -1;\\n        int lastIndex = -1;\\n        int ops =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 1) oneIndex = i;\\n            if(nums[i] == n) lastIndex = i; \\n        }\\n\\n        //Total Shifts to make 1 reach the start\\n        ops += oneIndex;\\n        //Total Shifts to make n reach the last.\\n        ops += (n-1)-lastIndex;\\n        //If n is before 1, we have to do one less shift.\\n        if(lastIndex < oneIndex) ops--;\\n\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = -1;\\n        int lastIndex = -1;\\n        int ops =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 1) oneIndex = i;\\n            if(nums[i] == n) lastIndex = i; \\n        }\\n\\n        //Total Shifts to make 1 reach the start\\n        ops += oneIndex;\\n        //Total Shifts to make n reach the last.\\n        ops += (n-1)-lastIndex;\\n        //If n is before 1, we have to do one less shift.\\n        if(lastIndex < oneIndex) ops--;\\n\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628737,
                "title": "super-easy-2ms-java-code",
                "content": "# APPROACH \\nfind index-i of 1 ie i operations needed\\nfind index-j of n ie n-j-1 operations needed\\nadd both i+j\\nand if j<i then do -1\\n\\n#\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n class Solution{\\n    public int semiOrderedPermutation(int[] nums) \\n    {\\n        int n=nums.length,res=0,indexOf1=0,indexOfn=n;\\n        for(int i=0;i<n;i++)\\n        {\\n        if(nums[i]==1) indexOf1=i;\\n        if(nums[i]==n) indexOfn=i;\\n        }\\n        res=n+ indexOf1-indexOfn-1;\\n         if(indexOfn<indexOf1)\\n         res--;\\n         return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution{\\n    public int semiOrderedPermutation(int[] nums) \\n    {\\n        int n=nums.length,res=0,indexOf1=0,indexOfn=n;\\n        for(int i=0;i<n;i++)\\n        {\\n        if(nums[i]==1) indexOf1=i;\\n        if(nums[i]==n) indexOfn=i;\\n        }\\n        res=n+ indexOf1-indexOfn-1;\\n         if(indexOfn<indexOf1)\\n         res--;\\n         return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627502,
                "title": "iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                one=i\\n            elif nums[i] ==len(nums):\\n                last=i\\n        if one<last:\\n            return one+(len(nums)-1-last)\\n        else:\\n            return one+(len(nums)-1-last)-1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                one=i\\n            elif nums[i] ==len(nums):\\n                last=i\\n        if one<last:\\n            return one+(len(nums)-1-last)\\n        else:\\n            return one+(len(nums)-1-last)-1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625619,
                "title": "c-solution",
                "content": "```\\nint semiOrderedPermutation(vector<int>& nums) {\\n\\tauto mn = min_element(begin(nums), end(nums));\\n\\tauto mx = max_element(begin(nums), end(nums));\\n\\tint stPos = distance(begin(nums), mn);\\n\\tint endPos = distance(begin(nums), mx);\\n\\tint res = stPos + nums.size() - endPos - 1;\\n\\treturn res < nums.size() ? res : res - 1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint semiOrderedPermutation(vector<int>& nums) {\\n\\tauto mn = min_element(begin(nums), end(nums));\\n\\tauto mx = max_element(begin(nums), end(nums));\\n\\tint stPos = distance(begin(nums), mn);\\n\\tint endPos = distance(begin(nums), mx);\\n\\tint res = stPos + nums.size() - endPos - 1;\\n\\treturn res < nums.size() ? res : res - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625459,
                "title": "from-simulation-to-formula",
                "content": "**Simulation: brute-force**\\n1. Find pos of `min` and `max` values\\n2. Simulate what you would do with swaps on an array:\\n- swap `max` right till you have `[N - 1] = N`\\n- swap `min` left till you have `[0] = 1`\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = max_pos = 0\\n        for i in range(N):\\n            if nums[i] == 1:\\n                min_pos = i\\n            if nums[i] == N:\\n                max_pos = i\\n        count = 0\\n        while nums[0] != 1 or nums[N - 1] != N:\\n            if nums[0] != 1:\\n                nums[min_pos], nums[min_pos - 1] = nums[min_pos - 1], nums[min_pos]\\n                if nums[min_pos] == N:\\n                    max_pos += 1\\n                min_pos -= 1\\n            elif nums[N - 1] != N:\\n                nums[max_pos], nums[max_pos + 1] = nums[max_pos + 1], nums[max_pos]\\n                if nums[max_pos] == 1:\\n                    min_pos -= 1\\n                max_pos += 1\\n            count += 1\\n        return count\\n```\\n\\n**Formula**\\nAnalysis of what simulaton does:\\nSimulate what you would do with swaps on an array:\\n- swap `max` right till you have `[N - 1] = N`\\n- swap `min` left till you have `[0] = 1`\\n\\n2 examples would be enough to show observations and logic:\\n\\n1 ) `min_pos` does not cross `max_pos` position\\n```\\n<---- ---->\\n3 2 1 6 5 4\\n  1 # 1 swap\\n1 # 1 swap\\n        6 # 1 swap\\n          6 # 1 swap\\n```\\n2 ) `min_pos` crosses `max_pos` position\\n```\\n<---- ---->\\n6 5 4 3 2 1\\n  6 # 1 swap\\n    6 # 1 swap\\n      6 # 1 swap\\n        6 # 1 swap\\n\\n*** !!! This is the important moment, when min_pos and max_pos are in adjacent positions !!! ***\\n6 5 4 3[6 1]\\n       [1 6] # 1 swap, but this swap also swaps 1 to the left by 1 !!! This is a free ride for min_pos left by 1 pos!!!\\n```\\nSo you need to calc travel for `min_pos` to get to `[0]` + `max_pos` to get to `[N-1]` - 1 pos if you have case #2 (`min_pos` > `max_pos`)\\n\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = nums.index(1)\\n        max_pos = nums.index(N)\\n\\t\\t# min_pos to [0] + max_pos to [N - 1] - free ride, if any\\n        return (min_pos) + (N - 1 - max_pos) - (min_pos > max_pos)\\n```\\n\\nFor 1-line fans:\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        return (min_pos := nums.index(1)) + (N := len(nums)) - 1 - (max_pos := nums.index(N)) - (min_pos > max_pos)\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = max_pos = 0\\n        for i in range(N):\\n            if nums[i] == 1:\\n                min_pos = i\\n            if nums[i] == N:\\n                max_pos = i\\n        count = 0\\n        while nums[0] != 1 or nums[N - 1] != N:\\n            if nums[0] != 1:\\n                nums[min_pos], nums[min_pos - 1] = nums[min_pos - 1], nums[min_pos]\\n                if nums[min_pos] == N:\\n                    max_pos += 1\\n                min_pos -= 1\\n            elif nums[N - 1] != N:\\n                nums[max_pos], nums[max_pos + 1] = nums[max_pos + 1], nums[max_pos]\\n                if nums[max_pos] == 1:\\n                    min_pos -= 1\\n                max_pos += 1\\n            count += 1\\n        return count\\n```\n```\\n<---- ---->\\n3 2 1 6 5 4\\n  1 # 1 swap\\n1 # 1 swap\\n        6 # 1 swap\\n          6 # 1 swap\\n```\n```\\n<---- ---->\\n6 5 4 3 2 1\\n  6 # 1 swap\\n    6 # 1 swap\\n      6 # 1 swap\\n        6 # 1 swap\\n\\n*** !!! This is the important moment, when min_pos and max_pos are in adjacent positions !!! ***\\n6 5 4 3[6 1]\\n       [1 6] # 1 swap, but this swap also swaps 1 to the left by 1 !!! This is a free ride for min_pos left by 1 pos!!!\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = nums.index(1)\\n        max_pos = nums.index(N)\\n\\t\\t# min_pos to [0] + max_pos to [N - 1] - free ride, if any\\n        return (min_pos) + (N - 1 - max_pos) - (min_pos > max_pos)\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        return (min_pos := nums.index(1)) + (N := len(nums)) - 1 - (max_pos := nums.index(N)) - (min_pos > max_pos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621951,
                "title": "c-no-swap-o-n",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int p1 = -1, pn = -1, n = nums.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                p1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                pn = i;\\n            }\\n        }\\n\\n        return p1 + (n - pn - 1) - (p1 > pn);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int p1 = -1, pn = -1, n = nums.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                p1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                pn = i;\\n            }\\n        }\\n\\n        return p1 + (n - pn - 1) - (p1 > pn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621126,
                "title": "using-index-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                f = i\\n            elif nums[i] == len(nums):\\n                l = i\\n        if l<f:\\n            return len(nums)-1-l+f-1\\n        else:\\n            return len(nums)-1-l+f\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                f = i\\n            elif nums[i] == len(nums):\\n                l = i\\n        if l<f:\\n            return len(nums)-1-l+f-1\\n        else:\\n            return len(nums)-1-l+f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619924,
                "title": "elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 381ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 62.4MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec semi_ordered_permutation(nums :: [integer]) :: integer\\n  def semi_ordered_permutation(nums) do\\n    n = Enum.count(nums)\\n    {_, {pos1, pos2}} =\\n      Enum.reduce(nums, {0, {0, 0}}, fn num, {i, {pos1, pos2}} ->\\n        cond do\\n          num == 1 ->\\n            {i + 1, {i, pos2}}\\n          num == n ->\\n            {i + 1, {pos1, i}}\\n          true ->\\n            {i + 1, {pos1, pos2}}\\n        end\\n      end)\\n    if pos1 > pos2, do: pos1 + n - 1 - pos2 - 1, else: pos1 + n - 1 - pos2\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec semi_ordered_permutation(nums :: [integer]) :: integer\\n  def semi_ordered_permutation(nums) do\\n    n = Enum.count(nums)\\n    {_, {pos1, pos2}} =\\n      Enum.reduce(nums, {0, {0, 0}}, fn num, {i, {pos1, pos2}} ->\\n        cond do\\n          num == 1 ->\\n            {i + 1, {i, pos2}}\\n          num == n ->\\n            {i + 1, {pos1, i}}\\n          true ->\\n            {i + 1, {pos1, pos2}}\\n        end\\n      end)\\n    if pos1 > pos2, do: pos1 + n - 1 - pos2 - 1, else: pos1 + n - 1 - pos2\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3619531,
                "title": "java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int p1 = 0,pn = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            if(nums[i] == 1) p1 = i;\\n            else if(nums[i] == nums.length) pn = i;\\n        }\\n        int ans = p1 + nums.length - 1 - pn;\\n        if(p1 > pn) --ans; // because in this case `1` and `n` will share one common swap\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int p1 = 0,pn = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            if(nums[i] == 1) p1 = i;\\n            else if(nums[i] == nums.length) pn = i;\\n        }\\n        int ans = p1 + nums.length - 1 - pn;\\n        if(p1 > pn) --ans; // because in this case `1` and `n` will share one common swap\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619471,
                "title": "easy-clean-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a very straightforward approach, we can simply, easily simulate it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep track of the given indices of 1 and the last element. Perform swaps and calculate swaps to find the required answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the size of nums\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        reqd = {1:0, n:(n-1)}\\n        given = {1:0, n:0}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                given[1] = i\\n            if nums[i] == n:\\n                given[n] = i\\n        if given == reqd: return 0\\n        if given[n] < given[1]:\\n            return n-1-given[n]+given[1]-1\\n        else:\\n            return given[1] + (n-1) - given[n]\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        reqd = {1:0, n:(n-1)}\\n        given = {1:0, n:0}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                given[1] = i\\n            if nums[i] == n:\\n                given[n] = i\\n        if given == reqd: return 0\\n        if given[n] < given[1]:\\n            return n-1-given[n]+given[1]-1\\n        else:\\n            return given[1] + (n-1) - given[n]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619132,
                "title": "find-positions-and-return",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let fPos = 0;\\n    let lPos = 0;\\n    const n = nums.length;\\n    for(let i=0; i<n; i++) {\\n        if(nums[i] == 1) fPos = i;\\n        else if(nums[i] == n) lPos = i;\\n    }\\n    \\n    return lPos < fPos? (n - lPos + fPos - 2) : (n - lPos + fPos - 1); \\n    \\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let fPos = 0;\\n    let lPos = 0;\\n    const n = nums.length;\\n    for(let i=0; i<n; i++) {\\n        if(nums[i] == 1) fPos = i;\\n        else if(nums[i] == n) lPos = i;\\n    }\\n    \\n    return lPos < fPos? (n - lPos + fPos - 2) : (n - lPos + fPos - 1); \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619013,
                "title": "java-solution-easy-to-understand-swap-2ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int s=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                s=i;\\n                break;\\n            }\\n        }\\n        int e=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==nums.length){\\n                e=i;\\n                break;\\n            }\\n        }\\n        int s1=s;\\n        int e1=e;\\n        int c=0;\\n        while(e!=nums.length-1){\\n            c++;\\n            e++;\\n        }\\n        while(s!=0){\\n            c++;\\n            s--;\\n        }\\n        if(s1>e1)return c-1;\\n        else return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int s=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                s=i;\\n                break;\\n            }\\n        }\\n        int e=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==nums.length){\\n                e=i;\\n                break;\\n            }\\n        }\\n        int s1=s;\\n        int e1=e;\\n        int c=0;\\n        while(e!=nums.length-1){\\n            c++;\\n            e++;\\n        }\\n        while(s!=0){\\n            c++;\\n            s--;\\n        }\\n        if(s1>e1)return c-1;\\n        else return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618551,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min_indx = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int max_indx = max_element(nums.begin(),nums.end()) - nums.begin();\\n        int n = nums.size();\\n        int cnt = 0;\\n        cnt += (min_indx);\\n        cnt += (n-1-max_indx);\\n        //this is because if max_indx is less than min_indx then by swaping the max_indx will get increase by 1;\\n        if(min_indx>max_indx){\\n            cnt--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min_indx = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int max_indx = max_element(nums.begin(),nums.end()) - nums.begin();\\n        int n = nums.size();\\n        int cnt = 0;\\n        cnt += (min_indx);\\n        cnt += (n-1-max_indx);\\n        //this is because if max_indx is less than min_indx then by swaping the max_indx will get increase by 1;\\n        if(min_indx>max_indx){\\n            cnt--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618477,
                "title": "2ms-100-java-solution",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        int index1=0;\\n        int indexn=0;\\n        int n=nums.length;\\n        if(n==1)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n            }\\n            else if(nums[i]==n)\\n            {\\n                indexn=i;\\n            }\\n        }\\n        int carry=(index1>indexn)?1:0;\\n        return index1+(n-indexn-1)-carry;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        int index1=0;\\n        int indexn=0;\\n        int n=nums.length;\\n        if(n==1)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n            }\\n            else if(nums[i]==n)\\n            {\\n                indexn=i;\\n            }\\n        }\\n        int carry=(index1>indexn)?1:0;\\n        return index1+(n-indexn-1)-carry;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618086,
                "title": "simulate-the-process-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums)\\n    {\\n          int count = 0;\\n          //we can just simulate the whole process using the loop or iteratons\\n\\n          //we need to find the position of the 1 in the nums vector\\n          int onepos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == 1)\\n              {\\n                  onepos = i;\\n                  break;\\n              }\\n          }\\n          if(onepos != 0)\\n          {\\n               while(onepos != 0)\\n               {\\n                   int temp       = nums[onepos-1];\\n                   nums[onepos-1] = nums[onepos];\\n                   nums[onepos]   = temp;\\n                   count++;\\n\\n                   onepos = onepos - 1;   \\n               }\\n          }\\n\\n          //we need to fnd the positon of the n in the nums vector\\n          int npos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == nums.size())\\n              {\\n                  npos = i;\\n                  break;\\n              }\\n          }\\n          if(npos != nums.size()-1)\\n          {\\n               while(npos != nums.size()-1)\\n               {\\n                   int temp       = nums[npos+1];\\n                   nums[npos+1] = nums[npos];\\n                   nums[npos]   = temp;\\n                   count++;\\n\\n                   npos = npos + 1;   \\n               }\\n          }\\n          return count;          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums)\\n    {\\n          int count = 0;\\n          //we can just simulate the whole process using the loop or iteratons\\n\\n          //we need to find the position of the 1 in the nums vector\\n          int onepos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == 1)\\n              {\\n                  onepos = i;\\n                  break;\\n              }\\n          }\\n          if(onepos != 0)\\n          {\\n               while(onepos != 0)\\n               {\\n                   int temp       = nums[onepos-1];\\n                   nums[onepos-1] = nums[onepos];\\n                   nums[onepos]   = temp;\\n                   count++;\\n\\n                   onepos = onepos - 1;   \\n               }\\n          }\\n\\n          //we need to fnd the positon of the n in the nums vector\\n          int npos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == nums.size())\\n              {\\n                  npos = i;\\n                  break;\\n              }\\n          }\\n          if(npos != nums.size()-1)\\n          {\\n               while(npos != nums.size()-1)\\n               {\\n                   int temp       = nums[npos+1];\\n                   nums[npos+1] = nums[npos];\\n                   nums[npos]   = temp;\\n                   count++;\\n\\n                   npos = npos + 1;   \\n               }\\n          }\\n          return count;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616433,
                "title": "easy-python-just-find-the-index-of-1-and-n",
                "content": "\\tclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)+1\\n        j=nums.index(n)+1\\n        if i<j:\\n            return (n-j)+(i-1)\\n        else:\\n            return (n-j)+(i-1) -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)+1\\n        j=nums.index(n)+1\\n        if i<j:\\n            return (n-j)+(i-1)\\n        else:\\n            return (n-j)+(i-1) -1",
                "codeTag": "Java"
            },
            {
                "id": 3615997,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def semiOrderedPermutation(nums: Array[Int]): Int = {\\n    val n = nums.length\\n    val left = nums.indexOf(1)\\n    val right = nums.indexOf(n)\\n    left + (n - 1 - right) - (if(left > right) 1 else 0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def semiOrderedPermutation(nums: Array[Int]): Int = {\\n    val n = nums.length\\n    val left = nums.indexOf(1)\\n    val right = nums.indexOf(n)\\n    left + (n - 1 - right) - (if(left > right) 1 else 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3615811,
                "title": "c-basic-searching-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int  n=size(nums),i=find(begin(nums),end(nums),1)-begin(nums),j=find(begin(nums),end(nums),n)-begin(nums);\\n        return n-1-j+i-(i>j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int  n=size(nums),i=find(begin(nums),end(nums),1)-begin(nums),j=find(begin(nums),end(nums),n)-begin(nums);\\n        return n-1-j+i-(i>j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615465,
                "title": "c-python-code-easy-to-understanf",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx1 , idxn , n = nums.size() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                idx1 = i ;\\n            }\\n            else if(nums[i] == n)\\n            {\\n                idxn = i ;\\n            }\\n        }\\n        return idx1 > idxn ? idx1 + (n - idxn) - 2 : idx1 + (n - idxn) - 1 ;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        val1 = -1\\n        valn = -1\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] == 1:\\n                val1 = i\\n            elif nums[i] == n:\\n                valn = i\\n        if val1 > valn:\\n            return val1 + (n - valn) - 2\\n        return val1 + (n-valn) - 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx1 , idxn , n = nums.size() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                idx1 = i ;\\n            }\\n            else if(nums[i] == n)\\n            {\\n                idxn = i ;\\n            }\\n        }\\n        return idx1 > idxn ? idx1 + (n - idxn) - 2 : idx1 + (n - idxn) - 1 ;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        val1 = -1\\n        valn = -1\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] == 1:\\n                val1 = i\\n            elif nums[i] == n:\\n                valn = i\\n        if val1 > valn:\\n            return val1 + (n - valn) - 2\\n        return val1 + (n-valn) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615378,
                "title": "python-3",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        f, l = nums.index(1), nums.index(n)\\n\\n        if f < l:\\n            return f + (n - 1 - l)\\n\\n        else:\\n            return f + (n - 1 - l - 1)\\n\\n        \\n        \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        f, l = nums.index(1), nums.index(n)\\n\\n        if f < l:\\n            return f + (n - 1 - l)\\n\\n        else:\\n            return f + (n - 1 - l - 1)\\n\\n        \\n        \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614690,
                "title": "simple-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        last=max(nums)\\n        if(nums[0]==1 and nums[-1]==last):\\n            return 0\\n        count=0\\n        while(nums[0]!=1):\\n            index1=nums.index(1)\\n            i=index1-1\\n            nums[index1], nums[i]=nums[i],nums[index1]\\n            count+=1\\n            \\n        while(nums[len(nums)-1]!=last):\\n            indexlast=nums.index(last)\\n            i=indexlast+1\\n            nums[indexlast], nums[i]=nums[i],nums[indexlast]\\n            count+=1\\n        \\n        return count\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        last=max(nums)\\n        if(nums[0]==1 and nums[-1]==last):\\n            return 0\\n        count=0\\n        while(nums[0]!=1):\\n            index1=nums.index(1)\\n            i=index1-1\\n            nums[index1], nums[i]=nums[i],nums[index1]\\n            count+=1\\n            \\n        while(nums[len(nums)-1]!=last):\\n            indexlast=nums.index(last)\\n            i=indexlast+1\\n            nums[indexlast], nums[i]=nums[i],nums[indexlast]\\n            count+=1\\n        \\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613943,
                "title": "best-solution-with-example-beats-100-without-swapping",
                "content": "# Intuition\\nproblem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\n\\nfind index of minimum element i.e 1 and maximum element i.e nums.length\\n\\nthat means elements before index1 and after index2 have to be swapped \\n![20230608_192346.jpg](https://assets.leetcode.com/users/images/b3a4eeea-66de-4fd8-8c4f-8d8ca9709d4d_1686232773.1585362.jpeg)\\n\\nwhat if index2<index1 you can you figure it out by your own? :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index1 =0;\\n        int index2 =0;\\n        \\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1 =i;\\n                continue;\\n            }\\n            \\n            if(nums[i]==nums.length){\\n                index2 = i;\\n                continue;\\n            }\\n        }\\n        \\n        if(index2<index1){\\n            index2 = nums.length-1 - index2;\\n            \\n            return (index1+index2)-1;\\n        }\\n        \\n        index2 = nums.length -1 - index2;\\n        \\n        return (index1+index2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index1 =0;\\n        int index2 =0;\\n        \\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1 =i;\\n                continue;\\n            }\\n            \\n            if(nums[i]==nums.length){\\n                index2 = i;\\n                continue;\\n            }\\n        }\\n        \\n        if(index2<index1){\\n            index2 = nums.length-1 - index2;\\n            \\n            return (index1+index2)-1;\\n        }\\n        \\n        index2 = nums.length -1 - index2;\\n        \\n        return (index1+index2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613588,
                "title": "java-simple-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n public int semiOrderedPermutation(int[] nums) {\\n    int indexOf1 = -1, indexOfN = -1;\\n    for(int i = 0; i < nums.length; i++){\\n        if(nums[i] == 1) indexOf1 = i;\\n        else if(nums[i] == nums.length) indexOfN = i;\\n    }\\n    return indexOf1 + nums.length - 1 - indexOfN - ((indexOfN < indexOf1) ? 1 : 0) ;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int semiOrderedPermutation(int[] nums) {\\n    int indexOf1 = -1, indexOfN = -1;\\n    for(int i = 0; i < nums.length; i++){\\n        if(nums[i] == 1) indexOf1 = i;\\n        else if(nums[i] == nums.length) indexOfN = i;\\n    }\\n    return indexOf1 + nums.length - 1 - indexOfN - ((indexOfN < indexOf1) ? 1 : 0) ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611842,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=fun1(nums)+fun2(nums);\\n        return ans;\\n    }\\n    int fun1(vector<int>&nums)\\n    {\\n        if(nums[0]==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                swap(nums[i],nums[i-1]);\\n                return 1+fun1(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n    int fun2(vector<int>&nums)\\n    {\\n        if(nums[nums.size()-1]==nums.size())\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                swap(nums[i],nums[i+1]);\\n                return 1+fun2(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=fun1(nums)+fun2(nums);\\n        return ans;\\n    }\\n    int fun1(vector<int>&nums)\\n    {\\n        if(nums[0]==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                swap(nums[i],nums[i-1]);\\n                return 1+fun1(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n    int fun2(vector<int>&nums)\\n    {\\n        if(nums[nums.size()-1]==nums.size())\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                swap(nums[i],nums[i+1]);\\n                return 1+fun2(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611295,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        var min = (int.MaxValue, 0);\\n        var max = (0, 0);\\n        for(var i = 0; i < nums.Length; i++){\\n            if(nums[i] < min.Item1)\\n                min = (nums[i], i);\\n            if(nums[i] > max.Item1)\\n                max = (nums[i], i);\\n        }\\n\\n        if(min.Item2 > max.Item2)\\n            return min.Item2 + (nums.Length - 2 - max.Item2);\\n        else\\n            return min.Item2 + (nums.Length - 1 - max.Item2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        var min = (int.MaxValue, 0);\\n        var max = (0, 0);\\n        for(var i = 0; i < nums.Length; i++){\\n            if(nums[i] < min.Item1)\\n                min = (nums[i], i);\\n            if(nums[i] > max.Item1)\\n                max = (nums[i], i);\\n        }\\n\\n        if(min.Item2 > max.Item2)\\n            return min.Item2 + (nums.Length - 2 - max.Item2);\\n        else\\n            return min.Item2 + (nums.Length - 1 - max.Item2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610955,
                "title": "js-solution-95-ms",
                "content": "# Complexity\\n- Time complexity:\\n95 ms\\n\\n- Space complexity:\\n45.5 MB\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n  const indexMin = nums.indexOf(Math.min(...nums))\\n  const indexMax = nums.indexOf(Math.max(...nums))\\n\\n  if(indexMin > indexMax){\\n    return indexMin + nums.length - 1 - indexMax - 1\\n  } else {\\n    return indexMin + nums.length - 1 - indexMax\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n  const indexMin = nums.indexOf(Math.min(...nums))\\n  const indexMax = nums.indexOf(Math.max(...nums))\\n\\n  if(indexMin > indexMax){\\n    return indexMin + nums.length - 1 - indexMax - 1\\n  } else {\\n    return indexMin + nums.length - 1 - indexMax\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610805,
                "title": "simple-formula",
                "content": "\\n# Code\\n```\\ndef semiOrderedPermutation(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    return nums.index(1) + n - 1 - nums.index(n) - int(nums.index(1) > nums.index(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef semiOrderedPermutation(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    return nums.index(1) + n - 1 - nums.index(n) - int(nums.index(1) > nums.index(n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3609704,
                "title": "easyyyyy",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        c1=0\\n        cn=0\\n        ind1=nums.index(1)\\n        for i in range(ind1-1,-1,-1):\\n            if nums[i]!=n:\\n                c1+=1\\n        indn=nums.index(n)\\n        for j in range(indn+1,n):\\n            cn+=1\\n        return c1+cn\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        c1=0\\n        cn=0\\n        ind1=nums.index(1)\\n        for i in range(ind1-1,-1,-1):\\n            if nums[i]!=n:\\n                c1+=1\\n        indn=nums.index(n)\\n        for j in range(indn+1,n):\\n            cn+=1\\n        return c1+cn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609283,
                "title": "pure-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        \\n        int n = nums.length;\\n        int r1=0;\\n        int r2=0;\\n        while (true) {\\n            if(nums[0]==1 && nums[n-1]==n){\\n                break;\\n            }\\n            while(nums[0]!=1){\\n                int first = getPosition(1,nums);\\n                swap(first,first-1,nums);\\n                r1++;\\n            }\\n            while(nums[n-1]!=n){\\n                int last = getPosition(n,nums);\\n                swap(last,last+1,nums);\\n                r2++;\\n            }\\n        }\\n        int result = r1+r2;\\n        return result;\\n        \\n    }\\n    \\n     public static void swap(int a,int b,int[] nums){\\n\\n        int temp= nums[a];\\n        nums[a]= nums[b];\\n        nums[b]=temp;\\n\\n//        System.out.println(\"a\"+a+\"b\"+b);\\n    }\\n\\n    public static int getPosition(int a,int[] nums){\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==a){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        \\n        int n = nums.length;\\n        int r1=0;\\n        int r2=0;\\n        while (true) {\\n            if(nums[0]==1 && nums[n-1]==n){\\n                break;\\n            }\\n            while(nums[0]!=1){\\n                int first = getPosition(1,nums);\\n                swap(first,first-1,nums);\\n                r1++;\\n            }\\n            while(nums[n-1]!=n){\\n                int last = getPosition(n,nums);\\n                swap(last,last+1,nums);\\n                r2++;\\n            }\\n        }\\n        int result = r1+r2;\\n        return result;\\n        \\n    }\\n    \\n     public static void swap(int a,int b,int[] nums){\\n\\n        int temp= nums[a];\\n        nums[a]= nums[b];\\n        nums[b]=temp;\\n\\n//        System.out.println(\"a\"+a+\"b\"+b);\\n    }\\n\\n    public static int getPosition(int a,int[] nums){\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==a){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608830,
                "title": "easy-cpp-solution-6-line-code",
                "content": "\\n# Approach\\nfind min and max element index by using stl (min & max element)\\nif max is left of min then \\nwe find min index from start ans max index from end \\nboth add and -1 for (one we swap both)\\notherwise we simple max from end index \\nadd min and max index then return add of both\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n- 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min=min_element(nums.begin(),nums.end())-nums.begin();\\n        int max=max_element(nums.begin(),nums.end())-nums.begin();\\n        if(max<min){\\n            max=(nums.size()-1)-max;\\n            return (max+min)-1;\\n        }\\n        max=(nums.size()-1)-max;\\n        return max+min;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min=min_element(nums.begin(),nums.end())-nums.begin();\\n        int max=max_element(nums.begin(),nums.end())-nums.begin();\\n        if(max<min){\\n            max=(nums.size()-1)-max;\\n            return (max+min)-1;\\n        }\\n        max=(nums.size()-1)-max;\\n        return max+min;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608172,
                "title": "straight-forward",
                "content": "# Intuition\\nbased on the location of 1 and the nums.length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index_of_first = 0;\\n        int index_of_last = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1)\\n                index_of_first = i;\\n            if (nums[i] == nums.length)\\n                index_of_last = i;\\n        }\\n\\n        if (index_of_first > index_of_last) {\\n            return index_of_first + nums.length - 1 - index_of_last - 1;\\n        } else {\\n            return index_of_first + nums.length - 1 - index_of_last;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index_of_first = 0;\\n        int index_of_last = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1)\\n                index_of_first = i;\\n            if (nums[i] == nums.length)\\n                index_of_last = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3608123,
                "title": "recursive-swapping",
                "content": "# Intuition\\nRecursive swapping.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       boolean checkForCross=true;\\n       int global_first=0;\\n       int global_second=0;\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        int first=0;\\n        int second=0;\\n     \\n        if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n        return 0;\\n       else if(nums[0]==1)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==nums.length)\\n                {\\n                    return nums.length-i-1;\\n                }\\n            }\\n        }\\n       else if(nums[nums.length-1]==nums.length)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n            global_first=first;global_second=second;\\n\\n           int finalResult=swap(nums,first,second);\\n           return finalResult;\\n        }\\n        return -1;\\n    }\\n    \\n    public int swap(int[] nums,int first,int second)\\n    {\\nif(nums[0]==1 && checkForCross==false)return global_first+(nums.length-1-global_second)-1;\\nif(nums[0]==1 && checkForCross==true)return global_first+(nums.length-1-global_second);\\n       for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n       if(second==first-1)checkForCross=false;\\n       int dummy=nums[first];\\n       nums[first]=nums[first-1];\\n       nums[first-1]=dummy;\\n       return swap(nums,first,second);\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       boolean checkForCross=true;\\n       int global_first=0;\\n       int global_second=0;\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        int first=0;\\n        int second=0;\\n     \\n        if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n        return 0;\\n       else if(nums[0]==1)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==nums.length)\\n                {\\n                    return nums.length-i-1;\\n                }\\n            }\\n        }\\n       else if(nums[nums.length-1]==nums.length)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n            global_first=first;global_second=second;\\n\\n           int finalResult=swap(nums,first,second);\\n           return finalResult;\\n        }\\n        return -1;\\n    }\\n    \\n    public int swap(int[] nums,int first,int second)\\n    {\\nif(nums[0]==1 && checkForCross==false)return global_first+(nums.length-1-global_second)-1;\\nif(nums[0]==1 && checkForCross==true)return global_first+(nums.length-1-global_second);\\n       for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n       if(second==first-1)checkForCross=false;\\n       int dummy=nums[first];\\n       nums[first]=nums[first-1];\\n       nums[first-1]=dummy;\\n       return swap(nums,first,second);\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607981,
                "title": "ez-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = -1, high = -1;\\n        if(nums[0] == 1 and nums[n-1] == n) return 0;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1)\\n              low = i;\\n            else if(nums[i] == n)\\n              high = i;\\n        }\\n        if(low > high) return (low - 0) + (n - 1 - high) - 1;\\n        else return (low - 0) + (n - 1 - high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = -1, high = -1;\\n        if(nums[0] == 1 and nums[n-1] == n) return 0;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1)\\n              low = i;\\n            else if(nums[i] == n)\\n              high = i;\\n        }\\n        if(low > high) return (low - 0) + (n - 1 - high) - 1;\\n        else return (low - 0) + (n - 1 - high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607180,
                "title": "python-simple-and-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe calculate the difference between indedx and the value of 1 or n. The difference is the number of steps required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the absolute difference of (index of 1 - 1) and (index of n - n). Sum the difference and that is the return value.\\n\\nAfter each operation, we would re-order the list to mimic the swap action. (Slower but intuitive)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        cnt = 0 \\n\\n        for i in [1, len(nums)]:\\n            if nums.index(i) != i - 1:\\n                cnt += abs(nums.index(i) - (i - 1))\\n                if i == 1:\\n                    nums[i-1:i-1] = [nums.pop(nums.index(i))] # Swap the location\\n\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        cnt = 0 \\n\\n        for i in [1, len(nums)]:\\n            if nums.index(i) != i - 1:\\n                cnt += abs(nums.index(i) - (i - 1))\\n                if i == 1:\\n                    nums[i-1:i-1] = [nums.pop(nums.index(i))] # Swap the location\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606980,
                "title": "javascript-tc-o-n-sc-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n \\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const n = nums.length;\\n    let fi = -1, li = -1;\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] === 1) {\\n            fi = i;\\n        } else if (nums[i] === n) {\\n            li = i;\\n        }\\n    }\\n    let ans = fi - 0 + n - 1 - li;\\n    if (li < fi) {\\n        ans--;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n \\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const n = nums.length;\\n    let fi = -1, li = -1;\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] === 1) {\\n            fi = i;\\n        } else if (nums[i] === n) {\\n            li = i;\\n        }\\n    }\\n    let ans = fi - 0 + n - 1 - li;\\n    if (li < fi) {\\n        ans--;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605904,
                "title": "100-fast-java-c-explain-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**step 1.** find min and max number **index** as **min** and **max** variable\\n**step 2.** for min to **0th** index there are **min - 0** swaps == min swaps\\n**step 3.** for max to **end** index there are **end - max** swaps\\n**step 4.** totalswaps = min + (end - max)\\n\\n**step 5.** if (min < max), return totalswaps\\n            else return totalswaps -1;\\n**NOTE:: here, -1 because min and max swap count added twice as shown below**\\n![1686072871283.jpg](https://assets.leetcode.com/users/images/5dff1329-02cb-4ea3-906e-65d31d9d08c3_1686074160.5710166.jpeg)\\n\\n![1686072871276.jpg](https://assets.leetcode.com/users/images/ad8a8733-9486-47c8-90d2-ef4587983f06_1686074103.3038957.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0] == 1 && nums[nums.length-1] == nums.length) return 0;\\n        int end = nums.length-1;\\n        int min = 0;\\n        int max = end;\\n        \\n        for(int i=0; i< nums.length;i++){\\n            if(nums[i] == nums.length){\\n                max = i;\\n            }\\n            if(nums[i] == 1){\\n                min = i;\\n            }\\n        }\\n        int totalSwaps = min + (end - max);\\n        if(min < max) return totalSwaps;\\n\\n        else return totalSwaps  - 1; //because max and min are already swapped \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0] == 1 && nums[nums.length-1] == nums.length) return 0;\\n        int end = nums.length-1;\\n        int min = 0;\\n        int max = end;\\n        \\n        for(int i=0; i< nums.length;i++){\\n            if(nums[i] == nums.length){\\n                max = i;\\n            }\\n            if(nums[i] == 1){\\n                min = i;\\n            }\\n        }\\n        int totalSwaps = min + (end - max);\\n        if(min < max) return totalSwaps;\\n\\n        else return totalSwaps  - 1; //because max and min are already swapped \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603696,
                "title": "c-o-n-solution-without-extra-space",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size(), index1 = -1, index2 = -1;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        for (int i=0;i<n;i++) {\\n            if (nums[i] == 1) {\\n                index1 = i;\\n            } \\n            if (nums[i] == n) {\\n                index2 = i;\\n            }\\n        }\\n        if (index1 < index2) {\\n            return index1 + n - 1 - index2;\\n        } else {\\n            return index2 + n - 1 - index1 + 2*(index1 - index2 - 1) + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size(), index1 = -1, index2 = -1;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        for (int i=0;i<n;i++) {\\n            if (nums[i] == 1) {\\n                index1 = i;\\n            } \\n            if (nums[i] == n) {\\n                index2 = i;\\n            }\\n        }\\n        if (index1 < index2) {\\n            return index1 + n - 1 - index2;\\n        } else {\\n            return index2 + n - 1 - index1 + 2*(index1 - index2 - 1) + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603326,
                "title": "java-simple-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int firstNumber = 0;\\n        int lastNumber = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                firstNumber = i;\\n            }\\n            if (nums[i] == n) {\\n                lastNumber = i;\\n            }\\n        }\\n\\n        int lessMove = 0;\\n        if (firstNumber > lastNumber) {\\n            lessMove = 1;\\n        }\\n\\n        return firstNumber + (n - 1 - lastNumber) - lessMove;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int firstNumber = 0;\\n        int lastNumber = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                firstNumber = i;\\n            }\\n            if (nums[i] == n) {\\n                lastNumber = i;\\n            }\\n        }\\n\\n        int lessMove = 0;\\n        if (firstNumber > lastNumber) {\\n            lessMove = 1;\\n        }\\n\\n        return firstNumber + (n - 1 - lastNumber) - lessMove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603198,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n       int index1 = 0;\\n        int indexlast = n;\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i] == 1) index1 = i;\\n            if(nums[i] == n) indexlast = i;\\n        }\\n        int ans = index1 + n - indexlast -1;\\n        if(index1 > indexlast) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n       int index1 = 0;\\n        int indexlast = n;\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i] == 1) index1 = i;\\n            if(nums[i] == n) indexlast = i;\\n        }\\n        int ans = index1 + n - indexlast -1;\\n        if(index1 > indexlast) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602382,
                "title": "swift-fast-one-pass",
                "content": "**One Pass (accepted answer)**\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        let N = nums.count\\n        var p = 0\\n        var q = nums[N-1] == N ? N - 1 : 0\\n        \\n        for (i,num) in nums.enumerated() where num == 1 || num == N {\\n            (p,q) = num == 1 ? (i,q) : (p,i) \\n            guard p*q == 0 else { break }\\n        }\\n        \\n        return p + (N - 1 - q) + (p>q ? -1 : 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        let N = nums.count\\n        var p = 0\\n        var q = nums[N-1] == N ? N - 1 : 0\\n        \\n        for (i,num) in nums.enumerated() where num == 1 || num == N {\\n            (p,q) = num == 1 ? (i,q) : (p,i) \\n            guard p*q == 0 else { break }\\n        }\\n        \\n        return p + (N - 1 - q) + (p>q ? -1 : 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602044,
                "title": "easy-solution-python-simple-and-best",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        idx_1 = nums.index(1)\\n        idx_n = nums.index(len(nums))\\n\\n        if idx_1 > idx_n:\\n            return idx_1 + (len(nums) - idx_n - 1) - 1\\n        else:\\n            return idx_1 + (len(nums) - idx_n - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        idx_1 = nums.index(1)\\n        idx_n = nums.index(len(nums))\\n\\n        if idx_1 > idx_n:\\n            return idx_1 + (len(nums) - idx_n - 1) - 1\\n        else:\\n            return idx_1 + (len(nums) - idx_n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601750,
                "title": "easiest-approach-with-intuition-cpp",
                "content": "# Intuition\\nThis is a very easy problem..\\nWe don\\'t need to swap and just observe the output array.\\nIf index of n < index of 1 then there will be one less swap as 1 will swap with n once.\\nand If index of n> index of 1 then simply we will subtract the index.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int sz=nums.size();\\n        int n=nums.size()-1;\\n        int lastele;\\n        int firstele;\\n        for(int i=0 ; i<=n ; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                firstele=i;   //we will store the index of 1\\n            }\\n            if(nums[i]==sz)   // we will store the index of n\\n            {\\n                lastele=i;\\n            }\\n        }\\n        \\n        int count;\\n        if(lastele<firstele)   //we will compare for both the cases\\n        {\\n            count=((firstele-0)+(n-lastele))-1;\\n        }\\n        else{\\n            count=((firstele-0)+(n-lastele));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int sz=nums.size();\\n        int n=nums.size()-1;\\n        int lastele;\\n        int firstele;\\n        for(int i=0 ; i<=n ; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                firstele=i;   //we will store the index of 1\\n            }\\n            if(nums[i]==sz)   // we will store the index of n\\n            {\\n                lastele=i;\\n            }\\n        }\\n        \\n        int count;\\n        if(lastele<firstele)   //we will compare for both the cases\\n        {\\n            count=((firstele-0)+(n-lastele))-1;\\n        }\\n        else{\\n            count=((firstele-0)+(n-lastele));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601694,
                "title": "simple-c-solution-by-finding-positions-of-maximum-and-minimum-element",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int i1=0,i2=0,mini=nums[0],maxi=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                i2=i;\\n                maxi=nums[i];\\n            }\\n            if(nums[i]<mini)\\n            {\\n                i1=i;\\n                mini=nums[i];\\n            }\\n        }\\n        if(i1>i2)\\n        return ((i1-0)+(nums.size()-1-i2))-1;\\n        else\\n        return ((i1-0)+(nums.size()-1-i2));\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int i1=0,i2=0,mini=nums[0],maxi=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                i2=i;\\n                maxi=nums[i];\\n            }\\n            if(nums[i]<mini)\\n            {\\n                i1=i;\\n                mini=nums[i];\\n            }\\n        }\\n        if(i1>i2)\\n        return ((i1-0)+(nums.size()-1-i2))-1;\\n        else\\n        return ((i1-0)+(nums.size()-1-i2));\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601615,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        first = last = None\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                first = i\\n            elif nums[i] == len(nums):\\n                last = i\\n        \\n        return first + (len(nums)-1-last) - (0 if first<last else 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        first = last = None\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                first = i\\n            elif nums[i] == len(nums):\\n                last = i\\n        \\n        return first + (len(nums)-1-last) - (0 if first<last else 1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1916664,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1916079,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1959233,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1925801,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1921322,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            }
        ]
    }
]