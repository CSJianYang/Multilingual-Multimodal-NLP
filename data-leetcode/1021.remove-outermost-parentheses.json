[
    {
        "title": "Remove Outermost Parentheses",
        "question_content": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\tFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n&nbsp;\nExample 1:\nInput: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".\nExample 2:\nInput: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".\nExample 3:\nInput: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\".\n&nbsp;\nConstraints:\n\t1 <= s.length <= 105\n\ts[i] is either '(' or ')'.\n\ts is a valid parentheses string.",
        "solutions": [
            {
                "id": 270022,
                "title": "java-c-python-count-opened-parenthesis",
                "content": "## **Intuition**\\nQuote from @shubhama,\\nPrimitive string will have equal number of opened and closed parenthesis.\\n\\n## **Explanation**:\\n`opened` count the number of opened parenthesis.\\nAdd every char to the result,\\nunless the first left parenthesis,\\nand the last right parenthesis.\\n\\n## **Time Complexity**:\\n`O(N)` Time, `O(N)` space\\n\\n<br>\\n\\n**Java:**\\n```\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder s = new StringBuilder();\\n        int opened = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\' && opened++ > 0) s.append(c);\\n            if (c == \\')\\' && opened-- > 1) s.append(c);\\n        }\\n        return s.toString();\\n    }\\n```\\n\\n**C++:**\\n```\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def removeOuterParentheses(self, S):\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        return \"\".join(res)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder s = new StringBuilder();\\n        int opened = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\' && opened++ > 0) s.append(c);\\n            if (c == \\')\\' && opened-- > 1) s.append(c);\\n        }\\n        return s.toString();\\n    }\\n```\n```\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def removeOuterParentheses(self, S):\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        return \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3551123,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        \\n        return \"\".join(res)\\n```\\n\\n```Java []\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int len = s.length();\\n        if (len <= 2) return \"\";\\n        char[] c = s.toCharArray();\\n        StringBuilder newString = new StringBuilder();\\n        int open = 1;\\n        int openLeft = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (c[i] == \\'(\\') {\\n                open++;\\n                if (open > 1) newString.append(\\'(\\');\\n            }\\n            else {\\n                if (open > 1) newString.append(\\')\\');\\n                open--;\\n            }\\n        }\\n        return newString.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        \\n        return \"\".join(res)\\n```\n```Java []\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int len = s.length();\\n        if (len <= 2) return \"\";\\n        char[] c = s.toCharArray();\\n        StringBuilder newString = new StringBuilder();\\n        int open = 1;\\n        int openLeft = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (c[i] == \\'(\\') {\\n                open++;\\n                if (open > 1) newString.append(\\'(\\');\\n            }\\n            else {\\n                if (open > 1) newString.append(\\')\\');\\n                open--;\\n            }\\n        }\\n        return newString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165562,
                "title": "well-explained-code-in-java",
                "content": "\\n\\n# Approach\\nThis is a solution to the problem of removing outermost parentheses from a string containing only parentheses.\\n\\nThe approach used is to keep track of the parentheses using a stack. Whenever an opening parenthesis is encountered, it is pushed onto the stack. Whenever a closing parenthesis is encountered, the last opening parenthesis is popped from the stack.\\n\\nIf the stack size is greater than zero after pushing or popping, it means that the parenthesis is not an outer parenthesis, and it is added to the result string. If the stack size is zero, it means that the parenthesis is an outer parenthesis and it is not added to the result string.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input string. This is because each character in the string is processed once and the push and pop operations on the stack take O(1) time each.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is O(n), where n is the length of the input string. This is because the maximum size of the stack is n/2 (if all the parentheses are opening parentheses), and in the worst case, the result string can also have a size of n/2.\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> bracket = new Stack<>();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n                bracket.push(s.charAt(i));\\n            }else{\\n                bracket.pop();\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/150a5515-b27f-42d1-9a2e-aed10f236bca_1675969899.9073486.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> bracket = new Stack<>();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n                bracket.push(s.charAt(i));\\n            }else{\\n                bracket.pop();\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270566,
                "title": "my-java-3ms-straight-forward-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int open=0, close=0, start=0;\\n        for(int i=0; i<S.length(); i++) {\\n            if(S.charAt(i) == \\'(\\') {\\n                open++;\\n            } else if(S.charAt(i) == \\')\\') {\\n                close++;\\n            }\\n            if(open==close) {\\n                sb.append(S.substring(start+1, i));\\n                start=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int open=0, close=0, start=0;\\n        for(int i=0; i<S.length(); i++) {\\n            if(S.charAt(i) == \\'(\\') {\\n                open++;\\n            } else if(S.charAt(i) == \\')\\') {\\n                close++;\\n            }\\n            if(open==close) {\\n                sb.append(S.substring(start+1, i));\\n                start=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290126,
                "title": "c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int count = 0;\\n        std::string str;\\n        for (char c : S) {\\n            if (c == \\'(\\') {\\n                if (count++) {\\n                    str += \\'(\\';\\n                }\\n            } else {\\n                if (--count) {\\n                    str += \\')\\';\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int count = 0;\\n        std::string str;\\n        for (char c : S) {\\n            if (c == \\'(\\') {\\n                if (count++) {\\n                    str += \\'(\\';\\n                }\\n            } else {\\n                if (--count) {\\n                    str += \\')\\';\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815947,
                "title": "c-two-solution-stack-and-with-out-stack-only-slight-modification-in-stack-sol",
                "content": "please **upVote** my solution if you like it.\\n\\nMy first solution is stack based and it consume more memory than with out stack solution in my second solution to elemenate stack from it so please reffer to that also \\n\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        stack<char>st;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st.size()>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'\\n\\nSolution without stack \\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        int st=0;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        stack<char>st;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st.size()>0)\\n                {\\n                    ans+=\\'(\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 299353,
                "title": "python-simple-o-n-solution-beats-97",
                "content": "```python\\ndef removeOuterParentheses(self, S):\\n\\tres = []\\n\\tbalance = 0\\n\\ti = 0\\n\\tfor j in range(len(S)):\\n\\t\\tif S[j] == \"(\":\\n\\t\\t\\tbalance += 1\\n\\t\\telif S[j] == \")\":\\n\\t\\t\\tbalance -= 1\\n\\t\\tif balance == 0:\\n\\t\\t\\tres.append(S[i+1:j])\\n\\t\\t\\ti = j+1\\n\\treturn \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef removeOuterParentheses(self, S):\\n\\tres = []\\n\\tbalance = 0\\n\\ti = 0\\n\\tfor j in range(len(S)):\\n\\t\\tif S[j] == \"(\":\\n\\t\\t\\tbalance += 1\\n\\t\\telif S[j] == \")\":\\n\\t\\t\\tbalance -= 1\\n\\t\\tif balance == 0:\\n\\t\\t\\tres.append(S[i+1:j])\\n\\t\\t\\ti = j+1\\n\\treturn \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2916928,
                "title": "one-pass-faang-sde-1-interview",
                "content": "```\\nVery Easy Beginner Friendly Solution \\uD83D\\uDCA1\\nDo not use stack to prevent more extra space.\\n\\n\\nPlease do Upvote if it helps :)\\n```\\n\\n# Complexity\\n- Time complexity: O(n) //One pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) //For resultant string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && count==0)\\n                count++;\\n            else if(s[i]==\\'(\\' && count>=1){\\n                res+=s[i];\\n                count++;\\n            }   \\n            else if(s[i]==\\')\\' && count>1){\\n                res+=s[i];\\n                count--;\\n            }\\n            else if(s[i]==\\')\\' && count==1)\\n                count--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nVery Easy Beginner Friendly Solution \\uD83D\\uDCA1\\nDo not use stack to prevent more extra space.\\n\\n\\nPlease do Upvote if it helps :)\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && count==0)\\n                count++;\\n            else if(s[i]==\\'(\\' && count>=1){\\n                res+=s[i];\\n                count++;\\n            }   \\n            else if(s[i]==\\')\\' && count>1){\\n                res+=s[i];\\n                count--;\\n            }\\n            else if(s[i]==\\')\\' && count==1)\\n                count--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319686,
                "title": "easy-to-understand-python-with-comments",
                "content": "```Python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \\'\\'\\n        stack = []\\n        \\n        # basket is used to store previous value\\n        basket = \\'\\'\\n        \\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(p)\\n            else:\\n                stack.pop()\\n            basket += p\\n            \\n            # if the stack is empty it means we have a valid\\n            # decomposition. remove the outer parentheses\\n            # and put it in the result/res. make sure to\\n            # clean up the basket though!\\n            if not stack:\\n                res += basket[1:-1]\\n                basket = \\'\\'\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```Python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \\'\\'\\n        stack = []\\n        \\n        # basket is used to store previous value\\n        basket = \\'\\'\\n        \\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(p)\\n            else:\\n                stack.pop()\\n            basket += p\\n            \\n            # if the stack is empty it means we have a valid\\n            # decomposition. remove the outer parentheses\\n            # and put it in the result/res. make sure to\\n            # clean up the basket though!\\n            if not stack:\\n                res += basket[1:-1]\\n                basket = \\'\\'\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428396,
                "title": "java-beats-98-simple-iterative-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273884,
                "title": "ridiculously-simple-java-o-n-solution-explanation-0ms-beats-100-time-memory",
                "content": "**Explanation:**\\nSince the input String only consists of parentheses we don\\'t even have to mainatain a Stack. We can simply maintain a counter which is O(1) and keep incrementing and decrementing it\\'s value based on the opening/closing bracket.\\n\\n**Algorithm:**\\n1. Convert the given input String to a `char` array and start scanning.\\n2. Maintain a `sum` counter (Initially 0) and for every following character in the input char array,\\n3. When, `(` check whether **sum** is greater than **zero** and if yes, add this char to your String Builder; Also, increment the **sum** by **1** \\n4. When, `)` decrement the **sum** by **1** and then, check whether **sum** is greater than **zero** and if yes, add this char to your String Builder;\\n5. Return the string from your builder.\\n\\n**Code:**\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif (chr[i] == \\'(\\') {\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t\\tsum += 1;\\n\\t\\t} else {\\n\\t\\t\\tsum -= 1;\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```\\n\\n**Compressed Version:**\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif ((chr[i] == \\'(\\' && sum++ > 0) || (chr[i] == \\')\\' && --sum > 0)) {\\n\\t\\t\\tbuilder.append(chr[i]);\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif (chr[i] == \\'(\\') {\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t\\tsum += 1;\\n\\t\\t} else {\\n\\t\\t\\tsum -= 1;\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif ((chr[i] == \\'(\\' && sum++ > 0) || (chr[i] == \\')\\' && --sum > 0)) {\\n\\t\\t\\tbuilder.append(chr[i]);\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269956,
                "title": "c-two-pointers",
                "content": "# Intuition\\nWhen the number of ```open``` parentheses equals ```closed```, we found a primitive string.\\n# Solution\\nUse two pointers to track primitive strings; when ```open == close```, remove outermost parentheses and add the string to the result.\\n```\\nstring removeOuterParentheses(string S, string res = \"\") {\\n  for (auto p1 = 0, p2 = 0, open = 0, close = 0; p2 < S.size(); ++p2) {\\n    if (S[p2] == \\'(\\') ++open;\\n    else ++close;\\n    if (open == close) {\\n      res += S.substr(p1 + 1, p2 - p1 - 1);\\n      p1 = p2 + 1;\\n    }\\n  }\\n  return res;\\n}\\n```\\n# Complexity Analysis\\nRuntime: O(n).\\nMemory: O(n) to store the result.",
                "solutionTags": [],
                "code": "```open```\n```closed```\n```open == close```\n```\\nstring removeOuterParentheses(string S, string res = \"\") {\\n  for (auto p1 = 0, p2 = 0, open = 0, close = 0; p2 < S.size(); ++p2) {\\n    if (S[p2] == \\'(\\') ++open;\\n    else ++close;\\n    if (open == close) {\\n      res += S.substr(p1 + 1, p2 - p1 - 1);\\n      p1 = p2 + 1;\\n    }\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262840,
                "title": "c-stack-and-without-stack-solutions",
                "content": "**Stack implementation**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char>sc;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(sc.size() > 0)\\n                {\\n                    ans += i;\\n                }\\n                sc.push(i);\\n            }\\n            else\\n            {\\n                if(sc.size() > 1)\\n                {\\n                    ans += i;\\n                }\\n                sc.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Without stack implementation**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        int count = 0;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(count > 0)\\n                {\\n                    ans += i;\\n                }\\n                count++;\\n            }\\n            else\\n            {\\n                if(count > 1)\\n                {\\n                    ans += i;\\n                }\\n                count--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char>sc;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(sc.size() > 0)\\n                {\\n                    ans += i;\\n                }\\n                sc.push(i);\\n            }\\n            else\\n            {\\n                if(sc.size() > 1)\\n                {\\n                    ans += i;\\n                }\\n                sc.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        int count = 0;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(count > 0)\\n                {\\n                    ans += i;\\n                }\\n                count++;\\n            }\\n            else\\n            {\\n                if(count > 1)\\n                {\\n                    ans += i;\\n                }\\n                count--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594405,
                "title": "python-super-easy-98-speed",
                "content": "We just need a For-Loop to count the number of Parenthesis open. The \"append\" operator goes at the center of the expression to avoid including the Outermost Patentheses. Cheers,\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        popen, result = 0, []\\n        for x in S:\\n            if x==\\')\\':\\n                popen -= 1\\n            if popen>0:\\n                result.append(x)\\n            if x==\\'(\\':\\n                popen += 1\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        popen, result = 0, []\\n        for x in S:\\n            if x==\\')\\':\\n                popen -= 1\\n            if popen>0:\\n                result.append(x)\\n            if x==\\'(\\':\\n                popen += 1\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301174,
                "title": "javascript-beats-99-26-easy-to-understand",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\';\\n    let open = 0\\n    for (let i = 0; i < S.length; i++) {\\n        if (S[i] === \\'(\\') {\\n            if (open > 0) { \\n\\t\\t\\t\\tresult += \\'(\\';\\n\\t\\t\\t}\\n\\t\\t\\topen++;\\n        } else if (S[i] === \\')\\') {\\n            if (open > 1) { \\n\\t\\t\\t\\tresult += \\')\\'; \\n\\t\\t\\t}\\n\\t\\t\\topen--;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\';\\n    let open = 0\\n    for (let i = 0; i < S.length; i++) {\\n        if (S[i] === \\'(\\') {\\n            if (open > 0) { \\n\\t\\t\\t\\tresult += \\'(\\';\\n\\t\\t\\t}\\n\\t\\t\\topen++;\\n        } else if (S[i] === \\')\\') {\\n            if (open > 1) { \\n\\t\\t\\t\\tresult += \\')\\'; \\n\\t\\t\\t}\\n\\t\\t\\topen--;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680199,
                "title": "python-solution-using-stack-and-maintaining-counter",
                "content": "# Before I explain any further get this, let\\'s say for each \"(\" you get you put -1 and for each \")\" you get you put +1 to the counter varriable and because of that whenever we encounter a valid paranthese our sum will be zero for example for (()())(()) can be decomposed to (()()) + (()) note that for each valid decomposition our sum will be zero. Example (()) -1-1+1+1 ==0 also for (()()) -1-1+1-1+1+1==0 for each time our sum is zero we are looking at a valid decompostion and hence at that moment we take what we have in our stack and remove the outter brackets which is done easily using stack[1:-1] it will exlude the first and last from our stack and we add this value to our answer list and make our stack empty again for future decompistion, we repeat this and return the \" \".join(final_answer) here final answer is the list that has all the decompositions with there outter barckets removed. Upvote if you liked the approch. Thanks\\n\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = []\\n        final_answer = []\\n        counter=0\\n        for val in s:\\n            stack.append(val)\\n            if val==\\'(\\':\\n                counter+=1\\n            elif val==\\')\\':\\n                counter-=1\\n            if counter==0:\\n                final_answer+=stack[1:-1]\\n                stack=[]\\n        \\n        return \"\".join(final_answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = []\\n        final_answer = []\\n        counter=0\\n        for val in s:\\n            stack.append(val)\\n            if val==\\'(\\':\\n                counter+=1\\n            elif val==\\')\\':\\n                counter-=1\\n            if counter==0:\\n                final_answer+=stack[1:-1]\\n                stack=[]\\n        \\n        return \"\".join(final_answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379872,
                "title": "javascript-solution-98-faster",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let parenthesCount = 0;\\n    let result = \"\";\\n    \\n    for (const letter of S) {\\n        if (letter === \"(\") {\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n            parenthesCount++;\\n        } else {\\n            parenthesCount--;\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let parenthesCount = 0;\\n    let result = \"\";\\n    \\n    for (const letter of S) {\\n        if (letter === \"(\") {\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n            parenthesCount++;\\n        } else {\\n            parenthesCount--;\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358358,
                "title": "shortest-python-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        cnt, res = 0, \\'\\'\\n        for c in S:\\n            if c == \\')\\': cnt -= 1  \\n            if cnt != 0: res += c \\n            if c == \\'(\\': cnt+=1    \\n        return res\\n```            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        cnt, res = 0, \\'\\'\\n        for c in S:\\n            if c == \\')\\': cnt -= 1  \\n            if cnt != 0: res += c \\n            if c == \\'(\\': cnt+=1    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399066,
                "title": "python3-simple-solution-99-8",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        count = 0\\n        first = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                count +=1\\n            else:\\n                count -= 1\\n            \\n            if(count == 0):\\n                res +=(S[first+1:i])\\n                first = i+1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        count = 0\\n        first = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                count +=1\\n            else:\\n                count -= 1\\n            \\n            if(count == 0):\\n                res +=(S[first+1:i])\\n                first = i+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194215,
                "title": "best-c-2-solution-ever-string-stack-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using String + Stack.\\n2. Solved using String.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(N), Stack(store) space.\\n\\n    Solved using String + Stack.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> store;\\n        string ans = \"\";\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(store.size() > 0){\\n                    ans += c;\\n                }\\n                store.push(c);\\n            }\\n            else if(c == \\')\\'){\\n                if(store.size() > 1){\\n                    ans += c;\\n                }\\n                store.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the String(ans), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using String.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int openParentheses = 0;\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(openParentheses > 0){\\n                    ans += c;\\n                }\\n                openParentheses++;\\n            }\\n            else if(c == \\')\\'){\\n                if(openParentheses > 1){\\n                    ans += c;\\n                }\\n                openParentheses--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(N), Stack(store) space.\\n\\n    Solved using String + Stack.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> store;\\n        string ans = \"\";\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(store.size() > 0){\\n                    ans += c;\\n                }\\n                store.push(c);\\n            }\\n            else if(c == \\')\\'){\\n                if(store.size() > 1){\\n                    ans += c;\\n                }\\n                store.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the String(ans), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using String.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int openParentheses = 0;\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(openParentheses > 0){\\n                    ans += c;\\n                }\\n                openParentheses++;\\n            }\\n            else if(c == \\')\\'){\\n                if(openParentheses > 1){\\n                    ans += c;\\n                }\\n                openParentheses--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308161,
                "title": "java-in-6-lines",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int count = 0;\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\n\\t\\t\\tif (c == \\'(\\' && count++ > 0) { sb.append(c); }\\n\\t\\t\\tif (c == \\')\\' && --count > 0) { sb.append(c); }\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int count = 0;\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\n\\t\\t\\tif (c == \\'(\\' && count++ > 0) { sb.append(c); }\\n\\t\\t\\tif (c == \\')\\' && --count > 0) { sb.append(c); }\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270153,
                "title": "simple-o-n-java-solution",
                "content": "Thanks to fengyunzhe90.\\n\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        \\n        String result = \"\";\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (stack.isEmpty() && c == \\'(\\') {\\n                stack.push(c);\\n                continue;\\n            }\\n            \\n            if (stack.size() == 1 && c == \\')\\') {\\n                stack.pop();\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            \\n            if (c == \\')\\') {\\n                stack.pop();\\n            }\\n            result += c + \"\";\\n        }\\n\\n        return result;\\n    }\\n} ;",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        \\n        String result = \"\";\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (stack.isEmpty() && c == \\'(\\') {\\n                stack.push(c);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1297744,
                "title": "java-o-n-easy-approach-with-comment",
                "content": "```\\nclass Solution\\n{\\n    public String removeOuterParentheses(String S) \\n    {\\n        Stack<Character> valid=new Stack<>();//checking the balance and when the stack is Empty\\n        List<Integer> index=new ArrayList<>();//for storing the index\\n        char ch;\\n        \\n        for(int i=0;i<S.length();i++)//traversering the indices \\n        {\\n            ch=S.charAt(i);//extracting charracter\\n            if(valid.isEmpty())//new valid parentheses \\n            {\\n                valid.push(ch);//pushing it into the stack the open parentheses \\n                index.add(i);//and pushing it corresponding index \\n            }\\n            else if(ch==\\')\\'&&valid.peek()==\\'(\\')\\n            {\\n                valid.pop();\\n                if(valid.isEmpty())//ending of new valid parentheses\\n                   index.add(i);//storing the closing index \\n            }\\n            else\\n            {\\n                valid.push(ch);//otherwise pushing he open parentheses \\n            }\\n        }\\n        StringBuilder res=new StringBuilder();//resultant \\n        for(int i=0;i<index.size();i+=2)//index is always in pair i.e;starting and ending \\n        {\\n            res.append(S.substring(index.get(i)+1,index.get(i+1)));//removing the outmost parenthesis for the given pair of indices \\n        }\\n        return res.toString();//returning the String \\n    }\\n}//Please do vote me, It helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public String removeOuterParentheses(String S) \\n    {\\n        Stack<Character> valid=new Stack<>();//checking the balance and when the stack is Empty\\n        List<Integer> index=new ArrayList<>();//for storing the index\\n        char ch;\\n        \\n        for(int i=0;i<S.length();i++)//traversering the indices \\n        {\\n            ch=S.charAt(i);//extracting charracter\\n            if(valid.isEmpty())//new valid parentheses \\n            {\\n                valid.push(ch);//pushing it into the stack the open parentheses \\n                index.add(i);//and pushing it corresponding index \\n            }\\n            else if(ch==\\')\\'&&valid.peek()==\\'(\\')\\n            {\\n                valid.pop();\\n                if(valid.isEmpty())//ending of new valid parentheses\\n                   index.add(i);//storing the closing index \\n            }\\n            else\\n            {\\n                valid.push(ch);//otherwise pushing he open parentheses \\n            }\\n        }\\n        StringBuilder res=new StringBuilder();//resultant \\n        for(int i=0;i<index.size();i+=2)//index is always in pair i.e;starting and ending \\n        {\\n            res.append(S.substring(index.get(i)+1,index.get(i+1)));//removing the outmost parenthesis for the given pair of indices \\n        }\\n        return res.toString();//returning the String \\n    }\\n}//Please do vote me, It helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978008,
                "title": "java-simple-solution-runtime-2ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                if (count != 0) {\\n                    result.append(c);\\n                }\\n                count++;\\n            } else {\\n                if (count != 1) {\\n                    result.append(c);\\n                }\\n                count--;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/81901a24-f5a0-4fb4-a020-a3cda419a018_1693337713.2181766.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                if (count != 0) {\\n                    result.append(c);\\n                }\\n                count++;\\n            } else {\\n                if (count != 1) {\\n                    result.append(c);\\n                }\\n                count--;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766133,
                "title": "stack-java",
                "content": "If you like it pls upvote\\n```\\n\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (st.size() >= 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.push(s.charAt(i));\\n            } else {\\n                if (st.size() > 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (st.size() >= 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.push(s.charAt(i));\\n            } else {\\n                if (st.size() > 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271188,
                "title": "c-solution-using-stack",
                "content": "```class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string result=\"\";\\n        stack<char> st;\\n        for(auto ch : S){\\n            if(ch==\\'(\\'){\\n                if(st.size()>0){\\n                    result+=ch;\\n                }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    result+=ch;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string result=\"\";\\n        stack<char> st;\\n        for(auto ch : S){\\n            if(ch==\\'(\\'){\\n                if(st.size()>0){\\n                    result+=ch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2607580,
                "title": "java-2-approaches-with-without-stack",
                "content": "**The main thing is --> (()()) --> If the stack(or counter) is greater than 1 then include \"(\" and \")\" in answer else don\\'t include as we need to remove outermost parenthesis... If you find the solution helpful please  upvote :)**\\n\\n**Without stack approach -->**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int level = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                level++;\\n            }\\n            if(level > 1){\\n                sb.append(s.charAt(i));\\n            }\\n            if(s.charAt(i) == \\')\\'){\\n                level--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n**With Stack Approach-->**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> st = new Stack<>();\\n        for(char c : s.toCharArray()){\\n            if(st.isEmpty() && c == \\'(\\'){\\n                st.push(\\'(\\');\\n            }\\n            else if(!st.isEmpty() && c == \\'(\\'){\\n                st.push(c);\\n                sb.append(c);\\n            }\\n            else if(st.size() >1 && c == \\')\\'){\\n                st.pop();\\n                sb.append(c);\\n            }\\n            else if(st.size() == 1 && c == \\')\\'){\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int level = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                level++;\\n            }\\n            if(level > 1){\\n                sb.append(s.charAt(i));\\n            }\\n            if(s.charAt(i) == \\')\\'){\\n                level--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> st = new Stack<>();\\n        for(char c : s.toCharArray()){\\n            if(st.isEmpty() && c == \\'(\\'){\\n                st.push(\\'(\\');\\n            }\\n            else if(!st.isEmpty() && c == \\'(\\'){\\n                st.push(c);\\n                sb.append(c);\\n            }\\n            else if(st.size() >1 && c == \\')\\'){\\n                st.pop();\\n                sb.append(c);\\n            }\\n            else if(st.size() == 1 && c == \\')\\'){\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977605,
                "title": "c-0ms-shortest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> st;\\n        string ans;\\n        for(char c: S)\\n        {\\n            if(c == \\')\\') st.pop();\\n            if(!st.empty()) ans += c;\\n            if(c == \\'(\\') st.push(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> st;\\n        string ans;\\n        for(char c: S)\\n        {\\n            if(c == \\')\\') st.pop();\\n            if(!st.empty()) ans += c;\\n            if(c == \\'(\\') st.push(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915577,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) space O(n)\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\'\\n    let level = 0\\n    \\n    for(const item of S) {\\n        if(item === \\')\\') {\\n            level--\\n        }\\n        if(level >= 1) {\\n            result += item                \\n        }\\n        if(item === \\'(\\') {\\n            level++\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) space O(n)\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\'\\n    let level = 0\\n    \\n    for(const item of S) {\\n        if(item === \\')\\') {\\n            level--\\n        }\\n        if(level >= 1) {\\n            result += item                \\n        }\\n        if(item === \\'(\\') {\\n            level++\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526367,
                "title": "c-2-solutions-stack-counter",
                "content": "# Solution 1 : Use std::stack\\n\\n## Intuition\\nTo solve this problem, we can keep track of the outer parentheses using a stack. Whenever we encounter an open parenthesis, we push it onto the stack. When we encounter a close parenthesis, we pop an open parenthesis from the stack. We only add the current character to our result string when the stack is not empty.\\n\\n## Approach\\n1 Initialize an empty stack and an empty result string.\\n2. Iterate through the input string:\\na. If the stack is not empty, add the current character to the result string.\\nb. If the current character is an open parenthesis, push it onto the stack.\\nc. If the current character is a close parenthesis, pop an open parenthesis from the stack. If the stack is now empty, remove the last character from the result string.\\n3. Return the result string.\\n\\n## Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string. We iterate through the entire string once.\\n- Space complexity: $$O(n)$$, as in the worst case (e.g., all open parentheses), the stack could store all characters in the input string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::stack<char> stack;\\n        std::string r;\\n\\n        for(auto c: s){\\n            if(!stack.empty()) {\\n                r += c;\\n            }\\n            if(c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            else {\\n                stack.pop();\\n                if(stack.empty()) { \\n                    r.pop_back();\\n                }\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```\\n\\n\\n# Solution 2 : Use a counter\\n\\n## Intuition\\nAn alternative to using a stack is to simply maintain a count of the open parentheses encountered. We can increment the count when we encounter an open parenthesis and decrement it when we encounter a close parenthesis.\\n\\n## Approach\\n1. Initialize an empty result string and a count variable set to 0.\\n2. Iterate through the input string:\\na. If the current character is an open parenthesis and the count is greater than 0, add the current character to the result string and increment the count.\\nb. If the current character is a close parenthesis and the count is greater than 1, add the current character to the result string and decrement the count.\\n3. Return the result string.\\n\\n## Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string. We iterate through the entire string once.\\n- Space complexity: $$O(n)$$, since the result string could store up to n-2 characters (e.g., if the input string has only one pair of outer parentheses).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::string r;\\n        int count = 0;\\n        for(char c : s){\\n            if(c == \\'(\\' && count++ > 0) r += c;\\n            if(c == \\')\\' && count-- > 1) r += c;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::stack<char> stack;\\n        std::string r;\\n\\n        for(auto c: s){\\n            if(!stack.empty()) {\\n                r += c;\\n            }\\n            if(c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            else {\\n                stack.pop();\\n                if(stack.empty()) { \\n                    r.pop_back();\\n                }\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::string r;\\n        int count = 0;\\n        for(char c : s){\\n            if(c == \\'(\\' && count++ > 0) r += c;\\n            if(c == \\')\\' && count-- > 1) r += c;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720986,
                "title": "c-stack-and-without-stack-easy-solution",
                "content": "**Approach 1: (Stack) \\u2705**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    stack<char>st;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st.size()>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st.push(\\'(\\');\\n        }\\n        else\\n        {\\n            if(st.size()>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st.pop();\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n               st.pop();\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Approach 2: (Without Stack ) \\u2705**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    int st=0;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st++;\\n        }\\n        else\\n        {\\n            if(st>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    stack<char>st;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st.size()>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st.push(\\'(\\');\\n        }\\n        else\\n        {\\n            if(st.size()>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st.pop();\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n               st.pop();\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    int st=0;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st++;\\n        }\\n        else\\n        {\\n            if(st>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250239,
                "title": "java-two-solution-1-using-stack-2-simple-for-loop",
                "content": "using Stack\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nusing Array\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int top=-1;\\n        String str=\"\";\\n        for(int i=0;i<S.length()-1;i++){\\n           \\n            if(S.charAt(i)==\\'(\\'&&++top!=0)\\n           {\\n               str+=S.charAt(i);\\n           }\\n            else if(S.charAt(i)==\\')\\'&&--top!=-1)\\n            {\\n                str+=S.charAt(i);\\n            }\\n          \\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int top=-1;\\n        String str=\"\";\\n        for(int i=0;i<S.length()-1;i++){\\n           \\n            if(S.charAt(i)==\\'(\\'&&++top!=0)\\n           {\\n               str+=S.charAt(i);\\n           }\\n            else if(S.charAt(i)==\\')\\'&&--top!=-1)\\n            {\\n                str+=S.charAt(i);\\n            }\\n          \\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162269,
                "title": "python-simplest-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        stack=[]\\n        counter=0\\n        for i in S:\\n            if i==\\'(\\':\\n                counter=counter+1\\n                if counter==1:\\n                    pass\\n                else:\\n                    stack.append(i)\\n            else:\\n                counter=counter-1\\n                if counter == 0:\\n                    pass\\n                else:\\n                    stack.append(i)\\n        return (\\'\\'.join(stack))\\n```\\n\\nDo upvote \\uD83D\\uDC4D if you like and understand my approach!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        stack=[]\\n        counter=0\\n        for i in S:\\n            if i==\\'(\\':\\n                counter=counter+1\\n                if counter==1:\\n                    pass\\n                else:\\n                    stack.append(i)\\n            else:\\n                counter=counter-1\\n                if counter == 0:\\n                    pass\\n                else:\\n                    stack.append(i)\\n        return (\\'\\'.join(stack))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270450,
                "title": "javascript-counter-solution",
                "content": "```\\n/**\\n * @param {string} S\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(S) {\\n    let counter = 0;\\n    let result = \\'\\';\\n    \\n    for (let i = 0; i < S.length; i++) {\\n        if ((S[i] === \\'(\\' && ++counter !== 1) || (S[i] === \\')\\' && --counter !== 0)) {\\n            result += S[i];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(S) {\\n    let counter = 0;\\n    let result = \\'\\';\\n    \\n    for (let i = 0; i < S.length; i++) {\\n        if ((S[i] === \\'(\\' && ++counter !== 1) || (S[i] === \\')\\' && --counter !== 0)) {\\n            result += S[i];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890939,
                "title": "easy-c-solution-beginner-friendly",
                "content": "\\n# Approach\\nThis question is all about the counter. As the very first bracket would start from 0 and thus that will not be included and the last outermost bracket with value 0 will also be not included.\\n\\nIn this way we will check whether the char should be added into the string or not. \\nAdd 1 if there is \\'(\\' open parenthesis. and sub 1 if  \\')\\' clsed paranthesis.\\n\\nFor eg.\\n    \\n![01.png](https://assets.leetcode.com/users/images/0aec98a5-dfdc-452d-9417-ad1e1bacf6eb_1691679008.493465.png)\\n\\n\\nIn above explanation, wherever the count is zero. We are not adding that in string.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int c=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\' && c==0){\\n                //skip, as this would be the first bracket so it will be considered as outermost bracket\\n                c++;\\n            }\\n            else if(ch==\\'(\\' && c>=1){\\n                ans+=ch;\\n                c++;\\n                //add ch in the string\\n            }\\n            else if(ch==\\')\\' && c>1){\\n                //sub ch in the string, as it\\'s pair is alrrady added\\n                ans+=ch;\\n                c--;\\n            }\\n            else if(ch==\\')\\' && c==1){\\n                //skip it, outermost bracket\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int c=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\' && c==0){\\n                //skip, as this would be the first bracket so it will be considered as outermost bracket\\n                c++;\\n            }\\n            else if(ch==\\'(\\' && c>=1){\\n                ans+=ch;\\n                c++;\\n                //add ch in the string\\n            }\\n            else if(ch==\\')\\' && c>1){\\n                //sub ch in the string, as it\\'s pair is alrrady added\\n                ans+=ch;\\n                c--;\\n            }\\n            else if(ch==\\')\\' && c==1){\\n                //skip it, outermost bracket\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876395,
                "title": "c-beats-100-self-explained-beginner-friendly-approach-clean-code-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        stack <char> st;\\n        for(int i:s)\\n        {\\n            if(i==\\'(\\')\\n            {\\n                if(!st.empty())\\n                {\\n                result.push_back(i);\\n                }\\n                st.push(i);\\n            }\\n            else{\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        stack <char> st;\\n        for(int i:s)\\n        {\\n            if(i==\\'(\\')\\n            {\\n                if(!st.empty())\\n                {\\n                result.push_back(i);\\n                }\\n                st.push(i);\\n            }\\n            else{\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627545,
                "title": "remove-outermost-parentheses-cpp-easy-way",
                "content": "```\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if( s[i]==\\'(\\' && count == 0){\\n                count++;\\n            }\\n            else\\n                if(s[i]==\\'(\\' && count>0){\\n                    count++;\\n                    ans+=s[i];\\n                }\\n            else if(s[i]==\\')\\'){\\n                count--;\\n                if(count>0)ans+=s[i];\\n            } \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1949936,
                "title": "simple-short-and-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        string ans = \"\";\\n        stack<char> s;\\n        \\n        for(char c : str){\\n            if(c == \\'(\\') s.push(c);\\n            if(s.size() > 1) ans += c;\\n            if(c == \\')\\') s.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        string ans = \"\";\\n        stack<char> s;\\n        \\n        for(char c : str){\\n            if(c == \\'(\\') s.push(c);\\n            if(s.size() > 1) ans += c;\\n            if(c == \\')\\') s.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338577,
                "title": "python-solution-beats-99",
                "content": "Traverse the string `S` from left to right. Time: O(N).\\n\\nUse the variable `net` to record the current net number of parenthese -- \\'(\\' contributes +1 and \\')\\' contributes -1. \\n\\nThe variable \\'start\\' is to store the starting index of the next primitive part in \\'S\\'.\\n\\nWhenever \\'net\\' becomes 0, one concludes that from the start position to the current position we have a primitive part. Update `res` by adding this primitive part without the starting \\'(\\' and the ending \\')\\'. Also, reset `start`.\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        net, res, start = 0 , \\'\\', 0\\n        for i in range(len(S)):\\n            \\n            if S[i] == \\'(\\':\\n                net += 1\\n            else:\\n                net -= 1\\n            \\n            if net == 0:\\n                res += S[start+1:i]\\n                start = i + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        net, res, start = 0 , \\'\\', 0\\n        for i in range(len(S)):\\n            \\n            if S[i] == \\'(\\':\\n                net += 1\\n            else:\\n                net -= 1\\n            \\n            if net == 0:\\n                res += S[start+1:i]\\n                start = i + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398832,
                "title": "c-and-c-very-easy-solution",
                "content": "# Intuition:First of all,we have to find outer parentheses and after that we have to add other parentheses to a new string.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:Each pair has a couple of parenthese.So we use stack to declare which parenthese is either opener or cleser.\\n<!-- Describe your approach to solving the problem. -->\\n![photo_2023-04-10_05-40-10.jpg](https://assets.leetcode.com/users/images/399e55fc-74f8-4ba0-809c-086907be6e71_1681087371.7124531.jpeg)\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        int index = 0;\\n        for (char x : s) {\\n           switch(x){\\n               case \\'(\\':\\n               if(index++>0)result+=x;\\n               break;\\n               case \\')\\':\\n               if(index-->1)result+=x;\\n               break;\\n           }\\n        }\\n        return result;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        StringBuilder result=new();\\n        int index = 0;\\n        foreach (char x in s) {\\n            if (x == \\'(\\' && index++ > 0) \\n            result.Append(x);\\n            else if (x == \\')\\' && index-- > 1) \\n            result.Append(x);\\n        }\\n        return result.ToString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        int index = 0;\\n        for (char x : s) {\\n           switch(x){\\n               case \\'(\\':\\n               if(index++>0)result+=x;\\n               break;\\n               case \\')\\':\\n               if(index-->1)result+=x;\\n               break;\\n           }\\n        }\\n        return result;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        StringBuilder result=new();\\n        int index = 0;\\n        foreach (char x in s) {\\n            if (x == \\'(\\' && index++ > 0) \\n            result.Append(x);\\n            else if (x == \\')\\' && index-- > 1) \\n            result.Append(x);\\n        }\\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109592,
                "title": "best-o-n-solution",
                "content": "\\n\\n# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                if (count > 0)\\n                    ans += s[i]; \\n                count++;\\n            }\\n            if (s[i] == \\')\\') {\\n                if (count > 1)\\n                    ans += s[i];\\n                count--;\\n            }       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                if (count > 0)\\n                    ans += s[i]; \\n                count++;\\n            }\\n            if (s[i] == \\')\\') {\\n                if (count > 1)\\n                    ans += s[i];\\n                count--;\\n            }       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062859,
                "title": "java-without-using-stack-simple-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       String res=\"\";\\n       int k=0;\\n       int op=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==\\'(\\')op++;\\n           else op--;\\n           if(op==0){\\n               res+=help(s.substring(k,i+1));\\n               k=i+1;\\n           }\\n       }\\n       return res;\\n    }\\n\\n    public static String help(String str)\\n    {\\n        return str.substring(1,str.length()-1);\\n    }\\n}\\n\\n/*\\n s = \"(  ()()   )    (  ()   )\"\\n int k=0;\\n open=0;close=0;\\n ( op=1  ( op=1\\n (op=2   ( op=2\\n )op=1   ) op=1\\n (op=2   ) op=0\\n )op=1\\n)op=0\\nwhen op becomes 0 (op=0) , we gonna found one decompose string and removing it\\'s outer most parenthese\\n*/\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       String res=\"\";\\n       int k=0;\\n       int op=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==\\'(\\')op++;\\n           else op--;\\n           if(op==0){\\n               res+=help(s.substring(k,i+1));\\n               k=i+1;\\n           }\\n       }\\n       return res;\\n    }\\n\\n    public static String help(String str)\\n    {\\n        return str.substring(1,str.length()-1);\\n    }\\n}\\n\\n/*\\n s = \"(  ()()   )    (  ()   )\"\\n int k=0;\\n open=0;close=0;\\n ( op=1  ( op=1\\n (op=2   ( op=2\\n )op=1   ) op=1\\n (op=2   ) op=0\\n )op=1\\n)op=0\\nwhen op becomes 0 (op=0) , we gonna found one decompose string and removing it\\'s outer most parenthese\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009037,
                "title": "without-stack-beats-100-6-lines-solution-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n    int cnt = 0;\\n    string res;\\n    for(char x : s)\\n    { \\n        if(x == \\'(\\'&& cnt++ > 0) res += x;\\n        if (x == \\')\\' && cnt-- > 1) res += x;\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n    int cnt = 0;\\n    string res;\\n    for(char x : s)\\n    { \\n        if(x == \\'(\\'&& cnt++ > 0) res += x;\\n        if (x == \\')\\' && cnt-- > 1) res += x;\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834889,
                "title": "java-faster-solution-99-85-big-o-n-without-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if( s.charAt(i) == \\'(\\'){\\n                count++;\\n                if(count>=2) str.append(\\'(\\');\\n            }else {\\n                if(count>=2) str.append(\\')\\');\\n                count--;\\n            }\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if( s.charAt(i) == \\'(\\'){\\n                count++;\\n                if(count>=2) str.append(\\'(\\');\\n            }else {\\n                if(count>=2) str.append(\\')\\');\\n                count--;\\n            }\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859843,
                "title": "c-easy-understandable-solution-using-stack",
                "content": "```\\nstring removeOuterParentheses(string s) {\\n        stack<char>s1;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(s1.size()>0)\\n                    ans+=\\'(\\';\\n                s1.push(\\'(\\');\\n            }else\\n            {\\n                if(s1.size()>1)\\n                    ans+=\\')\\';\\n                s1.pop();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        stack<char>s1;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(s1.size()>0)\\n                    ans+=\\'(\\';\\n                s1.push(\\'(\\');\\n            }else\\n            {\\n                if(s1.size()>1)\\n                    ans+=\\')\\';\\n                s1.pop();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487636,
                "title": "100-fastest-solution-explained-every-line-efficient-easy-to-understand-cpp-o-n",
                "content": "100% fastest solution | Explained every line | Efficient | Easy to understand | cpp | O(n)\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans;\\n        stack<char> st;\\n\\n        for(auto x: s)\\n        {\\n            if(x==\\'(\\')   // 1. ->add to stack    2. -> add to ans if not outermost\\n            {\\n                if(st.size()>0)\\n                    ans.push_back(x);\\n                st.push(x);\\n            }\\n            else  // 1. -> pop    2. -> add to ans if not empty\\n            {\\n                st.pop();\\n                if(!st.empty())\\n                    ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans;\\n        stack<char> st;\\n\\n        for(auto x: s)\\n        {\\n            if(x==\\'(\\')   // 1. ->add to stack    2. -> add to ans if not outermost\\n            {\\n                if(st.size()>0)\\n                    ans.push_back(x);\\n                st.push(x);\\n            }\\n            else  // 1. -> pop    2. -> add to ans if not empty\\n            {\\n                st.pop();\\n                if(!st.empty())\\n                    ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1209415,
                "title": "python-simple-solution-speed-98-46-and-memory-99-39",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        ans = []\\n        l = []\\n        count = 0\\n        for i in S:\\n            l.append(i)\\n            if i == \\'(\\':\\n                count+= 1\\n            else:\\n                count -= 1\\n            if count == 0:\\n                ans.extend(l[1:-1])\\n                l = []\\n        return \"\".join(ans)\\n\\t\\t\\n\\t# Kindly upvote if you find it useful !!\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        ans = []\\n        l = []\\n        count = 0\\n        for i in S:\\n            l.append(i)\\n            if i == \\'(\\':\\n                count+= 1\\n            else:\\n                count -= 1\\n            if count == 0:\\n                ans.extend(l[1:-1])\\n                l = []\\n        return \"\".join(ans)\\n\\t\\t\\n\\t# Kindly upvote if you find it useful !!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020703,
                "title": "python-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result =  \\'\\'\\n        depth = 0\\n        for index in range(0, len(S) - 1):\\n            char = S[index]\\n            if depth != 0:\\n                result += char\\n            if char == \"(\" and S[index + 1] == \"(\":\\n                depth += 1\\n            elif char == \")\" and S[index + 1] == \")\":\\n                depth -= 1\\n        return result\\n```\\n\\nThe **depth** variable represents how many levels into the primitive parentheses the current parenthesis is in. A depth value of zero represents a paraenteses belonging to a set primitive parentheses.\\n\\n## Logic\\n- Subsequent opening parentheses will result in depth increasing by one\\n- Subsequent closing parentheses will result in depth decreasing by one\\n-  A switch from closing to opening parenthesis \\'(\\' -> \\')\\' will not change the depth value\\n-  If the depth value is not 0 (i.e. not an outer parenthesis) add the current parenthesis to the result\\n-  The last parenthesis in the string S will always be a closing parenthesis [i.e. \")\" ]\\n\\n\\n### Example 1\\n| Depth Value | 0 | 1 | 2 | 2 | 1 | 0 |\\n|:-----------:|:-:|---|---|---|---|---|\\n| char in S      | ( | ( | ( | ) | ) | ) |\\n\\n\\n### Example 2\\n| Depth Value | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |\\n|:-----------:|:-:|---|---|---|---|---|---|---|\\n| char in S  | ( | ( | ) | ) | ( | ( | ) | ) |\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result =  \\'\\'\\n        depth = 0\\n        for index in range(0, len(S) - 1):\\n            char = S[index]\\n            if depth != 0:\\n                result += char\\n            if char == \"(\" and S[index + 1] == \"(\":\\n                depth += 1\\n            elif char == \")\" and S[index + 1] == \")\":\\n                depth -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955525,
                "title": "c-faster-than-100-easy",
                "content": "A simple iterative program that iterates on the string.\\nWe use a variable flag to cound the number of left parenthesis. Since we just have to remove one parenthesis only, we check if the flag value is greater than 1, and then add characters to the resultant string.\\n\\n```\\nConsider the following test case\\n\\n\\tS = \"(()())(())\"\\n\\t\\t\\n\\t\\t\\t1. S[i] = \"(\"  , flag = 1, result = \"\";\\n\\t\\t\\t2. S[i] = \"(\"  , flag = 2, result = \"(\";\\n\\t\\t\\t3. S[i] = \")\"  , flag = 1, result = \"()\";\\n\\t\\t\\t4. S[i] = \"(\"  , flag = 2, result = \"()(\";\\n\\t\\t\\t5. S[i] = \")\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t6. S[i] = \")\"  , flag = 0, result = \"()()\";\\n\\t\\t\\t7. S[i] = \"(\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t8. S[i] = \"(\"  , flag = 2, result = \"()()(\";\\n\\t\\t\\t9. S[i] = \")\"  , flag = 1, result = \"()()()\";\\n\\t\\t\\t10. S[i] = \")\"  , flag = 0, result = \"()()()\";\\n\\t\\t\\t\\n\\t\\t\\tresult = \"()()()\";\\n\\t\\t\\treturn result;\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int flag = 0,l = int(S.length());\\n        string result;\\n        for(int i = 0;i < l;i++){\\n            if(S[i] == \\'(\\'){\\n                flag += 1;\\n                result += flag > 1 ? \"(\" : \"\";\\n            } else {\\n                flag -= 1;\\n                result += flag > 0 ? \")\" : \"\";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/66145b21-665b-4402-ae74-2c6565dceefe_1606804144.1577873.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nConsider the following test case\\n\\n\\tS = \"(()())(())\"\\n\\t\\t\\n\\t\\t\\t1. S[i] = \"(\"  , flag = 1, result = \"\";\\n\\t\\t\\t2. S[i] = \"(\"  , flag = 2, result = \"(\";\\n\\t\\t\\t3. S[i] = \")\"  , flag = 1, result = \"()\";\\n\\t\\t\\t4. S[i] = \"(\"  , flag = 2, result = \"()(\";\\n\\t\\t\\t5. S[i] = \")\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t6. S[i] = \")\"  , flag = 0, result = \"()()\";\\n\\t\\t\\t7. S[i] = \"(\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t8. S[i] = \"(\"  , flag = 2, result = \"()()(\";\\n\\t\\t\\t9. S[i] = \")\"  , flag = 1, result = \"()()()\";\\n\\t\\t\\t10. S[i] = \")\"  , flag = 0, result = \"()()()\";\\n\\t\\t\\t\\n\\t\\t\\tresult = \"()()()\";\\n\\t\\t\\treturn result;\\n```\n```\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int flag = 0,l = int(S.length());\\n        string result;\\n        for(int i = 0;i < l;i++){\\n            if(S[i] == \\'(\\'){\\n                flag += 1;\\n                result += flag > 1 ? \"(\" : \"\";\\n            } else {\\n                flag -= 1;\\n                result += flag > 0 ? \")\" : \"\";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783755,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n    \\tchar [] chars=S.toCharArray();\\n    \\tStringBuilder sb=new  StringBuilder();\\n    \\tStack<Character> st= new Stack<>();\\n    \\tint startindex=0;\\n    \\tfor ( int i=0;i<chars.length;i++ ) {\\n    \\t\\tchar c= chars[i];\\n    \\t\\tif(c==\\'(\\') {\\n    \\t\\t\\tst.push(\\'(\\');\\n    \\t\\t}else if(c==\\')\\') {\\n    \\t\\t\\tst.pop();\\n    \\t\\t}\\n    \\t\\tif(st.isEmpty()) {\\n    \\t\\t\\tsb.append(S.substring((startindex+1),i));\\n    \\t\\t\\tstartindex=i+1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t}\\n    \\t\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n    \\tchar [] chars=S.toCharArray();\\n    \\tStringBuilder sb=new  StringBuilder();\\n    \\tStack<Character> st= new Stack<>();\\n    \\tint startindex=0;\\n    \\tfor ( int i=0;i<chars.length;i++ ) {\\n    \\t\\tchar c= chars[i];\\n    \\t\\tif(c==\\'(\\') {\\n    \\t\\t\\tst.push(\\'(\\');\\n    \\t\\t}else if(c==\\')\\') {\\n    \\t\\t\\tst.pop();\\n    \\t\\t}\\n    \\t\\tif(st.isEmpty()) {\\n    \\t\\t\\tsb.append(S.substring((startindex+1),i));\\n    \\t\\t\\tstartindex=i+1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t}\\n    \\t\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651147,
                "title": "simple-string-operation-no-stacks-used-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        String k=\"\",s=\"\";int c=0,d=0;// c-> to count no. of \\'(\\' and d->no. of \\')\\' \\n        for(int i=0;i<S.length();i++)\\n        {\\n            if(S.charAt(i)==\\'(\\'){\\n            s=s+\\'(\\';\\n                c++;\\n            }\\n            else if(S.charAt(i)==\\')\\')\\n            {\\n                s=s+\\')\\';\\n                d++;\\n            }\\n            if(c==d)// when c==d means one complete bracket series ended....eg: (()()) c==d for this.... \\n            {\\n                k=k+s.substring(1,s.length()-1);// select the string execpt first and last portion 1 -> s.length()-1,which gives ()()\\n                s=\"\";//this for next bracket series\\n                c=d=0;//for next bracket series....\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        String k=\"\",s=\"\";int c=0,d=0;// c-> to count no. of \\'(\\' and d->no. of \\')\\' \\n        for(int i=0;i<S.length();i++)\\n        {\\n            if(S.charAt(i)==\\'(\\'){\\n            s=s+\\'(\\';\\n                c++;\\n            }\\n            else if(S.charAt(i)==\\')\\')\\n            {\\n                s=s+\\')\\';\\n                d++;\\n            }\\n            if(c==d)// when c==d means one complete bracket series ended....eg: (()()) c==d for this.... \\n            {\\n                k=k+s.substring(1,s.length()-1);// select the string execpt first and last portion 1 -> s.length()-1,which gives ()()\\n                s=\"\";//this for next bracket series\\n                c=d=0;//for next bracket series....\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485690,
                "title": "c-solution",
                "content": "```\\nchar * removeOuterParentheses(char * S){\\n    char *str = malloc(sizeof(char) * strlen(S));\\n    int flag = 0,p = 0;\\n    for (int i = 0;i < strlen(S); i++) {\\n        if (S[i]==\\'(\\') {\\n            flag++;\\n            if (flag != 1) {\\n                str[p++] = S[i];\\n            }\\n        }else{\\n            flag--;\\n            if(flag!=0){\\n                str[p++] = S[i];\\n            }\\n        }\\n    }\\n    str[p] = 0;\\n    return str;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * removeOuterParentheses(char * S){\\n    char *str = malloc(sizeof(char) * strlen(S));\\n    int flag = 0,p = 0;\\n    for (int i = 0;i < strlen(S); i++) {\\n        if (S[i]==\\'(\\') {\\n            flag++;\\n            if (flag != 1) {\\n                str[p++] = S[i];\\n            }\\n        }else{\\n            flag--;\\n            if(flag!=0){\\n                str[p++] = S[i];\\n            }\\n        }\\n    }\\n    str[p] = 0;\\n    return str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270763,
                "title": "javascript",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let res = \\'\\',\\n        leftNum = 0;\\n    for(let i = 0; i < S.length; ++i) {\\n        if(S.charAt(i) == \\'(\\') {\\n            leftNum ++;\\n            if(leftNum == 2) {\\n                while(leftNum > 0) {\\n                    res += S.charAt(i);\\n                    S.charAt(++i) == \\'(\\' ? leftNum ++ : leftNum --;\\n                    \\n                }\\n            }\\n        } else\\n            leftNum --;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let res = \\'\\',\\n        leftNum = 0;\\n    for(let i = 0; i < S.length; ++i) {\\n        if(S.charAt(i) == \\'(\\') {\\n            leftNum ++;\\n            if(leftNum == 2) {\\n                while(leftNum > 0) {\\n                    res += S.charAt(i);\\n                    S.charAt(++i) == \\'(\\' ? leftNum ++ : leftNum --;\\n                    \\n                }\\n            }\\n        } else\\n            leftNum --;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269958,
                "title": "python-c-haskell-solutions",
                "content": "**Video Explanation:** https://www.youtube.com/watch?v=ekdNNn3vOqQ\\n\\n1. Group by parentheses substring when LEFT = RIGHT\\n2. Then just shave off the first and last parentheses of each group and rejoin\\n\\n**Python Solution 1:**\\n```\\ndef group(S):\\n\\tt, a, l = 0, 0, []\\n    for i in range(len(S)):\\n        t = t + 1 if S[i] == \\'(\\' else t - 1\\n        if t == 0:\\n            l.append(S[a:i+1])\\n            a = i + 1\\n    return l\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\\n**Python Solution 2 (Functional Programming):**\\n```\\ndef group(S: str) -> str:\\n    a = [1 if i == \\'(\\' else -1 for i in S]    \\n    b = [0] + [i+1 for i, j in enumerate(itertools.accumulate(a)) if j == 0]\\n    return [S[i:j] for i, j in zip(b[:-1], b[1:])]\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\\n**Haskell:**\\n```\\nremoveOuterParentheses s = concat $ map (tail . init) primitives\\n    where primitives = map (map fst) $ init $ segmentAfter ((==0) . snd) (zip s (parenCount s))\\n          parenCount = scanl1 (+) . map (\\\\e -> if e == \\'(\\' then 1 else -1)\\n```\\n**C++:**\\n```\\nstring removeOuterParentheses(string S) {\\n   vector<int> a(S.size()), b(S.size());\\n   transform(S.begin(), S.end(), a.begin(), [](auto c) { return c == \\'(\\' ? 1 : -1; });\\n   partial_sum(a.begin(), a.end(), b.begin());\\n   return accumulate(b.begin(), b.end(), string(),\\n      [&S, t = string(), i = 0](auto s, auto e) mutable {\\n      e == 0 ? s += t.substr(1, t.size() - 1), t = \"\" : t += S[i]; ++i;\\n      return s;\\n   });\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\ndef group(S):\\n\\tt, a, l = 0, 0, []\\n    for i in range(len(S)):\\n        t = t + 1 if S[i] == \\'(\\' else t - 1\\n        if t == 0:\\n            l.append(S[a:i+1])\\n            a = i + 1\\n    return l\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\n```\\ndef group(S: str) -> str:\\n    a = [1 if i == \\'(\\' else -1 for i in S]    \\n    b = [0] + [i+1 for i, j in enumerate(itertools.accumulate(a)) if j == 0]\\n    return [S[i:j] for i, j in zip(b[:-1], b[1:])]\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\n```\\nremoveOuterParentheses s = concat $ map (tail . init) primitives\\n    where primitives = map (map fst) $ init $ segmentAfter ((==0) . snd) (zip s (parenCount s))\\n          parenCount = scanl1 (+) . map (\\\\e -> if e == \\'(\\' then 1 else -1)\\n```\n```\\nstring removeOuterParentheses(string S) {\\n   vector<int> a(S.size()), b(S.size());\\n   transform(S.begin(), S.end(), a.begin(), [](auto c) { return c == \\'(\\' ? 1 : -1; });\\n   partial_sum(a.begin(), a.end(), b.begin());\\n   return accumulate(b.begin(), b.end(), string(),\\n      [&S, t = string(), i = 0](auto s, auto e) mutable {\\n      e == 0 ? s += t.substr(1, t.size() - 1), t = \"\" : t += S[i]; ++i;\\n      return s;\\n   });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886659,
                "title": "c-beats-100-with-explaination-o-n-time-o-1-space",
                "content": "# Intuition\\nOpening parenthesis decreases the counter and closing parenthesis increases the counter\\n```\\n   (  (  )  (  ) )  (  (  ) )\\n0 -1 -2 -1 -2 -1 0 -1 -2 -1 0\\n```\\n\\nThere is always a primitive string after a zero till next zero.\\nWe just need to remove first and last character of primitive string.\\n\\nSo the intution is...\\nIf you get c=0 do not take that character and the character next to it.\\n\\n# Approach\\nIf you encounter c=0, it means previous substring was primitive. So the position at which you are currently, must be opening parenthesis. Make c= -1 and continue.\\n```\\n if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n```\\n\\nIf you got Opening parenthesis decreases the counter else for closing parenthesis increases the counter.\\n```\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n```\\n\\nIf you got c=0, this is last character of primitive parenthesis. Therefore do not push it into ans str.\\n```\\n      if (c == 0) continue;\\n```\\n\\nElse push it into ans string.\\n```\\n      str.push_back(s[i]);\\n```\\n\\n# Code\\n```\\nclass Solution {\\n  public: string removeOuterParentheses(string s) {\\n    string str;\\n    int c = 0;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n      if (c == 0) continue;\\n      str.push_back(s[i]);\\n    }\\n    return str;\\n  }\\n};\\n```\\n\\n# Complexity\\n```\\n- Time complexity: O(n)\\n```\\n\\n```\\n- Space complexity: O(1)\\n```\\n\\n    if(helpful) Upvote++ ;\\n    \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n ![image.png](https://assets.leetcode.com/users/images/56a4f661-44cb-4e7b-98be-49a7b8604658_1691592068.1438534.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   (  (  )  (  ) )  (  (  ) )\\n0 -1 -2 -1 -2 -1 0 -1 -2 -1 0\\n```\n```\\n if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n```\n```\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n```\n```\\n      if (c == 0) continue;\\n```\n```\\n      str.push_back(s[i]);\\n```\n```\\nclass Solution {\\n  public: string removeOuterParentheses(string s) {\\n    string str;\\n    int c = 0;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n      if (c == 0) continue;\\n      str.push_back(s[i]);\\n    }\\n    return str;\\n  }\\n};\\n```\n```\\n- Time complexity: O(n)\\n```\n```\\n- Space complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823992,
                "title": "c-solution-explained",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        // to store the ans\\n        string ans = \"\";\\n        // to keep the track of valid parenthesis we have initialized count variable\\n        // valid parenthesis contains equal number of \\n        int count = 0;\\n        for(char ch: s){\\n            if(ch == \\'(\\' && count == 0){\\n                // this bracket is a part of outermost parenthesis\\n                // dont add it to the ans, skip it\\n                count++;\\n            }else if(ch == \\'(\\' && count >= 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans\\n                ans += ch;\\n                count++;\\n                \\n            }else if(ch == \\')\\' && count > 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans, and decrease the count\\n                ans += ch;\\n                count--;\\n            }else if(ch == \\')\\' && count == 1){\\n                // this bracket is a part of outer parenthesis\\n                // avoid it\\n                count--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        // to store the ans\\n        string ans = \"\";\\n        // to keep the track of valid parenthesis we have initialized count variable\\n        // valid parenthesis contains equal number of \\n        int count = 0;\\n        for(char ch: s){\\n            if(ch == \\'(\\' && count == 0){\\n                // this bracket is a part of outermost parenthesis\\n                // dont add it to the ans, skip it\\n                count++;\\n            }else if(ch == \\'(\\' && count >= 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans\\n                ans += ch;\\n                count++;\\n                \\n            }else if(ch == \\')\\' && count > 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans, and decrease the count\\n                ans += ch;\\n                count--;\\n            }else if(ch == \\')\\' && count == 1){\\n                // this bracket is a part of outer parenthesis\\n                // avoid it\\n                count--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778885,
                "title": "explained-optimized-interview-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nitna to samjh aa jaata hai saab, 350 ques karne k baad\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust use the stack \\n\\n# Complexity\\n- Time complexity:\\nO(n), n is size of given string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//see- https://www.youtube.com/watch?v=MLfAFCkzChU\\n/* algo:\\n   1. check stack empty ? if true then put the 1st char and this will be not ans as it\\'s    outermost.\\n\\n   2. add another cha, check stack is empty or not, if not then it means this char should be in our ans string add it their and then place it inside stack.\\n\\n   3. add another char if it\\'s a closing bracket then remove it\\'s opening bracket from stack and check if stack gets empty after this or not, if yes then it was outermost don\\'t add in ans, if not empty the this can be added to ans string.\\n*/\\n\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        if(s==\"\" || s==\"()\") return \"\";\\n        string ans=\"\";\\n        int n=s.size();\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    ans+=s[i];\\n                    st.push(s[i]);\\n                    \\n                }\\n                else\\n                {\\n                    st.pop();\\n                    if(!st.empty()) ans+=s[i];\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n// PLEASE UPVOTE THANK YOU\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//see- https://www.youtube.com/watch?v=MLfAFCkzChU\\n/* algo:\\n   1. check stack empty ? if true then put the 1st char and this will be not ans as it\\'s    outermost.\\n\\n   2. add another cha, check stack is empty or not, if not then it means this char should be in our ans string add it their and then place it inside stack.\\n\\n   3. add another char if it\\'s a closing bracket then remove it\\'s opening bracket from stack and check if stack gets empty after this or not, if yes then it was outermost don\\'t add in ans, if not empty the this can be added to ans string.\\n*/\\n\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        if(s==\"\" || s==\"()\") return \"\";\\n        string ans=\"\";\\n        int n=s.size();\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    ans+=s[i];\\n                    st.push(s[i]);\\n                    \\n                }\\n                else\\n                {\\n                    st.pop();\\n                    if(!st.empty()) ans+=s[i];\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n// PLEASE UPVOTE THANK YOU\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752187,
                "title": "easy-way-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (cnt == 0 && c == \\'(\\') cnt--;\\n            else if (cnt == -1 && c == \\')\\') cnt++;\\n            else {\\n                res.push_back(c);\\n                if (c == \\'(\\') cnt--;\\n                else cnt++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**compact code**\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (c == \\'(\\' && cnt++ > 0 ) res.push_back(c);\\n            if (c == \\')\\' && cnt-- > 1 ) res.push_back(c);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (cnt == 0 && c == \\'(\\') cnt--;\\n            else if (cnt == -1 && c == \\')\\') cnt++;\\n            else {\\n                res.push_back(c);\\n                if (c == \\'(\\') cnt--;\\n                else cnt++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (c == \\'(\\' && cnt++ > 0 ) res.push_back(c);\\n            if (c == \\')\\' && cnt-- > 1 ) res.push_back(c);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691237,
                "title": "c-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272641,
                "title": "o-n-solution-using-stack-beats-100-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n\\n        stack<char> st;\\n        string ans=\"\";\\n\\n        for(auto c: s){\\n\\n            if(!st.empty()) ans+=c;\\n            if(c==\\'(\\') st.push(c);\\n            else {\\n                st.pop();\\n                 if(st.empty()) ans.pop_back();\\n            }\\n           \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n\\n        stack<char> st;\\n        string ans=\"\";\\n\\n        for(auto c: s){\\n\\n            if(!st.empty()) ans+=c;\\n            if(c==\\'(\\') st.push(c);\\n            else {\\n                st.pop();\\n                 if(st.empty()) ans.pop_back();\\n            }\\n           \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169732,
                "title": "clean-readable-code-c",
                "content": "# Intuition\\nEasy one-liner in C++\\n\\n# Approach\\nYou don\\'t need Python, when you know C++ like me\\n\\n# Complexity\\n- Time complexity: O(-1)\\n\\n- Space complexity: O(inf)\\n\\n# Code\\n```\\nclass Solution {public:string removeOuterParentheses(string s) {string output;int count = 0;for (auto c : s) {if (c == \\')\\') count--;if (count != 0) output += c;if (c == \\'(\\') count++;}return output;}};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {public:string removeOuterParentheses(string s) {string output;int count = 0;for (auto c : s) {if (c == \\')\\') count--;if (count != 0) output += c;if (c == \\'(\\') count++;}return output;}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094732,
                "title": "simple-cpp-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.empty()&&s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>0 &&s[i]==\\'(\\')\\n                {\\n                    st.push(\\'(\\');\\n                    ans+=\\'(\\';\\n                }\\n                else if(st.size()>1 && s[i]==\\')\\')\\n                {\\n                    st.pop();\\n                    ans+=\\')\\';\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.empty()&&s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>0 &&s[i]==\\'(\\')\\n                {\\n                    st.push(\\'(\\');\\n                    ans+=\\'(\\';\\n                }\\n                else if(st.size()>1 && s[i]==\\')\\')\\n                {\\n                    st.pop();\\n                    ans+=\\')\\';\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819789,
                "title": "python-96-77-faster-explained-without-stack-o-n-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c,j,n=0,0,len(s)\\n        ans=[]\\n        for i in range(n):\\n            if s[i]==\\'(\\':\\n                c+=1 #If there is opening paranthesis we increment the counter variable\\n            else:\\n                c-=1 #If there is closing paranthesis we decrement the counter variable\\n#If counter variable is 0 it means that No. of opening paranthesis = No. of closing paranthesis and we get a set of valid parethesis \\n\\t\\t\\t\\tif c==0:\\n#Once we get a valid set of parenthesis we store it in the list where j is the starting index of the valid parenthesis set and i is the last index.\\n#j+1 will remove the opening parenthesis and slicing the string till i(i.e., i-1) will store the valid set of parethesis in list after removing the outermost parenthis\\n                    ans.append(s[j+1:i])\\n                    j=i+1 #Changing the value of starting index for next valid set of parenthesis\\n        return \\'\\'.join(ans) #It will change the list into string\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c,j,n=0,0,len(s)\\n        ans=[]\\n        for i in range(n):\\n            if s[i]==\\'(\\':\\n                c+=1 #If there is opening paranthesis we increment the counter variable\\n            else:\\n                c-=1 #If there is closing paranthesis we decrement the counter variable\\n#If counter variable is 0 it means that No. of opening paranthesis = No. of closing paranthesis and we get a set of valid parethesis \\n\\t\\t\\t\\tif c==0:\\n#Once we get a valid set of parenthesis we store it in the list where j is the starting index of the valid parenthesis set and i is the last index.\\n#j+1 will remove the opening parenthesis and slicing the string till i(i.e., i-1) will store the valid set of parethesis in list after removing the outermost parenthis\\n                    ans.append(s[j+1:i])\\n                    j=i+1 #Changing the value of starting index for next valid set of parenthesis\\n        return \\'\\'.join(ans) #It will change the list into string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518109,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0, start=0;\\n        StringBuilder res= new StringBuilder();\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\')\\n                count++;\\n            else\\n                count--;\\n\\t\\t\\t\\t\\n            if(count==0){\\n                res.append(s.substring(start+1,i));\\n                start=i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0, start=0;\\n        StringBuilder res= new StringBuilder();\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\')\\n                count++;\\n            else\\n                count--;\\n\\t\\t\\t\\t\\n            if(count==0){\\n                res.append(s.substring(start+1,i));\\n                start=i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361682,
                "title": "java-solution-5-lines-faster-and-less-memory-than-99-example-also-in-c-python",
                "content": "Although this problem is labeled as \\'easy\\' it can seem quite difficult at first, especially due to the way the writeup was written.\\n\\nHere is an advice, which has always helped me break down parenthesis problems. There is something called Catalan structures or Catalan numbers. Now, bear with me! This might seem awfully complicated since Catalan numbers is something abstract and mathematical. But take a look at table 2 on page 2 in this paper:\\n http://www.geometer.org/mathcircles/catalan.pdf\\n\\nSee these \\'Mountain Ranges\\'? These can be thought of as matches. Where you would add an upwards leaning match for an open parenthesis and a downwards leaning match for a closing parenthesis. Here is the important part: A Mountain range like this, where we start at the bottom and end at the bottom is a valid parenthesis.\\n\\nNow, if you draw on a piece of paper the three examples given in the write-up. You can see that the problem is only asking you to remove the lowest level of each \\'mountain\\'. Since that is the case, the only thing we need is a counter while we iterate through the characters forming the parenthesis string. For each level we go up (open parenthesis) we increment the counter while we decrement it while we go down. So you can think of the counter as keeping track of the elevation in the mountain range.\\n\\nNow, what I did in my solution was to initialize a counter and a string builder. Whenever there was an open parenthesis at levels other than zero I added the char to the string builder. Whenever there was a closing parenthesis at a level other than 1, I added the parenthesis to the string builder. This effectively removes the bottom level for each mountain in the mountain range\\n\\nWhy does this work? Try drawing it out!\\n\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        for(char c : s.toCharArray())\\n            if      (c == \\'(\\' && count++ != 0) sb.append(c);\\n            else if (c == \\')\\' && count-- != 1) sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n        \\n        int count = 0;            // count elevation\\n        char output[s.length()];  // the output string\\n        int head = 0;             // write head of buffer\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            char c = s[i];\\n            if      (c == \\'(\\' && count++ > 0) output[head++] = c;\\n            else if (c == \\')\\' && count-- > 1) output[head++] = c;\\n        }\\n        \\n        // null terminate the string and return\\n        output[head] = 0;\\n        return output;\\n    }\\n};\\n```\\n\\n**Python 3**\\nNote that using an array, keeps the running time linear (amortized) appending strings would result in O(N^2)\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        output = []\\n        count = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if count > 0: output.append(c)\\n                count += 1\\n            if c == \\')\\':\\n                if count > 1: output.append(c)\\n                count -= 1\\n        return \"\".join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        for(char c : s.toCharArray())\\n            if      (c == \\'(\\' && count++ != 0) sb.append(c);\\n            else if (c == \\')\\' && count-- != 1) sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n        \\n        int count = 0;            // count elevation\\n        char output[s.length()];  // the output string\\n        int head = 0;             // write head of buffer\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            char c = s[i];\\n            if      (c == \\'(\\' && count++ > 0) output[head++] = c;\\n            else if (c == \\')\\' && count-- > 1) output[head++] = c;\\n        }\\n        \\n        // null terminate the string and return\\n        output[head] = 0;\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        output = []\\n        count = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if count > 0: output.append(c)\\n                count += 1\\n            if c == \\')\\':\\n                if count > 1: output.append(c)\\n                count -= 1\\n        return \"\".join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307181,
                "title": "javascript-stack-oriented-solution",
                "content": "var removeOuterParentheses = function(S) {\\n\\n    let stack = [];\\n    let result = \\'\\';\\n    for (const s of S) {\\n       if( s === \\'(\\') {\\n           if (stack.length) {\\n               result+=s;\\n           }\\n           stack.push(s);\\n       } else {\\n           stack.pop();\\n           if (stack.length) {\\n               result+=s;\\n           }\\n       }\\n    }\\n\\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var removeOuterParentheses = function(S) {\\n\\n    let stack = [];\\n    let result = \\'\\';\\n    for (const s of S) {\\n       if( s === \\'(\\') {\\n           if (stack.length) {\\n               result+=s;\\n           }\\n           stack.push(s);\\n       } else {\\n           stack.pop();\\n           if (stack.length) {\\n               result+=s;\\n           }\\n       }\\n    }\\n\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1045167,
                "title": "simple-go-and-java-solutions",
                "content": "Java:\\n\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```\\n\\nGolang:\\n\\n```\\nfunc removeOuterParentheses(S string) string {\\n\\ts := \"\"\\n\\th := []string{}\\n\\n\\tfor _, i2 := range S {\\n\\t\\tif string(i2) == \"(\" {\\n\\t\\t\\tif len(h) != 0 {\\n\\t\\t\\t\\ts += \"(\"\\n\\t\\t\\t}\\n\\t\\t\\th = append(h, \"(\")\\n\\t\\t} else {\\n\\t\\t\\tif len(h) != 1 {\\n\\t\\t\\t\\ts += \")\"\\n\\t\\t\\t}\\n\\t\\t\\th = h[:len(h)-1]\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Go"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```\n```\\nfunc removeOuterParentheses(S string) string {\\n\\ts := \"\"\\n\\th := []string{}\\n\\n\\tfor _, i2 := range S {\\n\\t\\tif string(i2) == \"(\" {\\n\\t\\t\\tif len(h) != 0 {\\n\\t\\t\\t\\ts += \"(\"\\n\\t\\t\\t}\\n\\t\\t\\th = append(h, \"(\")\\n\\t\\t} else {\\n\\t\\t\\tif len(h) != 1 {\\n\\t\\t\\t\\ts += \")\"\\n\\t\\t\\t}\\n\\t\\t\\th = h[:len(h)-1]\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967051,
                "title": "java-solution-with-stack-and-explanation",
                "content": "This works because if the parentheses is outer most and it is a closing parenthese then the size of the stack has to be equal to one. If the parenthese is opening then the size should be 0. Other wise they are inear parentheses.\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935016,
                "title": "easy-way-explanation-every-step",
                "content": "# if your current char is \\'(\\' then two things happen one is stack is empty then don\\'t add char in result means it indicates no outer parentheses is present.if your stack is not empty then definitely have a outer parentheses this time add char into results\\n```\\nif c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n\\n```\\n# when current char is \")\" and popfrom a stack \"(\" .two things happen if your stack is empty it means no outer parentheses.if not empty then outer parentheses is present.so add into result .\\n```\\nelse:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n```\\n# Easy example\\n```\\nYour input\\n\"()()()()\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 2  current char= (  stack=  []\\nresult= \\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 4  current char= (  stack=  []\\nresult= \\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 6  current char= (  stack=  []\\nresult= \\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= \\n\\n\\nOutput\\n\"\"\\n\\n\\n```\\n# simple Example\\n```\\nYour input\\n\"(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= ()\\n\\n\\nOutput\\n\"()\"\\nExpected\\n\"()\"\\n```\\n# hard example\\n```\\n\"(((())))\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= (  stack=  [\\'(\\', \\'(\\']\\nresult= ((\\n\\nposition= 3  current char= (  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= (((\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\', \\'(\\']\\nresult= ((()\\n\\nposition= 5  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= ((())\\n\\nposition= 6  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ((()))\\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= ((()))\\n\\n\\nOutput\\n\"((()))\"\\nExpected\\n\"((()))\"\\n```\\n# complex example\\n```\\nYour input\\n\"(()())(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= (  stack=  [\\'(\\']\\nresult= ()(\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()\\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= ()()\\nposition= 6  current char= (  stack=  []\\nresult= ()()\\n\\nposition= 7  current char= (  stack=  [\\'(\\']\\nresult= ()()(\\n\\nposition= 8  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()()\\n\\nposition= 9  current char= )  stack=  [\\'(\\']\\nresult= ()()()\\n\\nOutput\\n\"()()()\"\\nExpected\\n\"()()()\"\\n\\n```\\n\\n```\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,stack = [],[]\\n        for i,c in enumerate (S):\\n            \\n            if c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n            else:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n           \\n        return \\'\\'.join(res)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nif c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n\\n```\n```\\nelse:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n```\n```\\nYour input\\n\"()()()()\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 2  current char= (  stack=  []\\nresult= \\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 4  current char= (  stack=  []\\nresult= \\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 6  current char= (  stack=  []\\nresult= \\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= \\n\\n\\nOutput\\n\"\"\\n\\n\\n```\n```\\nYour input\\n\"(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= ()\\n\\n\\nOutput\\n\"()\"\\nExpected\\n\"()\"\\n```\n```\\n\"(((())))\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= (  stack=  [\\'(\\', \\'(\\']\\nresult= ((\\n\\nposition= 3  current char= (  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= (((\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\', \\'(\\']\\nresult= ((()\\n\\nposition= 5  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= ((())\\n\\nposition= 6  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ((()))\\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= ((()))\\n\\n\\nOutput\\n\"((()))\"\\nExpected\\n\"((()))\"\\n```\n```\\nYour input\\n\"(()())(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= (  stack=  [\\'(\\']\\nresult= ()(\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()\\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= ()()\\nposition= 6  current char= (  stack=  []\\nresult= ()()\\n\\nposition= 7  current char= (  stack=  [\\'(\\']\\nresult= ()()(\\n\\nposition= 8  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()()\\n\\nposition= 9  current char= )  stack=  [\\'(\\']\\nresult= ()()()\\n\\nOutput\\n\"()()()\"\\nExpected\\n\"()()()\"\\n\\n```\n```\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,stack = [],[]\\n        for i,c in enumerate (S):\\n            \\n            if c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n            else:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n           \\n        return \\'\\'.join(res)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 570594,
                "title": "concept-of-these-kind-of-problems-simple",
                "content": "problem similar to Google Hashcode 2020 Qualification round\\nThe key in these types of problems is to have a variable named depth, and increment and decrement it accordingly [ \\'(\\' depth increases ] \\nHere whenver the depth is currently zero we ignore it, and when it is again going to be zero after a series of open and closing parenthesis we ignore it again. \\n\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int depth=0;\\n        string p;\\n        for(int i=0;i<S.length();i++){\\n            if (S[i]==\\'(\\') {\\n\\t\\t\\t\\tif (depth!=0){\\n                    p+=\\'(\\';\\n\\t\\t\\t\\t}\\n                depth+=1;\\n\\t\\t\\t}\\n            if (S[i]==\\')\\'){\\n\\t\\t\\t\\tif (depth-1!=0){\\n                    p+=\\')\\';\\n\\t\\t\\t\\t}\\n                depth-=1;\\n\\t\\t\\t}    \\n        }\\n        return p;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int depth=0;\\n        string p;\\n        for(int i=0;i<S.length();i++){\\n            if (S[i]==\\'(\\') {\\n\\t\\t\\t\\tif (depth!=0){\\n                    p+=\\'(\\';\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 483874,
                "title": "c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> ss;\\n        string ans = \"\";\\n        \\n        for(char c: S) {\\n            if(ss.empty() && c==\\'(\\') {\\n                ss.push(c);\\n            } else if(ss.size() == 1 && c==\\')\\') {\\n                ss.pop();\\n            } else if(c==\\'(\\') {\\n                ss.push(c);\\n                ans+=c;\\n            } else if(c==\\')\\') {\\n                ss.pop();\\n                ans+=c;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> ss;\\n        string ans = \"\";\\n        \\n        for(char c: S) {\\n            if(ss.empty() && c==\\'(\\') {\\n                ss.push(c);\\n            } else if(ss.size() == 1 && c==\\')\\') {\\n                ss.pop();\\n            } else if(c==\\'(\\') {\\n                ss.push(c);\\n                ans+=c;\\n            } else if(c==\\')\\') {\\n                ss.pop();\\n                ans+=c;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467915,
                "title": "c",
                "content": "```\\npublic string RemoveOuterParentheses(string S) {\\n\\tvar str = new StringBuilder();\\n\\tvar i = 0;\\n\\n\\tforeach (var c in S.ToCharArray()) {\\n\\t\\ti += c == \\'(\\' ? 1 : -1;\\n\\n\\t\\tif (c == \\'(\\' && i > 1 || c == \\')\\' && i > 0)\\n\\t\\t\\tstr.Append(c);\\n\\t}\\n\\n\\treturn str.ToString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string RemoveOuterParentheses(string S) {\\n\\tvar str = new StringBuilder();\\n\\tvar i = 0;\\n\\n\\tforeach (var c in S.ToCharArray()) {\\n\\t\\ti += c == \\'(\\' ? 1 : -1;\\n\\n\\t\\tif (c == \\'(\\' && i > 1 || c == \\')\\' && i > 0)\\n\\t\\t\\tstr.Append(c);\\n\\t}\\n\\n\\treturn str.ToString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358034,
                "title": "haskell-wins-1-liner",
                "content": "This is why Haskell is so beautiful:\\n```\\nsolve :: String -> String\\nsolve = concat \\n      . map (tail . init) \\n      . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```\\nThe one-liner would be:\\n```\\nsolve = concat . map (tail . init) . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```",
                "solutionTags": [],
                "code": "```\\nsolve :: String -> String\\nsolve = concat \\n      . map (tail . init) \\n      . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```\n```\\nsolve = concat . map (tail . init) . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324746,
                "title": "python3-40ms-beas-93",
                "content": "time complexity : O(n)\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        if len(S) <= 2:\\n            return \"\"\\n        \\n        ans = \"\"\\n        count = 0\\n        for c in S:\\n            if c == \"(\":\\n                count += 1\\n                if count > 1:\\n                    ans += c\\n            else:\\n                count -= 1\\n                if count > 0:\\n                    ans += c\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        if len(S) <= 2:\\n            return \"\"\\n        \\n        ans = \"\"\\n        count = 0\\n        for c in S:\\n            if c == \"(\":\\n                count += 1\\n                if count > 1:\\n                    ans += c\\n            else:\\n                count -= 1\\n                if count > 0:\\n                    ans += c\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316971,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        if(S == null) return \"\";\\n        char[] chars = S.toCharArray();\\n        int stack = 0;\\n\\n        StringBuilder builder = new StringBuilder();\\n        for(int i=0; i<chars.length; i++){\\n            if (chars[i] == 40) {\\n                stack ++;\\n                if(stack != 1) builder.append(chars[i]);\\n            } else if (chars[i] == 41) {\\n                stack --;\\n                if(stack != 0) builder.append(chars[i]);\\n            }\\n        }\\n\\n        return builder.toString();\\n    }\\n}\\n```\\n\\n\\nI use an \\u201Cint stack\\u201D to simulate the use of the stack.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        if(S == null) return \"\";\\n        char[] chars = S.toCharArray();\\n        int stack = 0;\\n\\n        StringBuilder builder = new StringBuilder();\\n        for(int i=0; i<chars.length; i++){\\n            if (chars[i] == 40) {\\n                stack ++;\\n                if(stack != 1) builder.append(chars[i]);\\n            } else if (chars[i] == 41) {\\n                stack --;\\n                if(stack != 0) builder.append(chars[i]);\\n            }\\n        }\\n\\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658776,
                "title": "c-2-solutions-using-stack-i-without-stack",
                "content": "\\n# Code\\n```\\n# WITHOUTSTACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int open=0;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(open>0)\\n            ans+=\\'(\\';\\n             open++;\\n        }\\n\\n        if(s[i] == \\')\\'){\\n            if(open>1){\\n                ans+=\\')\\';\\n            }\\n        open--;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\n# STACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(st.size()>0)\\n            ans+=\\'(\\';\\n             st.push(\\'(\\');\\n        }\\n\\n        if(s[i] == \\')\\'){\\n                if(st.size() > 1){\\n                    ans+=\\')\\';\\n                }\\n            st.pop();\\n\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n# WITHOUTSTACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int open=0;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(open>0)\\n            ans+=\\'(\\';\\n             open++;\\n        }\\n\\n        if(s[i] == \\')\\'){\\n            if(open>1){\\n                ans+=\\')\\';\\n            }\\n        open--;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478488,
                "title": "python-simple-clean-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans, cnt = [], 0\\n        for ch in s:\\n            if ch == \\'(\\' and cnt > 0: ans.append(ch)\\n            if ch == \\')\\' and cnt > 1: ans.append(ch)\\n            cnt += 1 if ch == \\'(\\' else -1\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans, cnt = [], 0\\n        for ch in s:\\n            if ch == \\'(\\' and cnt > 0: ans.append(ch)\\n            if ch == \\')\\' and cnt > 1: ans.append(ch)\\n            cnt += 1 if ch == \\'(\\' else -1\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444614,
                "title": "easily-understandable-java-stack-without-stack-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n         StringBuilder sb = new StringBuilder();\\n\\n//               STACK SOLUTION\\n\\n        //  Stack<Character> st = new Stack<>();\\n        //  for(int i=0;i<s.length();i++){\\n        //      char ch = s.charAt(i);\\n        //      if(ch == \\'(\\'){\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //          st.push(ch);                  \\n        //      }else{\\n        //          st.pop();\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //      }\\n        //  }\\n        // return sb.toString();\\n             \\n         int con=0;\\n         for(char c:s.toCharArray()){\\n             if(c==\\'(\\' && con++>0 )sb.append(c);\\n             if(c==\\')\\' && con-->1 )sb.append(c);\\n         }\\n         return sb.toString();\\n    }\\n}\\n/*  \\n-->Solve without using stack:\\nKeep a counter c = 0\\nIncrement when ( found and decrement when ) found\\nif c = 1 means ( is outer most, don\\'t add it to answer\\nif c = 0 means ) is outer most, don\\'t add it to answer\\nelse keep adding parenthesis to answer\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n         StringBuilder sb = new StringBuilder();\\n\\n//               STACK SOLUTION\\n\\n        //  Stack<Character> st = new Stack<>();\\n        //  for(int i=0;i<s.length();i++){\\n        //      char ch = s.charAt(i);\\n        //      if(ch == \\'(\\'){\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //          st.push(ch);                  \\n        //      }else{\\n        //          st.pop();\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //      }\\n        //  }\\n        // return sb.toString();\\n             \\n         int con=0;\\n         for(char c:s.toCharArray()){\\n             if(c==\\'(\\' && con++>0 )sb.append(c);\\n             if(c==\\')\\' && con-->1 )sb.append(c);\\n         }\\n         return sb.toString();\\n    }\\n}\\n/*  \\n-->Solve without using stack:\\nKeep a counter c = 0\\nIncrement when ( found and decrement when ) found\\nif c = 1 means ( is outer most, don\\'t add it to answer\\nif c = 0 means ) is outer most, don\\'t add it to answer\\nelse keep adding parenthesis to answer\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401631,
                "title": "go-golang-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc removeOuterParentheses(s string) string {\\n    var result string\\n    var index int\\n\\n    for _, x := range s {\\n        switch x {\\n        case \\'(\\':\\n            if index > 0 {\\n                result += string(x)\\n            }\\n            index++\\n        case \\')\\':\\n            index--\\n            if index > 0 {\\n                result += string(x)\\n            }\\n        }\\n    }\\n\\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\nfunc removeOuterParentheses(s string) string {\\n    var result string\\n    var index int\\n\\n    for _, x := range s {\\n        switch x {\\n        case \\'(\\':\\n            if index > 0 {\\n                result += string(x)\\n            }\\n            index++\\n        case \\')\\':\\n            index--\\n            if index > 0 {\\n                result += string(x)\\n            }\\n        }\\n    }\\n\\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3352798,
                "title": "c-0ms-solution",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int sum = 1;\\n        string ans = \"\";\\n        // \"we will count the opening and closing bracket\"\\n        int open = 1;\\n        int end = 0;\\n        for(int i = 1; i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                open++;\\n            }else{\\n                end++;\\n            }\\n            if(s[i] == \\')\\' && open == end ){\\n                open = 0;\\n                end = 0;\\n            }else if(open > 1){\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int sum = 1;\\n        string ans = \"\";\\n        // \"we will count the opening and closing bracket\"\\n        int open = 1;\\n        int end = 0;\\n        for(int i = 1; i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                open++;\\n            }else{\\n                end++;\\n            }\\n            if(s[i] == \\')\\' && open == end ){\\n                open = 0;\\n                end = 0;\\n            }else if(open > 1){\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109543,
                "title": "easy-c-without-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n   int n=s.size();\\n   string p;\\n   int c=0;\\n   for(int i=0;i<n;i++)\\n   {\\n       if(s[i]==\\'(\\')\\n       {c++;}\\n       else if(s[i]==\\')\\')\\n       {c--;}\\n        if( c!=1 && s[i]==\\'(\\')\\n        {p+=s[i];}\\n        else if(c!=0 && s[i]==\\')\\')\\n        {\\n            p+=s[i];\\n        }\\n   }\\n   return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n   int n=s.size();\\n   string p;\\n   int c=0;\\n   for(int i=0;i<n;i++)\\n   {\\n       if(s[i]==\\'(\\')\\n       {c++;}\\n       else if(s[i]==\\')\\')\\n       {c--;}\\n        if( c!=1 && s[i]==\\'(\\')\\n        {p+=s[i];}\\n        else if(c!=0 && s[i]==\\')\\')\\n        {\\n            p+=s[i];\\n        }\\n   }\\n   return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953073,
                "title": "without-stack-c-simple-100-fastest",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n![Capture.PNG](https://assets.leetcode.com/users/images/65e175ad-14eb-4977-863f-c412c1d53620_1672049199.2318532.png)\\n\\n# Approach \\n    Keep a counter c = 0\\n    Increment when ( found \\n    decrement when ) found\\n    if c = 1 &&  ( is outer most, don\\'t add it to answer\\n    if c = 0 && ) is outer most, don\\'t add it to answer\\n    else keep adding parenthesis to answer\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        if(s.length()==0) return \"\";\\n        if(s.length()==2) return \"\";\\n        string ans=\"\";\\n        stack<char>st;\\n        int counter=0;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s[i]==\\'(\\') counter++;\\n            else if(s[i]==\\')\\') counter--;\\n            if(s[i]==\\'(\\' && counter!=1) ans+=s[i];\\n            else if(s[i]==\\')\\' && counter!=0) ans+=s[i];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        if(s.length()==0) return \"\";\\n        if(s.length()==2) return \"\";\\n        string ans=\"\";\\n        stack<char>st;\\n        int counter=0;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s[i]==\\'(\\') counter++;\\n            else if(s[i]==\\')\\') counter--;\\n            if(s[i]==\\'(\\' && counter!=1) ans+=s[i];\\n            else if(s[i]==\\')\\' && counter!=0) ans+=s[i];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837110,
                "title": "c-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\";\\n        stack<char> st;\\n        int i=0;\\n        while(i<s.size()){\\n            char ch = s[i];\\n            if(ch ==\\'(\\'){\\n                if(st.size()>0)\\n                res += ch;\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    res +=\\')\\';\\n                }\\n                st.pop();\\n            }\\n          \\n\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\";\\n        stack<char> st;\\n        int i=0;\\n        while(i<s.size()){\\n            char ch = s[i];\\n            if(ch ==\\'(\\'){\\n                if(st.size()>0)\\n                res += ch;\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    res +=\\')\\';\\n                }\\n                st.pop();\\n            }\\n          \\n\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846566,
                "title": "javascript-easy-stepwise",
                "content": "\\n    let count = 0, outer = \"\"\\n    \\n    for(let i = 0 ; i < s.length; i++) {\\n        if(s[i] === \"(\") {\\n            count++\\n        }\\n         if(count > 1) {\\n            outer += s[i]\\n        }\\n        if(s[i] === \")\") {\\n            count--\\n        }\\n    }\\n    return outer\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n    let count = 0, outer = \"\"\\n    \\n    for(let i = 0 ; i < s.length; i++) {\\n        if(s[i] === \"(\") {\\n            count++\\n        }\\n         if(count > 1) {\\n            outer += s[i]\\n        }\\n        if(s[i] === \")\") {\\n            count--\\n        }\\n    }\\n    return outer\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1804384,
                "title": "without-stack-simple-solution-c",
                "content": "**My Approach**\\n\\nMaintain  a counter that counts the incoming open parenthesis \\'(\\'  \\nif count is 0 then we ignore it o/w add it to o/p string \\nsimilar case is for closing parenthesis :\\nif count is 0 we ignore o/w add it to the o/p string.\\n\\n**Time Complexity : O(N)**\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\' && count++)\\n                ans+=\"(\";\\n            else if(s[i]==\\')\\'&& (--count))\\n                ans+=\")\";\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote \\uD83D\\uDC4D\\uD83C\\uDFFB and Spread Motivation !!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\' && count++)\\n                ans+=\"(\";\\n            else if(s[i]==\\')\\'&& (--count))\\n                ans+=\")\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637392,
                "title": "python-idea-of-stack",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = 0\\n        start = 0\\n        answer = \\'\\'\\n\\n        for i,j in enumerate(s):\\n            if j == \"(\":\\n                stack+= 1\\n            elif j == \")\":\\n                stack -= 1\\n            if stack == 0:\\n                answer += s[start+1:i:]\\n                start = i+1\\n\\n        return answer\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = 0\\n        start = 0\\n        answer = \\'\\'\\n\\n        for i,j in enumerate(s):\\n            if j == \"(\":\\n                stack+= 1\\n            elif j == \")\":\\n                stack -= 1\\n            if stack == 0:\\n                answer += s[start+1:i:]\\n                start = i+1\\n\\n        return answer\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1425905,
                "title": "clean-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans = \"\"\\n        stack = []\\n        \\n        for br in s:\\n            if br == \\'(\\':\\n                if stack:\\n                    ans+=br\\n                stack.append(br)\\n            else:\\n                ch = stack.pop()\\n                if stack:\\n                    ans+=br\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans = \"\"\\n        stack = []\\n        \\n        for br in s:\\n            if br == \\'(\\':\\n                if stack:\\n                    ans+=br\\n                stack.append(br)\\n            else:\\n                ch = stack.pop()\\n                if stack:\\n                    ans+=br\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1381567,
                "title": "c-tc-o-n-sc-o-n",
                "content": "**Feel free to post your doubts in comment**\\n```\\nstring removeOuterParentheses(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n        int co=0, cc=0;\\n        int start=0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'(\\') co++;\\n            else cc++;\\n            if(co==cc){\\n                for(int j=start+1; j<i; j++)\\n                    ans+=s[j];\\n                start=i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n        int co=0, cc=0;\\n        int start=0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'(\\') co++;\\n            else cc++;\\n            if(co==cc){\\n                for(int j=start+1; j<i; j++)\\n                    ans+=s[j];\\n                start=i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374386,
                "title": "be-water-my-friend-time-o-n-no-substring-function-c",
                "content": "*Runtime: 0 ms, faster than 100.00% of C++ online submissions for Remove Outermost Parentheses.*\\n\\nJust keep incrementing and decrementing number of open bracket and take decisions.\\n\\n1st Decision: The current character will be part of the result if you have seen at least 1 opening bracket.\\n2nd Decision: As we are first decrementing we have to handle the last valid closing bracket explicitely.\\n\\nThat\\'s it.\\nStraightforward.\\n\\n```\\nstring removeOuterParentheses(string str) {\\n    int open = 0;\\n    string result = \"\";\\n    for (auto bracket : str) {\\n        bracket == \\'(\\' ? ++open : --open;\\n        if (open > 1 || (open == 1 && bracket == \\')\\')) {\\n            result += bracket;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nIf you are having problem understanding do one dry run on your own\\n\\n**My Dry Run**\\n**str = ( ( ) ) ( )**\\n\\nstrSeen = ( \\nresult = \"\"\\nopen = 1\\n\\nstrSeen = ( (\\nresult = \"(\"\\nopen = 2\\n\\nstrSeen = ( ( ) \\nresult = \"()\"\\nopen = 1\\n\\nstrSeen = ( ( ) )\\nresult = \"()\"\\nopen = 0\\n\\nstrSeen = ( ( ) ) (\\nresult = \"()\"\\nopen = 1\\n\\nstrSeen = ( ( ) ) ( )\\nresult = \"()\"\\nopen = 0",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring removeOuterParentheses(string str) {\\n    int open = 0;\\n    string result = \"\";\\n    for (auto bracket : str) {\\n        bracket == \\'(\\' ? ++open : --open;\\n        if (open > 1 || (open == 1 && bracket == \\')\\')) {\\n            result += bracket;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059557,
                "title": "cpp-use-counter-to-record-the-unmatched-pairs",
                "content": "## Analysis\\n\\nIn order to identify which parenthesis to be included inside our return string, we need to check two cases:\\n\\n1. If current **open parenthesis** is the first parenthesis in the block of the decomposition, we should not add it. This means the current **unmatched pairs** in block is 1.\\n2. If current **close parenthesis** is the last parenthesis in the block of the decomposition, we should not add it. This means the current **unmatched pairs** in block is 0.\\n\\nLet\\'s walk through an example:\\n\\nThe left most column represents the current processing parthesis\\n\\n```\\nFor \"(()(()))\":\\n(    (|()(())): we have 1 unmatched pair -> \"\" don\\'t do anything here\\n(    ((|)(())): we have 2 unmatched pair -> \"(\"\\n)    (()|(())): we have 1 unmatched pair -> \"()\"\\n(    (()(|())): we have 2 unmatched pair -> \"()(\"\\n(    (()((|))): we have 3 unmatched pair -> \"()((\"\\n)    (()(()|)): we have 2 unmatched pair -> \"()(()\"\\n)    (()(())|): we have 1 unmatched pair -> \"()(())\"\\n)    (()(()))|: we have 0 unmatched pair -> \"()(())\" don\\'t do anything here\\n```\\n\\nFrom this example, we can see that all we need is to count the number of unmatched pairs as well as the current processing parenthesis.\\n\\nTime: $O(n)$\\n\\nSpace: $O(1)$\\n\\n## Code\\n\\n```c++\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int cnt = 0;\\n        for (char& c : S) {\\n            if (c == \\'(\\' && ++cnt != 1)\\n                res += c;\\n            if (c == \\')\\' && --cnt != 0)\\n                res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNote that since the input is always valid (no mismatch), we can just use != instead of >= to check the unmatched pairs.\\n\\nThis analysis is included in: https://peterchen.xyz/Leetcode/1021.-Remove-Outermost-Parentheses/\\nIf you want to check my other analysis, please visit https://peterchen.xyz/\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nFor \"(()(()))\":\\n(    (|()(())): we have 1 unmatched pair -> \"\" don\\'t do anything here\\n(    ((|)(())): we have 2 unmatched pair -> \"(\"\\n)    (()|(())): we have 1 unmatched pair -> \"()\"\\n(    (()(|())): we have 2 unmatched pair -> \"()(\"\\n(    (()((|))): we have 3 unmatched pair -> \"()((\"\\n)    (()(()|)): we have 2 unmatched pair -> \"()(()\"\\n)    (()(())|): we have 1 unmatched pair -> \"()(())\"\\n)    (()(()))|: we have 0 unmatched pair -> \"()(())\" don\\'t do anything here\\n```\n```c++\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int cnt = 0;\\n        for (char& c : S) {\\n            if (c == \\'(\\' && ++cnt != 1)\\n                res += c;\\n            if (c == \\')\\' && --cnt != 0)\\n                res += c;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053939,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int leftBracket = 0;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char currChar:S.toCharArray())\\n        {\\n            if(currChar==\\'(\\')\\n            {\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n                leftBracket++;\\n            }\\n            else\\n            {\\n                leftBracket--;\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int leftBracket = 0;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char currChar:S.toCharArray())\\n        {\\n            if(currChar==\\'(\\')\\n            {\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n                leftBracket++;\\n            }\\n            else\\n            {\\n                leftBracket--;\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615583,
                "title": "python-3-easy-solution-with-explanation-20ms-99-95-speed",
                "content": "maintain a pointer variable to point which index you encountered, if the value of the variable is 0, you\\'re pointing to the opening of the outer braces, then you don\\'t append it to the result. \\nEach time we encounter a left brace we increment the value of ptr by 1, for a right brace we decrement it by 1. I\\'ll just explain this segment: \"(()())\" \\nnow look:\\n( => ptr = 0, don\\'t append to res; increment it and you get ptr = 1\\n( => ptr = 1, append to res; increment it and you get ptr = 2, \\n) => ptr = 2, decrement it and you get ptr = 1, append to res\\n( => ptr = 1, append to res; increment it and you get ptr = 2, \\n) => ptr = 2,  decrement it and you get ptr = 1, append to res\\n) => ptr = 1,  decrement it and you get ptr = 0, don\\'t append to res\\nthus you proceed\\n\\n```\\ndef removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        ptr = 0\\n        for c in S:\\n            if c==\\')\\':\\n                ptr-=1\\n            if ptr:\\n                res+=c\\n            if c==\\'(\\': \\n                ptr+=1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        ptr = 0\\n        for c in S:\\n            if c==\\')\\':\\n                ptr-=1\\n            if ptr:\\n                res+=c\\n            if c==\\'(\\': \\n                ptr+=1\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 584245,
                "title": "stack-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char>s;\\n        vector<int>partitions;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'(\\') s.push(S[i]);\\n            else {\\n                s.pop();\\n                if(s.empty()) partitions.push_back(i);\\n            }\\n        }\\n        int start = 1;\\n        string ans = \"\";\\n        for(int i=0;i<partitions.size();i++){\\n            string yo = S.substr(start,partitions[i]-start);\\n            ans += yo;\\n            start = partitions[i]+2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char>s;\\n        vector<int>partitions;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'(\\') s.push(S[i]);\\n            else {\\n                s.pop();\\n                if(s.empty()) partitions.push_back(i);\\n            }\\n        }\\n        int start = 1;\\n        string ans = \"\";\\n        for(int i=0;i<partitions.size();i++){\\n            string yo = S.substr(start,partitions[i]-start);\\n            ans += yo;\\n            start = partitions[i]+2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513253,
                "title": "python-o-n-time-o-1-space",
                "content": "Somewhat counter intuitive, but hey it works\\n```python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        parentheses = 0 \\n        result = \"\"\\n        for c in S:\\n            if(c == \"(\"):\\n                parentheses += 1\\n            \\n            if(parentheses > 1):\\n                result += c\\n            \\n            if(c == \")\"):\\n                parentheses -= 1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        parentheses = 0 \\n        result = \"\"\\n        for c in S:\\n            if(c == \"(\"):\\n                parentheses += 1\\n            \\n            if(parentheses > 1):\\n                result += c\\n            \\n            if(c == \")\"):\\n                parentheses -= 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504575,
                "title": "python-simple-solution",
                "content": "```\\n\\n```#40 ms, faster than 42.94% of Python3 online submissions for Remove Outermost Parentheses.\\n#12.9 MB, less than 100.00% of Python3 online submissions for Remove Outermost Parentheses.\\n\\nclass Solution:\\n\\tdef removeOuterParentheses(self, S: str) -> str:\\n        stacks = []\\n        result = \\'\\'\\n        for ch in S:\\n            stacks.append(ch)\\n            if (stacks.count(\\'(\\') == stacks.count(\\')\\')):\\n                result += (\\'\\'.join(stacks[1:-1]))\\n                stacks.clear()\\n        return (result)\\n",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459604,
                "title": "java-very-easy-solution",
                "content": "Use the depth of parentheses.\\n\\n```java\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder result = new StringBuilder();\\n        int depth = 0;\\n\\n        for (Character character : S.toCharArray()) {\\n            if (character == \\'(\\') {\\n                depth += 1;\\n            }\\n\\n            if (depth > 1) {\\n                result.append(character);\\n            }\\n\\n            if (character == \\')\\') {\\n                depth -= 1;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder result = new StringBuilder();\\n        int depth = 0;\\n\\n        for (Character character : S.toCharArray()) {\\n            if (character == \\'(\\') {\\n                depth += 1;\\n            }\\n\\n            if (depth > 1) {\\n                result.append(character);\\n            }\\n\\n            if (character == \\')\\') {\\n                depth -= 1;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416446,
                "title": "java-stack-solution",
                "content": "\\t\\t public String removeOuterParentheses(String S) {\\n\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t        stack.push(S.charAt(0));\\n\\t\\t\\t\\t   String ans = \"\";\\n\\t\\t\\t\\t   for(int i=1;i<S.length();i++) {\\n\\t\\t\\t\\tif(S.charAt(i) == \\'(\\' && stack.isEmpty()) {\\n\\t\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\t} else if(S.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tif(!stack.isEmpty())\\n\\t\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "solutionTags": [],
                "code": "\\t\\t public String removeOuterParentheses(String S) {\\n\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t        stack.push(S.charAt(0));\\n\\t\\t\\t\\t   String ans = \"\";\\n\\t\\t\\t\\t   for(int i=1;i<S.length();i++) {\\n\\t\\t\\t\\tif(S.charAt(i) == \\'(\\' && stack.isEmpty()) {\\n\\t\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\t} else if(S.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tif(!stack.isEmpty())\\n\\t\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 371270,
                "title": "java-100-runtime-and-memory-9-lines",
                "content": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder SB = new StringBuilder();\\n\\tint currDepth = 0;\\n\\tfor(char curr : S.toCharArray()) {\\n\\t\\tif(curr == \\'(\\' && (currDepth += 1) > 1) SB.append(curr);\\n\\t\\telse if (curr == \\')\\' && (currDepth -= 1) >= 1) SB.append(curr);\\n\\t}\\n\\treturn SB.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder SB = new StringBuilder();\\n\\tint currDepth = 0;\\n\\tfor(char curr : S.toCharArray()) {\\n\\t\\tif(curr == \\'(\\' && (currDepth += 1) > 1) SB.append(curr);\\n\\t\\telse if (curr == \\')\\' && (currDepth -= 1) >= 1) SB.append(curr);\\n\\t}\\n\\treturn SB.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306738,
                "title": "easy-python-solution-using-stack",
                "content": "```\\n# Main idea is to use stack, we push the character to stack and pop when stack is not empty and character is \\')\\'\\n# If there is only one character \\'(\\' and the current character in string is \\')\\', then pop the stack and append the substring : S[j+1:i] to result and update\\n# j to i+1\\n# Return result string\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,j = \"\",0\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and S[i]==\\')\\':\\n                if len(my_stack)==1:\\n                    my_stack.pop() \\n                    res+=S[j+1:i] #To ignore first character which is \\'(\\' in order to remove-outermost-parentheses\\n                    j=i+1\\n                else:\\n                    my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n# Main idea is to use stack, we push the character to stack and pop when stack is not empty and character is \\')\\'\\n# If there is only one character \\'(\\' and the current character in string is \\')\\', then pop the stack and append the substring : S[j+1:i] to result and update\\n# j to i+1\\n# Return result string\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,j = \"\",0\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and S[i]==\\')\\':\\n                if len(my_stack)==1:\\n                    my_stack.pop() \\n                    res+=S[j+1:i] #To ignore first character which is \\'(\\' in order to remove-outermost-parentheses\\n                    j=i+1\\n                else:\\n                    my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281068,
                "title": "python-beats-95-of-the-solutions",
                "content": "Python Solution \\n\\n```\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        count = 0 \\n        output_S = []\\n        for c in S:\\n            if c == \\')\\':\\n                count -= 1\\n            \\n            if count > 0:\\n                output_S.append(c)\\n            \\n            if c == \\'(\\':\\n                count += 1\\n        \\n        return \\'\\'.join(output_S)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        count = 0 \\n        output_S = []\\n        for c in S:\\n            if c == \\')\\':\\n                count -= 1\\n            \\n            if count > 0:\\n                output_S.append(c)\\n            \\n            if c == \\'(\\':\\n                count += 1\\n        \\n        return \\'\\'.join(output_S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270143,
                "title": "c-solution-using-one-stack-and-one-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> open;\\n        queue<char> primitive;\\n        string output;\\n        for(int i=0; i<S.length(); i++) {\\n            primitive.push(S[i]);\\n            if(S[i] == \\'(\\') {\\n                open.push(S[i]);\\n            }\\n            else {\\n                open.pop();\\n                if(open.empty()) {\\n                    primitive.pop();\\n                    while(!primitive.empty()) {\\n                        output.push_back(primitive.front());\\n                        primitive.pop();\\n                    }\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\nStack stores the opening brackets. Once the stack is empty, we found one primitive. Primitives are stored in queue. We remove the outer brackets and store in output.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> open;\\n        queue<char> primitive;\\n        string output;\\n        for(int i=0; i<S.length(); i++) {\\n            primitive.push(S[i]);\\n            if(S[i] == \\'(\\') {\\n                open.push(S[i]);\\n            }\\n            else {\\n                open.pop();\\n                if(open.empty()) {\\n                    primitive.pop();\\n                    while(!primitive.empty()) {\\n                        output.push_back(primitive.front());\\n                        primitive.pop();\\n                    }\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269960,
                "title": "python-straightforward-concise-valid-paranthesis",
                "content": "* Check valid paranthesis as usual.\\n* When it is balanced, add to res.\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        l = r = 0\\n        res = cur = \\'\\'\\n        for s in S:\\n            cur += s\\n            l += s == \\'(\\'\\n            r += s == \\')\\'\\n            if l == r:\\n                res += cur[1:-1]\\n                cur = \\'\\'\\n        return res \\n```\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        l = r = 0\\n        res = cur = \\'\\'\\n        for s in S:\\n            cur += s\\n            l += s == \\'(\\'\\n            r += s == \\')\\'\\n            if l == r:\\n                res += cur[1:-1]\\n                cur = \\'\\'\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 269955,
                "title": "simple-python-counter",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result = []\\n        counter = 1\\n        i = 1\\n        while i < len(S):\\n            counter += 1 if S[i] == \"(\" else -1\\n            if counter != 0:\\n                result.append(S[i])\\n            else:\\n                counter = 1\\n                i += 1\\n            i += 1\\n        return \"\".join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result = []\\n        counter = 1\\n        i = 1\\n        while i < len(S):\\n            counter += 1 if S[i] == \"(\" else -1\\n            if counter != 0:\\n                result.append(S[i])\\n            else:\\n                counter = 1\\n                i += 1\\n            i += 1\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269954,
                "title": "my-8-lines-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res = \"\";\\n        int cnt = 0, start = 0, n = S.size();\\n        for (int i = 0; i < n; ++i) {\\n            (S[i] == \\'(\\') ? ++cnt : --cnt;\\n            if (cnt != 0) continue;\\n            res += S.substr(start + 1, i - start - 1);\\n            start = i + 1;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res = \"\";\\n        int cnt = 0, start = 0, n = S.size();\\n        for (int i = 0; i < n; ++i) {\\n            (S[i] == \\'(\\') ? ++cnt : --cnt;\\n            if (cnt != 0) continue;\\n            res += S.substr(start + 1, i - start - 1);\\n            start = i + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4008513,
                "title": "js-simple-beats-95-easy-approach",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function (s) {\\n    let openCount = 0;\\n    let output = \"\";\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            if (openCount) output += s[i];\\n            openCount++;\\n        }\\n        else if (s[i] === \")\") {\\n            openCount--;\\n            if (openCount) output += s[i];\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function (s) {\\n    let openCount = 0;\\n    let output = \"\";\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            if (openCount) output += s[i];\\n            openCount++;\\n        }\\n        else if (s[i] === \")\") {\\n            openCount--;\\n            if (openCount) output += s[i];\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816879,
                "title": "single-pass-c-solution-without-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string a=\"\";\\n        int balanced=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n                balanced++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                balanced--;\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string a=\"\";\\n        int balanced=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n                balanced++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                balanced--;\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804317,
                "title": "c-o-n-tc-o-1-sc",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        //keeping track of opened\\n        //opened --> represent no. of opened without closed \\n        //\"(()())(())\"\\n        // \"((\" --> opened=2; \\n        // \"(()\"  --> opened=1; \\n        string ans;\\n        int opened=0;\\n        for(auto i:s){\\n            if(i==\\'(\\' && opened++>0)    ans+=i;\\n            if(i==\\')\\' && opened-->1)    ans+=i;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        //keeping track of opened\\n        //opened --> represent no. of opened without closed \\n        //\"(()())(())\"\\n        // \"((\" --> opened=2; \\n        // \"(()\"  --> opened=1; \\n        string ans;\\n        int opened=0;\\n        for(auto i:s){\\n            if(i==\\'(\\' && opened++>0)    ans+=i;\\n            if(i==\\')\\' && opened-->1)    ans+=i;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711986,
                "title": "c-easy-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.length();\\n        string ans;\\n        int count=0;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(count==0)count++;\\n                else\\n                {\\n                    count++;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                if(count==1)\\n                {\\n                    count--;\\n                }\\n                else\\n                {\\n                    count--;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.length();\\n        string ans;\\n        int count=0;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(count==0)count++;\\n                else\\n                {\\n                    count++;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                if(count==1)\\n                {\\n                    count--;\\n                }\\n                else\\n                {\\n                    count--;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585998,
                "title": "problem-1021-remove-outer-parentheses-solwed-with-stack-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        var stk = new Stack<char>();\\n        var qavslar = \"\";\\n        foreach (char c in s)\\n        {\\n            if(c == \\'(\\') stk.Push(c);\\n            if(stk.Count > 1) qavslar += c;\\n            if(c == \\')\\') stk.Pop();\\n        }\\n        return qavslar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        var stk = new Stack<char>();\\n        var qavslar = \"\";\\n        foreach (char c in s)\\n        {\\n            if(c == \\'(\\') stk.Push(c);\\n            if(stk.Count > 1) qavslar += c;\\n            if(c == \\')\\') stk.Pop();\\n        }\\n        return qavslar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487236,
                "title": "stack-c-beats-90",
                "content": "# Code\\n```\\nusing System.Text;\\n\\npublic class Solution \\n{\\n    public string RemoveOuterParentheses(string s) \\n    {\\n        Stack<char> stack = new Stack<char>();\\n        StringBuilder ans = new(\"\");\\n\\n        foreach (char c in s.ToCharArray())\\n        {\\n            if (c is \\'(\\')\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    ans.Append(\\'(\\');\\n                }\\n\\n                stack.Push(c);\\n            }\\n            else\\n            {\\n                if (stack.Count > 1)\\n                {\\n                    ans.Append(\\')\\');\\n\\n                }\\n\\n                stack.Pop();\\n            }\\n        }\\n\\n        return ans.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Text;\\n\\npublic class Solution \\n{\\n    public string RemoveOuterParentheses(string s) \\n    {\\n        Stack<char> stack = new Stack<char>();\\n        StringBuilder ans = new(\"\");\\n\\n        foreach (char c in s.ToCharArray())\\n        {\\n            if (c is \\'(\\')\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    ans.Append(\\'(\\');\\n                }\\n\\n                stack.Push(c);\\n            }\\n            else\\n            {\\n                if (stack.Count > 1)\\n                {\\n                    ans.Append(\\')\\');\\n\\n                }\\n\\n                stack.Pop();\\n            }\\n        }\\n\\n        return ans.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477847,
                "title": "simplest-method-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        int cnt = 0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                cnt--;\\n            }\\n            if((s[i]==\\'(\\' && cnt==1) || (s[i]==\\')\\'&& cnt==0))\\n            {\\n                continue;\\n            }\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        int cnt = 0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                cnt--;\\n            }\\n            if((s[i]==\\'(\\' && cnt==1) || (s[i]==\\')\\'&& cnt==0))\\n            {\\n                continue;\\n            }\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411357,
                "title": "c-without-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int st=0;\\n        string ans;\\n        for(auto a: s)\\n        {\\n            if(a == \\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int st=0;\\n        string ans;\\n        for(auto a: s)\\n        {\\n            if(a == \\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392528,
                "title": "one-pass-o-1-space-simplest-just-count-parenthesis",
                "content": "If you find this solution helpful, **Upvote**. \\uD83D\\uDC4D \\n\\n```\\n  string removeOuterParentheses(string s) {\\n     int count=0;\\n     int j=0;\\n     for(int i=0;i<s.size();i++){   \\n        \\n         if(s[i]==\\'(\\')count++;\\n         if(s[i]==\\')\\')count--;\\n         if(s[i]==\\')\\' and count==0){\\n\\t\\t \\n             s.erase(i,1);         //rightmost parenthesis.\\n             s.erase(j,1);        //leftmost parenthesis.\\n             i=i-2;                //adjusting i after deletion\\n             j=i+1;                //intializing starting parenthesis\\n\\t\\t\\t \\n         }      \\n     }\\n        return s;\\n    }",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "If you find this solution helpful, **Upvote**. \\uD83D\\uDC4D \\n\\n```\\n  string removeOuterParentheses(string s) {\\n     int count=0;\\n     int j=0;\\n     for(int i=0;i<s.size();i++){   \\n        \\n         if(s[i]==\\'(\\')count++;\\n         if(s[i]==\\')\\')count--;\\n         if(s[i]==\\')\\' and count==0){\\n\\t\\t \\n             s.erase(i,1);         //rightmost parenthesis.\\n             s.erase(j,1);        //leftmost parenthesis.\\n             i=i-2;                //adjusting i after deletion\\n             j=i+1;                //intializing starting parenthesis\\n\\t\\t\\t \\n         }      \\n     }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3181745,
                "title": "c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n     stack<char> a;\\n     string q;\\n     for(int i=0;i<s.length();i++){\\n         if(s[i]==\\'(\\'){\\n             if(a.size()>0){\\n             q.push_back(s[i]);\\n             }\\n             a.push(s[i]);\\n         }\\n         else{\\n             a.pop();\\n             if(!a.empty())\\n             q.push_back(s[i]);\\n         }\\n     \\n     } \\n     return q;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n     stack<char> a;\\n     string q;\\n     for(int i=0;i<s.length();i++){\\n         if(s[i]==\\'(\\'){\\n             if(a.size()>0){\\n             q.push_back(s[i]);\\n             }\\n             a.push(s[i]);\\n         }\\n         else{\\n             a.pop();\\n             if(!a.empty())\\n             q.push_back(s[i]);\\n         }\\n     \\n     } \\n     return q;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181729,
                "title": "easiest-c-code-using-for-loop-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.size();\\n        int c=0;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n                if(s[i]==\\'(\\'){\\n                    if(c>0){ str+=s[i];}\\n                    c++;\\n                    }\\n                else{\\n                    if(c>1){ str+=s[i];}\\n                    c--;\\n                    }\\n            }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.size();\\n        int c=0;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n                if(s[i]==\\'(\\'){\\n                    if(c>0){ str+=s[i];}\\n                    c++;\\n                    }\\n                else{\\n                    if(c>1){ str+=s[i];}\\n                    c--;\\n                    }\\n            }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181672,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> tem;\\n        string re;\\n        for(int i=0; i<s.length(); i++){\\n           if(s[i]==\\'(\\'){\\n               if(tem.size()>0) re.push_back(s[i]);\\n               tem.push(s[i]);\\n           }\\n           else{\\n               tem.pop();\\n               if(!tem.empty()) re.push_back(s[i]);\\n           }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> tem;\\n        string re;\\n        for(int i=0; i<s.length(); i++){\\n           if(s[i]==\\'(\\'){\\n               if(tem.size()>0) re.push_back(s[i]);\\n               tem.push(s[i]);\\n           }\\n           else{\\n               tem.pop();\\n               if(!tem.empty()) re.push_back(s[i]);\\n           }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140108,
                "title": "java-optimal-approach-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059333,
                "title": "c-no-extra-space",
                "content": "\\n\\n### Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int last = s.size() - 1, balanced = 0;\\n        for(int i = last; i >= 0; i--) {            \\n            if(s[i] == \\')\\') balanced++;\\n            else {\\n                balanced--;\\n                if(balanced == 0) {\\n                    s.erase(last,1);\\n                    s.erase(i, 1);\\n                    last = i - 1;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int last = s.size() - 1, balanced = 0;\\n        for(int i = last; i >= 0; i--) {            \\n            if(s[i] == \\')\\') balanced++;\\n            else {\\n                balanced--;\\n                if(balanced == 0) {\\n                    s.erase(last,1);\\n                    s.erase(i, 1);\\n                    last = i - 1;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862199,
                "title": "golang-efficient-two-pointers-solution-using-strings-builder-o-n-time-o-n-memory",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we only have one type of parentheses and the input sequence is guaranteed to be valid, let\\'s use a counter (called \"balance\" in my code) instead of a stack. As we iterate through the input string and get \\'(\\', then we increment by balance 1 and decrement it by 1 in case we get \\')\\'.\\nWhen the balance becomes equal to zero, we are sure that we got a perfectly valid parentheses string.\\n\\nLet\\'s use two pointers to know where the valid \"atomic\" parentheses sequence starts and ends. Lets call these pointers \"slow\" and \"fast\".\\n\\nFirst we suppose that the input string contains at least two parentheses, so we could place the pointers separately. Then we move the fast pointer and update the balance variable based on the value where the fast pointer is at.\\n\\nWhen the balance becomes equal to 0, we just need to remove the outer brackets. We go through the non-inclusive interval (slow, fast) with a new pointer and add all the parentheses to the answer variable.\\n\\nBecause of immutability of strings, it\\'s inefficient to use the sum operation to concatenate strings in a loop. Instead we use the [strings.Builder](https://pkg.go.dev/strings#Builder) type, which is used to efficiently build strings using several Write methods, as it minimizes memory copying.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe loop through the input string and then loop through the every valid segment we encounter. Basically, it\\'s $O(2n)$ in the worst case.\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe linear memory is used only to construct the answer storing it inside strings.Builder.\\n\\n# Code\\n```\\nimport (\\n    \"strings\"\\n)\\n\\nfunc removeOuterParentheses(s string) string {\\n    if s == \"\" {\\n        return \"\"\\n    }\\n\\n    var sb strings.Builder\\n\\n    slow := 0\\n    balance := 1 // assuming that the first character of the string is always (\\n    for fast := 1; fast < len(s); fast++ {\\n        if s[fast] == \\'(\\' {\\n            balance++\\n        } else if s[fast] == \\')\\' {\\n            balance--\\n        }\\n\\n        if balance == 0 {\\n            for c := slow + 1; c < fast; c++ {\\n                sb.WriteByte(s[c])\\n            }\\n\\n            slow = fast + 1\\n            fast++\\n            balance = 1\\n        }\\n    }\\n\\n    return sb.String()\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nimport (\\n    \"strings\"\\n)\\n\\nfunc removeOuterParentheses(s string) string {\\n    if s == \"\" {\\n        return \"\"\\n    }\\n\\n    var sb strings.Builder\\n\\n    slow := 0\\n    balance := 1 // assuming that the first character of the string is always (\\n    for fast := 1; fast < len(s); fast++ {\\n        if s[fast] == \\'(\\' {\\n            balance++\\n        } else if s[fast] == \\')\\' {\\n            balance--\\n        }\\n\\n        if balance == 0 {\\n            for c := slow + 1; c < fast; c++ {\\n                sb.WriteByte(s[c])\\n            }\\n\\n            slow = fast + 1\\n            fast++\\n            balance = 1\\n        }\\n    }\\n\\n    return sb.String()\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2800575,
                "title": "easy-python3-solution-using-two-pointer-concept",
                "content": "Approach:\\nUsing Two pointers concept we can remove the outer most parentheses by keep tracking the count of opening and closing parentheses.\\n```\\ndef removeOuterParentheses(self, s: str) -> str:\\n\\ti=j=1\\n\\tn = len(s)\\n\\topening_count = 1\\n\\tclosing_count = 0\\n\\tresult = \"\"\\n\\twhile j<n: \\n\\t\\tif  opening_count != closing_count:\\n\\t\\t\\tif s[j] == \"(\":\\n\\t\\t\\t\\topening_count +=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tclosing_count +=1\\n\\t\\t\\tj +=1\\n\\t\\t\\tif j ==n and  opening_count == closing_count :\\n\\t\\t\\t\\tresult += s[i:j-1]\\n\\t\\telse:\\n\\t\\t\\tresult += s[i:j-1]\\n\\t\\t\\tj += 1\\n\\t\\t\\ti = j\\n\\t\\t\\topening_count = 1\\n\\t\\t\\tclosing_count = 0\\n\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "Approach:\\nUsing Two pointers concept we can remove the outer most parentheses by keep tracking the count of opening and closing parentheses.\\n```\\ndef removeOuterParentheses(self, s: str) -> str:\\n\\ti=j=1\\n\\tn = len(s)\\n\\topening_count = 1\\n\\tclosing_count = 0\\n\\tresult = \"\"\\n\\twhile j<n: \\n\\t\\tif  opening_count != closing_count:\\n\\t\\t\\tif s[j] == \"(\":\\n\\t\\t\\t\\topening_count +=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tclosing_count +=1\\n\\t\\t\\tj +=1\\n\\t\\t\\tif j ==n and  opening_count == closing_count :\\n\\t\\t\\t\\tresult += s[i:j-1]\\n\\t\\telse:\\n\\t\\t\\tresult += s[i:j-1]\\n\\t\\t\\tj += 1\\n\\t\\t\\ti = j\\n\\t\\t\\topening_count = 1\\n\\t\\t\\tclosing_count = 0\\n\\treturn result",
                "codeTag": "Python3"
            },
            {
                "id": 2667158,
                "title": "java-without-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int n=s.length();\\n        int a=0;\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                if(a!=0){\\n                    str=str+ch;\\n                }\\n                a++;\\n            }\\n            else{\\n                if(a!=1){\\n                    str=str+ch;\\n                }\\n                a--;\\n            }\\n        }\\n        \\n       return str;\\n      \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        int n=s.length();\\n        int a=0;\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                if(a!=0){\\n                    str=str+ch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2654107,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n       stack<int> st;\\n       string ans = \"\";\\n        int start = 0 ;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s[i] == \\'(\\') st.push(s[i]) , ans.push_back(s[i]);\\n           else if(s[i] == \\')\\') st.pop() , ans.push_back(s[i]);\\n           \\n           if(st.empty())\\n           {\\n               ans.pop_back();\\n               ans.erase(start,1);\\n               start = ans.length();\\n           }\\n       }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n       stack<int> st;\\n       string ans = \"\";\\n        int start = 0 ;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s[i] == \\'(\\') st.push(s[i]) , ans.push_back(s[i]);\\n           else if(s[i] == \\')\\') st.pop() , ans.push_back(s[i]);\\n           \\n           if(st.empty())\\n           {\\n               ans.pop_back();\\n               ans.erase(start,1);\\n               start = ans.length();\\n           }\\n       }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557192,
                "title": "js-with-explanation-easy-to-understand-63ms",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/1021-remove-outermost-parentheses-stack.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(s) {\\n    let result = [];\\n    let stack = new Stack()\\n    for(let i=0;i<s.length;i++){\\n        let char  = s[i];\\n         if (stack.isEmpty()){\\n             if (char==\\'(\\'){\\n                 stack.push(\\'(\\');\\n             }\\n         }else {\\n            if(char == \\')\\' && stack.size() == 1){\\n                stack.pop();\\n            }else{\\n                result.push(char);\\n                if(char == \\'(\\'){\\n                   stack.push(char);\\n                }else{\\n                    stack.pop()\\n                }\\n            }\\n         }\\n    }\\n    return result.join(\"\");\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    toString(){\\n      return this.stack.join(\"\");  \\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```\\n\\n```\\nRuntime: 63 ms, faster than 97.88% of JavaScript online submissions for Remove Outermost Parentheses.\\nMemory Usage: 43.7 MB, less than 68.18% of JavaScript online submissions for Remove Outermost Parentheses.\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(s) {\\n    let result = [];\\n    let stack = new Stack()\\n    for(let i=0;i<s.length;i++){\\n        let char  = s[i];\\n         if (stack.isEmpty()){\\n             if (char==\\'(\\'){\\n                 stack.push(\\'(\\');\\n             }\\n         }else {\\n            if(char == \\')\\' && stack.size() == 1){\\n                stack.pop();\\n            }else{\\n                result.push(char);\\n                if(char == \\'(\\'){\\n                   stack.push(char);\\n                }else{\\n                    stack.pop()\\n                }\\n            }\\n         }\\n    }\\n    return result.join(\"\");\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    toString(){\\n      return this.stack.join(\"\");  \\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```\n```\\nRuntime: 63 ms, faster than 97.88% of JavaScript online submissions for Remove Outermost Parentheses.\\nMemory Usage: 43.7 MB, less than 68.18% of JavaScript online submissions for Remove Outermost Parentheses.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554567,
                "title": "java-o-n-tc",
                "content": "```\\n\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       \\n\\t    StringBuilder sb = new StringBuilder(); \\n        int sum = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {\\n                sum += 1;\\n                if(sum > 1) {\\n                    sb.append(\"(\");\\n                }\\n            } else {\\n                sum -= 1;\\n                if(sum > 0) {\\n                    sb.append(\")\");\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       \\n\\t    StringBuilder sb = new StringBuilder(); \\n        int sum = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {\\n                sum += 1;\\n                if(sum > 1) {\\n                    sb.append(\"(\");\\n                }\\n            } else {\\n                sum -= 1;\\n                if(sum > 0) {\\n                    sb.append(\")\");\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543307,
                "title": "java-stringbuilder-counting-easy-approach",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0;\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                count++;\\n                if(count!=1)\\n                    str.append(s.charAt(i));\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                count--;\\n                if(count!=0)\\n                    str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0;\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                count++;\\n                if(count!=1)\\n                    str.append(s.charAt(i));\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                count--;\\n                if(count!=0)\\n                    str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524647,
                "title": "c-easy-fast",
                "content": "```\\nstring removeOuterParentheses(string s) {\\n        string ans;\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++){\\n            char sb = s[i];\\n            if(sb==\\'(\\'){\\n              if(st.size()>0){\\n                ans.push_back(sb);  \\n              }\\n              st.push(sb);  \\n            }\\n            else{\\n                st.pop();\\n                if(st.size()>0){\\n                   ans.push_back(sb); \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        string ans;\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++){\\n            char sb = s[i];\\n            if(sb==\\'(\\'){\\n              if(st.size()>0){\\n                ans.push_back(sb);  \\n              }\\n              st.push(sb);  \\n            }\\n            else{\\n                st.pop();\\n                if(st.size()>0){\\n                   ans.push_back(sb); \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524511,
                "title": "easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    \\n    def removeOuterParentheses(self, s: str) -> str:\\n    \\n        val = 0 \\n        ans = []\\n        idx = 0 \\n        for i in range(0,len(s)):\\n\\n            if(i == 0):\\n\\n                val += 1 \\n\\n                continue \\n\\n\\n            elif(s[i] == \"(\"):\\n\\n                val += 1 \\n\\n            else: \\n\\n                val -= 1 \\n\\n\\n\\n            if(val == 0 ):\\n\\n                ans.append(s[idx:i+1])\\n\\n\\n                idx = i + 1 \\n\\n        t = \"\"\\n\\n\\n      \\n        for par in ans:\\n\\n            n = len(par)\\n\\n            t += par[1:n-1]\\n\\n\\n        return t \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def removeOuterParentheses(self, s: str) -> str:\\n    \\n        val = 0 \\n        ans = []\\n        idx = 0 \\n        for i in range(0,len(s)):\\n\\n            if(i == 0):\\n\\n                val += 1 \\n\\n                continue \\n\\n\\n            elif(s[i] == \"(\"):\\n\\n                val += 1 \\n\\n            else: \\n\\n                val -= 1 \\n\\n\\n\\n            if(val == 0 ):\\n\\n                ans.append(s[idx:i+1])\\n\\n\\n                idx = i + 1 \\n\\n        t = \"\"\\n\\n\\n      \\n        for par in ans:\\n\\n            n = len(par)\\n\\n            t += par[1:n-1]\\n\\n\\n        return t \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516105,
                "title": "easiest-python-solution-o-n-solution",
                "content": "```\\ndef removeOuterParentheses(self, s: str) -> str:\\n        countOpen = 0\\n        res = \"\"\\n        \\n        for ch in s:\\n            if ch == \\'(\\' :\\n                countOpen += 1\\n                if countOpen > 1 :\\n                    res += ch                \\n            \\n            if ch == \\')\\' :\\n                countOpen -= 1\\n                if countOpen > 0 :\\n                    res += ch\\n                  \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeOuterParentheses(self, s: str) -> str:\\n        countOpen = 0\\n        res = \"\"\\n        \\n        for ch in s:\\n            if ch == \\'(\\' :\\n                countOpen += 1\\n                if countOpen > 1 :\\n                    res += ch                \\n            \\n            if ch == \\')\\' :\\n                countOpen -= 1\\n                if countOpen > 0 :\\n                    res += ch\\n                  \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2514370,
                "title": "self-made-simple-logic-cpp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring removeOuterParentheses(string s) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tstring ns=\"\";\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch=s.at(i);\\n\\t\\t\\t\\tif(ch==\\')\\')\\n\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tif(c>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tns+=ch;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ch==\\'(\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring removeOuterParentheses(string s) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tstring ns=\"\";\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch=s.at(i);\\n\\t\\t\\t\\tif(ch==\\')\\')\\n\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tif(c>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tns+=ch;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2375032,
                "title": "c-simple-o-n-solution-beats-100",
                "content": "The question seems to be difficult but its rather easy to understand.\\nThe main idea here is to understand that the given string is already a valid parenthesis and the main requirement is to just remove the outermost bracket of the simplest valid parenthesis that can be done using the **counting method** what it means is that the number of opening brackets is same as closing bracket for a given sub valid parenthesis string.\\nTake two pointer i and j both at zero and start counting the opening brackets and reducing the count on closing bracket once the count reaches zero that means we have a valid parenthesis and we can now remove the given set of brackets and then update i to j+1 to the next opening bracket if it exits and then also incrementing j so that the above initial step can be repeated.\\n\\nC++ \\n```\\nstring removeOuterParentheses(string s) {\\n        int i=0,j=0,countOfBrackets=0;\\n        while(j<s.length())\\n        {\\n            if(s[j]==\\'(\\')\\n            {\\n                countOfBrackets++;\\n                j++;\\n            }else{\\n                countOfBrackets--;\\n                if(countOfBrackets==0)\\n                {\\n                    s[i]=\\'0\\';\\n                    s[j]=\\'0\\';\\n                    i=j+1;\\n                }\\n                j++;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.at(i)!=\\'0\\')\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        int i=0,j=0,countOfBrackets=0;\\n        while(j<s.length())\\n        {\\n            if(s[j]==\\'(\\')\\n            {\\n                countOfBrackets++;\\n                j++;\\n            }else{\\n                countOfBrackets--;\\n                if(countOfBrackets==0)\\n                {\\n                    s[i]=\\'0\\';\\n                    s[j]=\\'0\\';\\n                    i=j+1;\\n                }\\n                j++;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.at(i)!=\\'0\\')\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366578,
                "title": "python-o-1-space-easy-explanation",
                "content": "Success\\nDetails \\nRuntime: 55 ms, faster than **61.98%** of Python3 online submissions.\\nMemory Usage: 13.9 MB, less than **92.46%** of Python3 online submissions.\\n\\n1. Create an empty result string. res=\\'\\'\\n\\n2. I have take temp variable C which is intially zero.\\n3. Itterate over the string.\\n4. When we find \\'(\\' increament C and when we find \\')\\' decrement C.\\n5. So whenever C becmoes 0, we will be outside the paranthessis.\\n6. So, while iterating the string, when the current element is \\'(\\' append \\'(\\' to out result except when c==0 and while current element is \\')\\' append \\')\\' to our result except when c==1. (because after this we will decrement C to zero )\\n\\n***If this helps, Please leave an upvote!!!***\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c=0\\n        res=\\'\\'\\n        for i in s:\\n            if i==\\')\\' and c==1:\\n                c=c-1\\n            elif i==\\'(\\' and c==0:\\n                c=c+1\\n            elif i==\\'(\\':\\n                res=res+\\'(\\'\\n                c=c+1\\n            elif i==\\')\\':\\n                res=res+\\')\\'\\n                c=c-1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c=0\\n        res=\\'\\'\\n        for i in s:\\n            if i==\\')\\' and c==1:\\n                c=c-1\\n            elif i==\\'(\\' and c==0:\\n                c=c+1\\n            elif i==\\'(\\':\\n                res=res+\\'(\\'\\n                c=c+1\\n            elif i==\\')\\':\\n                res=res+\\')\\'\\n                c=c-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334680,
                "title": "solution-in-c-using-stack-and-without-stack",
                "content": "```\\n// using stack :- Time: O(n) ,  space: O(n)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        stack<char> st;\\n        for(char c: s){\\n            if(c == \\'(\\'){\\n                if(!st.empty()){\\n                    str += \\'(\\';\\n                }\\n                st.push(c);\\n            }\\n            else {\\n                st.pop();\\n                if(!st.empty()){\\n                    str += \")\";\\n                }\\n            }\\n            \\n        }\\n        return str;\\n    }\\n};\\n\\n//without stack Time: O(n),  space: O(1)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string str;\\n        for(char c : s){\\n            if (c == \\'(\\' && count++) str += \\'(\\';\\n            else if ( c == \\')\\' && --count) str+= \\')\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n// using stack :- Time: O(n) ,  space: O(n)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        stack<char> st;\\n        for(char c: s){\\n            if(c == \\'(\\'){\\n                if(!st.empty()){\\n                    str += \\'(\\';\\n                }\\n                st.push(c);\\n            }\\n            else {\\n                st.pop();\\n                if(!st.empty()){\\n                    str += \")\";\\n                }\\n            }\\n            \\n        }\\n        return str;\\n    }\\n};\\n\\n//without stack Time: O(n),  space: O(1)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string str;\\n        for(char c : s){\\n            if (c == \\'(\\' && count++) str += \\'(\\';\\n            else if ( c == \\')\\' && --count) str+= \\')\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269720,
                "title": "simple-java-solution-o-n",
                "content": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        int count=0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            \\n            char c=s.charAt(i);\\n            int prev=count;\\n            if(c==\\'(\\') count++;\\n            else count--;\\n            \\n            if(prev==0 && count==1) continue; // if it is a starting \\'(\\' of outer most parentheses then continue\\n            else if(prev==1 && count==0) continue; // if it is a ending \\')\\' of the outer most parentheses then continue\\n            \\n            res.append(c); // else append it to result\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        int count=0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            \\n            char c=s.charAt(i);\\n            int prev=count;\\n            if(c==\\'(\\') count++;\\n            else count--;\\n            \\n            if(prev==0 && count==1) continue; // if it is a starting \\'(\\' of outer most parentheses then continue\\n            else if(prev==1 && count==0) continue; // if it is a ending \\')\\' of the outer most parentheses then continue\\n            \\n            res.append(c); // else append it to result\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2040897,
                "title": "java-solution-using-stack",
                "content": "# java Solution\\n```\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder stb=new StringBuilder();\\n        Stack<Character> stack= new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(stack.size()>=1){\\n                    stb.append(\\'(\\');\\n                }\\n                stack.push(\\'(\\');\\n            }else{\\n                if(stack.size()>1){\\n                    stb.append(\\')\\');\\n                }\\n                stack.pop();\\n            }\\n           \\n        }\\n        return stb.toString();\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "String",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder stb=new StringBuilder();\\n        Stack<Character> stack= new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(stack.size()>=1){\\n                    stb.append(\\'(\\');\\n                }\\n                stack.push(\\'(\\');\\n            }else{\\n                if(stack.size()>1){\\n                    stb.append(\\')\\');\\n                }\\n                stack.pop();\\n            }\\n           \\n        }\\n        return stb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008555,
                "title": "simple-and-small-c-stack",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char> st;\\n        string ans = \"\", cur = \"\";\\n        for (auto it : s)\\n        {\\n            if (st.empty())\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\' && st.size() == 1)\\n            {\\n                st.pop();\\n                ans += cur.substr(1);\\n                cur = \"\";\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\')\\n            {\\n                st.pop();\\n                cur += it;\\n            }\\n            else\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char> st;\\n        string ans = \"\", cur = \"\";\\n        for (auto it : s)\\n        {\\n            if (st.empty())\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\' && st.size() == 1)\\n            {\\n                st.pop();\\n                ans += cur.substr(1);\\n                cur = \"\";\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\')\\n            {\\n                st.pop();\\n                cur += it;\\n            }\\n            else\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981458,
                "title": "c-without-stack-and-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int sum = 0, lastIndex=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'(\\') {\\n                sum++;\\n            } else if(s[i] == \\')\\') {\\n                sum--;\\n            }\\n            if(sum == 0) {\\n                ans +=  s.substr(lastIndex+1, i-lastIndex-1);\\n                lastIndex = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int sum = 0, lastIndex=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'(\\') {\\n                sum++;\\n            } else if(s[i] == \\')\\') {\\n                sum--;\\n            }\\n            if(sum == 0) {\\n                ans +=  s.substr(lastIndex+1, i-lastIndex-1);\\n                lastIndex = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935363,
                "title": "java-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int f=0,l=0;\\n        StringBuilder res = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n            if(stack.empty()){\\n                res.append(s.substring(f+1,i));\\n                f = i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int f=0,l=0;\\n        StringBuilder res = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n            if(stack.empty()){\\n                res.append(s.substring(f+1,i));\\n                f = i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794873,
                "title": "easy-java-solution-without-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int counter = 0;   \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\'){\\n                if (counter++ > 0)\\n                    sb.append(c);\\n            } else {\\n                if (--counter > 0) \\n                    sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int counter = 0;   \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\'){\\n                if (counter++ > 0)\\n                    sb.append(c);\\n            } else {\\n                if (--counter > 0) \\n                    sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749419,
                "title": "c-0ms-100-0",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\", temp=\"\";\\n        int n=s.size();\\n        int open=0, clos=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            temp+=s[i];\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                clos++;\\n            if(open==clos)\\n            {\\n                res+=temp.substr(1, temp.size()-2);\\n                temp=\"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\", temp=\"\";\\n        int n=s.size();\\n        int open=0, clos=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            temp+=s[i];\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                clos++;\\n            if(open==clos)\\n            {\\n                res+=temp.substr(1, temp.size()-2);\\n                temp=\"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734763,
                "title": "java-both-with-without-extra-space-fast-100",
                "content": "**Approach 1 : With using extra space** \\nWith using Stack, we are appending in resultant string if at any point our stack becomes empty :\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Integer> stk = new Stack<>() ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                stk.push(i);\\n            }\\n            else{\\n                int j = stk.pop() ;\\n                if(stk.isEmpty()){\\n                    res.append(s.substring(j+1,i));\\n                }\\n            }    \\n        }\\n        return res.toString() ;\\n    }\\n}\\n```\\n\\n**Approach 2 : Without using extra space**\\nIf we encounter an open bracket we will just increase the open count similarly for closeing bracket we are dereasing the count.\\nIf at any point `open` becomes 0 that means we need  substring from start of` open` = 0 to end `open` = 0 .\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int open = 0 ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                open++;\\n                if(open > 1) res.append(ch);\\n            }\\n            else{\\n                 open-- ;\\n                if(open > 0) res.append(ch);\\n            }\\n        }\\n        return res.toString() ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Integer> stk = new Stack<>() ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                stk.push(i);\\n            }\\n            else{\\n                int j = stk.pop() ;\\n                if(stk.isEmpty()){\\n                    res.append(s.substring(j+1,i));\\n                }\\n            }    \\n        }\\n        return res.toString() ;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int open = 0 ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                open++;\\n                if(open > 1) res.append(ch);\\n            }\\n            else{\\n                 open-- ;\\n                if(open > 0) res.append(ch);\\n            }\\n        }\\n        return res.toString() ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732284,
                "title": "100-faster-java-solution-without-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int op=0;\\n        int cl=0;\\n        int si=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                op++;\\n            }else{\\n                cl++;\\n            }\\n            if(op==cl){\\n                for(int j=si+1;j<i;j++){\\n                    sb.append(s.charAt(j));\\n                }\\n                op=0;\\n                cl=0;\\n                si=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int op=0;\\n        int cl=0;\\n        int si=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                op++;\\n            }else{\\n                cl++;\\n            }\\n            if(op==cl){\\n                for(int j=si+1;j<i;j++){\\n                    sb.append(s.charAt(j));\\n                }\\n                op=0;\\n                cl=0;\\n                si=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730020,
                "title": "c-solution",
                "content": "string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                str.pop();\\n            if(str.size()!=0)\\n                ans=ans+s[i];\\n            if(s[i]==\\'(\\')\\n                str.push(s[i]);\\n        }\\n        return ans;\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                str.pop();\\n            if(str.size()!=0)\\n                ans=ans+s[i];\\n            if(s[i]==\\'(\\')\\n                str.push(s[i]);\\n        }\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1691784,
                "title": "the-best-possible-solution-without-using-stack-that-run-in-0ms",
                "content": "class Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        \\n        string str = \"\";\\n        int i = 0;\\n        \\n        for(int j=1; j<s.size(); j++)\\n        {\\n            char ch = s[j];\\n            if(ch == \\'(\\')\\n                i++;\\n            if(i>0)\\n                str += ch;\\n            if(ch == \\')\\')\\n                i--;\\n        }\\n        \\n        \\n        \\n        return str;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        \\n        string str = \"\";\\n        int i = 0;\\n        \\n        for(int j=1; j<s.size(); j++)\\n        {\\n            char ch = s[j];\\n            if(ch == \\'(\\')\\n                i++;\\n            if(i>0)\\n                str += ch;\\n            if(ch == \\')\\')\\n                i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1686263,
                "title": "java-using-stack-and-without-using-stack",
                "content": "**USING STACK O(N)** \\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())  //convert string into character array\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)  //check if stack is empty or not i.e its first opening bracket or not\\n                 {\\n                     sb.append(ch);  // adds to sb if opening bracket but not first\\n                 }\\n                st.push(ch);  //push element into stack\\n            }\\n            else{\\n                if(st.size()>1)  // if stack is empty doesn\\'t append \\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop(); //pop out of stack\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**WITHOUT USING STACK O(N)**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String str) {\\n          StringBuilder sb= new StringBuilder();\\n        \\n        int opened= 0;\\n        for( char c:str.toCharArray()){\\n            \\n            if(c==\\'(\\'){\\n                if(opened>0) sb.append(c);\\n                opened++;\\n            }else{\\n                if(opened>1)sb.append(c);\\n                opened--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n**Hope you  like it**\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())  //convert string into character array\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)  //check if stack is empty or not i.e its first opening bracket or not\\n                 {\\n                     sb.append(ch);  // adds to sb if opening bracket but not first\\n                 }\\n                st.push(ch);  //push element into stack\\n            }\\n            else{\\n                if(st.size()>1)  // if stack is empty doesn\\'t append \\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop(); //pop out of stack\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String str) {\\n          StringBuilder sb= new StringBuilder();\\n        \\n        int opened= 0;\\n        for( char c:str.toCharArray()){\\n            \\n            if(c==\\'(\\'){\\n                if(opened>0) sb.append(c);\\n                opened++;\\n            }else{\\n                if(opened>1)sb.append(c);\\n                opened--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677664,
                "title": "easiest-solution-using-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<int> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                st.pop();\\n            if(st.size()!=0)\\n                ans+=s[i];\\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<int> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                st.pop();\\n            if(st.size()!=0)\\n                ans+=s[i];\\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611056,
                "title": "without-stack-solution-o-n-single-pass",
                "content": "````    public String removeOuterParentheses(String s) {\\n        int sb = 0;\\n        int eb = 0;int sp = 0;\\n        StringBuilder str1 = new StringBuilder(\"\");\\n        for(int i = 0;i < s.length() ;i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                sb++;\\n            }else{\\n                eb++;\\n            }\\n            if(sb == eb ){\\n                str1.append(s.substring(sp+1,i));\\n                sb = 0;eb = 0;sp = i+1;\\n            }\\n        }\\n\\n        return str1.toString();\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "````    public String removeOuterParentheses(String s) {\\n        int sb = 0;\\n        int eb = 0;int sp = 0;\\n        StringBuilder str1 = new StringBuilder(\"\");\\n        for(int i = 0;i < s.length() ;i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                sb++;\\n            }else{\\n                eb++;\\n            }\\n            if(sb == eb ){\\n                str1.append(s.substring(sp+1,i));\\n                sb = 0;eb = 0;sp = i+1;\\n            }\\n        }\\n\\n        return str1.toString();\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1506586,
                "title": "clean-solution-using-stack-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int countLeft = 0, countRight = 0;\\n        string ans = \"\";\\n        stack<char> st;\\n        \\n        for(int i =0;i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                countLeft++;\\n                if(countLeft > 1){\\n                    st.push(s[i]);\\n                }\\n            }else if(countLeft == countRight+1){\\n                countLeft = 0;\\n                countRight = 0;\\n                continue;\\n            }else if(s[i] == \\')\\'){\\n                st.push(s[i]);\\n                countRight++;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int countLeft = 0, countRight = 0;\\n        string ans = \"\";\\n        stack<char> st;\\n        \\n        for(int i =0;i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                countLeft++;\\n                if(countLeft > 1){\\n                    st.push(s[i]);\\n                }\\n            }else if(countLeft == countRight+1){\\n                countLeft = 0;\\n                countRight = 0;\\n                continue;\\n            }else if(s[i] == \\')\\'){\\n                st.push(s[i]);\\n                countRight++;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469321,
                "title": "java-easy-solution-using-stack-o-n",
                "content": "Simply use a stack follow if-else laddar conditions:-\\n\\n```class Solution {``\\n    public String removeOuterParentheses(String s) {\\n        String str=\"\";\\n    Stack<Character> st=new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        char ch=s.charAt(i);\\n        if(ch==\\'(\\'){\\n            st.push(ch);\\n            if(st.size()>1){\\n                str+=ch;\\n            }\\n        }\\n        else if(ch==\\')\\'){\\n            if( st.size()>1 && st.peek()==\\'(\\'){\\n                str+=ch;\\n                st.pop();\\n            }\\n            else if(st.size()==1 && st.peek()==\\'(\\' ){\\n                st.pop();\\n            }\\n        }\\n        \\n    }\\n    return str;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {``\\n    public String removeOuterParentheses(String s) {\\n        String str=\"\";\\n    Stack<Character> st=new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        char ch=s.charAt(i);\\n        if(ch==\\'(\\'){\\n            st.push(ch);\\n            if(st.size()>1){\\n                str+=ch;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433045,
                "title": "simple-solution-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        stack<char>s;\\n        string ans=\"\";\\n        \\n        for(auto x:str){\\n            \\n            if(x==\\'(\\'){\\n                \\n                if(!s.empty())  ans+=\\'(\\';\\n                 \\n                s.push(\\'(\\');\\n            \\n            } \\n            \\n            else{\\n                \\n                s.pop();\\n                \\n                if(!s.empty()) ans+=\\')\\';\\n                          \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        stack<char>s;\\n        string ans=\"\";\\n        \\n        for(auto x:str){\\n            \\n            if(x==\\'(\\'){\\n                \\n                if(!s.empty())  ans+=\\'(\\';\\n                 \\n                s.push(\\'(\\');\\n            \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1414500,
                "title": "java-using-stack-5ms",
                "content": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st=new Stack<>();\\n        StringBuilder sb= new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\')\\n            {\\n                if(st.size()>0)//to check if the stack is empty or not\\n                {\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n                st.pop();\\n                if(st.size()>0)\\n                {\\n                    sb.append(ch);\\n                }\\n                    \\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st=new Stack<>();\\n        StringBuilder sb= new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\')\\n            {\\n                if(st.size()>0)//to check if the stack is empty or not\\n                {\\n                    sb.append(ch);\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1749987,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1944035,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1568298,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 2019757,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1752088,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1717947,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1935039,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1907179,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1846855,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1574537,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1749987,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1944035,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1568298,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 2019757,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1752088,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1717947,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1935039,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1907179,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1846855,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1574537,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1801906,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2074725,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2059542,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2037140,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2036139,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2034017,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2030162,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2029746,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2004957,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 1963340,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            }
        ]
    }
]