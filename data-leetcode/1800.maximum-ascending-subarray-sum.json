[
    {
        "title": "Largest Perimeter Triangle",
        "question_content": "Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,2]\nOutput: 5\nExplanation: You can form a triangle with three side lengths: 1, 2, and 2.\n\nExample 2:\n\nInput: nums = [1,2,1,10]\nOutput: 0\nExplanation: \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 104\n\t1 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 217988,
                "title": "java-c-python-sort-and-try-biggest",
                "content": "For `a >= b >= c`, `a,b,c` can form a triangle if `a < b + c`.\\n\\n1. We sort the `A`\\n2. Try to get a triangle with 3 biggest numbers.\\n3. If `A[n-1] < A[n-2] + A[n-3]`, we get a triangle.\\n   If `A[n-1] >= A[n-2] + A[n-3] >= A[i] + A[j]`, we cannot get any triangle with `A[n-1]`\\n4. repeat step2 and step3 with the left numbers.\\n\\n\\n**Java:**\\n```\\n    public int largestPerimeter(int[] A) {\\n        Arrays.sort(A);\\n        for (int i = A.length - 1; i > 1; --i)\\n            if (A[i] < A[i - 1] + A[i - 2])\\n                return A[i] + A[i - 1] + A[i - 2];\\n        return 0;\\n    }\\n```\\n\\n**C++:**\\n```\\n    int largestPerimeter(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        for (int i = A.size() - 1 ; i > 1; --i)\\n            if (A[i] < A[i - 1] + A[i - 2])\\n                return A[i] + A[i - 1] + A[i - 2];\\n        return 0;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def largestPerimeter(self, A):\\n        A = sorted(A)[::-1]\\n        for i in range(len(A) - 2):\\n            if A[i] < A[i + 1] + A[i + 2]:\\n                return A[i] + A[i + 1] + A[i + 2]\\n        return 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int largestPerimeter(int[] A) {\\n        Arrays.sort(A);\\n        for (int i = A.length - 1; i > 1; --i)\\n            if (A[i] < A[i - 1] + A[i - 2])\\n                return A[i] + A[i - 1] + A[i - 2];\\n        return 0;\\n    }\\n```\n```\\n    int largestPerimeter(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        for (int i = A.size() - 1 ; i > 1; --i)\\n            if (A[i] < A[i - 1] + A[i - 2])\\n                return A[i] + A[i - 1] + A[i - 2];\\n        return 0;\\n    }\\n```\n```\\n    def largestPerimeter(self, A):\\n        A = sorted(A)[::-1]\\n        for i in range(len(A) - 2):\\n            if A[i] < A[i + 1] + A[i + 2]:\\n                return A[i] + A[i + 1] + A[i + 2]\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2692643,
                "title": "java-o-nlogn-easy-to-understand-simple-solution",
                "content": "IF YOU LIKE THE SOLUTION \\nDON\\'T FORGET TO UPVOTE IT.\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        //Sort the array first.\\n        Arrays.sort(nums);\\n        \\n        //Start traversing from back , so that we can get the largest value.\\n        for(int i = nums.length-1; i>1; i--){\\n            //Using triangle property to become valid sides\\n            // The sum of the length of the two sides of a triangle is greater than the length of the third side. \\n           if(nums[i] < nums[i-1] + nums[i-2])\\n               return  nums[i] + nums[i-1]+ nums[i-2];   \\n        }\\n        \\n        //If we didn\\'t found anything we return 0.\\n        return 0;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        //Sort the array first.\\n        Arrays.sort(nums);\\n        \\n        //Start traversing from back , so that we can get the largest value.\\n        for(int i = nums.length-1; i>1; i--){\\n            //Using triangle property to become valid sides\\n            // The sum of the length of the two sides of a triangle is greater than the length of the third side. \\n           if(nums[i] < nums[i-1] + nums[i-2])\\n               return  nums[i] + nums[i-1]+ nums[i-2];   \\n        }\\n        \\n        //If we didn\\'t found anything we return 0.\\n        return 0;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217972,
                "title": "c-4-lines-o-n-log-n",
                "content": "The goal is to find the largest number n1, where two other numbers, n2 and n3, exist, and  ```n1 > n2 && n1 > n3```, and ```n1 < n2 + n3```.\\nIf we sort our sizes, we just need to find the largest A[i] such as ```A[i] < A[i - 1] + A[i - 2]```. So, we analyze triplets largest to smallest, and return the perimeter for the first triplet that matches our criterion.\\n```\\nint largestPerimeter(vector<int>& A) {\\n  sort(begin(A), end(A));\\n  for (auto i = A.size() - 1; i >= 2; --i)\\n    if (A[i] < A[i - 1] + A[i - 2]) \\n        return A[i] + A[i - 1] + A[i - 2];\\n  return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```n1 > n2 && n1 > n3```\n```n1 < n2 + n3```\n```A[i] < A[i - 1] + A[i - 2]```\n```\\nint largestPerimeter(vector<int>& A) {\\n  sort(begin(A), end(A));\\n  for (auto i = A.size() - 1; i >= 2; --i)\\n    if (A[i] < A[i - 1] + A[i - 2]) \\n        return A[i] + A[i - 1] + A[i - 2];\\n  return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 230431,
                "title": "python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort(reverse=True)\\n        for i, x in enumerate(A[:-2]):\\n            # Sum of any two sides should be greater than the third side.\\n            # Consider sides: A[i], A[i+1] and A[i+2] \\n            # A[i] >= A[i+1] >= A[i+2] since the list is sorted\\n            # A[i] >= A[i+1] so A[i] + A[i+2] > A[i+1] and also A[i] >= A[i+2] so A[i] + A[i+1] > A[i+2] hence\\n            # the only condition we need to check is that A[i] < A[i+1] + A[i+2] \\n            if x < A[i+1] + A[i+2]:\\n                return x + A[i+1] + A[i+2]\\n\\n            # Another thing to note here is that: we have reached this point that means, A[i] > A[i+1] + A[i+2]\\n            # So there is no way that A[i] < A[i+1] and A[j] where j > i+2 so we need not consider all permutations\\n            # of A[i], A[i+1], A[i+3] or A[i], A[i+1], A[i+4] and so on.\\n\\n            # Hence the next case to be considered would be A[i+1], A[i+2] and A[i+3]\\n            # hence just incrementing i would do the job\\n            \\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort(reverse=True)\\n        for i, x in enumerate(A[:-2]):\\n            # Sum of any two sides should be greater than the third side.\\n            # Consider sides: A[i], A[i+1] and A[i+2] \\n            # A[i] >= A[i+1] >= A[i+2] since the list is sorted\\n            # A[i] >= A[i+1] so A[i] + A[i+2] > A[i+1] and also A[i] >= A[i+2] so A[i] + A[i+1] > A[i+2] hence\\n            # the only condition we need to check is that A[i] < A[i+1] + A[i+2] \\n            if x < A[i+1] + A[i+2]:\\n                return x + A[i+1] + A[i+2]\\n\\n            # Another thing to note here is that: we have reached this point that means, A[i] > A[i+1] + A[i+2]\\n            # So there is no way that A[i] < A[i+1] and A[j] where j > i+2 so we need not consider all permutations\\n            # of A[i], A[i+1], A[i+3] or A[i], A[i+1], A[i+4] and so on.\\n\\n            # Hence the next case to be considered would be A[i+1], A[i+2] and A[i+3]\\n            # hence just incrementing i would do the job\\n            \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693008,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n----------------------------------------------------------------------------\\n\\n**APPROACH** - Sort the array and when a+b>c, return the perimeter (a+b+c) \\n\\n-------------------------------------------------------------------------\\n\\n\\tint largestPerimeter(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());                 //sort the array\\n        \\n        for(int i=nums.size()-3; i>=0; i--){            //traverse from n-3 to 0\\n            if(nums[i]+nums[i+1] > nums[i+2]) {         //if at any instant a + b > c, return perimenter (a+b+c)\\n                return  nums[i]+nums[i+1]+nums[i+2];    // a=nums[i], b=nums[i+1], c=nums[i+2];\\n            }\\n        }\\n        return 0;                                       //else return 0\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n----------------------------------------------------------------------------\\n\\n**APPROACH** - Sort the array and when a+b>c, return the perimeter (a+b+c) \\n\\n-------------------------------------------------------------------------\\n\\n\\tint largestPerimeter(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());                 //sort the array\\n        \\n        for(int i=nums.size()-3; i>=0; i--){            //traverse from n-3 to 0\\n            if(nums[i]+nums[i+1] > nums[i+2]) {         //if at any instant a + b > c, return perimenter (a+b+c)\\n                return  nums[i]+nums[i+1]+nums[i+2];    // a=nums[i], b=nums[i+1], c=nums[i+2];\\n            }\\n        }\\n        return 0;                                       //else return 0\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2692462,
                "title": "python-3-4-lines-geometry-w-explanation-t-m-100-61",
                "content": "Three line segments comprise a triangle if and only if the greatest length of the three sides is less than the sum of lengths of the other two sides. (A few sketches or playing with three sticks should convince you of this fact.)\\n\\nHere\\'s the Plan:\\n- Sort nums in non-increasing order.\\n- Iterate though the list and pop off the first element until nums[0] < nums[1]+nums[2]. The sum of these three nums is the solution.\\n - If no such three numbers exist, then return 0\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: list[int]) -> int:\\n        \\n        nums.sort(reverse = True)\\n        \\n        while len(nums) > 2 and nums[0] >= nums[1] + nums[2]:\\n            nums.pop(0)\\n            \\n        return 0 if len(nums) < 3 else sum(nums[:3])\\n```\\n[https://leetcode.com/submissions/detail/587973432/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: list[int]) -> int:\\n        \\n        nums.sort(reverse = True)\\n        \\n        while len(nums) > 2 and nums[0] >= nums[1] + nums[2]:\\n            nums.pop(0)\\n            \\n        return 0 if len(nums) < 3 else sum(nums[:3])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915905,
                "title": "python-3-98-better-explained-with-simple-logic",
                "content": "***Logic:***\\n1. Sort the List to get the top 3 lengths\\n2. Check if the largest length is less than sum of other two\\n\\t3. If 2 is false, drop the max length take next 3 largest length and repeat 1-2\\n\\t4. if 2 is true, return sum of all lengths\\n5. if loop ends, and no possible combination found, return 0\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        A.sort(reverse = True)\\n        for i in range(3,len(A)+1):\\n            if(A[i-3] < A[i-2] + A[i-1]):\\n                return sum(A[i-3:i])\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        A.sort(reverse = True)\\n        for i in range(3,len(A)+1):\\n            if(A[i-3] < A[i-2] + A[i-1]):\\n                return sum(A[i-3:i])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987107,
                "title": "c-4-lines-sort-easy-understandable-single-pass",
                "content": "As, we know that the basic condition to make a triangle is (a+b>c).\\nNow, we sort the given array in the \"non-decreasing\" order to get the maximum values at right hand side only.\\nWe choose most three greatest side and checks whether it can form a triangle or not, If the sides forms a triangle we return the sum of those three sides.\\nMY CODE WITH **O(NlogN)** TIME COMPLEXITY IS GIVEN BELOW:\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423042,
                "title": "java-easy-solution-faster-than-99-57",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n     Arrays.sort(nums);\\n      for(int i = nums.length - 1; i > 1; i --) \\n        if(nums[i] < nums[i - 1] + nums[i - 2]) \\n          return nums[i] + nums[i - 1] + nums[i - 2];\\n      \\n      return 0;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n     Arrays.sort(nums);\\n      for(int i = nums.length - 1; i > 1; i --) \\n        if(nums[i] < nums[i - 1] + nums[i - 2]) \\n          return nums[i] + nums[i - 1] + nums[i - 2];\\n      \\n      return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218346,
                "title": "python-2-liner-comprehend-my-list-comprehension",
                "content": "**Hi fellas,\\nMy laptop is broken and i can\\'t participate Leetcode. I am writing this on my ipad and it\\'s been more than 20 mins for two line code to write correctly, such a pain in the ass LC mobile not responsive. Happy coding!**\\n```\\nclass Solution:\\n def largestPerimeter(self, A):\\n  A.sort()\\n  return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n def largestPerimeter(self, A):\\n  A.sort()\\n  return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693512,
                "title": "triangle-basic-property",
                "content": "The solution is based on one of the basic properties of a triangle:\\n*The sum of the length of any two sides of a triangle is greater than the length of the third side.*\\n\\n##### Java\\n```java\\npublic int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 3; i >= 0; --i) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) \\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n```\\n\\n##### C++\\n```c++\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = nums.size() - 3; i >= 0; --i) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) \\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n```\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 3; i >= 0; --i) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) \\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n```\n```c++\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = nums.size() - 3; i >= 0; --i) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) \\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692877,
                "title": "python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'ve to find the largest perimeter of triangle & that\\'s why we need to first sort the list and loop from behind.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we\\'ll sort the program & take j as size of nums minus 3 and we\\'ll decrease the value after each loop and similarly take i as the last element and decrease the value after each loop.\\n\\nTill the j is greater than 0, go in the nums list. If nums[j]+nums[j+1]>nums[i] then return the sum of all these otherwise go on in the loop and will return 0 if no such condition found.\\n\\n==========================================================\\n\\nLet\\'s understand this with an example :-\\n\\nnums = [3,6,2,3]\\n\\nSo, we\\'ll first sort the array and it will now look like \\nnums = [2,3,3,6]\\n\\nNow, we\\'ll take i as the last element of the list and j as the (length of list-3) index.\\n\\n \\n![image.png](https://assets.leetcode.com/users/images/344f6d8f-6347-4a5f-acde-7219b2a4a83e_1665580667.2809658.png)\\n\\nSo j will point to 3 and i will point to 6.\\n\\nNow, we\\'ll check the first condition if nums[j]+nums[j+1]>nums[i] i.e., if 3+3>6, so that is false so we\\'ll decrement both the value of i and j by 1.\\n\\nNow, i will start pointing to 3 and j will point to 2.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/3029c91b-08bc-425b-9d17-74069a901eca_1665580695.550933.png)\\n\\nNow, we\\'ll check the condition if nums[j]+nums[j+1]>nums[i] i.e., if 2+3>3, so that is true as 5>3 so we\\'ll return the sum of all these like 2+3+3 i.e., we\\'ll return 8.\\n\\nAnd this is how we\\'ll look in the list for every element.\\n\\n**Corner Case :-**\\n\\nAnd suppose if this also won\\'t work like if suppose the list is like 1 2 3 6 and for every case this condition is false, like 2+3>6 is false and similarly 1+2>3 is also false so in that case we\\'ll return 0.\\n\\n==========================================================\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!--Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        \\n        i = n-1\\n        j = n-3\\n\\n        while(j>=0):\\n            if(nums[j]+nums[j+1]>nums[i]):\\n                return nums[j]+nums[j+1]+nums[i]\\n            i=i-1\\n            j=j-1\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        \\n        i = n-1\\n        j = n-3\\n\\n        while(j>=0):\\n            if(nums[j]+nums[j+1]>nums[i]):\\n                return nums[j]+nums[j+1]+nums[i]\\n            i=i-1\\n            j=j-1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836412,
                "title": "c-clean-easy-sorting",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint largestPerimeter(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tfor(int i=nums.size()-3;i>=0;i--){\\n\\t\\t\\t\\tif(nums[i]+nums[i+1]>nums[i+2])\\n\\t\\t\\t\\t\\treturn nums[i]+nums[i+1]+nums[i+2];\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint largestPerimeter(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tfor(int i=nums.size()-3;i>=0;i--){\\n\\t\\t\\t\\tif(nums[i]+nums[i+1]>nums[i+2])\\n\\t\\t\\t\\t\\treturn nums[i]+nums[i+1]+nums[i+2];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2488729,
                "title": "python-easy-solution",
                "content": "```\\ndef largestPerimeter(self, nums: List[int]) -> int: # nums = [3,6,2,3]\\n        # condition to create a triangle a < (b + c). where  a >= b >= c\\n        nums = sorted(nums, reverse=True) # nums after sorting = [6, 3, 3, 2]\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] +nums[i+2]: # When i =1 => 3 < 3+2 (True)\\n                return nums[i]+nums[i+1] +nums[i+2] # 3 + 3 + 2 = 8\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef largestPerimeter(self, nums: List[int]) -> int: # nums = [3,6,2,3]\\n        # condition to create a triangle a < (b + c). where  a >= b >= c\\n        nums = sorted(nums, reverse=True) # nums after sorting = [6, 3, 3, 2]\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] +nums[i+2]: # When i =1 => 3 < 3+2 (True)\\n                return nums[i]+nums[i+1] +nums[i+2] # 3 + 3 + 2 = 8\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 550885,
                "title": "python-java-js-go-c-o-n-log-n-by-sorting-w-visualization",
                "content": "O( n log n ) by sorting. \\n\\n---\\n**Hint**:\\n\\n**Sort** input side length in descending order.\\n\\n**Try and test** the side length combination of triangle **from the largest one**.\\n\\nIf we find the optimal one, then early return the sum of valid largest side length combination.\\nOtherwise, return 0 (i.e., impossible to make triangle)\\n\\n---\\n\\n**Recall**:\\n\\nBasic property of triangle:\\n\\n**[Triangle inequality](https://en.wikipedia.org/wiki/Triangle_inequality)**\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585128080.png)\\n\\n\\nZ < X + Y where X, Y, Z are valid side length of triangle.\\n\\n---\\nImplementation:\\n```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        \\n\\t\\t# sort side length in descending order\\n        A.sort( reverse = True )\\n        \\n\\t\\t# Try and test from largest side length\\n        for i in range( len(A) - 2):\\n            \\n            if A[i] < A[i+1] + A[i+2]:\\n                # Early return when we find largest perimeter triangle\\n                return A[i] + A[i+1] + A[i+2]\\n        \\n        # Reject: impossible to make triangle\\n        return 0\\n        \\n```\\n\\n---\\n\\nJava:\\n\\n```\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        \\n        // Java native int[] sort doesn\\'t support reverse option\\n        Arrays.sort( nums );\\n\\n        for( int i = nums.length-3 ; i >= 0 ; i--){\\n            \\n            if( nums[i+2] < ( nums[i+1] + nums[i] ) ){\\n                // Accept: find the triangle with largest perimeter\\n                return ( nums[i] + nums[i+1] + nums[i+2] );\\n            }\\n            \\n        }\\n        \\n        // Reject: impossible to make triangle\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar compareFn = function(a, b){\\n    // put larger element of the left hand side\\n    return b - a;    \\n}\\n\\nvar largestPerimeter = function(nums) {\\n    \\n    nums.sort( compareFn );\\n    \\n    for( let i = 0 ; i < nums.length-2 ; i++){\\n        \\n        if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n            \\n            // Accept: find the triangle with largest perimeter\\n            return ( nums[i] +  nums[i+1] + nums[i+2] )\\n        }\\n        \\n    }\\n    \\n    // Reject: impossible to make triangle\\n    return 0;\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport(\\n    \"sort\"\\n)\\n\\nfunc largestPerimeter(nums []int) int {\\n    \\n    // sort side length in descending order\\n    sort.Slice( nums, func( i, j int) bool{\\n        return nums[i] > nums[j]\\n    })\\n    \\n    \\n    for i := 0 ; i < len(nums)-2 ; i++ {\\n\\n        // Accept: find the triangle with largest perimeter\\n        if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n            return nums[i] + nums[i+1] + nums[i+2]\\n        }\\n\\n    }\\n    \\n    // Reject: impossible to make triangle\\n    return 0\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        // sort side length in descending order\\n        std::sort( nums.rbegin(), nums.rend() );\\n        \\n        for( int i = 0 ; i < nums.size()-2 ; i++ ){\\n            \\n            // Accept: find the triangle with largest perimeter\\n            if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }\\n            \\n        }\\n        \\n        // Reject: impossible to make triangle\\n        return 0;\\n    }\\n};\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #611 Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/)\\n\\n[Leetcode #812 Largest Triangle Area](https://leetcode.com/problems/largest-triangle-area/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about sort( ) with direction](https://docs.python.org/3/howto/sorting.html#ascending-and-descending)\\n\\n[2] [Wiki: Triangle inequality](https://en.wikipedia.org/wiki/Triangle_inequality)\\n\\n[3] [MDN docs: Javascript Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\\n\\n[4] [CPP plus docs: STL sort()](https://cplusplus.com/reference/algorithm/sort/)\\n\\n[5] [Go offical docs: sort](https://pkg.go.dev/sort)\\n\\n[6] [Java official docs: sort](https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#sort(int[],%20int,%20int))",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        \\n\\t\\t# sort side length in descending order\\n        A.sort( reverse = True )\\n        \\n\\t\\t# Try and test from largest side length\\n        for i in range( len(A) - 2):\\n            \\n            if A[i] < A[i+1] + A[i+2]:\\n                # Early return when we find largest perimeter triangle\\n                return A[i] + A[i+1] + A[i+2]\\n        \\n        # Reject: impossible to make triangle\\n        return 0\\n        \\n```\n```\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        \\n        // Java native int[] sort doesn\\'t support reverse option\\n        Arrays.sort( nums );\\n\\n        for( int i = nums.length-3 ; i >= 0 ; i--){\\n            \\n            if( nums[i+2] < ( nums[i+1] + nums[i] ) ){\\n                // Accept: find the triangle with largest perimeter\\n                return ( nums[i] + nums[i+1] + nums[i+2] );\\n            }\\n            \\n        }\\n        \\n        // Reject: impossible to make triangle\\n        return 0;\\n    }\\n}\\n```\n```\\nvar compareFn = function(a, b){\\n    // put larger element of the left hand side\\n    return b - a;    \\n}\\n\\nvar largestPerimeter = function(nums) {\\n    \\n    nums.sort( compareFn );\\n    \\n    for( let i = 0 ; i < nums.length-2 ; i++){\\n        \\n        if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n            \\n            // Accept: find the triangle with largest perimeter\\n            return ( nums[i] +  nums[i+1] + nums[i+2] )\\n        }\\n        \\n    }\\n    \\n    // Reject: impossible to make triangle\\n    return 0;\\n};\\n```\n```\\nimport(\\n    \"sort\"\\n)\\n\\nfunc largestPerimeter(nums []int) int {\\n    \\n    // sort side length in descending order\\n    sort.Slice( nums, func( i, j int) bool{\\n        return nums[i] > nums[j]\\n    })\\n    \\n    \\n    for i := 0 ; i < len(nums)-2 ; i++ {\\n\\n        // Accept: find the triangle with largest perimeter\\n        if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n            return nums[i] + nums[i+1] + nums[i+2]\\n        }\\n\\n    }\\n    \\n    // Reject: impossible to make triangle\\n    return 0\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        // sort side length in descending order\\n        std::sort( nums.rbegin(), nums.rend() );\\n        \\n        for( int i = 0 ; i < nums.size()-2 ; i++ ){\\n            \\n            // Accept: find the triangle with largest perimeter\\n            if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }\\n            \\n        }\\n        \\n        // Reject: impossible to make triangle\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906224,
                "title": "c-4-lines-very-very-simple-solution-with-explanation",
                "content": "* Before diving into code.. Let us recall the **basic rule** for lengths of sides of a triangle\\ni.e, sum of any two sides of a triangle should be greater than its third side.\\nSimply, ` a + b > c `\\n\\twhere *a, b, c are sides of triangle*\\n\\n**Approach**:\\n Since we need the largest perimter from the given nums. We sort the array and traverse from the end\\n*  `if nums[i] < nums[i-1] + nums[i-2]`, then \\n\\t we Stop and return the perimeter==> `nums[i] + nums[i-1] + nums[i-2]`\\n \\n*  if there is no values that satisfies the given condition then\\n\\twe `return 0`\\n \\n**C++:**\\n\\n```\\nint largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i = nums.size()-1; i>=2; i--)\\n\\t\\t\\t\\tif(nums[i] < nums[i-1] + nums[i-2])    return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;\\n    }\\n \\n```\\n\\n**Please UpVote Me if you like it : )**",
                "solutionTags": [
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i = nums.size()-1; i>=2; i--)\\n\\t\\t\\t\\tif(nums[i] < nums[i-1] + nums[i-2])    return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;\\n    }\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529793,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        for(int i = nums.length - 3; i >= 0; i--) {\\n            if(nums[i] + nums[i + 1] > nums[i + 2])\\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        for(int i = nums.length - 3; i >= 0; i--) {\\n            if(nums[i] + nums[i + 1] > nums[i + 2])\\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2692917,
                "title": "java-easy-solution-beginner-friendly-98-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n  public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums); // sort element and select largest sides to maximize perimeter.\\n        int maxperimeter = 0;\\n        for(int i=nums.length-1;i>1;i--) {\\n            if(nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums); // sort element and select largest sides to maximize perimeter.\\n        int maxperimeter = 0;\\n        for(int i=nums.length-1;i>1;i--) {\\n            if(nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692879,
                "title": "c-easy-to-understand-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n int largestPerimeter(vector<int>& nums) {\\n       \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int ans;\\n        \\n        \\n        for(int i = 0; i < nums.size()- 2; i++)\\n        {\\n            if(nums[i] < nums[i+1] + nums[i+2])\\n            {\\n                 ans = nums[i]+nums[i+1]+nums[i+2];\\n                return ans;\\n            }           \\n        }\\n     \\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int largestPerimeter(vector<int>& nums) {\\n       \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int ans;\\n        \\n        \\n        for(int i = 0; i < nums.size()- 2; i++)\\n        {\\n            if(nums[i] < nums[i+1] + nums[i+2])\\n            {\\n                 ans = nums[i]+nums[i+1]+nums[i+2];\\n                return ans;\\n            }           \\n        }\\n     \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417162,
                "title": "simple-c-solution-using-sorting",
                "content": "In this we first sort the array then we are checking for each interval of length 3 of array. By triangle property, i.e. sum of two sides must be greater than largest side of the triangle.\\n\\n```\\nint largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                sum=max(sum,nums[i]+nums[i+1]+nums[i+2]);\\n            }\\n        }\\n        return sum;\\n    }\\n```\\nIf any doubt then feel free to ask !!\\nIf you get some value from this, then show some love by upvoting it !!\\nHappy Coding \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                sum=max(sum,nums[i]+nums[i+1]+nums[i+2]);\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840745,
                "title": "python-faster-than-100",
                "content": "Sort the list, then go through the triples of numbers starting with the largest triple. \\n\\nReturn the perimeter of the first valid triangle.\\n\\n```\\ndef largestPerimeter(nums):\\n    if len(nums) < 3: return 0\\n    nums.sort(reverse=True)\\n    a, b = nums[:2]\\n    for c in nums[2:]:\\n        if b + c > a:\\n            return a + b + c\\n        a, b = b, c\\n    return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef largestPerimeter(nums):\\n    if len(nums) < 3: return 0\\n    nums.sort(reverse=True)\\n    a, b = nums[:2]\\n    for c in nums[2:]:\\n        if b + c > a:\\n            return a + b + c\\n        a, b = b, c\\n    return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 218037,
                "title": "javascript-4-lines-sort",
                "content": "The longest length of a side of a triangle is smaller than sum of  other two sides lengths.\\nthe array is sorted descending  and check each A[i]<A[i+1]+A[i+2], A[i] is always max(A[i+1],A[i+2])\\n```\\nvar largestPerimeter = function(A) {\\n\\tA.sort(function(a, b) { return b - a; });    \\n\\tfor(let i=0;i<A.length-2;i++){\\n\\t\\tlet sum = A[i+1] + A[i+2];\\n\\t\\tif (sum > A[i]) return sum + A[i];\\n\\t }\\n\\treturn 0;  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestPerimeter = function(A) {\\n\\tA.sort(function(a, b) { return b - a; });    \\n\\tfor(let i=0;i<A.length-2;i++){\\n\\t\\tlet sum = A[i+1] + A[i+2];\\n\\t\\tif (sum > A[i]) return sum + A[i];\\n\\t }\\n\\treturn 0;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693367,
                "title": "largest-perimeter-triangle-faster-than-97-3-pointers-c",
                "content": "# Intuition\\nThe basic intuition was to sort the array and check the elements from the end. If the sum of last second and last third element is greater than last element, then return the sum of all last three elements, else decrement all pointers by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n        int a = size - 3, b = size - 2, c = size - 1;\\n\\n        while(a >= 0){\\n            if(nums[a] + nums[b] > nums[c]) return nums[a] + nums[b] + nums[c];\\n            else{\\n                a--;\\n                b--;\\n                c--;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n        int a = size - 3, b = size - 2, c = size - 1;\\n\\n        while(a >= 0){\\n            if(nums[a] + nums[b] > nums[c]) return nums[a] + nums[b] + nums[c];\\n            else{\\n                a--;\\n                b--;\\n                c--;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671103,
                "title": "python-easy-solution-faster-than-88-59",
                "content": "Runtime: 209 ms, **faster than 88.59%** of Python3 online submissions for Largest Perimeter Triangle.\\nMemory Usage: 15.4 MB, **less than 91.33%** of Python3 online submissions for Largest Perimeter Triangle.\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return 0\\n        \\n        nums.sort(reverse = True)\\n        for i in range(3,len(nums)+1):\\n            if(nums[i-3] < nums[i-2] + nums[i-1]):\\n                return sum(nums[i-3:i])\\n        \\n        return 0\\n```\\nKindly upvote if it helped you. Thanks :)",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return 0\\n        \\n        nums.sort(reverse = True)\\n        for i in range(3,len(nums)+1):\\n            if(nums[i-3] < nums[i-2] + nums[i-1]):\\n                return sum(nums[i-3:i])\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514283,
                "title": "javascript-easy-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\nvar largestPerimeter = function(A) {\\n  A.sort((a, b) => b - a);\\n  const N = A.length - 2;\\n  for (let i = 0; i < N; i++) {\\n    if (A[i] < A[i + 1] + A[i + 2]) return A[i] + A[i + 1] + A[i + 2];\\n  }\\n  return 0;\\n};\\n```\\n\\n* 84/84 cases passed (92 ms)\\n* Your runtime beats 86.17 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (38.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\nvar largestPerimeter = function(A) {\\n  A.sort((a, b) => b - a);\\n  const N = A.length - 2;\\n  for (let i = 0; i < N; i++) {\\n    if (A[i] < A[i + 1] + A[i + 2]) return A[i] + A[i + 1] + A[i + 2];\\n  }\\n  return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491556,
                "title": "easy-swift-solution",
                "content": "Easy Swift solution\\n```\\nclass Solution {\\n    func largestPerimeter(_ A: [Int]) -> Int {\\n        let a = A.sorted(by: >) // descending sort\\n        for i in 0..<(a.count - 2) { // loop every 3 of lengths from large to small\\n            if a[i + 1] + a[i + 2] - a[i] > 0 { // triangle is possible and non-empty\\n                return a[i + 1] + a[i + 2] + a[i]\\n            }\\n        }\\n        return 0 // there is no possible non-empty triangles\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestPerimeter(_ A: [Int]) -> Int {\\n        let a = A.sorted(by: >) // descending sort\\n        for i in 0..<(a.count - 2) { // loop every 3 of lengths from large to small\\n            if a[i + 1] + a[i + 2] - a[i] > 0 { // triangle is possible and non-empty\\n                return a[i + 1] + a[i + 2] + a[i]\\n            }\\n        }\\n        return 0 // there is no possible non-empty triangles\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694502,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        for(int i=n-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                return nums[i]+nums[i-1]+nums[i-2];\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        for(int i=n-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                return nums[i]+nums[i-1]+nums[i-2];\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693376,
                "title": "javascript-explained-with-comments-and-visualization",
                "content": "There is a great rule that\\'s called **Traingle Inequality** and it states the following:\\n\\n**In mathematics, the triangle inequality states that for any triangle, the sum of the lengths of any two sides must be greater than the length of the remaining side.**\\n**If x, y, and z are the lengths of the sides of the triangle, with no side being greater than z, then the triangle inequality states that z < x + y**\\n\\nFor example, we can take the next triangle for visualization:\\n\\n![image](https://assets.leetcode.com/users/images/411d9368-fecd-4970-b462-fcd2f2b1bde1_1665556972.1866663.png)\\n\\nThe rule states that **x + y > z**.\\n\\nTo answer the question, we first of all can sort the array in decreasing order, because we know that if **x + y > z**, then **x + z > y also**.\\nAfter that, we will loop through the array, we will declare three variables that will indicate the three sides of a triangle.\\nIf the sum b + c is greater than a (the last side of the triangle), then we know we have an answer (we just go by the rule I stated above).\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {    \\n\\t// Sort in DESC order\\n    nums.sort((a, b) => b - a);\\n        \\n    for(let i = 0; i < nums.length; i++) {\\n\\t\\n\\t\\t// Decalre the three sides of the triangle\\n        let a = nums[i], b = nums[i + 1], c = nums[i + 2];\\n        \\n\\t\\t// Perform the check depending on the rule\\n        if(a < b + c) return a + b + c;\\n    }\\n    \\n\\t// If we cannot form a triangle, we return 0\\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {    \\n\\t// Sort in DESC order\\n    nums.sort((a, b) => b - a);\\n        \\n    for(let i = 0; i < nums.length; i++) {\\n\\t\\n\\t\\t// Decalre the three sides of the triangle\\n        let a = nums[i], b = nums[i + 1], c = nums[i + 2];\\n        \\n\\t\\t// Perform the check depending on the rule\\n        if(a < b + c) return a + b + c;\\n    }\\n    \\n\\t// If we cannot form a triangle, we return 0\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692990,
                "title": "c-easy-math-rule-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        // as we know for creating a perfect Triangle two sides sum should be greater than the 3rd one\\n        // a+b>c   or     a+c>b    or   b+c>a\\n\\t\\t// now arrange values in increasing order , so no need to check for every combination\\n        sort(nums.begin(),nums.end());\\n        int mx = 0;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            if(nums[i]+nums[i+1]>nums[i+2]) mx = max(mx,nums[i]+nums[i+1]+nums[i+2]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        // as we know for creating a perfect Triangle two sides sum should be greater than the 3rd one\\n        // a+b>c   or     a+c>b    or   b+c>a\\n\\t\\t// now arrange values in increasing order , so no need to check for every combination\\n        sort(nums.begin(),nums.end());\\n        int mx = 0;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            if(nums[i]+nums[i+1]>nums[i+2]) mx = max(mx,nums[i]+nums[i+1]+nums[i+2]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692871,
                "title": "largest-perimeter-triangle-5-solutions-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 Largest Perimeter Triangle \\uD83D\\uDD25 || 5 Solutions || Simple Fast and Easy || with Explanation\\n\\n## Solution - 1\\n\\n### Explanation\\n- Before diving into code.. Let us recall the basic rule for lengths of sides of a triangle\\n i.e, sum of any two sides of a triangle should be greater than its third side.\\n Simply, a + b > c\\n-  where a, b, c are sides of triangle\\n ### Approach:\\n Since we need the largest perimeter from the given nums. We sort the array and traverse from the end\\n\\n-  if nums[i] < nums[i-1] + nums[i-2], then\\n we Stop and return the perimeter==> nums[i] + nums[i-1] + nums[i-2]\\n\\n-  if there is no values that satisfies the given condition then\\n we return 0\\n\\n```dart\\nclass Solution {\\n// Runtime: 426 ms, faster than 80.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 149.6 MB, less than 100.00% of Dart online submissions for Largest Perimeter Triangle.\\n\\n  int largestPerimeter(List<int> nums) {\\n    nums.sort();\\n    for (int i = nums.length - 1; i > 1; --i)\\n      if (nums[i] < nums[i - 1] + nums[i - 2])\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n    return 0;\\n  }\\n}\\n```\\n\\n## Solution - 2 Recursive\\n\\n```dart\\nclass Solution {\\n// Runtime: 514 ms, faster than 60.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 150.2 MB, less than 20.00% of Dart online submissions for Largest Perimeter Triangle.\\n\\n  //utility method to get max element at given index\\n  void swapToGetMax(List<int> nums, int index) {\\n    int max = 0, maxIndex = -1;\\n    for (int i = 0; i <= index; i++)\\n      if (max < nums[i]) {\\n        max = nums[i];\\n        maxIndex = i;\\n      }\\n    //actual swapping after finding max element in given range\\n    int temp = nums[index];\\n    nums[index] = max;\\n    nums[maxIndex] = temp;\\n  }\\n\\n  int largestPerimeter(List<int> nums) {\\n    //if array has only 3 elements\\n    if (nums.length == 3) {\\n      if (nums[0] < nums[1] + nums[2] &&\\n          nums[1] < nums[0] + nums[2] &&\\n          nums[2] < nums[1] + nums[0])\\n        return nums[0] + nums[1] + nums[2];\\n      else\\n        return 0;\\n    }\\n    //for more than 3 elements, without doing explicit sorting\\n    int n = nums.length;\\n    //here we are putting max element at last index\\n    swapToGetMax(nums, n - 1);\\n    //here we are putting max element at second last index\\n    swapToGetMax(nums, n - 2);\\n    //here we are putting max element at third last index\\n    swapToGetMax(nums, n - 3);\\n    //in loop checking if nums[i]<nums[i-1]+nums[i-2] which this triplet will form the max perimeter\\n    for (int i = n - 1; i >= 2; i--) {\\n      if (nums[i] < nums[i - 1] + nums[i - 2])\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n      //if not then will find max element as (i-3)th largest element\\n      else if (i > 2) swapToGetMax(nums, i - 3);\\n    }\\n    return 0;\\n  }\\n}\\n```\\n\\n## Solution - 3\\n\\n```dart\\nclass Solution {\\n// Runtime: 596 ms, faster than 40.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 150.3 MB, less than 20.00% of Dart online submissions for Largest Perimeter Triangle.\\n  int largestPerimeter(List<int> nums) {\\n    if (nums.length == 3) {\\n      if (nums[0] < nums[1] + nums[2] &&\\n          nums[1] < nums[0] + nums[2] &&\\n          nums[2] < nums[1] + nums[0])\\n        return nums[0] + nums[1] + nums[2];\\n      else\\n        return 0;\\n    }\\n    int n = nums.length;\\n    int maxi = 0;\\n    for (int i = 0; i < n - 2; i++) {\\n      for (int j = i + 1; j < n - 1; j++) {\\n        for (int k = j + 1; k < n; k++) {\\n          int a = nums[i];\\n          int b = nums[j];\\n          int c = nums[k];\\n          if (a < b + c && b < c + a && c < a + b) maxi = max(maxi, a + b + c);\\n        }\\n      }\\n    }\\n    if (maxi > 0) return maxi;\\n    return 0;\\n  }\\n}\\n```\\n\\n## Solution - 4\\n\\n```dart\\nclass Solution {\\n  int largestPerimeter(List<int> nums) {\\n    //sort the vector\\n    nums.sort();\\n    //any triangle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n    int maxPerimeter = 0;\\n\\n    for (int i = 0; i <= nums.length - 3; i++) {\\n      //check the triangle valid condition\\n      if (nums[i] + nums[i + 1] > nums[i + 2]) {\\n        maxPerimeter =\\n            max(maxPerimeter, nums[i] + nums[i + 1] + nums[i + 2]); //find max\\n      }\\n    }\\n\\n    return maxPerimeter; //return the result\\n  }\\n}\\n```\\n\\n## Solution - 5\\n\\n```dart\\nclass Solution {\\n  int largestPerimeter(List<int> nums) {\\n    nums.sort((a, b) => a - b);\\n    int i = nums.length - 1;\\n    while (i >= 0) {\\n      if (nums[i] < nums[i - 1] + nums[i - 2]) {\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n      } else {\\n        i--;\\n      }\\n    }\\n    return 0;\\n  }\\n}\\n```\\n## [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Recursion",
                    "Sorting"
                ],
                "code": "```dart\\nclass Solution {\\n// Runtime: 426 ms, faster than 80.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 149.6 MB, less than 100.00% of Dart online submissions for Largest Perimeter Triangle.\\n\\n  int largestPerimeter(List<int> nums) {\\n    nums.sort();\\n    for (int i = nums.length - 1; i > 1; --i)\\n      if (nums[i] < nums[i - 1] + nums[i - 2])\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n    return 0;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n// Runtime: 514 ms, faster than 60.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 150.2 MB, less than 20.00% of Dart online submissions for Largest Perimeter Triangle.\\n\\n  //utility method to get max element at given index\\n  void swapToGetMax(List<int> nums, int index) {\\n    int max = 0, maxIndex = -1;\\n    for (int i = 0; i <= index; i++)\\n      if (max < nums[i]) {\\n        max = nums[i];\\n        maxIndex = i;\\n      }\\n    //actual swapping after finding max element in given range\\n    int temp = nums[index];\\n    nums[index] = max;\\n    nums[maxIndex] = temp;\\n  }\\n\\n  int largestPerimeter(List<int> nums) {\\n    //if array has only 3 elements\\n    if (nums.length == 3) {\\n      if (nums[0] < nums[1] + nums[2] &&\\n          nums[1] < nums[0] + nums[2] &&\\n          nums[2] < nums[1] + nums[0])\\n        return nums[0] + nums[1] + nums[2];\\n      else\\n        return 0;\\n    }\\n    //for more than 3 elements, without doing explicit sorting\\n    int n = nums.length;\\n    //here we are putting max element at last index\\n    swapToGetMax(nums, n - 1);\\n    //here we are putting max element at second last index\\n    swapToGetMax(nums, n - 2);\\n    //here we are putting max element at third last index\\n    swapToGetMax(nums, n - 3);\\n    //in loop checking if nums[i]<nums[i-1]+nums[i-2] which this triplet will form the max perimeter\\n    for (int i = n - 1; i >= 2; i--) {\\n      if (nums[i] < nums[i - 1] + nums[i - 2])\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n      //if not then will find max element as (i-3)th largest element\\n      else if (i > 2) swapToGetMax(nums, i - 3);\\n    }\\n    return 0;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n// Runtime: 596 ms, faster than 40.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 150.3 MB, less than 20.00% of Dart online submissions for Largest Perimeter Triangle.\\n  int largestPerimeter(List<int> nums) {\\n    if (nums.length == 3) {\\n      if (nums[0] < nums[1] + nums[2] &&\\n          nums[1] < nums[0] + nums[2] &&\\n          nums[2] < nums[1] + nums[0])\\n        return nums[0] + nums[1] + nums[2];\\n      else\\n        return 0;\\n    }\\n    int n = nums.length;\\n    int maxi = 0;\\n    for (int i = 0; i < n - 2; i++) {\\n      for (int j = i + 1; j < n - 1; j++) {\\n        for (int k = j + 1; k < n; k++) {\\n          int a = nums[i];\\n          int b = nums[j];\\n          int c = nums[k];\\n          if (a < b + c && b < c + a && c < a + b) maxi = max(maxi, a + b + c);\\n        }\\n      }\\n    }\\n    if (maxi > 0) return maxi;\\n    return 0;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  int largestPerimeter(List<int> nums) {\\n    //sort the vector\\n    nums.sort();\\n    //any triangle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n    int maxPerimeter = 0;\\n\\n    for (int i = 0; i <= nums.length - 3; i++) {\\n      //check the triangle valid condition\\n      if (nums[i] + nums[i + 1] > nums[i + 2]) {\\n        maxPerimeter =\\n            max(maxPerimeter, nums[i] + nums[i + 1] + nums[i + 2]); //find max\\n      }\\n    }\\n\\n    return maxPerimeter; //return the result\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  int largestPerimeter(List<int> nums) {\\n    nums.sort((a, b) => a - b);\\n    int i = nums.length - 1;\\n    while (i >= 0) {\\n      if (nums[i] < nums[i - 1] + nums[i - 2]) {\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n      } else {\\n        i--;\\n      }\\n    }\\n    return 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738009,
                "title": "ruby-solution-several-variants-of-sliding-window",
                "content": "##### Leetcode: 976. Largest Perimeter Triangle.\\n\\n\\nIdea is in sorting input array. And sliding window of 3 elements from biggest to smallest elements. If in this window biggest element is less then sum of middle and small one - this means it is largest perimeter in this array, because it is already the biggest elements that granted by required criteria. \\n\\nRuby code:\\n```Ruby\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 88 ms, faster than 33.33% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 13.8 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(a)\\n  a.sort.reverse.each_cons(3).each{|(x,y,z)| \\n      return x+y+z if y+z > x\\n  }\\n 0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 116 ms, faster than 22.22% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 13.9 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(a)\\n  z = a.sort.reverse\\n  (2...z.size).each do |i|\\n      return z[i-2]+z[i-1]+z[i] if z[i-2] < z[i-1] + z[i]\\n  end\\n  0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 176 ms, faster than 11.11% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 12 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(z)\\n  z.sort_by!{|x| -x}\\n  (2...z.size).each do |i|\\n      return z[i-2]+z[i-1]+z[i] if z[i-2] < z[i-1] + z[i]\\n  end\\n  0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 124 ms, faster than 11.11% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 11.9 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(z)\\n  z.sort!\\n  bigest, middle, smallest = z.size-1, z.size-2, z.size-3;\\n  while smallest >= 0\\n     return z[bigest] + z[middle] + z[smallest] if z[bigest] < z[middle] + z[smallest]\\n      bigest -= 1; middle -= 1; smallest -= 1;\\n  end\\n  0\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Sliding Window"
                ],
                "code": "```Ruby\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 88 ms, faster than 33.33% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 13.8 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(a)\\n  a.sort.reverse.each_cons(3).each{|(x,y,z)| \\n      return x+y+z if y+z > x\\n  }\\n 0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 116 ms, faster than 22.22% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 13.9 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(a)\\n  z = a.sort.reverse\\n  (2...z.size).each do |i|\\n      return z[i-2]+z[i-1]+z[i] if z[i-2] < z[i-1] + z[i]\\n  end\\n  0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 176 ms, faster than 11.11% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 12 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(z)\\n  z.sort_by!{|x| -x}\\n  (2...z.size).each do |i|\\n      return z[i-2]+z[i-1]+z[i] if z[i-2] < z[i-1] + z[i]\\n  end\\n  0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 124 ms, faster than 11.11% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 11.9 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(z)\\n  z.sort!\\n  bigest, middle, smallest = z.size-1, z.size-2, z.size-3;\\n  while smallest >= 0\\n     return z[bigest] + z[middle] + z[smallest] if z[bigest] < z[middle] + z[smallest]\\n      bigest -= 1; middle -= 1; smallest -= 1;\\n  end\\n  0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 473798,
                "title": "python-with-heap",
                "content": "1) No need to sort the entire array. We need 3 largest numbers, then may be next largerst etc. Therefore we build the heap, to pre-order data only. O(n) time. Though Python\\'s min heap needs to negate the number, another O(n) run\\n2) To check the triangle rule, no need need to check every 3 combinations of the sides a, b, c, one check is enough. if a is the largest side, then then b < a + c and c < a + b are guaranteed, only need to check if a < b + c holds true\\n\\n```\\nfrom heapq import heapify, heappop\\n\\n\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        for i, x in enumerate(A):\\n            A[i] = -x\\n        heapify(A)\\n        \\n        s0 = -heappop(A)\\n        s1 = -heappop(A)\\n        s2 = -heappop(A)\\n        \\n        try:\\n            while s0 >= s1 + s2:\\n                s0, s1, s2 = s1, s2, -heappop(A)\\n            return s0 + s1 + s2\\n        except IndexError:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heapify, heappop\\n\\n\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        for i, x in enumerate(A):\\n            A[i] = -x\\n        heapify(A)\\n        \\n        s0 = -heappop(A)\\n        s1 = -heappop(A)\\n        s2 = -heappop(A)\\n        \\n        try:\\n            while s0 >= s1 + s2:\\n                s0, s1, s2 = s1, s2, -heappop(A)\\n            return s0 + s1 + s2\\n        except IndexError:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741189,
                "title": "c-o-n-sorting-easy-basic-triangle-properties",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n\\t\\t\\n\\t\\t// Sort in reverse order.\\n        sort(nums.begin(), nums.end(), greater<int>()); \\n\\t\\t\\n        int n = nums.size();\\n        int i = 0;\\n\\t\\t\\n\\t\\t// Run loop until we satisfy the basic triangle property ( sum of 2 sides >= third side).\\n\\t\\t// As the array is sorted in reverse order we will always get the maximum perimeter.\\n        while (i < n - 2 && nums[i] >= nums[i + 1] + nums[i + 2]) {\\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// If the we are unable to satisfy the property return 0 else the sum of 3 sides.\\n        return i >= n - 2 ? 0 : nums[i] + nums[i + 1] + nums[i + 2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n\\t\\t\\n\\t\\t// Sort in reverse order.\\n        sort(nums.begin(), nums.end(), greater<int>()); \\n\\t\\t\\n        int n = nums.size();\\n        int i = 0;\\n\\t\\t\\n\\t\\t// Run loop until we satisfy the basic triangle property ( sum of 2 sides >= third side).\\n\\t\\t// As the array is sorted in reverse order we will always get the maximum perimeter.\\n        while (i < n - 2 && nums[i] >= nums[i + 1] + nums[i + 2]) {\\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// If the we are unable to satisfy the property return 0 else the sum of 3 sides.\\n        return i >= n - 2 ? 0 : nums[i] + nums[i + 1] + nums[i + 2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693108,
                "title": "c-java-kotlin-o-n-partial-sorting-using-fibonacci-optimization",
                "content": "The standard solution for this leetcode problem, as shown on the problem\\'s Solution tab and as used by most people\\'s solutions for this problem, is to first sort the entire `nums[]` array, then search for the highest three adjacent values that form a valid triangle.  The code below uses a slightly different algorithm which uses ony a partial heap sort of the `nums[]` array to only sort as many values as needed, with the maximum values to be sorted being 31 as defined by the Fibonacci test case shown further below.  The standard coding solution is O(NlogN) because of the full sort of all `nums[]` values, while the partial sort algorithm is O(N).\\n\\n--- PARTIAL SORT ALGORITHM ---\\nThe solution below optimizes runtime by only doing a partial heap sort to try to solve this problem, which appears to be faster than the standard coding solution for this problem.  In Java, the partial heap sort code below is 8 times faster than my standard solution code, using my fastest runtimes for both coding solutions.  The partial sorting routine `swapMaxElement()` is called each time the next highest number from `nums[]` is needed, and that next highest number is placed toward the end of the `nums[]` array.  The `nums[]` array becomes sorted from the end back toward the start of the array, one value at a time.\\n\\nFirst the three highest values are moved to the last three positions in the `nums[]` array, by calling `swapMaxElement()` three times.  Then we test the triplet made of those highest three values in `nums[]` to see if they form a valid triangle.  A valid triangle is formed if the highest value at `nums[i]` is less than the sum of the next two adjacent lower values in `nums[i-1]` and `nums[i-2]`, when those values are in their sort order within `nums[]`.  If the highest three values in `nums[]` don\\'t form a valid triangle, then call `swapMaxElement()` again to get the next higher value in `nums[]` into its sorted position, then test the next lower triplet of values in `nums[]` to see if they form a valid triangle.  Repeat this process of sorting one more value, then testing the next triplet of adjacent values for a valid triangle, until a valid triangle is found, or we run out of triplets to test.\\n\\n--- FIBONACCI TEST CASE WITHOUT ANY TRIANGLES ---\\nIn this leetcode problem, the longest possible test case which does not form any valid triangle, is shown in sorted order as:\\n```\\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \\n233, 377, 610, 987, 1597, 2584, 4181, 6765, \\n10946, 17711, 28657, 46368, 75025, 121393, \\n196418, 317811, 514229, 832040]\\n```\\nThis test case is formed by starting with 1, 1 then each successive number is the sum of the previous two numbers, which gives the Fibonacci sequence.  This process is repeated until a number exceeds the maximum value, which is defined in this leetcode problem\\'s description as 10^6.  Any test case formed this way will NOT be able to form a valid triangle from any triplet of the values.  **The above test case has 30 values**.\\n\\n--- WORST CASE FOR PARTIAL SORT ---\\nUsing the partial heap sort in the code below, which gets the next higher value for each call to the partial heap sort routine `swapMaxElement()`, we will have to **sort at most 31 values before finding a valid triangle**.  The longest test case without any valid triangle has 30 values, as shown in the example test case above.  If another value is appended to that test case, then that modified test case would contain a valid triangle.  In this leetcode problem, the passed `nums[]` array can have up to 10_000 values.  But in the partial-sorting algorithm in the code below, at most only 31 values would need to be sorted, and usually fewer would need sorting.  This implies that **any test case with 31 or more values MUST contain a valid triangle**.\\n\\nCurrently in this leetcode problem\\'s test cases in October 2022, the worst test case only has to search through 19 triplets before finding a valid triangle.  This means that the partial-sort routine `swapMaxElement` had to be called 19+2=21 times, which is once for each of the 19 triplets searched, plus 2 extra times to create the first triplet.\\n\\nAlthough the Fibonacci test case above is the longest possible test case without any valid triangles, it is not the only possible test case of this length.  For example, adding a positive integer to the last value in the above Fibonacci test case, will result in a test case that still doesn\\'t have any valid triangles.  Other values in that Fibonacci test case can also be increased, as long as all values in the test case are increased by at least the sum of the increase of the previous two values in the test case, which will still result in a test case without any valid triangles.  The Fibonacci test case is the lowest valued test case possible for length 30 while not having any valid triangles.\\n\\n--- EXECUTION TIMES ---\\nThe code below had fast runtimes in C++ (32ms 99%), Java (1ms 100%), and Kotlin (263ms 100%) based on the leetcode problem\\'s graph data on October 10, 2022.  These runtimes are the fastest runtimes from my multiple Submits, and the runtimes and percentages may change in the future as test cases are changed and as other people develop faster code.\\n\\nIf useful, please upvote.\\n\\n**C++ ----------------**\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        swapMaxElement(nums, nums.size() - 1);\\n        swapMaxElement(nums, nums.size() - 2);\\n        for (int i = nums.size() - 1; i >= 2; i--) {\\n            swapMaxElement(nums, i - 2);\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        }\\n        return 0;\\n    }\\n    \\n    void swapMaxElement(vector<int>& nums, int index) {\\n        int max = nums[0];\\n        int maxIndex = 0;\\n        for (int i = 1; i <= index; i++)\\n            if (nums[i] > max)\\n                max = nums[(maxIndex = i)];\\n        nums[maxIndex] = nums[index];\\n        nums[index] = max;\\n    }\\n};\\n```\\n**Java -----------------**\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        swapMaxElement(nums, nums.length - 1);\\n        swapMaxElement(nums, nums.length - 2);\\n        for (int i = nums.length - 1; i >= 2; i--) {\\n            swapMaxElement(nums, i - 2);\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        }\\n        return 0;\\n    }\\n    \\n    \\n    private void swapMaxElement(int[] nums, int index) {\\n        int max = nums[0];\\n        int maxIndex = 0;\\n        for (int i = 1; i <= index; i++)\\n            if (nums[i] > max)\\n                max = nums[(maxIndex = i)];\\n        nums[maxIndex] = nums[index];\\n        nums[index] = max;\\n    }\\n}\\n```\\n**Kotlin ----------------**\\n```\\nclass Solution {\\n    fun largestPerimeter(nums: IntArray): Int {\\n        swapMaxElement(nums, nums.lastIndex)\\n        swapMaxElement(nums, nums.lastIndex - 1)\\n        for (i in nums.lastIndex downTo 2) {\\n            swapMaxElement(nums, i - 2)\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2]\\n        }\\n        return 0\\n    }\\n    \\n    \\n    fun swapMaxElement(nums: IntArray, index: Int) {\\n        var max = nums[0]\\n        var maxIndex = 0\\n        for (i in 1..index)\\n            if (nums[i] > max) {\\n                max = nums[i]\\n                maxIndex = i\\n            }\\n        nums[maxIndex] = nums[index]\\n        nums[index] = max\\n    }\\n}\\n```\\n\\n\\n**Java (standard solution) --------------**\\nThe following Java code is the solution that most people use, and is the official solution on the Solution tab for this leetcode problem.  This code is much simpler than the faster code above.  It simply sorts the `nums[]` array in ascending order.  Then search backward in the array from highest to lowest values, to find the first three adjacent values in the sorted array which can form a valid triangle.\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        return 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Kotlin"
                ],
                "code": "```\\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \\n233, 377, 610, 987, 1597, 2584, 4181, 6765, \\n10946, 17711, 28657, 46368, 75025, 121393, \\n196418, 317811, 514229, 832040]\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        swapMaxElement(nums, nums.size() - 1);\\n        swapMaxElement(nums, nums.size() - 2);\\n        for (int i = nums.size() - 1; i >= 2; i--) {\\n            swapMaxElement(nums, i - 2);\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        }\\n        return 0;\\n    }\\n    \\n    void swapMaxElement(vector<int>& nums, int index) {\\n        int max = nums[0];\\n        int maxIndex = 0;\\n        for (int i = 1; i <= index; i++)\\n            if (nums[i] > max)\\n                max = nums[(maxIndex = i)];\\n        nums[maxIndex] = nums[index];\\n        nums[index] = max;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        swapMaxElement(nums, nums.length - 1);\\n        swapMaxElement(nums, nums.length - 2);\\n        for (int i = nums.length - 1; i >= 2; i--) {\\n            swapMaxElement(nums, i - 2);\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        }\\n        return 0;\\n    }\\n    \\n    \\n    private void swapMaxElement(int[] nums, int index) {\\n        int max = nums[0];\\n        int maxIndex = 0;\\n        for (int i = 1; i <= index; i++)\\n            if (nums[i] > max)\\n                max = nums[(maxIndex = i)];\\n        nums[maxIndex] = nums[index];\\n        nums[index] = max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun largestPerimeter(nums: IntArray): Int {\\n        swapMaxElement(nums, nums.lastIndex)\\n        swapMaxElement(nums, nums.lastIndex - 1)\\n        for (i in nums.lastIndex downTo 2) {\\n            swapMaxElement(nums, i - 2)\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2]\\n        }\\n        return 0\\n    }\\n    \\n    \\n    fun swapMaxElement(nums: IntArray, index: Int) {\\n        var max = nums[0]\\n        var maxIndex = 0\\n        for (i in 1..index)\\n            if (nums[i] > max) {\\n                max = nums[i]\\n                maxIndex = i\\n            }\\n        nums[maxIndex] = nums[index]\\n        nums[index] = max\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692676,
                "title": "two-method-c-explanation-solution-sorting-greedy",
                "content": "**Approach 1**\\n\\n      int largestPerimeter(vector<int>& nums) {\\n        //sort the vector\\n        sort(nums.begin(),nums.end());\\n        //any tringle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n        int maxPerimeter=0;\\n        \\n        for(int i=0;i<=nums.size()-3;i++){\\n            //check the triangle valid condition\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                maxPerimeter=max(maxPerimeter,nums[i]+nums[i+1]+nums[i+2]); //find max\\n            }\\n        }\\n        \\n        return maxPerimeter; //return the result\\n    }\\n\\t\\n\\t\\n\\t\\n**Approach 2 : Sort the array**\\n**We know that max value gives maximum perimeter...so use greedy method...choose element from the last and if valid triangle then return the value**\\n\\n\\n\\n        int largestPerimeter(vector<int>& nums) {\\n        //sort the vector\\n        sort(nums.begin(),nums.end());\\n        //any tringle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n        \\n        \\n        for(int i=nums.size()-1;i>=2;i--){\\n            //check the triangle valid condition\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                return(nums[i]+nums[i-1]+nums[i-2]); //perimeter\\n            }\\n        }\\n        \\n        return 0; //return 0\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "**Approach 1**\\n\\n      int largestPerimeter(vector<int>& nums) {\\n        //sort the vector\\n        sort(nums.begin(),nums.end());\\n        //any tringle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n        int maxPerimeter=0;\\n        \\n        for(int i=0;i<=nums.size()-3;i++){\\n            //check the triangle valid condition\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                maxPerimeter=max(maxPerimeter,nums[i]+nums[i+1]+nums[i+2]); //find max\\n            }\\n        }\\n        \\n        return maxPerimeter; //return the result\\n    }\\n\\t\\n\\t\\n\\t\\n**Approach 2 : Sort the array**\\n**We know that max value gives maximum perimeter...so use greedy method...choose element from the last and if valid triangle then return the value**\\n\\n\\n\\n        int largestPerimeter(vector<int>& nums) {\\n        //sort the vector\\n        sort(nums.begin(),nums.end());\\n        //any tringle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n        \\n        \\n        for(int i=nums.size()-1;i>=2;i--){\\n            //check the triangle valid condition\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                return(nums[i]+nums[i-1]+nums[i-2]); //perimeter\\n            }\\n        }\\n        \\n        return 0; //return 0\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2692674,
                "title": "python-o-nlog-n-greedy-short",
                "content": "For a triangle to be valid it must satisfy the triangle inequality.\\n\\nWe sort the array in descending order and then iterate through looking for the largest perimeter triangle in a greedy fashion.\\n\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        # triange in-equality a+b > c\\n        # sum of 2 smallest > largest\\n        nums.sort(reverse=True)\\n        a,b,c = inf,inf,inf\\n        for n in nums:\\n            a, b, c = n, a, b\\n            if a + b > c:\\n                return a+b+c       \\n        return 0\\n         \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        # triange in-equality a+b > c\\n        # sum of 2 smallest > largest\\n        nums.sort(reverse=True)\\n        a,b,c = inf,inf,inf\\n        for n in nums:\\n            a, b, c = n, a, b\\n            if a + b > c:\\n                return a+b+c       \\n        return 0\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692525,
                "title": "c-solution-using-geometry",
                "content": "# **Steps**\\n* Sort the **array**\\n* Apply the geometry principe of triangle \"**The sum of the length of the two sides of a triangle is greater than the length of the third side**\" **A<B+C**\\n* Do the reverse iteration. \\n* Apply these logic `nums[i] + nums[i+1]>nums[i+2]` \\n*  `nums[i] + nums[i+1]>nums[i+2]` if it is true then return `nums[i] + nums[i+1] + nums[i+2]`\\n*  return `0`\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i= nums.size()-3;i>=0;i--){\\n            if(nums[i] + nums[i+1]>nums[i+2]){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Geometry",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i= nums.size()-3;i>=0;i--){\\n            if(nums[i] + nums[i+1]>nums[i+2]){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500264,
                "title": "c-faster-than-97-88-solution-easy-code-with-comments-o-1-space",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n\\t\\n\\t//Sort The Array\\n        sort(nums.begin(), nums.end());\\n        \\n        int i = nums.size()-1;\\n\\t\\t\\n\\t\\t//Traverse From back so that we get largest perimeter of valid Triangle\\n        while(i>=2)\\n        {\\n\\t\\t// s1 Will Be Largest Side\\n            int s1 = nums[i];\\n            int s2 = nums[i-1];\\n            int s3 = nums[i-2];\\n           \\n\\t\\t   // Apply Triangle Side i.e. Sum of Smaller Two Sides is greater Than Largest Side\\n            if(s1 < s3 + s2)\\n                return s1 + s2 +s3;\\n            i--;\\n        }\\n        \\n\\t\\t// if no valid triangle return 0\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n\\t\\n\\t//Sort The Array\\n        sort(nums.begin(), nums.end());\\n        \\n        int i = nums.size()-1;\\n\\t\\t\\n\\t\\t//Traverse From back so that we get largest perimeter of valid Triangle\\n        while(i>=2)\\n        {\\n\\t\\t// s1 Will Be Largest Side\\n            int s1 = nums[i];\\n            int s2 = nums[i-1];\\n            int s3 = nums[i-2];\\n           \\n\\t\\t   // Apply Triangle Side i.e. Sum of Smaller Two Sides is greater Than Largest Side\\n            if(s1 < s3 + s2)\\n                return s1 + s2 +s3;\\n            i--;\\n        }\\n        \\n\\t\\t// if no valid triangle return 0\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000126,
                "title": "python-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums):\\n        nums.sort(reverse=True)\\n        \\n        for i in range(len(nums)-2):\\n            base, side1, side2 = nums[i], nums[i+1], nums[i+2]\\n            if side1 + side2 > base:\\n                return base + side1 + side2\\n\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums):\\n        nums.sort(reverse=True)\\n        \\n        for i in range(len(nums)-2):\\n            base, side1, side2 = nums[i], nums[i+1], nums[i+2]\\n            if side1 + side2 > base:\\n                return base + side1 + side2\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910480,
                "title": "c-beginner-level-solution",
                "content": "Here I\\'ve sorted the vector nums and then searched triplets starting from the end.\\n\\nAs we know, for three sides to be a triangle it has to have **two sides sum that is bigger than the third one**.\\n\\n```\\nsort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2])\\n                return nums[i]+nums[i+1]+nums[i+2];            \\n        }\\n        return 0;\\n\\n```\\nupvote if you find this helpful. Thanks.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nsort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2])\\n                return nums[i]+nums[i+1]+nums[i+2];            \\n        }\\n        return 0;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1804033,
                "title": "easy-understanding-beginner-friendly-please-upvote-if-understood",
                "content": "class Solution {\\npublic:\\n\\n    int largestPerimeter(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        for(int i=n-1;i>1;i--){\\n            int c=v[i];\\n            int a=v[i-1];\\n            int b=v[i-2];\\n            if(c<a+b)\\n                return a+b+c;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int largestPerimeter(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        for(int i=n-1;i>1;i--){\\n            int c=v[i];\\n            int a=v[i-1];\\n            int b=v[i-2];\\n            if(c<a+b)\\n                return a+b+c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1554430,
                "title": "rust-solutions-8-ms-0-ms",
                "content": "1. Simple solution with sort (O(N logN)). Runtime =  **8 ms**\\n```\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable_by(|a, b| b.cmp(a));\\n        match nums.windows(3).find(|l| l[0] < l[1] + l[2]) {\\n            Some(l) => l.iter().sum(),\\n            None => 0,\\n        }\\n    }\\n}\\n```\\n2. Solution with BinaryHeap (O(N logK)). Runtime =  **0 ms**\\n```\\n impl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        let mut heap = std::collections::BinaryHeap::from(nums);\\n        let (mut b, mut c) = (-1, -1);\\n        while let Some(a) = heap.pop() {\\n            if a > 0 && b > 0 && c > 0 && c < b + a {\\n                return a + b + c;\\n            }\\n            c = b;\\n            b = a;\\n        }\\n        0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable_by(|a, b| b.cmp(a));\\n        match nums.windows(3).find(|l| l[0] < l[1] + l[2]) {\\n            Some(l) => l.iter().sum(),\\n            None => 0,\\n        }\\n    }\\n}\\n```\n```\\n impl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        let mut heap = std::collections::BinaryHeap::from(nums);\\n        let (mut b, mut c) = (-1, -1);\\n        while let Some(a) = heap.pop() {\\n            if a > 0 && b > 0 && c > 0 && c < b + a {\\n                return a + b + c;\\n            }\\n            c = b;\\n            b = a;\\n        }\\n        0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099407,
                "title": "c-5-2-lines-o-n-log-n-solution-use-qsort",
                "content": "```\\nbool comp(void*a,void*b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestPerimeter(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    for(int i=numsSize-3;i>=0;i--){\\n        if(nums[i]+nums[i+1]>nums[i+2]){\\n            return nums[i]+nums[i+1]+nums[i+2];\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(void*a,void*b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestPerimeter(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    for(int i=numsSize-3;i>=0;i--){\\n        if(nums[i]+nums[i+1]>nums[i+2]){\\n            return nums[i]+nums[i+1]+nums[i+2];\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390818,
                "title": "two-solutions-in-python-3-beats-95",
                "content": "_One For Loop:_\\n```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n    \\tL, _ = len(A), A.sort()\\n    \\tfor i in range(L-1,1,-1):\\n    \\t\\tif A[i] < A[i-1] + A[i-2]: return sum(A[i-2:i+1])\\n    \\treturn 0\\n\\t\\t\\n\\t\\t\\n```\\n_Two For Loops:_\\n```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n    \\tL, _ = len(A), A.sort()\\n    \\tfor i in range(L-1,1,-1):\\n    \\t\\ta = A[i]\\n    \\t\\tfor j in range(i-1,0,-1):\\n    \\t\\t\\tb, m, c = A[j], a - A[j] + 1, A[j-1]\\n    \\t\\t\\tif m > b: break\\n    \\t\\t\\tif c >= m: return a + b + c\\n    \\treturn 0\\n\\t\\t\\n\\t\\t\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n    \\tL, _ = len(A), A.sort()\\n    \\tfor i in range(L-1,1,-1):\\n    \\t\\tif A[i] < A[i-1] + A[i-2]: return sum(A[i-2:i+1])\\n    \\treturn 0\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672612,
                "title": "80-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n    int n = nums.length;\\n    Arrays.sort(nums);\\n    if(n<3){\\n        return 0;\\n    }    \\n    for(int i=n-1;i>=2;i--){\\n        if(nums[i-1]+nums[i-2]>nums[i]){\\n            return nums[i]+nums[i-1]+nums[i-2];\\n        }\\n    }\\n    return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n    int n = nums.length;\\n    Arrays.sort(nums);\\n    if(n<3){\\n        return 0;\\n    }    \\n    for(int i=n-1;i>=2;i--){\\n        if(nums[i-1]+nums[i-2]>nums[i]){\\n            return nums[i]+nums[i-1]+nums[i-2];\\n        }\\n    }\\n    return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542385,
                "title": "precise-explanation-of-why-sort-used-from-scratch",
                "content": "## Explanation\\n```\\n    Assume a = 2, b = 1, c = 2\\n\\nNow we have to find out if it\\'s possible to make a triangle using a,b,c.\\n\\nIF \\'EVERY\\' TWO SIDE\\'S SUMMATION FROM (a,b,c) > THIRD SIDE, THEN IT\\'S POSSIBLE\\n\\na + b > c          a + c > b           b + c > a\\n2 + 1 > 2          2 + 2 > 1           1 + 2 > 2\\n3 > 2              4 > 1               3 > 2\\n\\nDoesn\\'t matter which 2 side we pick, it\\'s summation always strictly larger than\\nthe third side. BUT IF ANY TWO SIDE\\'S SUMMATION WAS NOT LARGER THAN THE THIRD\\nSIDE, THEN THE TRIANGLE IS NOT POSSIBLE!\\n\\nAssume a = 1, b = 1, c = 2\\n\\na + c > b       b + c > a       BUT   a + b > c ?\\n1 + 2 > 1       1 + 2 > 1             1 + 1 > 2 ? \\n                                      FALSEEEEEE\\n\\nHence, with a = 1, b = 1, c = 2 making triangle is not possible!\\n\\nSo first we have to find if there is one single variation ( from a+b>c, \\na+c>b, b+c>a) is FALSE or not.\\n\\nLook the last example where if a and b both 1 but c = 2, means if  we sum c with\\neither a or b then it will be always larger than the third side because \\nTHE VALUE OF C IS LARGER THAN A AND B, SO IT\\'S ALREADY LARGER AND IF WE SUM IT \\nWITH A OR B THEN IT WILL BE MORE LARGER THAN THE THIRD SIDE (A/B).\\nSO WE WILL DO SUM OF THE FIRST TWO SMALL VALUES, IF THEIR SUM > THIRD SIDE, \\nTHEN WE CAN CLEARLY SAY THE OTHER TWO VARIATIONS (a+c>b & b+c>a) IS TRUE!\\n\\na, b = first two small values in sorted order and c = equal or larger than b\\n\\nAssume a, b, c = 1, 2, 2 (in sorted order)\\nsince a + b > c then no need to check for a + c > b   &   b + c > a\\n      1 + 2 > 2                           1 + 2 > 2       2 + 2 > 1\\n      3 > 2\\n\\nalso say a, b, c = 1, 1, 1\\n                   a + b > c so also a + c > b    b + c > a\\n                   1 + 1 > 1         1 + 1 > 1    1 + 1 > 1\\n                   2 > 1\\n    \\nSo the key point is for every three value (a,b,c) we need to check ONLY \\nTHE FIRST 2 SMALL VALUES I.E. if a+b>c then we will compare the summation \\nof those a,b,c with the rest.. \" ONLY THE FIRST 2 SMALL VALUES \"\\nSO THAT MEANS WE NEED TO SORT THE list/vector FIRST! Then for each index \\n(except the last 2) just check if nums[i] + nums[i+1] > nums[i+2]...\\n```\\nThere is 3 type variation I showed, so in order to check JUST ONE, we need to\\nsort it first.\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(begin(nums),end(nums));\\n        int sum = 0, size = nums.size()-2, a, b, c;\\n        for(int i=0; i<size; i++)\\n        {\\n            a = nums[i], b = nums[i+1], c = nums[i+2];\\n            if(a+b>c)\\n                sum = max(a+b+c, sum);\\n        }\\n        return sum;\\n    }\\n}; \\n```\\n```Python []\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max( sum(nums[i:i+3]) if nums[i]+nums[i+1] > nums[i+2] else 0 for i in range(len(nums)-2) )\\n```\\n```\\nTime complexity  : O(sort)\\nSpace complexity : O(sort)\\n\\nO(sort) as the sort function is hybrid sort, so it depends which sorting \\ntechnique is being used in the sort function. \\n```\\n## If any of the information was wrong please leave a comment with correctness. If the post was helpful an upvote will really make me happy:)\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n    Assume a = 2, b = 1, c = 2\\n\\nNow we have to find out if it\\'s possible to make a triangle using a,b,c.\\n\\nIF \\'EVERY\\' TWO SIDE\\'S SUMMATION FROM (a,b,c) > THIRD SIDE, THEN IT\\'S POSSIBLE\\n\\na + b > c          a + c > b           b + c > a\\n2 + 1 > 2          2 + 2 > 1           1 + 2 > 2\\n3 > 2              4 > 1               3 > 2\\n\\nDoesn\\'t matter which 2 side we pick, it\\'s summation always strictly larger than\\nthe third side. BUT IF ANY TWO SIDE\\'S SUMMATION WAS NOT LARGER THAN THE THIRD\\nSIDE, THEN THE TRIANGLE IS NOT POSSIBLE!\\n\\nAssume a = 1, b = 1, c = 2\\n\\na + c > b       b + c > a       BUT   a + b > c ?\\n1 + 2 > 1       1 + 2 > 1             1 + 1 > 2 ? \\n                                      FALSEEEEEE\\n\\nHence, with a = 1, b = 1, c = 2 making triangle is not possible!\\n\\nSo first we have to find if there is one single variation ( from a+b>c, \\na+c>b, b+c>a) is FALSE or not.\\n\\nLook the last example where if a and b both 1 but c = 2, means if  we sum c with\\neither a or b then it will be always larger than the third side because \\nTHE VALUE OF C IS LARGER THAN A AND B, SO IT\\'S ALREADY LARGER AND IF WE SUM IT \\nWITH A OR B THEN IT WILL BE MORE LARGER THAN THE THIRD SIDE (A/B).\\nSO WE WILL DO SUM OF THE FIRST TWO SMALL VALUES, IF THEIR SUM > THIRD SIDE, \\nTHEN WE CAN CLEARLY SAY THE OTHER TWO VARIATIONS (a+c>b & b+c>a) IS TRUE!\\n\\na, b = first two small values in sorted order and c = equal or larger than b\\n\\nAssume a, b, c = 1, 2, 2 (in sorted order)\\nsince a + b > c then no need to check for a + c > b   &   b + c > a\\n      1 + 2 > 2                           1 + 2 > 2       2 + 2 > 1\\n      3 > 2\\n\\nalso say a, b, c = 1, 1, 1\\n                   a + b > c so also a + c > b    b + c > a\\n                   1 + 1 > 1         1 + 1 > 1    1 + 1 > 1\\n                   2 > 1\\n    \\nSo the key point is for every three value (a,b,c) we need to check ONLY \\nTHE FIRST 2 SMALL VALUES I.E. if a+b>c then we will compare the summation \\nof those a,b,c with the rest.. \" ONLY THE FIRST 2 SMALL VALUES \"\\nSO THAT MEANS WE NEED TO SORT THE list/vector FIRST! Then for each index \\n(except the last 2) just check if nums[i] + nums[i+1] > nums[i+2]...\\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(begin(nums),end(nums));\\n        int sum = 0, size = nums.size()-2, a, b, c;\\n        for(int i=0; i<size; i++)\\n        {\\n            a = nums[i], b = nums[i+1], c = nums[i+2];\\n            if(a+b>c)\\n                sum = max(a+b+c, sum);\\n        }\\n        return sum;\\n    }\\n}; \\n```\n```Python []\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max( sum(nums[i:i+3]) if nums[i]+nums[i+1] > nums[i+2] else 0 for i in range(len(nums)-2) )\\n```\n```\\nTime complexity  : O(sort)\\nSpace complexity : O(sort)\\n\\nO(sort) as the sort function is hybrid sort, so it depends which sorting \\ntechnique is being used in the sort function. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105410,
                "title": "a-easy-python-solution",
                "content": "The below code is a class Solution that defines a method largestPerimeter which takes in an input array A representing the lengths of the sides of a triangle.\\n\\nThe first line of the function sorts the input array in descending order using the sort() method with the reverse=True argument. This is done so that the largest side of the triangle will be at the first index of the array after sorting.\\n\\nThen the function uses a for loop to iterate through the sorted array starting from the first index to the second last index, which is represented by the range (len(A)-2).\\n\\nThe loop assigns the first element of the array to the variable a, the second element to the variable b, and the third element to the variable c at each iteration.\\n\\nThen it checks if the variable a is less than the sum of b and c using an if statement. If this condition is true, it means that the sides b and c are longer than the side a and therefore can form a triangle. In this case, the function returns the sum of the three sides a, b, and c as the largest perimeter.\\n\\nIf the if statement is not true, the loop continues iterating through the array until it finds a combination of sides that can form a triangle or until it reaches the end of the array.\\n\\nIf the loop ends and no combination of sides that can form a triangle is found, the function returns 0 as the answer.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def largestPerimeter(self, A):\\n        A.sort(reverse=True)\\n\\n        for i in range(len(A)-2):\\n            a = A[i]\\n            b= A[i+1]\\n            c = A[i+2]\\n            if a< b+ c:\\n                return a+b+c\\n            \\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestPerimeter(self, A):\\n        A.sort(reverse=True)\\n\\n        for i in range(len(A)-2):\\n            a = A[i]\\n            b= A[i+1]\\n            c = A[i+2]\\n            if a< b+ c:\\n                return a+b+c\\n            \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944456,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        for(int i=0; i<nums.size()-2; i++) {\\n            if(nums[i] >= nums[i+1] + nums[i+2]) continue;\\n            return nums[i] + nums[i+1] + nums[i+2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        for(int i=0; i<nums.size()-2; i++) {\\n            if(nums[i] >= nums[i+1] + nums[i+2]) continue;\\n            return nums[i] + nums[i+1] + nums[i+2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695066,
                "title": "easy-java-solution-straight-forward-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = n-3; i >= 0; i --){\\n            if(nums[i] + nums[i+1] > nums[i+2]){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }   \\n        }\\n        return 0;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = n-3; i >= 0; i --){\\n            if(nums[i] + nums[i+1] > nums[i+2]){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }   \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694194,
                "title": "c-easy-solution-o-n-log-n",
                "content": "# Approach\\nSTEP-1: Sort the vector\\nSTEP-2: Traverse the vector from last elements, check if last 3 elements can for a triangle, if true return sum of elements.\\n\\n# Complexity\\n- Time complexity: O(n log(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& n) {\\n        sort(n.begin(), n.end());\\n\\n        for(int i = n.size()-3; i >= 0; i--)\\n        {\\n            if(n[i] + n[i+1] > n[i+2])\\n            {\\n                return n[i] + n[i+1] + n[i+2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& n) {\\n        sort(n.begin(), n.end());\\n\\n        for(int i = n.size()-3; i >= 0; i--)\\n        {\\n            if(n[i] + n[i+1] > n[i+2])\\n            {\\n                return n[i] + n[i+1] + n[i+2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694029,
                "title": "c-simple-sort-try-big-and-a-b-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1] > nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1] > nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693225,
                "title": "6-lines",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            a,b,c=nums[i],nums[i+1],nums[i+2]\\n            if( not (a+b<=c or b+c<=a or c+a<=b)):\\n                return a+b+c\\n        return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            a,b,c=nums[i],nums[i+1],nums[i+2]\\n            if( not (a+b<=c or b+c<=a or c+a<=b)):\\n                return a+b+c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693009,
                "title": "python-c-java-faster-than-99-57-simple-short-solution-easy-to-understand",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q976. Largest Perimeter Triangle***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>1;i--)\\n        \\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;       \\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                sum=max(sum,nums[i]+nums[i+1]+nums[i+2]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>1;i--)\\n        \\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;       \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                sum=max(sum,nums[i]+nums[i+1]+nums[i+2]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692688,
                "title": "js-with-explanation-easy-to-understand-simple",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/largest-perimeter-triangle.html\\nIt is very useful, and I just wanted to share it with you. \\nYou can bookmark it as a resource \\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n      const N = nums.length - 2;\\n      for (let i = 0; i < N; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];\\n      }\\n      return 0;\\n};\\n```\\n\\n```\\nRuntime: 191 ms, faster than 13.37% of JavaScript online submissions for Largest Perimeter Triangle.\\nMemory Usage: 45.3 MB, less than 75.97% of JavaScript online submissions for Largest Perimeter Triangle.\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n      const N = nums.length - 2;\\n      for (let i = 0; i < N; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];\\n      }\\n      return 0;\\n};\\n```\n```\\nRuntime: 191 ms, faster than 13.37% of JavaScript online submissions for Largest Perimeter Triangle.\\nMemory Usage: 45.3 MB, less than 75.97% of JavaScript online submissions for Largest Perimeter Triangle.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692403,
                "title": "explained-java-solutions",
                "content": "**upvote if it helped**\\nask any query if u got\\n**--------------from naive to best solution---------------------------------**\\n\\n**Naive approach**\\n\\n* check for all combinations of 3 elements, whether it forms a triangle or not, and update the maximum perimeter if it forms a triangle. The complexity of the naive solution is O(n3). Below is the code for it. *\\n\\n**------------------------------------------------------------------------------------------CODE------------------------------------------------------------------------------------**\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        if(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        int n = nums.length;\\n        int max = 0;\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            for (int j = i + 1; j < n - 1; j++)\\n            {\\n                for (int k = j + 1; k < n; k++)\\n                {\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    int c = nums[k];\\n                    if (a < b+c && b < c+a && c < a+b)\\n                        max = Math.max(max, a+b+c);\\n                }\\n            }\\n        }\\n        if(max>0)\\n            return max;\\n        return 0;\\n    }\\n}\\n```\\n\\n**Approach for the efficient solution**\\n\\n*First, we can sort the array in non-increasing order. So, the first element will be the maximum and the last will be the minimum. Now if the first 3 elements of this sorted array form a triangle, then it will be the maximum perimeter triangle, as for all other combinations the sum of elements(i.e. the perimeter of that triangle) will be = b >= c). a, b,c can not form a triangle, so a >= b + c. As, b and c = c+d (if we drop b and take d) or a >= b+d (if we drop c and take d). So, we have to drop a and pick up d. \\n\\nAgain, the same set of analysis for b, c, and d. We can continue this till end and whenever we find a triangle forming a triple, then we can stop checking, as this triple gives a maximum perimeter. \\n\\nHence, if arr[i] < arr[i+1] + arr[i+2] (0 <= i <= n-3)in the sorted array, then arr[i], arr[i+1] and arr[i+2] form a triangle. *\\n\\n**------------------------------------------------------------------------------------------CODE------------------------------------------------------------------------------------**\\n\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\tif(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for(int i=nums.length-1;i>=2;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                max = Math.max(max, nums[i]+nums[i-1]+nums[i-2]);\\n                break;\\n            }\\n        }\\n        if(max>0)\\n            return max;\\n        return 0;\\n    }\\n}\\n```\\n\\nTime complexity: O(n*log(n)). This much time is required to sort the array.\\nSpace complexity: O(1) since constant space is used.\\n\\n**Even better solution(1ms solution)**\\n*Without explicit sorting, we can do it this way too*\\n\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        //if array has only 3 elements\\n        if(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        //for more than 3 elements, without doing explicit sorting\\n        int n = nums.length;\\n        //here we are putting max element at last index\\n        swapToGetMax(nums, n-1);\\n        //here we are putting max element at second last index\\n        swapToGetMax(nums, n-2);\\n        //here we are putting max element at third last index\\n        swapToGetMax(nums, n-3);\\n        //in loop checking if nums[i]<nums[i-1]+nums[i-2] which this triplet will form the max perimeter\\n        for(int i=n-1;i>=2;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n            //if not then will find max element as (i-3)th largest element\\n            else if(i>2)\\n                swapToGetMax(nums, i-3);\\n        }\\n        return 0;\\n    }\\n    \\n    //utility method to get max element at given index\\n    private void swapToGetMax(int[] nums, int index){\\n        int max=0, maxIndex=-1;\\n        for(int i=0;i<=index;i++)\\n            if(max<nums[i]){\\n                max=nums[i];\\n                maxIndex=i;\\n            }\\n        //actual awapping after finding max element in given range\\n        int temp = nums[index];\\n        nums[index] = max;\\n        nums[maxIndex] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        if(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        int n = nums.length;\\n        int max = 0;\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            for (int j = i + 1; j < n - 1; j++)\\n            {\\n                for (int k = j + 1; k < n; k++)\\n                {\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    int c = nums[k];\\n                    if (a < b+c && b < c+a && c < a+b)\\n                        max = Math.max(max, a+b+c);\\n                }\\n            }\\n        }\\n        if(max>0)\\n            return max;\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\tif(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for(int i=nums.length-1;i>=2;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                max = Math.max(max, nums[i]+nums[i-1]+nums[i-2]);\\n                break;\\n            }\\n        }\\n        if(max>0)\\n            return max;\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        //if array has only 3 elements\\n        if(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        //for more than 3 elements, without doing explicit sorting\\n        int n = nums.length;\\n        //here we are putting max element at last index\\n        swapToGetMax(nums, n-1);\\n        //here we are putting max element at second last index\\n        swapToGetMax(nums, n-2);\\n        //here we are putting max element at third last index\\n        swapToGetMax(nums, n-3);\\n        //in loop checking if nums[i]<nums[i-1]+nums[i-2] which this triplet will form the max perimeter\\n        for(int i=n-1;i>=2;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n            //if not then will find max element as (i-3)th largest element\\n            else if(i>2)\\n                swapToGetMax(nums, i-3);\\n        }\\n        return 0;\\n    }\\n    \\n    //utility method to get max element at given index\\n    private void swapToGetMax(int[] nums, int index){\\n        int max=0, maxIndex=-1;\\n        for(int i=0;i<=index;i++)\\n            if(max<nums[i]){\\n                max=nums[i];\\n                maxIndex=i;\\n            }\\n        //actual awapping after finding max element in given range\\n        int temp = nums[index];\\n        nums[index] = max;\\n        nums[maxIndex] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692401,
                "title": "ruby-1-liner",
                "content": "```ruby\\ndef largest_perimeter(nums)\\n    nums.sort!.reverse.each_cons(3) { |a, b, c| return a + b + c if a < b + c } && 0\\nend\\n```\\n<hr>\\n\\n# Tests:\\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_largest_perimeter < Test::Unit::TestCase\\n    def test_\\n        assert_equal 5, largest_perimeter([2,1,2])\\n        assert_equal 0, largest_perimeter([1,2,1])\\n    end\\nend\\n```\\n\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef largest_perimeter(nums)\\n    nums.sort!.reverse.each_cons(3) { |a, b, c| return a + b + c if a < b + c } && 0\\nend\\n```\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_largest_perimeter < Test::Unit::TestCase\\n    def test_\\n        assert_equal 5, largest_perimeter([2,1,2])\\n        assert_equal 0, largest_perimeter([1,2,1])\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295098,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        // declare variables\\n        int n = nums.size();\\n        int prev = n-3; // the smallest side of the triangle\\n        int next = n-2; // the second largest side of the triangle\\n        int last = n-1; // the largest side of the triangle\\n        \\n        sort(nums.begin(), nums.end()); // sorting an array\\n        \\n        while(nums[prev] + nums[next] <= nums[last]) { // The triangle inequality must be satisfied\\n            last--;\\n            next--;\\n            prev--;\\n            if(prev < 0) return 0; // if no such triple is found, return 0 as given in the condition\\n        }\\n        return nums[prev]+nums[next]+nums[last]; // return the perimeter\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        // declare variables\\n        int n = nums.size();\\n        int prev = n-3; // the smallest side of the triangle\\n        int next = n-2; // the second largest side of the triangle\\n        int last = n-1; // the largest side of the triangle\\n        \\n        sort(nums.begin(), nums.end()); // sorting an array\\n        \\n        while(nums[prev] + nums[next] <= nums[last]) { // The triangle inequality must be satisfied\\n            last--;\\n            next--;\\n            prev--;\\n            if(prev < 0) return 0; // if no such triple is found, return 0 as given in the condition\\n        }\\n        return nums[prev]+nums[next]+nums[last]; // return the perimeter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287707,
                "title": "swift-solution-with-explanation",
                "content": "```\\n/* The only geometory you need to know to solve this problem is that a \\'non-zero \\narea triangle\\' is any triangle where c < a + b.  If you take any one side of a \\ntriangle (C) and it\\'s less than the sum of the other two, (A + B) and then do the same\\nfor all sides, and if they\\'re all true, than it is a valid (non zero area) triangle.  \\nHowever, if you start with the highest Int in a set of 3 sides you don\\'t need to \\ntest all 3 sides. If the highest Int of the 3 sides is less than the sum of the other \\n2 than we can conclude that the triangle is non-zero area triangle.\\n*/\\n\\nclass Solution {\\n    \\n    func largestPerimeter(_ nums: [Int]) -> Int {\\n        \\n        // Sort array of ints in descending order\\n        let x = nums.sorted(by: >)\\n        \\n        /* Loop through the sorted array in chunks of 3 Ints checking if the \\n\\t\\tfirst (highest) Int is less than the sum of the second and third,  until \\n\\t\\tyou reach the end. At each iteration the largest int will always be at \\n\\t\\tthe front therefore if it is a non-zero triangle all other sides will also \\n\\t\\tresult in a non-zero solution in which case you can just reutrn the \\n\\t\\tsum of all sides for the highest perimeter triangle.\\n\\t\\t*/\\n        for (i, _) in x.enumerated() where i <= x.count - 3 {\\n            if x[i] < x[i + 1] + x[i + 2] {\\n                return x[i] + x[i + 1] + x[i + 2]\\n            }\\n        }\\n        // If we exit the loop without finding any non-zero solutions we return 0\\n        return 0\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/* The only geometory you need to know to solve this problem is that a \\'non-zero \\narea triangle\\' is any triangle where c < a + b.  If you take any one side of a \\ntriangle (C) and it\\'s less than the sum of the other two, (A + B) and then do the same\\nfor all sides, and if they\\'re all true, than it is a valid (non zero area) triangle.  \\nHowever, if you start with the highest Int in a set of 3 sides you don\\'t need to \\ntest all 3 sides. If the highest Int of the 3 sides is less than the sum of the other \\n2 than we can conclude that the triangle is non-zero area triangle.\\n*/\\n\\nclass Solution {\\n    \\n    func largestPerimeter(_ nums: [Int]) -> Int {\\n        \\n        // Sort array of ints in descending order\\n        let x = nums.sorted(by: >)\\n        \\n        /* Loop through the sorted array in chunks of 3 Ints checking if the \\n\\t\\tfirst (highest) Int is less than the sum of the second and third,  until \\n\\t\\tyou reach the end. At each iteration the largest int will always be at \\n\\t\\tthe front therefore if it is a non-zero triangle all other sides will also \\n\\t\\tresult in a non-zero solution in which case you can just reutrn the \\n\\t\\tsum of all sides for the highest perimeter triangle.\\n\\t\\t*/\\n        for (i, _) in x.enumerated() where i <= x.count - 3 {\\n            if x[i] < x[i + 1] + x[i + 2] {\\n                return x[i] + x[i + 1] + x[i + 2]\\n            }\\n        }\\n        // If we exit the loop without finding any non-zero solutions we return 0\\n        return 0\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243859,
                "title": "sort-then-o-1-space",
                "content": "```\\nfunc largestPerimeter(nums []int) int {\\n    if len(nums) < 3 { return 0 }\\n    \\n    sort.Ints(nums)\\n    \\n    right := len(nums)-1\\n    \\n    for right >= 2 {\\n        if nums[right-2] > nums[right-1]-nums[right] && nums[right-2] > nums[right]-nums[right-1] {\\n            return nums[right-2]+nums[right-1]+nums[right]\\n        }\\n        \\n        right--\\n    }\\n        \\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```\\nfunc largestPerimeter(nums []int) int {\\n    if len(nums) < 3 { return 0 }\\n    \\n    sort.Ints(nums)\\n    \\n    right := len(nums)-1\\n    \\n    for right >= 2 {\\n        if nums[right-2] > nums[right-1]-nums[right] && nums[right-2] > nums[right]-nums[right-1] {\\n            return nums[right-2]+nums[right-1]+nums[right]\\n        }\\n        \\n        right--\\n    }\\n        \\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2220814,
                "title": "python3-simple-naive-approach",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n        for i in range(len(A) - 2):\\n            if A[i] < A[i+1] + A[i+2]:\\n                return A[i] + A[i+1] + A[i+2]\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n        for i in range(len(A) - 2):\\n            if A[i] < A[i+1] + A[i+2]:\\n                return A[i] + A[i+1] + A[i+2]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136139,
                "title": "python-easy-and-simple-solution",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        #sum of two side should always be greater than third side\\n        nums.sort()\\n        nums.reverse()\\n        for i in range(len(nums)-2):\\n            base,side1,side2 = nums[i],nums[i+1],nums[i+2] \\n            if side1+side2>base:\\n                return side1+side2+base\\n        return 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        #sum of two side should always be greater than third side\\n        nums.sort()\\n        nums.reverse()\\n        for i in range(len(nums)-2):\\n            base,side1,side2 = nums[i],nums[i+1],nums[i+2] \\n            if side1+side2>base:\\n                return side1+side2+base\\n        return 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887575,
                "title": "c-easy-approach-with-explanation",
                "content": "##### Hola Coders!!\\n\\nThere is a property of triangle where **if two sides is greater then the third side** ***we can get the larget perimeter triangle***, to getting the lagest triangle we sort the array and start from the right most corner that is largest element in the array. Using this logic we first run the loop from **length of vector -1** to the **third element** *(after third element triangle not possible)*, we keep on decreasing loop value by **1**, use three variables to store values from the vetor to compare, *if we found the right combination* we return the value, if not then we *continue iteration till the end,* after completing iteration of the loop we simply **return 0**.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n            if(a+b>c)\\n            {\\n                return a+b+c;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```\\nWe can further optimize it by not storing values in the variables and can directly compare the values to the array in the if condition that way we can optimize the space. \\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n           \\n            if(nums[i-2]+nums[i-1]>nums[i])\\n            {\\n                return nums[i-2]+nums[i-1]+nums[i];\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n            if(a+b>c)\\n            {\\n                return a+b+c;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n           \\n            if(nums[i-2]+nums[i-1]>nums[i])\\n            {\\n                return nums[i-2]+nums[i-1]+nums[i];\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827946,
                "title": "python-o-nlog-n",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)-1, 1, -1):\\n            a, b, c = nums[i-2], nums[i-1], nums[i]\\n            if (c < a + b):\\n                return a + b + c\\n        return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)-1, 1, -1):\\n            a, b, c = nums[i-2], nums[i-1], nums[i]\\n            if (c < a + b):\\n                return a + b + c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817714,
                "title": "java-solution-6-ms-faster-than-99-40-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] a) {\\n        Arrays.sort(a);\\n        for(int i=a.length - 1; i>1; i--){\\n             if(a[i] < (a[i-1] + a[i- 2])){\\n                  return (a[i]+a[i - 1]+ a[i - 2]);\\n             }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] a) {\\n        Arrays.sort(a);\\n        for(int i=a.length - 1; i>1; i--){\\n             if(a[i] < (a[i-1] + a[i- 2])){\\n                  return (a[i]+a[i - 1]+ a[i - 2]);\\n             }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700134,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        //select largest three that can form a triangle\\n        sort(nums.begin(),nums.end());\\n        //triangle property -> sum of smaller two > largest\\n        // first valid triplet from end will give maximum perimeter\\n        //other can not give maximum answer\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n            if(a+b>c) return a+b+c;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        //select largest three that can form a triangle\\n        sort(nums.begin(),nums.end());\\n        //triangle property -> sum of smaller two > largest\\n        // first valid triplet from end will give maximum perimeter\\n        //other can not give maximum answer\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n            if(a+b>c) return a+b+c;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489431,
                "title": "easy-sorting-c",
                "content": "Upvote will be highly appreciated\\n\\nclass Solution {\\npublic:\\n\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.rbegin(),nums.rend());\\n        \\n        \\n        for(int i = 0; i<nums.size()-2; i++){\\n            if(nums[i]<nums[i+1]+nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.rbegin(),nums.rend());\\n        \\n        \\n        for(int i = 0; i<nums.size()-2; i++){\\n            if(nums[i]<nums[i+1]+nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3274884,
                "title": "c-easy-sort-iterate",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n3 given sides A, B & Cform a triange iff -->>\\n**A + B > C**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort (nums.begin(), nums.end()) ; \\n\\n        for (int i = nums.size() - 3 ; i >= 0 ; i --)\\n        {\\n            if (nums[i] + nums[i + 1] > nums[i + 2])\\n            {\\n                return nums[i] + nums[i + 1] + nums[i + 2] ; \\n            }\\n        }\\n        return 0 ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/2150dec5-333c-46a4-bfc8-06195ebcc357_1678340224.2938855.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort (nums.begin(), nums.end()) ; \\n\\n        for (int i = nums.size() - 3 ; i >= 0 ; i --)\\n        {\\n            if (nums[i] + nums[i + 1] > nums[i + 2])\\n            {\\n                return nums[i] + nums[i + 1] + nums[i + 2] ; \\n            }\\n        }\\n        return 0 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265892,
                "title": "java-easy-and-explained-solution-speed-beats-99-7",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the array** after **sorting** it with  with `Arrays.sort()`. \\n\\n*At each iteration* we have to compare the three greater values:\\n1) If **is a triangle**, return  the perimeter. This happen if *the sum of two sides is larger than the last side*;\\n2) If **is not a triangle**, start the next iteration looking at the values at position `i--`;\\n\\n**Note:** In Java, we have **different ways to sort an array**, usually the best are `Arrays.sort()` and `Collection.sort()`. When we are working with primitive datatypes like int, `Arrays.sort()` proves to be way more time efficient than `Collections.sort()`\\n \\n**Arrays.sort():** make the sort inside the array.\\n**Collections.sort():** is used mainly to sort list, this means that it make more steps to do the same opeartion.\\n\\n# Complexity\\n- **Time complexity:** $O(n*log(n))$\\n- **Speed Beats:** 99.7%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i-1] + nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i-1] + nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924186,
                "title": "java-easy-solution",
                "content": "java, simple triangle property\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--){\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                return nums[i-1]+nums[i-2]+nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--){\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                return nums[i-1]+nums[i-2]+nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704786,
                "title": "java-72-15-faster-o-nlogn-beginner-friendly-with-comments",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);   \\n        int max=0;\\n        for(int i=0;i<=nums.length-3;i++){\\n            int a = nums[i];     \\n            int b = nums[i+1];\\n            int c = nums[i+2]; \\n            if((a+b)>c){        \\n                        int temp = a+b+c;\\n                        if(max<temp){\\n                            max = temp;      \\n                }\\n            }else{\\n             continue;   \\n            }\\n        }\\n        return max;       \\n    }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);   \\n        int max=0;\\n        for(int i=0;i<=nums.length-3;i++){\\n            int a = nums[i];     \\n            int b = nums[i+1];\\n            int c = nums[i+2]; \\n            if((a+b)>c){        \\n                        int temp = a+b+c;\\n                        if(max<temp){\\n                            max = temp;      \\n                }\\n            }else{\\n             continue;   \\n            }\\n        }\\n        return max;       \\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699306,
                "title": "true-o-n-in-c-better-than-o-n-log-n",
                "content": "By definition the Fibonacci sequence is an integer sequence that has no triplets making up a triangle of a non-zero area (triangle-triplets), as each number is the sum of the two preceding numbers:\\n\\n```\\n1 1 2 3 5 8 13 ...\\n```\\n\\nFor a given length `n`, among all sorted sequences of natural numbers with no triangle-triplets, the Fibonacci sequence is the sequence with the smallest number `a[i]` for `0 <= i < n`. In other words, it\\'s the lexicographically smallest sequence of numbers without triangle-triplets.\\n\\nKnowing the maximum possible number `x` in the array (1\\'000\\'000 for this problem), we can find the length `K` of the longest sequence that has no triangle-triplets using the next formula (or alternatively with the familiar Fibonacci number iterative algorithm):\\n\\n```\\nK = ceil(log(x * sqrt(5) - .5) / log(1.618))\\n```\\n\\nIf a sequence of numbers with a maximum element `x` has more than `K` elements, then it   contains triangle-triplets.\\n\\nNow I state that if there are no triangle-triplets in the top-K elements of an array of numbers, then there are no triangle-triplets in the whole array. To find the largest perimeter triangle we only need to consider the top-K elements of the array of numbers.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n    https://leetcode.com/qyryq/\\n        int k = min(invfib(1\\'000\\'000), nums.size());\\n        priority_queue<int, vector<int>, greater<>> q;\\n        for (auto n : nums)\\n            if (q.size() < k || n >= q.top()) {\\n                q.push(n);\\n                if (q.size() > k) q.pop();\\n            }\\n        vector<int> v;\\n        for (; !q.empty(); q.pop())\\n            v.emplace_back(q.top());\\n        for (size_t i = k-3; i < k; i--)\\n            if (v[i]+v[i+1] > v[i+2])\\n                return v[i]+v[i+1]+v[i+2];\\n        return 0;\\n    }\\nprivate:\\n    size_t invfib(size_t x) const {\\n        // https://stackoverflow.com/a/5162856/\\n        // https://en.wikipedia.org/wiki/Fibonacci_number#Relation_to_the_golden_ratio\\n        return ceil(log(x * sqrt(5) - .5) / log(1.618));\\n    }\\n};\\n```\\n\\nThe complexity of the algorithm is O(N * log( invfib(M) )), where N is the length of the `nums` vector and M is the maximum possible number in the vector. As M is fixed in this problem, we may consider the complexity of this algorithm to be O(N).\\n\\nOn large arrays the next approach is almost twice as fast as the priority queue one:\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n    https://leetcode.com/qyryq/\\n        const size_t k = 32ul;\\n        size_t imin = 0;\\n        vector<int> q(k, 0);\\n        for (const auto& n : nums)\\n            if (n > q[imin]) {\\n                q[imin] = n;\\n                imin = distance(begin(q), min_element(begin(q), end(q)));\\n            }\\n        sort(begin(q), end(q), greater{});\\n        for (size_t i = 0; i < k-2; i++)\\n            if (q[i] < q[i+1] + q[i+2])\\n                return q[i]+q[i+1]+q[i+2];\\n        return 0;\\n    }\\n};\\n```\\n\\nHere I use `32ul` constant instead of calling `invfib` function, but it\\'s not what makes the code faster. What does make it faster is the simplified loop body, that finds the smallest element in the `q` vector that holds the top-K elements. Asymptotically it should take more time that the priority queue approach, but I suppose the streamlined code is more \"comfortable\" for the modern CPU architecture to execute.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n1 1 2 3 5 8 13 ...\\n```\n```\\nK = ceil(log(x * sqrt(5) - .5) / log(1.618))\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n    https://leetcode.com/qyryq/\\n        int k = min(invfib(1\\'000\\'000), nums.size());\\n        priority_queue<int, vector<int>, greater<>> q;\\n        for (auto n : nums)\\n            if (q.size() < k || n >= q.top()) {\\n                q.push(n);\\n                if (q.size() > k) q.pop();\\n            }\\n        vector<int> v;\\n        for (; !q.empty(); q.pop())\\n            v.emplace_back(q.top());\\n        for (size_t i = k-3; i < k; i--)\\n            if (v[i]+v[i+1] > v[i+2])\\n                return v[i]+v[i+1]+v[i+2];\\n        return 0;\\n    }\\nprivate:\\n    size_t invfib(size_t x) const {\\n        // https://stackoverflow.com/a/5162856/\\n        // https://en.wikipedia.org/wiki/Fibonacci_number#Relation_to_the_golden_ratio\\n        return ceil(log(x * sqrt(5) - .5) / log(1.618));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n    https://leetcode.com/qyryq/\\n        const size_t k = 32ul;\\n        size_t imin = 0;\\n        vector<int> q(k, 0);\\n        for (const auto& n : nums)\\n            if (n > q[imin]) {\\n                q[imin] = n;\\n                imin = distance(begin(q), min_element(begin(q), end(q)));\\n            }\\n        sort(begin(q), end(q), greater{});\\n        for (size_t i = 0; i < k-2; i++)\\n            if (q[i] < q[i+1] + q[i+2])\\n                return q[i]+q[i+1]+q[i+2];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695633,
                "title": "super-average-solution-with-fastest-run-time-java",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0,n=nums.length;i<n-2;i++)\\n            if(nums[n-i-1]<nums[n-i-2]+nums[n-i-3])\\n                return nums[n-i-1]+nums[n-i-2]+nums[n-i-3];\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0,n=nums.length;i<n-2;i++)\\n            if(nums[n-i-1]<nums[n-i-2]+nums[n-i-3])\\n                return nums[n-i-1]+nums[n-i-2]+nums[n-i-3];\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695554,
                "title": "java-simple-solution-in-o-nlogn-with-easy-explanation",
                "content": "triangle sum property is used\\nwhich says side1+side2 > side3 when side3>side2>side1\\n\\nso to get the highest perimeter , we are first sorting the array first to get the maximum elements\\n\\n\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int per=0;// case where triangle will not be formed will be handled by per=0;\\n        for(int i=nums.length-1;i>=2; i--)\\n        {\\n            if(nums[i-1]+nums[i-2]>nums[i])\\n            {\\n                per=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n            \\n        }\\n        return per;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int per=0;// case where triangle will not be formed will be handled by per=0;\\n        for(int i=nums.length-1;i>=2; i--)\\n        {\\n            if(nums[i-1]+nums[i-2]>nums[i])\\n            {\\n                per=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n            \\n        }\\n        return per;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695058,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse=1)\\n        \\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] + nums[i+2]:\\n                return sum(nums[i:i+3])\\n\\t\\t\\t\\t\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse=1)\\n        \\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] + nums[i+2]:\\n                return sum(nums[i:i+3])\\n\\t\\t\\t\\t\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695028,
                "title": "c-using-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n         // for finding largest perimeter we are iterating arry from backwards\\n        for(int i=a.size()-1;i>1;i--)\\n        {\\n            if(a[i-2]+a[i-1]>a[i])\\n            {\\n             return a[i]+a[i-1]+a[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n         // for finding largest perimeter we are iterating arry from backwards\\n        for(int i=a.size()-1;i>1;i--)\\n        {\\n            if(a[i-2]+a[i-1]>a[i])\\n            {\\n             return a[i]+a[i-1]+a[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694351,
                "title": "python-5-liner-91-8-solution-sort",
                "content": "```python\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            if sum(nums[i:i+3])>2*nums[i]:\\n                return sum(nums[i:i+3])\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            if sum(nums[i:i+3])>2*nums[i]:\\n                return sum(nums[i:i+3])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693695,
                "title": "java-easy-solution",
                "content": "Triangle property : sum of any two sides must be greater than the third side.\\nwe have to find out maximum perimter that\\'s why we sorted array and check property of triangle from last 3 elements of array if it\\'s satisfied then return because it would be maximum perimeter.\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 2; i--){\\n            int first = nums[i];\\n            int second = nums[i - 1];\\n            int third = nums[i - 2];\\n            if(second + third > first){\\n                return (second + third + first);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 2; i--){\\n            int first = nums[i];\\n            int second = nums[i - 1];\\n            int third = nums[i - 2];\\n            if(second + third > first){\\n                return (second + third + first);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693690,
                "title": "easiest-runtime-0-ms-faster-than-100-submissions-sorting",
                "content": "```\\nclass Solution {\\n   public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i =n-1; i>=2; i--) {\\n            if(nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n   public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i =n-1; i>=2; i--) {\\n            if(nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693372,
                "title": "93-3-in-runtime-and-91-6-in-space-for-begginers",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        #sort the array iin decreasing order\\n        #TRIANGLE RULE\\n        #sum of two arre greater than third side\\n        nums.sort(reverse=True)\\n        for i in range(3,len(nums)+1):\\n            if nums[i-3]<nums[i-2]+nums[i-1]:\\n                return sum(nums[i-3:i])\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        #sort the array iin decreasing order\\n        #TRIANGLE RULE\\n        #sum of two arre greater than third side\\n        nums.sort(reverse=True)\\n        for i in range(3,len(nums)+1):\\n            if nums[i-3]<nums[i-2]+nums[i-1]:\\n                return sum(nums[i-3:i])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693105,
                "title": "java-simple-and-optimized-solution-3-lines-of-code",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i=nums.length-3; i >= 0; i--)\\n            if (nums[i] + nums[i+1] > nums[i+2])\\n                return nums[i] + nums[i+1] + nums[i+2];\\n        return 0;\\n    }\\n}\\n\\n/*\\nAlternate logic is that you can also use-\\nArrays.sort(nums);\\n        for (int i=nums.length-3; i >= 0; i--)\\n            if (nums[i-1] + nums[i-2] > nums[i])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;*/\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i=nums.length-3; i >= 0; i--)\\n            if (nums[i] + nums[i+1] > nums[i+2])\\n                return nums[i] + nums[i+1] + nums[i+2];\\n        return 0;\\n    }\\n}\\n\\n/*\\nAlternate logic is that you can also use-\\nArrays.sort(nums);\\n        for (int i=nums.length-3; i >= 0; i--)\\n            if (nums[i-1] + nums[i-2] > nums[i])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693092,
                "title": "simple-java-solution-with-explaination",
                "content": "**Logic used -**\\n* perimeter of triangle - summation of sides of triangle (**p = l1 + l2 + l3**)\\n* Triangle property - In order to create a triangle, largest side is always lesser than the summation of other two sides (**l1 < l2 + l3** considering l1 > l2, l3)\\n\\n**Explanation -**\\n\\n1.  we need largest three sides to form a triangle, so better to sort an array.\\n2.  loop from the last element and pick last three element, if they satisfy the triangle property then return it.\\n3.  Otherwise no solution found, return 0 \\n\\n\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int last = nums.length-1;\\n        while(last-1 > 0){\\n            if(nums[last] < nums[last-1] + nums[last-2]) // triangle property => largest size < addition of other two sides\\n                return nums[last] + nums[last-1] + nums[last-2];\\n            last--;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nTC - O(nlogn)\\nSC - O(1)\\n***Please upvote if you understood the solution, comment if you have any doubt.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int last = nums.length-1;\\n        while(last-1 > 0){\\n            if(nums[last] < nums[last-1] + nums[last-2]) // triangle property => largest size < addition of other two sides\\n                return nums[last] + nums[last-1] + nums[last-2];\\n            last--;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692972,
                "title": "c-solution-time-complexity-o-n-log-n-clean-and-concise-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<nums.size()-2;i++)\\n             if(nums[i+2]+nums[i+1]>nums[i])\\n               return nums[i+2]+nums[i+1]+nums[i];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<nums.size()-2;i++)\\n             if(nums[i+2]+nums[i+1]>nums[i])\\n               return nums[i+2]+nums[i+1]+nums[i];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692898,
                "title": "very-basic-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n Arrays.sort(nums);\\n \\n    for(int i=nums.length-1;i>1;i--){\\n        int a = nums[i-2];\\n        int b = nums[i-1];\\n        int c = nums[i];\\n\\t\\t\\n\\t\\t//sum of all the sides\\n\\t\\t\\tint s = a + b + c;\\n        \\n\\t\\t//condition for triangle\\n        if(a+b>c)\\n\\t\\t{\\n            return s;\\n        }\\n    }\\n\\n    return 0;\\n      \\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n Arrays.sort(nums);\\n \\n    for(int i=nums.length-1;i>1;i--){\\n        int a = nums[i-2];\\n        int b = nums[i-1];\\n        int c = nums[i];\\n\\t\\t\\n\\t\\t//sum of all the sides\\n\\t\\t\\tint s = a + b + c;\\n        \\n\\t\\t//condition for triangle\\n        if(a+b>c)\\n\\t\\t{\\n            return s;\\n        }\\n    }\\n\\n    return 0;\\n      \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692711,
                "title": "optimal-solution-c-easy-to-understand-complete-explanation",
                "content": "## Largest Perimeter Triangle - OPTIMAL SOLUTION \\u2705[ C++ ] \\u2705|| EASY TO UNDERSTAND || COMPLETE EXPLANATION\\n\\n***Please upvote if you like it.***\\n\\n### EXPLANATION:\\n![image](https://assets.leetcode.com/users/images/dba3a79b-c5fa-4532-9004-4d4b2dfb880a_1665544668.6957664.png)\\n![image](https://assets.leetcode.com/users/images/f88b382d-b97a-49b9-a2f7-ffc13717c120_1665544727.603764.png)\\n\\n\\n\\n#### Time Complexity : O(NlogN + N)    -------->Sort and traverse array\\n#### Space Complexity : O(logN) ----> While sorting \\n### </>CODE :\\n### \\n```\\n class Solution\\n{\\npublic:\\n    int largestPerimeter(vector<int> &a)\\n    {\\n        sort(a.begin(), a.end(), greater<int>());\\n        for(auto x: a)\\n        {\\n            cout<<x<<\" \";\\n        }\\n\\n        for (int i = 2; i < a.size(); i++)\\n        {\\n            // side 1 = a[i-2] ---> greatest side\\n            // side 2 = a[i-1]\\n            // side 3 = a[i]   \\n\\n            if (a[i-2] < (a[i - 1] + a[i]))\\n            {\\n                return a[i] + a[i - 1] + a[i - 2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n class Solution\\n{\\npublic:\\n    int largestPerimeter(vector<int> &a)\\n    {\\n        sort(a.begin(), a.end(), greater<int>());\\n        for(auto x: a)\\n        {\\n            cout<<x<<\" \";\\n        }\\n\\n        for (int i = 2; i < a.size(); i++)\\n        {\\n            // side 1 = a[i-2] ---> greatest side\\n            // side 2 = a[i-1]\\n            // side 3 = a[i]   \\n\\n            if (a[i-2] < (a[i - 1] + a[i]))\\n            {\\n                return a[i] + a[i - 1] + a[i - 2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2692697,
                "title": "c-99-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();  \\n        for(int i = n-1;i>1;i--)\\n\\t\\t      if(nums[i] < nums[i-1] + nums[i-2]) return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();  \\n        for(int i = n-1;i>1;i--)\\n\\t\\t      if(nums[i] < nums[i-1] + nums[i-2]) return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692533,
                "title": "c-solution-3-lines",
                "content": "**Idea:** We can make a  triangle if we have arr[i+1] + arr[i+2] > arr[i] mean sum of two sides should be greater than third side.\\n```\\n int largestPerimeter(vector<int>& arr) {\\n         sort(arr.rbegin(),arr.rend());\\n         for(int i =0;i<arr.size()-2;i++)\\n             if(arr[i+1] + arr[i+2] > arr[i])return arr[i+1] + arr[i+2] + arr[i];\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int largestPerimeter(vector<int>& arr) {\\n         sort(arr.rbegin(),arr.rend());\\n         for(int i =0;i<arr.size()-2;i++)\\n             if(arr[i+1] + arr[i+2] > arr[i])return arr[i+1] + arr[i+2] + arr[i];\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692328,
                "title": "daily-leetcoding-challenge-october-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-perimeter-triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-perimeter-triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2625238,
                "title": "easiest-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);// Sort the array so as to fetch elements from last\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i-2]+nums[i-1]>nums[i]) //A figure is a triangle if sum of two sides is greater than third  checking for each case\\n                return (nums[i-2]+nums[i-1]+nums[i]);// returnunng the perimeter\\n        }\\n        return 0;// if no side found return 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);// Sort the array so as to fetch elements from last\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i-2]+nums[i-1]>nums[i]) //A figure is a triangle if sum of two sides is greater than third  checking for each case\\n                return (nums[i-2]+nums[i-1]+nums[i]);// returnunng the perimeter\\n        }\\n        return 0;// if no side found return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615371,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i-2]+nums[i-1]>nums[i])\\n                return (nums[i-2]+nums[i-1]+nums[i]);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i-2]+nums[i-1]>nums[i])\\n                return (nums[i-2]+nums[i-1]+nums[i]);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584139,
                "title": "simplest-ruby-solution",
                "content": "Begin by sorting the array, then reversing.\\nThen we can look at one triplet at a time.  If that triplet can form a triangle, then it is the largest.\\n(They can form a triangle if the two shorter sides add to more than the longest side)\\n\\n\\ndef largest_perimeter(nums)\\n    nums = nums.sort.reverse\\n    useLength = nums.length - 3\\n    \\n    for i in 0..useLength do\\n        if nums[i+2] + nums[i+1] > nums[i]\\n            return nums[i+2] + nums[i+1] + nums[i]\\n        end\\n    end\\n    \\n    return 0\\n    \\nend",
                "solutionTags": [
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "Begin by sorting the array, then reversing.\\nThen we can look at one triplet at a time.  If that triplet can form a triangle, then it is the largest.\\n(They can form a triangle if the two shorter sides add to more than the longest side)\\n\\n\\ndef largest_perimeter(nums)\\n    nums = nums.sort.reverse\\n    useLength = nums.length - 3\\n    \\n    for i in 0..useLength do\\n        if nums[i+2] + nums[i+1] > nums[i]\\n            return nums[i+2] + nums[i+1] + nums[i]\\n        end\\n    end\\n    \\n    return 0\\n    \\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2355621,
                "title": "python-short-simple",
                "content": "```\\ndef largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1]+nums[i+2]:\\n                return nums[i] + nums[i+1] + nums[i+2]\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1]+nums[i+2]:\\n                return nums[i] + nums[i+1] + nums[i+2]\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2340977,
                "title": "c-explaination",
                "content": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] nums) {\\n        // triangle = sum of 2 sides must be greater than the 3rd side\\n        // sort the array so that we can look for the max value at the end of it.\\n        // i = nums.Length - 3 => we need minimum 3 values for a triangle & to prevent index out of bound as well\\n        \\n        Array.Sort(nums);\\n        \\n        for(int i = nums.Length - 3; i >= 0; i--) {\\n            if(nums[i] + nums[i + 1] > nums[i + 2])\\n                return (nums[i] + nums[i + 1] + nums[i + 2]);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] nums) {\\n        // triangle = sum of 2 sides must be greater than the 3rd side\\n        // sort the array so that we can look for the max value at the end of it.\\n        // i = nums.Length - 3 => we need minimum 3 values for a triangle & to prevent index out of bound as well\\n        \\n        Array.Sort(nums);\\n        \\n        for(int i = nums.Length - 3; i >= 0; i--) {\\n            if(nums[i] + nums[i + 1] > nums[i + 2])\\n                return (nums[i] + nums[i + 1] + nums[i + 2]);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282650,
                "title": "python-faster-than-92-81-sorting",
                "content": "```\\nclass Solution:       \\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort() \\n        N = len(nums)\\n        res = 0\\n        for i in range(N - 1, 1, -1): \\n            if nums[i-2] + nums[i-1] > nums[i]:\\n                return nums[i-2] + nums[i-1] + nums[i]\\n            \\n        return 0\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:       \\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort() \\n        N = len(nums)\\n        res = 0\\n        for i in range(N - 1, 1, -1): \\n            if nums[i-2] + nums[i-1] > nums[i]:\\n                return nums[i-2] + nums[i-1] + nums[i]\\n            \\n        return 0\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281077,
                "title": "python-greedy-approach-easily-explained",
                "content": "# \\u2714PYTHON\\uD83D\\uDC0DGREEDY APPROACH, EASILY EXPLAINED.\\n\\nWe know `the condition to form a triangle of non-zero area is a + b > c`, meaning sum of two sides > remaing side.\\nSince we have to return the largest perimeter we sort nums in reverse order and take first 3 numbers and check the condition, \\nif true we return the sum of three sides(perimeter of a triangel) else after the loop we retutn 0.\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for a, b, c in zip(nums, nums[1: ], nums[2: ]):\\n            if b+c > a:\\n                return a+b+c\\n        return 0\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for a, b, c in zip(nums, nums[1: ], nums[2: ]):\\n            if b+c > a:\\n                return a+b+c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203376,
                "title": "largest-perimeter-triangle",
                "content": "class Solution {\\n\\n    public int largestPerimeter(int[] nums) {\\n        int end = nums.length - 1;\\n        Arrays.sort(nums);\\n        while(1 < end){\\n            if (nums[end] + nums[end - 1] > nums[end - 2] && nums[end] + nums[end - 2] > nums[end - 1] && nums[end - 1] + nums[end - 2] > nums[end]){\\n                return nums[end] + nums[end - 1] + nums[end - 2];\\n            }\\n            end--;\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int largestPerimeter(int[] nums) {\\n        int end = nums.length - 1;\\n        Arrays.sort(nums);\\n        while(1 < end){\\n            if (nums[end] + nums[end - 1] > nums[end - 2] && nums[end] + nums[end - 2] > nums[end - 1] && nums[end - 1] + nums[end - 2] > nums[end]){\\n                return nums[end] + nums[end - 1] + nums[end - 2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2173861,
                "title": "javascript-solution-typescript-easy-to-understand",
                "content": "```\\nfunction largestPerimeter(nums: number[]): number {\\n    nums.sort((a, b) => b - a);\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] < nums[i+1] + nums[i+2]) {\\n            return nums[i] + nums[i+1] + nums[i+2];\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sorting"
                ],
                "code": "```\\nfunction largestPerimeter(nums: number[]): number {\\n    nums.sort((a, b) => b - a);\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] < nums[i+1] + nums[i+2]) {\\n            return nums[i] + nums[i+1] + nums[i+2];\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2172763,
                "title": "python-simple-python-solution-using-sorting",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\n# Runtime: 212 ms, faster than 81.66% of Python3 online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 15.4 MB, less than 45.46% of Python3 online submissions for Largest Perimeter Triangle.\\n\\tclass Solution:\\n\\t\\tdef largestPerimeter(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tnums = sorted(nums)\\n\\n\\t\\t\\ti = len(nums)-3\\n\\n\\t\\t\\twhile i>-1:\\n\\n\\t\\t\\t\\tif nums[i]+nums[i+1] > nums[i+2]:\\n\\n\\t\\t\\t\\t\\treturn nums[i]+nums[i+1]+nums[i+2]\\n\\n\\t\\t\\t\\ti = i - 1\\n\\n\\t\\t\\treturn 0\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\n# Runtime: 212 ms, faster than 81.66% of Python3 online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 15.4 MB, less than 45.46% of Python3 online submissions for Largest Perimeter Triangle.\\n\\tclass Solution:\\n\\t\\tdef largestPerimeter(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tnums = sorted(nums)\\n\\n\\t\\t\\ti = len(nums)-3\\n\\n\\t\\t\\twhile i>-1:\\n\\n\\t\\t\\t\\tif nums[i]+nums[i+1] > nums[i+2]:\\n\\n\\t\\t\\t\\t\\treturn nums[i]+nums[i+1]+nums[i+2]\\n\\n\\t\\t\\t\\ti = i - 1\\n\\n\\t\\t\\treturn 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 2149681,
                "title": "0ms100-faster-solution-ez-2-line-logic-c",
                "content": "Sort the array in Desc order and check if sum of next 2 elements is greater than the greatest of the 3 !\\n class Solution {\\n \\n public:\\n   \\n    int largestPerimeter(vector<int>& nums) {\\n        \\n\\t\\tsort(nums.begin(),nums.end(),greater<int>());\\n        \\n        for(int i=0;i<nums.size()-2;i++){\\n            \\n            if(nums[i]<nums[i+1]+nums[i+2])\\n                return nums[i] + nums[i+1] + nums[i+2];\\n        }  \\n       \\n     return 0;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n \\n public:\\n   \\n    int largestPerimeter(vector<int>& nums) {\\n        \\n\\t\\tsort(nums.begin(),nums.end(),greater<int>());\\n        \\n        for(int i=0;i<nums.size()-2;i++){\\n            \\n            if(nums[i]<nums[i+1]+nums[i+2])\\n                return nums[i] + nums[i+1] + nums[i+2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1954971,
                "title": "python-solution-with-explanation-about-triangle-properties",
                "content": "```python\\ndef largest_perimeter(nums: list[int]) -> int:\\n  \\'\\'\\'\\n  Per the triangle inequality theorem, for any triangle, including degenerate triangles with zero area:\\n    0 <= a <= b <= c\\n    a + b >= c\\n  Where a, b, and c are the side lengths of the triangle.\\n  Reference: https://en.wikipedia.org/wiki/Degeneracy_(mathematics)#Triangle\\n\\n  But for this problem, we don\\'t need to worry about degenerate triangles.\\n\\n  Therefore, for a triangle with non-zero area, the following expression must hold true:\\n    0 < a <= b <= c\\n    a + b > c\\n  To be clear, the sum of the two shortest sides of the triangle must be greater than the longest side.\\n\\n  Thus, we simply need to sort the list, so that we choose the largest possible a, b, and c that will form a civilized triangle.\\n\\n  Complexity Analysis\\n  Time Complexity: O(n log n), where n is the length of nums.\\n  Space Complexity: O(1).\\n\\n  Runtime: 194 ms, faster than 91.18% of Python3 online submissions for Largest Perimeter Triangle.\\n  Memory Usage: 15.6 MB, less than 9.30% of Python3 online submissions for Largest Perimeter Triangle.\\n  \\'\\'\\'\\n  nums = sorted(nums, reverse=True)\\n  for i in range(len(nums) - 2):\\n    a = nums[i+2]\\n    b = nums[i+1]\\n    c = nums[i]\\n    if a + b > c:\\n      return a + b + c\\n  return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef largest_perimeter(nums: list[int]) -> int:\\n  \\'\\'\\'\\n  Per the triangle inequality theorem, for any triangle, including degenerate triangles with zero area:\\n    0 <= a <= b <= c\\n    a + b >= c\\n  Where a, b, and c are the side lengths of the triangle.\\n  Reference: https://en.wikipedia.org/wiki/Degeneracy_(mathematics)#Triangle\\n\\n  But for this problem, we don\\'t need to worry about degenerate triangles.\\n\\n  Therefore, for a triangle with non-zero area, the following expression must hold true:\\n    0 < a <= b <= c\\n    a + b > c\\n  To be clear, the sum of the two shortest sides of the triangle must be greater than the longest side.\\n\\n  Thus, we simply need to sort the list, so that we choose the largest possible a, b, and c that will form a civilized triangle.\\n\\n  Complexity Analysis\\n  Time Complexity: O(n log n), where n is the length of nums.\\n  Space Complexity: O(1).\\n\\n  Runtime: 194 ms, faster than 91.18% of Python3 online submissions for Largest Perimeter Triangle.\\n  Memory Usage: 15.6 MB, less than 9.30% of Python3 online submissions for Largest Perimeter Triangle.\\n  \\'\\'\\'\\n  nums = sorted(nums, reverse=True)\\n  for i in range(len(nums) - 2):\\n    a = nums[i+2]\\n    b = nums[i+1]\\n    c = nums[i]\\n    if a + b > c:\\n      return a + b + c\\n  return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1891715,
                "title": "sort-function-javascript",
                "content": "*Hope you find help \\uD83E\\uDD17*\\n\\n> *Code:*\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    \\n    let perimeter = 0;\\n    nums.sort((x, y)=>y-x);\\n    \\n    for(let i = 0; i<nums.length-2; i++)\\n        {\\n            if(nums[i]<(nums[i+1] + nums[i+2]))\\n                {\\n                    perimeter = nums[i] + nums[i+1] + nums[i+2];\\n                    break;\\n                }\\n        }\\n    \\n    return perimeter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    \\n    let perimeter = 0;\\n    nums.sort((x, y)=>y-x);\\n    \\n    for(let i = 0; i<nums.length-2; i++)\\n        {\\n            if(nums[i]<(nums[i+1] + nums[i+2]))\\n                {\\n                    perimeter = nums[i] + nums[i+1] + nums[i+2];\\n                    break;\\n                }\\n        }\\n    \\n    return perimeter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874130,
                "title": "python3-circumvent-triangle-side-rule",
                "content": "There are 2 restraints for triangle sides are as follows:\\n> The length of one side of a triangle must be greater than the differnce and less than the sum of the lengths of the other two sides. are 15 and 5. The length of the third side must be greater than 15-5 or 10 and less than 15+5 or 20.\\n\\nNote that as the list is sorted, we only need to check one rule. Depending on the sort, the 3rd side will always be greater than or less than the difference/summation.\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        \\n        for i in range(len(nums) - 2):\\n            s1, s2, s3 = nums[i], nums[i+1], nums[i + 2]\\n            if (s3 > s1 - s2):\\n                return sum((s1, s2, s3))\\n        return 0\\n",
                "solutionTags": [],
                "code": "There are 2 restraints for triangle sides are as follows:\\n> The length of one side of a triangle must be greater than the differnce and less than the sum of the lengths of the other two sides. are 15 and 5. The length of the third side must be greater than 15-5 or 10 and less than 15+5 or 20.\\n\\nNote that as the list is sorted, we only need to check one rule. Depending on the sort, the 3rd side will always be greater than or less than the difference/summation.\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        \\n        for i in range(len(nums) - 2):\\n            s1, s2, s3 = nums[i], nums[i+1], nums[i + 2]\\n            if (s3 > s1 - s2):\\n                return sum((s1, s2, s3))\\n        return 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 1853345,
                "title": "javascript-solution",
                "content": "```\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let i = nums.length - 1;\\n    while(i >= 0){\\n        if (nums[i] < nums[i-1] + nums[i-2]){\\n            return nums[i] + nums[i-1] + nums[i-2];\\n        } else {\\n              i--;\\n        }\\n    }\\n    return 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let i = nums.length - 1;\\n    while(i >= 0){\\n        if (nums[i] < nums[i-1] + nums[i-2]){\\n            return nums[i] + nums[i-1] + nums[i-2];\\n        } else {\\n              i--;\\n        }\\n    }\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1819174,
                "title": "easy-solution-c-4-lines-of-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        }       \\n        return 0;       \\n    }\\n};\\n```\\n\\n**Upvote if it helped :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        }       \\n        return 0;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816267,
                "title": "c-efficient-using-sorting-easy-simple-clean-solution",
                "content": "##### Please upvote if u find it\\'s Helpful :)\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1; i>1; i--){\\n            if(nums[i]>=nums[i-1]+nums[i-2]) continue;\\n            else return nums[i]+nums[i-1]+nums[i-2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1; i>1; i--){\\n            if(nums[i]>=nums[i-1]+nums[i-2]) continue;\\n            else return nums[i]+nums[i-1]+nums[i-2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816020,
                "title": "python-98-21-faster",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums, reverse=True)\\n        for i in range(0, len(nums) - 2):\\n            a, b, c = nums[i:i+3]\\n            if (a < b + c) and (b < a + c) and (c < a + b):\\n                return a + b + c\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums, reverse=True)\\n        for i in range(0, len(nums) - 2):\\n            a, b, c = nums[i:i+3]\\n            if (a < b + c) and (b < a + c) and (c < a + b):\\n                return a + b + c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814774,
                "title": "java-easy-solution-largest-perimeter",
                "content": "**Code**\\n```java\\npublic int largestPerimeter(int[] nums) {\\n\\tArrays.sort(nums);\\n\\n\\tint maxperi = 0;\\n\\tfor(int i = nums.length-1; (i >= 0 && (i-2)>=0); i--) {\\n\\t\\tint a = nums[i-2], \\n\\t\\t\\tb = nums[i-1],\\n\\t\\t\\tc = nums[i];\\n\\n\\t\\tif(a + b > c) {\\n\\t\\t\\tmaxperi = Math.max(maxperi, a + b + c);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxperi;\\n}\\n```\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int largestPerimeter(int[] nums) {\\n\\tArrays.sort(nums);\\n\\n\\tint maxperi = 0;\\n\\tfor(int i = nums.length-1; (i >= 0 && (i-2)>=0); i--) {\\n\\t\\tint a = nums[i-2], \\n\\t\\t\\tb = nums[i-1],\\n\\t\\t\\tc = nums[i];\\n\\n\\t\\tif(a + b > c) {\\n\\t\\t\\tmaxperi = Math.max(maxperi, a + b + c);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxperi;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1691729,
                "title": "java-intuitive-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. In order for 3 edges to form a triangle, the sum of any 2 edges need to > 3rd edge.\\n        2. To get the max perimeter, look for the largest possible edges. \\n        3. Sort the array and iterate from n to 2. If edge[n-2] + edge[n-1] > edge[n], return the sum of edges.\\n    */\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int j = nums.length -1; j >= 2; j--) {\\n            if (nums[j-1] + nums[j-2] > nums[j]) {\\n                return nums[j-1] + nums[j-2] + nums[j];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. In order for 3 edges to form a triangle, the sum of any 2 edges need to > 3rd edge.\\n        2. To get the max perimeter, look for the largest possible edges. \\n        3. Sort the array and iterate from n to 2. If edge[n-2] + edge[n-1] > edge[n], return the sum of edges.\\n    */\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int j = nums.length -1; j >= 2; j--) {\\n            if (nums[j-1] + nums[j-2] > nums[j]) {\\n                return nums[j-1] + nums[j-2] + nums[j];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438060,
                "title": "o-n-log-n-time-o-n-space-without-input-modifiaction",
                "content": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] nums) {        \\n        var numsSorted = nums\\n            .OrderByDescending(n => n)\\n            .ToList();\\n        \\n        for(int i = 0; i < numsSorted.Count - 2; ++i) {\\n            if(numsSorted[i] < numsSorted[i+1] + numsSorted[i+2]) {\\n                return numsSorted[i] + numsSorted[i+1] + numsSorted[i+2];\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] nums) {        \\n        var numsSorted = nums\\n            .OrderByDescending(n => n)\\n            .ToList();\\n        \\n        for(int i = 0; i < numsSorted.Count - 2; ++i) {\\n            if(numsSorted[i] < numsSorted[i+1] + numsSorted[i+2]) {\\n                return numsSorted[i] + numsSorted[i+1] + numsSorted[i+2];\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381910,
                "title": "simple-greedy-solution-java",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        if(nums.length <3) return 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int a = n-3, b = n-2, c = n-1;\\n        while(a>=0){\\n            if(nums[a]+nums[b]>nums[c]) return nums[a]+nums[b]+nums[c];\\n            else{\\n                a--;\\n                b--;\\n                c--;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int largestPerimeter(int[] nums) {\\n        if(nums.length <3) return 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int a = n-3, b = n-2, c = n-1;\\n        while(a>=0){\\n            if(nums[a]+nums[b]>nums[c]) return nums[a]+nums[b]+nums[c];\\n            else{\\n                a--;\\n                b--;\\n                c--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1320183,
                "title": "java-sorting-greedy-6ms-beats-100-t-c-o-nlogn-s-c-o-1",
                "content": "\\n    // Sorting\\n\\t// O(NlogN) O(1)\\n\\tpublic int largestPerimeter(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tArrays.sort(nums);\\n\\n\\t\\tfor (int i = len - 1; i >= 2; i--) {\\n\\t\\t\\tif (isValid(nums[i], nums[i - 1], nums[i - 2]))\\n\\t\\t\\t\\treturn nums[i] + nums[i - 1] + nums[i - 2];\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t// O(1) O(1)\\n\\tpublic boolean isValid(int a, int b, int c) {\\n        if(a + b <= c || b + c <= a || a + c <= b)\\n            return false;\\n        return true;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // Sorting\\n\\t// O(NlogN) O(1)\\n\\tpublic int largestPerimeter(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tArrays.sort(nums);\\n\\n\\t\\tfor (int i = len - 1; i >= 2; i--) {\\n\\t\\t\\tif (isValid(nums[i], nums[i - 1], nums[i - 2]))\\n\\t\\t\\t\\treturn nums[i] + nums[i - 1] + nums[i - 2];\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t// O(1) O(1)\\n\\tpublic boolean isValid(int a, int b, int c) {\\n        if(a + b <= c || b + c <= a || a + c <= b)\\n            return false;\\n        return true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1296831,
                "title": "easy-python-solution-93-46",
                "content": "Runtime: 180 ms, faster than 93.46% of Python3 online submissions for Largest Perimeter Triangle.\\nMemory Usage: 15.5 MB, less than 59.90% of Python3 online submissions for Largest Perimeter Triangle.\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)-1,1,-1):\\n            if(nums[i-2]+nums[i-1]>nums[i]):\\n                return nums[i]+nums[i-1]+nums[i-2]\\n        return 0",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 180 ms, faster than 93.46% of Python3 online submissions for Largest Perimeter Triangle.\\nMemory Usage: 15.5 MB, less than 59.90% of Python3 online submissions for Largest Perimeter Triangle.\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)-1,1,-1):\\n            if(nums[i-2]+nums[i-1]>nums[i]):\\n                return nums[i]+nums[i-1]+nums[i-2]\\n        return 0",
                "codeTag": "Java"
            },
            {
                "id": 1259782,
                "title": "rust-4ms-faster-than-100-2-3mb-less-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/7a7614f0-d1dd-475d-9665-4947c43bfc81_1623180583.1149526.png)\\n\\n```\\n\\timpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        nums.reverse();\\n        for i in 1..nums.len() - 1{\\n            if nums[i-1] + nums[i] > nums[i+1] && nums[i-1] + nums[i+1] > nums[i] && nums[i] + nums[i+1] > nums[i-1] {\\n                return nums[i-1] + nums[i] + nums[i+1];\\n            }\\n        }\\n        0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\timpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        nums.reverse();\\n        for i in 1..nums.len() - 1{\\n            if nums[i-1] + nums[i] > nums[i+1] && nums[i-1] + nums[i+1] > nums[i] && nums[i] + nums[i+1] > nums[i-1] {\\n                return nums[i-1] + nums[i] + nums[i+1];\\n            }\\n        }\\n        0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168419,
                "title": "c-28ms-94-sorting-and-math",
                "content": "Runtime: 28 ms, faster than 93.96% of C++ online submissions for Largest Perimeter Triangle.\\nMemory Usage: 21.9 MB, less than 10.33% of C++ online submissions for Largest Perimeter Triangle.\\n**General idea**\\n1. sort all numbers\\n2. check : last three numbers is satisfied for inequality of triangle ? if not will check next three numbers and so etc.\\n```\\nclass Solution {\\npublic:\\n  int largestPerimeter(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\t\\n    for(int a= nums.size()- 1, b= nums.size()- 2, c= nums.size()- 3; b ;a--,b--,c--)\\n      if(nums[a] < nums[b] + nums[c]) return nums[a] + nums[b] + nums[c];\\n    \\n    return 0;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int largestPerimeter(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\t\\n    for(int a= nums.size()- 1, b= nums.size()- 2, c= nums.size()- 3; b ;a--,b--,c--)\\n      if(nums[a] < nums[b] + nums[c]) return nums[a] + nums[b] + nums[c];\\n    \\n    return 0;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123705,
                "title": "python3-priority-queue",
                "content": "It might be over-engineering but be another way of solving it.\\n\\n\"\"\"\\n\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n\\n        neg = [-x for x in nums]\\n        heapq.heapify(neg)\\n        a = -heapq.heappop(neg)\\n        b = -heapq.heappop(neg)\\n\\n        while len(neg) > 0:\\n            c = -heapq.heappop(neg)\\n            if a < b + c:\\n                return a + b + c\\n            else:\\n                a, b  = b, c\\n\\t\\t\\t\\t\\n        return 0\\n\\n\"\"\"",
                "solutionTags": [],
                "code": "It might be over-engineering but be another way of solving it.\\n\\n\"\"\"\\n\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n\\n        neg = [-x for x in nums]\\n        heapq.heapify(neg)\\n        a = -heapq.heappop(neg)\\n        b = -heapq.heappop(neg)\\n\\n        while len(neg) > 0:\\n            c = -heapq.heappop(neg)\\n            if a < b + c:\\n                return a + b + c\\n            else:\\n                a, b  = b, c\\n\\t\\t\\t\\t\\n        return 0\\n\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 1081040,
                "title": "golang-solution-faster-than-95-65",
                "content": "**Code On The Bottom, If this helped you please up vote**\\nThe idea of this solution is to sort the array and then keep on checking the largest three side lengths. \\n\\nIn the problem it asks us to \"return the largest perimeter of a triangle with non-zero area.\" Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images\\n\\n![image](https://assets.leetcode.com/users/images/66ccb9b3-8b78-4dc9-98ae-ab0552ee5a76_1614187356.9360328.png)\\n\\n*The triangle above is a proper triangle with an area greater than zero and we know that because the two smaller lengths, `5` and `5` added together is `10 > 7`.*\\n![image](https://assets.leetcode.com/users/images/0552ecab-f2d5-494e-a395-873af3e082e9_1614187373.3305833.png)\\n\\n*In the image above we can see that this is not a proper triangle because the area is zero. We know that this is not a proper triangle because the two smaller sides lengths are `4` and `3`. Four plus three is `7` and `7` is the length of the greatest triangle. So we don\\'t have a triangle.*\\n\\n![image](https://assets.leetcode.com/users/images/b922600c-e53c-46cd-9311-4eed61679add_1614187386.0672615.png)\\n![image](https://assets.leetcode.com/users/images/fb5dab69-6d7e-4c5c-8b31-ce81980346a1_1614187400.8811622.png)\\n\\n*The two images above are not proper triangles because the length of the two smaller sides are smaller than `7` and won\\'t be able to form a triangle.*\\n\\n```\\nfunc largestPerimeter(A []int) int {\\n    sort.Ints(A)\\n    for i := len(A) - 1; i >= 2; i-- {\\n        if A[i] < A[i - 1] + A[i - 2] {\\n            return A[i] + A[i - 1] + A[i - 2]\\n        }\\n    }\\n    return 0\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestPerimeter(A []int) int {\\n    sort.Ints(A)\\n    for i := len(A) - 1; i >= 2; i-- {\\n        if A[i] < A[i - 1] + A[i - 2] {\\n            return A[i] + A[i - 1] + A[i - 2]\\n        }\\n    }\\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1048016,
                "title": "using-triangle-properties-sum-of-two-sides-is-greater-than-third-side-simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] A) {\\n        int end = A.length-1;\\n        Arrays.sort(A);\\n        int sum=0;\\n        for(int i=end;i>=2;i--)\\n        {\\n            if(A[i-2]+A[i-1]>A[i]){\\n                sum = A[i-2]+A[i-1]+A[i];\\n                break;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] A) {\\n        int end = A.length-1;\\n        Arrays.sort(A);\\n        int sum=0;\\n        for(int i=end;i>=2;i--)\\n        {\\n            if(A[i-2]+A[i-1]>A[i]){\\n                sum = A[i-2]+A[i-1]+A[i];\\n                break;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998277,
                "title": "easy-clear-solution-99-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& A) {\\n        ios::sync_with_stdio(0); cout.tie(0); cin.tie(0);\\n        sort(A.begin(),A.end());\\n        int n=A.size();\\n        for(int i=n-1;i>1;i--){\\n            if(A[i]>=A[i-1]+A[i-2])continue;\\n            else return A[i]+A[i-1]+A[i-2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& A) {\\n        ios::sync_with_stdio(0); cout.tie(0); cin.tie(0);\\n        sort(A.begin(),A.end());\\n        int n=A.size();\\n        for(int i=n-1;i>1;i--){\\n            if(A[i]>=A[i-1]+A[i-2])continue;\\n            else return A[i]+A[i-1]+A[i-2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 218686,
                "title": "c-4-lines-beat-100",
                "content": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] A) {\\n        Array.Sort(A);\\n        for(int i = A.Length-1;i>=2;i--)\\n            if(A[i]<A[i-1]+A[i-2]) return A[i]+A[i-1]+A[i-2];\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] A) {\\n        Array.Sort(A);\\n        for(int i = A.Length-1;i>=2;i--)\\n            if(A[i]<A[i-1]+A[i-2]) return A[i]+A[i-1]+A[i-2];\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218455,
                "title": "simple-python-solution-without-sorting-beats-100",
                "content": "\\n\\tdef largestPerimeter(self, A):\\n\\t\\ta = max(A)\\n        A.remove(a)\\n        b = max(A)\\n        A.remove(b)\\n        c = max(A)\\n        A.remove(c)        \\n        while b+c <= a and A != []:\\n\\t\\t\\ta,b,c = b,c,max(A)\\n\\t\\t   A.remove(c)        \\n        if b+c>a: \\n            return a+b+c\\n        else:\\n            return 0",
                "solutionTags": [],
                "code": "\\n\\tdef largestPerimeter(self, A):\\n\\t\\ta = max(A)\\n        A.remove(a)\\n        b = max(A)\\n        A.remove(b)\\n        c = max(A)\\n        A.remove(c)        \\n        while b+c <= a and A != []:\\n\\t\\t\\ta,b,c = b,c,max(A)\\n\\t\\t   A.remove(c)        \\n        if b+c>a: \\n            return a+b+c\\n        else:\\n            return 0",
                "codeTag": "Python3"
            },
            {
                "id": 3938483,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(NlogN) + O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        for(int i = 0; i < nums.size()-2; i++){\\n            if(nums[i+2] + nums[i+1] > nums[i])\\n                return nums[i+2] + nums[i+1] + nums[i];\\n        }\\n        return 0;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/b4a78ab0-1c02-486b-88dd-f93befc74ad9_1692570558.5688822.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        for(int i = 0; i < nums.size()-2; i++){\\n            if(nums[i+2] + nums[i+1] > nums[i])\\n                return nums[i+2] + nums[i+1] + nums[i];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653933,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums));\\n\\n        for (int i=n-1; i>1; i--)\\n            if (nums[i] < nums[i-1]+nums[i-2]) return nums[i]+nums[i-1]+nums[i-2];\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums));\\n\\n        for (int i=n-1; i>1; i--)\\n            if (nums[i] < nums[i-1]+nums[i-2]) return nums[i]+nums[i-1]+nums[i-2];\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622121,
                "title": "c-simple-sorting-triangle-property",
                "content": "# Code\\n```\\n// Triangle property: a + b > c\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n       sort(nums.rbegin(), nums.rend());\\n       for (int i = 0; i < nums.size()-2; i++) {\\n           if (nums[i] < nums[i+1] + nums[i+2])\\n            return nums[i] + nums[i+1] + nums[i+2];\\n       }\\n       return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// Triangle property: a + b > c\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n       sort(nums.rbegin(), nums.rend());\\n       for (int i = 0; i < nums.size()-2; i++) {\\n           if (nums[i] < nums[i+1] + nums[i+2])\\n            return nums[i] + nums[i+1] + nums[i+2];\\n       }\\n       return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532977,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& n) {\\n        sort(n.begin(), n.end());\\n        for(int i = n.size()-3; i >= 0; i--)\\n        {\\n            if(n[i] + n[i+1] > n[i+2])\\n            {\\n                return n[i] + n[i+1] + n[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums) - 2):\\n            a = nums[i]\\n            b = nums[i+1]\\n            c = nums[i+2]\\n            if a < b + c:\\n                return a + b + c\\n        return 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        setMaxAtIndexI(nums.length - 1, nums);\\n        setMaxAtIndexI(nums.length - 2, nums);\\n        for (int i = nums.length - 1; i > 1; i--) {\\n             setMaxAtIndexI(i - 2, nums);\\n            if (nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n    private void setMaxAtIndexI(int index, int [] nums) {\\n        int maxValue = 0;\\n        int maxValueIndex = index;\\n\\n        for (int i = 0; i <= index; i++) {\\n            if (maxValue < nums[i]) {\\n                maxValue = nums[i];\\n                maxValueIndex = i;\\n            }\\n        }\\n        nums[maxValueIndex] = nums[index];\\n        nums[index] = maxValue;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& n) {\\n        sort(n.begin(), n.end());\\n        for(int i = n.size()-3; i >= 0; i--)\\n        {\\n            if(n[i] + n[i+1] > n[i+2])\\n            {\\n                return n[i] + n[i+1] + n[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums) - 2):\\n            a = nums[i]\\n            b = nums[i+1]\\n            c = nums[i+2]\\n            if a < b + c:\\n                return a + b + c\\n        return 0\\n```\n```Java []\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        setMaxAtIndexI(nums.length - 1, nums);\\n        setMaxAtIndexI(nums.length - 2, nums);\\n        for (int i = nums.length - 1; i > 1; i--) {\\n             setMaxAtIndexI(i - 2, nums);\\n            if (nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n    private void setMaxAtIndexI(int index, int [] nums) {\\n        int maxValue = 0;\\n        int maxValueIndex = index;\\n\\n        for (int i = 0; i <= index; i++) {\\n            if (maxValue < nums[i]) {\\n                maxValue = nums[i];\\n                maxValueIndex = i;\\n            }\\n        }\\n        nums[maxValueIndex] = nums[index];\\n        nums[index] = maxValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506631,
                "title": "simple-java-solution-for-beginners-8ms-beats-99-39",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 2; i--) {\\n            if(nums[i - 1] + nums[i - 2] > nums[i]) {\\n                return nums[i - 1] + nums[i - 2] + nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 2; i--) {\\n            if(nums[i - 1] + nums[i - 2] > nums[i]) {\\n                return nums[i - 1] + nums[i - 2] + nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462706,
                "title": "find-the-largest-perimeter-of-a-non-zero-area-triangle",
                "content": "\\n1. Sort the input array in non-descending order using Arrays.sort(nums).\\n2. Iterate over the sorted array from the last element towards the front.\\n3. For each element, check if it can be used as the longest side of a triangle by checking the triangle inequality: \"the sum of any two sides is strictly greater than the third side\". If this condition is satisfied for the current element and its two preceding elements, we have found a non-zero area triangle.\\n4. If a non-zero area triangle is found, return its perimeter which is the sum of the three sides. If no non-zero area triangle is found, return 0.\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i = n-1; i >= 2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i = n-1; i >= 2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438306,
                "title": "java-largest-perimeter-triangle",
                "content": "\\n```\\nclass Solution {\\n   public int minToMax(int[] nums)\\n    {\\n        int min = nums.length - 3;\\n        int sqere = 0;\\n        while (min > -1)\\n        {\\n            if (nums[min + 2] < nums[min] + nums[min + 1])\\n                sqere = Math.max(nums[min + 2] + nums[min] + nums[min + 1], sqere);\\n            \\n                min--;\\n        }\\n        return sqere;\\n    }\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        return minToMax(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int minToMax(int[] nums)\\n    {\\n        int min = nums.length - 3;\\n        int sqere = 0;\\n        while (min > -1)\\n        {\\n            if (nums[min + 2] < nums[min] + nums[min + 1])\\n                sqere = Math.max(nums[min + 2] + nums[min] + nums[min + 1], sqere);\\n            \\n                min--;\\n        }\\n        return sqere;\\n    }\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        return minToMax(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258929,
                "title": "sort-for-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n\\n    for (let i = 0; i < nums.length - 2; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\\n            return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n    }\\n\\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n\\n    for (let i = 0; i < nums.length - 2; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\\n            return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n    }\\n\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3192203,
                "title": "java-simple-fastest-solution-beats-99-64-with-explanation-using-test-cases",
                "content": "\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        //[2,1,2]\\n        //sort => [1,2,2]<-\\n        //a+b > c\\n        //(1+2)=3 > 2 true\\n        //res = 5\\n\\n        //[1,2,1]\\n        //sort=> [1,1,2]<-\\n        //(1+1)=2 > 2 false \\n        //return 0\\n\\n        //[1,1,10]\\n        //sort => [1,1,10] <-\\n        //(1+1)=2> 10 false\\n        // return 0\\n        \\n        //[1,2,10]\\n        //sort => [1,2,10]\\n        //(1+2)=3> 10 false\\n        // return 0\\n        \\n        //[1,2,1,2,1,2]\\n        //sort => [1,1,1,2,2,2] <-\\n        //(2+2)=4> 2 true\\n        // return 6\\n        \\n      \\n        Arrays.sort(nums);\\n\\n          // we need to loop through an array backward , this wasy we can get max values.\\n\\n        for(int i =nums.length-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        //[2,1,2]\\n        //sort => [1,2,2]<-\\n        //a+b > c\\n        //(1+2)=3 > 2 true\\n        //res = 5\\n\\n        //[1,2,1]\\n        //sort=> [1,1,2]<-\\n        //(1+1)=2 > 2 false \\n        //return 0\\n\\n        //[1,1,10]\\n        //sort => [1,1,10] <-\\n        //(1+1)=2> 10 false\\n        // return 0\\n        \\n        //[1,2,10]\\n        //sort => [1,2,10]\\n        //(1+2)=3> 10 false\\n        // return 0\\n        \\n        //[1,2,1,2,1,2]\\n        //sort => [1,1,1,2,2,2] <-\\n        //(2+2)=4> 2 true\\n        // return 6\\n        \\n      \\n        Arrays.sort(nums);\\n\\n          // we need to loop through an array backward , this wasy we can get max values.\\n\\n        for(int i =nums.length-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138912,
                "title": "c-greedy-approach-sort-easiest-soln",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort in asc order and then you know the max perimeter will be found only from the last. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int max_peri= 0;\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                max_peri=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return max_peri;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int max_peri= 0;\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                max_peri=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return max_peri;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073407,
                "title": "larggest-perimeter-triangle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068822,
                "title": "easiest-solution-ever-c",
                "content": "# Intuition\\njust think about in any \\u26DB triangle sum of two sides always greater than than third sides\\n\\n# Approach\\nat first sort the nums vector and i used here from last iterator you can also sort vector in descending order.\\njust use in any \\u26DB triangle sum of two sides always greater than than third sides and write code.  \\uD83D\\uDE0A\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(nums[i]<(nums[i-1]+nums[i-2])){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(nums[i]<(nums[i-1]+nums[i-2])){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022082,
                "title": "4-line-code-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        std::sort( nums.rbegin(), nums.rend() );\\n        for( int i = 0 ; i < nums.size()-2 ; i++ ){ \\n            if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }  \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        std::sort( nums.rbegin(), nums.rend() );\\n        for( int i = 0 ; i < nums.size()-2 ; i++ ){ \\n            if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }  \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957115,
                "title": "kotlin-4-line-solution-windowed",
                "content": "# Code\\n```\\nclass Solution {\\n    fun largestPerimeter(nums: IntArray): Int {\\n        nums.sortedDescending().windowed(3, 1).forEach { (a, b, c) ->\\n            if (a < b + c && b < a + c && c < a + b) return a + b + c\\n        }\\n\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun largestPerimeter(nums: IntArray): Int {\\n        nums.sortedDescending().windowed(3, 1).forEach { (a, b, c) ->\\n            if (a < b + c && b < a + c && c < a + b) return a + b + c\\n        }\\n\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808758,
                "title": "leetcode-the-hard-way-rust-solutions",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\nSort and find the first three lengths where satifies `a + b > c` from the largest.\\n\\n```rs\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        for i in (2 .. nums.len()).rev() {\\n            if (nums[i - 2] + nums[i - 1] > nums[i]) {\\n                return nums[i - 2] + nums[i - 1] + nums[i];\\n            }\\n        }\\n        0\\n    }\\n}\\n```\\n\\nWe can use `windows` as well.\\n\\n```rs\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        for w in nums.windows(3).rev() {\\n            if (w[0] + w[1] > w[2]) {\\n                return w[0] + w[1] + w[2];\\n            }\\n        }\\n        0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```rs\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        for i in (2 .. nums.len()).rev() {\\n            if (nums[i - 2] + nums[i - 1] > nums[i]) {\\n                return nums[i - 2] + nums[i - 1] + nums[i];\\n            }\\n        }\\n        0\\n    }\\n}\\n```\n```rs\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        for w in nums.windows(3).rev() {\\n            if (w[0] + w[1] > w[2]) {\\n                return w[0] + w[1] + w[2];\\n            }\\n        }\\n        0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2725205,
                "title": "95ms-beats-98-40-javascript-submissions-memory-usage-44-mb-beats-96-33-users",
                "content": "var largestPerimeter = function(nums) {\\n    nums.sort(function(a,b) {return a-b})\\n    for (let i=nums.length-1;i>=0;i--){\\n        if(nums[i]>=nums[i-1]+nums[i-2]){\\n        continue;\\n        }else if(nums[i]<nums[i-1]+nums[i-2]){\\n                 return nums[i]+nums[i-1]+nums[i-2]\\n        break;         \\n        }\\n        return 0\\n    }\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "var largestPerimeter = function(nums) {\\n    nums.sort(function(a,b) {return a-b})\\n    for (let i=nums.length-1;i>=0;i--){\\n        if(nums[i]>=nums[i-1]+nums[i-2]){\\n        continue;\\n        }else if(nums[i]<nums[i-1]+nums[i-2]){\\n                 return nums[i]+nums[i-1]+nums[i-2]\\n        break;         \\n        }\\n        return 0\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2702667,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=2){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=n-1;i>=2;i--){\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n\\n            if(a+b>c){\\n                return a+b+c;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n// class Solution {\\n// public:\\n//     int largestPerimeter(vector<int>& nums) {\\n//         sort(nums.begin(),nums.end());\\n//         for(int i=nums.size()-1;i>=2;i--){\\n//             int a=nums[i-2];\\n//             int b=nums[i-1];\\n//             int c=nums[i];\\n            \\n//             if(a+b>c){\\n//                 return a+b+c;\\n//             }\\n//         }\\n//         return 0;\\n        \\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=2){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=n-1;i>=2;i--){\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n\\n            if(a+b>c){\\n                return a+b+c;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n// class Solution {\\n// public:\\n//     int largestPerimeter(vector<int>& nums) {\\n//         sort(nums.begin(),nums.end());\\n//         for(int i=nums.size()-1;i>=2;i--){\\n//             int a=nums[i-2];\\n//             int b=nums[i-1];\\n//             int c=nums[i];\\n            \\n//             if(a+b>c){\\n//                 return a+b+c;\\n//             }\\n//         }\\n//         return 0;\\n        \\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699195,
                "title": "easy-solution-in-four-line-in-python",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)        \\n        for i in range(len(nums)-1,1,-1):\\n            if nums[i]+nums[i-1] > nums[i-2] and nums[i-1]+nums[i-2] > nums[i] and nums[i]+nums[i-2] > nums[i-1]:\\n                return (nums[i]+nums[i-1]+nums[i-2])\\n        return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)        \\n        for i in range(len(nums)-1,1,-1):\\n            if nums[i]+nums[i-1] > nums[i-2] and nums[i-1]+nums[i-2] > nums[i] and nums[i]+nums[i-2] > nums[i-1]:\\n                return (nums[i]+nums[i-1]+nums[i-2])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695906,
                "title": "java-same-as-all-the-others-but-consider-upvoting",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 3; i >= 0; i--) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) {\\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n) + O(n * logn) => O(n * logn)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 3; i >= 0; i--) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) {\\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n) + O(n * logn) => O(n * logn)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695691,
                "title": "c-short-solution",
                "content": "Solution should be fairly self explanatory, just sort the array and then check each triplet for the triangle inequality (`a+b > c`).\\n\\n```\\nint* comp(const void* a, const void* b){\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nint largestPerimeter(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int cur=0;\\n    for (int i=2; i<numsSize; i++)\\n        if (nums[i] < nums[i-1] + nums[i-2])\\n            cur = nums[i] + nums[i-1] + nums[i-2];\\n    \\n    return cur;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint* comp(const void* a, const void* b){\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nint largestPerimeter(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int cur=0;\\n    for (int i=2; i<numsSize; i++)\\n        if (nums[i] < nums[i-1] + nums[i-2])\\n            cur = nums[i] + nums[i-1] + nums[i-2];\\n    \\n    return cur;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2695516,
                "title": "largest-perimeter-triangle-c-o-logn-concise-and-description",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The solution is based on one of the basic properties of a triangle.\\nThe sum of the length of any two sides of a triangle is greater than the length of the third side.\\n2.Sort the array and when a+b>c, return the perimeter (a+b+c). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- sort the array\\ntraverse from n-3 to 0\\nif at any instant a + b > c, return perimenter (a+b+c)\\n a=nums[i], b=nums[i+1], c=nums[i+2];\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(logn)\\n\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#ifdef tabr\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n#define pb        push_back\\n#define ll        long long\\n#define ff        first\\n#define ss        second\\n#define ppi       pair<int, pair<int, int>>\\n#define fo(i,n)   for(int i=0;i<n;i++)\\n#define N 10000\\n\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = n - 3; i >= 0; i--)\\n        {\\n            if (nums[i] + nums[i + 1] > nums[i + 2])\\n            {\\n                return  nums[i] + nums[i + 1] + nums[i + 2];\\n            }\\n        }\\n        return 0;\\n\\n    }\\n};\\n\\n#ifdef tabr\\nint main()\\n{\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    //\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#ifdef tabr\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n#define pb        push_back\\n#define ll        long long\\n#define ff        first\\n#define ss        second\\n#define ppi       pair<int, pair<int, int>>\\n#define fo(i,n)   for(int i=0;i<n;i++)\\n#define N 10000\\n\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = n - 3; i >= 0; i--)\\n        {\\n            if (nums[i] + nums[i + 1] > nums[i + 2])\\n            {\\n                return  nums[i] + nums[i + 1] + nums[i + 2];\\n            }\\n        }\\n        return 0;\\n\\n    }\\n};\\n\\n#ifdef tabr\\nint main()\\n{\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    //\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2695475,
                "title": "east-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-3;i>=0;i--)\\n        {\\n            if(nums[i]+nums[i+1]>nums[i+2])\\n            {\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-3;i>=0;i--)\\n        {\\n            if(nums[i]+nums[i+1]>nums[i+2])\\n            {\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695298,
                "title": "c-simple-code-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool valid(int a,int b,int c){return (a+b>c && a+c>b && b+c>a);}\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(valid(nums[i],nums[i+1],nums[i+2])) return nums[i]+nums[i+1]+nums[i+2];\\n        }\\n        return 0;\\n    }\\n};\\n```\\n*Implementation of valid fns to check whether the triangle is valid or not\\nbasic triangle perimeter sum of two sides should be greater than the third side.*\\n\\n*Sort array in decreasing order to calculate maximum possible perimeter\\nwe iterate to nums.size()-2 cause we need 3 no\\'s*\\n\\n*Checking the three nos from ith posn i.e nums at* i, i+1, i+2 *if they fulfill triangles perimeter property they are good to go\\nso we return the sum of the 3no\\'s.*\\n\\nTime Complexity ~ O(NlogN)\\nSpace Complexity ~ O(1)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int a,int b,int c){return (a+b>c && a+c>b && b+c>a);}\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(valid(nums[i],nums[i+1],nums[i+2])) return nums[i]+nums[i+1]+nums[i+2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695154,
                "title": "python-easy-solution-bruteforce",
                "content": "\\nBruteforce -->\\n1. First sort the list and reverse it so that you can have the largest number at the start of the lisit.\\n2. Then traverse the list till len(nums)-2 because you are going to take 3 numberse into consideration.\\n3. Then we have to check the simple condition and rule of tranges ie. --> The sum of the two sides of the triangle is always smaller than the third side.\\n4. If all the condition meet then we have to return the sum of the three sides of the triange.\\n5. The three sides of the triangle are the 1st, 2nd and the 3rd element and they will always be the largest because we have sorted it in thre reverse order.\\n\\n![image](https://assets.leetcode.com/users/images/c584c62d-e263-4e30-849f-cc670169e10f_1665592727.4565024.png)\\n\\n\\n        nums.sort(reverse = True)\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] + nums[i+2]:\\n                return nums[i] + nums[i+1] + nums[i+2]\\n        return 0\\n\\nAnother way of writing the same code -->\\n![image](https://assets.leetcode.com/users/images/8e14b15c-a266-4581-b091-1c63863074e0_1665592747.352271.png)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nBruteforce -->\\n1. First sort the list and reverse it so that you can have the largest number at the start of the lisit.\\n2. Then traverse the list till len(nums)-2 because you are going to take 3 numberse into consideration.\\n3. Then we have to check the simple condition and rule of tranges ie. --> The sum of the two sides of the triangle is always smaller than the third side.\\n4. If all the condition meet then we have to return the sum of the three sides of the triange.\\n5. The three sides of the triangle are the 1st, 2nd and the 3rd element and they will always be the largest because we have sorted it in thre reverse order.\\n\\n![image](https://assets.leetcode.com/users/images/c584c62d-e263-4e30-849f-cc670169e10f_1665592727.4565024.png)\\n\\n\\n        nums.sort(reverse = True)\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] + nums[i+2]:\\n                return nums[i] + nums[i+1] + nums[i+2]\\n        return 0\\n\\nAnother way of writing the same code -->\\n![image](https://assets.leetcode.com/users/images/8e14b15c-a266-4581-b091-1c63863074e0_1665592747.352271.png)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2694948,
                "title": "c",
                "content": "\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int LargestPerimeter(int[] nums) \\n    {        \\n        if (nums.Length < 3)\\n        {\\n            return 0;\\n        }\\n\\n        Array.Sort(nums);\\n\\n        for(int i=nums.Length-1; i>=2; i--)\\n        {   \\n            if (nums[i-1] + nums[i-2] > nums[i])\\n            {\\n                return nums[i-1] + nums[i-2] + nums[i] ;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int LargestPerimeter(int[] nums) \\n    {        \\n        if (nums.Length < 3)\\n        {\\n            return 0;\\n        }\\n\\n        Array.Sort(nums);\\n\\n        for(int i=nums.Length-1; i>=2; i--)\\n        {   \\n            if (nums[i-1] + nums[i-2] > nums[i])\\n            {\\n                return nums[i-1] + nums[i-2] + nums[i] ;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694746,
                "title": "easy-c-solution",
                "content": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694739,
                "title": "easy-c-solution",
                "content": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694716,
                "title": "easy-c-solution",
                "content": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694150,
                "title": "accepted-java-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMax perimeter is the sum of the max 3 values\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        //max perimeter is the sum of the max 3 values\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--){\\n            \\n            //if the sum of the first two sides are greater than the third side then it forms a triangle\\n            if(nums[i] < nums[i-1]+nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        //max perimeter is the sum of the max 3 values\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--){\\n            \\n            //if the sum of the first two sides are greater than the third side then it forms a triangle\\n            if(nums[i] < nums[i-1]+nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694124,
                "title": "easy-solution-beginner-c-java-o-nlogn-simple-traversal",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\\n2)Sort the array to get the maximum element of the array at a side ;\\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\\n4)Store the value of it in ans (default value is 0) and return it .\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\nC++ solution\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i = nums.size()-1; i>=2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n               ans=nums[i] + nums[i-1]+ nums[i-2];  \\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nJAVA solution\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i = nums.length-1; i>=2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n               ans=nums[i] + nums[i-1]+ nums[i-2];  \\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i = nums.size()-1; i>=2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n               ans=nums[i] + nums[i-1]+ nums[i-2];  \\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i = nums.length-1; i>=2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n               ans=nums[i] + nums[i-1]+ nums[i-2];  \\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694095,
                "title": "java-100-faster-solution",
                "content": "class Solution {\\n    public int largestPerimeter(int[] n) {\\n        \\n        \\n     Arrays.sort(n);\\n        \\n        \\n        for(int i=n.length-1;i>1;--i){\\n            \\n            if(n[i]<n[i-1]+n[i-2])\\n                return n[i]+n[i-1]+n[i-2];\\n             }\\n        return 0;\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestPerimeter(int[] n) {\\n        \\n        \\n     Arrays.sort(n);\\n        \\n        \\n        for(int i=n.length-1;i>1;--i){\\n            \\n            if(n[i]<n[i-1]+n[i-2])\\n                return n[i]+n[i-1]+n[i-2];\\n             }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1642182,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1798479,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641689,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1572410,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1642254,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641635,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1643491,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1923724,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1643541,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641603,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1642182,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1798479,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641689,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1572410,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1642254,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641635,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1643491,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1923724,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1643541,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641603,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 2045134,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 2035602,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 2028623,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1993295,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1902267,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1899215,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1869938,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1852503,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1847491,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1838667,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Score After Splitting a String",
        "question_content": "<p>Given a&nbsp;string <code>s</code>&nbsp;of zeros and ones, <em>return the maximum score after splitting the string into two <strong>non-empty</strong> substrings</em> (i.e. <strong>left</strong> substring and <strong>right</strong> substring).</p>\n\n<p>The score after splitting a string is the number of <strong>zeros</strong> in the <strong>left</strong> substring plus the number of <strong>ones</strong> in the <strong>right</strong> substring.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;011101&quot;\n<strong>Output:</strong> 5 \n<strong>Explanation:</strong> \nAll possible ways of splitting s into two non-empty substrings are:\nleft = &quot;0&quot; and right = &quot;11101&quot;, score = 1 + 4 = 5 \nleft = &quot;01&quot; and right = &quot;1101&quot;, score = 1 + 3 = 4 \nleft = &quot;011&quot; and right = &quot;101&quot;, score = 1 + 2 = 3 \nleft = &quot;0111&quot; and right = &quot;01&quot;, score = 1 + 1 = 2 \nleft = &quot;01110&quot; and right = &quot;1&quot;, score = 2 + 1 = 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;00111&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> When left = &quot;00&quot; and right = &quot;111&quot;, we get the maximum score = 2 + 3 = 5\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1111&quot;\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 500</code></li>\n\t<li>The string <code>s</code> consists of characters <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code> only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 597716,
                "title": "java-5-liner-one-pass",
                "content": "This can be done in single pass as below. With this approach we do not know the number of ones on right while iterating, so I have added TotalOne\\'s to the result before returning.\\n\\nLogic behind this -\\nResult = Max of (ZerosOnLeft + OnesOnRight) \\n= Max of (ZerosOnLeft + (TotalOnes - OnesOnLeft)) \\n= Max of (ZerosOnLeft - OnesOnLeft) + TotalOnes (as TotalOnes is constant)\\n\\n```\\npublic int maxScore(String s) {\\n\\tint zeros = 0, ones = 0, max = Integer.MIN_VALUE;\\n\\tfor(int i=0;i<s.length();i++) {\\n\\t\\tif(s.charAt(i) == \\'0\\') zeros++; else ones++;\\n\\t\\tif(i != s.length()-1) max = Math.max(zeros - ones, max);\\n\\t}\\n\\treturn max + ones;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxScore(String s) {\\n\\tint zeros = 0, ones = 0, max = Integer.MIN_VALUE;\\n\\tfor(int i=0;i<s.length();i++) {\\n\\t\\tif(s.charAt(i) == \\'0\\') zeros++; else ones++;\\n\\t\\tif(i != s.length()-1) max = Math.max(zeros - ones, max);\\n\\t}\\n\\treturn max + ones;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 598000,
                "title": "c-clear-and-concise-solution-runtime-o-n-space-o-1",
                "content": "**Description**: Traverse once to count the number of ones. Travese again to count the left zeroes and right ones using the previous calculation of ones(they constitute the ones on the right). If you encounter a 0 increase the left zeroes count and if you encounter a 1, decreaser the right ones count. Keep track of the maximum score at each division.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int rightOnes = 0, leftZeroes = 0;\\n        for(char c: s)\\n            if(c==\\'1\\') rightOnes++;\\n        \\n        int score = 0;\\n        for(int i=0; i<s.length()-1; i++){\\n            if(s[i]==\\'0\\') leftZeroes++;\\n            else rightOnes--;\\n            score = max(score, leftZeroes + rightOnes);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int rightOnes = 0, leftZeroes = 0;\\n        for(char c: s)\\n            if(c==\\'1\\') rightOnes++;\\n        \\n        int score = 0;\\n        for(int i=0; i<s.length()-1; i++){\\n            if(s[i]==\\'0\\') leftZeroes++;\\n            else rightOnes--;\\n            score = max(score, leftZeroes + rightOnes);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597740,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int n = s.length();\\n        int c1 = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s.charAt(i) == \\'1\\') c1++;\\n        }\\n        int max = 0;\\n        int c2 = 0;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(s.charAt(i) == \\'0\\') c2++;\\n            else c1--;\\n            max = Math.max(max, c1 + c2);\\n        }\\n        return max;\\n    }\\n}\\n```\\n**Alternate Single Pass**\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int n = s.length(), max = -n - 1, zeroCount = 0, oneCount = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s.charAt(i) == \\'0\\') zeroCount++;\\n            else oneCount++;\\n            if(i < n - 1) max = Math.max(zeroCount - oneCount, max);\\n        }\\n        return max + oneCount;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int n = s.length();\\n        int c1 = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s.charAt(i) == \\'1\\') c1++;\\n        }\\n        int max = 0;\\n        int c2 = 0;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(s.charAt(i) == \\'0\\') c2++;\\n            else c1--;\\n            max = Math.max(max, c1 + c2);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619000,
                "title": "python-simple-faster-than-94",
                "content": "<b>Time Complexity:</b> O(N)\\n<b>Runtime:</b> Faster than 94% <i>(as of May 11th, 2020)</i>\\n<b>Example:</b> ```input``` = \"00010\", ```output``` = 4\\n<b>Explanation:</b> \\nStep 1: In the first 2 lines of code, calculate the number of 0s in the left substring (\"0\") and the number of 1s in the right substring (\"0010\"). Thus, we start with <b>zeros = 1</b> and <b>ones = 1</b>. \\nStep 2: Traverse only the highlighted part of the string \"0<b>001</b>0\" and update the <b>zeros</b>, <b>ones</b>, and <b>score</b> variables as follows:\\n- At index 1: left = \"00\" and right = \"010\", zeros = 2, ones = 1, score 2 + 1 = 3 \\n- At index 2: left = \"000\" and right = \"10\", zeros = 3, ones = 1, score 3 + 1 = <b>4</b> \\n- At index 3: left = \"0001\" and right = \"0\", zeros = 3, ones = 0, score 3 + 0 = 3 \\n\\n\\n```\\ndef solution(s):\\n\\tzeros = 1 if s[0] == \\'0\\' else 0\\n\\tones = s.count(\\'1\\', 1)  # count 1s in s[1:]\\n\\tscore = zeros + ones\\n\\tfor i in xrange(1, len(s) - 1):\\n\\t\\tif s[i] == \\'0\\':\\n\\t\\t\\tzeros += 1\\n\\t\\telse:\\n\\t\\t\\tones -= 1\\n\\t\\tscore = max(zeros + ones,  score)\\n\\treturn score\\n```\\nIf you like my solution and/or find it useful, please upvote :) Thank you.\\n\\n\\n",
                "solutionTags": [],
                "code": "```input```\n```output```\n```\\ndef solution(s):\\n\\tzeros = 1 if s[0] == \\'0\\' else 0\\n\\tones = s.count(\\'1\\', 1)  # count 1s in s[1:]\\n\\tscore = zeros + ones\\n\\tfor i in xrange(1, len(s) - 1):\\n\\t\\tif s[i] == \\'0\\':\\n\\t\\t\\tzeros += 1\\n\\t\\telse:\\n\\t\\t\\tones -= 1\\n\\t\\tscore = max(zeros + ones,  score)\\n\\treturn score\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 668605,
                "title": "java-o-1-space-o-n-time",
                "content": "```\\npublic int maxScore(String s) {\\n        int zero = 0, one = 0, res = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'1\\') one++;\\n        }\\n        for (int i = 0; i < s.length() - 1; i++) {  // when divide btwn i  and i + 1;\\n            if (s.charAt(i) == \\'1\\') one--;  //num of ones on right side;\\n            else zero++;  // num of zeros on left side\\n            res  = Math.max(res, one + zero);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxScore(String s) {\\n        int zero = 0, one = 0, res = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'1\\') one++;\\n        }\\n        for (int i = 0; i < s.length() - 1; i++) {  // when divide btwn i  and i + 1;\\n            if (s.charAt(i) == \\'1\\') one--;  //num of ones on right side;\\n            else zero++;  // num of zeros on left side\\n            res  = Math.max(res, one + zero);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089092,
                "title": "java-easy-one-line-solution-brute-force",
                "content": "# Approach\\nI\\'ve replaced all the \\'1\\' in left substring and \\'0\\' in right one got sum of each length\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max =0;\\n        for(int i =0; i<s.length()-1; i++)\\n            max = Math.max(max,s.substring(0,i+1).replace(\"1\",\"\").length()+s.substring(i+1).replace(\"0\",\"\").length());\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max =0;\\n        for(int i =0; i<s.length()-1; i++)\\n            max = Math.max(max,s.substring(0,i+1).replace(\"1\",\"\").length()+s.substring(i+1).replace(\"0\",\"\").length());\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598041,
                "title": "clean-python-3-one-pass",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        zeros, accu, ones, score = 0, 0, 0, 0\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'1\\':\\n                ones += 1\\n                accu -= 1\\n            else:\\n                zeros += 1\\n            score = max(score, zeros + accu)\\n        return score + ones + (s[0] == \\'0\\') + (s[-1] == \\'1\\')\\n```\\n\\n--\\nUpdate:\\nMerge `accu` and `ones` to save one variable.\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        zeros, ones, score = 0, 0, 0\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'1\\':\\n                ones += 1\\n            else:\\n                zeros += 1\\n            score = max(score, zeros - ones)\\n        return score + ones + (s[0] == \\'0\\') + (s[-1] == \\'1\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        zeros, accu, ones, score = 0, 0, 0, 0\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'1\\':\\n                ones += 1\\n                accu -= 1\\n            else:\\n                zeros += 1\\n            score = max(score, zeros + accu)\\n        return score + ones + (s[0] == \\'0\\') + (s[-1] == \\'1\\')\\n```\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        zeros, ones, score = 0, 0, 0\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'1\\':\\n                ones += 1\\n            else:\\n                zeros += 1\\n            score = max(score, zeros - ones)\\n        return score + ones + (s[0] == \\'0\\') + (s[-1] == \\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598029,
                "title": "100-faster-0ms-than-other-online-submission-in-c-with-explanation",
                "content": "Here , we need to split a string into two non-empty strings so we will take a loop and count all the 1\\'s in the given string ,\\n\\nNext step is to traverse again till n-1 because we want to split a string into non-empty strings so if till n-1 we will have atleast one string on the lefthand side.\\n\\nAfetr that if in the second iteration we get 0\\'s then increment count2 and if we get 1 derement count1 this will keep track for each partition maximum score,\\n\\nfinally we compare if maxSum is greater than maximum of (maxSum ,(count1+count2)) and return that. \\n\\t```\\n\\t ```\\n Left       Right       count1   count2    maxsum\\n\\t\\t 0            11101         4            1          4+1=5 \\n\\t\\t 01         1101            3            1          3+1=4\\n\\t\\t 011         101             1             2           1+2=3\\n\\t\\t 0111       01              1              1             1+1=2\\n\\t\\t 01110     1               2               1             2+1=3\\n```\\n```\\n\\t\\t\\t\\tHere you can see clearly i have partitioned the strings in to two non empty substrings and got maxScore as 5\\n\\n**Here  is my Solution and ask if you have any doubt.**\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int maxScore(string s) \\n    {\\n        \\n        int n = s.length();\\n        int maxSum = 0;\\n        int count1=0,count2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                count1++;\\n            }\\n        }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tfor(int i=0;i<n-1;i++)   \\n        {\\n            if(s[i] == \\'0\\')  //  if we get 0 then increment count2\\n            {\\n                count2++;\\n            }\\n            else\\n            {\\n                count1--;  // if we get one decrement\\n            }\\n            maxSum = max(maxSum,(count1+count2)); // Checking for curmax at every iteration\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\t ```\n```\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int maxScore(string s) \\n    {\\n        \\n        int n = s.length();\\n        int maxSum = 0;\\n        int count1=0,count2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                count1++;\\n            }\\n        }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tfor(int i=0;i<n-1;i++)   \\n        {\\n            if(s[i] == \\'0\\')  //  if we get 0 then increment count2\\n            {\\n                count2++;\\n            }\\n            else\\n            {\\n                count1--;  // if we get one decrement\\n            }\\n            maxSum = max(maxSum,(count1+count2)); // Checking for curmax at every iteration\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410990,
                "title": "python-easy-solution",
                "content": "```\\ndef maxScore(self, s: str) -> int:\\n        maxx = 0\\n        i=1\\n        while i <= len(s)-1:\\n            left = s[:i]\\n            right = s[i:]\\n            zero_count = left.count(\"0\")\\n            one_count = right.count(\"1\")\\n            maxx = max(maxx,(zero_count+one_count))\\n            i = i+1\\n        return maxx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxScore(self, s: str) -> int:\\n        maxx = 0\\n        i=1\\n        while i <= len(s)-1:\\n            left = s[:i]\\n            right = s[i:]\\n            zero_count = left.count(\"0\")\\n            one_count = right.count(\"1\")\\n            maxx = max(maxx,(zero_count+one_count))\\n            i = i+1\\n        return maxx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 898668,
                "title": "python-two-passes-time-o-n",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        score = 0        \\n        zeros = 0\\n        ones = s.count(\\'1\\') \\n        \\n        for i in range(len(s)-1):\\n            if s[i] == \\'0\\':\\n                zeros += 1\\n            else:\\n                ones -= 1\\n            score = max(score, ones + zeros)\\n            \\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        score = 0        \\n        zeros = 0\\n        ones = s.count(\\'1\\') \\n        \\n        for i in range(len(s)-1):\\n            if s[i] == \\'0\\':\\n                zeros += 1\\n            else:\\n                ones -= 1\\n            score = max(score, ones + zeros)\\n            \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597859,
                "title": "linear-time-python-solution-with-explanation",
                "content": "```\\n# IDEA: on first pass count total number of 1s, on second pass keep track of how many 0s and 1s encountered so far\\n#       and calculate current score (subtract current 1s from total 1s and add current 0s), keep track of maximum\\n#       O(N) time, O(1) space\\n#\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        curr0, curr1, total1 = 0, 0, 0\\n        for c in s:\\n            if c == \\'1\\':\\n                total1 += 1\\n        \\n        maxScore = 0\\n        for c in s[:-1]:\\n            if c == \\'0\\':\\n                curr0 += 1\\n            else:\\n                curr1 += 1\\n            maxScore = max(maxScore, curr0 + total1 - curr1)\\n                \\n        return maxScore\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# IDEA: on first pass count total number of 1s, on second pass keep track of how many 0s and 1s encountered so far\\n#       and calculate current score (subtract current 1s from total 1s and add current 0s), keep track of maximum\\n#       O(N) time, O(1) space\\n#\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        curr0, curr1, total1 = 0, 0, 0\\n        for c in s:\\n            if c == \\'1\\':\\n                total1 += 1\\n        \\n        maxScore = 0\\n        for c in s[:-1]:\\n            if c == \\'0\\':\\n                curr0 += 1\\n            else:\\n                curr1 += 1\\n            maxScore = max(maxScore, curr0 + total1 - curr1)\\n                \\n        return maxScore\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1686704,
                "title": "java-2-methods-explained",
                "content": "**Method 1:** Find all 1s and 0s counts, then find max\\n>**T/S:** O(n)/O(n)\\n```\\npublic int maxScore(String s) {\\n\\tvar n = s.length();\\n\\n\\tvar zeroes = new int[n];\\n\\tzeroes[0] = (s.charAt(0) == \\'0\\') ? 1 : 0;\\n\\n\\tvar ones = new int[n];\\n\\tones[n - 1] = (s.charAt(n - 1) == \\'1\\') ? 1 : 0;\\n\\n\\tfor (int i = 1, j = n - 2; i < n; i++, j--) {\\n\\t\\tzeroes[i] = zeroes[i - 1] + (s.charAt(i) == \\'0\\' ? 1 : 0);\\n\\t\\tones[j] = ones[j + 1] + (s.charAt(j) == \\'1\\' ? 1 : 0);\\n\\t}\\n\\n\\tvar maxScore = Integer.MIN_VALUE;\\n\\tfor (var i = 0; i + 1 < n; i++)\\n\\t\\tmaxScore = Math.max(maxScore, zeroes[i] + ones[i + 1]);\\n\\treturn maxScore;\\n}\\n```\\n\\n**Method 2:** Observational\\n```\\nMax score = max(left 0s + right 1s)\\n= max(left 0s + total 1s - left 1s)\\n= max(left 0s - left 1s) + total 1s\\n```\\n>**T/S:** O(n)/O(1)\\n```\\npublic int maxScore(String s) {\\n\\tvar ones = 0;\\n\\tvar maxScore = Integer.MIN_VALUE;\\n\\n\\tfor (int i = 0, zeros = 0; i < s.length(); i++) {\\n\\t\\tif (s.charAt(i) == \\'0\\')\\n\\t\\t\\tzeros++;\\n\\t\\telse\\n\\t\\t\\tones++;\\n\\t\\tif (i < s.length() - 1) // since we want non-empty partitions\\n\\t\\t\\tmaxScore = Math.max(maxScore, zeros - ones);\\n\\t}\\n\\n\\treturn maxScore + ones;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxScore(String s) {\\n\\tvar n = s.length();\\n\\n\\tvar zeroes = new int[n];\\n\\tzeroes[0] = (s.charAt(0) == \\'0\\') ? 1 : 0;\\n\\n\\tvar ones = new int[n];\\n\\tones[n - 1] = (s.charAt(n - 1) == \\'1\\') ? 1 : 0;\\n\\n\\tfor (int i = 1, j = n - 2; i < n; i++, j--) {\\n\\t\\tzeroes[i] = zeroes[i - 1] + (s.charAt(i) == \\'0\\' ? 1 : 0);\\n\\t\\tones[j] = ones[j + 1] + (s.charAt(j) == \\'1\\' ? 1 : 0);\\n\\t}\\n\\n\\tvar maxScore = Integer.MIN_VALUE;\\n\\tfor (var i = 0; i + 1 < n; i++)\\n\\t\\tmaxScore = Math.max(maxScore, zeroes[i] + ones[i + 1]);\\n\\treturn maxScore;\\n}\\n```\n```\\nMax score = max(left 0s + right 1s)\\n= max(left 0s + total 1s - left 1s)\\n= max(left 0s - left 1s) + total 1s\\n```\n```\\npublic int maxScore(String s) {\\n\\tvar ones = 0;\\n\\tvar maxScore = Integer.MIN_VALUE;\\n\\n\\tfor (int i = 0, zeros = 0; i < s.length(); i++) {\\n\\t\\tif (s.charAt(i) == \\'0\\')\\n\\t\\t\\tzeros++;\\n\\t\\telse\\n\\t\\t\\tones++;\\n\\t\\tif (i < s.length() - 1) // since we want non-empty partitions\\n\\t\\t\\tmaxScore = Math.max(maxScore, zeros - ones);\\n\\t}\\n\\n\\treturn maxScore + ones;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597944,
                "title": "python3-linear-scan",
                "content": "Inspired by @vikrant_pc in this [thread](https://leetcode.com/problems/maximum-score-after-splitting-a-string/discuss/597716/Java-5-Liner-(One-Pass)). \\n\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        zeros = ones = 0\\n        ans = float(\"-inf\")\\n        \\n        for i in range(len(s)-1):\\n            if s[i] == \"0\": zeros += 1\\n            else: ones -= 1\\n            ans = max(ans, zeros + ones)\\n        \\n        return ans - ones + (1 if s[-1] == \"1\" else 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        zeros = ones = 0\\n        ans = float(\"-inf\")\\n        \\n        for i in range(len(s)-1):\\n            if s[i] == \"0\": zeros += 1\\n            else: ones -= 1\\n            ans = max(ans, zeros + ones)\\n        \\n        return ans - ones + (1 if s[-1] == \"1\" else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537032,
                "title": "go-clean-solution",
                "content": "```\\nfunc maxScore(s string) int {\\n    var result, totalOnes, leftZeros, leftOnes int\\n    \\n    for _, char := range s {\\n        if char == \\'1\\' {\\n            totalOnes++\\n        }\\n    }\\n    \\n    for i := 0; i < len(s)-1; i++ {\\n        if s[i] == \\'0\\' {\\n            leftZeros++\\n        } else {\\n            leftOnes++\\n        }\\n        \\n        result = max(result, leftZeros + totalOnes - leftOnes)\\n    }\\n    \\n    return result\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxScore(s string) int {\\n    var result, totalOnes, leftZeros, leftOnes int\\n    \\n    for _, char := range s {\\n        if char == \\'1\\' {\\n            totalOnes++\\n        }\\n    }\\n    \\n    for i := 0; i < len(s)-1; i++ {\\n        if s[i] == \\'0\\' {\\n            leftZeros++\\n        } else {\\n            leftOnes++\\n        }\\n        \\n        result = max(result, leftZeros + totalOnes - leftOnes)\\n    }\\n    \\n    return result\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2409364,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int O = count(begin(s),end(s),\\'1\\') ;\\n        int left = 0, right = 0 , ones = 0 , ans = 0 ;\\n        \\n        for(int i = 0 ; i < s.size() - 1 ; ++i){\\n            left += s[i] == \\'0\\' ;\\n            ones += s[i] == \\'1\\' ;\\n            right = O - ones ;\\n            ans = max(ans,right + left) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int O = count(begin(s),end(s),\\'1\\') ;\\n        int left = 0, right = 0 , ones = 0 , ans = 0 ;\\n        \\n        for(int i = 0 ; i < s.size() - 1 ; ++i){\\n            left += s[i] == \\'0\\' ;\\n            ones += s[i] == \\'1\\' ;\\n            right = O - ones ;\\n            ans = max(ans,right + left) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210734,
                "title": "c-simple-7-liner-o-n-sol-100-fast-no-extra-space",
                "content": "lc = count of zeros in left substring\\nrc = count of ones in right substring\\n```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int i, mx=0, lc=0, rc=0, n=s.length();\\n        \\n        for(i=0;i<n;i++)\\n            s[i]==\\'1\\'? rc++ : rc;\\n                \\n        for(i=0;i<n-1;i++){\\n            s[i] == \\'0\\'? lc++ : rc--;\\n            mx = max(mx, lc+rc);\\n        }\\n        \\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxScore(string s) {\\n        int i, mx=0, lc=0, rc=0, n=s.length();\\n        \\n        for(i=0;i<n;i++)\\n            s[i]==\\'1\\'? rc++ : rc;\\n                \\n        for(i=0;i<n-1;i++){\\n            s[i] == \\'0\\'? lc++ : rc--;\\n            mx = max(mx, lc+rc);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 874669,
                "title": "my-java-solution-single-pass",
                "content": "```\\n// the idea is to find thr total count of 0 and 1\\n// the required answer will (zeroLeft-oneLeft) + totalOneCount\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = Integer.MIN_VALUE;\\n        int zeroCount = 0;\\n        int oneCount = 0;\\n        for (int i=0; i<s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\')\\n                zeroCount += 1;\\n            else\\n                oneCount += 1;\\n            if (i != s.length()-1)\\n                max = Math.max(max, zeroCount - oneCount);\\n        }\\n        return max + oneCount;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// the idea is to find thr total count of 0 and 1\\n// the required answer will (zeroLeft-oneLeft) + totalOneCount\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = Integer.MIN_VALUE;\\n        int zeroCount = 0;\\n        int oneCount = 0;\\n        for (int i=0; i<s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\')\\n                zeroCount += 1;\\n            else\\n                oneCount += 1;\\n            if (i != s.length()-1)\\n                max = Math.max(max, zeroCount - oneCount);\\n        }\\n        return max + oneCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613260,
                "title": "javascript-solution",
                "content": "76ms, 37.5mb\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxScore = function(s) {\\n    let max = 0;\\n    for (let i = 1; i < s.length; i++) {\\n        const left = s.slice(0, i).split(\\'0\\').length - 1;\\n        const right = s.slice(i).split(\\'1\\').length - 1;\\n        let currentSum = left + right;\\n        max = Math.max(max, currentSum);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxScore = function(s) {\\n    let max = 0;\\n    for (let i = 1; i < s.length; i++) {\\n        const left = s.slice(0, i).split(\\'0\\').length - 1;\\n        const right = s.slice(i).split(\\'1\\').length - 1;\\n        let currentSum = left + right;\\n        max = Math.max(max, currentSum);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597691,
                "title": "c-simple-counts-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n\\t\\t// Time Complexity: O(n)\\n\\t\\t// Space Complexity: O(1)\\n\\t\\t\\n        int zeros(0), ones(0);\\n        \\n        for (const char& c: s)\\n            if (c == \\'1\\') ones++;\\n        \\n        s.pop_back();\\n        int ans(0);\\n        \\n        for (const char& c: s) {\\n            c == \\'0\\' ? zeros++ : ones--;\\n            ans = max(ans, zeros + ones);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n\\t\\t// Time Complexity: O(n)\\n\\t\\t// Space Complexity: O(1)\\n\\t\\t\\n        int zeros(0), ones(0);\\n        \\n        for (const char& c: s)\\n            if (c == \\'1\\') ones++;\\n        \\n        s.pop_back();\\n        int ans(0);\\n        \\n        for (const char& c: s) {\\n            c == \\'0\\' ? zeros++ : ones--;\\n            ans = max(ans, zeros + ones);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984113,
                "title": "python-3-two-pointers-approach",
                "content": "#### Example:\\n##### s = \"011101\"\\n```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        left, right = 0, 1 \\n        left_str, right_str = \\'\\', \\'\\'\\n        count = 0\\n        for i in range(len(s)-1):\\n            left_str += s[:left+1] #left_str = [0],[0,1],[0,1,1],[0,1,1,1],[0,1,1,1,0] \\n            right_str += s[right:] #right_str = [1,1,1,0,1],[1,1,0,1],[1,0,1],[0,1],[1]\\n            count = max(count, left_str.count(\\'0\\') + right_str.count(\\'1\\'))# stores the maximum of count\\n            left += 1\\n            right += 1\\n            right_str = \\'\\' \\n            left_str = \\'\\'\\n        return count\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        left, right = 0, 1 \\n        left_str, right_str = \\'\\', \\'\\'\\n        count = 0\\n        for i in range(len(s)-1):\\n            left_str += s[:left+1] #left_str = [0],[0,1],[0,1,1],[0,1,1,1],[0,1,1,1,0] \\n            right_str += s[right:] #right_str = [1,1,1,0,1],[1,1,0,1],[1,0,1],[0,1],[1]\\n            count = max(count, left_str.count(\\'0\\') + right_str.count(\\'1\\'))# stores the maximum of count\\n            left += 1\\n            right += 1\\n            right_str = \\'\\' \\n            left_str = \\'\\'\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817338,
                "title": "c-fastest-100-shortest-6-lines-o-n-time-o-1-space",
                "content": "Runtime: 0 ms, faster than 100.00%. Memory Usage: 6.2 MB, less than 87.85%.\\n```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int p = int(count(s.begin(), s.end(), \\'1\\')), mx = 0;\\n        for (int i = 0; i < s.length()-1; i++) {\\n            p += s[i] == \\'0\\' ? 1 : -1;\\n            mx = max(mx, p);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int p = int(count(s.begin(), s.end(), \\'1\\')), mx = 0;\\n        for (int i = 0; i < s.length()-1; i++) {\\n            p += s[i] == \\'0\\' ? 1 : -1;\\n            mx = max(mx, p);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598482,
                "title": "javascript-6-lines-o-n-count-ones-first",
                "content": "1. Count the fequency of 1 from s\\n2. If s[i] is 0 count up it to the variable `zero`.\\n3. Else if s[i] is 1 count down it to the variable `one`.\\n4.  Update result if `zero + one` is bigger than previous results.\\n- Time Complexity: O(n)\\n- Space Complexity: O(1)\\n```JavaScript\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxScore = function(s) {\\n    let zero = 0, one = [...s.matchAll(/1/g)].length, res = 0;\\n    for (let i = 0; i + 1 < s.length; i++) {\\n        s[i] === \"0\" ? zero++ : one--;\\n        res = Math.max(zero + one, res);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxScore = function(s) {\\n    let zero = 0, one = [...s.matchAll(/1/g)].length, res = 0;\\n    for (let i = 0; i + 1 < s.length; i++) {\\n        s[i] === \"0\" ? zero++ : one--;\\n        res = Math.max(zero + one, res);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2746276,
                "title": "python-easy-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        m,n=0,len(s)\\n        l=r=\\'\\'\\n        for i in range(1,n):\\n            l,r=s[:i],s[i:]\\n            c1=l.count(\\'0\\')\\n            c2=r.count(\\'1\\')\\n            m=max(m,c1+c2)\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        m,n=0,len(s)\\n        l=r=\\'\\'\\n        for i in range(1,n):\\n            l,r=s[:i],s[i:]\\n            c1=l.count(\\'0\\')\\n            c2=r.count(\\'1\\')\\n            m=max(m,c1+c2)\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738413,
                "title": "java-string-manipulation-modular-code",
                "content": "```\\nclass Solution {\\n    public int countOnes(String temp){\\n        int count = 0;\\n        for(char c : temp.toCharArray()){\\n            if(c == \\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int countZeroes(String temp){\\n        int count = 0;\\n        for(char c : temp.toCharArray()){\\n            if(c == \\'0\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int maxScore(String s) {\\n        int i = 0, max = Integer.MIN_VALUE;\\n        while(i<s.length()-1){\\n            String left = s.substring(0, i+1);\\n            String right = s.substring(i+1);\\n            int leftZeroes = countZeroes(left);\\n            int rightOnes = countOnes(right);\\n            max = Math.max(max, leftZeroes+rightOnes);\\n            i++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countOnes(String temp){\\n        int count = 0;\\n        for(char c : temp.toCharArray()){\\n            if(c == \\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int countZeroes(String temp){\\n        int count = 0;\\n        for(char c : temp.toCharArray()){\\n            if(c == \\'0\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int maxScore(String s) {\\n        int i = 0, max = Integer.MIN_VALUE;\\n        while(i<s.length()-1){\\n            String left = s.substring(0, i+1);\\n            String right = s.substring(i+1);\\n            int leftZeroes = countZeroes(left);\\n            int rightOnes = countOnes(right);\\n            max = Math.max(max, leftZeroes+rightOnes);\\n            i++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623894,
                "title": "c-solution-using-2-pointer-approch",
                "content": "class Solution {\\npublic:\\n    int maxScore(string s) \\n    {\\n        int ans=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            int cnt=0;\\n            int j=i;\\n            if(i!=s.length()-1)\\n            {\\n            for(int k=0;k<=j;k++)\\n            {\\n                if(s[k]==\\'0\\')\\n                    cnt+=1;\\n            }\\n            for(int k=j+1;k<s.length();k++)\\n            {\\n                if(s[k]==\\'1\\')\\n                {\\n                    cnt+=1;\\n                }\\n            }\\n           ans=max(cnt,ans);\\n            i++; \\n           }\\n        else\\n            {\\n               for(int k=0;k<i;k++)\\n               {\\n                  if(s[k]==\\'0\\')\\n                      cnt+=1;\\n               }\\n                if(s[i]==\\'1\\')\\n                    cnt+=1;\\n                ans=max(cnt,ans);\\n            i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxScore(string s) \\n    {\\n        int ans=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            int cnt=0;\\n            int j=i;\\n            if(i!=s.length()-1)\\n            {\\n            for(int k=0;k<=j;k++)\\n            {\\n                if(s[k]==\\'0\\')\\n                    cnt+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1579977,
                "title": "python-clever-one-liner",
                "content": "```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        return max([s[:i].count(\\'0\\') + s[i:].count(\\'1\\') for i in range(1, len(s))])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        return max([s[:i].count(\\'0\\') + s[i:].count(\\'1\\') for i in range(1, len(s))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281773,
                "title": "python-3-o-n",
                "content": "\\tdef maxScore(self, s: str) -> int:\\n\\t\\t\\tscore = 0 \\n\\t\\t\\ts = list(map(int,s))\\n\\t\\t\\tfor i in range(1,len(s)):\\n\\t\\t\\t\\tleft = s[:i]\\n\\t\\t\\t\\tright = s[i:]\\n\\t\\t\\t\\ttemp_score = left.count(0) + right.count(1)\\n\\t\\t\\t\\tif temp_score > score:\\n\\t\\t\\t\\t\\tscore = temp_score\\n\\t\\t\\treturn score\\nIf you like the solution, UPVOTE. Motivates a lot. Thanks.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef maxScore(self, s: str) -> int:\\n\\t\\t\\tscore = 0 \\n\\t\\t\\ts = list(map(int,s))\\n\\t\\t\\tfor i in range(1,len(s)):\\n\\t\\t\\t\\tleft = s[:i]\\n\\t\\t\\t\\tright = s[i:]\\n\\t\\t\\t\\ttemp_score = left.count(0) + right.count(1)\\n\\t\\t\\t\\tif temp_score > score:\\n\\t\\t\\t\\t\\tscore = temp_score\\n\\t\\t\\treturn score\\nIf you like the solution, UPVOTE. Motivates a lot. Thanks.",
                "codeTag": "Python3"
            },
            {
                "id": 1255748,
                "title": "java-simple-and-o-n-time-and-space",
                "content": "```class Solution {\\n    public int maxScore(String s) {\\n        int maxScore = 0;\\n        int numOnes = 0;\\n        int numZeros = 0;\\n        \\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') numOnes++;\\n        }\\n        \\n        for(int i = 0; i < s.length() - 1; i++) {\\n            if(s.charAt(i) == \\'0\\') numZeros++;\\n            else numOnes--;\\n            \\n            if(maxScore < numOnes + numZeros) maxScore = numOnes + numZeros;\\n        }\\n        \\n        return maxScore;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxScore(String s) {\\n        int maxScore = 0;\\n        int numOnes = 0;\\n        int numZeros = 0;\\n        \\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') numOnes++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1057309,
                "title": "java-beats-100-time-90-space-according-to-hints-given-easy-solution",
                "content": "```\\npublic int maxScore(String s) {\\n        int max=0;\\n        int count1=0;\\n        int count0=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                count1+=1;\\n            }\\n        }\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                count0+=1;\\n            }\\n            else{\\n                count1--;\\n            }\\n            int d=count0+count1;\\n            if(d>max){\\n                max=d;\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxScore(String s) {\\n        int max=0;\\n        int count1=0;\\n        int count0=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                count1+=1;\\n            }\\n        }\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                count0+=1;\\n            }\\n            else{\\n                count1--;\\n            }\\n            int d=count0+count1;\\n            if(d>max){\\n                max=d;\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 889767,
                "title": "python-solution-97-6-faster-100-memory-usage",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        ones = sum(1 for c in s if c == \\'1\\')\\n        ans = 0\\n        n_ones = 0\\n        for i in range(len(s)-1):\\n            if s[i] == \\'1\\':\\n                n_ones += 1\\n            ans = max(ans, (i + 1 - n_ones) + (ones - n_ones))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        ones = sum(1 for c in s if c == \\'1\\')\\n        ans = 0\\n        n_ones = 0\\n        for i in range(len(s)-1):\\n            if s[i] == \\'1\\':\\n                n_ones += 1\\n            ans = max(ans, (i + 1 - n_ones) + (ones - n_ones))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826030,
                "title": "c-2-solutions",
                "content": "**C++**\\n\\n**(1) Transform**\\nOriginal Solution : Max( zeroOnLeft + oneOnright);\\n=>Max (zeroOnLeft + (oneOnAll - oneOnLeft) )\\n=>Max (zeroOnLeft - oneOnLeft) + oneOnAll\\n```\\nint maxScore(string s) {\\n\\tint zero=0, one=0, maximum=INT_MIN, n =s.size();\\n\\tfor(auto &c:s.substr(0,n-1)){\\n\\t  c==\\'1\\'?one++:zero++;\\n\\t  maximum = max(zero-one,maximum);\\n\\t}\\n\\treturn maximum+one+(s.back()==\\'1\\');\\n}\\n```\\n**(2) Count**\\n```\\nint maxScore(string s) {\\n\\tstring left, right;\\n\\tint maximum=0,sum=0;\\n\\tfor(int i=1;i<=s.size()-1;++i){\\n\\t  left = s.substr(0,i), right = s.substr(i);\\n\\t  sum = count(begin(left),end(left),\\'0\\') + count(begin(right),end(right),\\'1\\');\\n\\t  maximum = max(maximum, sum);\\n\\t}\\n\\treturn maximum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxScore(string s) {\\n\\tint zero=0, one=0, maximum=INT_MIN, n =s.size();\\n\\tfor(auto &c:s.substr(0,n-1)){\\n\\t  c==\\'1\\'?one++:zero++;\\n\\t  maximum = max(zero-one,maximum);\\n\\t}\\n\\treturn maximum+one+(s.back()==\\'1\\');\\n}\\n```\n```\\nint maxScore(string s) {\\n\\tstring left, right;\\n\\tint maximum=0,sum=0;\\n\\tfor(int i=1;i<=s.size()-1;++i){\\n\\t  left = s.substr(0,i), right = s.substr(i);\\n\\t  sum = count(begin(left),end(left),\\'0\\') + count(begin(right),end(right),\\'1\\');\\n\\t  maximum = max(maximum, sum);\\n\\t}\\n\\treturn maximum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746343,
                "title": "java-simple-two-pass-solution",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int scoreRight = 0;\\n        int scoreLeft = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                scoreRight++;\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                scoreRight--;\\n            } else {\\n                scoreLeft++;\\n            }\\n            \\n            answer = Math.max(scoreLeft + scoreRight, answer);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int scoreRight = 0;\\n        int scoreLeft = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                scoreRight++;\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                scoreRight--;\\n            } else {\\n                scoreLeft++;\\n            }\\n            \\n            answer = Math.max(scoreLeft + scoreRight, answer);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645869,
                "title": "java-2-pass-counting-ones-and-zeroes",
                "content": "\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int left = 0;\\n        int right = 0;\\n        int total = 0;\\n        if (s.length() == 0) return total;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            if (s.charAt(i) == \\'1\\') right++;\\n        }\\n        \\n        for (int i=0;i<s.length()-1;i++) {\\n            if (s.charAt(i) == \\'0\\') left++;\\n            if (s.charAt(i) == \\'1\\') right--;\\n            total = Math.max(total, left+right);\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int left = 0;\\n        int right = 0;\\n        int total = 0;\\n        if (s.length() == 0) return total;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            if (s.charAt(i) == \\'1\\') right++;\\n        }\\n        \\n        for (int i=0;i<s.length()-1;i++) {\\n            if (s.charAt(i) == \\'0\\') left++;\\n            if (s.charAt(i) == \\'1\\') right--;\\n            total = Math.max(total, left+right);\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601882,
                "title": "python-o-n-time-o-1-space-clear-logic",
                "content": "Count all the ones in s, and scan s. At each char, we use it in the left substring, when we see a zero, increment zero counter because it counts in the left substring. When we see a one, decrement the total ones, because the right substring now has less one.\\n\\nNote that we exclude the last character in s, because the right substring can\\'t be empty, so it at least uses the last char.\\n\\n```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        ones = sum(c == \\'1\\' for c in s)\\n        ans = zeros = 0\\n        for c in s[:-1]:\\n            if c == \\'0\\':\\n                zeros += 1\\n            else:\\n                ones -= 1\\n            ans = max(ans, zeros + ones)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        ones = sum(c == \\'1\\' for c in s)\\n        ans = zeros = 0\\n        for c in s[:-1]:\\n            if c == \\'0\\':\\n                zeros += 1\\n            else:\\n                ones -= 1\\n            ans = max(ans, zeros + ones)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601297,
                "title": "go-very-simple-solution",
                "content": "```go\\nfunc maxScore(s string) int {\\n\\tcount0, count1 := 0, 0\\n\\tfor _, v := range s {\\n\\t\\tif v == \\'0\\' {\\n\\t\\t\\tcount0++\\n\\t\\t} else {\\n\\t\\t\\tcount1++\\n\\t\\t}\\n\\t}\\n\\tcurrentScore, maxScore := count1, 0\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tif s[i] == \\'0\\' {\\n\\t\\t\\tcurrentScore++\\n\\t\\t} else {\\n\\t\\t\\tcurrentScore--\\n\\t\\t}\\n\\t\\tif currentScore > maxScore {\\n\\t\\t\\tmaxScore = currentScore\\n\\t\\t}\\n\\t}\\n\\treturn maxScore\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxScore(s string) int {\\n\\tcount0, count1 := 0, 0\\n\\tfor _, v := range s {\\n\\t\\tif v == \\'0\\' {\\n\\t\\t\\tcount0++\\n\\t\\t} else {\\n\\t\\t\\tcount1++\\n\\t\\t}\\n\\t}\\n\\tcurrentScore, maxScore := count1, 0\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tif s[i] == \\'0\\' {\\n\\t\\t\\tcurrentScore++\\n\\t\\t} else {\\n\\t\\t\\tcurrentScore--\\n\\t\\t}\\n\\t\\tif currentScore > maxScore {\\n\\t\\t\\tmaxScore = currentScore\\n\\t\\t}\\n\\t}\\n\\treturn maxScore\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 598392,
                "title": "c-explainations-included",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        if(s.length() == 0) return 0;  //base case \\n        int total_one = 0;\\n        int total_zero = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i] == \\'1\\')                // count the total no. of numbers of one present in the array\\n                total_one++;\\n        }\\n       \\n        int return_ans = 0;\\n        for(int i  = 0; i < s.length() -1; i++){     \\n            if(s[i] == \\'0\\'){           // if you find 0 in the array, jus increment the count to make sure that the zero moved to the left subarray\\n                total_zero++;\\n            }\\n            else\\n                total_one--;        //decrement the total_one (1 counter) to make sure that the 1 moved to the left sub array!\\n            return_ans = max(return_ans, total_one + total_zero);\\n        }\\n        return return_ans;\\n    }\\n};\\n```\\n\\nUpvote if you found it useful and if there is any optimization please comment down!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        if(s.length() == 0) return 0;  //base case \\n        int total_one = 0;\\n        int total_zero = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i] == \\'1\\')                // count the total no. of numbers of one present in the array\\n                total_one++;\\n        }\\n       \\n        int return_ans = 0;\\n        for(int i  = 0; i < s.length() -1; i++){     \\n            if(s[i] == \\'0\\'){           // if you find 0 in the array, jus increment the count to make sure that the zero moved to the left subarray\\n                total_zero++;\\n            }\\n            else\\n                total_one--;        //decrement the total_one (1 counter) to make sure that the 1 moved to the left sub array!\\n            return_ans = max(return_ans, total_one + total_zero);\\n        }\\n        return return_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597799,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        long ans = 0;\\n        for(int i=1;i<s.length();i++){\\n            String left = s.substring(0,i);\\n            String right = s.substring(i);\\n            long x = left.chars().map(c -> (char)c).filter(c -> c == \\'0\\').count();\\n            long y = right.chars().map(c -> (char)c).filter(c -> c == \\'1\\').count();\\n            ans = Math.max(ans,x+y);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        long ans = 0;\\n        for(int i=1;i<s.length();i++){\\n            String left = s.substring(0,i);\\n            String right = s.substring(i);\\n            long x = left.chars().map(c -> (char)c).filter(c -> c == \\'0\\').count();\\n            long y = right.chars().map(c -> (char)c).filter(c -> c == \\'1\\').count();\\n            ans = Math.max(ans,x+y);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597700,
                "title": "c-count",
                "content": "Split a 0-1 string into two parts, what is the maximum sum of number of zeros in the left part and number of ones in the right part?\\n\\n# Explanation\\n\\nJust count the number of 0s and 1s in the whole string, and then calculate the number of 0s in every left substring.\\n\\nThe time complexity is O(n).\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int zeroSum = 0, oneSum = 0;\\n        for (char c: s)\\n            if (c == \\'0\\') zeroSum++;\\n            else oneSum++;\\n        \\n        int zeros = 0, ones = 0;\\n        int ans = -1;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s[i] == \\'0\\') zeros++;\\n            else ones++;\\n            ans = max(ans, zeros + oneSum - ones);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int zeroSum = 0, oneSum = 0;\\n        for (char c: s)\\n            if (c == \\'0\\') zeroSum++;\\n            else oneSum++;\\n        \\n        int zeros = 0, ones = 0;\\n        int ans = -1;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s[i] == \\'0\\') zeros++;\\n            else ones++;\\n            ans = max(ans, zeros + oneSum - ones);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324165,
                "title": "python-simple-beginner-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        cnt = 0\\n        for i in range(1, len(s)):\\n            cnt = max(cnt, (s[:i].count(\\'0\\') + s[i:].count(\\'1\\')))\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        cnt = 0\\n        for i in range(1, len(s)):\\n            cnt = max(cnt, (s[:i].count(\\'0\\') + s[i:].count(\\'1\\')))\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294783,
                "title": "maximum-score-after-splitting-a-string-java-1ms-beats-97-82",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can split the string at each index and count the number of zeros and ones in the left and right substrings. The score for each split is the sum of the number of zeros in the left substring and the number of ones in the right substring. We can then return the maximum score seen so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first count the number of zeros and ones in the input string. We then initialize the maximum score to 0 and the counters for the number of zeros and ones in the left and right substrings. We then iterate over the input string and split it at each index. We calculate the number of zeros in the left substring by incrementing the counter for each \\'0\\' encountered. We calculate the number of ones in the right substring by decrementing the counter for each \\'1\\' encountered. We then update the maximum score seen so far by taking the maximum of the current score and the maximum score seen so far. Finally, we return the maximum score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe function iterates over the input string twice. Therefore, the time complexity of the function is O(n), where n is the length of the input string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe function uses constant extra space to store the counters for the number of zeros and ones in the left and right substrings. Therefore, the space complexity of the function is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int zeros = 0 ; \\n        int ones = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'0\\')\\n            {\\n                zeros++;\\n            }\\n            else\\n            {\\n                ones++;\\n            }\\n        }\\n\\n        int maxScore = 0;\\n        int leftZeros = 0; \\n        int rightOnes = ones;\\n        for(int i = 0 ; i < s.length() - 1; i++)\\n        {\\n            if(s.charAt(i) == \\'0\\')\\n            {\\n                leftZeros++;\\n            }\\n            else\\n            {\\n                rightOnes--;\\n            }\\n\\n            maxScore = Math.max(maxScore, leftZeros + rightOnes);\\n        }\\n\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int zeros = 0 ; \\n        int ones = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'0\\')\\n            {\\n                zeros++;\\n            }\\n            else\\n            {\\n                ones++;\\n            }\\n        }\\n\\n        int maxScore = 0;\\n        int leftZeros = 0; \\n        int rightOnes = ones;\\n        for(int i = 0 ; i < s.length() - 1; i++)\\n        {\\n            if(s.charAt(i) == \\'0\\')\\n            {\\n                leftZeros++;\\n            }\\n            else\\n            {\\n                rightOnes--;\\n            }\\n\\n            maxScore = Math.max(maxScore, leftZeros + rightOnes);\\n        }\\n\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215551,
                "title": "javascript-logic",
                "content": "# Code\\n```\\n// T: O(n) | S: O(1)\\nvar maxScore = function(s) {\\n    let l = 0;\\n    let r = s.split(\\'\\').filter(x => x === \\'1\\').length;\\n    let max = 0;\\n    for (let i = 0; i < s.length - 1; i++) {\\n        s[i] === \\'0\\' ? l++ : r--;\\n        max = Math.max(max, l + r);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// T: O(n) | S: O(1)\\nvar maxScore = function(s) {\\n    let l = 0;\\n    let r = s.split(\\'\\').filter(x => x === \\'1\\').length;\\n    let max = 0;\\n    for (let i = 0; i < s.length - 1; i++) {\\n        s[i] === \\'0\\' ? l++ : r--;\\n        max = Math.max(max, l + r);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3196314,
                "title": "faster-than-100-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        vector<int> arr(s.size());\\n        if (s[0] == \\'1\\') {\\n            arr[0] = 1;\\n        } else {\\n            arr[0] = 0;\\n        }\\n        for (int i = 1; i < s.size(); ++i) {\\n            arr[i] = arr[i - 1] + (s[i] == \\'1\\');\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size()-1; ++i) {\\n            ans = max(ans, arr[s.size() - 1] - arr[i] + (i + 1 - arr[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        vector<int> arr(s.size());\\n        if (s[0] == \\'1\\') {\\n            arr[0] = 1;\\n        } else {\\n            arr[0] = 0;\\n        }\\n        for (int i = 1; i < s.size(); ++i) {\\n            arr[i] = arr[i - 1] + (s[i] == \\'1\\');\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < s.size()-1; ++i) {\\n            ans = max(ans, arr[s.size() - 1] - arr[i] + (i + 1 - arr[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105730,
                "title": "just-count-do-sum-and-boomm-in-o-n-time-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncount \\'0\\' and \\'1\\'. Do sum conditionally.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst of all count how many one have the input sitring and store the result. again loop thorugh the string and check how many \\'0\\' and \\'1\\' have traversed. do the sum of remaining number of one and number of \\'0\\' we already traversed. if the sum is bigger than previous sum. update the sum. that\\'s it.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        countOne = 0\\n        for ele in s:\\n            if ele == \"1\":\\n                countOne += 1\\n\\n\\n        zero = 0\\n        one = 0\\n\\n        ans = 0\\n        for i, ele in enumerate(s):\\n\\n            if i > 0:\\n                right1 = countOne - one\\n                print(zero, right1)\\n                if ans < zero + right1:\\n                    ans = zero + right1\\n\\n            if ele == \"1\":\\n                one += 1\\n            else:\\n                zero += 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        countOne = 0\\n        for ele in s:\\n            if ele == \"1\":\\n                countOne += 1\\n\\n\\n        zero = 0\\n        one = 0\\n\\n        ans = 0\\n        for i, ele in enumerate(s):\\n\\n            if i > 0:\\n                right1 = countOne - one\\n                print(zero, right1)\\n                if ans < zero + right1:\\n                    ans = zero + right1\\n\\n            if ele == \"1\":\\n                one += 1\\n            else:\\n                zero += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683791,
                "title": "java-javascript-solution-jw",
                "content": "Java:\\n```\\npublic int maxScore(String s) {\\n\\tint zeros = 0, ones = 0, max = Integer.MIN_VALUE;\\n\\tfor(int i = 0;i < s.length();i++) {\\n\\t\\tif(s.charAt(i) == \\'0\\') {\\n\\t\\t\\tzeros++;\\n\\t\\t} else {\\n\\t\\t\\tones++;\\n\\t\\t}\\n\\t\\tif(i != s.length()-1) {\\n\\t\\t\\tmax = Math.max(zeros - ones, max);\\n\\t\\t}\\n\\t}\\n\\treturn max + ones;\\n}\\n```\\n\\nJavascript:\\n```\\nvar maxScore = function(s) {\\n    let zeros = 0, ones = 0, max = -Number.MAX_VALUE;\\n    for(let i = 0;i < s.length;i++) {\\n        if(s.charAt(i) === \\'0\\') {\\n            zeros++;\\n        } else {\\n            ones++;\\n        }\\n        if(i !== s.length - 1) {\\n            max = Math.max(zeros - ones, max);\\n        }\\n    }\\n    return max + ones;\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic int maxScore(String s) {\\n\\tint zeros = 0, ones = 0, max = Integer.MIN_VALUE;\\n\\tfor(int i = 0;i < s.length();i++) {\\n\\t\\tif(s.charAt(i) == \\'0\\') {\\n\\t\\t\\tzeros++;\\n\\t\\t} else {\\n\\t\\t\\tones++;\\n\\t\\t}\\n\\t\\tif(i != s.length()-1) {\\n\\t\\t\\tmax = Math.max(zeros - ones, max);\\n\\t\\t}\\n\\t}\\n\\treturn max + ones;\\n}\\n```\n```\\nvar maxScore = function(s) {\\n    let zeros = 0, ones = 0, max = -Number.MAX_VALUE;\\n    for(let i = 0;i < s.length;i++) {\\n        if(s.charAt(i) === \\'0\\') {\\n            zeros++;\\n        } else {\\n            ones++;\\n        }\\n        if(i !== s.length - 1) {\\n            max = Math.max(zeros - ones, max);\\n        }\\n    }\\n    return max + ones;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2536118,
                "title": "python-easy-slicing",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        \\n        res = []\\n        \\n        for i in range(len(s)):\\n            left = s[:i+1]\\n            right = s[i+1:]\\n            \\n            if len(right)==0:\\n                break\\n            res.append(left.count(\"0\")+right.count(\"1\"))    \\n                \\n        return max(res)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        \\n        res = []\\n        \\n        for i in range(len(s)):\\n            left = s[:i+1]\\n            right = s[i+1:]\\n            \\n            if len(right)==0:\\n                break\\n            res.append(left.count(\"0\")+right.count(\"1\"))    \\n                \\n        return max(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362979,
                "title": "java-solution-easy-to-understand-easy-code",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < s.length() - 1; i++){\\n            String left = s.substring(0, i+1);\\n            String right = s.substring(i+1);\\n            int sum = (helper(left, \\'0\\') + helper(right, \\'1\\'));\\n            max = Integer.max(max, sum);\\n        }\\n        return max;\\n    }\\n\\n    private static int helper(String str, char i) {\\n        int count = 0;\\n\\n        for (char c : str.toCharArray()){\\n            if (c == i) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < s.length() - 1; i++){\\n            String left = s.substring(0, i+1);\\n            String right = s.substring(i+1);\\n            int sum = (helper(left, \\'0\\') + helper(right, \\'1\\'));\\n            max = Integer.max(max, sum);\\n        }\\n        return max;\\n    }\\n\\n    private static int helper(String str, char i) {\\n        int count = 0;\\n\\n        for (char c : str.toCharArray()){\\n            if (c == i) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210985,
                "title": "c-easy-o-n-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/b03da33c-7d32-4939-bf1e-769246a7cb73_1656432636.752572.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxScore(string s) {\\n\\t\\t\\tint ans=0,l=0,r=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\')r++;\\n\\t\\t\\t}        \\n\\t\\t\\tfor(int i=0;i<s.size()-1;i++){\\n\\t\\t\\t\\tif(s[i]==\\'0\\')l++;\\n\\t\\t\\t\\telse r--;\\n\\t\\t\\t\\tans=max(ans,l+r);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxScore(string s) {\\n\\t\\t\\tint ans=0,l=0,r=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\')r++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2198674,
                "title": "python-one-line-solution",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        \\n        return max([s[:i].count(\\'0\\')+s[i:].count(\\'1\\') for i in range(1, len(s))])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        \\n        return max([s[:i].count(\\'0\\')+s[i:].count(\\'1\\') for i in range(1, len(s))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152247,
                "title": "1422-java-o-n-solution-but-only-beats-60-why",
                "content": "Should be O(n) time time complexity but not sure why it only beats 60% ? Optimization advice ? \\n\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        \\n        int n = s.length();\\n        \\n        int[] ps0 = new int[n+1]; // presum of 0\\n        int[] ps1 = new int[n+1]; // presum of 1\\n        \\n        \\n        for (int i = 1; i <= n; i++) {\\n            ps0[i] = ps0[i-1] + (s.charAt(i-1)==\\'0\\'? 1 : 0);\\n            ps1[i] = ps1[i-1] + (s.charAt(i-1)== \\'1\\' ? 1:0);\\n        }\\n        \\n        int res = 0;\\n        // split into 2 **non-empty** substring\\n        // X|XXXXX\\n        // i|\\n        // ps0[i]-ps[0]\\n        // ps1[n]-ps[i]\\n        for (int i = 1; i <= n-1; i++) {\\n            int sum = ps0[i] + (ps1[n] - ps1[i]);\\n            res = Math.max(res, sum);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        \\n        int n = s.length();\\n        \\n        int[] ps0 = new int[n+1]; // presum of 0\\n        int[] ps1 = new int[n+1]; // presum of 1\\n        \\n        \\n        for (int i = 1; i <= n; i++) {\\n            ps0[i] = ps0[i-1] + (s.charAt(i-1)==\\'0\\'? 1 : 0);\\n            ps1[i] = ps1[i-1] + (s.charAt(i-1)== \\'1\\' ? 1:0);\\n        }\\n        \\n        int res = 0;\\n        // split into 2 **non-empty** substring\\n        // X|XXXXX\\n        // i|\\n        // ps0[i]-ps[0]\\n        // ps1[n]-ps[i]\\n        for (int i = 1; i <= n-1; i++) {\\n            int sum = ps0[i] + (ps1[n] - ps1[i]);\\n            res = Math.max(res, sum);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978278,
                "title": "simple-python-solution-minimal-logic",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maxScore(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tscore=[]\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tleft=s[:i+1]\\n\\t\\t\\t\\tright=s[i+1:]\\n\\t\\t\\t\\tcnt=left.count(\\'0\\')+right.count(\\'1\\')\\n\\t\\t\\t\\tscore.append(cnt)\\n\\t\\t\\treturn max(score)",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef maxScore(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tscore=[]\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tleft=s[:i+1]\\n\\t\\t\\t\\tright=s[i+1:]\\n\\t\\t\\t\\tcnt=left.count(\\'0\\')+right.count(\\'1\\')\\n\\t\\t\\t\\tscore.append(cnt)\\n\\t\\t\\treturn max(score)",
                "codeTag": "Java"
            },
            {
                "id": 1919233,
                "title": "python-greedy",
                "content": "Setup `left` and `right` counter which represent the left zeros / right ones, and since we start from index = 0, we initialize `left=0`, `right=<all ones in string>`, means we start from no zeros and all ones.\\n\\nUpdate the counter and result through the iteration (greedy) and that\\'s it.\\n\\nNotice that it\\'s no allowed to have empty string, so our iteration will stop at `i == len(s) - 1`\\n\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n\\n        left, right = 0, sum(map(int, s))\\n        \\n        ans = 0\\n        \\n        for i in range(len(s) - 1):\\n            \\n            if s[i] == \\'0\\':\\n                left += 1\\n            else:\\n                right -= 1\\n                \\n            ans = max(ans, left + right)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n\\n        left, right = 0, sum(map(int, s))\\n        \\n        ans = 0\\n        \\n        for i in range(len(s) - 1):\\n            \\n            if s[i] == \\'0\\':\\n                left += 1\\n            else:\\n                right -= 1\\n                \\n            ans = max(ans, left + right)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746502,
                "title": "java-two-pass-solution-faster-than-98-easy",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int cnt =0;\\n        for(char ch:s.toCharArray())\\n            cnt+= ch == \\'1\\'?1:0;\\n        int zro =0;\\n        int max=0;\\n        for(int i=0;i<s.length()-1;i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'0\\')\\n                zro++;\\n            else cnt--;\\n            max = Math.max(zro+cnt,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int cnt =0;\\n        for(char ch:s.toCharArray())\\n            cnt+= ch == \\'1\\'?1:0;\\n        int zro =0;\\n        int max=0;\\n        for(int i=0;i<s.length()-1;i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'0\\')\\n                zro++;\\n            else cnt--;\\n            max = Math.max(zro+cnt,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573331,
                "title": "c-100-time-99-space-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int zero=0,one=0,sum=0;\\n       if(s[0]==\\'0\\')\\n           zero++;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==\\'1\\')\\n                one++;\\n        }\\n        sum=zero+one;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==\\'1\\')\\n                one--;\\n            else if(i<s.size()-1){\\n                zero++;\\n            }\\n            sum=max(sum,(one+zero));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int zero=0,one=0,sum=0;\\n       if(s[0]==\\'0\\')\\n           zero++;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==\\'1\\')\\n                one++;\\n        }\\n        sum=zero+one;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==\\'1\\')\\n                one--;\\n            else if(i<s.size()-1){\\n                zero++;\\n            }\\n            sum=max(sum,(one+zero));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572206,
                "title": "java-easy-o-n-solution",
                "content": "```\\n     public int maxScore(String s) {\\n        int maxScore = 0, numberOfOnes = 0, numberOfZeroes = 0, length = s.length();\\n        for (int i = 0; i < length; i++) {\\n            if (s.charAt(i) == \\'1\\') numberOfOnes++;\\n        }\\n        if (numberOfOnes == length) return length - 1;\\n        else if (numberOfOnes == 0) return length - 1;\\n        for (int i = 0; i < length; i++) {\\n            if (s.charAt(i) == \\'0\\' && i < length - 1) {\\n                numberOfZeroes ++;\\n                if ((numberOfZeroes + numberOfOnes) > maxScore) maxScore = numberOfOnes + numberOfZeroes;\\n            } else numberOfOnes--;\\n            if ((numberOfZeroes + numberOfOnes) > maxScore) maxScore = numberOfOnes + numberOfZeroes;\\n        }\\n        return maxScore;\\n    }",
                "solutionTags": [],
                "code": "```\\n     public int maxScore(String s) {\\n        int maxScore = 0, numberOfOnes = 0, numberOfZeroes = 0, length = s.length();\\n        for (int i = 0; i < length; i++) {\\n            if (s.charAt(i) == \\'1\\') numberOfOnes++;\\n        }\\n        if (numberOfOnes == length) return length - 1;\\n        else if (numberOfOnes == 0) return length - 1;\\n        for (int i = 0; i < length; i++) {\\n            if (s.charAt(i) == \\'0\\' && i < length - 1) {\\n                numberOfZeroes ++;\\n                if ((numberOfZeroes + numberOfOnes) > maxScore) maxScore = numberOfOnes + numberOfZeroes;\\n            } else numberOfOnes--;\\n            if ((numberOfZeroes + numberOfOnes) > maxScore) maxScore = numberOfOnes + numberOfZeroes;\\n        }\\n        return maxScore;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1548741,
                "title": "python3-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        right=s.count(\\'1\\')\\n        left=0\\n        res=0\\n        for i in range(len(s)-1):\\n            if s[i]==\\'0\\':\\n                left+=1\\n            else:\\n                right-=1\\n            res=max(res,left+right)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        right=s.count(\\'1\\')\\n        left=0\\n        res=0\\n        for i in range(len(s)-1):\\n            if s[i]==\\'0\\':\\n                left+=1\\n            else:\\n                right-=1\\n            res=max(res,left+right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453225,
                "title": "easy-c-solution-o-n-tc-o-n-sc",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int maxScore(string s) \\n    {\\n        int n=s.length(),zero=0,one=0,score=0;\\n        vector<int>left(n),right(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            zero+=s[i]==\\'0\\'?1:0;\\n            one+=s[n-i-1]==\\'1\\'?1:0;\\n            left[i]=zero;\\n            right[n-i-1]=one;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i+1<n)\\n            {\\n                score=max(score,left[i]+right[i+1]);\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxScore(string s) \\n    {\\n        int n=s.length(),zero=0,one=0,score=0;\\n        vector<int>left(n),right(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            zero+=s[i]==\\'0\\'?1:0;\\n            one+=s[n-i-1]==\\'1\\'?1:0;\\n            left[i]=zero;\\n            right[n-i-1]=one;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i+1<n)\\n            {\\n                score=max(score,left[i]+right[i+1]);\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442256,
                "title": "easy-c-one-pass-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int m=0;\\n        int zero=0, one=0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                one++;\\n        }\\n        \\n        for(int i=0; i<s.size()-1; i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                zero++;\\n            else\\n                one--;\\n            m=max(m, zero+one);\\n        }\\n        return m; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int m=0;\\n        int zero=0, one=0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                one++;\\n        }\\n        \\n        for(int i=0; i<s.size()-1; i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                zero++;\\n            else\\n                one--;\\n            m=max(m, zero+one);\\n        }\\n        return m; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403782,
                "title": "80-faster-python-solution",
                "content": "```\\n\\tif s.count(\"1\") == len(s) or s.count(\"0\") == len(s):\\n            return len(s)-1\\n        max_value = 0 \\n        for i in range(1,len(s)):\\n            if (s[:i].count(\"0\")+s[i:].count(\"1\")) > max_value:\\n                max_value = (s[:i].count(\"0\")+s[i:].count(\"1\"))\\n        return max_value\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n\\tif s.count(\"1\") == len(s) or s.count(\"0\") == len(s):\\n            return len(s)-1\\n        max_value = 0 \\n        for i in range(1,len(s)):\\n            if (s[:i].count(\"0\")+s[i:].count(\"1\")) > max_value:\\n                max_value = (s[:i].count(\"0\")+s[i:].count(\"1\"))\\n        return max_value\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1335448,
                "title": "js-solution",
                "content": "```\\nvar maxScore = function(s) {\\n    let allScores = [];\\n    for(let i=1; i<s.length; i++){\\n        let num1 = s.substr(0,i).replace(/1/g, \"\").length;\\n        let num2 = s.slice(i).replace(/0/g, \"\").length;\\n        allScores.push(num1 + num2);\\n    }\\n    return Math.max(...allScores);\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxScore = function(s) {\\n    let allScores = [];\\n    for(let i=1; i<s.length; i++){\\n        let num1 = s.substr(0,i).replace(/1/g, \"\").length;\\n        let num2 = s.slice(i).replace(/0/g, \"\").length;\\n        allScores.push(num1 + num2);\\n    }\\n    return Math.max(...allScores);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333160,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int totalOnes = 0;\\n        for(int i=0;i<s.length();i++)\\n            if(s.charAt(i)-\\'0\\' == 1)\\n                totalOnes++;\\n        if(totalOnes == s.length() || totalOnes == 0)\\n            return s.length()-1;\\n        int result = 0;\\n        //Let i be the current partition during the loop.\\n        int zeroCount = 0;\\n        boolean divide = false;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            zeroCount += (s.charAt(i)-\\'0\\' == 0) ? 1 : 0;\\n            totalOnes += (s.charAt(i)-\\'0\\' == 1) ? -1 : 0; \\n            result = Math.max(result,(zeroCount+totalOnes));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int totalOnes = 0;\\n        for(int i=0;i<s.length();i++)\\n            if(s.charAt(i)-\\'0\\' == 1)\\n                totalOnes++;\\n        if(totalOnes == s.length() || totalOnes == 0)\\n            return s.length()-1;\\n        int result = 0;\\n        //Let i be the current partition during the loop.\\n        int zeroCount = 0;\\n        boolean divide = false;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            zeroCount += (s.charAt(i)-\\'0\\' == 0) ? 1 : 0;\\n            totalOnes += (s.charAt(i)-\\'0\\' == 1) ? -1 : 0; \\n            result = Math.max(result,(zeroCount+totalOnes));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270585,
                "title": "python-simple-solution-o-n-time-o-1-space",
                "content": "```python\\ndef maxScore(self, s: str) -> int:\\n        count_one, count_zero, max_ = s.count(\\'1\\'), 0, 0\\n        for i in range(len(s)-1):\\n            count_zero += s[i] == \\'0\\'\\n            count_one -= s[i] == \\'1\\'\\n            max_ = max(max_, count_zero+count_one)\\n        return max_\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef maxScore(self, s: str) -> int:\\n        count_one, count_zero, max_ = s.count(\\'1\\'), 0, 0\\n        for i in range(len(s)-1):\\n            count_zero += s[i] == \\'0\\'\\n            count_one -= s[i] == \\'1\\'\\n            max_ = max(max_, count_zero+count_one)\\n        return max_\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1249522,
                "title": "c-0ms-100-two-pass",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximum Score After Splitting a String.\\nMemory Usage: 6.3 MB, less than 36.13% of C++ online submissions for Maximum Score After Splitting a String.\\n```\\nclass Solution {\\npublic:\\n  int maxScore(string s) {\\n    int nz = 0, no = 0, answer = 0, limit = s.size();\\n    for(auto &ch : s) if(ch == \\'1\\') no++;\\n    \\n    if(s[0] == \\'0\\') nz++, answer = 1;\\n    else no--;\\n    \\n    for(int i = 1; i != limit; i++){\\n      answer = max(answer, no + nz);\\n      if(s[i] == \\'0\\') nz++;\\n      else no--;\\n    } \\n    \\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxScore(string s) {\\n    int nz = 0, no = 0, answer = 0, limit = s.size();\\n    for(auto &ch : s) if(ch == \\'1\\') no++;\\n    \\n    if(s[0] == \\'0\\') nz++, answer = 1;\\n    else no--;\\n    \\n    for(int i = 1; i != limit; i++){\\n      answer = max(answer, no + nz);\\n      if(s[i] == \\'0\\') nz++;\\n      else no--;\\n    } \\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241590,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        l = 0 if s[0] == \\'1\\' else 1\\n        r = Counter(s[1:])[\\'1\\']\\n        score = l + r\\n        for i in range(1,  len(s) - 1):\\n            if s[i] == \\'0\\':\\n                l += 1\\n            if s[i] == \\'1\\':\\n                r -= 1\\n            score = max(score, l + r)\\n        return score\\n```\\n\\nWe start with the split where we keep everything in the right half. Then, we iterate through the string, and increment the left half if we see a 0 (we didn\\'t previously count this for a score) or decrement the right half if we see a 1 (because we previously had it in the right half). We take the max score.\\n\\nWe have O(n) time for 2 linear passes. We could decrease space to O(1) by counting the initial 1\\'s without the Counter.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        l = 0 if s[0] == \\'1\\' else 1\\n        r = Counter(s[1:])[\\'1\\']\\n        score = l + r\\n        for i in range(1,  len(s) - 1):\\n            if s[i] == \\'0\\':\\n                l += 1\\n            if s[i] == \\'1\\':\\n                r -= 1\\n            score = max(score, l + r)\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240629,
                "title": "javascript-o-n-solution-86-faster",
                "content": "```\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxScore = function(s) {\\n    const leftScores = []\\n    const rightScores = []\\n    let score = 0\\n    for (let i = 0; i < s.length-1; i++) {\\n        if (s[i] === \\'0\\') \\n            score++\\n        leftScores.push(score)\\n    }\\n    score = 0\\n    for (let i = s.length-1; i > 0; i--) {\\n        if (s[i] === \\'1\\')\\n            score++\\n        rightScores.unshift(score)\\n    }\\n    \\n    const scores = leftScores.map((val, idx) => val + rightScores[idx])\\n    return Math.max(...scores)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxScore = function(s) {\\n    const leftScores = []\\n    const rightScores = []\\n    let score = 0\\n    for (let i = 0; i < s.length-1; i++) {\\n        if (s[i] === \\'0\\') \\n            score++\\n        leftScores.push(score)\\n    }\\n    score = 0\\n    for (let i = s.length-1; i > 0; i--) {\\n        if (s[i] === \\'1\\')\\n            score++\\n        rightScores.unshift(score)\\n    }\\n    \\n    const scores = leftScores.map((val, idx) => val + rightScores[idx])\\n    return Math.max(...scores)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1223696,
                "title": "simple-solution-in-java",
                "content": "Use two variables - left & right.\\nleft - No. of zeroes\\nright - No. of ones\\nIterate from i=0 to i=s.length()-1\\n\\t- if the character at i th place is 0 increment left by one, else decrement right by one\\n\\t- calculate the current max of left & right and store in max\\nReturn the final value stored in max.\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max=0,left=0,right=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\')\\n                right++;\\n        }\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==\\'0\\')\\n                left++;\\n            else\\n                right--;\\n            max=Math.max(max,left+right);\\n        }\\n        return max;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max=0,left=0,right=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\')\\n                right++;\\n        }\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==\\'0\\')\\n                left++;\\n            else\\n                right--;\\n            max=Math.max(max,left+right);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187205,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int zero = 0;\\n        for(char a : s.toCharArray()){\\n            if(a == \\'0\\')\\n                zero++;\\n        }\\n        int left = 0;\\n        int right = s.length() - zero;\\n        int max = 0;\\n        for(int i = 0; i < s.length() -1; i++){\\n            if(s.charAt(i) == \\'0\\')\\n                left++;\\n            if(s.charAt(i) == \\'1\\')\\n                right--;\\n            max = Math.max(max, left + right);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxScore(String s) {\\n        int zero = 0;\\n        for(char a : s.toCharArray()){\\n            if(a == \\'0\\')\\n                zero++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1183218,
                "title": "python3-o-n-no-found-lee215-so-do-it-myself",
                "content": "hope it will help;\\n 0 0 1 1 1 0 0   left = 0,right = 3  init\\n 0 /0 1 1 1 0 0   left = 1,right = 3\\n 0 0/ 1 1 1 0 0   left = 2,right = 3\\n 0 0 1/ 1 1 0 0   left = 2,right = 2\\n 0 0 1 1 /1 0 0   left = 2,right = 1\\n  0 0 1 1 1/ 0 0   left = 2,right = 0\\n   0 0 1 1 1 0 /0   left = 3,right = 0\\n```\\nclass Solution: \\n    def maxScore(self, s: str) -> int:\\n        left,right = 0,s.count(\"1\")\\n        res= 0 \\n        for i in range(0,len(s)-1):\\n            if s[i] ==\"0\":\\n                left+=1\\n            elif s[i] == \"1\":\\n                right-=1\\n            res = max(res,left+right)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution: \\n    def maxScore(self, s: str) -> int:\\n        left,right = 0,s.count(\"1\")\\n        res= 0 \\n        for i in range(0,len(s)-1):\\n            if s[i] ==\"0\":\\n                left+=1\\n            elif s[i] == \"1\":\\n                right-=1\\n            res = max(res,left+right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180330,
                "title": "simple-java-solution",
                "content": "```\\npublic int maxScore(String s) {\\n        int count0 = 0, count1=0, sum=0;\\n        for(int i=0;i<s.length();i++)\\n            if(s.charAt(i)==\\'1\\')\\n                count1++;\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==\\'0\\')\\n                count0++;\\n            if(s.charAt(i)==\\'1\\')\\n                count1--;\\n            \\n            sum = Math.max(sum, count0+count1);\\n        }\\n            \\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxScore(String s) {\\n        int count0 = 0, count1=0, sum=0;\\n        for(int i=0;i<s.length();i++)\\n            if(s.charAt(i)==\\'1\\')\\n                count1++;\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==\\'0\\')\\n                count0++;\\n            if(s.charAt(i)==\\'1\\')\\n                count1--;\\n            \\n            sum = Math.max(sum, count0+count1);\\n        }\\n            \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176161,
                "title": "two-golang-solutions-both-100-100-with-explanation",
                "content": "[1422. Maximum Score After Splitting a String](https://leetcode.com/problems/maximum-score-after-splitting-a-string/)\\n\\nThe idea of the first solution is pretty simple, and the second solution is based on the first solution.\\n\\nThe idea of the first solution is:\\n\\n* We loop through `s` and add all the numbers to a counter called `numberOfOnes` to count the number of ones. We do this by using ASCII. The ASCII of `0` is `48`, and the ASCII of `1` is `49`, so we can get the `int` of `s[i]` and then subtract `48` from it to get `0` or `1`. If it is `0` `s[i] = \\'0\\'` and if it is `1` `s[i] = \\'1\\'`.\\n* If the first element is a `\\'0\\'` we add one to `numberOfZeros` and if it is a `\\'1\\'` we can subtract one from `numberOfOnes` because the split string starts with a substring of length `1` on the left and a substring of length `(len(s) - 1) - 1`.\\n* Then we can loop through `1` to `len(s) - 1` and add one to `numberOfZeros` or subtract one from the `numberOfOnes`, and then check whether the `numberOfZeros + numberOfOnes` is greater than `maximum`, if so make `maximum` equal to `numberOfZeros + numberOfOnes`.\\n\\nThe idea of the second solution is: We do the same thing as the first solution, but we combine `numberOfZeros` and `numberOfOnes` into a variable called `sum`.\\n\\n**The First Code:**\\n\\n``` go\\nfunc maxScore(s string) int {\\n    numberOfOnes := 0\\n    numberOfZeros := 0\\n    maximum := 0\\n\\n    for _, i := range s {\\n        numberOfOnes += int(i) - 48\\n    }\\n    \\n    numberOfZeros, numberOfOnes = \\n    addAndSubtractFromOnesAndZeros(s, numberOfZeros, numberOfOnes, 0)\\n    \\n    maximum = numberOfOnes + numberOfZeros\\n\\n    for i := 1; i < len(s)-1; i++ {\\n        numberOfZeros, numberOfOnes = \\n        addAndSubtractFromOnesAndZeros(s, numberOfZeros, numberOfOnes, i)\\n        \\n        if numberOfOnes + numberOfZeros > maximum {\\n            maximum = numberOfOnes + numberOfZeros\\n        }\\n    }\\n\\n    return maximum\\n}\\n\\nfunc addAndSubtractFromOnesAndZeros(s string, \\nnumberOfZeros, numberOfOnes, i int) (int, int) {\\n\\n    if s[i] == \\'0\\' {\\n        return numberOfZeros + 1, numberOfOnes\\n    }\\n    return numberOfZeros, numberOfOnes - 1\\n}\\n```\\n\\n**The Second Code:**\\n\\n``` go\\nfunc maxScore(s string) int {\\n    maximum := 0\\n    sum := 0\\n\\n    for _, i := range s {\\n        sum += int(i) - 48\\n    }\\n\\n    sum = addAndSubtractFromOnesAndZeros2(s, sum, 0)\\n    maximum = sum\\n\\n    for i := 1; i < len(s)-1; i++ {\\n        sum = addAndSubtractFromOnesAndZeros2(s, sum, i)\\n        if sum > maximum {\\n            maximum = sum\\n        }\\n    }\\n\\n    return maximum\\n}\\n\\nfunc addAndSubtractFromOnesAndZeros2(s string, sum, i int) int {\\n    if s[i] == \\'0\\' {\\n        return sum + 1\\n    }\\n    return sum - 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc maxScore(s string) int {\\n    numberOfOnes := 0\\n    numberOfZeros := 0\\n    maximum := 0\\n\\n    for _, i := range s {\\n        numberOfOnes += int(i) - 48\\n    }\\n    \\n    numberOfZeros, numberOfOnes = \\n    addAndSubtractFromOnesAndZeros(s, numberOfZeros, numberOfOnes, 0)\\n    \\n    maximum = numberOfOnes + numberOfZeros\\n\\n    for i := 1; i < len(s)-1; i++ {\\n        numberOfZeros, numberOfOnes = \\n        addAndSubtractFromOnesAndZeros(s, numberOfZeros, numberOfOnes, i)\\n        \\n        if numberOfOnes + numberOfZeros > maximum {\\n            maximum = numberOfOnes + numberOfZeros\\n        }\\n    }\\n\\n    return maximum\\n}\\n\\nfunc addAndSubtractFromOnesAndZeros(s string, \\nnumberOfZeros, numberOfOnes, i int) (int, int) {\\n\\n    if s[i] == \\'0\\' {\\n        return numberOfZeros + 1, numberOfOnes\\n    }\\n    return numberOfZeros, numberOfOnes - 1\\n}\\n```\n``` go\\nfunc maxScore(s string) int {\\n    maximum := 0\\n    sum := 0\\n\\n    for _, i := range s {\\n        sum += int(i) - 48\\n    }\\n\\n    sum = addAndSubtractFromOnesAndZeros2(s, sum, 0)\\n    maximum = sum\\n\\n    for i := 1; i < len(s)-1; i++ {\\n        sum = addAndSubtractFromOnesAndZeros2(s, sum, i)\\n        if sum > maximum {\\n            maximum = sum\\n        }\\n    }\\n\\n    return maximum\\n}\\n\\nfunc addAndSubtractFromOnesAndZeros2(s string, sum, i int) int {\\n    if s[i] == \\'0\\' {\\n        return sum + 1\\n    }\\n    return sum - 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138472,
                "title": "java-0ms-o-2n",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        char[] chars = s.toCharArray();\\n        int max = 0;\\n        if(chars[0]==\\'0\\') max = 1;\\n        \\n        for(int i = 1; i < chars.length; i++)\\n            if(chars[i]==\\'1\\') max++;\\n        \\n        int curr = max;\\n        \\n        for(int i = 1; i < chars.length-1; i++) {\\n            if(chars[i]==\\'0\\') curr++;\\n            else curr--;\\n            max = Math.max(max, curr);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        char[] chars = s.toCharArray();\\n        int max = 0;\\n        if(chars[0]==\\'0\\') max = 1;\\n        \\n        for(int i = 1; i < chars.length; i++)\\n            if(chars[i]==\\'1\\') max++;\\n        \\n        int curr = max;\\n        \\n        for(int i = 1; i < chars.length-1; i++) {\\n            if(chars[i]==\\'0\\') curr++;\\n            else curr--;\\n            max = Math.max(max, curr);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055500,
                "title": "python3-two-pass-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        res, a, b = 0, 0, s.count(\\'1\\')\\n        for x in s[:-1]:\\n            a += x == \\'0\\'\\n            b -= x == \\'1\\'\\n            res = max(res, a+b)\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        res, a, b = 0, 0, s.count(\\'1\\')\\n        for x in s[:-1]:\\n            a += x == \\'0\\'\\n            b -= x == \\'1\\'\\n            res = max(res, a+b)\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1048137,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        score = 0\\n        for i in range(1,len(s)):\\n            score = max(score,s[:i].count(\\'0\\') + s[i:].count(\\'1\\'))\\n        return score\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        score = 0\\n        for i in range(1,len(s)):\\n            score = max(score,s[:i].count(\\'0\\') + s[i:].count(\\'1\\'))\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015446,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        \\n        int max = 0;\\n        int ones = 0;\\n        int zeros = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                ones++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < s.length() - 1; i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                zeros++;\\n            }else{\\n                ones--;\\n            }\\n            max = Math.max(zeros + ones, max);\\n        }\\n        \\n        return max;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        \\n        int max = 0;\\n        int ones = 0;\\n        int zeros = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                ones++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < s.length() - 1; i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                zeros++;\\n            }else{\\n                ones--;\\n            }\\n            max = Math.max(zeros + ones, max);\\n        }\\n        \\n        return max;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997707,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int maxvalue = -2;\\n        int total = 0;\\n        int currentvalue = 0;\\n        for(int i = 0; i < s.length()-1; i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                currentvalue += 1;\\n            }\\n            else{\\n                currentvalue -= 1;\\n                total += 1;\\n                \\n            }\\n            if(currentvalue > maxvalue){\\n                    maxvalue = currentvalue;\\n            }\\n        }\\n        if(s.charAt(s.length() -1) == \\'1\\')\\n            return total + maxvalue + 1;\\n        else\\n            return total + maxvalue;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int maxvalue = -2;\\n        int total = 0;\\n        int currentvalue = 0;\\n        for(int i = 0; i < s.length()-1; i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                currentvalue += 1;\\n            }\\n            else{\\n                currentvalue -= 1;\\n                total += 1;\\n                \\n            }\\n            if(currentvalue > maxvalue){\\n                    maxvalue = currentvalue;\\n            }\\n        }\\n        if(s.charAt(s.length() -1) == \\'1\\')\\n            return total + maxvalue + 1;\\n        else\\n            return total + maxvalue;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994612,
                "title": "python-3-one-pass-explained-o-n",
                "content": "Explaination:\\nTraverse the string, plus 1 if the char is \"0\", minus 1 if the char is \"1\".\\n\\n~~~\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        res, co, cl = 0, 0, s.count(\"1\")\\n        for i in range(len(s)-1):\\n            if s[i] == \"0\": co += 1\\n            else: cl -= 1\\n            res = max(co+cl, res)\\n        return res\\n~~~\\n\\n#Runtime: 24 ms, faster than 97.69% of Python3 online submissions for Maximum Score After Splitting a String.\\n#Memory Usage: 14.2 MB, less than 65.29% of Python3 online submissions for Maximum Score After Splitting a String.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Explaination:\\nTraverse the string, plus 1 if the char is \"0\", minus 1 if the char is \"1\".\\n\\n~~~\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        res, co, cl = 0, 0, s.count(\"1\")\\n        for i in range(len(s)-1):\\n            if s[i] == \"0\": co += 1\\n            else: cl -= 1\\n            res = max(co+cl, res)\\n        return res\\n~~~\\n\\n#Runtime: 24 ms, faster than 97.69% of Python3 online submissions for Maximum Score After Splitting a String.\\n#Memory Usage: 14.2 MB, less than 65.29% of Python3 online submissions for Maximum Score After Splitting a String.",
                "codeTag": "Java"
            },
            {
                "id": 980861,
                "title": "python-two-pass-o-n-o-1",
                "content": "```\\n    def maxScore(self, s: str) -> int:\\n        max_score = s.count(\\'1\\')\\n        running_max = max_score\\n\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'0\\':\\n                running_max += 1\\n            else:\\n                running_max -= 1\\n            max_score = max(max_score, running_max)\\n            \\n        return max_score + 1 if s[0] == \\'0\\' else max_score - 1\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxScore(self, s: str) -> int:\\n        max_score = s.count(\\'1\\')\\n        running_max = max_score\\n\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'0\\':\\n                running_max += 1\\n            else:\\n                running_max -= 1\\n            max_score = max(max_score, running_max)\\n            \\n        return max_score + 1 if s[0] == \\'0\\' else max_score - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 963806,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(const string& s) {\\n        int one=count(s.begin(),s.end(),\\'1\\'), zero=0, score=0;\\n        for(int i=0; i<s.size()-1; ++i)\\n            score=s[i]==\\'0\\'?max(score,++zero+one):max(score,--one+zero);\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(const string& s) {\\n        int one=count(s.begin(),s.end(),\\'1\\'), zero=0, score=0;\\n        for(int i=0; i<s.size()-1; ++i)\\n            score=s[i]==\\'0\\'?max(score,++zero+one):max(score,--one+zero);\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931280,
                "title": "simple-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int[] numLeftZeros = new int[s.length()];\\n        \\n        int numZero = 0;\\n        for(int i = 0 ; i < s.length() ; i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                numZero++;\\n            }\\n            numLeftZeros[i] = numZero;\\n        }\\n\\n        int maxScore = 0;\\n        int numOne = 0;\\n        for(int i = s.length() - 1 ; i >= 0 ; i--) {\\n            if (i < s.length() - 1) {\\n                maxScore = Math.max(maxScore, numOne + numLeftZeros[i]);\\n            }\\n            if (s.charAt(i) == \\'1\\') {\\n                numOne++;\\n            }\\n        }\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int[] numLeftZeros = new int[s.length()];\\n        \\n        int numZero = 0;\\n        for(int i = 0 ; i < s.length() ; i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                numZero++;\\n            }\\n            numLeftZeros[i] = numZero;\\n        }\\n\\n        int maxScore = 0;\\n        int numOne = 0;\\n        for(int i = s.length() - 1 ; i >= 0 ; i--) {\\n            if (i < s.length() - 1) {\\n                maxScore = Math.max(maxScore, numOne + numLeftZeros[i]);\\n            }\\n            if (s.charAt(i) == \\'1\\') {\\n                numOne++;\\n            }\\n        }\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895692,
                "title": "c-100-easy-to-understand-short-solution",
                "content": "```class Solution {\\npublic:\\n    int maxScore(string s) {\\n        int count_0 = 0, count_1 = 0, res = 0;\\n        for(char ch:s) if(ch == \\'1\\') count_1++;\\n        for(int i = 0;   i < s.size()-1 ; ++i){\\n            (s[i] == \\'0\\') ? count_0++ : count_1--;\\n            res = max(res, count_0 + count_1);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxScore(string s) {\\n        int count_0 = 0, count_1 = 0, res = 0;\\n        for(char ch:s) if(ch == \\'1\\') count_1++;\\n        for(int i = 0;   i < s.size()-1 ; ++i){\\n            (s[i] == \\'0\\') ? count_0++ : count_1--;\\n            res = max(res, count_0 + count_1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 762463,
                "title": "simple-cpp-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        map<char,int>mp1;\\n        for(int i=0;i<s.size();i++)\\n            mp1[s[i]]++;\\n        map<char,int>mp2;\\n        int ans=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {   mp1[s[i]]--;mp2[s[i]]++;\\n            int ma=mp1[\\'1\\']+mp2[\\'0\\'];\\n            ans=max(ans,ma);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        map<char,int>mp1;\\n        for(int i=0;i<s.size();i++)\\n            mp1[s[i]]++;\\n        map<char,int>mp2;\\n        int ans=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {   mp1[s[i]]--;mp2[s[i]]++;\\n            int ma=mp1[\\'1\\']+mp2[\\'0\\'];\\n            ans=max(ans,ma);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757013,
                "title": "small-and-easy-java-code",
                "content": "```\\n\\n```class Solution {\\n    public int maxScore(String s) {\\n        int p=0,c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\')\\n                p++;\\n        }\\n        int sum=p-1;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==\\'0\\')\\n                c++;\\n            else\\n                p--;\\n            if(c+p>sum)\\n                sum=c+p;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748048,
                "title": "python-2-pass-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        ones = s.count(\\'1\\')\\n        max_score = num_zeros = 0\\n        for i in range(len(s)-1):\\n            char = s[i]\\n            num_zeros += char == \\'0\\'\\n            ones -= char == \\'1\\'\\n            max_score = max(max_score, num_zeros+ones)\\n        return max_score\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        ones = s.count(\\'1\\')\\n        max_score = num_zeros = 0\\n        for i in range(len(s)-1):\\n            char = s[i]\\n            num_zeros += char == \\'0\\'\\n            ones -= char == \\'1\\'\\n            max_score = max(max_score, num_zeros+ones)\\n        return max_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738715,
                "title": "easy-to-understand-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        \\n        //count 1s in the string\\n        int totalOnes = 0;\\n        for(char ch: s.toCharArray())\\n            if(ch == \\'1\\')\\n                totalOnes++;\\n        \\n        int ans = 0;\\n        int currZeroes = 0;\\n        int currOnes = 0;\\n        \\n        for(int i = 0; i < s.length() - 1; i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'0\\')\\n                currZeroes++;\\n            else\\n                currOnes++;\\n            \\n            //Number of ones on the right side of i will be \\n            //total count of ones - curr count of ones  \\n            \\n            int currScore = currZeroes + (totalOnes - currOnes);\\n            \\n            ans = Math.max(ans, currScore);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        \\n        //count 1s in the string\\n        int totalOnes = 0;\\n        for(char ch: s.toCharArray())\\n            if(ch == \\'1\\')\\n                totalOnes++;\\n        \\n        int ans = 0;\\n        int currZeroes = 0;\\n        int currOnes = 0;\\n        \\n        for(int i = 0; i < s.length() - 1; i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'0\\')\\n                currZeroes++;\\n            else\\n                currOnes++;\\n            \\n            //Number of ones on the right side of i will be \\n            //total count of ones - curr count of ones  \\n            \\n            int currScore = currZeroes + (totalOnes - currOnes);\\n            \\n            ans = Math.max(ans, currScore);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729268,
                "title": "java-o-2n-1ms-solution",
                "content": "\\n\\tpublic int maxScore(String s) {\\n        int leftSum = s.charAt(0) == \\'0\\' ? 1 : 0;\\n        int rightSum = s.charAt(s.length() - 1) == \\'1\\' ? 1 : 0;\\n        \\n        for (int i = 1; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                rightSum++;\\n            }\\n        }\\n        \\n        int maxScore = leftSum + rightSum;\\n        \\n        for (int j = 1; j < s.length() - 1; j++) {\\n            if (s.charAt(j) == \\'0\\') {\\n                leftSum++;\\n            } else {\\n                rightSum--;\\n            }\\n            \\n            maxScore = Math.max(leftSum + rightSum, maxScore);\\n        }\\n        \\n        return maxScore;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\tpublic int maxScore(String s) {\\n        int leftSum = s.charAt(0) == \\'0\\' ? 1 : 0;\\n        int rightSum = s.charAt(s.length() - 1) == \\'1\\' ? 1 : 0;\\n        \\n        for (int i = 1; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                rightSum++;\\n            }\\n        }\\n        \\n        int maxScore = leftSum + rightSum;\\n        \\n        for (int j = 1; j < s.length() - 1; j++) {\\n            if (s.charAt(j) == \\'0\\') {\\n                leftSum++;\\n            } else {\\n                rightSum--;\\n            }\\n            \\n            maxScore = Math.max(leftSum + rightSum, maxScore);\\n        }\\n        \\n        return maxScore;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 724845,
                "title": "swift-simple-easy-but-slow",
                "content": "```\\n    func maxScore(_ s: String) -> Int {\\n        let arr = Array(s)\\n        var best = 0\\n        \\n        for i in 1..<arr.count {\\n            let left = Array(arr[..<i])\\n            let right = Array(arr[i...])\\n            \\n            var cur = left.filter { $0 == \"0\" }.count\\n            cur += right.filter { $0 == \"1\" }.count\\n            best = max(best, cur)\\n        }\\n        \\n        return best\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func maxScore(_ s: String) -> Int {\\n        let arr = Array(s)\\n        var best = 0\\n        \\n        for i in 1..<arr.count {\\n            let left = Array(arr[..<i])\\n            let right = Array(arr[i...])\\n            \\n            var cur = left.filter { $0 == \"0\" }.count\\n            cur += right.filter { $0 == \"1\" }.count\\n            best = max(best, cur)\\n        }\\n        \\n        return best\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 692625,
                "title": "2-line-python",
                "content": "**summary**\\n`i  + 1 - ones[i]` is the number of zeroes on the left\\n`ones[-1] - ones[i]` is the number of ones on the right\\n```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        ones = list(accumulate(map(int, list(s))))\\n        return max(i + 1 - ones[i] + ones[-1] - ones[i] for i in range(len(s) - 1))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        ones = list(accumulate(map(int, list(s))))\\n        return max(i + 1 - ones[i] + ones[-1] - ones[i] for i in range(len(s) - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643023,
                "title": "java-dp-o-n-space-o-n-time-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int[] zeros =new int[s.length()];\\n        int max=0;\\n        int ones=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zeros[i]=(i==0) ? 1 : 1+ zeros[i-1];\\n            }else{\\n                zeros[i]=(i==0) ? 0 : zeros[i-1];\\n                ones++;\\n            }\\n        }\\n      \\n     for(int j=1;j<s.length();j++){\\n          int zLeft=zeros[j-1];\\n          int oLeft= j-zLeft;\\n          max=Math.max(max,zLeft+ones-oLeft);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int[] zeros =new int[s.length()];\\n        int max=0;\\n        int ones=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zeros[i]=(i==0) ? 1 : 1+ zeros[i-1];\\n            }else{\\n                zeros[i]=(i==0) ? 0 : zeros[i-1];\\n                ones++;\\n            }\\n        }\\n      \\n     for(int j=1;j<s.length();j++){\\n          int zLeft=zeros[j-1];\\n          int oLeft= j-zLeft;\\n          max=Math.max(max,zLeft+ones-oLeft);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640234,
                "title": "java-easy-solution-without-splitting",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max=0;\\n        for(int j=1;j<s.length();j++){            \\n            int leftZero=0, rightOne=0;\\n                \\n            for(int i=0;i<j;i++){\\n                if(s.charAt(i)==\\'0\\')\\n                    leftZero++;\\n            }\\n            \\n            for(int i=j;i<s.length();i++){\\n                if(s.charAt(i)==\\'1\\')\\n                    rightOne++;\\n            }\\n            \\n            if(max<leftZero+rightOne)\\n                max=leftZero+rightOne;\\n            \\n        }\\n        return max;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max=0;\\n        for(int j=1;j<s.length();j++){            \\n            int leftZero=0, rightOne=0;\\n                \\n            for(int i=0;i<j;i++){\\n                if(s.charAt(i)==\\'0\\')\\n                    leftZero++;\\n            }\\n            \\n            for(int i=j;i<s.length();i++){\\n                if(s.charAt(i)==\\'1\\')\\n                    rightOne++;\\n            }\\n            \\n            if(max<leftZero+rightOne)\\n                max=leftZero+rightOne;\\n            \\n        }\\n        return max;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631531,
                "title": "0ms-c",
                "content": "```\\n\\nint maxScore(char * s){\\n    int max = 0;\\n    int len = strlen(s);\\n    int one, zero;\\n    one = zero = 0;\\n    for (int i = 0; i < len; i++)\\n        if (s[i] == \\'1\\')\\n            one++;\\n    for (int i = 0; i < len - 1; i++)\\n    {\\n        if (s[i] == \\'0\\') \\n            zero++;\\n        if (s[i] == \\'1\\')\\n            one--;\\n        if (one + zero > max)\\n            max = one + zero;\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint maxScore(char * s){\\n    int max = 0;\\n    int len = strlen(s);\\n    int one, zero;\\n    one = zero = 0;\\n    for (int i = 0; i < len; i++)\\n        if (s[i] == \\'1\\')\\n            one++;\\n    for (int i = 0; i < len - 1; i++)\\n    {\\n        if (s[i] == \\'0\\') \\n            zero++;\\n        if (s[i] == \\'1\\')\\n            one--;\\n        if (one + zero > max)\\n            max = one + zero;\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618711,
                "title": "simple-cpp",
                "content": "```\\n int n=s.size();\\n        int i;\\n        vector<int>a(n);\\n        vector<int>b(n);\\n        int cnt=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                cnt++;\\n                a[i]=cnt;\\n            }\\n        }\\n        cnt=0;\\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                cnt++;\\n                b[i]=cnt;\\n            }\\n        }\\n        int maxans=0;\\n        for(i=0;i<n-1;i++)\\n        {\\n            maxans=max(maxans,a[i]+b[i+1]);\\n        }\\n        return maxans;\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n int n=s.size();\\n        int i;\\n        vector<int>a(n);\\n        vector<int>b(n);\\n        int cnt=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                cnt++;\\n                a[i]=cnt;\\n            }\\n        }\\n        cnt=0;\\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                cnt++;\\n                b[i]=cnt;\\n            }\\n        }\\n        int maxans=0;\\n        for(i=0;i<n-1;i++)\\n        {\\n            maxans=max(maxans,a[i]+b[i+1]);\\n        }\\n        return maxans;\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 612709,
                "title": "javascript",
                "content": "```\\nvar getScore = function(left, right) {\\n  let counter = 0;\\n  \\n  for (let i = 0; i < left.length; i += 1) {\\n    if (left[i] === \\'0\\') counter += 1;\\n  }\\n    \\n  for (let i = 0; i < right.length; i += 1) {\\n    if (right[i] === \\'1\\') counter += 1;\\n  }\\n  \\n  return counter;\\n}\\n\\nvar maxScore = function(s) {\\n  const scores = [];\\n  \\n  for (let i = 0; i < s.length - 1; i += 1) {\\n    const left = s.slice(0, i + 1);\\n    const right = s.slice(i + 1, s.length);\\n\\n    scores.push(getScore(left, right));\\n  }\\n  \\n  return Math.max(...scores);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getScore = function(left, right) {\\n  let counter = 0;\\n  \\n  for (let i = 0; i < left.length; i += 1) {\\n    if (left[i] === \\'0\\') counter += 1;\\n  }\\n    \\n  for (let i = 0; i < right.length; i += 1) {\\n    if (right[i] === \\'1\\') counter += 1;\\n  }\\n  \\n  return counter;\\n}\\n\\nvar maxScore = function(s) {\\n  const scores = [];\\n  \\n  for (let i = 0; i < s.length - 1; i += 1) {\\n    const left = s.slice(0, i + 1);\\n    const right = s.slice(i + 1, s.length);\\n\\n    scores.push(getScore(left, right));\\n  }\\n  \\n  return Math.max(...scores);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 606065,
                "title": "easy-to-understand-python-97",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int: \\n        ways=[]\\n        for i in range(len(s)-1):\\n            left=\"\" \\n            right=\"\"\\n            left+=(s[0:i+1])\\n            right+=(s[i+1:len(s)])\\n            ways.append(left.count(\"0\")+right.count(\"1\"))\\n        return max(ways)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int: \\n        ways=[]\\n        for i in range(len(s)-1):\\n            left=\"\" \\n            right=\"\"\\n            left+=(s[0:i+1])\\n            right+=(s[i+1:len(s)])\\n            ways.append(left.count(\"0\")+right.count(\"1\"))\\n        return max(ways)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 603979,
                "title": "python-one-loop",
                "content": "time O(n)\\nspace O(1)\\n```\\ndef maxScore(self, s: str) -> int:\\n\\tans = baseV = tAns = 0\\n\\tfor i in range(1, len(s)-1):\\n\\t\\tif s[i] == \"0\":\\n\\t\\t\\ttAns += 1\\n\\t\\telse:\\n\\t\\t\\ttAns -= 1\\n\\t\\t\\tbaseV += 1\\n\\t\\tans = max(ans, tAns)\\n\\treturn ans + baseV + (s[0] == \"0\") + (s[-1] == \"1\")\\n```\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\ndef maxScore(self, s: str) -> int:\\n\\tans = baseV = tAns = 0\\n\\tfor i in range(1, len(s)-1):\\n\\t\\tif s[i] == \"0\":\\n\\t\\t\\ttAns += 1\\n\\t\\telse:\\n\\t\\t\\ttAns -= 1\\n\\t\\t\\tbaseV += 1\\n\\t\\tans = max(ans, tAns)\\n\\treturn ans + baseV + (s[0] == \"0\") + (s[-1] == \"1\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 602264,
                "title": "java-counting-simple-explained-1-ms",
                "content": "We can find the maximum by emulating every possible split. We can do it in a clever way (something like a sliding window) - when the edge has moved one step to the right we check what was that char that was in the right part but became the right most in the left part. \\n\\nInitially all zeroes are to the right, so count \\'1\\' and make it out starting point. Then iterate over every position up to len - 1. When we visite index it means we count it to the left part. If it was \\'1\\' it means that there are less ones in right part, so decrement the score. If it is \\'0\\' it means that there is one more 0 to the left and we need to increment the score.\\n\\nAt the end check if new score can be a maximum.\\n\\nO(n) time - iterate over the string two times\\nO(1) space - no extra space used apart from few state variables.\\n\\n```\\n  public int maxScore(String s) {\\n    int cur = 0;\\n    for (char ch : s.toCharArray()) {\\n      if (ch == \\'1\\')\\n        ++cur;\\n    }\\n\\n    int max = 0;\\n    for (int i = 0; i < s.length() - 1; i++) {\\n      if (s.charAt(i) == \\'0\\') {\\n        ++cur;\\n      } else {\\n        --cur;\\n      }\\n      max = Math.max(max, cur);\\n    }\\n    return max;\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n  public int maxScore(String s) {\\n    int cur = 0;\\n    for (char ch : s.toCharArray()) {\\n      if (ch == \\'1\\')\\n        ++cur;\\n    }\\n\\n    int max = 0;\\n    for (int i = 0; i < s.length() - 1; i++) {\\n      if (s.charAt(i) == \\'0\\') {\\n        ++cur;\\n      } else {\\n        --cur;\\n      }\\n      max = Math.max(max, cur);\\n    }\\n    return max;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 602126,
                "title": "one-loop-javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxScore = function(s) {\\n    if (!s || s.length < 2) return 0;\\n    \\n    const last = s.length - 1;\\n    \\n    let max = s.length; // assume we have the best score out of a string\\n    if (s[0] === \"1\") max--;\\n    if (s[last] === \"0\") max--;\\n    \\n    let ones = 0, zeros = 0;    \\n    \\n\\t// travel from left to right\\n    for(let i = 1; i < last; i++) { \\n        if (s[i] === \"1\") {\\n            ones++;  // count the number of \"1\"          \\n        } else {\\n            zeros++; // count the number of \"0\"\\n            max--; // We know every \"0\" on the right will reduce possible max by 1                    \\n            if (zeros > ones) { // if we have more zeros than ones on the right, correct max\\n                max = max + zeros - ones;  // correct it !\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// reset counters since we have the new max\\n                zeros = 0;\\n                ones = 0;\\n            }\\n        }        \\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxScore = function(s) {\\n    if (!s || s.length < 2) return 0;\\n    \\n    const last = s.length - 1;\\n    \\n    let max = s.length; // assume we have the best score out of a string\\n    if (s[0] === \"1\") max--;\\n    if (s[last] === \"0\") max--;\\n    \\n    let ones = 0, zeros = 0;    \\n    \\n\\t// travel from left to right\\n    for(let i = 1; i < last; i++) { \\n        if (s[i] === \"1\") {\\n            ones++;  // count the number of \"1\"          \\n        } else {\\n            zeros++; // count the number of \"0\"\\n            max--; // We know every \"0\" on the right will reduce possible max by 1                    \\n            if (zeros > ones) { // if we have more zeros than ones on the right, correct max\\n                max = max + zeros - ones;  // correct it !\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// reset counters since we have the new max\\n                zeros = 0;\\n                ones = 0;\\n            }\\n        }        \\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600444,
                "title": "python-rust-time-o-n-and-space-1",
                "content": "- **Python**\\n```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        res = ones = zeros = 0\\n        \\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        \\n        for i, l in enumerate(s[:-1]):\\n            if l == \\'0\\': zeros += 1\\n            else: ones -= 1\\n            res = max(res, ones+zeros)\\n            \\n        return res   \\n```\\n- **Rust**\\n\\n```rust\\nimpl Solution {\\n    pub fn max_score(s: String) -> i32 {\\n        let (mut res, mut ones, mut zeros) = (0, 0, 0);\\n    \\n        for l in s.chars() {\\n            if l == \\'1\\' { ones += 1; }\\n        }\\n        \\n        for i in 0..s.len()-1 {\\n            if s.chars().nth(i).unwrap() == \\'0\\' {\\n                zeros += 1; \\n            } else { \\n                ones -= 1; \\n            }\\n            res = res.max(ones + zeros);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        res = ones = zeros = 0\\n        \\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        \\n        for i, l in enumerate(s[:-1]):\\n            if l == \\'0\\': zeros += 1\\n            else: ones -= 1\\n            res = max(res, ones+zeros)\\n            \\n        return res   \\n```\n```rust\\nimpl Solution {\\n    pub fn max_score(s: String) -> i32 {\\n        let (mut res, mut ones, mut zeros) = (0, 0, 0);\\n    \\n        for l in s.chars() {\\n            if l == \\'1\\' { ones += 1; }\\n        }\\n        \\n        for i in 0..s.len()-1 {\\n            if s.chars().nth(i).unwrap() == \\'0\\' {\\n                zeros += 1; \\n            } else { \\n                ones -= 1; \\n            }\\n            res = res.max(ones + zeros);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600284,
                "title": "java-consider-using-left-subarray-and-right-sub-array-beats-99-49-and-100",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n\\t\\t// Consider dividing the entire string virtually into left and right sub arrays. A String is basically an array of characters.\\n        int leftSum = 0;\\n        int rightSum = 0;\\n        \\n\\t\\t//At index 0, left Sub array sum is incremented by 1 if first character is 0 else it is by default 0\\n        if(s.charAt(0) == \\'0\\') {\\n            leftSum = 1;\\n        }\\n        \\n\\t\\t// Increment the right Sub array sum by 1 if the character at that particular index is 1\\n        for(int i=1; i<s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                rightSum++;\\n            }\\n        }\\n        \\n\\t\\t// Now at index 0, both left sum and right sum are calculated and their sum is our initial max value\\n        int max = leftSum + rightSum;\\n        \\n\\t\\t// Depending on the character at each index either increment left sum or decrement right sum.\\n\\t\\t//If it is a \\'1\\' it is moved to left array and right sum is decremented. \\n\\t\\t//If it is a \\'0\\' left sum is incremented and there is no change to right sum.\\n        for(int i=1; i<s.length()-1; i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                leftSum++;\\n            } else {\\n                rightSum--;\\n            }\\n            max = Math.max(max, leftSum + rightSum);\\n        }\\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n\\t\\t// Consider dividing the entire string virtually into left and right sub arrays. A String is basically an array of characters.\\n        int leftSum = 0;\\n        int rightSum = 0;\\n        \\n\\t\\t//At index 0, left Sub array sum is incremented by 1 if first character is 0 else it is by default 0\\n        if(s.charAt(0) == \\'0\\') {\\n            leftSum = 1;\\n        }\\n        \\n\\t\\t// Increment the right Sub array sum by 1 if the character at that particular index is 1\\n        for(int i=1; i<s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                rightSum++;\\n            }\\n        }\\n        \\n\\t\\t// Now at index 0, both left sum and right sum are calculated and their sum is our initial max value\\n        int max = leftSum + rightSum;\\n        \\n\\t\\t// Depending on the character at each index either increment left sum or decrement right sum.\\n\\t\\t//If it is a \\'1\\' it is moved to left array and right sum is decremented. \\n\\t\\t//If it is a \\'0\\' left sum is incremented and there is no change to right sum.\\n        for(int i=1; i<s.length()-1; i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                leftSum++;\\n            } else {\\n                rightSum--;\\n            }\\n            max = Math.max(max, leftSum + rightSum);\\n        }\\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599703,
                "title": "java-1-ms-simple-one-pass-solution",
                "content": "```\\npublic int maxScore(String s) {\\n\\tint ls = 0, rs = 0, max = 0;\\n\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tif (s.charAt(i) == \\'1\\')\\n\\t\\t\\trs++;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.length()-1; i++) {\\n\\t\\tif (s.charAt(i) == \\'0\\')\\n\\t\\t\\tls++;\\n\\t\\telse\\n\\t\\t\\trs--;\\n\\n\\t\\tmax = Math.max(max, ls + rs);\\n\\t}\\n\\treturn max;\\n}",
                "solutionTags": [],
                "code": "```\\npublic int maxScore(String s) {\\n\\tint ls = 0, rs = 0, max = 0;\\n\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tif (s.charAt(i) == \\'1\\')\\n\\t\\t\\trs++;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.length()-1; i++) {\\n\\t\\tif (s.charAt(i) == \\'0\\')\\n\\t\\t\\tls++;\\n\\t\\telse\\n\\t\\t\\trs--;\\n\\n\\t\\tmax = Math.max(max, ls + rs);\\n\\t}\\n\\treturn max;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 598874,
                "title": "java-solution-with-explanation",
                "content": "The Idea hear is to spilt the sting in two non empty string. So we spilt it at index 1 and count zeros on left of index 1 and ones in right of index 1 including index 1.\\nThen loop through each element of string from index 2 and see if there was a zero at index  i - 1 then add it to count as left string which has all zeros else substract from count as now it is been removed from right string. At every step take the max of count.\\n\\nTime Complexity - O(n)\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int count = 0, ind = 1;\\n        if(s.charAt(0) - \\'0\\' == 0) {\\n            count++;\\n        }\\n        while(ind < s.length()) {\\n            if(s.charAt(ind++) - \\'0\\' == 1) {\\n                count++;\\n            }\\n        }\\n        int max = count;\\n        for(int i = 2; i < s.length(); i++) {\\n            if(s.charAt(i - 1) - \\'0\\' == 0) {\\n                count++;\\n            }else {\\n                count--;\\n            }\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int count = 0, ind = 1;\\n        if(s.charAt(0) - \\'0\\' == 0) {\\n            count++;\\n        }\\n        while(ind < s.length()) {\\n            if(s.charAt(ind++) - \\'0\\' == 1) {\\n                count++;\\n            }\\n        }\\n        int max = count;\\n        for(int i = 2; i < s.length(); i++) {\\n            if(s.charAt(i - 1) - \\'0\\' == 0) {\\n                count++;\\n            }else {\\n                count--;\\n            }\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598559,
                "title": "java-straightforward-using-substring-and-count",
                "content": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 1; i < s.length(); i++){\\n            String partOne = s.substring(0, i);\\n            String partTwo = s.substring(i, s.length());\\n            int countOne = partOne.length() - partOne.replaceAll(\"0\", \"\").length();\\n            int countTwo = partTwo.length() - partTwo.replaceAll(\"1\", \"\").length();\\n            max = Math.max(max, countOne + countTwo);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 1; i < s.length(); i++){\\n            String partOne = s.substring(0, i);\\n            String partTwo = s.substring(i, s.length());\\n            int countOne = partOne.length() - partOne.replaceAll(\"0\", \"\").length();\\n            int countTwo = partTwo.length() - partTwo.replaceAll(\"1\", \"\").length();\\n            max = Math.max(max, countOne + countTwo);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598074,
                "title": "c-with-explanation",
                "content": "## Solution 1.\\n\\n`zero` and `one` are the counts of `0`s in `left` and `1`s in right.\\n\\nFirst compute the count of all `1`s as `one`. Then for each `i` in range `[0, N - 2]`, increment `zero` if `s[i] == \\'0\\'` and decrement `one` if `s[i] == \\'1\\'`. The maximum `zero + one` is the result.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-score-after-splitting-a-string\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int one = 0, zero = 0, ans = 0;\\n        for (char c : s) one += c == \\'1\\';\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            char c  = s[i];\\n            zero += c == \\'0\\';\\n            one -= c == \\'1\\';\\n            ans = max(ans, zero + one);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximum-score-after-splitting-a-string\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int one = 0, zero = 0, ans = 0;\\n        for (char c : s) one += c == \\'1\\';\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            char c  = s[i];\\n            zero += c == \\'0\\';\\n            one -= c == \\'1\\';\\n            ans = max(ans, zero + one);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598018,
                "title": "python-one-line",
                "content": "```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        return max([s[:i].count(\\'0\\') + s[i:].count(\\'1\\') for i in range(1, len(s))])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        return max([s[:i].count(\\'0\\') + s[i:].count(\\'1\\') for i in range(1, len(s))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597976,
                "title": "rust-solution-0ms-with-explanations",
                "content": "Two phases:\\n1. Iterate over the char vector `s.chars()` to get the count of `1` occourning in string `s`\\n2. Start from index \\'0\\' to \\'s.len() - 2\\' to get the maximum sum of `left_str.count(\\'0\\') + right_str.count(\\'1\\')`\\n\\nA pitfall here: we should exit the algorithm when `i` hits `s.len() - 2` (not `s.len() - 1`). This is because if `i == s.len() - 1`, then the right substring is empty, which is forbidden by the question. \\n\\n```rust\\nimpl Solution {\\n    pub fn max_score(s: String) -> i32 {\\n        let C1 = s.chars().filter(|c| *c == \\'1\\').collect::<Vec<_>>().len();\\n        let (mut cnt_0, mut cnt_1, mut res) = (0, 0, 0);\\n        let cs: Vec<char> = s.chars().collect();\\n\\n        for i in (0..s.len() - 1) {\\n            if cs[i] == \\'0\\' {\\n                cnt_0 += 1;\\n            } else {\\n                cnt_1 += 1;\\n            }\\n            res = max(res, cnt_0 + C1 - cnt_1);\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_score(s: String) -> i32 {\\n        let C1 = s.chars().filter(|c| *c == \\'1\\').collect::<Vec<_>>().len();\\n        let (mut cnt_0, mut cnt_1, mut res) = (0, 0, 0);\\n        let cs: Vec<char> = s.chars().collect();\\n\\n        for i in (0..s.len() - 1) {\\n            if cs[i] == \\'0\\' {\\n                cnt_0 += 1;\\n            } else {\\n                cnt_1 += 1;\\n            }\\n            res = max(res, cnt_0 + C1 - cnt_1);\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597932,
                "title": "c-with-just-count-function",
                "content": "we just need to count from index 1 that eliminates the corner cases\\n```\\n    int maxScore(string s) {\\n        int ans=0;\\n        for(int i=1;i<s.length();i++)\\n            ans=max(ans,int(count(s.begin(), s.begin()+i, \\'0\\')+count(s.begin()+i, s.end(), \\'1\\')));\\n\\t\\t\\t//simply count the 0 and 1 in ranges and max of it updates the ans\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxScore(string s) {\\n        int ans=0;\\n        for(int i=1;i<s.length();i++)\\n            ans=max(ans,int(count(s.begin(), s.begin()+i, \\'0\\')+count(s.begin()+i, s.end(), \\'1\\')));\\n\\t\\t\\t//simply count the 0 and 1 in ranges and max of it updates the ans\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597926,
                "title": "python-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        zeros_and_ones = [0] * len(s)\\n        counter = 0\\n        \\n        for i in range(len(s)-1):\\n            counter += 1 if s[i] == \\'0\\' else 0\\n            zeros_and_ones[i] += counter\\n        \\n        counter = 0\\n        for i in range(len(s) - 1, 0, -1):\\n            counter += 1 if s[i] == \\'1\\' else 0\\n            zeros_and_ones[i] += counter\\n\\n        return max(zeros_and_ones)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        zeros_and_ones = [0] * len(s)\\n        counter = 0\\n        \\n        for i in range(len(s)-1):\\n            counter += 1 if s[i] == \\'0\\' else 0\\n            zeros_and_ones[i] += counter\\n        \\n        counter = 0\\n        for i in range(len(s) - 1, 0, -1):\\n            counter += 1 if s[i] == \\'1\\' else 0\\n            zeros_and_ones[i] += counter\\n\\n        return max(zeros_and_ones)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597827,
                "title": "c-using-prefix-sums",
                "content": "Note - The question asks for non empty sub arrrays, so can\\'t consider entire array as subarray.\\n\\n```csharp\\npublic int MaxScore(string s)\\n{\\n\\tint[] zeroes = new int[s.Length + 1];\\n\\tint[] ones = new int[s.Length + 1];\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tzeroes[i + 1] += zeroes[i];\\n\\t\\tones[i + 1] += ones[i];\\n\\n\\t\\tif (s[i] == \\'0\\')\\n\\t\\t{\\n\\t\\t\\tzeroes[i + 1]++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tones[i + 1]++;\\n\\t\\t}\\n\\t}\\n\\n\\tint maxScore = 0;\\n\\tfor (int i = 0; i < s.Length - 1; i++)\\n\\t{\\n\\t\\tint score = zeroes[i + 1] + ones[s.Length] - ones[i + 1];            \\n\\t\\tmaxScore = Math.Max(maxScore, score);\\n\\t}\\n\\n\\treturn maxScore;\\n}",
                "solutionTags": [],
                "code": "Note - The question asks for non empty sub arrrays, so can\\'t consider entire array as subarray.\\n\\n```csharp\\npublic int MaxScore(string s)\\n{\\n\\tint[] zeroes = new int[s.Length + 1];\\n\\tint[] ones = new int[s.Length + 1];\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tzeroes[i + 1] += zeroes[i];\\n\\t\\tones[i + 1] += ones[i];\\n\\n\\t\\tif (s[i] == \\'0\\')\\n\\t\\t{\\n\\t\\t\\tzeroes[i + 1]++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tones[i + 1]++;\\n\\t\\t}\\n\\t}\\n\\n\\tint maxScore = 0;\\n\\tfor (int i = 0; i < s.Length - 1; i++)\\n\\t{\\n\\t\\tint score = zeroes[i + 1] + ones[s.Length] - ones[i + 1];            \\n\\t\\tmaxScore = Math.Max(maxScore, score);\\n\\t}\\n\\n\\treturn maxScore;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 597804,
                "title": "my-python-solution",
                "content": "This is a brute force solution. There are other solution available in other threads.\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        max_score = 0\\n        \\n        for i in range(1, len(s)):\\n            left, right = s[:i], s[i:]\\n            score = left.count(\"0\") + right.count(\"1\")\\n            max_score = max(max_score, score)\\n\\n        return max_score\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        max_score = 0\\n        \\n        for i in range(1, len(s)):\\n            left, right = s[:i], s[i:]\\n            score = left.count(\"0\") + right.count(\"1\")\\n            max_score = max(max_score, score)\\n\\n        return max_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102161,
                "title": "python3-concise-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        \\n        n=len(s)\\n        zeros=0\\n        ones=s.count(\"1\")\\n        ans=0\\n        \\n        for i in range(n-1):\\n            zeros+=s[i]==\"0\"\\n            ones-=s[i]==\"1\"\\n            ans=max(ans,zeros+ones)\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        \\n        n=len(s)\\n        zeros=0\\n        ones=s.count(\"1\")\\n        ans=0\\n        \\n        for i in range(n-1):\\n            zeros+=s[i]==\"0\"\\n            ones-=s[i]==\"1\"\\n            ans=max(ans,zeros+ones)\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087177,
                "title": "simple-python-code-very-fast-and-very-memory-efficient",
                "content": "# Intuition\\nYou can determine the score when split between index 0 and 1. After that, you slide where you split. When you see a 0, increase the score. When you see a 1, decrease score (since you\\'re losing it from the right group).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        score = s[1:].count(\"1\")\\n        if s[0] == \"0\":\\n            score += 1\\n        max_score = score\\n        for char in s[1:len(s)-1]:\\n            if char == \"0\":\\n                score += 1\\n            else:\\n                score -= 1\\n            if score > max_score:\\n                max_score = score\\n        return max_score\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        score = s[1:].count(\"1\")\\n        if s[0] == \"0\":\\n            score += 1\\n        max_score = score\\n        for char in s[1:len(s)-1]:\\n            if char == \"0\":\\n                score += 1\\n            else:\\n                score -= 1\\n            if score > max_score:\\n                max_score = score\\n        return max_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072385,
                "title": "linear-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n\\n\\n        best = 0\\n        suffix_one = s.count(\"1\")\\n        prefix_zero = 0\\n\\n        for i in range(len(s)-1):\\n            if s[i]==\"0\":\\n                prefix_zero +=1\\n            if s[i]==\"1\":\\n                suffix_one -=1\\n            best = max(best,prefix_zero+suffix_one)\\n            \\n        return best\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n\\n\\n        best = 0\\n        suffix_one = s.count(\"1\")\\n        prefix_zero = 0\\n\\n        for i in range(len(s)-1):\\n            if s[i]==\"0\":\\n                prefix_zero +=1\\n            if s[i]==\"1\":\\n                suffix_one -=1\\n            best = max(best,prefix_zero+suffix_one)\\n            \\n        return best\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068865,
                "title": "delta-code",
                "content": "\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MaxScore(string s)\\n    {\\n        int maxSum = s[^1] == \\'1\\' ? 1 : 0;\\n        maxSum += s[0] == \\'0\\' ? 1 : 0;\\n        sbyte delta = 0;\\n        sbyte maxDelta = 0;\\n        for (int i = 1; i < s.Length - 1; i++)\\n        {\\n          if (s[i] == \\'1\\')\\n          {            \\n            delta--;\\n            maxSum++;\\n          }\\n          else\\n          { \\n            delta++;\\n          }  \\n\\n          if(maxDelta < delta){\\n            maxDelta = delta;\\n          }\\n        }\\n\\n        return maxSum + maxDelta;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxScore(string s)\\n    {\\n        int maxSum = s[^1] == \\'1\\' ? 1 : 0;\\n        maxSum += s[0] == \\'0\\' ? 1 : 0;\\n        sbyte delta = 0;\\n        sbyte maxDelta = 0;\\n        for (int i = 1; i < s.Length - 1; i++)\\n        {\\n          if (s[i] == \\'1\\')\\n          {            \\n            delta--;\\n            maxSum++;\\n          }\\n          else\\n          { \\n            delta++;\\n          }  \\n\\n          if(maxDelta < delta){\\n            maxDelta = delta;\\n          }\\n        }\\n\\n        return maxSum + maxDelta;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056952,
                "title": "simple-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int one =0, ans=0, zero=0;\\n        //if(s.charAt(0) == \\'1\\') one--;\\n        //if(s.charAt(s.length()-1) == \\'0\\') zero--;\\n        for(char c:s.toCharArray()){\\n            if(c == \\'1\\') one++;\\n        }\\n        //ans = one;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i) == \\'0\\') zero++;\\n            else one--;\\n            ans = ans> one+zero?ans:one+zero;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int one =0, ans=0, zero=0;\\n        //if(s.charAt(0) == \\'1\\') one--;\\n        //if(s.charAt(s.length()-1) == \\'0\\') zero--;\\n        for(char c:s.toCharArray()){\\n            if(c == \\'1\\') one++;\\n        }\\n        //ans = one;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i) == \\'0\\') zero++;\\n            else one--;\\n            ans = ans> one+zero?ans:one+zero;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037310,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        s = list(s)\\n\\n        m = 0\\n        for i in range(1,len(s)):\\n            left = s[:i].count(\\'0\\')\\n            right = s[i:].count(\\'1\\')\\n\\n            m = max(m, left+right)\\n        \\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        s = list(s)\\n\\n        m = 0\\n        for i in range(1,len(s)):\\n            left = s[:i].count(\\'0\\')\\n            right = s[i:].count(\\'1\\')\\n\\n            m = max(m, left+right)\\n        \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025046,
                "title": "easy-python-solution-for-maximum-score-after-splitting-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        s = [*s]\\n        left = \\'\\'\\n        right = \\'\\'\\n        res = []\\n        for _ in range(len(s)-1):\\n            left += s[0]\\n            s.pop(0)\\n            right = s\\n            res.append(left.count(\\'0\\') + right.count(\\'1\\'))\\n        return max(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        s = [*s]\\n        left = \\'\\'\\n        right = \\'\\'\\n        res = []\\n        for _ in range(len(s)-1):\\n            left += s[0]\\n            s.pop(0)\\n            right = s\\n            res.append(left.count(\\'0\\') + right.count(\\'1\\'))\\n        return max(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002116,
                "title": "c-solution-by-ajeet20-iit-kanpur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n\\n        int max = 0;\\n\\n        for(int i = 0; i < s.length() - 1; i++){\\n            int sum = left(s,i) + right(s,i+1);\\n            if(sum > max) max = sum;\\n        }\\n        return max;\\n        \\n    }\\npublic:\\n        int left(string s, int k){\\n            int sum = 0;\\n\\n            for(int  i = 0; i <= k; i++){\\n                if(s[i] == \\'0\\') sum++;\\n            }\\n            return sum;\\n        }\\npublic:\\n        int right(string s, int k){\\n            int sum = 0;\\n\\n            for(int  i = k; i < s.length(); i++){\\n                if(s[i] == \\'1\\') sum++;\\n            }\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n\\n        int max = 0;\\n\\n        for(int i = 0; i < s.length() - 1; i++){\\n            int sum = left(s,i) + right(s,i+1);\\n            if(sum > max) max = sum;\\n        }\\n        return max;\\n        \\n    }\\npublic:\\n        int left(string s, int k){\\n            int sum = 0;\\n\\n            for(int  i = 0; i <= k; i++){\\n                if(s[i] == \\'0\\') sum++;\\n            }\\n            return sum;\\n        }\\npublic:\\n        int right(string s, int k){\\n            int sum = 0;\\n\\n            for(int  i = k; i < s.length(); i++){\\n                if(s[i] == \\'1\\') sum++;\\n            }\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001608,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        a=[]\\n        for i in range(0,len(s)-1) :\\n            b=s[0:i+1].count(\\'0\\')\\n            c=s[i+1:len(s)].count(\\'1\\')\\n            a.append(b+c)\\n        return max(a)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        a=[]\\n        for i in range(0,len(s)-1) :\\n            b=s[0:i+1].count(\\'0\\')\\n            c=s[i+1:len(s)].count(\\'1\\')\\n            a.append(b+c)\\n        return max(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991312,
                "title": "python-easy-solution-80-96-beating-with-a-walrus-operator",
                "content": "# Approach\\nEverything is quite simple - we iterate over the indices in which we can make a \"cut\", then using the walrus operator we assign \"score\" to the variable and immediately return the sum of the left and right parts, and if it is greater than the current result, we change the result.\\n\\nUpvote my solution if you like it <3 thanks\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        res = 0\\n        for index in range(1, len(s), 1):\\n            if (score := s[0:index].count(\\'0\\') + s[index:].count(\\'1\\')) > res: \\n                res = score\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        res = 0\\n        for index in range(1, len(s), 1):\\n            if (score := s[0:index].count(\\'0\\') + s[index:].count(\\'1\\')) > res: \\n                res = score\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987621,
                "title": "c-simple-easy-solution-100-o-n",
                "content": "# EXPLANATION\\nAt first count the number of **1** present in string.\\nThen again traverse in string till second last, and update the count if that pointer has 0, then add **1** or else **-1**.\\nSimultaneously update the **ans**.\\nFinally return **ans**.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int c=0;\\n        for(auto x:s)\\n            if(x==\\'1\\')\\n                c++;\\n        int ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            c+=(s[i]==\\'0\\')?1:-1;\\n            ans=max(c,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int c=0;\\n        for(auto x:s)\\n            if(x==\\'1\\')\\n                c++;\\n        int ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            c+=(s[i]==\\'0\\')?1:-1;\\n            ans=max(c,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972311,
                "title": "kotlin-beat-mem-and-time",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\u041E(2n) ~ \\u041E(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), but i used additional array just for chars\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxScore(s: String): Int {\\n        var sCa = s.toCharArray()\\n        var counter0 = 0\\n        var counter1 = 0\\n\\n        for(c in sCa) {\\n            if(c == \\'1\\') counter1++\\n        }\\n        if(sCa[0] == \\'0\\') {\\n            counter0++\\n        } else {\\n            counter1--\\n        }\\n        var max = counter1 + counter0\\n\\n        for(sIndex in 1..(sCa.size - 2)) {\\n            if(sCa[sIndex] == \\'0\\') {\\n                counter0++\\n                if(max < counter0 + counter1) {\\n                    max = counter0 + counter1\\n                }\\n            } else if(sCa[sIndex] == \\'1\\') {\\n                counter1--\\n            }\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxScore(s: String): Int {\\n        var sCa = s.toCharArray()\\n        var counter0 = 0\\n        var counter1 = 0\\n\\n        for(c in sCa) {\\n            if(c == \\'1\\') counter1++\\n        }\\n        if(sCa[0] == \\'0\\') {\\n            counter0++\\n        } else {\\n            counter1--\\n        }\\n        var max = counter1 + counter0\\n\\n        for(sIndex in 1..(sCa.size - 2)) {\\n            if(sCa[sIndex] == \\'0\\') {\\n                counter0++\\n                if(max < counter0 + counter1) {\\n                    max = counter0 + counter1\\n                }\\n            } else if(sCa[sIndex] == \\'1\\') {\\n                counter1--\\n            }\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951092,
                "title": "easy-python-solution-using-string-slicing",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        bestScore = 0\\n        for i in range(len(s)-1):\\n            left = s[0:i+1]\\n            right = s[i+1:]\\n            zero = left.count(\\'0\\')\\n            ones = right.count(\\'1\\')\\n            score = zero + ones\\n            if score > bestScore:\\n                bestScore = score\\n\\n        return bestScore\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        bestScore = 0\\n        for i in range(len(s)-1):\\n            left = s[0:i+1]\\n            right = s[i+1:]\\n            zero = left.count(\\'0\\')\\n            ones = right.count(\\'1\\')\\n            score = zero + ones\\n            if score > bestScore:\\n                bestScore = score\\n\\n        return bestScore\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947981,
                "title": "easy-solution-o-n-no-extra-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int maxi=0,c0=0,c1=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')c1++;\\n        }\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n             c0++;\\n             else \\n                  c1--;\\n            maxi=max(maxi,c0+c1);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int maxi=0,c0=0,c1=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')c1++;\\n        }\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n             c0++;\\n             else \\n                  c1--;\\n            maxi=max(maxi,c0+c1);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944980,
                "title": "easiest-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int countleft=0;\\n        int countright=0;\\n        int maxx=Integer.MIN_VALUE;\\n        for(int i=0;i<s.length();i++){\\n            countright=0;\\n            countleft=0;\\n            if(i+1<s.length()){\\n            String s1=s.substring(0,i+1);\\n            String s2=s.substring(i+1);\\n            \\n            for(int j=0;j<s1.length();j++){\\n                if(s1.charAt(j)==\\'0\\'){\\n                    countleft++;\\n                }\\n            }\\n            for(int k=0;k<s2.length();k++){\\n                if(s2.charAt(k)==\\'1\\'){\\n                    countright++;\\n                }\\n            }\\n            }\\n            maxx=Math.max(maxx,countleft+countright);\\n        }\\n        return maxx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int countleft=0;\\n        int countright=0;\\n        int maxx=Integer.MIN_VALUE;\\n        for(int i=0;i<s.length();i++){\\n            countright=0;\\n            countleft=0;\\n            if(i+1<s.length()){\\n            String s1=s.substring(0,i+1);\\n            String s2=s.substring(i+1);\\n            \\n            for(int j=0;j<s1.length();j++){\\n                if(s1.charAt(j)==\\'0\\'){\\n                    countleft++;\\n                }\\n            }\\n            for(int k=0;k<s2.length();k++){\\n                if(s2.charAt(k)==\\'1\\'){\\n                    countright++;\\n                }\\n            }\\n            }\\n            maxx=Math.max(maxx,countleft+countright);\\n        }\\n        return maxx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944499,
                "title": "easy-soln",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        l=len(s)\\n        maxi=-1\\n        if s==\"00\":\\n            return 1\\n        for i in range(0,l-1):\\n            x=[]\\n            y=[]\\n            x=s[0:i+1]\\n            y=s[i+1:l]\\n            zero=x.count(\\'0\\')\\n            one=y.count(\\'1\\')\\n            sum1=zero+one\\n            maxi=max(maxi,sum1)\\n        return maxi\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        l=len(s)\\n        maxi=-1\\n        if s==\"00\":\\n            return 1\\n        for i in range(0,l-1):\\n            x=[]\\n            y=[]\\n            x=s[0:i+1]\\n            y=s[i+1:l]\\n            zero=x.count(\\'0\\')\\n            one=y.count(\\'1\\')\\n            sum1=zero+one\\n            maxi=max(maxi,sum1)\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942640,
                "title": "python-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAssigned num of 0\\'s and 1\\'s for each possibility to a dictionary then looped through it and found max.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        left = s[:1]\\n        right = s[1:]\\n        max1 = 0\\n        max2 = 0\\n        store = {}\\n        finalmax1 = 0\\n        finalmax2 = 0\\n        for i in range(len(s)-1):\\n            max1 = left.count(\\'0\\') \\n            max2 = right.count(\\'1\\')\\n            store[i] = (max1, max2)\\n            left += s[i+1]\\n            right = right[1:]\\n        for i in range(len(store)):\\n            if store[i][0] + store[i][1] > finalmax1 + finalmax2:\\n                finalmax1 = store[i][0]\\n                finalmax2 = store[i][1]\\n        return finalmax1 + finalmax2\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        left = s[:1]\\n        right = s[1:]\\n        max1 = 0\\n        max2 = 0\\n        store = {}\\n        finalmax1 = 0\\n        finalmax2 = 0\\n        for i in range(len(s)-1):\\n            max1 = left.count(\\'0\\') \\n            max2 = right.count(\\'1\\')\\n            store[i] = (max1, max2)\\n            left += s[i+1]\\n            right = right[1:]\\n        for i in range(len(store)):\\n            if store[i][0] + store[i][1] > finalmax1 + finalmax2:\\n                finalmax1 = store[i][0]\\n                finalmax2 = store[i][1]\\n        return finalmax1 + finalmax2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940068,
                "title": "java-count-0s-1s-100-faster-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        \\n        int n = s.length();\\n\\n        int countRightZeroes = 0;\\n        int countRightOnes = 0; \\n\\n        for(char chr : s.toCharArray()) {\\n            if(chr == \\'0\\') countRightZeroes++;\\n            else countRightOnes++;\\n        }\\n\\n        int countLeftZeroes = 0;\\n        int countLeftOnes = 0; \\n\\n        int maxScore = 0;\\n\\n        for(int i = 0; i < n - 1; i++) {\\n\\n            char chr = s.charAt(i);\\n\\n            if(chr == \\'0\\') {\\n                countRightZeroes--;\\n                countLeftZeroes++;\\n            } else {\\n                countRightOnes--;\\n                countLeftOnes++;\\n            }\\n\\n            maxScore = Math.max(maxScore, countLeftZeroes + countRightOnes);\\n\\n        }\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        \\n        int n = s.length();\\n\\n        int countRightZeroes = 0;\\n        int countRightOnes = 0; \\n\\n        for(char chr : s.toCharArray()) {\\n            if(chr == \\'0\\') countRightZeroes++;\\n            else countRightOnes++;\\n        }\\n\\n        int countLeftZeroes = 0;\\n        int countLeftOnes = 0; \\n\\n        int maxScore = 0;\\n\\n        for(int i = 0; i < n - 1; i++) {\\n\\n            char chr = s.charAt(i);\\n\\n            if(chr == \\'0\\') {\\n                countRightZeroes--;\\n                countLeftZeroes++;\\n            } else {\\n                countRightOnes--;\\n                countLeftOnes++;\\n            }\\n\\n            maxScore = Math.max(maxScore, countLeftZeroes + countRightOnes);\\n\\n        }\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939031,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        char[] chars = s.toCharArray();\\n        int zeros = 0, ones = 0;\\n        int n = chars.length,  max = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            if(chars[i] ==\\'1\\') ones ++;\\n\\n        for(int i = 0; i < n-1; i++){\\n            if(chars[i] == \\'0\\')\\n               zeros++;\\n            else ones --;\\n\\n            max = Math.max(max, ones + zeros);  \\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        char[] chars = s.toCharArray();\\n        int zeros = 0, ones = 0;\\n        int n = chars.length,  max = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            if(chars[i] ==\\'1\\') ones ++;\\n\\n        for(int i = 0; i < n-1; i++){\\n            if(chars[i] == \\'0\\')\\n               zeros++;\\n            else ones --;\\n\\n            max = Math.max(max, ones + zeros);  \\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923502,
                "title": "python-simple-and-faster-99-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        right = s.count(\\'1\\')\\n        left = 0\\n        max_score = 0\\n        for i in range(len(s) - 1):\\n            if s[i] == \\'0\\':   \\n                left += 1\\n            else:\\n                right -= 1\\n            max_score = max(max_score, left + right)\\n        return max_score\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        right = s.count(\\'1\\')\\n        left = 0\\n        max_score = 0\\n        for i in range(len(s) - 1):\\n            if s[i] == \\'0\\':   \\n                left += 1\\n            else:\\n                right -= 1\\n            max_score = max(max_score, left + right)\\n        return max_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919235,
                "title": "simple-and-fast-python-code",
                "content": "\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        n=len(s)\\n        lc=0 //left counter\\n        rc=s.count(\\'1\\') //right counter\\n        i=0\\n        score=0 //max score\\n        while i<n-1:\\n            if s[i]==\\'0\\':\\n                lc+=1                \\n            else:\\n                rc-=1\\n            \\n            if score<lc+rc:\\n                score=lc+rc\\n            i+=1\\n        return score\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        n=len(s)\\n        lc=0 //left counter\\n        rc=s.count(\\'1\\') //right counter\\n        i=0\\n        score=0 //max score\\n        while i<n-1:\\n            if s[i]==\\'0\\':\\n                lc+=1                \\n            else:\\n                rc-=1\\n            \\n            if score<lc+rc:\\n                score=lc+rc\\n            i+=1\\n        return score\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891054,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = 0, count_zero = 0, count_one = 0;\\n        for(char c:s.toCharArray()){\\n            if(c == \\'1\\'){\\n                count_one++;\\n            }\\n        }\\n        for(int i=0;i<s.length()-1;i++){\\n            char c = s.charAt(i);\\n            if(c == \\'0\\'){\\n                count_zero++;\\n            }else{\\n                count_one--;\\n            }\\n            max = Math.max(max, count_zero + count_one);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = 0, count_zero = 0, count_one = 0;\\n        for(char c:s.toCharArray()){\\n            if(c == \\'1\\'){\\n                count_one++;\\n            }\\n        }\\n        for(int i=0;i<s.length()-1;i++){\\n            char c = s.charAt(i);\\n            if(c == \\'0\\'){\\n                count_zero++;\\n            }else{\\n                count_one--;\\n            }\\n            max = Math.max(max, count_zero + count_one);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884803,
                "title": "very-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n\\n        a = [int(i) for i in s]\\n        b = []\\n\\n        for i in range(1, len(a)):\\n            b.append(a[0:i].count(0) + a[i:].count(1))\\n        \\n        print(b)\\n\\n        return max(b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n\\n        a = [int(i) for i in s]\\n        b = []\\n\\n        for i in range(1, len(a)):\\n            b.append(a[0:i].count(0) + a[i:].count(1))\\n        \\n        print(b)\\n\\n        return max(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876207,
                "title": "a-naive-solution-beats-100-00",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        score_l = int(s[0] == \\'0\\')\\n        score_r = s.count(\\'1\\') - (not score_l)\\n        result = score_l + score_r\\n        for val in s[1:-1]:\\n            if val == \\'1\\':\\n                score_r -= 1\\n            else:\\n                score_l += 1\\n            result = max(result, score_l + score_r)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        score_l = int(s[0] == \\'0\\')\\n        score_r = s.count(\\'1\\') - (not score_l)\\n        result = score_l + score_r\\n        for val in s[1:-1]:\\n            if val == \\'1\\':\\n                score_r -= 1\\n            else:\\n                score_l += 1\\n            result = max(result, score_l + score_r)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876109,
                "title": "java-easy-solution",
                "content": "make to string using substrings\\niterate over each string and increse count by 1 for str if str has 0 and increse count by 1 if the str2 has 1 in it then store the max value in max variable and reinitialise the count with 0 and return max\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) \\n    {\\n        int max=0;\\n        int count=0;\\n     //   StringBuilder str=new StringBuilder();\\n    //    StringBuilder str2=new StringBuilder();\\n        for(int i=1;i<s.length();i++)\\n        {\\n          String  str=s.substring(0,i);\\n          String  str2=s.substring(i,s.length());\\n            for(int j=0;j<str.length();j++)\\n            {\\n                if(str.charAt(j)==\\'0\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            for(int k=0;k<str2.length();k++)\\n            {\\n                if(str2.charAt(k)==\\'1\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            max=Math.max(max,count);\\n            count=0;\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) \\n    {\\n        int max=0;\\n        int count=0;\\n     //   StringBuilder str=new StringBuilder();\\n    //    StringBuilder str2=new StringBuilder();\\n        for(int i=1;i<s.length();i++)\\n        {\\n          String  str=s.substring(0,i);\\n          String  str2=s.substring(i,s.length());\\n            for(int j=0;j<str.length();j++)\\n            {\\n                if(str.charAt(j)==\\'0\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            for(int k=0;k<str2.length();k++)\\n            {\\n                if(str2.charAt(k)==\\'1\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            max=Math.max(max,count);\\n            count=0;\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856261,
                "title": "java-simple-o-n-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n       int n = s.length();\\n       int zeros=0,ones=0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'1\\')ones++;    \\n        }\\n\\n        int score=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)==\\'0\\')zeros++;\\n            else ones--;\\n        score= Math.max(score,zeros+ones);\\n        }\\n\\nreturn score; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n       int n = s.length();\\n       int zeros=0,ones=0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'1\\')ones++;    \\n        }\\n\\n        int score=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)==\\'0\\')zeros++;\\n            else ones--;\\n        score= Math.max(score,zeros+ones);\\n        }\\n\\nreturn score; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833553,
                "title": "java-beats-99-57-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int n = s.length();\\n        int[]arr1 = new int[n];\\n        int count = 0;\\n        for(int i = n-1;i >= 0;i--){\\n            arr1[i] = count;\\n            if(s.charAt(i) == \\'1\\')\\n                count++;\\n        }\\n        int ans = 0;\\n        int left = 0;\\n        for(int i = 0;i < n-1;i++){\\n            if(s.charAt(i) == \\'0\\')\\n                left++;\\n            ans = Math.max(ans,left + arr1[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int n = s.length();\\n        int[]arr1 = new int[n];\\n        int count = 0;\\n        for(int i = n-1;i >= 0;i--){\\n            arr1[i] = count;\\n            if(s.charAt(i) == \\'1\\')\\n                count++;\\n        }\\n        int ans = 0;\\n        int left = 0;\\n        for(int i = 0;i < n-1;i++){\\n            if(s.charAt(i) == \\'0\\')\\n                left++;\\n            ans = Math.max(ans,left + arr1[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822803,
                "title": "maximum-score-after-splitting-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = 0;\\n        int left0=0;\\n        int right1=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n            right1++;\\n        }\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            left0++;\\n            else if(s.charAt(i)==\\'1\\')\\n            right1--;\\n            max = Math.max(max,right1+left0);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max = 0;\\n        int left0=0;\\n        int right1=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n            right1++;\\n        }\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            left0++;\\n            else if(s.charAt(i)==\\'1\\')\\n            right1--;\\n            max = Math.max(max,right1+left0);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813359,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int left = 0, right = 0, max = 0;\\n        for(int i=0; i < s.size(); i++) if(s[i]==\\'1\\') right++;\\n        for(int i=0; i < s.size()-1; i++){\\n            if(s[i]==\\'0\\') left++;\\n            else if(s[i]==\\'1\\') right--;\\n            if(max < left+right) max = left + right;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int left = 0, right = 0, max = 0;\\n        for(int i=0; i < s.size(); i++) if(s[i]==\\'1\\') right++;\\n        for(int i=0; i < s.size()-1; i++){\\n            if(s[i]==\\'0\\') left++;\\n            else if(s[i]==\\'1\\') right--;\\n            if(max < left+right) max = left + right;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809109,
                "title": "1422-maximum-score-after-splitting-a-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n    int zeros = 0, ones = 0, max = Integer.MIN_VALUE;\\n\\tfor(int i=0;i<s.length();i++) {\\n\\t\\tif(s.charAt(i) == \\'0\\') zeros++; else ones++;\\n\\t\\tif(i != s.length()-1) max = Math.max(zeros - ones, max);\\n\\t}\\n\\treturn max + ones;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n    int zeros = 0, ones = 0, max = Integer.MIN_VALUE;\\n\\tfor(int i=0;i<s.length();i++) {\\n\\t\\tif(s.charAt(i) == \\'0\\') zeros++; else ones++;\\n\\t\\tif(i != s.length()-1) max = Math.max(zeros - ones, max);\\n\\t}\\n\\treturn max + ones;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762078,
                "title": "python-2-approaches-bruteforce-optimized",
                "content": "# Bruteforce\\n### Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution:\\n  def maxScore(self, s: str) -> int:\\n    n = len(s)\\n    max_sum = 0\\n    for i in range(1, n):\\n      left = s.count(\\'0\\', 0, i)\\n      right = s.count(\\'1\\', i, n)\\n      max_sum = max(max_sum, left + right)\\n    return max_sum\\n```\\n# Optimized\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution:\\n  def maxScore(self, s: str) -> int:\\n    n = len(s)\\n    ones = [0] * n\\n    if s[n - 1] == \\'1\\':\\n      ones[n - 1] = 1\\n    for i in range(n - 2, -1):\\n      if s[i] == \\'1\\':\\n        ones[i] = ones[i + 1] + 1\\n    max_sum = 0\\n    for i in range(n - 1):\\n      max_sum = max(max_sum, s.count(\\'0\\', 0, i) + ones[i + 1])\\n    return max_sum\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def maxScore(self, s: str) -> int:\\n    n = len(s)\\n    max_sum = 0\\n    for i in range(1, n):\\n      left = s.count(\\'0\\', 0, i)\\n      right = s.count(\\'1\\', i, n)\\n      max_sum = max(max_sum, left + right)\\n    return max_sum\\n```\n```\\nclass Solution:\\n  def maxScore(self, s: str) -> int:\\n    n = len(s)\\n    ones = [0] * n\\n    if s[n - 1] == \\'1\\':\\n      ones[n - 1] = 1\\n    for i in range(n - 2, -1):\\n      if s[i] == \\'1\\':\\n        ones[i] = ones[i + 1] + 1\\n    max_sum = 0\\n    for i in range(n - 1):\\n      max_sum = max(max_sum, s.count(\\'0\\', 0, i) + ones[i + 1])\\n    return max_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756760,
                "title": "a-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        SCORES = []\\n        left = s[0]\\n        right = s[1:]\\n        SCORES.append(left.count(\\'0\\') + right.count(\\'1\\'))\\n        for i in range(1,len(s)-1):\\n            left += right[0]\\n            right = s[i+1:]\\n            SCORES.append(left.count(\\'0\\') + right.count(\\'1\\'))\\n        return max(SCORES)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, s):\\n        SCORES = []\\n        left = s[0]\\n        right = s[1:]\\n        SCORES.append(left.count(\\'0\\') + right.count(\\'1\\'))\\n        for i in range(1,len(s)-1):\\n            left += right[0]\\n            right = s[i+1:]\\n            SCORES.append(left.count(\\'0\\') + right.count(\\'1\\'))\\n        return max(SCORES)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749333,
                "title": "java-substring-method-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countbits(String str,char ch)\\n    {\\n        int count=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n          if(str.charAt(i)==ch)\\n          count++; \\n        }\\n        return count;\\n    }\\n    public int maxScore(String s) {\\n      int total=0;\\n       for(int i=1;i<s.length();i++){\\n            String left=s.substring(0,i);\\n            String right=s.substring(i,s.length());\\n            total=Math.max(total,countbits(left,\\'0\\')+countbits(right,\\'1\\'));\\n        } \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countbits(String str,char ch)\\n    {\\n        int count=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n          if(str.charAt(i)==ch)\\n          count++; \\n        }\\n        return count;\\n    }\\n    public int maxScore(String s) {\\n      int total=0;\\n       for(int i=1;i<s.length();i++){\\n            String left=s.substring(0,i);\\n            String right=s.substring(i,s.length());\\n            total=Math.max(total,countbits(left,\\'0\\')+countbits(right,\\'1\\'));\\n        } \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722905,
                "title": "straigth-forward-ruby-brute-force",
                "content": "# Approach\\nGet the score for each split points, and return the max\\n# Code\\n```\\n# @param {String} s\\n# @return {Integer}\\ndef max_score(s)\\n    [*1..s.size-1].map{|i|s[...i].count(\\'0\\')+s[i..].count(\\'1\\')}.max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {Integer}\\ndef max_score(s)\\n    [*1..s.size-1].map{|i|s[...i].count(\\'0\\')+s[i..].count(\\'1\\')}.max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3722533,
                "title": "python-easy-to-understand-beats-98-95",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        # Calculate l_score and r_score.\\n        l_score, r_score = (1 if s[0] == \\'0\\' else 0), s[1:].count(\\'1\\')\\n\\n        # Set initial maximum score.\\n        max_score =  l_score + r_score\\n\\n        for i in range(1, len(s)-1):\\n            # Assume, that at the ith iteration we split string at the ith position,\\n            # so if s[i] == \\'0\\', then increment l_score by 1.\\n            if s[i] == \\'0\\':\\n                l_score += 1\\n\\n                # l_score + r_score could be bigger than max_score only if\\n                # the overall score value is increasing.\\n                if l_score + r_score > max_score:\\n                    max_score = l_score + r_score\\n            else:\\n                # If s[i] == \\'1\\' we should decrease r_score by 1\\n                r_score -= 1 \\n\\n        return max_score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        # Calculate l_score and r_score.\\n        l_score, r_score = (1 if s[0] == \\'0\\' else 0), s[1:].count(\\'1\\')\\n\\n        # Set initial maximum score.\\n        max_score =  l_score + r_score\\n\\n        for i in range(1, len(s)-1):\\n            # Assume, that at the ith iteration we split string at the ith position,\\n            # so if s[i] == \\'0\\', then increment l_score by 1.\\n            if s[i] == \\'0\\':\\n                l_score += 1\\n\\n                # l_score + r_score could be bigger than max_score only if\\n                # the overall score value is increasing.\\n                if l_score + r_score > max_score:\\n                    max_score = l_score + r_score\\n            else:\\n                # If s[i] == \\'1\\' we should decrease r_score by 1\\n                r_score -= 1 \\n\\n        return max_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719958,
                "title": "swift-solution-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$ O(N) $$\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$ O(N) $$\\n\\n# Code\\n```\\nclass Solution {\\n    func maxScore(_ s: String) -> Int {\\n        var sArray = Array(s)\\n        var totalZero = 0\\n        var totalOne = 0\\n        var sLength = s.count\\n        var ans = 0\\n\\n        for iterator in 0..<sLength {\\n            if sArray[iterator] == \"0\" {\\n                totalZero = totalZero + 1\\n            } else {\\n                totalOne = totalOne + 1\\n            }\\n        }\\n\\n        var currentZero = 0\\n        var currentOne = 0\\n        for iterator in 0..<(sLength - 1) {\\n            if sArray[iterator] == \"0\" {\\n                currentZero = currentZero + 1\\n            } else {\\n                currentOne = currentOne + 1\\n            }\\n            \\n            var temp = currentZero + totalOne - currentOne\\n            ans = max(ans,temp)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxScore(_ s: String) -> Int {\\n        var sArray = Array(s)\\n        var totalZero = 0\\n        var totalOne = 0\\n        var sLength = s.count\\n        var ans = 0\\n\\n        for iterator in 0..<sLength {\\n            if sArray[iterator] == \"0\" {\\n                totalZero = totalZero + 1\\n            } else {\\n                totalOne = totalOne + 1\\n            }\\n        }\\n\\n        var currentZero = 0\\n        var currentOne = 0\\n        for iterator in 0..<(sLength - 1) {\\n            if sArray[iterator] == \"0\" {\\n                currentZero = currentZero + 1\\n            } else {\\n                currentOne = currentOne + 1\\n            }\\n            \\n            var temp = currentZero + totalOne - currentOne\\n            ans = max(ans,temp)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716590,
                "title": "100-beats-simple-and-intuitive-solution-c-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int oneCount=0;\\n        int zeroCount=0;\\n        int totalCount=0;\\n        for(int i=0 ; i<s.length() ; i++) {\\n            if(s[i]==\\'1\\') ++oneCount;\\n            else ++zeroCount;\\n            ++totalCount;\\n        }\\n        int max=INT_MIN;\\n        int left=0;\\n        int right=oneCount;\\n        for(int i=0 ; i<s.length()-1 ; i++) {\\n            char curr=s[i];\\n            if(curr==\\'0\\') {\\n                ++left;\\n            } else {\\n                --right;\\n            }\\n            int score=left+right;\\n            max=std::max(max,score);\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(string s) {\\n        int oneCount=0;\\n        int zeroCount=0;\\n        int totalCount=0;\\n        for(int i=0 ; i<s.length() ; i++) {\\n            if(s[i]==\\'1\\') ++oneCount;\\n            else ++zeroCount;\\n            ++totalCount;\\n        }\\n        int max=INT_MIN;\\n        int left=0;\\n        int right=oneCount;\\n        for(int i=0 ; i<s.length()-1 ; i++) {\\n            char curr=s[i];\\n            if(curr==\\'0\\') {\\n                ++left;\\n            } else {\\n                --right;\\n            }\\n            int score=left+right;\\n            max=std::max(max,score);\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703286,
                "title": "c-easy-brute-force-sol-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(std::string s) {\\n        int maxScore = 0;\\n        int score = 0;\\n        int zerosCount = 0;\\n        int onesCount = std::count(s.begin(), s.end(), \\'1\\');\\n\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s[i] == \\'0\\')\\n                zerosCount++;\\n            else\\n                onesCount--;\\n\\n            score = zerosCount + onesCount;\\n            maxScore = max(maxScore, score);\\n        }\\n\\n        return maxScore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(std::string s) {\\n        int maxScore = 0;\\n        int score = 0;\\n        int zerosCount = 0;\\n        int onesCount = std::count(s.begin(), s.end(), \\'1\\');\\n\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s[i] == \\'0\\')\\n                zerosCount++;\\n            else\\n                onesCount--;\\n\\n            score = zerosCount + onesCount;\\n            maxScore = max(maxScore, score);\\n        }\\n\\n        return maxScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698885,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max =0;\\n        for(int i =0; i<s.length()-1; i++)\\n            max = Math.max(max,s.substring(0,i+1).replace(\"1\",\"\").length()+s.substring(i+1).replace(\"0\",\"\").length());\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max =0;\\n        for(int i =0; i<s.length()-1; i++)\\n            max = Math.max(max,s.substring(0,i+1).replace(\"1\",\"\").length()+s.substring(i+1).replace(\"0\",\"\").length());\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690551,
                "title": "maximum-score-after-splitting-a-string-python-o-n-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        maxVal = 0\\n        for i in range(1,len(s)):\\n            left = s[:i]\\n            right = s[i:]\\n            zeroes = 0\\n            ones = 0\\n            for val in left:\\n                if val == \"0\":\\n                    zeroes +=1\\n            for val in right:\\n                if val == \"1\":\\n                    ones +=1\\n            score = zeroes + ones\\n            if score > maxVal:\\n                maxVal = score\\n        return maxVal\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        maxVal = 0\\n        for i in range(1,len(s)):\\n            left = s[:i]\\n            right = s[i:]\\n            zeroes = 0\\n            ones = 0\\n            for val in left:\\n                if val == \"0\":\\n                    zeroes +=1\\n            for val in right:\\n                if val == \"1\":\\n                    ones +=1\\n            score = zeroes + ones\\n            if score > maxVal:\\n                maxVal = score\\n        return maxVal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646260,
                "title": "basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max=0;\\n        for(int i=1;i<s.length();i++){\\n            String l=s.substring(0,i);\\n            String r=s.substring(i,s.length());\\n            max=Math.max(max,count(l,\\'0\\')+count(r,\\'1\\'));\\n        }\\n        return max;\\n    }\\n    private int count(String side, char ch){\\n        int c=0;\\n        for(int i=0;i<side.length();i++)\\n            if(side.charAt(i)==ch)\\n                c++;\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(String s) {\\n        int max=0;\\n        for(int i=1;i<s.length();i++){\\n            String l=s.substring(0,i);\\n            String r=s.substring(i,s.length());\\n            max=Math.max(max,count(l,\\'0\\')+count(r,\\'1\\'));\\n        }\\n        return max;\\n    }\\n    private int count(String side, char ch){\\n        int c=0;\\n        for(int i=0;i<side.length();i++)\\n            if(side.charAt(i)==ch)\\n                c++;\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631273,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        s1= 0\\n\\n        for i in range(1,len(s)):\\n            s1 = max(s1,s[:i].count(\\'0\\') + s[i:].count(\\'1\\'))\\n\\n        return s1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        s1= 0\\n\\n        for i in range(1,len(s)):\\n            s1 = max(s1,s[:i].count(\\'0\\') + s[i:].count(\\'1\\'))\\n\\n        return s1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625227,
                "title": "easy-solution-using-prefix-sum",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        count_1 = 0\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                count_1 += 1\\n\\n        sum_left, sum_right = 0, count_1\\n        max_sum = 0\\n        # we use len(s) - 1 because the right substring\\n        # cannot be empty\\n        for i in range(len(s)-1):\\n            if s[i] == \"0\":\\n                sum_left += 1\\n            else:\\n                sum_right -= 1\\n\\n            max_sum = max(max_sum, sum_left + sum_right)\\n\\n        return max_sum\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, s: str) -> int:\\n        count_1 = 0\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                count_1 += 1\\n\\n        sum_left, sum_right = 0, count_1\\n        max_sum = 0\\n        # we use len(s) - 1 because the right substring\\n        # cannot be empty\\n        for i in range(len(s)-1):\\n            if s[i] == \"0\":\\n                sum_left += 1\\n            else:\\n                sum_right -= 1\\n\\n            max_sum = max(max_sum, sum_left + sum_right)\\n\\n        return max_sum\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1785460,
                "content": [
                    {
                        "username": "Suraj_chauhan2000",
                        "content": "Why the output is 3 for 1111"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AMerrill](/AMerrill) This is a really good beginner problem that is pretty easy, but contains some edge cases you\\'d want to think about ideally BEFORE failing getting an error."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Because the substrings must be non-empty, so the maximum value occurs when split is \"1\" & \"111\", which has $$0$$ zeroes in left substring and $$3$$ ones in right substring, for max score of 3."
                    },
                    {
                        "username": "topswe",
                        "content": " prefix sum for 0, suffix sum for 1. dp[i] = prefix_sum_0 + suffix_sum_1"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "Output for 111101 is expected to be 4 . How?"
                    },
                    {
                        "username": "j-l-sg",
                        "content": "split as 1 and 11101, left has 0 \\'0\\'s, right has 4 \\'1\\'s, total is 4."
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you would like to figure out how to do it in one pass, check [this](https://leetcode.com/problems/maximum-score-after-splitting-a-string/solutions/3234673/c-beats-100-one-pass-two-variables-optimised/)."
                    }
                ]
            },
            {
                "id": 1721920,
                "content": [
                    {
                        "username": "Suraj_chauhan2000",
                        "content": "Why the output is 3 for 1111"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AMerrill](/AMerrill) This is a really good beginner problem that is pretty easy, but contains some edge cases you\\'d want to think about ideally BEFORE failing getting an error."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Because the substrings must be non-empty, so the maximum value occurs when split is \"1\" & \"111\", which has $$0$$ zeroes in left substring and $$3$$ ones in right substring, for max score of 3."
                    },
                    {
                        "username": "topswe",
                        "content": " prefix sum for 0, suffix sum for 1. dp[i] = prefix_sum_0 + suffix_sum_1"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "Output for 111101 is expected to be 4 . How?"
                    },
                    {
                        "username": "j-l-sg",
                        "content": "split as 1 and 11101, left has 0 \\'0\\'s, right has 4 \\'1\\'s, total is 4."
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you would like to figure out how to do it in one pass, check [this](https://leetcode.com/problems/maximum-score-after-splitting-a-string/solutions/3234673/c-beats-100-one-pass-two-variables-optimised/)."
                    }
                ]
            },
            {
                "id": 1998077,
                "content": [
                    {
                        "username": "Suraj_chauhan2000",
                        "content": "Why the output is 3 for 1111"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AMerrill](/AMerrill) This is a really good beginner problem that is pretty easy, but contains some edge cases you\\'d want to think about ideally BEFORE failing getting an error."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Because the substrings must be non-empty, so the maximum value occurs when split is \"1\" & \"111\", which has $$0$$ zeroes in left substring and $$3$$ ones in right substring, for max score of 3."
                    },
                    {
                        "username": "topswe",
                        "content": " prefix sum for 0, suffix sum for 1. dp[i] = prefix_sum_0 + suffix_sum_1"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "Output for 111101 is expected to be 4 . How?"
                    },
                    {
                        "username": "j-l-sg",
                        "content": "split as 1 and 11101, left has 0 \\'0\\'s, right has 4 \\'1\\'s, total is 4."
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you would like to figure out how to do it in one pass, check [this](https://leetcode.com/problems/maximum-score-after-splitting-a-string/solutions/3234673/c-beats-100-one-pass-two-variables-optimised/)."
                    }
                ]
            },
            {
                "id": 1815826,
                "content": [
                    {
                        "username": "Suraj_chauhan2000",
                        "content": "Why the output is 3 for 1111"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AMerrill](/AMerrill) This is a really good beginner problem that is pretty easy, but contains some edge cases you\\'d want to think about ideally BEFORE failing getting an error."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Because the substrings must be non-empty, so the maximum value occurs when split is \"1\" & \"111\", which has $$0$$ zeroes in left substring and $$3$$ ones in right substring, for max score of 3."
                    },
                    {
                        "username": "topswe",
                        "content": " prefix sum for 0, suffix sum for 1. dp[i] = prefix_sum_0 + suffix_sum_1"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "Output for 111101 is expected to be 4 . How?"
                    },
                    {
                        "username": "j-l-sg",
                        "content": "split as 1 and 11101, left has 0 \\'0\\'s, right has 4 \\'1\\'s, total is 4."
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you would like to figure out how to do it in one pass, check [this](https://leetcode.com/problems/maximum-score-after-splitting-a-string/solutions/3234673/c-beats-100-one-pass-two-variables-optimised/)."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Ascending Subarray Sum",
        "question_content": "<p>Given an array of positive integers <code>nums</code>, return the <em>maximum possible sum of an <strong>ascending</strong> subarray in </em><code>nums</code>.</p>\n\n<p>A subarray is defined as a contiguous sequence of numbers in an array.</p>\n\n<p>A subarray <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> is <strong>ascending</strong> if for all <code>i</code> where <code>l &lt;= i &lt; r</code>, <code>nums<sub>i </sub> &lt; nums<sub>i+1</sub></code>. Note that a subarray of size <code>1</code> is <strong>ascending</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,20,30,5,10,50]\n<strong>Output:</strong> 65\n<strong>Explanation: </strong>[5,10,50] is the ascending subarray with the maximum sum of 65.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,20,30,40,50]\n<strong>Output:</strong> 150\n<strong>Explanation: </strong>[10,20,30,40,50] is the ascending subarray with the maximum sum of 150.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,17,15,13,10,11,12]\n<strong>Output:</strong> 33\n<strong>Explanation: </strong>[10,11,12] is the ascending subarray with the maximum sum of 33.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1168768,
                "title": "java-one-pas-solution",
                "content": "If you like it pls upvote\\n\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int res = nums[0],temp = nums[0];\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] > nums[i-1])\\n                temp+=nums[i];\\n            else\\n                temp = nums[i];\\n            res = Math.max(res,temp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int res = nums[0],temp = nums[0];\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] > nums[i-1])\\n                temp+=nums[i];\\n            else\\n                temp = nums[i];\\n            res = Math.max(res,temp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122323,
                "title": "c-maximum-subarray",
                "content": "Pretty nice easy problem, actually. A twist of [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/).\\n\\n**C++**\\n```cpp\\nint maxAscendingSum(vector<int>& nums) {\\n    int res = 0, sum = nums[0];\\n    for (auto i = 1; i < nums.size(); ++i) {\\n        if (nums[i] <= nums[i - 1]) {\\n            res = max(res, sum);\\n            sum = 0;\\n        }\\n        sum += nums[i];\\n    }\\n    return max(res, sum);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxAscendingSum(vector<int>& nums) {\\n    int res = 0, sum = nums[0];\\n    for (auto i = 1; i < nums.size(); ++i) {\\n        if (nums[i] <= nums[i - 1]) {\\n            res = max(res, sum);\\n            sum = 0;\\n        }\\n        sum += nums[i];\\n    }\\n    return max(res, sum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119854,
                "title": "python3-easy-one-pass-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        res = 0\\n        sum = 0\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i - 1] < nums[i]:\\n                sum += nums[i]\\n            else:\\n                sum = nums[i]\\n            res = max(res, sum)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        res = 0\\n        sum = 0\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i - 1] < nums[i]:\\n                sum += nums[i]\\n            else:\\n                sum = nums[i]\\n            res = max(res, sum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120008,
                "title": "begineer-friendly-explained-solution-java-time-o-n-and-constant-space",
                "content": "**IDEA:**\\nidea is very similar to [Kadanes Algorithm](https://leetcode.com/problems/maximum-subarray/discuss/1108980/Thought-Process-and-O(N)-java-solution). not exactly same because :\\n1.nums values are always going to be positive as per constraint. so as in kadane\\'s either we start from ourself or be a part of previous . Here we know that if there exist a previous valid subarray the sum is definately going to be positive. So I am definately going to merge myself into that . no Point of starting from ourself if valid subarray exist.\\n2.if previous value is greater than me . means No valid subarray is present start from ourself.\\n\\nAnswer can lie in between of the array. \\neg : [12,17,15,13,**10,11,12**,7,4,3]\\nSo we are going to maintain overall maximum and current maximum.\\nI have write 2 ways to code this problem\\n\\n**Complexity:**\\n```\\nTime  : O(n)\\nSpace : O(1)\\n```\\n\\n**Way1:**\\n```\\npublic int maxAscendingSum(int[] nums) {\\n        int currentMax=nums[0];\\n        int overallMax=nums[0];\\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(nums[i]>nums[i-1]){\\n                currentMax+=nums[i];\\n            }else{\\n                currentMax=nums[i];\\n            }\\n            \\n            overallMax=Math.max(currentMax,overallMax);\\n        }\\n        return overallMax;\\n    }\\n```\\n\\n**Way2:**\\n```\\n    public int maxAscendingSum(int[] nums) {\\n        int currentMax=nums[0];\\n        int overallMax=nums[0];\\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(!(nums[i]>nums[i-1])){ \\n                currentMax=0;\\n            }\\n            \\n            currentMax+=nums[i];\\n            overallMax=Math.max(currentMax,overallMax);\\n        }\\n        return overallMax;\\n  }\\n```\\t\\n\\n**Mistake People Generally Do**:\\n###### 1. miss boundary Case (what is array length is zero this code will throw error ) [given constraint nums.length>1 so chill] . Confirm this to your interviewer can array length be 0?\\n###### 2. use concept of LIS(longest increasing subsequence) .. but here **we need subarray** if subsequence is needed then you can use DP concept of LIS.\\n###### 3. If in interview a this question is asked  to you then make sure you clarify this from interviewer:\\n###### 3.1 can sum exceed the Integer.MAX_VALUE?\\n###### 3.2 array contain negative values or not?\\n###### If you just code it up without clarifying these you may get Rejection even after solving in most optimised way.. \\n###### Hope it helps :)\\nPlease **UPVOTE** if found it helpful :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nTime  : O(n)\\nSpace : O(1)\\n```\n```\\npublic int maxAscendingSum(int[] nums) {\\n        int currentMax=nums[0];\\n        int overallMax=nums[0];\\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(nums[i]>nums[i-1]){\\n                currentMax+=nums[i];\\n            }else{\\n                currentMax=nums[i];\\n            }\\n            \\n            overallMax=Math.max(currentMax,overallMax);\\n        }\\n        return overallMax;\\n    }\\n```\n```\\n    public int maxAscendingSum(int[] nums) {\\n        int currentMax=nums[0];\\n        int overallMax=nums[0];\\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(!(nums[i]>nums[i-1])){ \\n                currentMax=0;\\n            }\\n            \\n            currentMax+=nums[i];\\n            overallMax=Math.max(currentMax,overallMax);\\n        }\\n        return overallMax;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338038,
                "title": "c-simple-and-easy-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int max_sum = nums[0], curr = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] < nums[i]) {\\n                curr += nums[i];\\n            }\\n            else {\\n                max_sum = max(max_sum, curr);\\n                curr = nums[i];\\n            }\\n        }\\n        return max(max_sum, curr);\\n    }\\n};\\n```\\n**Like it? plese upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int max_sum = nums[0], curr = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] < nums[i]) {\\n                curr += nums[i];\\n            }\\n            else {\\n                max_sum = max(max_sum, curr);\\n                curr = nums[i];\\n            }\\n        }\\n        return max(max_sum, curr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119686,
                "title": "python3-line-sweep",
                "content": "\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i, x in enumerate(nums): \\n            if not i or nums[i-1] >= nums[i]: val = 0 # reset val \\n            val += nums[i]\\n            ans = max(ans, val)\\n        return ans \\n```\\n\\nEdited on 3/22/2021\\nAdding C++ implementation\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int ans = 0, val = 0; \\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (i == 0 || nums[i-1] >= nums[i]) val = 0; \\n            val += nums[i]; \\n            ans = max(ans, val); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i, x in enumerate(nums): \\n            if not i or nums[i-1] >= nums[i]: val = 0 # reset val \\n            val += nums[i]\\n            ans = max(ans, val)\\n        return ans \\n```\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int ans = 0, val = 0; \\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (i == 0 || nums[i-1] >= nums[i]) val = 0; \\n            val += nums[i]; \\n            ans = max(ans, val); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135736,
                "title": "python-3-solution-beat-95",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        count=nums[0]\\n        final=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>nums[i-1]:\\n                count+=nums[i]\\n            else:\\n                count=nums[i]\\n            final=max(final,count)\\n        return final\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        count=nums[0]\\n        final=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>nums[i-1]:\\n                count+=nums[i]\\n            else:\\n                count=nums[i]\\n            final=max(final,count)\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119685,
                "title": "java-c-my-easy-o-n-linear-solution",
                "content": "// C++\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxAscendingSum(vector<int>& nums) {\\n\\t\\t\\tint ans = nums[0], sum = nums[0];\\n\\t\\t\\tfor(int i = 1; i < nums.size(); i++){\\n\\t\\t\\t\\tsum = nums[i] > nums[i-1] ? sum+nums[i] : nums[i]; \\n\\t\\t\\t\\tans = max(ans, sum);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n// Java\\n\\n\\tclass Solution {\\n\\t\\tpublic int maxAscendingSum(int[] nums) {\\n\\t\\t\\tint ans = nums[0], sum = nums[0];\\n\\t\\t\\tfor(int i = 1; i < nums.length; i++){\\n\\t\\t\\t\\tsum = nums[i] > nums[i-1] ? sum+nums[i] : nums[i]; \\n\\t\\t\\t\\tans = ans > sum? ans: sum;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\nPlease up vote if like solution",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxAscendingSum(vector<int>& nums) {\\n\\t\\t\\tint ans = nums[0], sum = nums[0];\\n\\t\\t\\tfor(int i = 1; i < nums.size(); i++){\\n\\t\\t\\t\\tsum = nums[i] > nums[i-1] ? sum+nums[i] : nums[i]; \\n\\t\\t\\t\\tans = max(ans, sum);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2052206,
                "title": "python-linear-solution-o-n-easy-understanding",
                "content": "<b>Success\\nDetails \\nRuntime: 37 ms, faster than 81.76% of Python3 online submissions for Maximum Ascending Subarray Sum.\\nMemory Usage: 13.8 MB, less than 64.18% of Python3 online submissions for Maximum Ascending Subarray Sum.</b>\\n\\n1. We are iterating  through the array once.\\n\\n2. We are checking if the previous  element is less than or greter than our current element.\\n\\n3. If the current element is grether than thast of our previous  element then we are still in ascending  order and we can add the number in our temperary sum variable.\\n\\n4. If the current element is smaller than previous element we update the maximum sum if the temperary sum is greater than maximum_sum\\n\\n\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        temp=nums[0]\\n        max_sum=0\\n        for i in range(1,len(nums)):\\n            if nums[i-1]>=nums[i]:\\n                if temp>max_sum:\\n                    max_sum=temp\\n                temp=0\\n            temp=temp+nums[i]\\n        if temp>max_sum:\\n            return temp\\n        else:\\n            return max_sum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        temp=nums[0]\\n        max_sum=0\\n        for i in range(1,len(nums)):\\n            if nums[i-1]>=nums[i]:\\n                if temp>max_sum:\\n                    max_sum=temp\\n                temp=0\\n            temp=temp+nums[i]\\n        if temp>max_sum:\\n            return temp\\n        else:\\n            return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430104,
                "title": "easy-to-understand-javascript-solution-reduce",
                "content": "\\tvar maxAscendingSum = function(nums) {\\n\\t\\tconst subarray = nums.reduce((acc, curr, index) => {\\n\\t\\t\\tcurr > nums[index - 1] ? acc[acc.length - 1] += curr : acc.push(curr);\\n\\t\\t\\treturn acc;\\n\\t\\t}, []);\\n\\n\\t\\treturn Math.max(...subarray);\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar maxAscendingSum = function(nums) {\\n\\t\\tconst subarray = nums.reduce((acc, curr, index) => {\\n\\t\\t\\tcurr > nums[index - 1] ? acc[acc.length - 1] += curr : acc.push(curr);\\n\\t\\t\\treturn acc;\\n\\t\\t}, []);\\n\\n\\t\\treturn Math.max(...subarray);\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1283162,
                "title": "python3-o-n-one-loop",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        result = 0\\n        count = 0\\n        for i in range(len(nums) + 1):\\n            if i != 0:\\n                if result < count:\\n                    result = count\\n                if i != len(nums):\\n                    if nums[i - 1] >= nums[i]:\\n                        count = 0\\n            if i != len(nums):\\n                count += nums[i]\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        result = 0\\n        count = 0\\n        for i in range(len(nums) + 1):\\n            if i != 0:\\n                if result < count:\\n                    result = count\\n                if i != len(nums):\\n                    if nums[i - 1] >= nums[i]:\\n                        count = 0\\n            if i != len(nums):\\n                count += nums[i]\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204617,
                "title": "python3-simple-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        sum = nums[0]\\n        x = nums[0]\\n        i = 1\\n        while i < len(nums):\\n            if nums[i] > nums[i-1]:\\n                x += nums[i]\\n            else:\\n                x = nums[i]\\n            sum = max(x,sum)\\n            i += 1\\n        return sum\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        sum = nums[0]\\n        x = nums[0]\\n        i = 1\\n        while i < len(nums):\\n            if nums[i] > nums[i-1]:\\n                x += nums[i]\\n            else:\\n                x = nums[i]\\n            sum = max(x,sum)\\n            i += 1\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159788,
                "title": "golang-o-n-solution-faster-than-100-with-walk-through",
                "content": "[1800. Maximum Ascending Subarray Sum](https://leetcode.com/problems/maximum-ascending-subarray-sum/)\\n\\nThe idea of this solution is pretty simple:\\n\\n* We need two variables, `sum` for the current sum of ascending values and `maximum` for the maximum sum.\\n* Then we loop through `nums`.\\n* Inside the loop, we check whether the current number is greater than the previous number. If so, we can add the number to `sum`.\\n* Else the number is smaller than or equal to the previous number, we can make `maximum` equal to the `math.Max(maximum, sum)` and reset sum to the current number.\\n* After we have looped through `nums` we can make `maximum` equal to `math.Max(maximum, sum)` again.\\n* Now we can return `maximum.`\\n\\n**The Code:**\\n\\n``` go\\nfunc maxAscendingSum(nums []int) int {\\n    maximum := nums[0]\\n    sum := nums[0]\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            sum += nums[i]\\n        } else {\\n            maximum, sum = \\n            int(math.Max(float64(maximum), float64(sum))), nums[i]\\n        }\\n    }\\n    maximum = int(math.Max(float64(maximum), float64(sum)))\\n    return maximum\\n}\\n```\\n\\n**Same Solution Without `math.Max()`**\\n\\n``` go\\nfunc maxAscendingSum(nums []int) int {\\n    maximum := nums[0]\\n    sum := nums[0]\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            sum += nums[i]\\n        } else {\\n            maximum, sum = max(maximum, sum), nums[i]\\n        }\\n    }\\n    maximum = max(maximum, sum)\\n    return maximum\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc maxAscendingSum(nums []int) int {\\n    maximum := nums[0]\\n    sum := nums[0]\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            sum += nums[i]\\n        } else {\\n            maximum, sum = \\n            int(math.Max(float64(maximum), float64(sum))), nums[i]\\n        }\\n    }\\n    maximum = int(math.Max(float64(maximum), float64(sum)))\\n    return maximum\\n}\\n```\n``` go\\nfunc maxAscendingSum(nums []int) int {\\n    maximum := nums[0]\\n    sum := nums[0]\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            sum += nums[i]\\n        } else {\\n            maximum, sum = max(maximum, sum), nums[i]\\n        }\\n    }\\n    maximum = max(maximum, sum)\\n    return maximum\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119810,
                "title": "java-o-n-solution",
                "content": "```\\npublic int maxAscendingSum(int[] nums) {\\n\\tint curSum = 0, max = 0, pre = Integer.MIN_VALUE;\\n\\tfor(int num : nums){\\n\\t\\tcurSum = pre < num ? curSum + num : num;\\n\\t\\tmax = Math.max(max, curSum);\\n\\t\\tpre = num;\\n\\t}\\n\\treturn max;         \\n}\\n```\\n\\nSimilar solution from Stefan_77\\n\\n```\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = nums[0], max = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                sum += nums[i];\\n            } else {\\n                sum = nums[i];\\n            }\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxAscendingSum(int[] nums) {\\n\\tint curSum = 0, max = 0, pre = Integer.MIN_VALUE;\\n\\tfor(int num : nums){\\n\\t\\tcurSum = pre < num ? curSum + num : num;\\n\\t\\tmax = Math.max(max, curSum);\\n\\t\\tpre = num;\\n\\t}\\n\\treturn max;         \\n}\\n```\n```\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = nums[0], max = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                sum += nums[i];\\n            } else {\\n                sum = nums[i];\\n            }\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044687,
                "title": "c-solution-beast-100-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int  n = nums.size();\\n        int currsum = nums[0];\\n        int maxsum = nums[0];\\n        int i = 1;\\n        while(i<n){\\n            if(nums[i]>nums[i-1]){\\n                currsum+=nums[i];\\n            }\\n            else{\\n                maxsum = max(maxsum,currsum);\\n                currsum = nums[i];\\n            }\\n            i++;\\n        }\\n        maxsum = max(maxsum,currsum);\\n        return maxsum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int  n = nums.size();\\n        int currsum = nums[0];\\n        int maxsum = nums[0];\\n        int i = 1;\\n        while(i<n){\\n            if(nums[i]>nums[i-1]){\\n                currsum+=nums[i];\\n            }\\n            else{\\n                maxsum = max(maxsum,currsum);\\n                currsum = nums[i];\\n            }\\n            i++;\\n        }\\n        maxsum = max(maxsum,currsum);\\n        return maxsum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589032,
                "title": "with-explanation-comments-time-3-ms-51-22-space-8-3-mb-84-19",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        \\n        //initialize sum & maximum sum variables with ititial values of the first element\\n        int maxSum=nums[0], sum=nums[0];\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<nums.size();i++){\\n            //check if the subarray is in increasing order, ascending\\n            if(nums[i-1]<nums[i])\\n                //if yes-> add the current value to the sum\\n                sum+=nums[i];\\n            else\\n                //if no-> begin a new sum variable for the new subarray with initiali value of the current element, too\\n                sum=nums[i];\\n            \\n            //at the end, compare and save the maximum possible sum\\n            maxSum=max(maxSum, sum);\\n        }\\n        \\n        //return the maximum possible sum value\\n        return maxSum;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        \\n        //initialize sum & maximum sum variables with ititial values of the first element\\n        int maxSum=nums[0], sum=nums[0];\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<nums.size();i++){\\n            //check if the subarray is in increasing order, ascending\\n            if(nums[i-1]<nums[i])\\n                //if yes-> add the current value to the sum\\n                sum+=nums[i];\\n            else\\n                //if no-> begin a new sum variable for the new subarray with initiali value of the current element, too\\n                sum=nums[i];\\n            \\n            //at the end, compare and save the maximum possible sum\\n            maxSum=max(maxSum, sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2523814,
                "title": "java-simple-and-easy-solution-0ms-100-faster",
                "content": "\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n\\t\\n        int res = Integer.MIN_VALUE;\\n        int sum = nums[0]; // Initially we are storing sum = 10\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) { // checking is i(20) > i-1(10) if yes then we simply add and store it into sum. //adding till the no. is in ascending order.\\n                sum += nums[i]; // sums = 10+20+30=60\\n            } else {\\n                res = Math.max(sum, res); // updating the res(60, -999999999) --> res =60\\n                sum = nums[i];\\n            }\\n        }\\n        res = Math.max(res, sum); // updating the res (60, 65) --> res = 65 =5+10+50\\n        return res;\\n  }\\n}\\nIf you find this code useful, kindly cosider to upvote.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxAscendingSum(int[] nums) {\\n\\t\\n        int res = Integer.MIN_VALUE;\\n        int sum = nums[0]; // Initially we are storing sum = 10\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) { // checking is i(20) > i-1(10) if yes then we simply add and store it into sum. //adding till the no. is in ascending order.\\n                sum += nums[i]; // sums = 10+20+30=60\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2352088,
                "title": "java-simple-clean",
                "content": ">**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int maxAscendingSum(int[] nums) {\\n\\tvar sum = 0;\\n\\tvar maxSum = 0;\\n\\n\\tfor (int i = 0, prev = 0; i < nums.length; prev = nums[i++])\\n\\t\\tif (nums[i] > prev) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t} else {\\n\\t\\t\\tmaxSum = Math.max(maxSum, sum);\\n\\t\\t\\tsum = nums[i];\\n\\t\\t}\\n\\n\\treturn Math.max(maxSum, sum);\\n}\\n```\\n**Variation 2:** Method 1 can be re-written like this\\n```\\npublic int maxAscendingSum(int[] nums) {\\n\\tvar sum = 0;\\n\\tvar maxSum = 0;\\n\\n\\tfor (int i = 0, prev = 0; i < nums.length; sum += prev = nums[i++])\\n\\t\\tif (nums[i] <= prev) {\\n\\t\\t\\tmaxSum = Math.max(maxSum, sum);\\n\\t\\t\\tsum = 0;\\n\\t\\t}\\n\\t\\t\\n\\treturn Math.max(maxSum, sum);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxAscendingSum(int[] nums) {\\n\\tvar sum = 0;\\n\\tvar maxSum = 0;\\n\\n\\tfor (int i = 0, prev = 0; i < nums.length; prev = nums[i++])\\n\\t\\tif (nums[i] > prev) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t} else {\\n\\t\\t\\tmaxSum = Math.max(maxSum, sum);\\n\\t\\t\\tsum = nums[i];\\n\\t\\t}\\n\\n\\treturn Math.max(maxSum, sum);\\n}\\n```\n```\\npublic int maxAscendingSum(int[] nums) {\\n\\tvar sum = 0;\\n\\tvar maxSum = 0;\\n\\n\\tfor (int i = 0, prev = 0; i < nums.length; sum += prev = nums[i++])\\n\\t\\tif (nums[i] <= prev) {\\n\\t\\t\\tmaxSum = Math.max(maxSum, sum);\\n\\t\\t\\tsum = 0;\\n\\t\\t}\\n\\t\\t\\n\\treturn Math.max(maxSum, sum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345109,
                "title": "python-simple-solution-beginner-friendly",
                "content": "```\\nclass Solution(object):\\n    def maxAscendingSum(self, nums):\\n        res = nums[0]\\n        result = []\\n        for i in range(1, len(nums)):\\n            if nums[i-1] < nums[i]:\\n                res += nums[i]\\n            else:\\n                result.append(res)\\n                res = nums[i]\\n        result.append(res)\\n        return max(result)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxAscendingSum(self, nums):\\n        res = nums[0]\\n        result = []\\n        for i in range(1, len(nums)):\\n            if nums[i-1] < nums[i]:\\n                res += nums[i]\\n            else:\\n                result.append(res)\\n                res = nums[i]\\n        result.append(res)\\n        return max(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584405,
                "title": "java-simple-solution",
                "content": "```\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = 0, currSum = 0, previousNumber = Integer.MIN_VALUE;\\n        for (int number : nums) {\\n            if (previousNumber < number) {\\n                currSum += number;\\n            } else {\\n                maxSum = Math.max(maxSum, currSum);\\n                currSum = number;\\n            }\\n            previousNumber = number;\\n        }\\n        return Math.max(maxSum, currSum);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = 0, currSum = 0, previousNumber = Integer.MIN_VALUE;\\n        for (int number : nums) {\\n            if (previousNumber < number) {\\n                currSum += number;\\n            } else {\\n                maxSum = Math.max(maxSum, currSum);\\n                currSum = number;\\n            }\\n            previousNumber = number;\\n        }\\n        return Math.max(maxSum, currSum);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1372830,
                "title": "c-easy-and-simple-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(nums[i+1]>nums[i])\\n            {\\n                sum+=nums[i+1];\\n                \\n            }\\n             else\\n             {\\n                 sum=nums[i+1];\\n             }\\n            res = max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(nums[i+1]>nums[i])\\n            {\\n                sum+=nums[i+1];\\n                \\n            }\\n             else\\n             {\\n                 sum=nums[i+1];\\n             }\\n            res = max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293244,
                "title": "simple-solution",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Maximum Ascending Subarray Sum.**\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = nums[0],sum = nums[0];\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] > nums[i-1])\\n                sum+=nums[i];\\n            else\\n                sum = nums[i];\\n            max = Math.max(max,sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = nums[0],sum = nums[0];\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] > nums[i-1])\\n                sum+=nums[i];\\n            else\\n                sum = nums[i];\\n            max = Math.max(max,sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130601,
                "title": "java-o-n-simplest-solution-8-lines-beats-100",
                "content": "The solution can be summarized in 3 steps:\\n1. Iterate through the array and maintain a sum of all the values.\\n2. Reset the sum whenever you encounter a value that is smaller than or equal to the previous value.\\n3. Update the max at every step. \\n\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = 0, currentSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > 0 && nums[i] <= nums[i - 1]) \\n                currentSum = 0;\\n            currentSum += nums[i];\\n            max = Math.max(currentSum, max);            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = 0, currentSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > 0 && nums[i] <= nums[i - 1]) \\n                currentSum = 0;\\n            currentSum += nums[i];\\n            max = Math.max(currentSum, max);            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126385,
                "title": "python-3-simple-solution-faster-than-96-22",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, l: List[int]) -> int:\\n        ms=l[0]\\n        cs=l[0]\\n        for i in range(1,len(l)):\\n            if l[i]<=l[i-1]:\\n                cs=l[i]\\n            else:\\n                cs+=l[i]  \\n            ms=max(cs,ms)\\n            # print(ms,i)\\n        return ms",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, l: List[int]) -> int:\\n        ms=l[0]\\n        cs=l[0]\\n        for i in range(1,len(l)):\\n            if l[i]<=l[i-1]:\\n                cs=l[i]\\n            else:\\n                cs+=l[i]  \\n            ms=max(cs,ms)\\n            # print(ms,i)\\n        return ms",
                "codeTag": "Java"
            },
            {
                "id": 1126185,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        \"\"\"\\n            thought:\\n                Use for loop to check if the subarray is ascending.\\n                Use the cumsum to add up and keep checking the max.\\n            time:\\n                O(n)\\n            space:\\n                O(1)\\n        \"\"\"\\n        max_ = nums[0]\\n        cumsum = nums[0]\\n        \\n        for i in range(len(nums)-1):\\n            if nums[i+1] - nums[i] > 0:\\n                cumsum += nums[i+1]\\n            else:\\n                cumsum = nums[i+1]\\n            max_ = max(max_, cumsum, nums[i+1])\\n        \\n        return max(max_, cumsum)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        \"\"\"\\n            thought:\\n                Use for loop to check if the subarray is ascending.\\n                Use the cumsum to add up and keep checking the max.\\n            time:\\n                O(n)\\n            space:\\n                O(1)\\n        \"\"\"\\n        max_ = nums[0]\\n        cumsum = nums[0]\\n        \\n        for i in range(len(nums)-1):\\n            if nums[i+1] - nums[i] > 0:\\n                cumsum += nums[i+1]\\n            else:\\n                cumsum = nums[i+1]\\n            max_ = max(max_, cumsum, nums[i+1])\\n        \\n        return max(max_, cumsum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124106,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int prefixSum = nums[0];\\n        int max = nums[0];\\n        for (int i=1; i<nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                prefixSum += nums[i];\\n            }\\n            else {\\n                prefixSum = nums[i];\\n            }\\n            max = Math.max(max, prefixSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int prefixSum = nums[0];\\n        int max = nums[0];\\n        for (int i=1; i<nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                prefixSum += nums[i];\\n            }\\n            else {\\n                prefixSum = nums[i];\\n            }\\n            max = Math.max(max, prefixSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122295,
                "title": "java-beats-o-n-runtime-o-1-space",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n      int maxSum = nums[0];\\n      int tempSum = nums[0];\\n      for(int i = 1;i<nums.length;i++){\\n         if(nums[i] > nums[i-1]){\\n            tempSum+=nums[i];\\n         }\\n         else\\n            tempSum = nums[i];\\n         if(tempSum > maxSum)\\n            maxSum = tempSum;\\n\\n      }\\n      return maxSum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxAscendingSum(int[] nums) {\\n      int maxSum = nums[0];\\n      int tempSum = nums[0];\\n      for(int i = 1;i<nums.length;i++){\\n         if(nums[i] > nums[i-1]){\\n            tempSum+=nums[i];\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1119671,
                "title": "clean-python-one-pass",
                "content": "```\\n\\n    def maxAscendingSum(self, A: List[int]) -> int:\\n        mx,subsum = [],0\\n        A.append(float(\\'inf\\'))        # added extra element to ignore problem with last element (forgotting to calculate last element) \\n        for i in range(len(A)-1):\\n            if A[i] < A[i+1]:\\n                subsum += A[i]                   # calculate sum until we reach a[i]>=a[i+1]\\n            else:\\n                mx.append(subsum + A[i])     # append all subarray sum including the last element in subarray\\n                subsum = 0\\n            if i == len(A) - 2:                # check if we meet last element\\n                mx.append(subsum)\\n        return max(mx) if mx else 0   # return max if it exists otherwise 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n    def maxAscendingSum(self, A: List[int]) -> int:\\n        mx,subsum = [],0\\n        A.append(float(\\'inf\\'))        # added extra element to ignore problem with last element (forgotting to calculate last element) \\n        for i in range(len(A)-1):\\n            if A[i] < A[i+1]:\\n                subsum += A[i]                   # calculate sum until we reach a[i]>=a[i+1]\\n            else:\\n                mx.append(subsum + A[i])     # append all subarray sum including the last element in subarray\\n                subsum = 0\\n            if i == len(A) - 2:                # check if we meet last element\\n                mx.append(subsum)\\n        return max(mx) if mx else 0   # return max if it exists otherwise 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3642548,
                "title": "100-beat-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = nums[0], max = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                sum += nums[i];\\n            } else {\\n                if (max < sum) {\\n                 max = sum;\\n                  }\\n                sum = nums[i];\\n            }\\n        }\\n        if (max < sum) {\\n            max = sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = nums[0], max = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                sum += nums[i];\\n            } else {\\n                if (max < sum) {\\n                 max = sum;\\n                  }\\n                sum = nums[i];\\n            }\\n        }\\n        if (max < sum) {\\n            max = sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483454,
                "title": "straightforward-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        res = 0\\n        temp = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                temp += nums[i]\\n            else:\\n                res = max(res, temp)\\n                temp = nums[i]\\n        return max(res, temp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        res = 0\\n        temp = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                temp += nums[i]\\n            else:\\n                res = max(res, temp)\\n                temp = nums[i]\\n        return max(res, temp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377903,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n      if(nums.size()==1)\\n      return nums[0];\\n    int sum=nums[0];\\n    int ans=0;\\n    for(int i=1;i<nums.size();i++){\\n      if(nums[i]>nums[i-1])\\n      sum+=nums[i];\\n\\n      if(ans<sum)\\n      ans=sum;\\n       if(nums[i]<=nums[i-1])\\n      sum=nums[i];\\n    }\\n      \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n      if(nums.size()==1)\\n      return nums[0];\\n    int sum=nums[0];\\n    int ans=0;\\n    for(int i=1;i<nums.size();i++){\\n      if(nums[i]>nums[i-1])\\n      sum+=nums[i];\\n\\n      if(ans<sum)\\n      ans=sum;\\n       if(nums[i]<=nums[i-1])\\n      sum=nums[i];\\n    }\\n      \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364554,
                "title": "maximum-ascending-subarray-sum-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i, j, k, sum=0, max=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            sum=nums[i];\\n            k = i;\\n            for(j=i+1 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]>nums[k])\\n                {\\n                    sum += nums[j];\\n                    k = j;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            if(sum>max)\\n            {\\n                max = sum;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i, j, k, sum=0, max=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            sum=nums[i];\\n            k = i;\\n            for(j=i+1 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]>nums[k])\\n                {\\n                    sum += nums[j];\\n                    k = j;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            if(sum>max)\\n            {\\n                max = sum;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025372,
                "title": "python-32-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        sumx = -1\\n        for i in range(len(nums)):\\n            subarr=[nums[i]]\\n            for j in range(i+1, len(nums)):\\n                if nums[j]>subarr[-1]:subarr.append(nums[j])\\n                else:break\\n            s=sum(subarr)\\n            if s>sumx:sumx=s\\n        return sumx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        sumx = -1\\n        for i in range(len(nums)):\\n            subarr=[nums[i]]\\n            for j in range(i+1, len(nums)):\\n                if nums[j]>subarr[-1]:subarr.append(nums[j])\\n                else:break\\n            s=sum(subarr)\\n            if s>sumx:sumx=s\\n        return sumx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887772,
                "title": "java-100-time-97-memory-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = nums[0], maxSum = sum;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                sum += nums[i];\\n            } else {\\n                if (maxSum < sum) {\\n                    maxSum = sum;\\n                }\\n                sum = nums[i];\\n            }\\n        }\\n        if (maxSum < sum) {\\n            maxSum = sum;\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = nums[0], maxSum = sum;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                sum += nums[i];\\n            } else {\\n                if (maxSum < sum) {\\n                    maxSum = sum;\\n                }\\n                sum = nums[i];\\n            }\\n        }\\n        if (maxSum < sum) {\\n            maxSum = sum;\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864518,
                "title": "java-golang-0ms-and-beat-100-simple-solution",
                "content": "# Code\\n```\\n//Java solution\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int[] arr = new int[101];\\n\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i < 1){\\n                arr[j] += nums[i];\\n            }else if(nums[i] > nums[i-1]){\\n                arr[j] += nums[i];\\n            }else{\\n                j++;\\n                arr[j] += nums[i];\\n            }\\n        }\\n\\n        int max = 0;\\n\\n        for(int i = 0; i <= j; i++){\\n            if(arr[i] > max) max = arr[i];\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n\\n//Golang solution\\nfunc maxAscendingSum(nums []int) int {\\n    arr := make([]int, 101)\\n\\n    j := 0\\n    for i := 0; i < len(nums); i++{\\n        if i < 1 {\\n            arr[j] += nums[i]\\n        }else if nums[i] > nums[i-1] {\\n            arr[j] += nums[i]\\n        }else{\\n            j++\\n            arr[j] += nums[i]\\n        }\\n\\n    }\\n\\n    max := 0\\n    for i := 0; i <= j; i++{\\n        if arr[i] > max { max = arr[i] }\\n    }\\n\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Go"
                ],
                "code": "```\\n//Java solution\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int[] arr = new int[101];\\n\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i < 1){\\n                arr[j] += nums[i];\\n            }else if(nums[i] > nums[i-1]){\\n                arr[j] += nums[i];\\n            }else{\\n                j++;\\n                arr[j] += nums[i];\\n            }\\n        }\\n\\n        int max = 0;\\n\\n        for(int i = 0; i <= j; i++){\\n            if(arr[i] > max) max = arr[i];\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n\\n//Golang solution\\nfunc maxAscendingSum(nums []int) int {\\n    arr := make([]int, 101)\\n\\n    j := 0\\n    for i := 0; i < len(nums); i++{\\n        if i < 1 {\\n            arr[j] += nums[i]\\n        }else if nums[i] > nums[i-1] {\\n            arr[j] += nums[i]\\n        }else{\\n            j++\\n            arr[j] += nums[i]\\n        }\\n\\n    }\\n\\n    max := 0\\n    for i := 0; i <= j; i++{\\n        if arr[i] > max { max = arr[i] }\\n    }\\n\\n    return max;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835127,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\n   class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int max_sum = nums[0], curr = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] < nums[i]) {\\n                curr += nums[i];\\n            }\\n            else {\\n                max_sum = max(max_sum, curr);\\n                curr = nums[i];\\n            }\\n        }\\n        return max(max_sum, curr);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int max_sum = nums[0], curr = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] < nums[i]) {\\n                curr += nums[i];\\n            }\\n            else {\\n                max_sum = max(max_sum, curr);\\n                curr = nums[i];\\n            }\\n        }\\n        return max(max_sum, curr);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780910,
                "title": "easy-c-solution-cpp",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int curr = nums[0];\\n        int ans = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                ans = max(ans,curr);\\n                curr = nums[i];\\n            }\\n            else \\n            {\\n                curr += nums[i];\\n            }\\n        }\\n        ans = max(ans,curr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int curr = nums[0];\\n        int ans = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                ans = max(ans,curr);\\n                curr = nums[i];\\n            }\\n            else \\n            {\\n                curr += nums[i];\\n            }\\n        }\\n        ans = max(ans,curr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779160,
                "title": "java-two-pointer-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        int i = 0, max = 0;\\n        while(i<nums.length){\\n            int count = nums[i];\\n            for(int j = i;j<nums.length-1;j++){\\n                if(nums[j+1]<=nums[j]){\\n                    max = Math.max(count, max);\\n                    break; \\n                }\\n                else{\\n                    count+= nums[j+1];\\n                    max = Math.max(max, count);\\n                }\\n            }\\n            i++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        int i = 0, max = 0;\\n        while(i<nums.length){\\n            int count = nums[i];\\n            for(int j = i;j<nums.length-1;j++){\\n                if(nums[j+1]<=nums[j]){\\n                    max = Math.max(count, max);\\n                    break; \\n                }\\n                else{\\n                    count+= nums[j+1];\\n                    max = Math.max(max, count);\\n                }\\n            }\\n            i++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671585,
                "title": "solution-from-niyaz-java",
                "content": "```\\n\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = 0;\\n        int sum = nums[0];\\n        int cur = nums[0];\\n        for (int i = 1; i <= nums.length-1; i++) {\\n            if (cur < nums[i]) {\\n                sum += nums[i];\\n                cur = nums[i];\\n            } else {\\n                    maxSum = Math.max(maxSum, sum);\\n                    sum = nums[i];\\n                    cur = nums[i];\\n            }\\n        }\\n        return Math.max(maxSum, sum);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = 0;\\n        int sum = nums[0];\\n        int cur = nums[0];\\n        for (int i = 1; i <= nums.length-1; i++) {\\n            if (cur < nums[i]) {\\n                sum += nums[i];\\n                cur = nums[i];\\n            } else {\\n                    maxSum = Math.max(maxSum, sum);\\n                    sum = nums[i];\\n                    cur = nums[i];\\n            }\\n        }\\n        return Math.max(maxSum, sum);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330038,
                "title": "simple-python3-solution-faster-than-95-89",
                "content": "```\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        res = 0\\n        \\n        curr = nums[0]\\n        for i, n in enumerate(nums[1:]):\\n            if n <= nums[i]:\\n                res = max(res, curr)\\n                curr = n\\n            else:\\n                curr += n\\n                \\n        return max(res, curr)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        res = 0\\n        \\n        curr = nums[0]\\n        for i, n in enumerate(nums[1:]):\\n            if n <= nums[i]:\\n                res = max(res, curr)\\n                curr = n\\n            else:\\n                curr += n\\n                \\n        return max(res, curr)",
                "codeTag": "Python3"
            },
            {
                "id": 2315584,
                "title": "go-one-pass",
                "content": "```\\nfunc maxAscendingSum(nums []int) int {\\n    globalSum, currentSum := nums[0], nums[0]\\n    \\n    for i := 1; i < len(nums); i++ {\\n        globalSum = max(globalSum, nums[i])\\n        \\n        if nums[i] > nums[i-1] {\\n            currentSum += nums[i]\\n        } else {\\n            globalSum = max(globalSum, currentSum)\\n            currentSum = nums[i]\\n        }\\n    }\\n    \\n    return max(globalSum, currentSum)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxAscendingSum(nums []int) int {\\n    globalSum, currentSum := nums[0], nums[0]\\n    \\n    for i := 1; i < len(nums); i++ {\\n        globalSum = max(globalSum, nums[i])\\n        \\n        if nums[i] > nums[i-1] {\\n            currentSum += nums[i]\\n        } else {\\n            globalSum = max(globalSum, currentSum)\\n            currentSum = nums[i]\\n        }\\n    }\\n    \\n    return max(globalSum, currentSum)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281490,
                "title": "java-easy-understandable-solution-0ms-faster",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int ans=0;\\n        int sum=nums[0];\\n        \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                sum+=nums[i];\\n            }\\n            else{\\n                ans=Math.max(ans,sum);\\n                sum=nums[i];\\n            }\\n        }\\n       \\n        return Math.max(ans,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int ans=0;\\n        int sum=nums[0];\\n        \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                sum+=nums[i];\\n            }\\n            else{\\n                ans=Math.max(ans,sum);\\n                sum=nums[i];\\n            }\\n        }\\n       \\n        return Math.max(ans,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278104,
                "title": "java-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0];\\n        int last=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                last+=nums[i];\\n            }else{\\n                max=Math.max(max, last);\\n                last=nums[i];\\n            }\\n        }\\n        return Math.max(max, last);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0];\\n        int last=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                last+=nums[i];\\n            }else{\\n                max=Math.max(max, last);\\n                last=nums[i];\\n            }\\n        }\\n        return Math.max(max, last);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265368,
                "title": "c-100",
                "content": "```\\nint maxAscendingSum(int* nums, int ns){\\n\\n        int m = nums[0];\\n        int curr_max = nums[0];\\n        for(int i = 1; i < ns; i++)\\n        {\\n            if(nums[i] > nums[i-1])\\n            {\\n                curr_max += nums[i];\\n                m = fmax(m, curr_max);\\n            }\\n            else\\n                curr_max = nums[i];     \\n        }\\n        return m;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxAscendingSum(int* nums, int ns){\\n\\n        int m = nums[0];\\n        int curr_max = nums[0];\\n        for(int i = 1; i < ns; i++)\\n        {\\n            if(nums[i] > nums[i-1])\\n            {\\n                curr_max += nums[i];\\n                m = fmax(m, curr_max);\\n            }\\n            else\\n                curr_max = nums[i];     \\n        }\\n        return m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2215473,
                "title": "c-simple-easy-t-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/dfeca59d-24b0-4ca0-baf7-78a8c751bfb6_1656539043.0274851.png)\\n\\n**T-> O(N) && S-> O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxAscendingSum(vector<int>& nums) {\\n\\t\\t\\tnums.push_back(-1);\\n\\t\\t\\tint n=nums.size(),ans=0,sum=0;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tif(nums[i]<nums[i+1])sum+=nums[i];\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\t\\tans=max(ans,sum);\\n\\t\\t\\t\\t\\tsum=0;\\n\\t\\t\\t\\t}    \\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxAscendingSum(vector<int>& nums) {\\n\\t\\t\\tnums.push_back(-1);\\n\\t\\t\\tint n=nums.size(),ans=0,sum=0;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tif(nums[i]<nums[i+1])sum+=nums[i];\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\t\\tans=max(ans,sum);\\n\\t\\t\\t\\t\\tsum=0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2209974,
                "title": "0-ms-100-faster-maximum-subarray-clean-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxAscendingSum(vector<int>& nums) {\\n\\t\\t\\tint ans=0,sum=nums[0];\\n\\t\\t\\tfor(int i=1;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i-1]<nums[i]){\\n\\t\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tans=max(ans,sum);\\n\\t\\t\\t\\t\\tsum=nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn max(ans,sum);\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxAscendingSum(vector<int>& nums) {\\n\\t\\t\\tint ans=0,sum=nums[0];\\n\\t\\t\\tfor(int i=1;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i-1]<nums[i]){\\n\\t\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2159633,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int max_sum = nums[0], curr = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] < nums[i]) {\\n                curr += nums[i];\\n            }\\n            else {\\n                max_sum = max(max_sum, curr);\\n                curr = nums[i];\\n            }\\n        }\\n        return max(max_sum, curr);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int max_sum = nums[0], curr = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i-1] < nums[i]) {\\n                curr += nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2130182,
                "title": "maximum-ascending-subarray-sum",
                "content": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=INT_MIN;\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            while(i+1<n&&nums[i+1]>nums[i]){\\n                ans+=nums[i];\\n                if(res<ans) res=ans;\\n                i++;\\n            }\\n            ans+=nums[i];\\n            if(res<ans) res=ans;\\n            ans=0;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=INT_MIN;\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            while(i+1<n&&nums[i+1]>nums[i]){\\n                ans+=nums[i];\\n                if(res<ans) res=ans;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2121735,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int maxEnding=0;\\n        int maxSoFar=0;\\n        if(nums.size()<=1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(i!=nums.size()-1 && nums[i]<nums[i+1]){\\n                 maxEnding=maxEnding+nums[i];\\n                 if(maxSoFar<maxEnding){\\n                maxSoFar=maxEnding;\\n            }\\n            }else{\\n              \\n                maxEnding=maxEnding+nums[i];\\n                if(maxSoFar<maxEnding){\\n                     maxSoFar=maxEnding;\\n                }\\n               \\n                maxEnding=0;\\n            }\\n           \\n          \\n           \\n        }\\n        return maxSoFar;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int maxEnding=0;\\n        int maxSoFar=0;\\n        if(nums.size()<=1){\\n            return nums[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2108808,
                "title": "java-easy-100",
                "content": "```\\npublic int maxAscendingSum(int[] nums) {\\n        int max=0;\\n        for(int i:nums){\\n            max=Math.max(max,i);\\n        }\\n        int ans=nums[0];\\n        int main=0;\\n        for(int i=1;i<nums.length;i++){   //[90,10,20,30]\\n            if(nums[i]>nums[i-1]){\\n                ans+=nums[i];\\n                main=Math.max(main,ans);\\n            }else{\\n\\n                ans=nums[i];\\n                }\\n        }\\n        return Math.max(max,main);\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxAscendingSum(int[] nums) {\\n        int max=0;\\n        for(int i:nums){\\n            max=Math.max(max,i);\\n        }\\n        int ans=nums[0];\\n        int main=0;\\n        for(int i=1;i<nums.length;i++){   //[90,10,20,30]\\n            if(nums[i]>nums[i-1]){\\n                ans+=nums[i];\\n                main=Math.max(main,ans);\\n            }else{\\n\\n                ans=nums[i];\\n                }\\n        }\\n        return Math.max(max,main);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2102983,
                "title": "python-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        maxSum = 0\\n        subSum = 0\\n        \\n        for i in range(len(nums)):\\n            \\n            if i == 0 or nums[i-1] < nums[i]:\\n                subSum += nums[i]\\n                maxSum = max(maxSum, subSum)\\n            else:\\n                subSum = nums[i]\\n                \\n        return maxSum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        maxSum = 0\\n        subSum = 0\\n        \\n        for i in range(len(nums)):\\n            \\n            if i == 0 or nums[i-1] < nums[i]:\\n                subSum += nums[i]\\n                maxSum = max(maxSum, subSum)\\n            else:\\n                subSum = nums[i]\\n                \\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065480,
                "title": "c-easy-solution-dp",
                "content": "Hey all..\\nI have solved this in cpp using Global sum and local sum in Dynamic programming.\\nIf you have any doubts be free to ask..\\nand please upvote if you understood or found it useful :)\\n\\nThank you..\\n\\nTC= O(N)\\nSC= O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n\\t    // mx for global max sum and curr for local iteration sum\\n        int mx=0,curr=0;\\n\\t\\t\\n\\t\\t// adding lowest value at end to compare for last element\\n        nums.push_back(1);\\n\\t\\t\\n\\t\\t// If its only one element return it\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n\\t\\t\\n        // traverse the array\\n        for(int i=0;i<nums.size()-1;i++){\\n\\t\\t    //compare ith and next element \\n\\t\\t\\t//if its in ascending add\\n            if(nums[i]<nums[i+1]){\\n                curr+=nums[i];\\n            }\\n            else{\\n\\t\\t\\t\\t// else add current and update mx \\n                curr+=nums[i];\\n                mx=max(mx,curr);\\n\\t\\t\\t\\t// since its descending update local sum\\n                curr=0;\\n            }\\n        }\\n\\t\\t// overall mx sum\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n\\t    // mx for global max sum and curr for local iteration sum\\n        int mx=0,curr=0;\\n\\t\\t\\n\\t\\t// adding lowest value at end to compare for last element\\n        nums.push_back(1);\\n\\t\\t\\n\\t\\t// If its only one element return it\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n\\t\\t\\n        // traverse the array\\n        for(int i=0;i<nums.size()-1;i++){\\n\\t\\t    //compare ith and next element \\n\\t\\t\\t//if its in ascending add\\n            if(nums[i]<nums[i+1]){\\n                curr+=nums[i];\\n            }\\n            else{\\n\\t\\t\\t\\t// else add current and update mx \\n                curr+=nums[i];\\n                mx=max(mx,curr);\\n\\t\\t\\t\\t// since its descending update local sum\\n                curr=0;\\n            }\\n        }\\n\\t\\t// overall mx sum\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021210,
                "title": "easy-java-beats-100-solution",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = nums[0];\\n        int curSum = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                curSum+=nums[i];\\n            }else{\\n                maxSum = Math.max(maxSum,curSum);\\n                curSum = nums[i];\\n            }\\n            maxSum = Math.max(maxSum,curSum);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = nums[0];\\n        int curSum = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                curSum+=nums[i];\\n            }else{\\n                maxSum = Math.max(maxSum,curSum);\\n                curSum = nums[i];\\n            }\\n            maxSum = Math.max(maxSum,curSum);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990548,
                "title": "java-100-faster",
                "content": "```\\n\\tpublic int maxAscendingSum(int[] nums) {\\n        int max = nums[0];\\n        int sum = nums[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                sum += nums[i];\\n            } else {\\n                sum = nums[i];\\n            }\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int maxAscendingSum(int[] nums) {\\n        int max = nums[0];\\n        int sum = nums[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                sum += nums[i];\\n            } else {\\n                sum = nums[i];\\n            }\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935624,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=0;\\n        int sum=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                sum+=nums[i];\\n            else\\n            {\\n                sum+=nums[i];\\n                max=Math.max(max,sum);\\n                sum=0;\\n            }\\n        }\\n        sum+=nums[nums.length-1];\\n        max=Math.max(max,sum);\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=0;\\n        int sum=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                sum+=nums[i];\\n            else\\n            {\\n                sum+=nums[i];\\n                max=Math.max(max,sum);\\n                sum=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1639270,
                "title": "most-understandable-c-solution",
                "content": "```\\nint maxAscendingSum(int* nums, int numsSize){\\n    int i, sum = nums[0], max = nums[0];\\n    \\n    for(i = 1; i < numsSize; i++){\\n        if(nums[i] > nums[i - 1])\\n            sum += nums[i];\\n        else\\n            sum = nums[i];\\n        \\n        max = sum > max? sum: max;\\n    }\\n    \\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxAscendingSum(int* nums, int numsSize){\\n    int i, sum = nums[0], max = nums[0];\\n    \\n    for(i = 1; i < numsSize; i++){\\n        if(nums[i] > nums[i - 1])\\n            sum += nums[i];\\n        else\\n            sum = nums[i];\\n        \\n        max = sum > max? sum: max;\\n    }\\n    \\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601274,
                "title": "java-o-n-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = 0;\\n        int currentMax = nums[0];\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            //if the order breaks, update the max and reset currentMax\\n            if(nums[i] <= nums[i-1]) \\n            {\\n                max = Math.max(max, currentMax);\\n                currentMax = 0;\\n            }\\n            currentMax+=nums[i];\\n        }\\n        return Math.max(max, currentMax);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = 0;\\n        int currentMax = nums[0];\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            //if the order breaks, update the max and reset currentMax\\n            if(nums[i] <= nums[i-1]) \\n            {\\n                max = Math.max(max, currentMax);\\n                currentMax = 0;\\n            }\\n            currentMax+=nums[i];\\n        }\\n        return Math.max(max, currentMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573523,
                "title": "c-o-n-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) \\n    {\\n        int max_sum = 0,sum = 0;\\n        sum = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                sum += nums[i];\\n            }\\n            else\\n            {\\n                max_sum = max(max_sum,sum);\\n                sum = nums[i];\\n            }\\n            cout<<sum<<\" \";\\n        }\\n        max_sum = max(max_sum,sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) \\n    {\\n        int max_sum = 0,sum = 0;\\n        sum = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                sum += nums[i];\\n            }\\n            else\\n            {\\n                max_sum = max(max_sum,sum);\\n                sum = nums[i];\\n            }\\n            cout<<sum<<\" \";\\n        }\\n        max_sum = max(max_sum,sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1540483,
                "title": "o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        if(len(nums)<2):\\n            return(nums[0])\\n        \\n        s=0\\n        x=nums[0]\\n        for i in range(1,len(nums)):\\n            if(nums[i-1]<nums[i]):\\n                x=x+nums[i]\\n                s=max([s,x])\\n            else:\\n                s=max([s,x])\\n                x=nums[i]\\n\\n        return(s)\\n```\\nif u liked the code...plz upvote...thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        if(len(nums)<2):\\n            return(nums[0])\\n        \\n        s=0\\n        x=nums[0]\\n        for i in range(1,len(nums)):\\n            if(nums[i-1]<nums[i]):\\n                x=x+nums[i]\\n                s=max([s,x])\\n            else:\\n                s=max([s,x])\\n                x=nums[i]\\n\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529878,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxAscendingSum(vector<int> &nums)\\n    {\\n        int maxsum = INT_MIN;\\n        int n = nums.size();\\n        int tempsum = nums[0];\\n        for (int i = 0; i < (n - 1); ++i)\\n        {\\n            if (nums[i] >= nums[i + 1])\\n            {\\n                maxsum = max(maxsum, tempsum);\\n                tempsum = 0;\\n            }\\n\\n            tempsum += nums[i + 1];\\n        }\\n        maxsum = max(maxsum, tempsum);\\n        return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxAscendingSum(vector<int> &nums)\\n    {\\n        int maxsum = INT_MIN;\\n        int n = nums.size();\\n        int tempsum = nums[0];\\n        for (int i = 0; i < (n - 1); ++i)\\n        {\\n            if (nums[i] >= nums[i + 1])\\n            {\\n                maxsum = max(maxsum, tempsum);\\n                tempsum = 0;\\n            }\\n\\n            tempsum += nums[i + 1];\\n        }\\n        maxsum = max(maxsum, tempsum);\\n        return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504964,
                "title": "java-0ms-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        \\n        int i, sum = nums[0], maxsum = 0;\\n        \\n        for(i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                sum += nums[i];\\n            }\\n            else {\\n                maxsum = Math.max(maxsum, sum);\\n                sum = nums[i];\\n            }\\n        }\\n        return Math.max(maxsum, sum);\\n    }\\n}\\n```\\nplease **upvote** if found helpful :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        \\n        int i, sum = nums[0], maxsum = 0;\\n        \\n        for(i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                sum += nums[i];\\n            }\\n            else {\\n                maxsum = Math.max(maxsum, sum);\\n                sum = nums[i];\\n            }\\n        }\\n        return Math.max(maxsum, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489154,
                "title": "java-beats100-kadane-algorithm-variant",
                "content": "```\\n        int sum= nums[0], maxSum= sum;\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n                sum=sum+ nums[i];\\n            else\\n                sum=nums[i];\\n       \\n            maxSum= Math.max(sum,maxSum);\\n        }\\n        return maxSum;\\n```",
                "solutionTags": [],
                "code": "```\\n        int sum= nums[0], maxSum= sum;\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n                sum=sum+ nums[i];\\n            else\\n                sum=nums[i];\\n       \\n            maxSum= Math.max(sum,maxSum);\\n        }\\n        return maxSum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444436,
                "title": "faster-than-99-memory-usage-less-than-97-python-solution",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        current=nums[0]\\n        res=nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i-1]<nums[i]:\\n                current+=nums[i]\\n                res = max(res, current)\\n            else:\\n                current=nums[i]\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        current=nums[0]\\n        res=nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i-1]<nums[i]:\\n                current+=nums[i]\\n                res = max(res, current)\\n            else:\\n                current=nums[i]\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1399495,
                "title": "o-n-c-solution",
                "content": "```\\n int maxAscendingSum(vector<int>& nums) {\\n        int large=INT_MIN,sum=0;\\n        sum+=nums[0];\\n        large=sum;\\n        for(int i=1;i<nums.size();i++){\\n             if(nums[i-1]<nums[i]){\\n                sum+=nums[i];\\n            }\\n            else if(nums[i-1]>=nums[i]){\\n                large = max(sum,large);\\n                sum=nums[i];\\n            }\\n            \\n        }\\n        large=max(sum,large);\\n        return large;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int maxAscendingSum(vector<int>& nums) {\\n        int large=INT_MIN,sum=0;\\n        sum+=nums[0];\\n        large=sum;\\n        for(int i=1;i<nums.size();i++){\\n             if(nums[i-1]<nums[i]){\\n                sum+=nums[i];\\n            }\\n            else if(nums[i-1]>=nums[i]){\\n                large = max(sum,large);\\n                sum=nums[i];\\n            }\\n            \\n        }\\n        large=max(sum,large);\\n        return large;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1393138,
                "title": "c-lengthy-but-100-time-86-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i=0,sum2=0,sum=0,res=0;\\n        while(i<nums.size()-1){\\n            sum2=nums[i];\\n            if(nums[i]<nums[i+1]){\\n                sum+=nums[i];\\n                while(i<nums.size()-1&&nums[i]<nums[i+1]){\\n                    sum+=nums[i+1];\\n                    i++;\\n                    }\\n            }\\n            \\n            res=max(res,max(sum2,sum));\\n            i++;\\n            sum2=0,sum=0;\\n        }\\n        res=max(res,nums[nums.size()-1]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i=0,sum2=0,sum=0,res=0;\\n        while(i<nums.size()-1){\\n            sum2=nums[i];\\n            if(nums[i]<nums[i+1]){\\n                sum+=nums[i];\\n                while(i<nums.size()-1&&nums[i]<nums[i+1]){\\n                    sum+=nums[i+1];\\n                    i++;\\n                    }\\n            }\\n            \\n            res=max(res,max(sum2,sum));\\n            i++;\\n            sum2=0,sum=0;\\n        }\\n        res=max(res,nums[nums.size()-1]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389400,
                "title": "python-o-n-time-o-1-space",
                "content": "\\n```python\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i - 1]: # A rule violation. We have reached an element that is less than previous so sum must reset.\\n                curr_sum = nums[i]\\n            else:\\n                curr_sum += nums[i]\\n\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i - 1]: # A rule violation. We have reached an element that is less than previous so sum must reset.\\n                curr_sum = nums[i]\\n            else:\\n                curr_sum += nums[i]\\n\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389023,
                "title": "faster-than-100-percent-solution-easy",
                "content": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans=nums;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1]) ans[i+1]+=ans[i];\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[ans.size()-1];\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans=nums;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1]) ans[i+1]+=ans[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1388104,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        currentSum = nums[0]\\n        maxSum = currentSum\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                currentSum += nums[i]\\n                maxSum = max(maxSum, currentSum)\\n            else:\\n                currentSum = nums[i]\\n        \\n        return maxSum\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        currentSum = nums[0]\\n        maxSum = currentSum\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                currentSum += nums[i]\\n                maxSum = max(maxSum, currentSum)\\n            else:\\n                currentSum = nums[i]\\n        \\n        return maxSum\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387065,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n      curMax = nums[0]\\n      out = 0\\n      tot = 0\\n      for i, each in enumerate(nums):\\n          if nums[i] > curMax:\\n            curMax = nums[i]\\n            tot += nums[i]\\n          else:\\n            tot = nums[i]\\n            curMax = nums[i]\\n          out = max(tot, out)\\n      return out\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n      curMax = nums[0]\\n      out = 0\\n      tot = 0\\n      for i, each in enumerate(nums):\\n          if nums[i] > curMax:\\n            curMax = nums[i]\\n            tot += nums[i]\\n          else:\\n            tot = nums[i]\\n            curMax = nums[i]\\n          out = max(tot, out)\\n      return out\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347514,
                "title": "java-100-faster-0ms-using-2-pointer-approach",
                "content": "<-----**If you like the solution . Kindly UPvote for better reach**\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0],sum=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n                sum+=nums[i];\\n            else\\n            {\\n                if(max<sum)\\n                    max=sum;\\n                sum=nums[i];\\n            }\\n        }\\n        if(max<sum)\\n            max=sum;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0],sum=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n                sum+=nums[i];\\n            else\\n            {\\n                if(max<sum)\\n                    max=sum;\\n                sum=nums[i];\\n            }\\n        }\\n        if(max<sum)\\n            max=sum;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286668,
                "title": "simple-java-solution-with-1-pointer-and-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = 0;\\n        int result = nums[0];\\n        if(nums.length == 1){\\n            return result;\\n        }\\n        \\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                result += nums[i];\\n                continue;\\n            }\\n            max = Math.max(result, max);\\n            result = nums[i];\\n        }\\n        return Math.max(result, max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = 0;\\n        int result = nums[0];\\n        if(nums.length == 1){\\n            return result;\\n        }\\n        \\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                result += nums[i];\\n                continue;\\n            }\\n            max = Math.max(result, max);\\n            result = nums[i];\\n        }\\n        return Math.max(result, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281750,
                "title": "c-1-loop-sol-simple-basic-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& arr) {\\n        int i, curSum=arr[0], mx = arr[0];\\n        \\n        for(i=1; i<arr.size(); i++){\\n            if(arr[i] > arr[i-1]){\\n                curSum +=arr[i];\\n            }\\n            else\\n                curSum = arr[i];\\n            mx = max(mx, curSum);\\n        }\\n        \\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& arr) {\\n        int i, curSum=arr[0], mx = arr[0];\\n        \\n        for(i=1; i<arr.size(); i++){\\n            if(arr[i] > arr[i-1]){\\n                curSum +=arr[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1272947,
                "title": "clear-python3-sliding-window-max-subarray-code-easy-to-understand-beats-94",
                "content": "To find the Max Ascending Sum, we can find the total for each increasing section of an array. \\n\\nWe know we are in the increasing section of an array if the current element we are looking at (which is `x`) is greater than the last element.\\n\\nTo start out, we let last be one less than the first element so that the first element is always recognized as the start of an increasing subarray.\\n\\nThen we simply update `maxSoFar` whenever an increasing subarray ends (as that has the potential to yield a new maximum sum so far) and then we just return the max sum we saw.\\n\\n```py\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        total = maxSoFar = 0\\n        last = nums[0] - 1\\n        for x in nums:\\n            if x > last:\\n                total += x\\n            else:\\n                maxSoFar = max(maxSoFar, total)\\n                total = x\\n            last = x\\n        maxSoFar = max(maxSoFar, total)\\n        return maxSoFar\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```py\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        total = maxSoFar = 0\\n        last = nums[0] - 1\\n        for x in nums:\\n            if x > last:\\n                total += x\\n            else:\\n                maxSoFar = max(maxSoFar, total)\\n                total = x\\n            last = x\\n        maxSoFar = max(maxSoFar, total)\\n        return maxSoFar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253660,
                "title": "java-0ms-100",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int max=nums[0];\\n        int sum=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                sum+=nums[i];\\n                max=Math.max(max,sum);\\n            }else{\\n                sum=nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int max=nums[0];\\n        int sum=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                sum+=nums[i];\\n                max=Math.max(max,sum);\\n            }else{\\n                sum=nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240458,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\npublic int maxAscendingSum(int[] nums) {\\n\\tint max = nums[0], count = nums[0];\\n\\tfor (int i=1; i<nums.length; i++) {\\n\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tcount += nums[i];\\n\\t\\t} else {\\n\\t\\t\\tcount = nums[i];\\n\\t\\t}\\n\\t\\tmax = max < count ? count : max;\\n\\t}\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxAscendingSum(int[] nums) {\\n\\tint max = nums[0], count = nums[0];\\n\\tfor (int i=1; i<nums.length; i++) {\\n\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tcount += nums[i];\\n\\t\\t} else {\\n\\t\\t\\tcount = nums[i];\\n\\t\\t}\\n\\t\\tmax = max < count ? count : max;\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233632,
                "title": "c-faster-than-100-solutions",
                "content": "```\\n class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n      vector<int> sum;\\n      sum.push_back(nums[0]);\\n        int ind=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                sum[ind]+=nums[i];\\n            }\\n            else\\n            {\\n                ind++;\\n                sum.push_back(nums[i]);\\n            }\\n        }\\n        int maxi=sum[0];\\n        for(int i=1;i<sum.size();i++)\\n        {\\n            if(maxi<sum[i])\\n                maxi=sum[i];\\n        }\\n        return maxi;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n      vector<int> sum;\\n      sum.push_back(nums[0]);\\n        int ind=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                sum[ind]+=nums[i];\\n            }\\n            else\\n            {\\n                ind++;\\n                sum.push_back(nums[i]);\\n            }\\n        }\\n        int maxi=sum[0];\\n        for(int i=1;i<sum.size();i++)\\n        {\\n            if(maxi<sum[i])\\n                maxi=sum[i];\\n        }\\n        return maxi;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226086,
                "title": "simple-cpp-solution-0-ms-faster-than-100-00",
                "content": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& s) {\\n        \\n        int  n=s.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           int sum=0;\\n            for(int j=i;j<n;j++) {\\n                if(j==i || s[j]>s[j-1])\\n                {\\n                   sum+= s[j];      \\n                   ans = max(sum,ans);\\n                } else break;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& s) {\\n        \\n        int  n=s.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           int sum=0;\\n            for(int j=i;j<n;j++) {\\n                if(j==i || s[j]>s[j-1])\\n                {\\n                   sum+= s[j];      \\n                   ans = max(sum,ans);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1222019,
                "title": "java-solution-100-faster-o-n-basic-method",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=nums[0];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                sum+=nums[i];\\n            }\\n            else{\\n                 max=sum>max ? sum:max;\\n                sum=nums[i];\\n            }\\n        }\\n        if(sum>max){return sum;}//for end sequence sum that doesn\\'t enter else statement above\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=nums[0];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                sum+=nums[i];\\n            }\\n            else{\\n                 max=sum>max ? sum:max;\\n                sum=nums[i];\\n            }\\n        }\\n        if(sum>max){return sum;}//for end sequence sum that doesn\\'t enter else statement above\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219136,
                "title": "c-two-pointers-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i = 0,j = 0;\\n        int res = 0,cur = 0;\\n        while(j < nums.size()) {\\n            if(j == i) {\\n                cur += nums[j];\\n                res = max(res, cur);\\n                j++;\\n                continue;\\n            }\\n            if(nums[j] <= nums[j-1]) {\\n                i = j;\\n                res = max(res, cur);\\n                cur = 0;\\n                continue;\\n            }else {\\n                cur += nums[j];\\n                res = max(res, cur);\\n                j++;\\n            }\\n            cout << cur << \" \";\\n        }\\n        //if(j == nums.size()) res = max(res, cur);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i = 0,j = 0;\\n        int res = 0,cur = 0;\\n        while(j < nums.size()) {\\n            if(j == i) {\\n                cur += nums[j];\\n                res = max(res, cur);\\n                j++;\\n                continue;\\n            }\\n            if(nums[j] <= nums[j-1]) {\\n                i = j;\\n                res = max(res, cur);\\n                cur = 0;\\n                continue;\\n            }else {\\n                cur += nums[j];\\n                res = max(res, cur);\\n                j++;\\n            }\\n            cout << cur << \" \";\\n        }\\n        //if(j == nums.size()) res = max(res, cur);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1208780,
                "title": "javascript-o-n",
                "content": "```\\nvar maxAscendingSum = function(nums) {\\n  let max = nums[0], sum = nums[0]\\n  for(let i=1;i<nums.length;i++){\\n    const curr = nums[i]\\n    if(curr <= nums[i-1]){\\n      sum = 0\\n    }\\n    sum+=curr\\n    max = Math.max(max, sum)\\n  }\\n  return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxAscendingSum = function(nums) {\\n  let max = nums[0], sum = nums[0]\\n  for(let i=1;i<nums.length;i++){\\n    const curr = nums[i]\\n    if(curr <= nums[i-1]){\\n      sum = 0\\n    }\\n    sum+=curr\\n    max = Math.max(max, sum)\\n  }\\n  return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1204696,
                "title": "maximum-ascending-subarray-sum-solution-in-python",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        sum = nums[0]\\n        x = nums[0]\\n        i = 1\\n        l=len(nums)\\n        while i<l:\\n            if nums[i]>nums[i-1]:\\n                x+=nums[i]\\n            else:\\n                x=nums[i]\\n            sum=max(x,sum)\\n            i+=1\\n        return sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        sum = nums[0]\\n        x = nums[0]\\n        i = 1\\n        l=len(nums)\\n        while i<l:\\n            if nums[i]>nums[i-1]:\\n                x+=nums[i]\\n            else:\\n                x=nums[i]\\n            sum=max(x,sum)\\n            i+=1\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189362,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        \\n        maxSum = nums[0]\\n        localSum = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            \\n            if nums[i] > nums[i-1]:\\n                localSum += nums[i]\\n            else:\\n                localSum = nums[i]\\n                \\n            if localSum > maxSum:\\n                maxSum = localSum\\n\\n        return maxSum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        \\n        maxSum = nums[0]\\n        localSum = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            \\n            if nums[i] > nums[i-1]:\\n                localSum += nums[i]\\n            else:\\n                localSum = nums[i]\\n                \\n            if localSum > maxSum:\\n                maxSum = localSum\\n\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188339,
                "title": "java-o-n-0ms-beats-100-submissions-easy-understanding-solution",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0],sum=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[i-1]) sum=0;\\n            sum+=nums[i];\\n            if(sum>max) max=sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0],sum=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[i-1]) sum=0;\\n            sum+=nums[i];\\n            if(sum>max) max=sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187892,
                "title": "python-simple-two-pointer-solution-faster-than-95-43",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        fp = nums[0]\\n        bp = nums[0]\\n        i = 0\\n        while i<=len(nums)-2:\\n            if nums[i+1]>nums[i]:\\n                fp+=nums[i+1]\\n            else:\\n                fp = nums[i+1]\\n            bp = max(bp,fp)\\n            i = i+1\\n        return bp\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        fp = nums[0]\\n        bp = nums[0]\\n        i = 0\\n        while i<=len(nums)-2:\\n            if nums[i+1]>nums[i]:\\n                fp+=nums[i+1]\\n            else:\\n                fp = nums[i+1]\\n            bp = max(bp,fp)\\n            i = i+1\\n        return bp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179539,
                "title": "c-solution-beats-100",
                "content": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int first = 0;\\n        int second = 1;\\n        int sum = nums[first];\\n        int max_val = -1;\\n        \\n        \\n        if(nums.size() == 1)\\n        {\\n            return nums[0];\\n        }\\n        \\n        \\n        while(second < nums.size())\\n        {\\n            if(nums[first] < nums[second])\\n            {\\n                sum = sum + nums[second];\\n                max_val = max(sum,max(max_val,nums[second]));\\n                second += 1;\\n                first += 1;\\n            }\\n            else\\n            {\\n                max_val = max(max_val,nums[first]);\\n                sum = nums[second];\\n                first = second;\\n                second = second + 1;\\n            }\\n        }\\n        \\n        return max_val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int first = 0;\\n        int second = 1;\\n        int sum = nums[first];\\n        int max_val = -1;\\n        \\n        \\n        if(nums.size() == 1)\\n        {\\n            return nums[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1176249,
                "title": "simple-o-n-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int ans=0;\\n        int sum=nums[0];\\n        for(int i=1;i<nums.size();i++) {\\n            if(nums[i]<=nums[i-1])  //strictly increasing \\n            {\\n                ans = max(ans,sum);\\n                sum=0;\\n            }\\n            sum+=nums[i];\\n            cout<<sum<<\" \";\\n        }\\n        return max(sum,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int ans=0;\\n        int sum=nums[0];\\n        for(int i=1;i<nums.size();i++) {\\n            if(nums[i]<=nums[i-1])  //strictly increasing \\n            {\\n                ans = max(ans,sum);\\n                sum=0;\\n            }\\n            sum+=nums[i];\\n            cout<<sum<<\" \";\\n        }\\n        return max(sum,ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1163460,
                "title": "c-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i=0,j=1;\\n        int ms=nums[0],cs=nums[0];\\n        int n=nums.size();\\n        while(j<n){\\n            while(j<n && nums[j]>nums[j-1]){\\n                cs+=nums[j];\\n                j++;\\n            }\\n            ms=max(ms,cs);\\n            if(j<n){\\n                cs=nums[j];\\n                j++;\\n            }\\n        }\\n        return ms;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i=0,j=1;\\n        int ms=nums[0],cs=nums[0];\\n        int n=nums.size();\\n        while(j<n){\\n            while(j<n && nums[j]>nums[j-1]){\\n                cs+=nums[j];\\n                j++;\\n            }\\n            ms=max(ms,cs);\\n            if(j<n){\\n                cs=nums[j];\\n                j++;\\n            }\\n        }\\n        return ms;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149384,
                "title": "solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int cur=nums[0],sum=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]<nums[i]){\\n                cur=cur+nums[i];\\n            }\\n            else{\\n                sum=Math.max(sum,cur);\\n                cur=nums[i];\\n            }\\n        }\\n        return Math.max(sum,cur);\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int cur=nums[0],sum=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]<nums[i]){\\n                cur=cur+nums[i];\\n            }\\n            else{\\n                sum=Math.max(sum,cur);\\n                cur=nums[i];\\n            }\\n        }\\n        return Math.max(sum,cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135851,
                "title": "java-0-ms",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        \\n        int cur = nums[0];\\n        int sum = nums[0];\\n        int n = nums.length;\\n        \\n        for(int i = 1; i<n; i++) {\\n            \\n            if( nums[i-1] < nums[i]  )\\n                cur += nums[i];\\n            else {\\n                cur = nums[i];\\n            }\\n            \\n            sum = Math.max(sum, cur);\\n                            \\n        }\\n        \\n        return sum;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        \\n        int cur = nums[0];\\n        int sum = nums[0];\\n        int n = nums.length;\\n        \\n        for(int i = 1; i<n; i++) {\\n            \\n            if( nums[i-1] < nums[i]  )\\n                cur += nums[i];\\n            else {\\n                cur = nums[i];\\n            }\\n            \\n            sum = Math.max(sum, cur);\\n                            \\n        }\\n        \\n        return sum;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135432,
                "title": "faster-than-100-c-submissions",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int maxAscendingSum(vector<int>& nums) \\n    {\\n        int ans=INT_MIN,j=0;\\n        while(j<nums.size())\\n        {\\n            int tmp=0;\\n            while(j<nums.size()-1 && nums[j]<nums[j+1])\\n            {\\n                tmp+=nums[j];\\n                j++;\\n            }\\n            tmp+=nums[j];\\n            ans=max(ans,tmp);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxAscendingSum(vector<int>& nums) \\n    {\\n        int ans=INT_MIN,j=0;\\n        while(j<nums.size())\\n        {\\n            int tmp=0;\\n            while(j<nums.size()-1 && nums[j]<nums[j+1])\\n            {\\n                tmp+=nums[j];\\n                j++;\\n            }\\n            tmp+=nums[j];\\n            ans=max(ans,tmp);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125224,
                "title": "java-using-kadane-s-algo-approach-in-0ms",
                "content": "```\\npublic int maxAscendingSum(int[] nums) {\\n        if(nums.length == 1)\\n            return nums[0];\\n    \\n        int len = nums.length;\\n        \\n        int cur_sum = nums[0];\\n        int max_sum = 0; \\n        \\n        for(int i=1; i<len; ++i)\\n        {\\n            if(nums[i] > nums[i-1])\\n            {\\n                cur_sum += nums[i];\\n            }\\n            else\\n            {\\n                max_sum = Math.max(max_sum, cur_sum);\\n                cur_sum = nums[i];\\n            }\\n        }\\n        max_sum = Math.max(max_sum, cur_sum);\\n        return max_sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxAscendingSum(int[] nums) {\\n        if(nums.length == 1)\\n            return nums[0];\\n    \\n        int len = nums.length;\\n        \\n        int cur_sum = nums[0];\\n        int max_sum = 0; \\n        \\n        for(int i=1; i<len; ++i)\\n        {\\n            if(nums[i] > nums[i-1])\\n            {\\n                cur_sum += nums[i];\\n            }\\n            else\\n            {\\n                max_sum = Math.max(max_sum, cur_sum);\\n                cur_sum = nums[i];\\n            }\\n        }\\n        max_sum = Math.max(max_sum, cur_sum);\\n        return max_sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123658,
                "title": "java-simple-o-n-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = 0;\\n        int max = 0,start = 0;\\n        while(start<nums.length){\\n            if(start == 0){\\n                sum += nums[start];\\n            }\\n            else{\\n                if(nums[start]>nums[start-1])\\n                    sum += nums[start];\\n                else{\\n                    if(sum>max)\\n                        max = sum;\\n                    sum = nums[start];\\n                }\\n            }\\n            start++;\\n        }\\n        if(sum>max)\\n            max = sum;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = 0;\\n        int max = 0,start = 0;\\n        while(start<nums.length){\\n            if(start == 0){\\n                sum += nums[start];\\n            }\\n            else{\\n                if(nums[start]>nums[start-1])\\n                    sum += nums[start];\\n                else{\\n                    if(sum>max)\\n                        max = sum;\\n                    sum = nums[start];\\n                }\\n            }\\n            start++;\\n        }\\n        if(sum>max)\\n            max = sum;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123334,
                "title": "simple-1-liner",
                "content": "```\\ndef max_ascending_sum(nums)\\n  nums.chunk_while(&:<).map(&:sum).max\\nend\\n```\\nSometimes Ruby is really nice.",
                "solutionTags": [],
                "code": "```\\ndef max_ascending_sum(nums)\\n  nums.chunk_while(&:<).map(&:sum).max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1122403,
                "title": "easy-and-simple-approach-o-n-runtime-100",
                "content": "***upvote if you like the solution***\\n<hr>\\n\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = 0, temp = nums[0], prev = nums[0];\\n        \\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] <= prev){\\n                if(temp > sum)\\n                    sum = temp;\\n                temp = 0;\\n            }\\n            \\n            temp += nums[i];\\n            prev = nums[i];\\n        }\\n        \\n        if(temp > sum)\\n            return temp;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = 0, temp = nums[0], prev = nums[0];\\n        \\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] <= prev){\\n                if(temp > sum)\\n                    sum = temp;\\n                temp = 0;\\n            }\\n            \\n            temp += nums[i];\\n            prev = nums[i];\\n        }\\n        \\n        if(temp > sum)\\n            return temp;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121374,
                "title": "python3-using-stack",
                "content": "Stack is proper data structure for this problem.\\nIf we store the number into the stack in ascending order, the top of the stack is always the largest value.\\nTherefore, when we meet a new value `n` from `nums`, there are two cases:\\n 1. `n` is less than top: it is in ascending order with all the other values in stack, so just push to the stack.\\n 2. `n` is greater than or equals to top: the ascending order is broken. Update maximum sum with the sum of stack, and clear the stack.\\n\\nAnd at the end of the loop, stack could not be empty, so handle remainings.\\n\\n```python\\ndef max_ascending_sum(nums):\\n  max_sum = 0\\n  stack = []\\n  \\n  for n in nums:\\n    if stack and stack[-1] >= n:\\n\\t  # update sum\\n\\t  max_sum = max(max_sum, sum(stack))\\n\\t  stack = []\\n\\tstack.append(n)\\n\\t\\n# handle remainings\\nreturn max(max_sum, sum(stack))\\n```",
                "solutionTags": [],
                "code": "```python\\ndef max_ascending_sum(nums):\\n  max_sum = 0\\n  stack = []\\n  \\n  for n in nums:\\n    if stack and stack[-1] >= n:\\n\\t  # update sum\\n\\t  max_sum = max(max_sum, sum(stack))\\n\\t  stack = []\\n\\tstack.append(n)\\n\\t\\n# handle remainings\\nreturn max(max_sum, sum(stack))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1121008,
                "title": "java-o-n-one-pass-0ms-runtime",
                "content": "Need to maintain the running sum of ascending items of subarray. ``prevMax`` holds previous maximum value of sum calculated. Return the bigger value out of ``prevMax`` and ``result``\\n\\n```\\npublic int maxAscendingSum(int[] nums) {\\n        int result = nums[0];\\n        int prevMax = nums[0];\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n        \\tif(nums[i] > nums[i - 1]) {\\n        \\t\\tresult += nums[i];\\n        \\t}\\n        \\telse {\\n        \\t\\tprevMax = Math.max(prevMax,result);\\n        \\t\\tresult =  nums[i];\\n        \\t}\\n        }\\n    \\treturn Math.max(prevMax, result);\\n    }\\n",
                "solutionTags": [],
                "code": "Need to maintain the running sum of ascending items of subarray. ``prevMax`` holds previous maximum value of sum calculated. Return the bigger value out of ``prevMax`` and ``result``\\n\\n```\\npublic int maxAscendingSum(int[] nums) {\\n        int result = nums[0];\\n        int prevMax = nums[0];\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n        \\tif(nums[i] > nums[i - 1]) {\\n        \\t\\tresult += nums[i];\\n        \\t}\\n        \\telse {\\n        \\t\\tprevMax = Math.max(prevMax,result);\\n        \\t\\tresult =  nums[i];\\n        \\t}\\n        }\\n    \\treturn Math.max(prevMax, result);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1119811,
                "title": "ok",
                "content": "```\\nint maxAscendingSum(vector<int>& n) \\n{\\n\\tint out{n[0]};\\n\\tfor(auto i{1}, s(n[0]); i<size(n); ++i)\\n\\t\\tout = max(out, s = n[i-1]<n[i] ? s+n[i] : n[i]);\\n\\treturn out;\\n}\\n```\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/f8f94eb0-e7d8-474b-81a7-5bb516b7da1b_1616357086.575112.png)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxAscendingSum(vector<int>& n) \\n{\\n\\tint out{n[0]};\\n\\tfor(auto i{1}, s(n[0]); i<size(n); ++i)\\n\\t\\tout = max(out, s = n[i-1]<n[i] ? s+n[i] : n[i]);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119726,
                "title": "simple-for-loop-in-python",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        s = ms = nums[0]\\n\\t\\t\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                s += nums[i]\\n                ms = max(ms, s)\\n            else:\\n                s = nums[i]\\n\\n        return ms\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        s = ms = nums[0]\\n\\t\\t\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                s += nums[i]\\n                ms = max(ms, s)\\n            else:\\n                s = nums[i]\\n\\n        return ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119688,
                "title": "java-c-python-javascript-o-n-solution",
                "content": "**Java**\\n\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int res = nums[0];\\n        int sum = nums[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i-1] < nums[i]) sum += nums[i];\\n            else sum = nums[i];\\n            res = Math.max(sum, res);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int res = nums[0];\\n        int sum = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i-1] < nums[i]) sum += nums[i];\\n            else sum = nums[i];\\n            res = max(sum, res);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int res = nums[0];\\n        int sum = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i-1] < nums[i]) sum += nums[i];\\n            else sum = nums[i];\\n            res = max(sum, res);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**JavaScript**\\n\\n```\\nvar maxAscendingSum = function(nums) {\\n    let res = nums[0];\\n    let sum = nums[0];\\n    for(let i = 1; i < nums.length; i++) {\\n            if(nums[i-1] < nums[i]) sum += nums[i];\\n            else sum = nums[i];\\n            res = Math.max(sum, res);\\n        }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int res = nums[0];\\n        int sum = nums[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i-1] < nums[i]) sum += nums[i];\\n            else sum = nums[i];\\n            res = Math.max(sum, res);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int res = nums[0];\\n        int sum = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i-1] < nums[i]) sum += nums[i];\\n            else sum = nums[i];\\n            res = max(sum, res);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int res = nums[0];\\n        int sum = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i-1] < nums[i]) sum += nums[i];\\n            else sum = nums[i];\\n            res = max(sum, res);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nvar maxAscendingSum = function(nums) {\\n    let res = nums[0];\\n    let sum = nums[0];\\n    for(let i = 1; i < nums.length; i++) {\\n            if(nums[i-1] < nums[i]) sum += nums[i];\\n            else sum = nums[i];\\n            res = Math.max(sum, res);\\n        }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119678,
                "title": "beats-100-o-n-c-easy-to-understand",
                "content": "```\\nint maxAscendingSum(vector<int>& arr) {\\n    int n=arr.size();\\n    int a=0;\\n    int currsum=arr[0],maxsum=arr[0];\\n    for(int i=1;i<n;++i){\\n        if(arr[i]>arr[i-1]){\\n        currsum+=arr[i];\\n        }else{\\n            currsum=arr[i];\\n        }\\n        maxsum=max(maxsum,currsum);\\n        currsum=max(0,currsum);\\n    }\\n    return maxsum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxAscendingSum(vector<int>& arr) {\\n    int n=arr.size();\\n    int a=0;\\n    int currsum=arr[0],maxsum=arr[0];\\n    for(int i=1;i<n;++i){\\n        if(arr[i]>arr[i-1]){\\n        currsum+=arr[i];\\n        }else{\\n            currsum=arr[i];\\n        }\\n        maxsum=max(maxsum,currsum);\\n        currsum=max(0,currsum);\\n    }\\n    return maxsum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119661,
                "title": "java-solution-one-pass-o-n-kadane-s-algorithm",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = nums[0];\\n        int max = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i] > nums[i-1]){\\n                max += nums[i];\\n            }else{\\n                maxSum = Math.max(maxSum, max);\\n                max = nums[i];\\n            }\\n        }\\n        return Math.max(maxSum, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = nums[0];\\n        int max = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i] > nums[i-1]){\\n                max += nums[i];\\n            }else{\\n                maxSum = Math.max(maxSum, max);\\n                max = nums[i];\\n            }\\n        }\\n        return Math.max(maxSum, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4107624,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        b=[nums[0]]\\n        for i in range(0,len(nums)-1) :\\n            if nums[i+1]>nums[i] :\\n                # a+=nums[i+1]\\n                b.append(nums[i+1]+b[i])\\n            if nums[i+1]<=nums[i] :\\n                a=0\\n                b.append(nums[i+1])\\n        return max(b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        b=[nums[0]]\\n        for i in range(0,len(nums)-1) :\\n            if nums[i+1]>nums[i] :\\n                # a+=nums[i+1]\\n                b.append(nums[i+1]+b[i])\\n            if nums[i+1]<=nums[i] :\\n                a=0\\n                b.append(nums[i+1])\\n        return max(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104938,
                "title": "python-clean-sliding-window-prefix-sum-solution",
                "content": "```\\nfrom itertools import pairwise\\nfrom math import inf\\n\\n\\nclass Solution:\\n    def maxAscendingSum(self, A: list[int]) -> int:\\n        # return self.method1(A)\\n        return self.method2(A)\\n\\n    @staticmethod\\n    def method2(A: list[int]) -> int:\\n        A = A + [-inf]\\n\\n        w_sum, output = 0, 0\\n\\n        for cur, nxt in pairwise(A):\\n            w_sum += cur\\n\\n            if cur >= nxt:\\n                output = max(output, w_sum)\\n                w_sum = 0\\n\\n        return output\\n\\n    @staticmethod\\n    def method1(A: list[int]) -> int:\\n        A = A + [-inf]\\n\\n        w_sum, output = A[0], A[0]\\n\\n        for prev, cur in pairwise(A):\\n            if prev >= cur:\\n                output = max(output, w_sum)\\n                w_sum = 0\\n\\n            w_sum += cur\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom itertools import pairwise\\nfrom math import inf\\n\\n\\nclass Solution:\\n    def maxAscendingSum(self, A: list[int]) -> int:\\n        # return self.method1(A)\\n        return self.method2(A)\\n\\n    @staticmethod\\n    def method2(A: list[int]) -> int:\\n        A = A + [-inf]\\n\\n        w_sum, output = 0, 0\\n\\n        for cur, nxt in pairwise(A):\\n            w_sum += cur\\n\\n            if cur >= nxt:\\n                output = max(output, w_sum)\\n                w_sum = 0\\n\\n        return output\\n\\n    @staticmethod\\n    def method1(A: list[int]) -> int:\\n        A = A + [-inf]\\n\\n        w_sum, output = A[0], A[0]\\n\\n        for prev, cur in pairwise(A):\\n            if prev >= cur:\\n                output = max(output, w_sum)\\n                w_sum = 0\\n\\n            w_sum += cur\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079379,
                "title": "c-easy-solution-beats-98-space-and-88-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxAscendingSum(int[] nums) {\\n        int max=0,curr=nums[0];\\n        for(int i=1;i<nums.Length;i++){\\n            if(nums[i-1]<nums[i]){\\n                curr+=nums[i];\\n            }\\n            else{\\n                max=max<curr?curr:max;\\n                curr=nums[i];\\n            }\\n        }\\n        return Math.Max(max,curr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxAscendingSum(int[] nums) {\\n        int max=0,curr=nums[0];\\n        for(int i=1;i<nums.Length;i++){\\n            if(nums[i-1]<nums[i]){\\n                curr+=nums[i];\\n            }\\n            else{\\n                max=max<curr?curr:max;\\n                curr=nums[i];\\n            }\\n        }\\n        return Math.Max(max,curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075150,
                "title": "optimize-solution-with-linear-time-complexity-with-beginner-friendly-100-beats-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int res = Integer.MIN_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            int count = nums[i];\\n            for(int j=i; j<nums.length-1; j++){\\n                if(nums[j]<nums[j+1]){\\n                    count += nums[j+1];\\n                } else{ \\n                    break;\\n                }\\n            }\\n            res = Math.max(res, count);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int res = Integer.MIN_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            int count = nums[i];\\n            for(int j=i; j<nums.length-1; j++){\\n                if(nums[j]<nums[j+1]){\\n                    count += nums[j+1];\\n                } else{ \\n                    break;\\n                }\\n            }\\n            res = Math.max(res, count);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054566,
                "title": "using-kaden-s-algorithm-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=nums[0],maxsum=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[i-1])\\n                sum=0;\\n            sum+=nums[i];\\n            if(sum>maxsum)\\n                maxsum=sum;\\n            \\n        }\\n        return maxsum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=nums[0],maxsum=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[i-1])\\n                sum=0;\\n            sum+=nums[i];\\n            if(sum>maxsum)\\n                maxsum=sum;\\n            \\n        }\\n        return maxsum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041252,
                "title": "simple-solution",
                "content": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        prev, sum_num, max_sum = nums[0], 0, 0\\n        for num in nums:\\n            if num > prev:\\n                sum_num += num\\n            else:\\n                max_sum = max(sum_num, max_sum)\\n                sum_num = num\\n            prev = num\\n        return max(sum_num, max_sum)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        prev, sum_num, max_sum = nums[0], 0, 0\\n        for num in nums:\\n            if num > prev:\\n                sum_num += num\\n            else:\\n                max_sum = max(sum_num, max_sum)\\n                sum_num = num\\n            prev = num\\n        return max(sum_num, max_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014288,
                "title": "100-beat-best-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach-: Inspired by kadane algorithm\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int min=Integer.MIN_VALUE;\\n        int count=nums[0];\\n        int i=0;\\n        for(i=0;i<nums.length-1;i++){\\n            if(nums[i + 1] > nums[i]){\\n                count += nums[i+1];\\n            }\\n            else{\\n                min=Math.max(min,count);\\n                count=nums[i+1];\\n            }\\n        }\\n        min=Math.max(min,count);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int min=Integer.MIN_VALUE;\\n        int count=nums[0];\\n        int i=0;\\n        for(i=0;i<nums.length-1;i++){\\n            if(nums[i + 1] > nums[i]){\\n                count += nums[i+1];\\n            }\\n            else{\\n                min=Math.max(min,count);\\n                count=nums[i+1];\\n            }\\n        }\\n        min=Math.max(min,count);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013908,
                "title": "1800-maximum-ascending-subarray-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int res = 0;  \\n        int currentSum = nums[0];  \\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                currentSum += nums[i];  \\n            } else {\\n                res = Math.max(res, currentSum);  \\n                currentSum = nums[i];  \\n            }\\n        }\\n        res = Math.max(res, currentSum);\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int res = 0;  \\n        int currentSum = nums[0];  \\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                currentSum += nums[i];  \\n            } else {\\n                res = Math.max(res, currentSum);  \\n                currentSum = nums[i];  \\n            }\\n        }\\n        res = Math.max(res, currentSum);\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009613,
                "title": "easy-java-solution-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int s=0,s1=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i+1]>nums[i])\\n                s+=nums[i];\\n            else{\\n                s+=nums[i];\\n                if(s>s1)\\n                    s1=s;\\n                if(i<nums.length-2)\\n                    s=0;\\n            }\\n        }\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums[nums.length-1]>nums[nums.length-2])\\n            s+=nums[nums.length-1];\\n        return Math.max(s,s1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int s=0,s1=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i+1]>nums[i])\\n                s+=nums[i];\\n            else{\\n                s+=nums[i];\\n                if(s>s1)\\n                    s1=s;\\n                if(i<nums.length-2)\\n                    s=0;\\n            }\\n        }\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums[nums.length-1]>nums[nums.length-2])\\n            s+=nums[nums.length-1];\\n        return Math.max(s,s1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006675,
                "title": "java-short-code-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0];\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(max<nums[i]){\\n                sum+=nums[i];\\n            }\\n            else{\\n                res=Math.max(res,sum);\\n                sum=nums[i];\\n            }\\n            max=nums[i];\\n        }\\n        return Math.max(res,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0];\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(max<nums[i]){\\n                sum+=nums[i];\\n            }\\n            else{\\n                res=Math.max(res,sum);\\n                sum=nums[i];\\n            }\\n            max=nums[i];\\n        }\\n        return Math.max(res,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995914,
                "title": "c-simple-easy-explanation-o-n",
                "content": "# EXPLANATION\\nIt\\'s just simple.\\nJust add the sum of stictly increasing number and compare it with all, then finally return the answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int x=nums[0],s=x;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1])\\n                s+=nums[i];\\n            else\\n                s=nums[i];\\n            x=max(x,s);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int x=nums[0],s=x;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1])\\n                s+=nums[i];\\n            else\\n                s=nums[i];\\n            x=max(x,s);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979996,
                "title": "simple-c-solution-100-faster",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n       int maxsum=nums[0];\\n       int sum=nums[0];\\n       for(int i=1;i<nums.size();i++)\\n       {\\n           if(nums[i]>nums[i-1])\\n           sum+=nums[i];\\n           else\\n           {\\n               maxsum=max(maxsum,sum);\\n               sum=nums[i];\\n           }\\n       }\\n       maxsum=max(maxsum,sum);\\n       return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n       int maxsum=nums[0];\\n       int sum=nums[0];\\n       for(int i=1;i<nums.size();i++)\\n       {\\n           if(nums[i]>nums[i-1])\\n           sum+=nums[i];\\n           else\\n           {\\n               maxsum=max(maxsum,sum);\\n               sum=nums[i];\\n           }\\n       }\\n       maxsum=max(maxsum,sum);\\n       return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975710,
                "title": "1800-maximum-ascending-subarray-sum",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = 0;\\n        int current = 0;\\n        int n = nums.length;\\n\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                current += nums[0];\\n\\n            }\\n            else{\\n                if(nums[i] > nums[i-1]){\\n                    current += nums[i];\\n                }\\n                else{\\n                    current = nums[i];\\n                }\\n            }\\n            sum = Math.max(sum, current);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = 0;\\n        int current = 0;\\n        int n = nums.length;\\n\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                current += nums[0];\\n\\n            }\\n            else{\\n                if(nums[i] > nums[i-1]){\\n                    current += nums[i];\\n                }\\n                else{\\n                    current = nums[i];\\n                }\\n            }\\n            sum = Math.max(sum, current);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969106,
                "title": "c-kadane-s-algo-o-n",
                "content": "# Intuition\\nkeep in mind that subarray which will give max sum, is strictly ascending and applied Kadane\\'s Algo\\n\\n# Approach\\nKadane\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        // sort(nums.begin(), nums.end());\\n        int currentSum=nums[0];\\n        int maxSum=nums[0];\\n\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]<nums[i]){\\n                currentSum+=nums[i];\\n                if(currentSum<0){\\n                    currentSum=0;\\n                }\\n            } else{\\n                currentSum=nums[i];\\n            }\\n            maxSum=max(maxSum, currentSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        // sort(nums.begin(), nums.end());\\n        int currentSum=nums[0];\\n        int maxSum=nums[0];\\n\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]<nums[i]){\\n                currentSum+=nums[i];\\n                if(currentSum<0){\\n                    currentSum=0;\\n                }\\n            } else{\\n                currentSum=nums[i];\\n            }\\n            maxSum=max(maxSum, currentSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967792,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/8801697d-695c-477d-8eb1-d4eb79272a57_1693146774.2595491.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int ans = 0, size = nums.size();\\n        int tmp=0;\\n        for(int i=0; i<size; i++){\\n            if(tmp != 0 && nums[i] <= nums[i-1]){\\n                ans = max(ans, tmp);\\n                tmp = 0;\\n            }\\n            tmp += nums[i];\\n        }\\n        ans = max(ans, tmp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int ans = 0, size = nums.size();\\n        int tmp=0;\\n        for(int i=0; i<size; i++){\\n            if(tmp != 0 && nums[i] <= nums[i-1]){\\n                ans = max(ans, tmp);\\n                tmp = 0;\\n            }\\n            tmp += nums[i];\\n        }\\n        ans = max(ans, tmp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963216,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        maxsum = 0\\n        l = 0\\n        while l < len(nums):\\n            r = l + 1\\n            currsum = nums[l]\\n            while r < len(nums):\\n                if nums[r] <= nums[r-1]:\\n                    break\\n                elif nums[r] > nums[r-1]:\\n                    currsum += nums[r]\\n                r += 1\\n            \\n            maxsum = max(maxsum, currsum)\\n            l += 1\\n\\n        return maxsum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        maxsum = 0\\n        l = 0\\n        while l < len(nums):\\n            r = l + 1\\n            currsum = nums[l]\\n            while r < len(nums):\\n                if nums[r] <= nums[r-1]:\\n                    break\\n                elif nums[r] > nums[r-1]:\\n                    currsum += nums[r]\\n                r += 1\\n            \\n            maxsum = max(maxsum, currsum)\\n            l += 1\\n\\n        return maxsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960082,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        int sum=0;\\n        int prev=-1;\\n        int curr=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            curr=nums[i];\\n            if(curr>prev){\\n            sum+=nums[i];\\n            prev=curr;\\n            maxi=max(sum,maxi);\\n            }\\n            \\n            else {\\n             sum=0;\\n              sum+=nums[i];\\n              prev=curr;\\n              maxi=max(sum,maxi);\\n            }\\n            \\n\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        int sum=0;\\n        int prev=-1;\\n        int curr=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            curr=nums[i];\\n            if(curr>prev){\\n            sum+=nums[i];\\n            prev=curr;\\n            maxi=max(sum,maxi);\\n            }\\n            \\n            else {\\n             sum=0;\\n              sum+=nums[i];\\n              prev=curr;\\n              maxi=max(sum,maxi);\\n            }\\n            \\n\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953485,
                "title": "beats-100-java-users-very-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0];\\n        int sum=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                sum+=nums[i];\\n                if(sum>=max)\\n                max=sum;\\n            }\\n            else\\n            sum=nums[i];\\n        }   \\n        return max;   \\n    }\\n\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0];\\n        int sum=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                sum+=nums[i];\\n                if(sum>=max)\\n                max=sum;\\n            }\\n            else\\n            sum=nums[i];\\n        }   \\n        return max;   \\n    }\\n\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945489,
                "title": "easy-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix Sum\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int n=size(nums);\\n        vector<int>pre(n+1,0);\\n        pre[0]=nums[0];\\n   \\n        for(int i=1;i<n;i++){\\n            if(nums[i-1]<nums[i])pre[i]=pre[i-1]+nums[i];\\n            else{\\n                pre[i]=nums[i];\\n            }\\n        }\\n    \\n        sort(pre.begin(),pre.end());\\n        return pre[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int n=size(nums);\\n        vector<int>pre(n+1,0);\\n        pre[0]=nums[0];\\n   \\n        for(int i=1;i<n;i++){\\n            if(nums[i-1]<nums[i])pre[i]=pre[i-1]+nums[i];\\n            else{\\n                pre[i]=nums[i];\\n            }\\n        }\\n    \\n        sort(pre.begin(),pre.end());\\n        return pre[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932284,
                "title": "self-explanatory-code-o-n-time-complexity-easy-code",
                "content": "**Please Upvote if you like the approach !!**\\n![meme.gif](https://assets.leetcode.com/users/images/cd6a18df-43a8-4d61-b55e-2483c3fba8e6_1692462440.1113057.gif)\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=nums[0];\\n        int temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i-1]>=nums[i]){\\n                ans=max(ans,temp);\\n                temp=nums[i];\\n            }\\n            else{\\n                temp=temp+nums[i];\\n            }\\n        }\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=nums[0];\\n        int temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i-1]>=nums[i]){\\n                ans=max(ans,temp);\\n                temp=nums[i];\\n            }\\n            else{\\n                temp=temp+nums[i];\\n            }\\n        }\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914679,
                "title": "max-subarray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxAscendingSum(int[] nums) {\\n        int i =0;\\n        int res =0;\\n        int sum = nums[0];\\n        for(i=1;i<nums.Length;i++){\\n            if(nums[i-1]<nums[i]){\\n                sum += nums[i]; \\n            }\\n            else{\\n                    res = Math.Max(res,sum);\\n                    sum = nums[i];\\n            }\\n        }\\n    res = Math.Max(res,sum);\\n     return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxAscendingSum(int[] nums) {\\n        int i =0;\\n        int res =0;\\n        int sum = nums[0];\\n        for(i=1;i<nums.Length;i++){\\n            if(nums[i-1]<nums[i]){\\n                sum += nums[i]; \\n            }\\n            else{\\n                    res = Math.Max(res,sum);\\n                    sum = nums[i];\\n            }\\n        }\\n    res = Math.Max(res,sum);\\n     return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890688,
                "title": "easy-code",
                "content": "\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        \\n        int maxi =  nums[0];\\n        int curr = nums[0];\\n\\n\\n        for(int i=1; i<nums.size();i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n            {\\n                curr = curr + nums[i];\\n            }\\n\\n            else\\n            {\\n                maxi = max(curr, maxi); \\n                curr= nums[i];\\n            }\\n        }\\n        return maxi = max(curr, maxi);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        \\n        int maxi =  nums[0];\\n        int curr = nums[0];\\n\\n\\n        for(int i=1; i<nums.size();i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n            {\\n                curr = curr + nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3887727,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxAscendingSum = function(nums) {\\n    let max = 0\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i+1] > nums[i]) {\\n          sum += nums[i]\\n        } \\n        else {\\n          sum+=nums[i]\\n          sum > max ? max = sum : max\\n          sum = 0\\n        }\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxAscendingSum = function(nums) {\\n    let max = 0\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i+1] > nums[i]) {\\n          sum += nums[i]\\n        } \\n        else {\\n          sum+=nums[i]\\n          sum > max ? max = sum : max\\n          sum = 0\\n        }\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885476,
                "title": "easy-and-straightforward-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int n =  nums.size();\\n        int sum = nums[0], maxSum = 0;\\n\\n        for(int i=1; i<n; i++)\\n        {\\n            if(nums[i] <= nums[i-1])\\n            {   \\n                maxSum = max(sum, maxSum);\\n                sum=nums[i];\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n            }\\n        }\\n        return max(maxSum, sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int n =  nums.size();\\n        int sum = nums[0], maxSum = 0;\\n\\n        for(int i=1; i<n; i++)\\n        {\\n            if(nums[i] <= nums[i-1])\\n            {   \\n                maxSum = max(sum, maxSum);\\n                sum=nums[i];\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n            }\\n        }\\n        return max(maxSum, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880655,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = nums[0];\\n        int sum = nums[0];\\n\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i-1] >= nums[i]) \\n                sum = nums[i];\\n            else \\n                sum += nums[i];\\n            \\n            max = Math.max(sum, max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = nums[0];\\n        int sum = nums[0];\\n\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i-1] >= nums[i]) \\n                sum = nums[i];\\n            else \\n                sum += nums[i];\\n            \\n            max = Math.max(sum, max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876721,
                "title": "beats-100-c-59ms-runtime-simple-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the famous Kadane\\'s Algorithm.\\n+ List of all sums and take the biggest one\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxAscendingSum(int[] nums) {\\n            var currSum = nums[0];\\n            var maxSum = nums[0];\\n            var allSums = new List<int>();\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                if (nums[i] <= nums[i - 1])\\n                {\\n                    allSums.Add(maxSum);\\n                    maxSum = 0;\\n                    currSum = 0;\\n                }\\n\\n                currSum = Math.Max(nums[i], nums[i] + currSum);\\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n            \\n            allSums.Add(maxSum);\\n            allSums.Sort();\\n            var test = allSums.Last();\\n\\n            return test;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxAscendingSum(int[] nums) {\\n            var currSum = nums[0];\\n            var maxSum = nums[0];\\n            var allSums = new List<int>();\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                if (nums[i] <= nums[i - 1])\\n                {\\n                    allSums.Add(maxSum);\\n                    maxSum = 0;\\n                    currSum = 0;\\n                }\\n\\n                currSum = Math.Max(nums[i], nums[i] + currSum);\\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n            \\n            allSums.Add(maxSum);\\n            allSums.Sort();\\n            var test = allSums.Last();\\n\\n            return test;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864967,
                "title": "maximum-ascending-subarray-sum-python3-100-tc-o-n",
                "content": "# Complexity\\n- Time complexity: ```O(N)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        l,sum,maxi = 1,0,0\\n        nums.append(0)\\n        while l<len(nums) :\\n            if nums[l-1]<nums[l] :\\n                sum+=nums[l-1]\\n            else :\\n                sum+=nums[l-1]\\n                maxi = max(maxi,sum)\\n                sum = 0\\n            l+=1\\n        return maxi\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```O(N)```\n```O(1)```\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        l,sum,maxi = 1,0,0\\n        nums.append(0)\\n        while l<len(nums) :\\n            if nums[l-1]<nums[l] :\\n                sum+=nums[l-1]\\n            else :\\n                sum+=nums[l-1]\\n                maxi = max(maxi,sum)\\n                sum = 0\\n            l+=1\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859334,
                "title": "easy-kadane-s-algorithm",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        m=float(\\'-inf\\')\\n        prev=-1\\n        curr=0\\n        for i in nums:\\n            if i>prev:\\n                curr+=i\\n                m=max(m,curr)\\n            else:\\n                curr=i\\n            prev=i\\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        m=float(\\'-inf\\')\\n        prev=-1\\n        curr=0\\n        for i in nums:\\n            if i>prev:\\n                curr+=i\\n                m=max(m,curr)\\n            else:\\n                curr=i\\n            prev=i\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848868,
                "title": "java-clean-code-with-explanation-0-ms-beats-100",
                "content": "\"Madara Uchiha commands you to **Upvote**!!\"\\n\\n# Approach\\nThe logic involves iterating through the array while keeping track of the current ascending sum. Whenever the sequence stops being ascending (when the current number is not greater than the previous number), it compares the current ascending sum with the maximum sum found so far and updates max accordingly. Then, it starts a new ascending sequence with the current number as the initial sum. After the loop, it compares the last ascending sequence sum with max and returns the maximum value between the two sums.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        // Initialize variables to keep track of the maximum ascending sum and the current ascending sum.\\n        int max = nums[0];\\n        int sum = nums[0];\\n        \\n        // Iterate through the \\'nums\\' array starting from the second element.\\n        for (int i = 1; i < nums.length; i++) {\\n            // If the current number is greater than the previous number, it is part of the ascending sequence.\\n            if (nums[i] > nums[i - 1]) {\\n                // Add the current number to the current ascending sum.\\n                sum += nums[i];\\n            } else {\\n                // If the current number is not greater than the previous one, the ascending sequence ends.\\n                // Compare the current ascending sum with the maximum ascending sum so far and update \\'max\\' if necessary.\\n                max = Math.max(max, sum);\\n                \\n                // Start a new ascending sequence with the current number as the initial sum.\\n                sum = nums[i];\\n            }\\n        }\\n       \\n        // After the loop, compare the last ascending sequence sum with \\'max\\' and return the maximum value.\\n        return Math.max(max, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        // Initialize variables to keep track of the maximum ascending sum and the current ascending sum.\\n        int max = nums[0];\\n        int sum = nums[0];\\n        \\n        // Iterate through the \\'nums\\' array starting from the second element.\\n        for (int i = 1; i < nums.length; i++) {\\n            // If the current number is greater than the previous number, it is part of the ascending sequence.\\n            if (nums[i] > nums[i - 1]) {\\n                // Add the current number to the current ascending sum.\\n                sum += nums[i];\\n            } else {\\n                // If the current number is not greater than the previous one, the ascending sequence ends.\\n                // Compare the current ascending sum with the maximum ascending sum so far and update \\'max\\' if necessary.\\n                max = Math.max(max, sum);\\n                \\n                // Start a new ascending sequence with the current number as the initial sum.\\n                sum = nums[i];\\n            }\\n        }\\n       \\n        // After the loop, compare the last ascending sequence sum with \\'max\\' and return the maximum value.\\n        return Math.max(max, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848170,
                "title": "dp-solution-very-easy-to-understand-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int maxsum=nums[0];\\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n                dp[i]=dp[i-1]+nums[i];\\n            }\\n            else{\\n                dp[i]=nums[i];\\n            }\\n            maxsum=Math.max(dp[i],maxsum);\\n        }\\n        return maxsum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int maxsum=nums[0];\\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n                dp[i]=dp[i-1]+nums[i];\\n            }\\n            else{\\n                dp[i]=nums[i];\\n            }\\n            maxsum=Math.max(dp[i],maxsum);\\n        }\\n        return maxsum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841096,
                "title": "beats-100-00-of-users-with-java-dart-direct-approach",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int count =nums[0],max = 0;\\n        for(int i =1;i<nums.length;i++){\\n            if(nums[i-1]<nums[i])\\n                count+=nums[i];\\n            else{\\n                if(max<count)\\n                    max = count;\\n                count = nums[i];\\n            } \\n        }\\n        if(max<count)\\n            max = count;\\n        return max;\\n    }\\n}\\n```\\n\\n# Dart Code\\n```\\nclass Solution {\\n  int maxAscendingSum(List<int> nums) {\\n    int count =nums[0],max = 0;\\n        for(int i =1;i<nums.length;i++){\\n            if(nums[i-1]<nums[i])\\n                count+=nums[i];\\n            else{\\n                if(max<count)\\n                    max = count;\\n                count = nums[i];\\n            } \\n        }\\n        if(max<count)\\n            max = count;\\n        return max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dart",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int count =nums[0],max = 0;\\n        for(int i =1;i<nums.length;i++){\\n            if(nums[i-1]<nums[i])\\n                count+=nums[i];\\n            else{\\n                if(max<count)\\n                    max = count;\\n                count = nums[i];\\n            } \\n        }\\n        if(max<count)\\n            max = count;\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n  int maxAscendingSum(List<int> nums) {\\n    int count =nums[0],max = 0;\\n        for(int i =1;i<nums.length;i++){\\n            if(nums[i-1]<nums[i])\\n                count+=nums[i];\\n            else{\\n                if(max<count)\\n                    max = count;\\n                count = nums[i];\\n            } \\n        }\\n        if(max<count)\\n            max = count;\\n        return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839935,
                "title": "a-simple-start-pointer-and-end-pointer-approach-beats-100-of-users-runtime",
                "content": "# Intuition\\nIf you see , problem statement we have to find subarray which is in ascending order and have maximum sum.\\nWhat are known points:\\n    1. An array of Integers which will contain subarray in ascending order having maximum sum.\\n    2. Their will subarray which have maximum sum , it could be single element, or actual subarray.(**What is a subarray ?** Answer: A subarray is a contiguous part of array, i.e., Subarray is an array that is inside another array.)\\n    3. The subarray should be in ascending order, in which single element subarray can also be consider as ascending order, and also if you find subarray size > 0 having maximum sum Let say Example {a, b ,c} then a<b<c strictly.\\n    \\nGathering all known things , we can think about start pointer and end pointer approach, where\\n\\nstart = 0\\nend = 1\\ntempSum = nums[start]\\nans = 0\\nTraverse through nums array with condition start <= end && end < n\\n    \\n>1. if current element is greater than previous element (following ascending order rule) , add the values to temporary sum and maximize the answer , Increase end pointer by one\\n\\n>2. else we will make start point as end and end pointer to next of start i.e (start + 1), maximize the answer, reset temporary sum value to nums[start].\\n\\nDon\\'t Forget the Edge Case which is not covered in iteration:\\nif length of array is equal to 1 then return nums[0]\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n    \\n        int start = 0;\\n        int end = 1;\\n        int n = nums.length;\\n        if(n == 1) {\\n            return nums[0];\\n        }\\n        int ans = 0;\\n        int s = nums[0];\\n        while(start <= end && end < n) {\\n            if(nums[end] > nums[end - 1]) {\\n                s += nums[end];\\n                ans = Math.max(ans, s);\\n                end ++;\\n            } else {\\n                start = end;\\n                end = start + 1;\\n                ans = Math.max(ans, s);\\n                s = nums[start];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```\\nThank You",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n    \\n        int start = 0;\\n        int end = 1;\\n        int n = nums.length;\\n        if(n == 1) {\\n            return nums[0];\\n        }\\n        int ans = 0;\\n        int s = nums[0];\\n        while(start <= end && end < n) {\\n            if(nums[end] > nums[end - 1]) {\\n                s += nums[end];\\n                ans = Math.max(ans, s);\\n                end ++;\\n            } else {\\n                start = end;\\n                end = start + 1;\\n                ans = Math.max(ans, s);\\n                s = nums[start];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838870,
                "title": "easy-java-solution-100-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0];\\n        int sum=nums[0];\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            \\n            if(nums[i]>nums[i-1])\\n            {\\n                sum+=nums[i];\\n                \\n            }\\n            else\\n            {\\n                max=Integer.max(max,sum);\\n                sum=nums[i];\\n            }\\n            \\n        }\\n        max=Integer.max(max,sum);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max=nums[0];\\n        int sum=nums[0];\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            \\n            if(nums[i]>nums[i-1])\\n            {\\n                sum+=nums[i];\\n                \\n            }\\n            else\\n            {\\n                max=Integer.max(max,sum);\\n                sum=nums[i];\\n            }\\n            \\n        }\\n        max=Integer.max(max,sum);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836370,
                "title": "c-100-faster-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int i=1;\\n        int sum=nums[0];\\n        while(i<nums.size()){\\n           if(nums[i]>nums[i-1]){\\n               sum+=nums[i];\\n           }\\n           else{\\n               maxi=max(sum,maxi);\\n               sum=nums[i];\\n           }\\n            maxi=max(sum,maxi);\\n           i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int i=1;\\n        int sum=nums[0];\\n        while(i<nums.size()){\\n           if(nums[i]>nums[i-1]){\\n               sum+=nums[i];\\n           }\\n           else{\\n               maxi=max(sum,maxi);\\n               sum=nums[i];\\n           }\\n            maxi=max(sum,maxi);\\n           i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819441,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        l=0\\n        res=-999999999\\n        ans=nums[l]\\n        if len(nums)==1:\\n            return nums[0]\\n        for r in range(1,len(nums)):\\n            if nums[r]>nums[r-1]:\\n                ans+=nums[r]\\n                res=max(res,ans)\\n            else:\\n                res=max(res,ans)\\n                l=r\\n                ans=nums[r]\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        l=0\\n        res=-999999999\\n        ans=nums[l]\\n        if len(nums)==1:\\n            return nums[0]\\n        for r in range(1,len(nums)):\\n            if nums[r]>nums[r-1]:\\n                ans+=nums[r]\\n                res=max(res,ans)\\n            else:\\n                res=max(res,ans)\\n                l=r\\n                ans=nums[r]\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811462,
                "title": "java-simple-solution-beats-100-runtime-0ms",
                "content": "# Intuition\\nBrute Force\\n\\n# Approach\\nStep 1: Create two variables to store current sum(currSum) and maximum sum(maxSum).\\nStep 2: Iterate through the array and add the current sum and store the maximum value between current and max in the maxSum.\\nStep 3: Reset the currSum to 0 if the ascending order breaks.\\nStep 4: Return the maxSum value in the end. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int currSum = 0;\\n\\n        for(int i=0; i<nums.length-1; i++){\\n            currSum += nums[i];\\n            maxSum = Math.max(currSum, maxSum);\\n\\n            if(nums[i] >= nums[i+1]){\\n                currSum = 0;\\n            }\\n        }\\n        maxSum = Math.max(currSum+nums[nums.length-1], maxSum);\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int currSum = 0;\\n\\n        for(int i=0; i<nums.length-1; i++){\\n            currSum += nums[i];\\n            maxSum = Math.max(currSum, maxSum);\\n\\n            if(nums[i] >= nums[i+1]){\\n                currSum = 0;\\n            }\\n        }\\n        maxSum = Math.max(currSum+nums[nums.length-1], maxSum);\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807569,
                "title": "java-100-time-97-memory-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = nums[0];\\n        int max = sum;\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                sum += nums[i];\\n            }else{\\n                if(sum > max){\\n                    max = sum;\\n                }\\n                sum = nums[i];\\n            }\\n        }\\n        if(sum > max){\\n            max = sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = nums[0];\\n        int max = sum;\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                sum += nums[i];\\n            }else{\\n                if(sum > max){\\n                    max = sum;\\n                }\\n                sum = nums[i];\\n            }\\n        }\\n        if(sum > max){\\n            max = sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786266,
                "title": "best-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=nums[0],maxSum=sum;\\n        for( int i=1 ; i<nums.length ; i++ )\\n        {\\n            if( nums[i]>nums[i-1] )\\n            {\\n                sum+=nums[i];\\n            }\\n            else\\n            {\\n                maxSum=Math.max(maxSum,sum);\\n                sum=nums[i];\\n            }\\n        }\\n        if (maxSum < sum) \\n            maxSum = sum;\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=nums[0],maxSum=sum;\\n        for( int i=1 ; i<nums.length ; i++ )\\n        {\\n            if( nums[i]>nums[i-1] )\\n            {\\n                sum+=nums[i];\\n            }\\n            else\\n            {\\n                maxSum=Math.max(maxSum,sum);\\n                sum=nums[i];\\n            }\\n        }\\n        if (maxSum < sum) \\n            maxSum = sum;\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786110,
                "title": "twisted-version-of-kadane-s-algo-explained",
                "content": "# Intuition\\n        #the main intuition is that we will maintain a \"temp\" counter and\\n        #if the prev ele is smaller than the curr ele, we will add that\\n        #ele to the \"temp\" counter\\n        #if curr ele is not greater than prev element then we will assign the\\n        #temp value to its curr element\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        ans=nums[0]\\n        \\n\\n        temp=nums[0]\\n\\n        for i in range(1,len(nums)):\\n            if nums[i]>nums[i-1]:\\n                temp+=nums[i]\\n            else:\\n                temp=nums[i]\\n            ans=max(temp,ans)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        ans=nums[0]\\n        \\n\\n        temp=nums[0]\\n\\n        for i in range(1,len(nums)):\\n            if nums[i]>nums[i-1]:\\n                temp+=nums[i]\\n            else:\\n                temp=nums[i]\\n            ans=max(temp,ans)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779097,
                "title": "easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n      int i = 1;\\n       int sum =nums[0];\\n       int max = nums[0];\\n      while(i<nums.length){\\n          if(nums[i]>nums[i-1]){\\n              sum += nums[i];\\n              max = Math.max(max,sum);\\n          }\\n          else\\n          {\\n              sum = nums[i];\\n               max = Math.max(max,sum);\\n          }\\n          i++;\\n      }  \\n      return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n      int i = 1;\\n       int sum =nums[0];\\n       int max = nums[0];\\n      while(i<nums.length){\\n          if(nums[i]>nums[i-1]){\\n              sum += nums[i];\\n              max = Math.max(max,sum);\\n          }\\n          else\\n          {\\n              sum = nums[i];\\n               max = Math.max(max,sum);\\n          }\\n          i++;\\n      }  \\n      return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773934,
                "title": "o-n-solution-in-cpp",
                "content": "# Complexity\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int ans = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            if(i > 0 && nums[i - 1] >= nums[i]){\\n                sum -= nums[i];\\n                ans = max(ans, sum);\\n                sum = nums[i];\\n            }\\n\\n            ans = max(ans, sum);\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int ans = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            if(i > 0 && nums[i - 1] >= nums[i]){\\n                sum -= nums[i];\\n                ans = max(ans, sum);\\n                sum = nums[i];\\n            }\\n\\n            ans = max(ans, sum);\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763046,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>&n){\\n        int mx=n[0];\\n        int sum=n[0];\\n        for(int i=1; i<n.size(); i++){\\n            if(n[i-1]<n[i]){\\n                sum+=n[i];\\n                if(mx<sum){\\n                    mx=sum;\\n                }\\n            }\\n            else{\\n                sum=n[i];\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>&n){\\n        int mx=n[0];\\n        int sum=n[0];\\n        for(int i=1; i<n.size(); i++){\\n            if(n[i-1]<n[i]){\\n                sum+=n[i];\\n                if(mx<sum){\\n                    mx=sum;\\n                }\\n            }\\n            else{\\n                sum=n[i];\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744987,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            sum+=nums[i];\\n            max=Math.max(max,sum);\\n            if(nums[i]>=nums[i+1])\\n                sum=0;\\n        }\\n        max=Math.max(max,sum+nums[nums.length-1]);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            sum+=nums[i];\\n            max=Math.max(max,sum);\\n            if(nums[i]>=nums[i+1])\\n                sum=0;\\n        }\\n        max=Math.max(max,sum+nums[nums.length-1]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741546,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxAscendingSum = function(nums) {\\n    let max = nums[0];\\n    let score = nums[0];\\n    let current = nums[0];\\n\\n    for(let i=1;i<nums.length;i++){\\n        if (current < nums[i]){\\n            score+=nums[i];\\n            current = nums[i];\\n        } else {\\n            current = nums[i];\\n            score = nums[i];\\n        }\\n        max = Math.max(score,max);\\n    }\\n\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxAscendingSum = function(nums) {\\n    let max = nums[0];\\n    let score = nums[0];\\n    let current = nums[0];\\n\\n    for(let i=1;i<nums.length;i++){\\n        if (current < nums[i]){\\n            score+=nums[i];\\n            current = nums[i];\\n        } else {\\n            current = nums[i];\\n            score = nums[i];\\n        }\\n        max = Math.max(score,max);\\n    }\\n\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739401,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = -1, tot = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i-1]<nums[i]) tot += nums[i];\\n            else{\\n                max = Math.max(max, tot);\\n                tot = nums[i];\\n            }\\n        }\\n        return Math.max(max, tot);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int max = -1, tot = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i-1]<nums[i]) tot += nums[i];\\n            else{\\n                max = Math.max(max, tot);\\n                tot = nums[i];\\n            }\\n        }\\n        return Math.max(max, tot);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730560,
                "title": "max-ascending-sum-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2);\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i,j,k,max=0,sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=nums[i];\\n            k=i;\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]>nums[k])\\n                {\\n                    sum+=nums[j];\\n                    k=j;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            if(sum>max)\\n            {\\n                max=sum;\\n            }\\n        }\\n        return max;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAscendingSum(vector<int>& nums) {\\n        int i,j,k,max=0,sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=nums[i];\\n            k=i;\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]>nums[k])\\n                {\\n                    sum+=nums[j];\\n                    k=j;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            if(sum>max)\\n            {\\n                max=sum;\\n            }\\n        }\\n        return max;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730180,
                "title": "go-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxAscendingSum(nums []int) int {\\n    sum := nums[0]\\n    temp := 0\\n\\n    for i := 0; i < len(nums); i++ {\\n        if i < len(nums)-1 && nums[i] < nums[i+1] {\\n            sum += nums[i+1]\\n        } else {\\n            if sum > temp {\\n                temp = sum\\n            }\\n            if i < len(nums)-1 {\\n                sum = nums[i+1]\\n            }\\n        }\\n    }\\n\\n    return temp\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxAscendingSum(nums []int) int {\\n    sum := nums[0]\\n    temp := 0\\n\\n    for i := 0; i < len(nums); i++ {\\n        if i < len(nums)-1 && nums[i] < nums[i+1] {\\n            sum += nums[i+1]\\n        } else {\\n            if sum > temp {\\n                temp = sum\\n            }\\n            if i < len(nums)-1 {\\n                sum = nums[i+1]\\n            }\\n        }\\n    }\\n\\n    return temp\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730085,
                "title": "dart-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int maxAscendingSum(List<int> nums) {\\n      var sums=[];\\n      int sum = 0;\\n      int i;\\n      for(i=0; i<nums.length-1; i++){\\n          if(nums[i]<nums[i+1]){\\n              sum = sum + nums[i];\\n          }else{\\n              sum = sum + nums[i];\\n              sums.add(sum);\\n              sum = 0;\\n          }\\n      }\\n      sum = sum+nums[i];\\n      sums.add(sum);\\n      sums.sort();\\n      return sums.last;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maxAscendingSum(List<int> nums) {\\n      var sums=[];\\n      int sum = 0;\\n      int i;\\n      for(i=0; i<nums.length-1; i++){\\n          if(nums[i]<nums[i+1]){\\n              sum = sum + nums[i];\\n          }else{\\n              sum = sum + nums[i];\\n              sums.add(sum);\\n              sum = 0;\\n          }\\n      }\\n      sum = sum+nums[i];\\n      sums.add(sum);\\n      sums.sort();\\n      return sums.last;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730078,
                "title": "easy-solution-in-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int maxAscendingSum(List<int> nums) {\\n      int sum = nums[0];\\n      int res = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          if(nums[i]>nums[i-1]){\\n              sum =sum+nums[i];\\n          }else{\\n              if(sum>res){\\n                  res = sum;\\n              }\\n              sum=nums[i];\\n          }\\n          if(sum>res){\\n              res=sum;\\n          }\\n      }\\n      return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maxAscendingSum(List<int> nums) {\\n      int sum = nums[0];\\n      int res = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          if(nums[i]>nums[i-1]){\\n              sum =sum+nums[i];\\n          }else{\\n              if(sum>res){\\n                  res = sum;\\n              }\\n              sum=nums[i];\\n          }\\n          if(sum>res){\\n              res=sum;\\n          }\\n      }\\n      return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1739306,
                "content": [
                    {
                        "username": "NeerAtCode",
                        "content": "Simple O(n) approach using Kadane\\'s Algorithm.\\n\\n"
                    },
                    {
                        "username": "Coding_is_hell",
                        "content": "strictly ascending !!!!"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "https://leetcode.com/problems/maximum-ascending-subarray-sum/solutions/3504151/solve-it-in-o-n/"
                    }
                ]
            },
            {
                "id": 1950951,
                "content": [
                    {
                        "username": "NeerAtCode",
                        "content": "Simple O(n) approach using Kadane\\'s Algorithm.\\n\\n"
                    },
                    {
                        "username": "Coding_is_hell",
                        "content": "strictly ascending !!!!"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "https://leetcode.com/problems/maximum-ascending-subarray-sum/solutions/3504151/solve-it-in-o-n/"
                    }
                ]
            },
            {
                "id": 1888109,
                "content": [
                    {
                        "username": "NeerAtCode",
                        "content": "Simple O(n) approach using Kadane\\'s Algorithm.\\n\\n"
                    },
                    {
                        "username": "Coding_is_hell",
                        "content": "strictly ascending !!!!"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "https://leetcode.com/problems/maximum-ascending-subarray-sum/solutions/3504151/solve-it-in-o-n/"
                    }
                ]
            }
        ]
    }
]