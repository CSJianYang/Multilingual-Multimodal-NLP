[
    {
        "title": "Find the Maximum Number of Marked Indices",
        "question_content": "You are given a 0-indexed integer array nums.\nInitially, all of the indices are unmarked. You are allowed to make this operation any number of times:\n\n\tPick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j.\n\nReturn the maximum possible number of marked indices in nums using the above operation any number of times.\n&nbsp;\nExample 1:\n\nInput: nums = [3,5,2,4]\nOutput: 2\nExplanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1.\nIt can be shown that there's no other valid operation so the answer is 2.\n\nExample 2:\n\nInput: nums = [9,2,5,4]\nOutput: 4\nExplanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0.\nIn the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] <= nums[2]. Then mark index 1 and 2.\nSince there is no other operation, the answer is 4.\n\nExample 3:\n\nInput: nums = [7,6,8]\nOutput: 0\nExplanation: There is no valid operation to do, so the answer is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109\n\n&nbsp;\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "solutions": [
            {
                "id": 3231114,
                "title": "two-pointers",
                "content": "Intuition for this problem is tricky.\\n\\nIndices `i` and `j` form a pair (if `2 * nums[i] < nums[j]`). If we want to make `m` pairs, the best strategy is to pick `m` smallest numbers as `nums[i]`.\\n\\nAt the same time, we cannot make more than `n / 2` pairs. Therefore, we consider `n - n / 2` largest numbers for `nums[j]`.\\n\\nSo, we sort the array, and greedily match smallest numbers with numbers in the second half of the sorted array.\\n\\n**C++**\\n```cpp\\nint maxNumOfMarkedIndices(vector<int>& nums) {\\n    int i = 0, n = nums.size();\\n    sort(begin(nums), end(nums));\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j];\\n    return i * 2;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int maxNumOfMarkedIndices(int[] nums) {\\n    int i = 0, n = nums.length;\\n    Arrays.sort(nums);\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j] ? 1 : 0;\\n    return i * 2;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        i, n = 0, len(nums)\\n        nums.sort()\\n        for j in range(n - n // 2, n):\\n            i += 2 * nums[i] <= nums[j]\\n        return i * 2\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nint maxNumOfMarkedIndices(vector<int>& nums) {\\n    int i = 0, n = nums.size();\\n    sort(begin(nums), end(nums));\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j];\\n    return i * 2;\\n}\\n```\n```java\\npublic int maxNumOfMarkedIndices(int[] nums) {\\n    int i = 0, n = nums.length;\\n    Arrays.sort(nums);\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j] ? 1 : 0;\\n    return i * 2;\\n}\\n```\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        i, n = 0, len(nums)\\n        nums.sort()\\n        for j in range(n - n // 2, n):\\n            i += 2 * nums[i] <= nums[j]\\n        return i * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230779,
                "title": "c-java-python-need-sorting-with-two-pointers",
                "content": "### SOLUTION\\n##### INTUTION \\n\\n---\\n\\n-  We only make `n / 2` pairs. So, we make pairs form element `i = 0` for first ptr & `j = n / 2` for second ptr if `nums[i] * 2 <= nums[j]` is valid pair then add `+2` in `ans` & increment `i` & also `j` bcz we used this two `idx`.\\n-  but it\\'s invalid then we know that next element of `jth` index is greater, so in that case we increament `jth` pointer.\\n---\\n\\n>**This intution by @votrubac** \\n\\n-  Intuition for this problem is tricky.\\n\\n-  Indices i and j form a pair (if 2 * nums[i] < nums[j]). If we want to make m pairs, the best strategy is to pick m smallest numbers as nums[i].\\n\\n-  At the same time, we cannot make more than n / 2 pairs. Therefore, we consider n - n / 2 largest numbers for nums[j].\\n\\n- So, we sort the array, and greedily match smallest numbers with numbers in the second half of the sorted array.\\n---\\n\\n\\n##### Time Complexity - `O(N*Log(N))`\\n##### Space Complexity - `O(1)`\\n\\n---\\n```cpp []\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = 0, i = 0, j = n/2;\\n        while(i < n/2 && j < n) {\\n            if(nums[i] * 2 <= nums[j]) ans += 2, i++, j++;\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, ans = 0, i = 0, j = n / 2; \\n        while(i < n / 2 && j < n) {\\n            if(nums[i] * 2 <= nums[j]) {ans += 2; i++; j++;}\\n            else j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n, i, ans = len(nums), 0, 0\\n        nums.sort()\\n        for j in range(n - n // 2, n):\\n            if nums[i] * 2 <= nums[j]:\\n                i += 1 \\n                ans += 2\\n        return ans\\n```\\n\\n\\n>##### If You Helpful, Please Upvote !!!\\n\\nHappy Coding ;) \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = 0, i = 0, j = n/2;\\n        while(i < n/2 && j < n) {\\n            if(nums[i] * 2 <= nums[j]) ans += 2, i++, j++;\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, ans = 0, i = 0, j = n / 2; \\n        while(i < n / 2 && j < n) {\\n            if(nums[i] * 2 <= nums[j]) {ans += 2; i++; j++;}\\n            else j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n, i, ans = len(nums), 0, 0\\n        nums.sort()\\n        for j in range(n - n // 2, n):\\n            if nums[i] * 2 <= nums[j]:\\n                i += 1 \\n                ans += 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230855,
                "title": "python3-c-java-sort-and-two-pointers",
                "content": "# Please UPVOTE\\uD83D\\uDE0A\\n# Two pointers\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums.size()/2;\\n        while (r<nums.size() and l<nums.size()/2)\\n        {\\n            if(2*nums[l]<=nums[r]) l++;\\n            r++;\\n        }\\n        return l*2;\\n    }\\n};\\n```\\n# Python3\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l,r=0,len(nums)//2\\n        while r<len(nums) and l<len(nums)//2:\\n            if 2*nums[l]<=nums[r]: l+=1\\n            r+=1\\n        return l*2\\n```\\n# Java\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int l=0,r=nums.length/2;\\n        while (r<nums.length && l<nums.length/2)\\n        {\\n            if(2*nums[l]<=nums[r])\\n            {\\n                l+=1;\\n            }\\n            r+=1;\\n        }\\n        return l*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums.size()/2;\\n        while (r<nums.size() and l<nums.size()/2)\\n        {\\n            if(2*nums[l]<=nums[r]) l++;\\n            r++;\\n        }\\n        return l*2;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l,r=0,len(nums)//2\\n        while r<len(nums) and l<len(nums)//2:\\n            if 2*nums[l]<=nums[r]: l+=1\\n            r+=1\\n        return l*2\\n```\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int l=0,r=nums.length/2;\\n        while (r<nums.length && l<nums.length/2)\\n        {\\n            if(2*nums[l]<=nums[r])\\n            {\\n                l+=1;\\n            }\\n            r+=1;\\n        }\\n        return l*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231353,
                "title": "explained-pointers-iteration-very-simple-easy-to-understand-solution",
                "content": "# Intuition\\nMax possible ans is nums.size() -> as we need to match each of the pairs \\nSo we can think to match the larger value with largest value first then keep on checking matching of smaller numbers.\\n\\n# Approach\\nSimpply sort the array \\nTake two pointers one at the mid (fptr )\\nand one at the last (ptr) -> refering to largest value.\\n\\nNow we iterate fptr to match it with the largest value at ptr.\\nKeep soing this and counting the matched pairs\\nReturn anser as no of matched pair x 2 to return no of marked elements\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1)\\n\\n#### Up vote if you like the solution \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int fptr = nums.size()/2-1, ptr = nums.size()-1, ans = 0;\\n        while(fptr >= 0 && ptr >= 0){\\n            //if(nums[ptr]) {\\n                if( 2*nums[fptr] <= nums[ptr] ) { ans++; ptr--; }\\n                fptr--;\\n            //}\\n            //else ptr--;\\n        }\\n        return 2*ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int fptr = nums.size()/2-1, ptr = nums.size()-1, ans = 0;\\n        while(fptr >= 0 && ptr >= 0){\\n            //if(nums[ptr]) {\\n                if( 2*nums[fptr] <= nums[ptr] ) { ans++; ptr--; }\\n                fptr--;\\n            //}\\n            //else ptr--;\\n        }\\n        return 2*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230864,
                "title": "2576-find-the-maximum-number-of-marked-indices-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=0;\\n        int g=(n+1)/2;\\n        while(g<n){\\n            if(nums[b]*2<=nums[g]) b++;\\n            g++;\\n        }\\n        return 2*b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=0;\\n        int g=(n+1)/2;\\n        while(g<n){\\n            if(nums[b]*2<=nums[g]) b++;\\n            g++;\\n        }\\n        return 2*b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231270,
                "title": "explanation-with-no-code",
                "content": "# Intuition\\nMany people post simple code without explanation, here I will do the contrary, which I think is more helpful (hopefully you think so too, if yes, please **UPVOTE**). Correct logic to this problem is tricky, please comment if you have better explainations. \\n\\n0. Definitely need to sort first\\n\\n1. Let\\'s call all pairs [a, b], where a * 2 <= b, then first we need to realize the set of a and set of b won\\'t overlap, that is, it is always possible to find an optimal solution where all a are before all b. (this step is not very easy to figure out, since you may think each time we can just grab the max, then find the largest index such that nums[indx] <= max//2, I tried that but it is not the correct way to go)\\n\\nWhy? suppose after put into order, the max possible pairs we can make is a1, b1, a2, a3, b2, b3, (numbers are in increasing order)\\nwhere a1 matches to b1, a2 matches to b2, a3 matches to b3, then it can always change to a1\\', a2\\', a3\\', b1\\', b2\\', b3\\' (the same set of numbers in increasing order), since we know a1*2 <= b1, thus a1\\' * 2 <= b1\\', etc.. \\n\\n2. Now we know set of a must come before set of b, the question reduces to, where is the best cutoff point, so that a are chosen before the cutoff, and all b are chosen after the cutoff? \\n\\nTo do this, we can use binary search, to search the range *ans* in range [0, n//2]: there are two cases, case 1 is that first part has only *ans* count of elements from the beginning, the rest belongs to the 2nd part, we can use 2 pointers to match these 2 parts (In python, part1 is nums[:ans], part2 is nums[ans:]); case 2 is that, second part only has *ans* count of elements from the end, the rest belongs to the 1st part (In python, part1 is nums[:-ans], part2 is nums[-ans:]), again we can use 2 pointers to match these 2 parts. If either of the case is feasible, we know *ans* is feasbile to achieve.\\n\\nHowever, after some thought, this is not the most efficient approach. If we look again the above 2 cases, we realize that, for all possible cases, no matter where the cutoff point is,  we only need to compare [0, mid) to [mid, n). For example, for above case 1, we can always start searching the 2nd part from the mid (i.e., 2nd pointer starts at the mid due to the fact that we still have enough candidates in the 2nd part, and these candidates are better than those we can choose from if we start the 2nd pointer before mid), which won\\'t hurt the optimal count a bit (since for all those b we can match from the 2nd part, we can find their replacement after mid)\\n\\n\\n# Approach\\ntwo pointers, 1st starts at index 0, 2nd starts at index mid\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "# Intuition\\nMany people post simple code without explanation, here I will do the contrary, which I think is more helpful (hopefully you think so too, if yes, please **UPVOTE**). Correct logic to this problem is tricky, please comment if you have better explainations. \\n\\n0. Definitely need to sort first\\n\\n1. Let\\'s call all pairs [a, b], where a * 2 <= b, then first we need to realize the set of a and set of b won\\'t overlap, that is, it is always possible to find an optimal solution where all a are before all b. (this step is not very easy to figure out, since you may think each time we can just grab the max, then find the largest index such that nums[indx] <= max//2, I tried that but it is not the correct way to go)\\n\\nWhy? suppose after put into order, the max possible pairs we can make is a1, b1, a2, a3, b2, b3, (numbers are in increasing order)\\nwhere a1 matches to b1, a2 matches to b2, a3 matches to b3, then it can always change to a1\\', a2\\', a3\\', b1\\', b2\\', b3\\' (the same set of numbers in increasing order), since we know a1*2 <= b1, thus a1\\' * 2 <= b1\\', etc.. \\n\\n2. Now we know set of a must come before set of b, the question reduces to, where is the best cutoff point, so that a are chosen before the cutoff, and all b are chosen after the cutoff? \\n\\nTo do this, we can use binary search, to search the range *ans* in range [0, n//2]: there are two cases, case 1 is that first part has only *ans* count of elements from the beginning, the rest belongs to the 2nd part, we can use 2 pointers to match these 2 parts (In python, part1 is nums[:ans], part2 is nums[ans:]); case 2 is that, second part only has *ans* count of elements from the end, the rest belongs to the 1st part (In python, part1 is nums[:-ans], part2 is nums[-ans:]), again we can use 2 pointers to match these 2 parts. If either of the case is feasible, we know *ans* is feasbile to achieve.\\n\\nHowever, after some thought, this is not the most efficient approach. If we look again the above 2 cases, we realize that, for all possible cases, no matter where the cutoff point is,  we only need to compare [0, mid) to [mid, n). For example, for above case 1, we can always start searching the 2nd part from the mid (i.e., 2nd pointer starts at the mid due to the fact that we still have enough candidates in the 2nd part, and these candidates are better than those we can choose from if we start the 2nd pointer before mid), which won\\'t hurt the optimal count a bit (since for all those b we can match from the 2nd part, we can find their replacement after mid)\\n\\n\\n# Approach\\ntwo pointers, 1st starts at index 0, 2nd starts at index mid\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3230920,
                "title": "python3-2-pointer",
                "content": "\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0 \\n        j = len(nums)-1\\n        for i in range(len(nums)//2-1, -1, -1): \\n            if nums[i]*2 <= nums[j]: \\n                ans += 2\\n                j -= 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0 \\n        j = len(nums)-1\\n        for i in range(len(nums)//2-1, -1, -1): \\n            if nums[i]*2 <= nums[j]: \\n                ans += 2\\n                j -= 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241900,
                "title": "100-solution-explained-code-explanation-video",
                "content": "# Intuition + Approach\\nhttps://youtu.be/Yi_-IZq40Cc\\n\\nIn this video, I have discussed two approaches, one that takes O(n) space and another optimized approach which takes O(1) space.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n- Space complexity: $$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\n        int n = nums.size();\\n        int i = 0;\\n        int j = n/2;\\n        int res = 0;\\n\\n        while(i<n/2 && j<n){\\n            if(2*nums[i]<=nums[j]){\\n                i++;\\n                j++;\\n                res += 2;\\n            }\\n            else\\n                j++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\n        int n = nums.size();\\n        int i = 0;\\n        int j = n/2;\\n        int res = 0;\\n\\n        while(i<n/2 && j<n){\\n            if(2*nums[i]<=nums[j]){\\n                i++;\\n                j++;\\n                res += 2;\\n            }\\n            else\\n                j++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230952,
                "title": "two-pointers-greedy-with-intuition-and-approach-with-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. We need to find the maximum possible number of marked indices in nums array by picking any 2 indices i and j such that 2* num[i] <= nums[j], then mark i and j (Initially all indices are unmarked).\\n2. We have to multiply nums[i] by 2 and then compare with nums[j] and then mark both indices if 2*nums[I]<=nums[j], in order to mark maximum indices we need to pick smallest value and then choose number which follows the above condition and mark them.\\n3. This can be done by sorting the nums array and comparing first element with the middle element as we need to find maximum marked indices. We also use two pointer approach two move the pointer from middle element(choosing mid element gives optimal solution) to next element if condition not matches and hence find the maximum indices see the approach and code to understand better.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the nums array.\\n2. Initialise two pointers i=0, j=nums.size()/2 and create a set to check indices are present or not.\\n3. First check if both the indices are present in set or not, if both indices are not present and matches the above condition then insert both indices into set and increment i and j pointers.\\n4. If above condition fails and j<n-1 then increment j pointer else increment i pointer.\\n5. Finally return size of set which stores the marked indices.\\n\\n\\n# Complexity\\n- Time complexity: N*Log(N) (sorting)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) (set)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        unordered_set<int> marked;\\n        int i = 0, j = n/2;\\n        while (i < n && j < n) {\\n            if (marked.find(i) == marked.end() && marked.find(j) == marked.end() && 2 * nums[i] <= nums[j]) {\\n                marked.insert(i);\\n                marked.insert(j);\\n                i++;\\n                j++;\\n            } \\n            else {\\n                if (j < n - 1) {\\n                    j++;\\n                } \\n                else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return marked.size();\\n    }\\n};\\n```\\n\\n# Upvote if you like the solution :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        unordered_set<int> marked;\\n        int i = 0, j = n/2;\\n        while (i < n && j < n) {\\n            if (marked.find(i) == marked.end() && marked.find(j) == marked.end() && 2 * nums[i] <= nums[j]) {\\n                marked.insert(i);\\n                marked.insert(j);\\n                i++;\\n                j++;\\n            } \\n            else {\\n                if (j < n - 1) {\\n                    j++;\\n                } \\n                else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return marked.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240358,
                "title": "leetcode-the-hard-way-binary-search",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), l = 0, r = n / 2;\\n        while (l < r) {\\n            int m = l + (r - l + 1) / 2;\\n            int ok = 1;\\n            for (int i = 0; i < m; i++) {\\n                if (2 * nums[i] > nums[n - m + i]) {\\n                    ok = 0;\\n                    break;\\n                }\\n            }\\n            if (ok) l = m;\\n            else r = m - 1;\\n        }\\n        return 2 * l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), l = 0, r = n / 2;\\n        while (l < r) {\\n            int m = l + (r - l + 1) / 2;\\n            int ok = 1;\\n            for (int i = 0; i < m; i++) {\\n                if (2 * nums[i] > nums[n - m + i]) {\\n                    ok = 0;\\n                    break;\\n                }\\n            }\\n            if (ok) l = m;\\n            else r = m - 1;\\n        }\\n        return 2 * l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232381,
                "title": "easy-simple-priority-queue-approach",
                "content": "# Intuition\\nSimply try to group the smaller number with a greater number such that it is just enough to satisfy the equation \\n\\n**2 * small <= large**\\n\\n\\nIt means if we have 2 possiblities for an element then we will choose the one which is just sufficient to satisfy the above equation\\n\\nFor ex - > For [ 2 , 3 , 5 , 8] \\n\\nIn this array we can have 2 possible pairs for 2 which are **( 2 , 5 )** and **( 2 , 8 )** so we will choose **first pair** as the condition is sufficient enough to make the valid pair i.e **2*2<=5**  and further 8 can be selected with 3 making ( 3 , 8) as another valid pair **2*3<=8**\\n\\n# Approach\\nSo it is always profitable to make pair between the max possible smaller and max possible greater or vice-versa\\n\\nTo do so we will divide the array into two half \\n\\nSmaller half --> These elements are the candidates for pair in which they will act as small elements\\n\\nGreater half --> These elements are the candidates for pair in which they will act as greater elements\\n\\nWe will store the both half seperately in max-heaps namely small heap and large heap to retrieve the candidates quickly\\n\\nThese half can be created by dividing the array into two parts after sorting because this will create a perfect distribution of elements such that we can get maximum possible pairs of valid elements which is equal to number_of_element / 2 ( if possible).\\n\\nNow we will try to make pairs such that for every element of smaller half we will check if there is some element in greater half which satisfy the equation .\\n\\n// If element found -- > then increase the answer by 2 and remove the top element from both the small and large heap\\n\\n// If element not found --> then remove the top element of small heap because there is no possible element available in the large heap which can make pair with this element\\n\\n###### WHY IT WORKS ?? \\n\\nSuppose we have an element a as the top of small priority queue and b as the top of large prioity queue\\n\\nif **2 * a <= b** is not true then there can not be any value for a which can help it make pair because\\n\\nin smaller half all the elements are less than or  equal to a hence a cannot have any pair-element within small half elements\\n\\nin greater half or large half all the elements are less than or equal to b and the equation is not true for b so eventually it will not be true for less than or equal to b choice of candidates  hence a cannot have any pair-element with large half elements\\n\\n\\n// DRY RUN \\n\\nEX - [ 14 , 9 , 9 , 2 , 5 ,15 ]\\n\\nAfter sorting [ 2 , 5 , 9 , 9  ,14 , 15] \\n\\n\\nSmaller half -- 9 , 5 , 2 ( greater ele at top -- max heap)\\n\\nLarge or Greater half -- 15 , 14 , 9 ( greater ele at top -- max heap)\\n\\n\\n1) 2 * 9 <=  15 ( false ) . Hence we cannot make a valid pair for 9 thus remove it from small heap \\n\\n2) 2 * 5 <= 15 ( true ) . Valid pair can be made thus answer += 2 and remove both 5 and 15 from small heap and large heap respectively \\n\\n3) 2 * 2 <= 14 (true ) . Valid pair can be made thus answer += 2 and remove both 2 and 14 from small heap and large heap respectively \\n\\n\\nNow more candidates left in small heap hence the algorithm stops and we got our answer as 4 i.e 4 indexes are marked with pairs ( 5 , 15 ) and ( 2 , 14 ) .\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nnlogn for sorting \\nnlogn for storing elements in the heap and executing operations\\n\\nHence overall time complexity is \\nO ( nlogn )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nExtra Space required to store the elements in heap \\n\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        // sort the elements in non-decreasing order \\n        \\n        sort( nums.begin() , nums.end());\\n        \\n         // priority queue to store the smaller elements \\n\\n        priority_queue< int >small;\\n        \\n        // priority queue to store the greater elements\\n          \\n        priority_queue< int >large;\\n        \\n        int size = nums.size();\\n        \\n        // first half of sorted array in small priority_queue\\n\\n        for( int i = 0; i < size /2 ; i++)\\n        {\\n            small.push(nums[i]);\\n        }\\n        // second half of sorted array in large priority_queue        \\n\\n        for( int i = size /2 ; i < size ; i++)\\n        {\\n            large.push(nums[i]);\\n        }\\n        \\n\\n        int ans = 0;\\n        \\n        // check till the small heap become empty \\n         \\n        while(small.empty() == false)\\n        {   \\n\\n            // if large heap is not empty then check\\n            // if the current element of large heap is greater than small heap element or not \\n            \\n            // if yes -- > increase ans +=2 and remove the small\\n            // as well as large heap element as they have formed pair\\n            \\n           // if no -- > remove the small heap element as there is no possible element \\n           // available to satisfy the equation 2*small_ele <= large_ele             \\n\\n                if(large.top() >= 2*small.top())\\n                {\\n                    ans += 2;\\n\\n                    large.pop();\\n                }\\n\\n                small.pop();\\n        }\\n        \\n        return  ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        // sort the elements in non-decreasing order \\n        \\n        sort( nums.begin() , nums.end());\\n        \\n         // priority queue to store the smaller elements \\n\\n        priority_queue< int >small;\\n        \\n        // priority queue to store the greater elements\\n          \\n        priority_queue< int >large;\\n        \\n        int size = nums.size();\\n        \\n        // first half of sorted array in small priority_queue\\n\\n        for( int i = 0; i < size /2 ; i++)\\n        {\\n            small.push(nums[i]);\\n        }\\n        // second half of sorted array in large priority_queue        \\n\\n        for( int i = size /2 ; i < size ; i++)\\n        {\\n            large.push(nums[i]);\\n        }\\n        \\n\\n        int ans = 0;\\n        \\n        // check till the small heap become empty \\n         \\n        while(small.empty() == false)\\n        {   \\n\\n            // if large heap is not empty then check\\n            // if the current element of large heap is greater than small heap element or not \\n            \\n            // if yes -- > increase ans +=2 and remove the small\\n            // as well as large heap element as they have formed pair\\n            \\n           // if no -- > remove the small heap element as there is no possible element \\n           // available to satisfy the equation 2*small_ele <= large_ele             \\n\\n                if(large.top() >= 2*small.top())\\n                {\\n                    ans += 2;\\n\\n                    large.pop();\\n                }\\n\\n                small.pop();\\n        }\\n        \\n        return  ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231018,
                "title": "beats-100-solutions-sorting-easy-and-understandable-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>&v) {\\n        sort(v.begin(),v.end());\\n        int i=0,n=v.size(),j=n/2,cnt=0;\\n        while(i<n/2 && j<n){\\n            if(v[i]*2<=v[j]){\\n                i++;\\n                j++;\\n                cnt+=2;\\n            }\\n            else j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>&v) {\\n        sort(v.begin(),v.end());\\n        int i=0,n=v.size(),j=n/2,cnt=0;\\n        while(i<n/2 && j<n){\\n            if(v[i]*2<=v[j]){\\n                i++;\\n                j++;\\n                cnt+=2;\\n            }\\n            else j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230939,
                "title": "c-solution-tc-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint maxNumOfMarkedIndices(vector<int> &arr)\\n{\\n    int n = arr.size();\\n    sort(arr.begin(), arr.end());\\n    int ans = 0;\\n    int h = n +1;\\n    h/=2;\\n    int pre = n;\\n    int l=0;\\n\\n    while (h<n)\\n    {\\n        if (arr[l]*2<=arr[h])\\n        {\\n            l++;\\n            h++;\\n        }\\n        else\\n        {\\n            h++;\\n        }\\n        \\n        \\n    }\\n    \\n    return l*2;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxNumOfMarkedIndices(vector<int> &arr)\\n{\\n    int n = arr.size();\\n    sort(arr.begin(), arr.end());\\n    int ans = 0;\\n    int h = n +1;\\n    h/=2;\\n    int pre = n;\\n    int l=0;\\n\\n    while (h<n)\\n    {\\n        if (arr[l]*2<=arr[h])\\n        {\\n            l++;\\n            h++;\\n        }\\n        else\\n        {\\n            h++;\\n        }\\n        \\n        \\n    }\\n    \\n    return l*2;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230841,
                "title": "easy-c-using-multiset",
                "content": "# Intuition\\nSort nums and then We need to find lowerbond of nums[i]*2 if found then delete else break\\n\\n# Approach\\nusing multiset will reduce time-complexity\\ntake 2 multiset and insert first n/2 smallest element in one and other in 2nd\\n\\nnow if lower bound of smallest element * 2 is found in 2nd multiset we will delete that element and increase ans by 2 else break the loop\\n\\n# Time Complexity\\nO(n log(n))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        multiset<long long>le,ri;\\n        for(int i=0;i<n/2;++i){\\n            le.insert(nums[i]);\\n        }\\n        for(int i=n/2;i<n;++i){\\n            ri.insert(nums[i]);\\n        }\\n        int ans=0;\\n        \\n        for(auto it=le.begin();it!=le.end();++it){\\n            long long val=*it;\\n            val*=2;\\n            auto it1=ri.lower_bound(val);\\n            if(it1==ri.end()){\\n                break;\\n            }else{\\n                ans+=2;\\n                ri.erase(it1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        multiset<long long>le,ri;\\n        for(int i=0;i<n/2;++i){\\n            le.insert(nums[i]);\\n        }\\n        for(int i=n/2;i<n;++i){\\n            ri.insert(nums[i]);\\n        }\\n        int ans=0;\\n        \\n        for(auto it=le.begin();it!=le.end();++it){\\n            long long val=*it;\\n            val*=2;\\n            auto it1=ri.lower_bound(val);\\n            if(it1==ri.end()){\\n                break;\\n            }else{\\n                ans+=2;\\n                ri.erase(it1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230960,
                "title": "codeforces-2-pointers-easy-and-elegant",
                "content": "# Intuition\\nWe can have at max N / 2 pairs. We have to greedily assign in groups of 2. How to do that ? Consider different problem of dividing array in 2 parts after sorting both having size N / 2. Did you get an idea?\\n\\n# Approach\\nSo we can split array in two set, such that first set contains the elements whose size is in smaller half and second set contains the elements whose size is in larger half, and use easy greedy algorithm. \\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```c++ []\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), i = 0, j = n / 2;\\n        \\n        while(i < n / 2 && j < n) {\\n            while(j < n && 2 * A[i] > A[j]) {\\n                j += 1;\\n            }\\n            if(j == n) {\\n                break;\\n            }\\n            i += 1;\\n            j += 1;\\n        }\\n        \\n        return i * 2;\\n    }\\n};\\n```\\n\\n# Codeforces\\nhttps://codeforces.com/contest/372/problem/A\\n\\nThanks, you can upvote :\\')",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sort"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), i = 0, j = n / 2;\\n        \\n        while(i < n / 2 && j < n) {\\n            while(j < n && 2 * A[i] > A[j]) {\\n                j += 1;\\n            }\\n            if(j == n) {\\n                break;\\n            }\\n            i += 1;\\n            j += 1;\\n        }\\n        \\n        return i * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233352,
                "title": "greedy-solution",
                "content": "# Intuition\\nWe can sort an array and make a gridy solution here. \\n\\n# Approach\\nSort the array. We can have up to N/2 index pairs. Check first N/2 smallest elements and try find min element from the second half so that condition will be valid.\\n\\n# Complexity\\n- Time complexity:\\nO(N*Log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n   nums.sort((a,b) => a-b)\\n   let i = 0\\n   let end = Math.floor(nums.length / 2)\\n   let j = end\\n   let res = 0;\\n   while(i < end && j < nums.length){\\n       if(2*nums[i] <= nums[j]){\\n           res+=2\\n           i++\\n       }\\n       j++\\n   }\\n\\n   return res\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n   nums.sort((a,b) => a-b)\\n   let i = 0\\n   let end = Math.floor(nums.length / 2)\\n   let j = end\\n   let res = 0;\\n   while(i < end && j < nums.length){\\n       if(2*nums[i] <= nums[j]){\\n           res+=2\\n           i++\\n       }\\n       j++\\n   }\\n\\n   return res\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3232369,
                "title": "c-easy-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        int n=v.size();\\n        map<int,int>m;\\n        sort(v.begin(),v.end());\\n        int left = 0, right = n/2;\\n        int count = 0;\\n        while (left <n && right <n) {\\n            if(m[left]){\\n                left++;\\n                continue;\\n            }\\n            if(m[right]){\\n                right++;\\n                continue;\\n            }\\n            if(left==right){\\n                right++;\\n                continue;\\n            }\\n            if (2 * v[left] <= v[right]) {\\n                count++;\\n                m[left]++;\\n                m[right]++;\\n                left++;\\n                right++;  \\n            }\\n            else\\n            right++;\\n        } \\n        return count*2; \\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/360356ec-be49-4e11-bce3-4abce0c78e4e_1677407533.801757.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        int n=v.size();\\n        map<int,int>m;\\n        sort(v.begin(),v.end());\\n        int left = 0, right = n/2;\\n        int count = 0;\\n        while (left <n && right <n) {\\n            if(m[left]){\\n                left++;\\n                continue;\\n            }\\n            if(m[right]){\\n                right++;\\n                continue;\\n            }\\n            if(left==right){\\n                right++;\\n                continue;\\n            }\\n            if (2 * v[left] <= v[right]) {\\n                count++;\\n                m[left]++;\\n                m[right]++;\\n                left++;\\n                right++;  \\n            }\\n            else\\n            right++;\\n        } \\n        return count*2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231476,
                "title": "c-2-pointers-intuitive",
                "content": "\\n# Approach\\n- Sort the array.\\n- Find out the mid and start iterating till mid is lesser than j.\\n- IF our condition matches (2*nums[mid] <= nums[j]) : inrease the counter + move backward.\\n- IF not then call back mid by 1 step.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort( nums.begin(), nums.end() );\\n\\n        int mid = (n/2)-1;\\n        int j = n-1;\\n\\n        int cnt = 0;\\n\\n        while( mid>=0 && mid<j ){\\n\\n            if( 2*nums[mid] <= nums[j] ) {\\n                cnt += 2;\\n                mid--; j--;\\n            }\\n\\n            else mid--;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```\\n**\\uD83D\\uDC4DPlase Upvote IF u Like the Solution :D**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort( nums.begin(), nums.end() );\\n\\n        int mid = (n/2)-1;\\n        int j = n-1;\\n\\n        int cnt = 0;\\n\\n        while( mid>=0 && mid<j ){\\n\\n            if( 2*nums[mid] <= nums[j] ) {\\n                cnt += 2;\\n                mid--; j--;\\n            }\\n\\n            else mid--;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231187,
                "title": "c-explanation-beats-100",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n-   The given problem asks to find the maximum number of marked indices in the given array \"nums\" using a specific operation any number of times.\\n- The given operation involves selecting two different unmarked indices i and j such that 2 * nums[i] <= nums[j], and then marking them.\\n- The solution approach is to sort the given array and maintain two pointers, f and s. Initially, f is set to 0 and s is set to the middle index of the array (or the next integer if the array has an odd length).\\n- We then iterate over the array with the condition s < n, where n is the length of the array. Within the loop, we check if the current condition for the operation is satisfied, i.e., if nums[f] * 2 is less than or equal to nums[s]. If the condition is satisfied, we move the f pointer forward to the next unmarked index.\\n- In the end, we return the number of marked indices, which is equal to the value of f multiplied by 2. This is because we marked two indices (i and j) in each successful operation.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n    - The time complexity of this solution is O(nlogn) due to the sorting operation.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n    - The space complexity is O(1) as we are not using any extra space to solve this problem.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n       \\n        int f=0,s=(nums.size()+1)/2;\\n        while(s<n)\\n        {\\n            if(nums[f]*2<=nums[s]) \\n                f++;\\n            \\n            s++;\\n        }\\n        return f*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n       \\n        int f=0,s=(nums.size()+1)/2;\\n        while(s<n)\\n        {\\n            if(nums[f]*2<=nums[s]) \\n                f++;\\n            \\n            s++;\\n        }\\n        return f*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231183,
                "title": "clean-short-java",
                "content": "\\n# Code\\n```java []\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int count = 0, j = nums.length-1;\\n        Arrays.sort(nums);\\n        for(int i=nums.length/2-1; i>=0; i--){\\n            if(nums[i] <= nums[j]/2){\\n                count += 2;\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int count = 0, j = nums.length-1;\\n        Arrays.sort(nums);\\n        for(int i=nums.length/2-1; i>=0; i--){\\n            if(nums[i] <= nums[j]/2){\\n                count += 2;\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230797,
                "title": "python-sort-o-nlogn-o-n-greedy",
                "content": "# Intuition\\nMax count of pairs are N/2 pairs.\\nAfter sort nums,\\nif nums[mid] >= nums[0] * 2 then all indices after mid works, greedily select nums[mid]\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        m = len(nums)//2\\n        i, j = 0, m\\n        res = 0\\n        nums.sort()\\n        while i < m and j < len(nums):\\n            if nums[j] >= nums[i]*2:\\n                res += 2\\n                i += 1\\n            j += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        m = len(nums)//2\\n        i, j = 0, m\\n        res = 0\\n        nums.sort()\\n        while i < m and j < len(nums):\\n            if nums[j] >= nums[i]*2:\\n                res += 2\\n                i += 1\\n            j += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234136,
                "title": "python-3-7-lines-w-explanation-and-example-t-m-644-ms-27-7-mb",
                "content": "Here\\'s the plan:\\n- We sort`nums`.\\n- We use the ptr`r`to iterate left-to-right through the second half of`nums`. For each value of`r`, we increment another ptr`l` to identify the least available value to pair with`nums[r`].\\n- Because each increment of`l`indicates a successful pairng, and each successful pairiing increases the number of markings by two, we return`2*l`\\n\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n\\n                                    # Example: nums = [9,2,5,4,5,7,7]\\n        nums.sort()                 # <\\u2013\\u2013      nums = [2,4,5,5,7,7,9]\\n        n = len(nums)\\n        l, r = 0, n//2              #   (l,r)   nums[l]   nums[r]\\n                                    #   \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n        while l < n//2 and r < n:   #   (0,3)      2         5   <\\u2013\\u2013 (2*2<=5) = True\\n                                    #   (1,4)      4         6   <\\u2013\\u2013 (2*4<=6) = False \\n            l+= 2*nums[l]<=nums[r]  #   (1,5)      4         7   <\\u2013\\u2013 (2*4<=7) = False \\n                                    #   (1,6)      5         9   <\\u2013\\u2013 (2*4<=9) = True\\n            r+= 1                   #   (2,7)      r >= n\\n                                    #\\n        return 2*l                  #    return 2*2 = 4\\n```\\n[https://leetcode.com/problems/find-the-maximum-number-of-marked-indices/submissions/905498629/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n\\n                                    # Example: nums = [9,2,5,4,5,7,7]\\n        nums.sort()                 # <\\u2013\\u2013      nums = [2,4,5,5,7,7,9]\\n        n = len(nums)\\n        l, r = 0, n//2              #   (l,r)   nums[l]   nums[r]\\n                                    #   \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n        while l < n//2 and r < n:   #   (0,3)      2         5   <\\u2013\\u2013 (2*2<=5) = True\\n                                    #   (1,4)      4         6   <\\u2013\\u2013 (2*4<=6) = False \\n            l+= 2*nums[l]<=nums[r]  #   (1,5)      4         7   <\\u2013\\u2013 (2*4<=7) = False \\n                                    #   (1,6)      5         9   <\\u2013\\u2013 (2*4<=9) = True\\n            r+= 1                   #   (2,7)      r >= n\\n                                    #\\n        return 2*l                  #    return 2*2 = 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233285,
                "title": "c-solutions-beats-100-based-on-the-basic-approach",
                "content": "\\n\\n# Approach\\nBASIC APPROACH & EASY TO UNDERSTAND\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int p=0;\\n        int q=(n+1)/2;\\n        sort(nums.begin(),nums.end());\\n\\n        if(n==1)\\n            return 0;\\n        while(p<n && q<n)\\n        {\\n            if(2 * nums[p] <= nums[q])\\n            {\\n                p++;\\n            }\\n            q++;\\n        }\\n        return p*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int p=0;\\n        int q=(n+1)/2;\\n        sort(nums.begin(),nums.end());\\n\\n        if(n==1)\\n            return 0;\\n        while(p<n && q<n)\\n        {\\n            if(2 * nums[p] <= nums[q])\\n            {\\n                p++;\\n            }\\n            q++;\\n        }\\n        return p*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231524,
                "title": "c-using-two-pointer",
                "content": "# Approach\\nsort the array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        vector<int> sorted=v;\\n        sort(sorted.begin(),sorted.end());\\n        nums=sorted;        \\n        int s=0,e=(nums.size()+1)/2,count=0;\\n        while(e<nums.size())\\n        {\\n            if(2*nums[s]<=nums[e])\\n            {\\n                s++;\\n                count++;\\n            }\\n            e++;\\n        }\\n        cout<<\"ankit\"<<e<<\" \";\\n       return 2*count;\\n    }\\n};\\n// [1,78,27,48,14,86,79,68,77,20,57,21,18,67,5,51,70,85,47,56,22,79,41,8,39,81,59,74,14,45,49,15,10,28,16,77,22,65,8,36,79,94,44,80,72,8,96,78,39,92,69,55,9,44,26,76,40,77,16,69,40,64,12,48,66,7,59,10]\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        vector<int> sorted=v;\\n        sort(sorted.begin(),sorted.end());\\n        nums=sorted;        \\n        int s=0,e=(nums.size()+1)/2,count=0;\\n        while(e<nums.size())\\n        {\\n            if(2*nums[s]<=nums[e])\\n            {\\n                s++;\\n                count++;\\n            }\\n            e++;\\n        }\\n        cout<<\"ankit\"<<e<<\" \";\\n       return 2*count;\\n    }\\n};\\n// [1,78,27,48,14,86,79,68,77,20,57,21,18,67,5,51,70,85,47,56,22,79,41,8,39,81,59,74,14,45,49,15,10,28,16,77,22,65,8,36,79,94,44,80,72,8,96,78,39,92,69,55,9,44,26,76,40,77,16,69,40,64,12,48,66,7,59,10]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3231144,
                "title": "video-explanation-how-to-reach-at-2-pointers-solution",
                "content": "# Video Explanation\\n\\nhttps://youtu.be/lk9H3FYvqQw\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        vector<bool> marked(n, false);\\n        int l = 0, r = (n + 1)/2;\\n        \\n        while (l <= (n-1)/2) {\\n            while (r < n && nums[l]*2 > nums[r]) r ++;\\n            \\n            if (r < n) {\\n                marked[l] = marked[r] = true;\\n                l ++, r ++;\\n            }\\n            else break;\\n        }\\n        \\n        int result = 0;\\n        for (auto i : marked) if (i) result ++;\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        vector<bool> marked(n, false);\\n        int l = 0, r = (n + 1)/2;\\n        \\n        while (l <= (n-1)/2) {\\n            while (r < n && nums[l]*2 > nums[r]) r ++;\\n            \\n            if (r < n) {\\n                marked[l] = marked[r] = true;\\n                l ++, r ++;\\n            }\\n            else break;\\n        }\\n        \\n        int result = 0;\\n        for (auto i : marked) if (i) result ++;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231055,
                "title": "2-solutions-two-pointers-binary-search-c",
                "content": "# Binary Search\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int> v(n), idx, cnt(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            int pos = lower_bound(nums.begin(), nums.end(), nums[i] * 2) - nums.begin();\\n            v[i] = pos < n ? pos : -1;\\n        }\\n        for(int i : v) {\\n            if(i != -1) idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), greater<int>());\\n        \\n        int j = n - 1, ans = 0;\\n        for(int i : idx) {\\n            if(j >= i) cnt[j] = 1, j--;\\n        }\\n        for(int i : cnt) ans += i * 2;\\n        if(n % 2) n--;\\n        return min(ans, n);\\n    }\\n};\\n```\\n\\n# Two Pointers\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size() - 1, i = n / 2, j = n, ans = 0;\\n        while(i >= 0 && j > n / 2) {\\n            if(nums[i] * 2 <= nums[j]) ans += 2, i--, j--;\\n            else i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int> v(n), idx, cnt(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            int pos = lower_bound(nums.begin(), nums.end(), nums[i] * 2) - nums.begin();\\n            v[i] = pos < n ? pos : -1;\\n        }\\n        for(int i : v) {\\n            if(i != -1) idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), greater<int>());\\n        \\n        int j = n - 1, ans = 0;\\n        for(int i : idx) {\\n            if(j >= i) cnt[j] = 1, j--;\\n        }\\n        for(int i : cnt) ans += i * 2;\\n        if(n % 2) n--;\\n        return min(ans, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size() - 1, i = n / 2, j = n, ans = 0;\\n        while(i >= 0 && j > n / 2) {\\n            if(nums[i] * 2 <= nums[j]) ans += 2, i--, j--;\\n            else i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230991,
                "title": "c-sorting-sliding-widow",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 0, i = 0, j, n = nums.size();\\n        j = n-1;\\n        for(i = n/2-1; i>=0;i--){\\n            if(nums[j]>=nums[i]*2){\\n                ans += 2;\\n                j--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 0, i = 0, j, n = nums.size();\\n        j = n-1;\\n        for(i = n/2-1; i>=0;i--){\\n            if(nums[j]>=nums[i]*2){\\n                ans += 2;\\n                j--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230970,
                "title": "sorting-two-pointers-approach",
                "content": "# Complexity\\n- Time `O(N logN)`\\n- Space `O(N) #for sorting`\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxNumOfMarkedIndices(self, nums):\\n        nums.sort()\\n        n, res = len(nums), 0\\n        ptr1, ptr2 = 0, n // 2\\n        while ptr2 < n:\\n            if nums[ptr1] * 2 <= nums[ptr2]:\\n                if nums[ptr1] == -1: break #this condition will help when n is odd.\\n                else:\\n                    nums[ptr1], nums[ptr2] = -1, -1 #Mark index as taken.\\n                    res += 2\\n                    ptr1 += 1\\n            ptr2 += 1\\n        return res\\n```\\n**UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxNumOfMarkedIndices(self, nums):\\n        nums.sort()\\n        n, res = len(nums), 0\\n        ptr1, ptr2 = 0, n // 2\\n        while ptr2 < n:\\n            if nums[ptr1] * 2 <= nums[ptr2]:\\n                if nums[ptr1] == -1: break #this condition will help when n is odd.\\n                else:\\n                    nums[ptr1], nums[ptr2] = -1, -1 #Mark index as taken.\\n                    res += 2\\n                    ptr1 += 1\\n            ptr2 += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232456,
                "title": "sorting-set-intuition-behind-the-solution",
                "content": "1- As we need to find the number of pairs such that 2*nums[i]<=nums[j], so atfirst we will think of for each number finding the smallest number that will satisfy the given condition.\\n\\t\\t\\tError in this way - For each number if we find the smallest number that satisfy the given condition then it may lie in the same half which will decrease the number of other pairs that can be formed.\\n\\t\\t\\texample - A=[4,8,15,17]\\n\\t\\t\\tif we pair 4 with 8 then we cannot form pair of 15 and 17.\\nCorrect approach - We will think of the given array as two halves and the for the each number in the first half we will find the element satisfying the given condition in the second half as we can form maximum of n/2 pairs.\\n\\tExample - A=[4,8,15,17]\\n\\tNow we will consider 4,8 as the first hlaf and 15,17 as second half \\n\\tand for 4 we will form pair with 15 and for 8 we will form pair with 17.\\nFor finding such an element in the second half we can either use Two pointer, Binary search or Set\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int ans=0, n=v.size();\\n        int i=(n-1)/2;\\n        multiset<int> s(v.begin(), v.end());\\n        while(s.size()>1 && i>=0){\\n            auto str=s.find(v[i]);\\n            auto ptr=s.lower_bound((*str)*2);\\n            if(ptr!=s.end()){\\n                ans+=2;\\n                s.erase(str);\\n                s.erase(ptr);\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int ans=0, n=v.size();\\n        int i=(n-1)/2;\\n        multiset<int> s(v.begin(), v.end());\\n        while(s.size()>1 && i>=0){\\n            auto str=s.find(v[i]);\\n            auto ptr=s.lower_bound((*str)*2);\\n            if(ptr!=s.end()){\\n                ans+=2;\\n                s.erase(str);\\n                s.erase(ptr);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3230953,
                "title": "javascript-code-with-approach",
                "content": "**The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.**\\n\\n**To achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.**\\n\\n**We continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices.**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n     const n = nums.length;\\n  nums.sort((a, b) => a - b); // sort the array in non-decreasing order\\n  let st = 0;\\n  let mid = Math.floor((n + 1) / 2);\\n  while (mid < n) {\\n    if (nums[st] * 2 <= nums[mid]) {\\n      st++;\\n    }\\n    mid++;\\n  }\\n  return st * 2; \\n};\\n```\\n# UpVoting is Much Appreciated",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n     const n = nums.length;\\n  nums.sort((a, b) => a - b); // sort the array in non-decreasing order\\n  let st = 0;\\n  let mid = Math.floor((n + 1) / 2);\\n  while (mid < n) {\\n    if (nums[st] * 2 <= nums[mid]) {\\n      st++;\\n    }\\n    mid++;\\n  }\\n  return st * 2; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231743,
                "title": "binary-search-easy-solution",
                "content": "# Approach\\nBinary Search\\n\\nif we think brout force :\\nfor example given a sorted array : 2, 3, 5, 6, 7, 9\\ntake first 1 and last 1 numbers : 2x2 <= 9. It satisfy the condition\\nthen take first 2 and last 2 numbers : 2x2 <= 7, 3x2 <= 9. It satisfy the condition.\\nthen take first 3 and last 3 number : 2x2 <= 6, 3x2 <= 7, but 5x3 > 9 It does not satisfy the condition.\\nSo the ans is 2.\\n```\\nclass Solution {\\npublic:\\n    int max_count(vector<int>&a)\\n    {\\n        sort(a.begin(),a.end());\\n        int ans = 0, n = a.size();\\n        int l = 0, r = n/2;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2, flag = 0, c1 = 0;\\n            vector <int> v, v1;\\n\\n            for (int i = 0; i < mid; i++) v.push_back(a[i]);\\n            // store from first in v\\n            for (int i = n-1; i >= 0; i--) {\\n                if (c1 == mid) break;\\n                v1.push_back(a[i]);\\n                c1++;\\n            }\\n            // store from last in v1 and then reverse\\n            reverse(v1.begin(), v1.end());\\n            for (int i = 0; i < mid; i++) \\n            {\\n                if (v[i]*2 > v1[i]) flag = 1;\\n            }\\n            if (flag == 0) { // if all element v[i]*2 <= v1[i]\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else {\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& a) \\n    {\\n        int x = max_count(a);\\n        return x*2;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int max_count(vector<int>&a)\\n    {\\n        sort(a.begin(),a.end());\\n        int ans = 0, n = a.size();\\n        int l = 0, r = n/2;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2, flag = 0, c1 = 0;\\n            vector <int> v, v1;\\n\\n            for (int i = 0; i < mid; i++) v.push_back(a[i]);\\n            // store from first in v\\n            for (int i = n-1; i >= 0; i--) {\\n                if (c1 == mid) break;\\n                v1.push_back(a[i]);\\n                c1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3231390,
                "title": "binary-search-easy-lower-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        int i = 0,j = 0, n = size(nums), cnt = 0;\\n        auto it = nums.begin();\\n        \\n        for(int i = 0; i < n/2; i++) {\\n            \\n            it++;\\n            it = lower_bound(it, end(nums), nums[i]*2);\\n            if(it == end(nums))break;\\n            cnt++;\\n        }\\n        return cnt*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        int i = 0,j = 0, n = size(nums), cnt = 0;\\n        auto it = nums.begin();\\n        \\n        for(int i = 0; i < n/2; i++) {\\n            \\n            it++;\\n            it = lower_bound(it, end(nums), nums[i]*2);\\n            if(it == end(nums))break;\\n            cnt++;\\n        }\\n        return cnt*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231064,
                "title": "very-simple-solution",
                "content": "**connect with me on linkedin https://www.linkedin.com/in/raghav-upadhyay-80336b229/**\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& n) {\\n        int myans=0;\\n        sort(n.begin(),n.end());\\n        int i=0,j=(n.size()+1)/2;\\n        while(j<n.size()){\\n            if(n[i]*2<=n[j]){\\n                myans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return myans*2;\\n    }\\n};\\n```\\n# **Don\\'t forgot to upvote \\u2B06\\uFE0F**\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& n) {\\n        int myans=0;\\n        sort(n.begin(),n.end());\\n        int i=0,j=(n.size()+1)/2;\\n        while(j<n.size()){\\n            if(n[i]*2<=n[j]){\\n                myans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return myans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230996,
                "title": "c-binary-search-greedy-similar-to-painters-partition",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool pos(int x,vector<int>&nums){\\n        int n=nums.size();\\n        int i=0;\\n        int j=x;\\n        while(i<x&&j<n){\\n            if(nums[i]*2<=nums[j])\\n                i++;\\n            j++;\\n        }\\n        return i==x;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int lo=0;\\n        int hi=nums.size()/2;\\n        int ans=0;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(pos(mid,nums)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pos(int x,vector<int>&nums){\\n        int n=nums.size();\\n        int i=0;\\n        int j=x;\\n        while(i<x&&j<n){\\n            if(nums[i]*2<=nums[j])\\n                i++;\\n            j++;\\n        }\\n        return i==x;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int lo=0;\\n        int hi=nums.size()/2;\\n        int ans=0;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(pos(mid,nums)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603312,
                "title": "understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n   \\n   the main problem of this question was , that  we want to increase the count of maximum marked index\\n   , now since 10^5 length h array ki , oth ye toh pakka h ki hum sorting karenge ; \\n\\n   // now , hum starting se iterate kar re hain , ab kaun se index wale ko uske saath pair kare , ye dikkat \\n   hai ( because marked humesha pair mein honge , becauae each time we have to take two unmarked index)\\n   and we have to marked them , and \\n\\n   ONE IMPORANT POINT IS THAT ANSWER WILL BE EVEN , MEANS COUNT OF MARKED INDEX WILL BE EVEN ( obviously \\n   because we are marking indexes in pairs ) , and THE MAXIMUM ANSWER CAN BE (N/2) BECAUSE USKE BAAD\\n   ELEMENT BACHENGE HI NAHI \\n\\n\\n   NOW THE Optimised way OF DOING QUESITNO IS \\n\\n   1. SORT THE ARRAY ; \\n\\n   2. DIVIDE THE ARRAY INTO TWO PARTS , AND DONO KE STARTING MEIN TWO POINTERS RAKEHNGE AND THEN\\n      COUNT GINNA SHURU KARENGE ; \\n\\n      ( JAB BHI PAIR MEIN INDEXES MEIN MARKED KARNA HO , KISI BHI REASON KE WAJAH SE ,TOH PHLE\\n      SORT KARENEGE , FIRST USKE BAAD MATCHING \\n      HUMESHA AISE HI HOGI , ARRAY KKO 2 PART MEIN DIVIDE KARENGE , FIR DO POINTER DONO KE STARTING\\n      MEIN RAKH DENGE , AUR FIR DEKHENGE )\\n*/\\n\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        \\n        \\n        Arrays.sort(nums) ;\\n\\n         int i = 0 ; \\n         int j = nums.length/2 ; \\n\\n          long count = 0 ;\\n\\n         while( i < nums.length/2 && j < nums.length)\\n         {\\n             if( nums[i] *2  <= nums[j])\\n             {\\n                 i++ ; \\n                 j++ ;\\n\\n                 count = count+ 2 ; // kyonki pair mein indexes marked ho rahe hain , isliye count humesha \\n                 // 2 se badh rahi hai ;  \\n             }\\n             else\\n             {\\n                 j++ ; \\n             }\\n         }\\n\\n         return (int)count ; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n   \\n   the main problem of this question was , that  we want to increase the count of maximum marked index\\n   , now since 10^5 length h array ki , oth ye toh pakka h ki hum sorting karenge ; \\n\\n   // now , hum starting se iterate kar re hain , ab kaun se index wale ko uske saath pair kare , ye dikkat \\n   hai ( because marked humesha pair mein honge , becauae each time we have to take two unmarked index)\\n   and we have to marked them , and \\n\\n   ONE IMPORANT POINT IS THAT ANSWER WILL BE EVEN , MEANS COUNT OF MARKED INDEX WILL BE EVEN ( obviously \\n   because we are marking indexes in pairs ) , and THE MAXIMUM ANSWER CAN BE (N/2) BECAUSE USKE BAAD\\n   ELEMENT BACHENGE HI NAHI \\n\\n\\n   NOW THE Optimised way OF DOING QUESITNO IS \\n\\n   1. SORT THE ARRAY ; \\n\\n   2. DIVIDE THE ARRAY INTO TWO PARTS , AND DONO KE STARTING MEIN TWO POINTERS RAKEHNGE AND THEN\\n      COUNT GINNA SHURU KARENGE ; \\n\\n      ( JAB BHI PAIR MEIN INDEXES MEIN MARKED KARNA HO , KISI BHI REASON KE WAJAH SE ,TOH PHLE\\n      SORT KARENEGE , FIRST USKE BAAD MATCHING \\n      HUMESHA AISE HI HOGI , ARRAY KKO 2 PART MEIN DIVIDE KARENGE , FIR DO POINTER DONO KE STARTING\\n      MEIN RAKH DENGE , AUR FIR DEKHENGE )\\n*/\\n\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        \\n        \\n        Arrays.sort(nums) ;\\n\\n         int i = 0 ; \\n         int j = nums.length/2 ; \\n\\n          long count = 0 ;\\n\\n         while( i < nums.length/2 && j < nums.length)\\n         {\\n             if( nums[i] *2  <= nums[j])\\n             {\\n                 i++ ; \\n                 j++ ;\\n\\n                 count = count+ 2 ; // kyonki pair mein indexes marked ho rahe hain , isliye count humesha \\n                 // 2 se badh rahi hai ;  \\n             }\\n             else\\n             {\\n                 j++ ; \\n             }\\n         }\\n\\n         return (int)count ; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547370,
                "title": "simplest-python-solution-linear-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        ct=0\\n        rct=[i for i in range((n//2),n)]\\n        for i in range((n//2)-1,-1,-1):\\n            if rct:\\n                if nums[rct[-1]]>=2*nums[i]:\\n                    rct.pop()\\n                    ct+=2\\n                else:\\n                    rct.insert(0,i)\\n            else:\\n                rct.insert(0,i)\\n        return ct\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        ct=0\\n        rct=[i for i in range((n//2),n)]\\n        for i in range((n//2)-1,-1,-1):\\n            if rct:\\n                if nums[rct[-1]]>=2*nums[i]:\\n                    rct.pop()\\n                    ct+=2\\n                else:\\n                    rct.insert(0,i)\\n            else:\\n                rct.insert(0,i)\\n        return ct\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494167,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsliding window and sorting\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n       sort(nums.begin(),nums.end());\\n       int n= nums.size();\\n       int i =n/2-1;    //one pointer at middle of sorted array\\n       int j=n-1;       // another pointer at the end\\n       int ans=0;\\n       while(i>=0)\\n       {\\n           if(nums[j]>=nums[i]*2)\\n         {  \\n             ans+=2;\\n              --j;\\n         }\\n              i--;\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n       sort(nums.begin(),nums.end());\\n       int n= nums.size();\\n       int i =n/2-1;    //one pointer at middle of sorted array\\n       int j=n-1;       // another pointer at the end\\n       int ans=0;\\n       while(i>=0)\\n       {\\n           if(nums[j]>=nums[i]*2)\\n         {  \\n             ans+=2;\\n              --j;\\n         }\\n              i--;\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335079,
                "title": "c-sorting-two-pointers-faster-easy-to-understand",
                "content": "* ***Using Sorting && Two Pointers***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the nums\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // use two pointers\\n        \\n        int i = 0, j = n / 2;\\n        \\n        int count = 0;\\n        \\n        while(i < n / 2 && j < n)\\n        {\\n            if(2 * nums[i] <= nums[j])\\n            {\\n                count++;\\n                \\n                i++;\\n                \\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        \\n        return 2 * count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the nums\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // use two pointers\\n        \\n        int i = 0, j = n / 2;\\n        \\n        int count = 0;\\n        \\n        while(i < n / 2 && j < n)\\n        {\\n            if(2 * nums[i] <= nums[j])\\n            {\\n                count++;\\n                \\n                i++;\\n                \\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        \\n        return 2 * count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245332,
                "title": "scala-binary-search-recursion",
                "content": "# Code\\n```\\nobject Solution {\\n  def maxNumOfMarkedIndices(nums: Array[Int]): Int = {\\n    lazy val nsize = nums.size\\n    lazy val sorted = nums.sorted\\n    def check(k: Int): Boolean = (0 until k).forall{i => (2*sorted(i)) <= sorted(nsize-k+i)}\\n    def bs(lo: Int, hi: Int): Int = {\\n      lazy val mid = (hi+lo)/2\\n      if(lo+1>=hi) lo else if(check(mid)) bs(mid,hi) else bs(lo,mid)\\n    }\\n    if(check(nsize/2)) (nsize/2)*2 else bs(0,nsize/2)*2\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nobject Solution {\\n  def maxNumOfMarkedIndices(nums: Array[Int]): Int = {\\n    lazy val nsize = nums.size\\n    lazy val sorted = nums.sorted\\n    def check(k: Int): Boolean = (0 until k).forall{i => (2*sorted(i)) <= sorted(nsize-k+i)}\\n    def bs(lo: Int, hi: Int): Int = {\\n      lazy val mid = (hi+lo)/2\\n      if(lo+1>=hi) lo else if(check(mid)) bs(mid,hi) else bs(lo,mid)\\n    }\\n    if(check(nsize/2)) (nsize/2)*2 else bs(0,nsize/2)*2\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3240140,
                "title": "c-easy-to-understand-two-pointers",
                "content": "# Complexity\\n- Time complexity:  O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        int j = (nums.size())/2;\\n        while(i < nums.size()/2 and j < nums.size()) \\n        {\\n            if((2*nums[i]) <= nums[j])\\n            {\\n                count += 2;\\n                j++;\\n                i++;\\n            }\\n            else j++;\\n        }   \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        int j = (nums.size())/2;\\n        while(i < nums.size()/2 and j < nums.size()) \\n        {\\n            if((2*nums[i]) <= nums[j])\\n            {\\n                count += 2;\\n                j++;\\n                i++;\\n            }\\n            else j++;\\n        }   \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236042,
                "title": "using-two-pointers-easy-to-understand-with-explanation",
                "content": "# Intuition\\nTake two pointers one on 0th index and another on n/2th index where n = length of the array.\\nIterator till last index and check if the 2*(value of ith index) <= (value of jth index) then mark nums[j] as visited and increment both pointers by 1.\\nIf nums[i] is visited then increment i by 1\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N) where n = size of array\\n\\n- Space complexity:\\n- constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 0,i=0,j=nums.size()/2;\\n        while(j<nums.size()) {\\n            if(nums[i]==-1) {i+=1; continue;}\\n            if(nums[i]*2 <= nums[j]) {\\n                ans+=2;\\n                nums[j]=-1;\\n                i+=1; j+=1;\\n            }\\n            else {\\n                j+=1;\\n            }\\n        } return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 0,i=0,j=nums.size()/2;\\n        while(j<nums.size()) {\\n            if(nums[i]==-1) {i+=1; continue;}\\n            if(nums[i]*2 <= nums[j]) {\\n                ans+=2;\\n                nums[j]=-1;\\n                i+=1; j+=1;\\n            }\\n            else {\\n                j+=1;\\n            }\\n        } return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235431,
                "title": "java-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        \\n        int res = 0;\\n        Arrays.sort(nums);\\n\\n        // visited array to mark the indices we visited , so not to take the \\n        // same indices again\\n        boolean[] visited = new boolean[nums.length];\\n        for(int i = 0;i<nums.length/2;i++)\\n        {\\n            int target = 2 * nums[i];\\n            if(binarySearch(nums, target , i/2 , nums.length-1, visited))\\n                res+=2;\\n        }\\n\\n        return res;\\n    }\\n  \\n    boolean binarySearch(int [] nums , int target , int start , int end, boolean [] visited)\\n    {\\n\\n        boolean found = false;\\n        int index = -1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target <= nums[mid] && !visited[mid]) {\\n                found = true;\\n                index = mid;\\n                end = mid - 1;\\n\\n            } else {\\n                start = mid + 1;\\n            }\\n\\n        }\\n\\n\\n        if (found)\\n            visited[index] = true;\\n\\n        return found;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        \\n        int res = 0;\\n        Arrays.sort(nums);\\n\\n        // visited array to mark the indices we visited , so not to take the \\n        // same indices again\\n        boolean[] visited = new boolean[nums.length];\\n        for(int i = 0;i<nums.length/2;i++)\\n        {\\n            int target = 2 * nums[i];\\n            if(binarySearch(nums, target , i/2 , nums.length-1, visited))\\n                res+=2;\\n        }\\n\\n        return res;\\n    }\\n  \\n    boolean binarySearch(int [] nums , int target , int start , int end, boolean [] visited)\\n    {\\n\\n        boolean found = false;\\n        int index = -1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target <= nums[mid] && !visited[mid]) {\\n                found = true;\\n                index = mid;\\n                end = mid - 1;\\n\\n            } else {\\n                start = mid + 1;\\n            }\\n\\n        }\\n\\n\\n        if (found)\\n            visited[index] = true;\\n\\n        return found;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233411,
                "title": "c-and-python-beats-100-most-efficient-solution-sorting-two-pointers",
                "content": "\\n\\n# Code\\n**C++ Solution:-**\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        int i = 0;\\n        int j = n / 2;\\n        int ans = 0;\\n        while (i < n/2 && j < n) {\\n            if (2 * nums[i] <= nums[j]) {\\n                ans += 2;\\n                i++;\\n                j++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Python Solution:-**\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        i = 0\\n        j = n // 2\\n        ans = 0\\n        while i < n//2 and j < n:\\n            if 2*nums[i] <= nums[j]:\\n                ans += 2\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        int i = 0;\\n        int j = n / 2;\\n        int ans = 0;\\n        while (i < n/2 && j < n) {\\n            if (2 * nums[i] <= nums[j]) {\\n                ans += 2;\\n                i++;\\n                j++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        i = 0\\n        j = n // 2\\n        ans = 0\\n        while i < n//2 and j < n:\\n            if 2*nums[i] <= nums[j]:\\n                ans += 2\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233039,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def maxNumOfMarkedIndices(nums: Array[Int]): Int = {\\n        def help(leftSorted: Array[Int], rigthSorted: Array[Int], res: Int): Int = (leftSorted, rigthSorted) match {\\n            case (l, r) if(l.isEmpty || r.isEmpty) => res\\n            case (l, r) if(l(0) * 2 <= r(0)) => help(l.tail, r.tail, res + 2)\\n            case (l, r) => help(l, r.tail, res)\\n        }\\n\\n        val (leftSorted, rigthSorted) = nums.sorted.splitAt(nums.length / 2)\\n        help(leftSorted, rigthSorted, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maxNumOfMarkedIndices(nums: Array[Int]): Int = {\\n        def help(leftSorted: Array[Int], rigthSorted: Array[Int], res: Int): Int = (leftSorted, rigthSorted) match {\\n            case (l, r) if(l.isEmpty || r.isEmpty) => res\\n            case (l, r) if(l(0) * 2 <= r(0)) => help(l.tail, r.tail, res + 2)\\n            case (l, r) => help(l, r.tail, res)\\n        }\\n\\n        val (leftSorted, rigthSorted) = nums.sorted.splitAt(nums.length / 2)\\n        help(leftSorted, rigthSorted, 0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3232764,
                "title": "two-pointers",
                "content": "## Why include the middle element in the 1st half\\nFor the people confused why mid is in the first part:\\nWe know that the condition: nums[firstElement]<=2*nums[secondElement] will hold true for all elements to the right of second element:\\nfor example:\\n[1,2,3] => if 12<=2 (indices 0,1), which is true\\nit will also be true for 12<=3, (indices 0,2)\\n\\nThus we can say if we choose to include in the middle we cancel the possibility that:\\nnums[mid]<=nums[lastElement]\\n\\nNow consider this possibility existed, we will never mark it as the middle element is a part of our second half.\\nBut if we kept it as a part of our 1st half we will be able to make a pair of this with the last element:(mid,lastIndex)\\nNow what happened to the index for which mid satisfied the condition: i.e. nums[smallerIndex]*2<=nums[mid]; it can still be marked with indexes greater than mid;\\nsay nums[smallerIndex]>*2<=nums[mid+1] (mid+1 is just for demonstration here, any index with a value greater than mid could be paired with the smaller index as they all are greater than the smaller index).\\n\\nHope I was properly able to explain the reason why we take 1st half as [0, mid] and 2nd half as (mid,lastIndex]\\n\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        nums.sort()\\n        for j in range(n//2,n):\\n            i+= nums[j]>=nums[i]*2\\n        return i*2\\n```\\nSolution credits: @votrubac\\n\\n**Example**:\\n```\\nIf n= 5\\nN//2 or n-n//2\\n2 or 5-2=3\\n\\n----v\\n0 1 2 3 4. [indexes of an array of length 5]\\n------^\\nseparate as :\\n{0,1,2} and {3,4}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        nums.sort()\\n        for j in range(n//2,n):\\n            i+= nums[j]>=nums[i]*2\\n        return i*2\\n```\n```\\nIf n= 5\\nN//2 or n-n//2\\n2 or 5-2=3\\n\\n----v\\n0 1 2 3 4. [indexes of an array of length 5]\\n------^\\nseparate as :\\n{0,1,2} and {3,4}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232686,
                "title": "kotlin-sorting-two-pointers-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxNumOfMarkedIndices(nums: IntArray): Int {    \\n        nums.sort()    \\n        var count = 0\\n        var i = 0\\n        var j = nums.size / 2\\n\\n        while(j < nums.size && i < nums.size / 2) {\\n            if(nums[i] * 2 <= nums[j]) {\\n                count+=2\\n                i++\\n                j++\\n            } else {\\n                j++\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun maxNumOfMarkedIndices(nums: IntArray): Int {    \\n        nums.sort()    \\n        var count = 0\\n        var i = 0\\n        var j = nums.size / 2\\n\\n        while(j < nums.size && i < nums.size / 2) {\\n            if(nums[i] * 2 <= nums[j]) {\\n                count+=2\\n                i++\\n                j++\\n            } else {\\n                j++\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232532,
                "title": "go-python-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc maxNumOfMarkedIndices(nums []int) int {\\n    n := len(nums)\\n    sort.Ints(nums)\\n    answer := 0\\n    i := n / 2 - 1\\n    j := n - 1\\n    for i >= 0{\\n        if nums[i] * 2 <= nums[j]{\\n            answer+=2\\n            j--\\n        }\\n        i--\\n    }\\n    return answer\\n}\\n```\\n```python []\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        answer = 0\\n        i = n // 2 - 1\\n        j = n - 1\\n        while i >= 0:\\n            if nums[i] * 2 <= nums[j]:\\n                answer+=2\\n                j-=1\\n            i-=1\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Two Pointers",
                    "Greedy",
                    "Sort"
                ],
                "code": "```golang []\\nfunc maxNumOfMarkedIndices(nums []int) int {\\n    n := len(nums)\\n    sort.Ints(nums)\\n    answer := 0\\n    i := n / 2 - 1\\n    j := n - 1\\n    for i >= 0{\\n        if nums[i] * 2 <= nums[j]{\\n            answer+=2\\n            j--\\n        }\\n        i--\\n    }\\n    return answer\\n}\\n```\n```python []\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        answer = 0\\n        i = n // 2 - 1\\n        j = n - 1\\n        while i >= 0:\\n            if nums[i] * 2 <= nums[j]:\\n                answer+=2\\n                j-=1\\n            i-=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232472,
                "title": "two-pointers-o-nlogn-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor an array of size n there will be exactly n/2 pairs, so we\\'ve divided the array into two halves and compared the left half with right half.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array and take 2 pointers i and j and place it at index 0 and n/2 respectively.\\nNow we\\'ll check for the condition i.e 2*nums[i] <= nums[j] and if satisfied, we\\'ll move forward and check for other numbers. If not then we keep on finding the pair for the current element nums[i].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int j = n/2;\\n        int cnt = 0;\\n        while(i < n/2 and j < n){\\n            if(2*nums[i] <= nums[j]){\\n                i++;\\n                j++;\\n                cnt+=2;\\n            } else{\\n                j++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int j = n/2;\\n        int cnt = 0;\\n        while(i < n/2 and j < n){\\n            if(2*nums[i] <= nums[j]){\\n                i++;\\n                j++;\\n                cnt+=2;\\n            } else{\\n                j++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232366,
                "title": "java-easy-solution-beats-100",
                "content": "# Intuition\\nSorting and TWo Pointers,constant space\\n\\n# Approach\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }\\n           j++;\\n        } \\n\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }\\n           j++;\\n        } \\n\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231193,
                "title": "simply-sort-the-array-and-divide-it-into-two-halves",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int j=nums.size()-1;\\n        int c=0;\\n        int i=0;\\n        for(int i=nums.size()/2-1;i>=0;i--)\\n        {\\n            if(nums[i]*2<=nums[j])\\n            {\\n                c+=2;\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int j=nums.size()-1;\\n        int c=0;\\n        int i=0;\\n        for(int i=nums.size()/2-1;i>=0;i--)\\n        {\\n            if(nums[i]*2<=nums[j])\\n            {\\n                c+=2;\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231134,
                "title": "two-pointer-sorting-tc-o-nlogn-sc-o-1",
                "content": "# Approach\\nThe given problem requires us to find the maximum number of indices we can mark in the input array nums. To mark an index, we need to select two different unmarked indices i and j such that 2*nums[i] <= nums[j].\\n\\nThe given solution uses two pointers to solve this problem. First, we sort the input array in ascending order. We then initialize two pointers i and j. The pointer i starts at the beginning of the array, and the pointer j starts at the middle of the array.\\n\\nThe condition for finding a suitable index pair (i,j) is nums[i]*2 <= nums[j]. When we find such a pair, we increment the counter cnt by 2, as we can mark both i and j. Finally, we increment the pointer j and move to the next index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end()); // sort the input array\\n        int j = n/2; // initialize pointer j to middle of the array\\n        int cnt = 0; // initialize counter to 0\\n        for(int i=0; i<n/2 && j<n; i++) { // loop over the array using pointer i until the middle index\\n            while(j<n && nums[i]*2 > nums[j]) { // try to find a suitable index j using a nested loop\\n                j++; // increment j until a suitable index is found\\n            }\\n            if(j<n) cnt += 2; // increment the counter by 2 as we can mark both i and j\\n            j++; // move to the next index\\n        }\\n        return cnt; // return the maximum number of marked indices\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end()); // sort the input array\\n        int j = n/2; // initialize pointer j to middle of the array\\n        int cnt = 0; // initialize counter to 0\\n        for(int i=0; i<n/2 && j<n; i++) { // loop over the array using pointer i until the middle index\\n            while(j<n && nums[i]*2 > nums[j]) { // try to find a suitable index j using a nested loop\\n                j++; // increment j until a suitable index is found\\n            }\\n            if(j<n) cnt += 2; // increment the counter by 2 as we can mark both i and j\\n            j++; // move to the next index\\n        }\\n        return cnt; // return the maximum number of marked indices\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231056,
                "title": "how-to-think-for-initialization-of-pointers-intuition-of-2-pointers-explained-o-nlogn-n",
                "content": "# Idea\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- See looking at prob, if they suppose mentioned that we can use marked multiple times then all we need to do is to take max ele and compare how many nums[i]*2 <= max ele\\n- But here we cannnot reuse\\n- so technically speaking we need to keep i at 0 and j at half of array\\n- Why ? See at max we can mark All elements ANS is N\\n- For that we need to pair 0 with half, 1 with half+1, .... half-1 with N-1\\n- So we keep pointers that way like i=0 and j= (N+1)/2\\n- So at max we can get N/2 pairs, so we always do j++, doesnt matter used or not.\\n- Whereas i is like the border for CONDITION VALID. As ARR is sorted, if Arr[i] is marked then Arr[0...i-1] should ofcourse have a pair, without which it cant exist.\\n-  At last i*2 is the tot nos of elements\\n- because every i has a unique j at that end\\n\\n# Complexity\\n- Time complexity:$$O(NLogN + N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); // sort the array in non-decreasing order\\n        int n = nums.size();\\n        int i = 0, j = (n+1)/2;\\n        int ctr = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) { \\n                i++; \\n            }\\n            j++; \\n        }\\n        return i*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); // sort the array in non-decreasing order\\n        int n = nums.size();\\n        int i = 0, j = (n+1)/2;\\n        int ctr = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) { \\n                i++; \\n            }\\n            j++; \\n        }\\n        return i*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231040,
                "title": "o-nlogn-java",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n\\n        int end = n - 1;\\n        int ans = 0;\\n\\n        for (int i = (n / 2) - 1; i >= 0; i--) {\\n            if (nums[i] * 2 <= nums[end]) {\\n                ans += 2;\\n                nums[i] = -1;\\n                nums[end] = -1;\\n            }\\n\\n            while (end >= 0 && nums[end] == -1) end--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n\\n        int end = n - 1;\\n        int ans = 0;\\n\\n        for (int i = (n / 2) - 1; i >= 0; i--) {\\n            if (nums[i] * 2 <= nums[end]) {\\n                ans += 2;\\n                nums[i] = -1;\\n                nums[end] = -1;\\n            }\\n\\n            while (end >= 0 && nums[end] == -1) end--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231028,
                "title": "easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        int j=nums.size()-1;\\n        int ans=0;\\n        for(int i=(nums.size()/2)-1;i>=0;i--){\\n            if(nums[i]*2<=nums[j]){\\n                ans+=2;\\n                j--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        int j=nums.size()-1;\\n        int ans=0;\\n        for(int i=(nums.size()/2)-1;i>=0;i--){\\n            if(nums[i]*2<=nums[j]){\\n                ans+=2;\\n                j--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230962,
                "title": "easiest-way",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int s = 0;\\n        int e = (n+1)/2;\\n        \\n        while(e<n){\\n            if(2 * nums[s] <= nums[e])\\n                s++;\\n            e++;\\n        }\\n        return s*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int s = 0;\\n        int e = (n+1)/2;\\n        \\n        while(e<n){\\n            if(2 * nums[s] <= nums[e])\\n                s++;\\n            e++;\\n        }\\n        return s*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230911,
                "title": "multiset-easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        multiset<int>s;\\n        for(int i=n/2; i<n; i++) s.insert(v[i]);\\n        for(int i=v.size()/2-1; i>=0; i--) {\\n            auto up=s.lower_bound(v[i]*2);\\n            if(up!=s.end()){\\n                ans+=2;\\n                s.erase(up);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        multiset<int>s;\\n        for(int i=n/2; i<n; i++) s.insert(v[i]);\\n        for(int i=v.size()/2-1; i>=0; i--) {\\n            auto up=s.lower_bound(v[i]*2);\\n            if(up!=s.end()){\\n                ans+=2;\\n                s.erase(up);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230895,
                "title": "greedy-two-pointers-pair-smaller-half-to-larger-half",
                "content": "Sort the numbers, use two pointers, left at the n // 2 - 1, right at n - 1. Greedily pair left pointed to the right pointed. If a left pointed unmatchable, skip it and try matching [left - 1] to [right].\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        # ans = 0\\n        \\n        # print(n, nums)\\n        # print(nums[:n//2])\\n        \\n        marked = [0] * n\\n        \\n        j = n - 1\\n        for i in range(n // 2 - 1, -1, -1):\\n            if marked[i]:\\n                continue\\n            found = 1\\n            while marked[j]:\\n                j -= 1\\n                if j == i:\\n                    found = 0\\n                    break\\n            if not found:\\n                continue\\n            if nums[i] * 2 <= nums[j]:\\n                marked[i] = marked[j] = 1\\n                j -= 1\\n        \\n        return sum(marked)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        # ans = 0\\n        \\n        # print(n, nums)\\n        # print(nums[:n//2])\\n        \\n        marked = [0] * n\\n        \\n        j = n - 1\\n        for i in range(n // 2 - 1, -1, -1):\\n            if marked[i]:\\n                continue\\n            found = 1\\n            while marked[j]:\\n                j -= 1\\n                if j == i:\\n                    found = 0\\n                    break\\n            if not found:\\n                continue\\n            if nums[i] * 2 <= nums[j]:\\n                marked[i] = marked[j] = 1\\n                j -= 1\\n        \\n        return sum(marked)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230851,
                "title": "easy-clean-c",
                "content": "# Intuition\\nTwo Pointer\\n\\n# Approach\\nWe can sort the array and count the number of good pairs using two pointers in linear time.\\n\\n1. We keep the first pointer at the beginning of the sorted array (as we have to start taking first element of pairs from minimum).\\n\\n2. We keep the second pointer after half of the sorted array, as the maximum good pairs we can get will be half of the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(c)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size(), result = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        if(n == 1)return 0;\\n        \\n        \\n        int first = 0, last = (n + 1) / 2; // we only need to start taking second element of pairs after half of \\n                                           // the array, as maximum number of good pairs will be n / 2\\n        \\n        while(last < n)\\n        {\\n            if(2 * nums[first] <= nums[last])\\n            {\\n                result++; // counting number of good pairs\\n                first++;\\n            }\\n            \\n            last++;\\n        }\\n        \\n        return result * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size(), result = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        if(n == 1)return 0;\\n        \\n        \\n        int first = 0, last = (n + 1) / 2; // we only need to start taking second element of pairs after half of \\n                                           // the array, as maximum number of good pairs will be n / 2\\n        \\n        while(last < n)\\n        {\\n            if(2 * nums[first] <= nums[last])\\n            {\\n                result++; // counting number of good pairs\\n                first++;\\n            }\\n            \\n            last++;\\n        }\\n        \\n        return result * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230849,
                "title": "easy-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int end = n-1;\\n        int start = 0;\\n        \\n        int mid = start+(end-start)/2;\\n        int i = 0, j = mid+1;\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        while(i <= mid && j < n){\\n            if((i != j) && (2*nums[i] <= nums[j])){\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        int ans = cnt*2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int end = n-1;\\n        int start = 0;\\n        \\n        int mid = start+(end-start)/2;\\n        int i = 0, j = mid+1;\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        while(i <= mid && j < n){\\n            if((i != j) && (2*nums[i] <= nums[j])){\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        int ans = cnt*2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230843,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=(nums.length+1)>>1;\\n        int low=0;\\n        int cnt=0;\\n        while(mid<nums.length){\\n            if(nums[mid]>=((nums[low])<<1)){\\n                low++;\\n                cnt+=2;\\n            }\\n            mid++;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/af01dab1-431d-4e1d-9173-0adfb3c8cfed_1677384132.5504675.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=(nums.length+1)>>1;\\n        int low=0;\\n        int cnt=0;\\n        while(mid<nums.length){\\n            if(nums[mid]>=((nums[low])<<1)){\\n                low++;\\n                cnt+=2;\\n            }\\n            mid++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230804,
                "title": "c-two-pointer-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        int mid = (nums.size())/2;\\n        int j = mid;\\n        int count = 0;\\n        while(i<mid and j<nums.size())\\n        {\\n            if((2*nums[i])<=nums[j])\\n            {\\n                i++;\\n                j++;\\n                count+=2;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        int mid = (nums.size())/2;\\n        int j = mid;\\n        int count = 0;\\n        while(i<mid and j<nums.size())\\n        {\\n            if((2*nums[i])<=nums[j])\\n            {\\n                i++;\\n                j++;\\n                count+=2;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230776,
                "title": "easiest-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int st=0;\\n        int mid=(n+1)/2;\\n        while(mid<n){\\n            if(nums[st]*2<=nums[mid]) st++;\\n            mid++;\\n        }\\n        return st*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int st=0;\\n        int mid=(n+1)/2;\\n        while(mid<n){\\n            if(nums[st]*2<=nums[mid]) st++;\\n            mid++;\\n        }\\n        return st*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072720,
                "title": "simplest-java-solution-100-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n\\n        // int count = 0 ;\\n\\n        // for ( int i = 0 ; i < nums.length ; i ++){\\n            \\n        // for ( int j=i ; j < nums.length ; j ++){\\n\\n        //     if(2 * nums[i] <= nums[j]){\\n        //         count += 2 ;\\n        //     }\\n            \\n        // }\\n        // }\\n        \\n        // return count ;\\n\\n\\n       int n = nums.length ;\\n\\n       Arrays.sort(nums);\\n       int ans = 0 ;\\n       int strt = 0 ; \\n       int mid = (n+1)/2;\\n\\n       while(mid<n){\\n           if(2 * nums[strt] <= nums[mid]){\\n               strt++;\\n               ans += 2;\\n           }\\n\\n           mid++;\\n       }\\n\\n\\n     return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n\\n        // int count = 0 ;\\n\\n        // for ( int i = 0 ; i < nums.length ; i ++){\\n            \\n        // for ( int j=i ; j < nums.length ; j ++){\\n\\n        //     if(2 * nums[i] <= nums[j]){\\n        //         count += 2 ;\\n        //     }\\n            \\n        // }\\n        // }\\n        \\n        // return count ;\\n\\n\\n       int n = nums.length ;\\n\\n       Arrays.sort(nums);\\n       int ans = 0 ;\\n       int strt = 0 ; \\n       int mid = (n+1)/2;\\n\\n       while(mid<n){\\n           if(2 * nums[strt] <= nums[mid]){\\n               strt++;\\n               ans += 2;\\n           }\\n\\n           mid++;\\n       }\\n\\n\\n     return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060325,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length; \\n        Arrays.sort(nums);\\n\\n        int i = (n/2)-1;\\n        int j = n-1;\\n        int count = 0;\\n\\n        while(i >= 0) {\\n\\n           if(nums[i]*2 <= nums[j]) {\\n               count += 2;\\n               j--;\\n               i--;\\n\\n           } else if(nums[i]*2 > nums[j]){\\n               i--;\\n           } else {\\n               i--;\\n               j--;\\n           }\\n\\n        }\\n\\n\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length; \\n        Arrays.sort(nums);\\n\\n        int i = (n/2)-1;\\n        int j = n-1;\\n        int count = 0;\\n\\n        while(i >= 0) {\\n\\n           if(nums[i]*2 <= nums[j]) {\\n               count += 2;\\n               j--;\\n               i--;\\n\\n           } else if(nums[i]*2 > nums[j]){\\n               i--;\\n           } else {\\n               i--;\\n               j--;\\n           }\\n\\n        }\\n\\n\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997351,
                "title": "easy-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst sort the array and then use Two pointer method \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        if(nums.size()%2==0)\\n        {\\n            i=(nums.size()/2)-1;\\n        }\\n        else{\\n            i=nums.size()/2;\\n        }\\n        int t=i;\\n        int j=nums.size()-1;\\n        int cnt=0;\\n        while(i>=0 && j>t)\\n        {\\n            if(2*nums[i]<=nums[j])\\n            {\\n                i--;\\n                j--;\\n                cnt=cnt+2;\\n            }\\n            else if(2*nums[i]>nums[j]){\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        if(nums.size()%2==0)\\n        {\\n            i=(nums.size()/2)-1;\\n        }\\n        else{\\n            i=nums.size()/2;\\n        }\\n        int t=i;\\n        int j=nums.size()-1;\\n        int cnt=0;\\n        while(i>=0 && j>t)\\n        {\\n            if(2*nums[i]<=nums[j])\\n            {\\n                i--;\\n                j--;\\n                cnt=cnt+2;\\n            }\\n            else if(2*nums[i]>nums[j]){\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987006,
                "title": "java-simple-solution-using-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        int i = 0, j = len - len / 2;\\n\\n        while(j < len){\\n            if(2 * nums[i] <= nums[j]){\\n                i++;\\n            }\\n            j++;\\n        }\\n        return 2 * i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        int i = 0, j = len - len / 2;\\n\\n        while(j < len){\\n            if(2 * nums[i] <= nums[j]){\\n                i++;\\n            }\\n            j++;\\n        }\\n        return 2 * i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969139,
                "title": "java-strategic-pointer-manipulation-beats-97",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int i = 0, j = nums.length/2;\\n        while(i < nums.length/2 && j < nums.length){\\n            if(2*nums[i] <= nums[j]){\\n                count+=2;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Please upvote if you liked the solution \\u263A\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int i = 0, j = nums.length/2;\\n        while(i < nums.length/2 && j < nums.length){\\n            if(2*nums[i] <= nums[j]){\\n                count+=2;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968018,
                "title": "simple-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int c =0, j = nums.length-1;\\n        for(int i=nums.length/2 -1; i>=0;i--){\\n            if(nums[i] <= nums[j]/2 ) {\\n                c += 2;\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int c =0, j = nums.length-1;\\n        for(int i=nums.length/2 -1; i>=0;i--){\\n            if(nums[i] <= nums[j]/2 ) {\\n                c += 2;\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944119,
                "title": "simple-4-steps-javascript-beginner-approach-using-greedy-fully-explained",
                "content": "# Approach\\nStep 1: Sort the Array in ascending order(Non decreasing order)\\n\\nStep 2: Find the index of the mid of the array and add +1 so we are going to traverse from the second half of the array....\\n\\nStep3: if the first element of the first half of the array is less than the second element of the first half of the array then increment the count...\\n\\nStep 4: After traversing, Multiply count with 2 to mark the second half of the array and return the count.\\n\\n# UPVOTE IS APPRECIATED!!\\n# Complexity\\n- Time complexity: O(logn)\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n    var count=0;\\n    nums.sort((a,b)=>a-b);\\n    var len=nums.length;\\n    var mid=Math.floor((nums.length+1)/2);\\n    while(mid<len){\\n        if((nums[count]*2)<=nums[mid]){\\n            count++;\\n        }\\n        mid++;\\n    }\\n    return count*2;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n    var count=0;\\n    nums.sort((a,b)=>a-b);\\n    var len=nums.length;\\n    var mid=Math.floor((nums.length+1)/2);\\n    while(mid<len){\\n        if((nums[count]*2)<=nums[mid]){\\n            count++;\\n        }\\n        mid++;\\n    }\\n    return count*2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931170,
                "title": "solution-using-sorting-and-two-pointers-rust-tm",
                "content": "# Code\\n```\\n// use std::collections::HashSet;\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(nums: Vec<i32>) -> i32 {\\n        // Pick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j\\n        let mut temp_nums: Vec<i32> = nums.to_vec();\\n        let mut count: i32 = 0; \\n        temp_nums.sort_by(|a,b| a.cmp(b));\\n        let mut l: usize = 0;\\n        let mut r: usize = temp_nums.len()/2;\\n        // let mut idx_set: HashSet<usize> = HashSet::new();\\n        // println!(\"l:{},r:{}\\\\n{:?}\", l, r, temp_nums);\\n        while l < (temp_nums.len()/2) && r < temp_nums.len() {\\n            // if idx_set.contains(&l) {\\n            //     break;\\n            // }\\n            // println!(\"{:?}\", idx_set);\\n            let first_val: i32 = temp_nums[l] * 2;\\n            let second_val: i32 = temp_nums[r];\\n            // println!(\"l:{},r:{},1:{},2:{}\", l, r, first_val, second_val);\\n            if first_val <= second_val {\\n                count += 2;\\n                // idx_set.insert(r);\\n                l += 1;\\n                r += 1;\\n                continue;\\n            }\\n            r += 1;\\n        }\\n        // println!(\"{:?}\", idx_set);\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// use std::collections::HashSet;\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(nums: Vec<i32>) -> i32 {\\n        // Pick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j\\n        let mut temp_nums: Vec<i32> = nums.to_vec();\\n        let mut count: i32 = 0; \\n        temp_nums.sort_by(|a,b| a.cmp(b));\\n        let mut l: usize = 0;\\n        let mut r: usize = temp_nums.len()/2;\\n        // let mut idx_set: HashSet<usize> = HashSet::new();\\n        // println!(\"l:{},r:{}\\\\n{:?}\", l, r, temp_nums);\\n        while l < (temp_nums.len()/2) && r < temp_nums.len() {\\n            // if idx_set.contains(&l) {\\n            //     break;\\n            // }\\n            // println!(\"{:?}\", idx_set);\\n            let first_val: i32 = temp_nums[l] * 2;\\n            let second_val: i32 = temp_nums[r];\\n            // println!(\"l:{},r:{},1:{},2:{}\", l, r, first_val, second_val);\\n            if first_val <= second_val {\\n                count += 2;\\n                // idx_set.insert(r);\\n                l += 1;\\n                r += 1;\\n                continue;\\n            }\\n            r += 1;\\n        }\\n        // println!(\"{:?}\", idx_set);\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876028,
                "title": "the-optimal-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j= (n+1)/2;\\n        int ans = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) {\\n                i++;\\n                ans += 2;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j= (n+1)/2;\\n        int ans = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) {\\n                i++;\\n                ans += 2;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821460,
                "title": "c-sort",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) -> N= number of elements in nums\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int left=0,sz = nums.size(),right=(sz+1)/2,ans=0;\\n        while (left < sz/2 && right<sz){\\n            if (2*nums[left] <= nums[right]) {\\n                left++;\\n                right++;\\n                ans+=2;\\n            }\\n            else right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int left=0,sz = nums.size(),right=(sz+1)/2,ans=0;\\n        while (left < sz/2 && right<sz){\\n            if (2*nums[left] <= nums[right]) {\\n                left++;\\n                right++;\\n                ans+=2;\\n            }\\n            else right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782143,
                "title": "simple-c-solution-2-pointer",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int left=0,right;\\n        int n=nums.size()/2;\\n        right=n;\\n        int count=0;\\n        while(right<nums.size() and left<n){\\n            if(2*nums[left]>nums[right])right++;\\n            else{\\n                left++;\\n                right++;\\n                count+=2;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int left=0,right;\\n        int n=nums.size()/2;\\n        right=n;\\n        int count=0;\\n        while(right<nums.size() and left<n){\\n            if(2*nums[left]>nums[right])right++;\\n            else{\\n                left++;\\n                right++;\\n                count+=2;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758702,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }\\n           j++;\\n        } \\n\\n        return counter;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }\\n           j++;\\n        } \\n\\n        return counter;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723402,
                "title": "sorting-two-pointer-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=(n+1)/2;\\n        while(j<n)\\n        {\\n            if(2*nums[i]<=nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else j++;\\n        }\\n        return 2*count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=(n+1)/2;\\n        while(j<n)\\n        {\\n            if(2*nums[i]<=nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else j++;\\n        }\\n        return 2*count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718377,
                "title": "two-pointer-with-sorting-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let l = 0, r = nums.length - 1;\\n    let mid = Math.floor((l + r)/2);\\n    let ans = 0;\\n    const curMid = mid;\\n    while (mid >= 0 && curMid < r) {\\n        if (nums[mid] * 2 <= nums[r]) {\\n            ans+=2;\\n            r--;\\n        }\\n        mid--;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let l = 0, r = nums.length - 1;\\n    let mid = Math.floor((l + r)/2);\\n    let ans = 0;\\n    const curMid = mid;\\n    while (mid >= 0 && curMid < r) {\\n        if (nums[mid] * 2 <= nums[r]) {\\n            ans+=2;\\n            r--;\\n        }\\n        mid--;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3639231,
                "title": "simple-python-with-sorting",
                "content": "\\n\\n# Code\\n```\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        m = n // 2\\n        i = 0\\n        j = m\\n        c = 0\\n        while i < m and j < n:\\n            if 2 * nums[i] <= nums[j]:\\n                c += 2\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n\\n        return c\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        m = n // 2\\n        i = 0\\n        j = m\\n        c = 0\\n        while i < m and j < n:\\n            if 2 * nums[i] <= nums[j]:\\n                c += 2\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n\\n        return c\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3572776,
                "title": "c-simple-solution-must-check-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnlog(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int i = 0; int j = n/2;\\n        int jj = j;\\n        int cnt = 0;\\n        while(i<jj && j<n)\\n        {\\n            if(2 * nums[i] <= nums[j])\\n            {\\n                cnt += 2;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int i = 0; int j = n/2;\\n        int jj = j;\\n        int cnt = 0;\\n        while(i<jj && j<n)\\n        {\\n            if(2 * nums[i] <= nums[j])\\n            {\\n                cnt += 2;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526851,
                "title": "c-python-greedy-solution-with-explanation",
                "content": "we can use the first k smallest numbers to match the first k largest numbers, and count how many pairs are matched.\\n\\ntc is O(nlogn), sc is O(1)\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        for (int j = (nums.size() + 1) / 2; j < nums.size(); j+=1) {\\n            if (2 * nums[i] <= nums[j]) i += 1;\\n        }\\n        return 2 * i;\\n    }\\n};\\n```\\n\\n### python\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        for j in range((len(nums) + 1)// 2, len(nums)):\\n            if nums[i] * 2 <= nums[j]: i+=1\\n        return 2 * i\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        for (int j = (nums.size() + 1) / 2; j < nums.size(); j+=1) {\\n            if (2 * nums[i] <= nums[j]) i += 1;\\n        }\\n        return 2 * i;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        for j in range((len(nums) + 1)// 2, len(nums)):\\n            if nums[i] * 2 <= nums[j]: i+=1\\n        return 2 * i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492253,
                "title": "two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- sort the array\\n- if nums[i]*2<=nums[j] then nums[i]*2<=nums[k] when k<=j\\n- therefore we just need to count the valid number of i\\n- break when either i==nums.size()/2 or j==nums.size()/2\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(int i=0,j=1; i<nums.size()/2;i++){\\n            while(j<nums.size() and nums[j]<nums[i]*2) j++;\\n            if(j<nums.size()){\\n                cnt+=2;\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(int i=0,j=1; i<nums.size()/2;i++){\\n            while(j<nums.size() and nums[j]<nums[i]*2) j++;\\n            if(j<nums.size()){\\n                cnt+=2;\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477856,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUSING SORTING ALGORITHM \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int i=0;\\n        int j=(nums.size()+1)/2;\\n        int mx=0;\\n        sort(nums.begin(),nums.end());\\n       while(j<nums.size()){\\n            if(2*nums[i]<=nums[j]){\\n               mx++;\\n               i++;\\n              \\n            \\n            }\\n            j++;\\n        }\\n        return mx*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int i=0;\\n        int j=(nums.size()+1)/2;\\n        int mx=0;\\n        sort(nums.begin(),nums.end());\\n       while(j<nums.size()){\\n            if(2*nums[i]<=nums[j]){\\n               mx++;\\n               i++;\\n              \\n            \\n            }\\n            j++;\\n        }\\n        return mx*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473205,
                "title": "divide-the-arr-in-half-part-and-calculate-easy-and-simple-way-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int len = nums.size();\\n        int mid =(len+1)/2;\\n        int res=0;\\n        int i=0, j=mid; \\n        while(j<len){\\n            if(nums[j] >= 2*nums[i]) {\\n                res++;\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n\\n        return 2*res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int len = nums.size();\\n        int mid =(len+1)/2;\\n        int res=0;\\n        int i=0, j=mid; \\n        while(j<len){\\n            if(nums[j] >= 2*nums[i]) {\\n                res++;\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n\\n        return 2*res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404775,
                "title": "java-easy-approach-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDivide array into half and take smallest of both array and check for condition. if condition satisfies increment both index else increment only greater value index \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int mid=(nums.length+1)/2;\\n        int l=0;\\n        int count=0;\\n        int r=mid;\\n        while(r<=nums.length-1){\\n            if((nums[l]*2)<=nums[r]){\\n                count=count+2;\\n                l=l+1;\\n                r=r+1;\\n            }\\n            else{\\n\\n                r=r+1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int mid=(nums.length+1)/2;\\n        int l=0;\\n        int count=0;\\n        int r=mid;\\n        while(r<=nums.length-1){\\n            if((nums[l]*2)<=nums[r]){\\n                count=count+2;\\n                l=l+1;\\n                r=r+1;\\n            }\\n            else{\\n\\n                r=r+1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402127,
                "title": "sort-and-greedily-simply-matching-python",
                "content": "```\\n\"\"\"\\nTreatment: queue ADT\\n\\nIdea: we try to pair smaller numbers in the list with large ones (larger means 2 * small <= large)\\nObs: if the n = len(nums), then there are at most n // 2 matching pairs.\\n\\nWith the above Idea and Obs, we can use the following steps:\\n\\nAlgorithm/Steps:\\n\\nstep-0 sort the list nums from small to large and retrieve its length n\\nstep-1 use the first n//2 elements to check matching larger elements\\n       Let q1 = nums[:n//2]; q2 = nums[n//2:]\\n       for each element y in q1 (note these elements are from small to larger),\\n       we pop from q2 the elements that are not large enough, i.e., < 2 * y.\\n       If q2 is empty, it means no match, we just return the counting of pairs\\n       Else: q2[0] >= 2 * y, so we pop it to match y, increment the counting by 2 (= 1 pair)\\nstep-2 return the counting\\n       \\nEx-2. nums = [9,2,5,4] => sort => nums=[2, 4, 5, 9] => q1=[2, 4]; q2=[5, 9].\\n=> use 4 to match 2, and 9 to match 4, so the final result is 4.\\n\\nNote: we donot use 9 to match 2 though it can, b/c 5 can not match 4. This note\\njustified the soundness of the above algorithm.\\n\\nFollow up at Youtube channel \"Code-Yao\".\\n\"\"\"\\n\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        q1, q2 = collections.deque(nums[:n//2]), collections.deque(nums[n//2:])\\n        res = 0\\n        for y in q1:\\n            while q2 and q2[0] < 2 * y:\\n                q2.popleft()\\n            if not q2:\\n                break\\n            else:\\n                q2.popleft()\\n                res += 2\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: queue ADT\\n\\nIdea: we try to pair smaller numbers in the list with large ones (larger means 2 * small <= large)\\nObs: if the n = len(nums), then there are at most n // 2 matching pairs.\\n\\nWith the above Idea and Obs, we can use the following steps:\\n\\nAlgorithm/Steps:\\n\\nstep-0 sort the list nums from small to large and retrieve its length n\\nstep-1 use the first n//2 elements to check matching larger elements\\n       Let q1 = nums[:n//2]; q2 = nums[n//2:]\\n       for each element y in q1 (note these elements are from small to larger),\\n       we pop from q2 the elements that are not large enough, i.e., < 2 * y.\\n       If q2 is empty, it means no match, we just return the counting of pairs\\n       Else: q2[0] >= 2 * y, so we pop it to match y, increment the counting by 2 (= 1 pair)\\nstep-2 return the counting\\n       \\nEx-2. nums = [9,2,5,4] => sort => nums=[2, 4, 5, 9] => q1=[2, 4]; q2=[5, 9].\\n=> use 4 to match 2, and 9 to match 4, so the final result is 4.\\n\\nNote: we donot use 9 to match 2 though it can, b/c 5 can not match 4. This note\\njustified the soundness of the above algorithm.\\n\\nFollow up at Youtube channel \"Code-Yao\".\\n\"\"\"\\n\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        q1, q2 = collections.deque(nums[:n//2]), collections.deque(nums[n//2:])\\n        res = 0\\n        for y in q1:\\n            while q2 and q2[0] < 2 * y:\\n                q2.popleft()\\n            if not q2:\\n                break\\n            else:\\n                q2.popleft()\\n                res += 2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389623,
                "title": "even-a-kid-can-understand-c",
                "content": "# Intuition\\nso max pair can be made is n/2  if array size is n .\\nwe have to maximize the indices \\nwe will sort the array \\nlets start matching n/2 smallest element to n/2 largest element\\noptimally we should find the smallest element from second half \\n**ex :- 2 4 5 9 \\nfor two 5 and 9  both are suitable \\nif we pick 9 then for 4 we will be left with no option\\nso we choose min from second half\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        int count = 0; \\n        sort(nums.begin(),nums.end());\\n        int n  = nums.size();\\n\\n        int i = 0 , j = n - n/2;\\n\\n        while(i<n/2+1 && j<n)\\n        {\\n          if(nums[i]*2<=nums[j])\\n          {\\n              i++;\\n              j++;\\n              count +=2;\\n          }\\n          else j++;\\n        } \\n\\n        return count ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        int count = 0; \\n        sort(nums.begin(),nums.end());\\n        int n  = nums.size();\\n\\n        int i = 0 , j = n - n/2;\\n\\n        while(i<n/2+1 && j<n)\\n        {\\n          if(nums[i]*2<=nums[j])\\n          {\\n              i++;\\n              j++;\\n              count +=2;\\n          }\\n          else j++;\\n        } \\n\\n        return count ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349239,
                "title": "c-solution-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorting the Array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmax pair can be formed is n \\nand pair can be formed by n/2 * 2 which means\\nseparte sorted array in two equal parts \\nand check condition accordingly \\nsee the code for more ....\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        int mid = nums.size()/2;\\n        for(int i = 0; i<nums.size()/2 ; i++){\\n            while(mid < nums.size()){\\n                if(nums[i]*2 <= nums[mid]){\\n                    ans++;\\n                    mid++;\\n                    break;\\n                }\\n                else\\n                    mid++;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        int mid = nums.size()/2;\\n        for(int i = 0; i<nums.size()/2 ; i++){\\n            while(mid < nums.size()){\\n                if(nums[i]*2 <= nums[mid]){\\n                    ans++;\\n                    mid++;\\n                    break;\\n                }\\n                else\\n                    mid++;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335759,
                "title": "tricky-approach-and-harder-than-it-looks",
                "content": "I got the idea from another pro coder but it is really good. \\nYou just need the count and thats why you can sort the array and you\\'ll get the condition true (2*nums[i] <=nums[j)* if and only if the nums[i] is smaller so we divide array into two parts *smaller and larger* and we compare first index of smaller to first index of larger as we need top maximize the count.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n      int n = nums.size();\\n      int i=0;\\n      sort(nums.begin(),nums.end());\\n\\n\\n      for(int j=n-n/2 ; j<n ; j++){\\n          i+=(2*nums[i]<=nums[j]);\\n      }\\n      return i*2;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n      int n = nums.size();\\n      int i=0;\\n      sort(nums.begin(),nums.end());\\n\\n\\n      for(int j=n-n/2 ; j<n ; j++){\\n          i+=(2*nums[i]<=nums[j]);\\n      }\\n      return i*2;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287345,
                "title": "short-simple-easy-c-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA greedy approach is well suited here. In best case, we want to pair up every i and j. The ideal situation would be - in a sorted array item at index 0 paired up with item at nums.size()/2; 1 -> nums.size()/2 +1 and so on.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTaking a two pointer approach works well here with i ranging from [0,nums.size()/2) and j belonging to [nums.size()/2, nums.size())\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) as we sort the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0, j = nums.size()/2;i<nums.size()/2;i++){\\n            while(j<nums.size() && nums[j]<2*nums[i])j++;\\n            if(j>=nums.size())break;\\n            else {\\n                j++;\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0, j = nums.size()/2;i<nums.size()/2;i++){\\n            while(j<nums.size() && nums[j]<2*nums[i])j++;\\n            if(j>=nums.size())break;\\n            else {\\n                j++;\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285095,
                "title": "two-pointers-thoughts-and-prove",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTBH, I didn\\'t get to this until a few hours of try-and-WA and I feel like this is very delicate so I would like to organize my thoughs and share them.\\n\\nThe idea is you can also find the optimal pairs by spliting the sorted `nums` into two halves. One number from the lower half and the other from the upper half.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the input `nums` in ascending order.\\n2. Split the sorted input into two halves from the middle.\\n    - `i = 0 ` is the head of lower half, `j=(n+1)/2` is the head of upper half. \\n    - you may wonder about what if the number of input is odd, where to put the middle one: the lower or the upper. The answer is the upper one. For example, you have 13 numbers from the input. If you can paired the lower 6 numbers with the upper 6, then it is optimal. Therefore no need to put an extra number to the lower half. \\n3. Start matching the lower half and the upper half.\\n    - if `nums[j]` does not meet `nums[j] >= 2*nums[i]`,`i` stays and `j` moves to the next one.\\n    - if it does, then `i` and `j` moves to the next\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j= (n+1)/2;\\n        int ans = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) {\\n                i++;\\n                ans += 2;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j= (n+1)/2;\\n        int ans = 0;\\n        while (j < n) {\\n            if (2*nums[i] <= nums[j]) {\\n                i++;\\n                ans += 2;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284335,
                "title": "2576-find-the-maximum-number-of-marked-indices-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaximum answer can be the total size of the array. To happen that, half of the number should be higher or equal to the other half of the arry.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we sort the arry in non-decreasing order, then we can easily check if the second half of the array is greater or equal to the first half of the array. If not so, then we should check which maximum position we we get so that the other corresponding element is greater or equal to that element.\\n1. Sort the array in non-decreasing order.\\n2. Define a vector v and push the value in it which is twice as the first half of the sorted array.\\n3. Then simply check how many element of the sorted array of the second half is greater or equal to the previously defined vector v.\\n4. Each time the condition is satisfied our ans(answer)(initially defind 0(zero)) is incremented by 2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt will be O(nlong(n)). To sort the array it will take O(nlog(n)). Then a loop of the size of the given vector. So the overall time complexity will be O(nlogn).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt will O(n). Because we have used a vector of the half of the size of the given vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        vector<int> v;\\n        int i;\\n        for(i=0;i<(nums.size()/2);i++){\\n            v.push_back(2*nums[i]);\\n        }\\n        int ans=0;\\n        int k=0;\\n        for(i=(nums.size()/2);i<nums.size();i++){\\n            //cout<<\"nums[i]: \"<<nums[i]<<\" \"<<\"v[k]: \"<<v[k]<<endl;\\n            if(nums[i]>=v[k]){\\n                ans+=2;\\n                k++;\\n            }\\n            if(k==v.size()){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        vector<int> v;\\n        int i;\\n        for(i=0;i<(nums.size()/2);i++){\\n            v.push_back(2*nums[i]);\\n        }\\n        int ans=0;\\n        int k=0;\\n        for(i=(nums.size()/2);i<nums.size();i++){\\n            //cout<<\"nums[i]: \"<<nums[i]<<\" \"<<\"v[k]: \"<<v[k]<<endl;\\n            if(nums[i]>=v[k]){\\n                ans+=2;\\n                k++;\\n            }\\n            if(k==v.size()){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3278460,
                "title": "short-easiest-2-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n    int p=0; sort(v.begin(),v.end());\\n    for(int i=v.size()-v.size()/2;i<v.size();i++)p+=2*v[p]<=v[i];return p*2;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n    int p=0; sort(v.begin(),v.end());\\n    for(int i=v.size()-v.size()/2;i<v.size();i++)p+=2*v[p]<=v[i];return p*2;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274271,
                "title": "c-binary-search",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n        int lo = 0, hi = n / 2;\\n\\n        while (lo < hi)\\n        {\\n            int md = (lo + hi + 1) / 2; // make `md` stick with hi to avoid infinite loop\\n\\n            int i = 0;\\n            for (; i < md; ++i)\\n            {\\n                if (nums[i] * 2 > nums[n - md + i])\\n                {\\n                    break;\\n                }\\n            }\\n\\n            if (i < md)\\n            {\\n                hi = md - 1;\\n            }\\n            else\\n            {\\n                lo = md;\\n            }\\n        }\\n\\n        return lo * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n        int lo = 0, hi = n / 2;\\n\\n        while (lo < hi)\\n        {\\n            int md = (lo + hi + 1) / 2; // make `md` stick with hi to avoid infinite loop\\n\\n            int i = 0;\\n            for (; i < md; ++i)\\n            {\\n                if (nums[i] * 2 > nums[n - md + i])\\n                {\\n                    break;\\n                }\\n            }\\n\\n            if (i < md)\\n            {\\n                hi = md - 1;\\n            }\\n            else\\n            {\\n                lo = md;\\n            }\\n        }\\n\\n        return lo * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270720,
                "title": "binary-search-two-pointer-approach-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem first I sort the array and then find the minimum index for which i can get the minimum index for which i can get my answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy code just a simple predicate function which return true if for the mid i can have enough values.\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool predi(vector<int>&num,int mid){\\n        int n = num.size();\\n        int i = 0;\\n        int j = mid+1;\\n        while(i<=mid && j<n){\\n            if(2*num[i]<=num[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(i==mid+1){\\n            return true;\\n        }\\n        else return false;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int index = -1;\\n        int i=0;\\n        int j = nums.size()-1;\\n        while(j>=i){\\n            int mid = (i+j)/2;\\n            if(predi(nums,mid)){\\n                index = mid;\\n                i = mid+1;\\n            }\\n            else{\\n                j = mid-1;\\n            }\\n            \\n        }\\n        cout<<index<<endl;\\n        if(index==-1)return 0;\\n        return 2*(index+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool predi(vector<int>&num,int mid){\\n        int n = num.size();\\n        int i = 0;\\n        int j = mid+1;\\n        while(i<=mid && j<n){\\n            if(2*num[i]<=num[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(i==mid+1){\\n            return true;\\n        }\\n        else return false;\\n    }\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int index = -1;\\n        int i=0;\\n        int j = nums.size()-1;\\n        while(j>=i){\\n            int mid = (i+j)/2;\\n            if(predi(nums,mid)){\\n                index = mid;\\n                i = mid+1;\\n            }\\n            else{\\n                j = mid-1;\\n            }\\n            \\n        }\\n        cout<<index<<endl;\\n        if(index==-1)return 0;\\n        return 2*(index+1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3265714,
                "title": "1-liner",
                "content": "```ruby\\ndef max_num_of_marked_indices(a) =\\n    ((z = a.sort!.size) - z / 2...z).reduce(0) do\\n        _1 + (a[_1] * 2 <= a[_2] ? 1 : 0)\\n    end * 2\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef max_num_of_marked_indices(a) =\\n    ((z = a.sort!.size) - z / 2...z).reduce(0) do\\n        _1 + (a[_1] * 2 <= a[_2] ? 1 : 0)\\n    end * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3254611,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter we sort the input, we can greedly check if an answer is possible in linear time, so we can use binary search in the solution space for this quesstion. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe sort the array so we can check if the potencial answer \"max\" is possible in linear time. We check greedyly, smallest number that\\'s in lower group match with smallest number that\\'s in upper group.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting cost O(nLog(n))\\nBinary Search cost O(Log(n))\\nThe final algorithem cost O(nLog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nIn my code, I clone the input to a new array then sorted it, but you can just sort the input array.\\n# Code\\n```\\npublic class Solution {\\n\\n    int[] ascendArray;\\n    int n;\\n\\n    public int MaxNumOfMarkedIndices(int[] nums) {\\n        \\n        n = nums.Length;\\n        ascendArray = (int[])nums.Clone();\\n\\n        Array.Sort(ascendArray);\\n\\n\\n        int left = 0;\\n        int right = n/2;\\n\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            if(Check(mid))\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return right * 2;\\n\\n    }\\n\\n    bool Check(int max)\\n    {\\n        if(max > n) {\\n            return false;\\n        }\\n\\n        for(int i = 0; i < max; i++)\\n        {\\n            int small = ascendArray[i];\\n            int large = ascendArray[n - (max - i)];\\n            if(small * 2 > large)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    int[] ascendArray;\\n    int n;\\n\\n    public int MaxNumOfMarkedIndices(int[] nums) {\\n        \\n        n = nums.Length;\\n        ascendArray = (int[])nums.Clone();\\n\\n        Array.Sort(ascendArray);\\n\\n\\n        int left = 0;\\n        int right = n/2;\\n\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            if(Check(mid))\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return right * 2;\\n\\n    }\\n\\n    bool Check(int max)\\n    {\\n        if(max > n) {\\n            return false;\\n        }\\n\\n        for(int i = 0; i < max; i++)\\n        {\\n            int small = ascendArray[i];\\n            int large = ascendArray[n - (max - i)];\\n            if(small * 2 > large)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252926,
                "title": "python-two-pointers",
                "content": "```\\ndef maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        lth,div,re = len(nums),len(nums)//2,0\\n        left = nums[:div]\\n        right = nums[div:]\\n        j=len(left)-1\\n        for i in range(len(right)-1, -1, -1):\\n            while j >= 0:\\n                if right[i] >= left[j]*2:\\n                    re+=2\\n                    j-=1\\n                    break\\n                else:\\n                    j-=1\\n        return re\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        lth,div,re = len(nums),len(nums)//2,0\\n        left = nums[:div]\\n        right = nums[div:]\\n        j=len(left)-1\\n        for i in range(len(right)-1, -1, -1):\\n            while j >= 0:\\n                if right[i] >= left[j]*2:\\n                    re+=2\\n                    j-=1\\n                    break\\n                else:\\n                    j-=1\\n        return re\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3252026,
                "title": "pair",
                "content": "# * 1. class Solution(object):``\\n    def maxNumOfMarkedIndices(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i=0\\n        count=0\\n        nums.sort()\\n        n=len(nums)\\n        for j in range((n+1)//2,len(nums)):\\n            if 2 * nums[i] <= nums[j]:\\n                i+=1\\n                count+=2\\n        return count\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "# * 1. class Solution(object):``\\n    def maxNumOfMarkedIndices(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i=0\\n        count=0\\n        nums.sort()\\n        n=len(nums)\\n        for j in range((n+1)//2,len(nums)):\\n            if 2 * nums[i] <= nums[j]:\\n                i+=1\\n                count+=2\\n        return count\\n",
                "codeTag": "Java"
            },
            {
                "id": 3251666,
                "title": "java-2-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=nums.length/2-1;\\n        int l=mid;\\n        int count=0;\\n        int r=nums.length-1;\\n        while(l>=0){\\n            if((nums[l]*2)<=nums[r]){\\n                count=count+1;\\n                l=l-1;\\n                r=r-1;\\n            }\\n            else{\\n                l=l-1;\\n            }\\n        }\\n        return count*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=nums.length/2-1;\\n        int l=mid;\\n        int count=0;\\n        int r=nums.length-1;\\n        while(l>=0){\\n            if((nums[l]*2)<=nums[r]){\\n                count=count+1;\\n                l=l-1;\\n                r=r-1;\\n            }\\n            else{\\n                l=l-1;\\n            }\\n        }\\n        return count*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251102,
                "title": "c-easy-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        vector<char>v(nums.size(),\\'u\\');\\n        sort(nums.begin(),nums.end());\\n        int largest = nums[nums.size()-1];\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int l=0 , h= i-1;\\n            int k = nums[i]/2;\\n            int a = -1;\\n            while(l<=h){\\n                int mid= ((h-l)/2)+l;\\n                if(i==3){\\n                    cout<<nums[i]<<\\' \\';\\n                }\\n                if(nums[mid]<=k && v[mid]==\\'u\\'){\\n                    a=mid;\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n                \\n            }\\n            if(a==-1){\\n                continue;\\n            }\\n            else{\\n                v[a]=\\'m\\';\\n                v[i]=\\'m\\';\\n                \\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            cout<<v[i]<<\\' \\';\\n        }\\n        int c = count(v.begin(),v.end(),\\'m\\');\\n        if(c%2!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(v[i]==\\'u\\' && nums[i]<=largest/2)\\n                {\\n                    return c+1;\\n                }\\n            }\\n            return c-1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        vector<char>v(nums.size(),\\'u\\');\\n        sort(nums.begin(),nums.end());\\n        int largest = nums[nums.size()-1];\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int l=0 , h= i-1;\\n            int k = nums[i]/2;\\n            int a = -1;\\n            while(l<=h){\\n                int mid= ((h-l)/2)+l;\\n                if(i==3){\\n                    cout<<nums[i]<<\\' \\';\\n                }\\n                if(nums[mid]<=k && v[mid]==\\'u\\'){\\n                    a=mid;\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n                \\n            }\\n            if(a==-1){\\n                continue;\\n            }\\n            else{\\n                v[a]=\\'m\\';\\n                v[i]=\\'m\\';\\n                \\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            cout<<v[i]<<\\' \\';\\n        }\\n        int c = count(v.begin(),v.end(),\\'m\\');\\n        if(c%2!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(v[i]==\\'u\\' && nums[i]<=largest/2)\\n                {\\n                    return c+1;\\n                }\\n            }\\n            return c-1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3250452,
                "title": "antarnab-100-faster-java-solution-full-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //public int maxNumOfMarkedIndices(int[] nums) {\\n        public int maxNumOfMarkedIndices(int[] nums) {\\n    int i = 0, n = nums.length;\\n    Arrays.sort(nums);\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j] ? 1 : 0;\\n    return i * 2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //public int maxNumOfMarkedIndices(int[] nums) {\\n        public int maxNumOfMarkedIndices(int[] nums) {\\n    int i = 0, n = nums.length;\\n    Arrays.sort(nums);\\n    for (int j = n - n / 2; j < n; ++j)\\n        i += 2 * nums[i] <= nums[j] ? 1 : 0;\\n    return i * 2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244986,
                "title": "easy-to-understand-solution-in-c",
                "content": "\\n# Complexity\\n- Time complexity:162 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:60.2 mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans=0,i=0,j=nums.size()/2;\\n        sort(nums.begin(),nums.end());\\n        while(i<nums.size()/2 && j<nums.size()){\\n            if(2*nums[i]<=nums[j]) ans++,i++;\\n            j++;\\n        }\\n        return 2*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans=0,i=0,j=nums.size()/2;\\n        sort(nums.begin(),nums.end());\\n        while(i<nums.size()/2 && j<nums.size()){\\n            if(2*nums[i]<=nums[j]) ans++,i++;\\n            j++;\\n        }\\n        return 2*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244909,
                "title": "c-golang-two-pointers-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0, j = n / 2; i < n / 2 && j < n; i++, j++) {\\n            while(j < n && 2 * nums[i] > nums[j]) j++;\\n            if(j < n) ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maxNumOfMarkedIndices(nums []int) int {\\n    sort.Ints(nums)\\n    var n, ans int = len(nums), 0\\n    for i, j := 0, n / 2; i < n / 2 && j < n; i, j = i + 1, j + 1 {\\n        for j < n && 2 * nums[i] > nums[j] {j++}\\n        if j < n {ans += 2}\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0, j = n / 2; i < n / 2 && j < n; i++, j++) {\\n            while(j < n && 2 * nums[i] > nums[j]) j++;\\n            if(j < n) ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maxNumOfMarkedIndices(nums []int) int {\\n    sort.Ints(nums)\\n    var n, ans int = len(nums), 0\\n    for i, j := 0, n / 2; i < n / 2 && j < n; i, j = i + 1, j + 1 {\\n        for j < n && 2 * nums[i] > nums[j] {j++}\\n        if j < n {ans += 2}\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244598,
                "title": "20230301-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int nn=n;\\n        for (int i = n/2; i>0; i--)\\n            if (nums[i-1]*2 <= nums[n-1]) n--;\\n        return (nn-n)*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int nn=n;\\n        for (int i = n/2; i>0; i--)\\n            if (nums[i-1]*2 <= nums[n-1]) n--;\\n        return (nn-n)*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243696,
                "title": "treemap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        TreeMap<Integer,Integer> set = new TreeMap<>();\\n        TreeMap<Integer,Integer> set2 = new TreeMap<>();\\n        int ans = 0, l = nums.length;\\n        Arrays.sort(nums);\\n        for(int i = 0;i<l/2;i++){\\n            int a = nums[i];\\n            if(set.containsKey(a))set.put(a,set.get(a) + 1);\\n            else set.put(a,1);\\n        }\\n\\n        for(int i = l/2;i<l;i++){\\n            int a = nums[i];\\n            if(set2.containsKey(a))set2.put(a,set2.get(a) + 1);\\n            else set2.put(a,1);\\n        }\\n\\n        for(int i = 0;i<l/2;i++){\\n            int a = nums[i];\\n            if(set2.ceilingKey(2*a)!=null){\\n                int b = set2.ceilingKey(2*a);\\n                set2.put(b,set2.get(b)-1);\\n                if(set2.get(b)==0)set2.remove(b);\\n                set.put(a,set.get(a)-1);\\n                if(set.get(a)==0)set.remove(a);\\n                ans+=2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n\\n// 2 \\n// 2 3 4 5\\n// 2,4\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        TreeMap<Integer,Integer> set = new TreeMap<>();\\n        TreeMap<Integer,Integer> set2 = new TreeMap<>();\\n        int ans = 0, l = nums.length;\\n        Arrays.sort(nums);\\n        for(int i = 0;i<l/2;i++){\\n            int a = nums[i];\\n            if(set.containsKey(a))set.put(a,set.get(a) + 1);\\n            else set.put(a,1);\\n        }\\n\\n        for(int i = l/2;i<l;i++){\\n            int a = nums[i];\\n            if(set2.containsKey(a))set2.put(a,set2.get(a) + 1);\\n            else set2.put(a,1);\\n        }\\n\\n        for(int i = 0;i<l/2;i++){\\n            int a = nums[i];\\n            if(set2.ceilingKey(2*a)!=null){\\n                int b = set2.ceilingKey(2*a);\\n                set2.put(b,set2.get(b)-1);\\n                if(set2.get(b)==0)set2.remove(b);\\n                set.put(a,set.get(a)-1);\\n                if(set.get(a)==0)set.remove(a);\\n                ans+=2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n\\n// 2 \\n// 2 3 4 5\\n// 2,4\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242935,
                "title": "easy-to-understand-c-solution-two-pointers",
                "content": "# Complexity\\n- Time complexity: O(n*logn)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0, n = nums.size(), j = n/2;\\n        for(int i=0;i<n/2 && j<n;) {\\n            if(2* nums[i] <= nums[j]) {\\n                cnt+=2;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0, n = nums.size(), j = n/2;\\n        for(int i=0;i<n/2 && j<n;) {\\n            if(2* nums[i] <= nums[j]) {\\n                cnt+=2;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242914,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        const auto size = nums.size();\\n        int skips = size % 2, result = 0;\\n        for (auto i = 0; i + size / 2 + skips < size;) {\\n            if (2 * nums[i] <= nums[i + size / 2 + skips]) {\\n                ++result; ++i;\\n            } else ++skips;\\n        }\\n        return 2 * result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        const auto size = nums.size();\\n        int skips = size % 2, result = 0;\\n        for (auto i = 0; i + size / 2 + skips < size;) {\\n            if (2 * nums[i] <= nums[i + size / 2 + skips]) {\\n                ++result; ++i;\\n            } else ++skips;\\n        }\\n        return 2 * result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242197,
                "title": "this-question-was-so-easy-and-i-have-wasted-time-thinking-about-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n      int n = nums.length ;\\n        int count = 0 ;\\n      int i = 0;\\n        int j = (n%2==0)?n/2:(n/2)+1;\\n        while(i<=j){\\n            if(i==n||j==n)\\n                break;\\n            if(  2*nums[i]<=nums[j] ){\\n                i++;\\n            j++;\\n                count+=2;\\n                \\n            }\\n            else \\n            {\\n                j++;\\n            }\\n        }\\n                \\nreturn count ;\\n}\\n       \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n      int n = nums.length ;\\n        int count = 0 ;\\n      int i = 0;\\n        int j = (n%2==0)?n/2:(n/2)+1;\\n        while(i<=j){\\n            if(i==n||j==n)\\n                break;\\n            if(  2*nums[i]<=nums[j] ){\\n                i++;\\n            j++;\\n                count+=2;\\n                \\n            }\\n            else \\n            {\\n                j++;\\n            }\\n        }\\n                \\nreturn count ;\\n}\\n       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242093,
                "title": "the-worst-solution",
                "content": "# Intuition\\ngreed and badly written code\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n), thanks Tim!\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i, j = 0, (len(nums) + 1) // 2\\n\\n        while j < len(nums):\\n            if (nums[i] * 2) <= nums[j]: #success\\n                i += 1\\n                j += 1\\n            else: #failure\\n                j += 1 #note that j+= 1 happens both times but has DISTINCTION here\\n\\n        #num of pairs == how much we can move i to the right and pair it with j_elements\\n        #total == (that mess) * 2\\n        return (i) * 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i, j = 0, (len(nums) + 1) // 2\\n\\n        while j < len(nums):\\n            if (nums[i] * 2) <= nums[j]: #success\\n                i += 1\\n                j += 1\\n            else: #failure\\n                j += 1 #note that j+= 1 happens both times but has DISTINCTION here\\n\\n        #num of pairs == how much we can move i to the right and pair it with j_elements\\n        #total == (that mess) * 2\\n        return (i) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241087,
                "title": "c-sorting-two-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),cnt=0;\\n        int i=0,j=n/2;\\n        while(i<n/2 && j<n){\\n            if(2*nums[i]<=nums[j]){\\n                cnt++;\\n                i++;\\n                j++;\\n            }else {\\n                j++;\\n            }\\n        }\\n        return 2*cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),cnt=0;\\n        int i=0,j=n/2;\\n        while(i<n/2 && j<n){\\n            if(2*nums[i]<=nums[j]){\\n                cnt++;\\n                i++;\\n                j++;\\n            }else {\\n                j++;\\n            }\\n        }\\n        return 2*cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240625,
                "title": "c-sorting-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=n/2,ans=0;\\n        while(j<n&&i<n/2)\\n        {\\n            if(nums[i]*2<=nums[j])\\n            {\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans*2;\\n        \\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=n/2,ans=0;\\n        while(j<n&&i<n/2)\\n        {\\n            if(nums[i]*2<=nums[j])\\n            {\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans*2;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239918,
                "title": "1sentence-faster-than-98-matching-lower-half-with-upper-half-of-nums-with-2-pointers",
                "content": "# Upvote if you like the solution\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        j = n//2\\n        ret = 0\\n        for i in range(n//2):\\n            while j<n and nums[j] < 2 * nums[i]:\\n                j += 1\\n            if j<n:\\n                ret += 2\\n                j += 1\\n            elif j==n:\\n                break\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        j = n//2\\n        ret = 0\\n        for i in range(n//2):\\n            while j<n and nums[j] < 2 * nums[i]:\\n                j += 1\\n            if j<n:\\n                ret += 2\\n                j += 1\\n            elif j==n:\\n                break\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239756,
                "title": "easy-java-solution",
                "content": "# Intuition\\nWe require pairs to be maximum so we have pair them in such a way that we can find pair for all nums[i]. \\n\\n# Approach\\nWe can do it by sorting the array and two pointers algorithm \\n\\n# Complexity\\n- Time complexity:\\nO(logn) (Sorting)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        int i=0, j=n/2, ans = 0;\\n        Arrays.sort(nums);\\n        while(i<n/2 && j<n){\\n            if(2*nums[i] <= nums[j]){\\n                i++;\\n                j++;\\n                ans=ans+2;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPls give an upvote :)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        int i=0, j=n/2, ans = 0;\\n        Arrays.sort(nums);\\n        while(i<n/2 && j<n){\\n            if(2*nums[i] <= nums[j]){\\n                i++;\\n                j++;\\n                ans=ans+2;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238885,
                "title": "easy-simple-solution-c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ft=0;\\n        int sec=n/2;\\n        int cnt=0;\\n        while(ft<n/2 && sec<n){\\n            if(2*nums[ft]<=nums[sec]){\\n                cnt+=2;\\n                ft++;\\n                sec++;\\n            }\\n            else\\n            sec++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ft=0;\\n        int sec=n/2;\\n        int cnt=0;\\n        while(ft<n/2 && sec<n){\\n            if(2*nums[ft]<=nums[sec]){\\n                cnt+=2;\\n                ft++;\\n                sec++;\\n            }\\n            else\\n            sec++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238823,
                "title": "fundamental-approach-two-pointers-c-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int n = nums.size();\\n        int j = n/2;\\n        int out = 0;\\n        while(i < (n/2) and j < n) {\\n            if(nums[i]*2 <= nums[j]) {\\n                out += 2;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: (Whose-so-ever concerned)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int n = nums.size();\\n        int j = n/2;\\n        int out = 0;\\n        while(i < (n/2) and j < n) {\\n            if(nums[i]*2 <= nums[j]) {\\n                out += 2;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: (Whose-so-ever concerned)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238660,
                "title": "two-pointer-rust",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        nums.sort_unstable();\\n\\n        let mut left: usize = 0;\\n        let mut right: usize = n / 2;    \\n        while left < n/2 && right < n {\\n            if nums[left] * 2 <= nums[right] {\\n                left += 1;\\n            }\\n            right += 1;\\n        }\\n        return (left * 2) as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        nums.sort_unstable();\\n\\n        let mut left: usize = 0;\\n        let mut right: usize = n / 2;    \\n        while left < n/2 && right < n {\\n            if nums[left] * 2 <= nums[right] {\\n                left += 1;\\n            }\\n            right += 1;\\n        }\\n        return (left * 2) as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238659,
                "title": "two-pointer-rust",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        nums.sort_unstable();\\n\\n        let mut left: usize = 0;\\n        let mut right: usize = n / 2;    \\n        while left < n/2 && right < n {\\n            if nums[left] * 2 <= nums[right] {\\n                left += 1;\\n            }\\n            right += 1;\\n        }\\n        return (left * 2) as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        nums.sort_unstable();\\n\\n        let mut left: usize = 0;\\n        let mut right: usize = n / 2;    \\n        while left < n/2 && right < n {\\n            if nums[left] * 2 <= nums[right] {\\n                left += 1;\\n            }\\n            right += 1;\\n        }\\n        return (left * 2) as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238454,
                "title": "java-beginner-friendly-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int n = nums.length;\\n        int j = n-1;\\n    \\n        for(int i=n/2-1;i>=0;i--){\\n            if (nums[i] * 2 <= nums[j]) {\\n                ans += 2; \\n                j -= 1;\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int n = nums.length;\\n        int j = n-1;\\n    \\n        for(int i=n/2-1;i>=0;i--){\\n            if (nums[i] * 2 <= nums[j]) {\\n                ans += 2; \\n                j -= 1;\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237853,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    int n = nums.size();\\n    int i = 0, j = n/2, cnt = 0;\\n    while(j<n and i < n/2){\\n        if(2 * nums[i] <= nums[j]){\\n            cnt += 2;\\n            i++;\\n        }\\n        j++;\\n    }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    int n = nums.size();\\n    int i = 0, j = n/2, cnt = 0;\\n    while(j<n and i < n/2){\\n        if(2 * nums[i] <= nums[j]){\\n            cnt += 2;\\n            i++;\\n        }\\n        j++;\\n    }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237459,
                "title": "c-sorting-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int n=nums.size()/2;\\n        int j=n;\\n        for(int i=0;i<n && j<nums.size();){\\n            if(nums[i]*2<=nums[j]){\\n                    i++;\\n                    j++;\\n                    ans+=2;\\n                }\\n                else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n//Please upvote if you like the code",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int n=nums.size()/2;\\n        int j=n;\\n        for(int i=0;i<n && j<nums.size();){\\n            if(nums[i]*2<=nums[j]){\\n                    i++;\\n                    j++;\\n                    ans+=2;\\n                }\\n                else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237233,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        // vector<int>vis(n,0);\\n        int i=0;\\n        int j=n/2;\\n        while(i<n/2 && j<n){\\n            if( 2*nums[i]<=nums[j]){\\n                ans+=2;\\n                \\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        // vector<int>vis(n,0);\\n        int i=0;\\n        int j=n/2;\\n        while(i<n/2 && j<n){\\n            if( 2*nums[i]<=nums[j]){\\n                ans+=2;\\n                \\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237032,
                "title": "easy-understanding-c-solution-binary-search",
                "content": "```\\nclass Solution {\\n    bool utilfunc(vector<int> &nums,int k)\\n    {\\n        int count = 0;\\n        int n = nums.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            if(2*nums[i]<=nums[n-k+i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count == k;\\n    }\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int l = 0;\\n        int h = nums.size()/2;\\n        int ans  = l;\\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n            \\n            if(utilfunc(nums,mid))\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }else{\\n                h = mid-1;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool utilfunc(vector<int> &nums,int k)\\n    {\\n        int count = 0;\\n        int n = nums.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            if(2*nums[i]<=nums[n-k+i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count == k;\\n    }\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int l = 0;\\n        int h = nums.size()/2;\\n        int ans  = l;\\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n            \\n            if(utilfunc(nums,mid))\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }else{\\n                h = mid-1;\\n            }\\n        }\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236736,
                "title": "binarysearch-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, n // 2\\n        while left <= right:\\n            k = (left + right) // 2\\n            if all(nums[i] * 2 <= nums[i - k] for i in range(k)):\\n                left = k + 1\\n            else:\\n                right = k - 1\\n\\n        return (left - 1) * 2\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, n // 2\\n        while left <= right:\\n            k = (left + right) // 2\\n            if all(nums[i] * 2 <= nums[i - k] for i in range(k)):\\n                left = k + 1\\n            else:\\n                right = k - 1\\n\\n        return (left - 1) * 2\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236578,
                "title": "a-few-solutions",
                "content": "Initialize `i` and `j` to the index of the last element of the first and second half of the *sorted* input array `A` correspondingly.\\n\\nFrom right-to-left, greedily consume pairs of index `i`,`j` if-and-only-if `A[i] * 2 <= A[j]`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxNumOfMarkedIndices(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return 0\\n        var cnt = 0\\n        A.sort()\\n        var (i, j) = Pair(N / 2 - 1, N - 1)\\n        while (0 <= i) {\\n            if (A[i] * 2 <= A[j]) {\\n                --j; cnt += 2;\\n            }\\n            --i\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxNumOfMarkedIndices = (A, cnt = 0) => {\\n    let N = A.length;\\n    if (N == 1)\\n        return 0;\\n    A.sort((a, b) => a - b);\\n    let [i, j] = [Math.floor(N / 2) - 1, N - 1];\\n    while (0 <= i) {\\n        if (A[i] * 2 <= A[j])\\n            --j, cnt += 2;\\n        --i;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, A: List[int], cnt = 0) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return 0\\n        A.sort()\\n        i, j = N // 2 - 1, N - 1\\n        while 0 <= i:\\n            if A[i] * 2 <= A[j]:\\n                j -= 1; cnt += 2\\n            i -= 1\\n        return cnt\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut A: VI) -> i32 {\\n        let N = A.len();\\n        if N == 1 {\\n            return 0;\\n        }\\n        let mut cnt = 0;\\n        A.sort();\\n        let (mut i, mut j) = (N / 2 - 1, N - 1);\\n        loop {\\n            if A[i] * 2 <= A[j] {\\n                j -= 1; cnt += 2;\\n            }\\n            if i == 0 { break; } else { i -= 1; }\\n        }\\n        cnt\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxNumOfMarkedIndices(VI& A, int cnt = 0) {\\n        int N = A.size();\\n        if (N == 1)\\n            return 0;\\n        sort(A.begin(), A.end());\\n        auto [i, j] = make_pair(N / 2 - 1, N - 1);\\n        while (0 <= i) {\\n            if (A[i] * 2 <= A[j])\\n                --j, cnt += 2;\\n            --i;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxNumOfMarkedIndices(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return 0\\n        var cnt = 0\\n        A.sort()\\n        var (i, j) = Pair(N / 2 - 1, N - 1)\\n        while (0 <= i) {\\n            if (A[i] * 2 <= A[j]) {\\n                --j; cnt += 2;\\n            }\\n            --i\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet maxNumOfMarkedIndices = (A, cnt = 0) => {\\n    let N = A.length;\\n    if (N == 1)\\n        return 0;\\n    A.sort((a, b) => a - b);\\n    let [i, j] = [Math.floor(N / 2) - 1, N - 1];\\n    while (0 <= i) {\\n        if (A[i] * 2 <= A[j])\\n            --j, cnt += 2;\\n        --i;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, A: List[int], cnt = 0) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return 0\\n        A.sort()\\n        i, j = N // 2 - 1, N - 1\\n        while 0 <= i:\\n            if A[i] * 2 <= A[j]:\\n                j -= 1; cnt += 2\\n            i -= 1\\n        return cnt\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn max_num_of_marked_indices(mut A: VI) -> i32 {\\n        let N = A.len();\\n        if N == 1 {\\n            return 0;\\n        }\\n        let mut cnt = 0;\\n        A.sort();\\n        let (mut i, mut j) = (N / 2 - 1, N - 1);\\n        loop {\\n            if A[i] * 2 <= A[j] {\\n                j -= 1; cnt += 2;\\n            }\\n            if i == 0 { break; } else { i -= 1; }\\n        }\\n        cnt\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxNumOfMarkedIndices(VI& A, int cnt = 0) {\\n        int N = A.size();\\n        if (N == 1)\\n            return 0;\\n        sort(A.begin(), A.end());\\n        auto [i, j] = make_pair(N / 2 - 1, N - 1);\\n        while (0 <= i) {\\n            if (A[i] * 2 <= A[j])\\n                --j, cnt += 2;\\n            --i;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236378,
                "title": "c-solution-with-sort-and-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first need to sort the array to maximise the result. Then we canseperate the first half and second half oof array and greedly try to make as much pair as we can.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        for (int j=(n+1)/2; j<n; ++j) {\\n            if (2 * nums[i] <= nums[j]) i++;\\n        }\\n        return i * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        for (int j=(n+1)/2; j<n; ++j) {\\n            if (2 * nums[i] <= nums[j]) i++;\\n        }\\n        return i * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236363,
                "title": "java-easy-5-lines-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxNumOfMarkedIndices(int[] nums) {\\n    Arrays.sort(nums);\\n    int l = 0;\\n\\n    for(int r = (nums.length+1)>>1; r != nums.length; r++)\\n      if((nums[l]<<1) <= nums[r]) l++;\\n    \\n    return l<<1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxNumOfMarkedIndices(int[] nums) {\\n    Arrays.sort(nums);\\n    int l = 0;\\n\\n    for(int r = (nums.length+1)>>1; r != nums.length; r++)\\n      if((nums[l]<<1) <= nums[r]) l++;\\n    \\n    return l<<1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236273,
                "title": "two-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that the order of i,j does not matter in this question.\\nSo we can sort it and look for the required pairs.\\n\\nWe know that there can only be n/2 pairs maximum in the given array\\nSo while trying to find maximum number of pairs we can go from the. midpoint of the sorted array with the idea of matching the elements in the first half of the array with elements of second half of arrray.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse 2 ptr approach and greedily search the first possible pair for the element in the first half of array to the available elements in the second half of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxNumOfMarkedIndices(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        int n = nums.Length;\\n        \\n        int p1 = 0, midPoint = (n%2==0)?n/2:n/2+1;\\n        \\n        int p2 = midPoint;\\n        \\n        int ans = 0;\\n        \\n        while(p1<midPoint && p2<n){\\n            if(2*nums[p1]<=nums[p2]){\\n                ans += 2;\\n                p1++;\\n                p2++;\\n            }\\n            else{\\n                p2++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxNumOfMarkedIndices(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        int n = nums.Length;\\n        \\n        int p1 = 0, midPoint = (n%2==0)?n/2:n/2+1;\\n        \\n        int p2 = midPoint;\\n        \\n        int ans = 0;\\n        \\n        while(p1<midPoint && p2<n){\\n            if(2*nums[p1]<=nums[p2]){\\n                ans += 2;\\n                p1++;\\n                p2++;\\n            }\\n            else{\\n                p2++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236051,
                "title": "simple-and-fast-approach-c",
                "content": "#\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int i=0,count=0,j=nums.size()/2;\\n        while(j<nums.size())\\n        {\\n            if(nums[i]==-1)\\n            {\\n                i+=1;\\n                continue;\\n            }\\n            if(2*nums[i]<=nums[j])\\n            {\\n                i+=1;\\n                nums[j]=-1;\\n                j+=1;\\n                count+=2;\\n            }\\n            else\\n            {\\n                j+=1;\\n            }\\n        }\\n        return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int i=0,count=0,j=nums.size()/2;\\n        while(j<nums.size())\\n        {\\n            if(nums[i]==-1)\\n            {\\n                i+=1;\\n                continue;\\n            }\\n            if(2*nums[i]<=nums[j])\\n            {\\n                i+=1;\\n                nums[j]=-1;\\n                j+=1;\\n                count+=2;\\n            }\\n            else\\n            {\\n                j+=1;\\n            }\\n        }\\n        return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235980,
                "title": "very-easy-c-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n         int n=nums.size();\\n        int k=nums.size()/2;\\n        if(n==1){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int i=k-1;\\n        int j=n-1;\\n        int ans=0;\\n        while(i>=0 && j>=k){\\n            if(2*nums[i]<=nums[j]){\\n                ans+=2;\\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n         int n=nums.size();\\n        int k=nums.size()/2;\\n        if(n==1){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int i=k-1;\\n        int j=n-1;\\n        int ans=0;\\n        while(i>=0 && j>=k){\\n            if(2*nums[i]<=nums[j]){\\n                ans+=2;\\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235710,
                "title": "dart-both-two-pointer-and-binary-search-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(LogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Two Pointer\\n```\\n  int maxNumOfMarkedIndices(List<int> nums) {\\n    nums.sort();\\n    int n = nums.length;\\n    int res = 0;\\n    for (var i = 0, j = (n + 1) ~/ 2; j < n; j++) {\\n      if (nums[j] >= nums[i] * 2) {\\n        i++;\\n        res += 2;\\n      }\\n    }\\n\\n    return res;\\n  }\\n```\\n\\n# Binary Search Answer\\n```\\nclass Solution {\\n  int maxNumOfMarkedIndices(List<int> nums) {\\n    nums.sort();\\n    int n = nums.length;\\n    int res = 0;\\n    int mid = (n + 1) ~/ 2;\\n    for (var i = 0; i < n / 2; i++) {\\n      mid = lowerBound(nums, 2 * nums[i], start: mid);\\n      if (mid == n) {\\n          break;\\n      }\\n      mid++;\\n      res += 2;\\n    }\\n\\n    return res;\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n  int maxNumOfMarkedIndices(List<int> nums) {\\n    nums.sort();\\n    int n = nums.length;\\n    int res = 0;\\n    for (var i = 0, j = (n + 1) ~/ 2; j < n; j++) {\\n      if (nums[j] >= nums[i] * 2) {\\n        i++;\\n        res += 2;\\n      }\\n    }\\n\\n    return res;\\n  }\\n```\n```\\nclass Solution {\\n  int maxNumOfMarkedIndices(List<int> nums) {\\n    nums.sort();\\n    int n = nums.length;\\n    int res = 0;\\n    int mid = (n + 1) ~/ 2;\\n    for (var i = 0; i < n / 2; i++) {\\n      mid = lowerBound(nums, 2 * nums[i], start: mid);\\n      if (mid == n) {\\n          break;\\n      }\\n      mid++;\\n      res += 2;\\n    }\\n\\n    return res;\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235374,
                "title": "c-solution-beats-100-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=n/2;\\n        while(j<n&&i<n/2){\\n            if(nums[i]*2<=nums[j]){\\n                ans+=2;\\n                i++;   \\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=n/2;\\n        while(j<n&&i<n/2){\\n            if(nums[i]*2<=nums[j]){\\n                ans+=2;\\n                i++;   \\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235198,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func maxNumOfMarkedIndices(_ n: [Int]) -> Int {\\n        ((n.count+1)/2..<n.count).reduce(into: (0, n.sorted())) {$0.0 += $0.1[$0.0]*2<=$0.1[$1] ? 1:0}.0*2\\n    }\\n}\\n```\\n\\n----\\n\\n**One-Liner, expanded and annnotated (accepted answer)**\\n```\\nclass Solution {\\n    func maxNumOfMarkedIndices(_ nums: [Int]) -> Int {\\n        ((nums.count+1)/2..<nums.count).reduce(into: (\\n            result: 0, \\n            nums: nums.sorted()\\n        )) { data, num in \\n            data.result += data.nums[data.result]*2 <= data.nums[num] ? 1:0\\n        }.result * 2\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxNumOfMarkedIndices(_ n: [Int]) -> Int {\\n        ((n.count+1)/2..<n.count).reduce(into: (0, n.sorted())) {$0.0 += $0.1[$0.0]*2<=$0.1[$1] ? 1:0}.0*2\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func maxNumOfMarkedIndices(_ nums: [Int]) -> Int {\\n        ((nums.count+1)/2..<nums.count).reduce(into: (\\n            result: 0, \\n            nums: nums.sorted()\\n        )) { data, num in \\n            data.result += data.nums[data.result]*2 <= data.nums[num] ? 1:0\\n        }.result * 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235184,
                "title": "javascript-greedy-201ms",
                "content": "```\\nconst maxNumOfMarkedIndices = (a) => {\\n    a.sort((x, y) => x - y);\\n    let n = a.length, j = n - 1, res = 0;\\n    for (let i = (n >> 1) - 1; i >= 0; i--) {\\n        if (a[i] * 2 <= a[j]) {\\n            res += 2;\\n            j--;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst maxNumOfMarkedIndices = (a) => {\\n    a.sort((x, y) => x - y);\\n    let n = a.length, j = n - 1, res = 0;\\n    for (let i = (n >> 1) - 1; i >= 0; i--) {\\n        if (a[i] * 2 <= a[j]) {\\n            res += 2;\\n            j--;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3235182,
                "title": "100-fast-4-lines-sol-c",
                "content": "***Code is poetry of the binary***\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());int i=0;int j=nums.size()/2;int count=0;\\n        while(i<nums.size()/2&&j<nums.size()){\\n            if(nums[i]*2<=nums[j]){i++;j++;count++;}else j++;\\n        }return count*2;\\n    }\\n};\\n```\\n**logik**\\n1.sort \\n2.make i go from 0 to n/2 and j from n/2 to n \\n3.whenever nums[i]*2<=nums[j] then increment count (as it is a pair) and j++,i++;\\n4.else keep doing j++;\\n5.return 2*count as count is number of pairs and 2*count is number of numbers \\n![image](https://assets.leetcode.com/users/images/268ef4e7-46dd-4e2f-8c3f-cfe1dbee2293_1677476936.8152895.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());int i=0;int j=nums.size()/2;int count=0;\\n        while(i<nums.size()/2&&j<nums.size()){\\n            if(nums[i]*2<=nums[j]){i++;j++;count++;}else j++;\\n        }return count*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235032,
                "title": "easy-cpp-code-binary-search-lower-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort the array.\\n2. Traverse from middle index to the zeroth index.\\n3. At each index i search for an index j that follows the condition(2*nums[i]<=nums[j]).\\n4. After each search if the element is found decrease the end iterator by one for the subseqence search. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int start=(n/2)-1;\\n        int count=0;\\n        for(int i=start;i>=0;i--){\\n            auto it2=nums.end()-count;\\n            auto it1=nums.begin()+start+1;\\n            auto it = lower_bound(it1, it2, 2*nums[i]);\\n            if(it!=it2) count++;\\n        }\\n        return 2*count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int start=(n/2)-1;\\n        int count=0;\\n        for(int i=start;i>=0;i--){\\n            auto it2=nums.end()-count;\\n            auto it1=nums.begin()+start+1;\\n            auto it = lower_bound(it1, it2, 2*nums[i]);\\n            if(it!=it2) count++;\\n        }\\n        return 2*count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234916,
                "title": "reverse-sort-and-two-pointers",
                "content": "# Original solution (easiest to understand):\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        h = n // 2\\n        l = nums[:h]\\n        r = nums[h:]\\n        c = 0\\n        while l and r:\\n            if 2 * l[0] <= r[0]:\\n                l.pop(0)\\n                r.pop(0)\\n                c += 2\\n            else:\\n                r.pop(0)\\n        return c\\n```\\n\\n# Reversed (because popping from right is faster)\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        h = n // 2\\n        r = nums[:h]\\n        l = nums[h:]\\n        c = 0\\n        while l and r:\\n            if 2 * l[-1] <= r[-1]:\\n                l.pop()\\n                r.pop()\\n                c += 2\\n            else:\\n                r.pop()\\n        return c\\n```\\n# Converted to two pointers\\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        h = n // 2\\n        c = 0\\n        i = h - 1\\n        j = n - 1\\n        while i >= 0 and j >= h:\\n            if 2 * nums[j] <= nums[i]:\\n                i -= 1\\n                j -= 1\\n                c += 2\\n            else:\\n                i -= 1\\n        return c\\n```\\n\\nProbably should have converted the original solution to two pointers instead, but ayeeee.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        h = n // 2\\n        l = nums[:h]\\n        r = nums[h:]\\n        c = 0\\n        while l and r:\\n            if 2 * l[0] <= r[0]:\\n                l.pop(0)\\n                r.pop(0)\\n                c += 2\\n            else:\\n                r.pop(0)\\n        return c\\n```\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        h = n // 2\\n        r = nums[:h]\\n        l = nums[h:]\\n        c = 0\\n        while l and r:\\n            if 2 * l[-1] <= r[-1]:\\n                l.pop()\\n                r.pop()\\n                c += 2\\n            else:\\n                r.pop()\\n        return c\\n```\n```python\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        n = len(nums)\\n        h = n // 2\\n        c = 0\\n        i = h - 1\\n        j = n - 1\\n        while i >= 0 and j >= h:\\n            if 2 * nums[j] <= nums[i]:\\n                i -= 1\\n                j -= 1\\n                c += 2\\n            else:\\n                i -= 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234900,
                "title": "two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans=0,n = nums.size(), lp =0, rp =n/2;\\n        while( lp < n/2 and rp <= n-1){\\n            if( 2*nums[lp]<= nums[rp]){\\n                ans+=2;\\n                lp++;\\n                \\n            }\\n         rp++;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans=0,n = nums.size(), lp =0, rp =n/2;\\n        while( lp < n/2 and rp <= n-1){\\n            if( 2*nums[lp]<= nums[rp]){\\n                ans+=2;\\n                lp++;\\n                \\n            }\\n         rp++;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234646,
                "title": "python-2-pointers-most-readable-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        start = 0\\n        end = n//2\\n        ans = 0\\n\\n        while(end<n and start<n//2):\\n            if(nums[end]>=2*nums[start]):\\n                ans+=2\\n                start += 1\\n                end += 1\\n            else:\\n                end += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        start = 0\\n        end = n//2\\n        ans = 0\\n\\n        while(end<n and start<n//2):\\n            if(nums[end]>=2*nums[start]):\\n                ans+=2\\n                start += 1\\n                end += 1\\n            else:\\n                end += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234543,
                "title": "javascript-sorting-two-pointers",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function (nums) {\\n  nums.sort((a, b) => a - b);\\n  const half = Math.floor(nums.length / 2);\\n\\n  let ans = 0;\\n  let i = 0;\\n  let j = half;\\n  while (i < half && j < nums.length) {\\n    if (nums[i] * 2 <= nums[j]) {\\n      ans += 2;\\n      i++;\\n      j++;\\n    } else {\\n      j++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function (nums) {\\n  nums.sort((a, b) => a - b);\\n  const half = Math.floor(nums.length / 2);\\n\\n  let ans = 0;\\n  let i = 0;\\n  let j = half;\\n  while (i < half && j < nums.length) {\\n    if (nums[i] * 2 <= nums[j]) {\\n      ans += 2;\\n      i++;\\n      j++;\\n    } else {\\n      j++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3234476,
                "title": "c-5-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int res = 0;\\n        for(int i=0, n = nums.size(), j = n/2; i<n/2 && j<n;)\\n            nums[i] * 2  <= nums[j] ? i++, j++, res++ : j++;\\n        return res*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int res = 0;\\n        for(int i=0, n = nums.size(), j = n/2; i<n/2 && j<n;)\\n            nums[i] * 2  <= nums[j] ? i++, j++, res++ : j++;\\n        return res*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234187,
                "title": "c-greedy-two-pointers",
                "content": "# Intuition\\nBacktracking is TLE, there is no good key to use for memoization\\n\\nGreedy:\\n- we can sort nums, the indices don\\'t matter\\n- there are at max n/2 i\\'s and n/2 j\\'s\\n- the best approach is point i to 0 point j to (n + 1) / 2\\n- if nums[i] * 2 >= nums[j]\\n    mark them\\n- else \\n    increment j\\n\\n\\nO(nlgn) time\\nO(n) space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // 2,3,4,5\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int i = 0;\\n        int j = (nums.size() + 1) >> 1;\\n\\n        while (j < nums.size()) {\\n            if ((nums[i] << 1) <= nums[j]) {\\n                ans += 2;\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 2,3,4,5\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int i = 0;\\n        int j = (nums.size() + 1) >> 1;\\n\\n        while (j < nums.size()) {\\n            if ((nums[i] << 1) <= nums[j]) {\\n                ans += 2;\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234148,
                "title": "python-solution-with-video-explanation",
                "content": "**Detailed Video Explanation**\\nhttps://youtu.be/H3YIq2lea7Y\\n\\n# Approach\\n- sort the array \\n- We can make at most n//2 pairs, its always better for i to pick the smallest available number and pair it with the smallest valid number at j (valid means 2 * nums[i] <= nums[j])\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        count = 0\\n        i = 0\\n\\n        for j in range((n + 1)//2, n):\\n            if nums[j] >= 2*nums[i]: # (i, j) is a valid pair\\n                i += 1\\n                count += 2\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        count = 0\\n        i = 0\\n\\n        for j in range((n + 1)//2, n):\\n            if nums[j] >= 2*nums[i]: # (i, j) is a valid pair\\n                i += 1\\n                count += 2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234070,
                "title": "c-solution-sort-two-pointerss",
                "content": "# Intuition\\nSort the array first, then cut the array into lower half and upper half, then use two pointers.\\n\\n# Complexity\\n- Time complexity:\\nO(N * log(N)) + O(N / 2) = O(N * log(N))\\n\\n- Space complexity:\\nO(1), there is no extra space used\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size == 1) return 0;\\n        sort(nums.begin(), nums.end());\\n        int pos1 = 0, pos2 = size / 2, res = 0;\\n        while(pos1 < size / 2 && pos2 < size){\\n            if(2 * nums[pos1] <= nums[pos2]){\\n                res += 2;\\n                pos1++;\\n            }\\n            pos2++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size == 1) return 0;\\n        sort(nums.begin(), nums.end());\\n        int pos1 = 0, pos2 = size / 2, res = 0;\\n        while(pos1 < size / 2 && pos2 < size){\\n            if(2 * nums[pos1] <= nums[pos2]){\\n                res += 2;\\n                pos1++;\\n            }\\n            pos2++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234045,
                "title": "two-pointers-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n* Order doesn\\'t matter, so sorting the array certainly helps. It\\'s size is not too large, so we have time to do so.\\n* After sorting, sliding window with 2 pointers seems like a good solution. Meaning we go through the array with 2 pointers, left and right, and mark pairs as we go.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n* Sort the array first\\n* Initialize the pointers: one at the beginning of the array, the other one at the middle. Why at the middle? Because we don\\'t want to pair indices at the beginning, and then end up with similar sized items at the end of the array.\\n* For each left index, increase the right index until it\\'s 2 times the size of the left one. When it is, mark them\\n* Don\\'t forget to skip the left index if it\\'s already marked as a right one.\\n* Finish when the right index reaches end of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n)), for sorting the array. Later part of the algorithm has O(n) complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) because we add indices to the marked arrays.\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        Set<Integer> marked = new HashSet<>();\\n        // get the pointer to the middle of the array\\n        int right = nums.length / 2;\\n        for (int left = 0; left < nums.length; left++) {\\n            // if we have already marked left index, as right\\n            if (!marked.contains(left)) {\\n                // increase right until it\\'s double the size of left, or until the end\\n                while (right < nums.length - 1 && nums[right] < nums[left] * 2) {\\n                    right++;\\n                }\\n                // check again if right is twice as big as left. It may not be so, if we stopped \\n                // increasing it because we reahed the end of the array.\\n                if (nums[right] >= nums[left] * 2) {\\n                    marked.add(left);\\n                    marked.add(right);\\n                    right++;\\n                }\\n                // if we reached the end of the array, that\\'s it, no more pairs to be found\\n                if (right == nums.length) {\\n                    break;\\n                }\\n            }\\n        }\\n        return marked.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        Set<Integer> marked = new HashSet<>();\\n        // get the pointer to the middle of the array\\n        int right = nums.length / 2;\\n        for (int left = 0; left < nums.length; left++) {\\n            // if we have already marked left index, as right\\n            if (!marked.contains(left)) {\\n                // increase right until it\\'s double the size of left, or until the end\\n                while (right < nums.length - 1 && nums[right] < nums[left] * 2) {\\n                    right++;\\n                }\\n                // check again if right is twice as big as left. It may not be so, if we stopped \\n                // increasing it because we reahed the end of the array.\\n                if (nums[right] >= nums[left] * 2) {\\n                    marked.add(left);\\n                    marked.add(right);\\n                    right++;\\n                }\\n                // if we reached the end of the array, that\\'s it, no more pairs to be found\\n                if (right == nums.length) {\\n                    break;\\n                }\\n            }\\n        }\\n        return marked.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233949,
                "title": "javascript-solution-based-on-kreakemp-s-great-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Based on the idea from leetcode solution\\n *\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function (nums) {\\n  const LEN = nums.length;\\n  const HALFLEN = Math.floor(nums.length / 2 - 1);\\n  nums.sort((a, b) => a - b);\\n\\n  let ans = 0;\\n  let lo = HALFLEN;\\n  let hi = LEN - 1;\\n  while (lo >= 0 && hi > HALFLEN) {\\n    if (nums[hi] >= 2 * nums[lo]) {\\n      ans++;\\n      hi--;\\n    }\\n\\n    lo--;\\n  }\\n\\n  return ans * 2;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Based on the idea from leetcode solution\\n *\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxNumOfMarkedIndices = function (nums) {\\n  const LEN = nums.length;\\n  const HALFLEN = Math.floor(nums.length / 2 - 1);\\n  nums.sort((a, b) => a - b);\\n\\n  let ans = 0;\\n  let lo = HALFLEN;\\n  let hi = LEN - 1;\\n  while (lo >= 0 && hi > HALFLEN) {\\n    if (nums[hi] >= 2 * nums[lo]) {\\n      ans++;\\n      hi--;\\n    }\\n\\n    lo--;\\n  }\\n\\n  return ans * 2;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3233851,
                "title": "java-weekly-contest-334-two-pointers-beat-100-tc-o-n",
                "content": "# Approach\\n1. Try to use Two pointers to solve the issue. In order to use it, I need to have the array sorted. The sort part takes O(nlogn).\\n2. Two pointers, one points(j) to the largest number started from the end of the sorted array; another one(i) points to the most suitable solution that satisfies ```2 * nums[i] <= nums[j] ```\\n3. The best start index of i might be the middle of the array. However, if this number doesn\\'t satisfy ```2 * nums[i] <= nums[j] ```, we need to move it to the right until it finds the first index that works. \\n4. Once find the first i that works, try to go through the whole array and find all marked indices. \\n\\nPlease upvote if it makes sense. Thank you!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) + O(n) = O(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int total = 0;\\n        int endIndex = nums.length - 1;\\n        int startIndex = endIndex;\\n        int midIndex = nums.length / 2 - 1 ;\\n        if (midIndex < 0)\\n            return 0;\\n        if (nums[midIndex] * 2 <= nums[endIndex])\\n            startIndex = midIndex;\\n        else {\\n            startIndex = midIndex;\\n            // FIND FIRST POSSIBLE INDEX\\n            while (startIndex >= 0 && nums[startIndex] * 2 > nums[endIndex]) {\\n                startIndex --;\\n            }\\n        }\\n\\n        if (startIndex == -1)\\n            return 0;\\n        int[] marked = new int[nums.length];\\n        while (startIndex >= 0) {\\n            if (marked[endIndex] == 1) {\\n                endIndex --;\\n            }\\n            else {\\n                // CASE 1 - MATCH\\n                if (nums[startIndex] * 2 <= nums[endIndex]) {\\n                    total += 2;\\n                    marked[startIndex] = 1;\\n                    marked[endIndex] = 1;\\n                    startIndex --;\\n                    endIndex --;\\n                }   \\n                // CASE 2 - BIGGER \\n                else {\\n                    startIndex --;\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```2 * nums[i] <= nums[j] ```\n```2 * nums[i] <= nums[j] ```\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int total = 0;\\n        int endIndex = nums.length - 1;\\n        int startIndex = endIndex;\\n        int midIndex = nums.length / 2 - 1 ;\\n        if (midIndex < 0)\\n            return 0;\\n        if (nums[midIndex] * 2 <= nums[endIndex])\\n            startIndex = midIndex;\\n        else {\\n            startIndex = midIndex;\\n            // FIND FIRST POSSIBLE INDEX\\n            while (startIndex >= 0 && nums[startIndex] * 2 > nums[endIndex]) {\\n                startIndex --;\\n            }\\n        }\\n\\n        if (startIndex == -1)\\n            return 0;\\n        int[] marked = new int[nums.length];\\n        while (startIndex >= 0) {\\n            if (marked[endIndex] == 1) {\\n                endIndex --;\\n            }\\n            else {\\n                // CASE 1 - MATCH\\n                if (nums[startIndex] * 2 <= nums[endIndex]) {\\n                    total += 2;\\n                    marked[startIndex] = 1;\\n                    marked[endIndex] = 1;\\n                    startIndex --;\\n                    endIndex --;\\n                }   \\n                // CASE 2 - BIGGER \\n                else {\\n                    startIndex --;\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233823,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums.size()/2;\\n        while(l<nums.size()/2&&r<nums.size()){\\n            if(2*nums[l]<=nums[r++])\\n            l++;\\n        }\\n        return 2*l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums.size()/2;\\n        while(l<nums.size()/2&&r<nums.size()){\\n            if(2*nums[l]<=nums[r++])\\n            l++;\\n        }\\n        return 2*l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233762,
                "title": "easy-to-understand-two-deques-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nLet\\'s take [2, 4, 5, 9] for example, we have two deques \\'small\\' and \\'large\\', let\\'s say we put 2 into small and 4 into large, now the two deques are:\\n\\nsmall [2]\\nlarge [4]\\n\\n2 in small and 4 in large are matched with each other, now let\\'s work on the next element which is 5, initially we place the 5 into small, since 2 and 4 are matched (used).\\n\\nsmall [2, 5]\\nlarge [4]\\n\\nThe greedy manipulation we can do here is to swap 5 with 4 which is the front of deque \\'large\\', and now we have \\n\\nsmall [2, 4]\\nlarge [5]\\n\\nsince 4 is smaller than 5, it has a better chance to get matched in the future.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSort and process array elements one by one, if we can find a match in \\'small\\' for the current element, add it into \\'large\\', otherwise, we place the current element at the back of \\'large\\', and take out the front of \\'large\\' then append it to \\'small\\' (greedy intuition mentioned above). \\n\\nNotice that if \\'large\\' is empty, we can not use the greedy intuition, we have to append the current element to \\'small\\'. (an example would be arr = [5, 6, 7, 8, 9] in which max = 9 is smaller than 2 * min = 2 * 5 = 10)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n log n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        deque<int> small, large;\\n        int n = nums.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (small.empty() || nums[i] < 2 * nums[small.front()]) {\\n                if (large.empty()) small.push_back(i);\\n                else {\\n                    small.push_back(large.front());\\n                    large.pop_front();\\n                    large.push_back(i);\\n                }\\n            } else {\\n                small.pop_front();\\n                large.push_back(i);\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n        // or equivalently, return (int)(2 * large.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        deque<int> small, large;\\n        int n = nums.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (small.empty() || nums[i] < 2 * nums[small.front()]) {\\n                if (large.empty()) small.push_back(i);\\n                else {\\n                    small.push_back(large.front());\\n                    large.pop_front();\\n                    large.push_back(i);\\n                }\\n            } else {\\n                small.pop_front();\\n                large.push_back(i);\\n                ans += 2;\\n            }\\n        }\\n        return ans;\\n        // or equivalently, return (int)(2 * large.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233729,
                "title": "easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n     //Step01 Sort Array for easy Answer\\n     Arrays.sort(nums);\\n     int n=0;\\n     int m = (nums.length+1)/2;\\n     int res=0;\\n     while(m<nums.length) {\\n         if(nums[n]*2 <= nums[m]){\\n            n++;\\n            res+=2;\\n         }\\n        m++;\\n     }    \\n     return res;\\n     //return n*2;\\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n     //Step01 Sort Array for easy Answer\\n     Arrays.sort(nums);\\n     int n=0;\\n     int m = (nums.length+1)/2;\\n     int res=0;\\n     while(m<nums.length) {\\n         if(nums[n]*2 <= nums[m]){\\n            n++;\\n            res+=2;\\n         }\\n        m++;\\n     }    \\n     return res;\\n     //return n*2;\\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233658,
                "title": "c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe try to search minimum possible number that satisfy given condition.\\nTo output maximum marked index\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this we use binary search to find the minimum possible number in the 2nd half of the sorted array. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int bs(int ind ,int v, vector<int>&vp,vector<int>&anss){\\n        \\n        int low = vp.size()/2, high = vp.size()-1 , ans = -1;\\n        \\n        while(low<=high){\\n            \\n            int mid = (low+high)/2;\\n            \\n            if(vp[mid]>=2*vp[ind]){\\n                if(anss[mid] == 0){\\n                 ans = mid;\\n                 high  = mid-1; \\n                }\\n                 else{\\n                low = mid+1;\\n            }\\n            \\n            }\\n            else{\\n                low = mid+1;\\n            }\\n            \\n        }\\n       \\n        return ans;\\n    }\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        \\n        sort(v.begin(),v.end());\\n        vector<int>ans(n,0);\\n        \\n        for(int i =0; i<n/2;i++){\\n            cout<<bs(i,v[i],v,ans)<<\"\\\\n\";\\n              if(bs(i,v[i],v,ans)!=-1){\\n                    ans[bs(i,v[i],v,ans)] = 1;\\n                    ans[i] = 1;\\n                  \\n              }\\n        }\\n        \\n        for(int i = 0; i<n; i++){\\n            cout<<ans[i]<<\" \";\\n            if(ans[i]==1){\\n                cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bs(int ind ,int v, vector<int>&vp,vector<int>&anss){\\n        \\n        int low = vp.size()/2, high = vp.size()-1 , ans = -1;\\n        \\n        while(low<=high){\\n            \\n            int mid = (low+high)/2;\\n            \\n            if(vp[mid]>=2*vp[ind]){\\n                if(anss[mid] == 0){\\n                 ans = mid;\\n                 high  = mid-1; \\n                }\\n                 else{\\n                low = mid+1;\\n            }\\n            \\n            }\\n            else{\\n                low = mid+1;\\n            }\\n            \\n        }\\n       \\n        return ans;\\n    }\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& v) {\\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        \\n        sort(v.begin(),v.end());\\n        vector<int>ans(n,0);\\n        \\n        for(int i =0; i<n/2;i++){\\n            cout<<bs(i,v[i],v,ans)<<\"\\\\n\";\\n              if(bs(i,v[i],v,ans)!=-1){\\n                    ans[bs(i,v[i],v,ans)] = 1;\\n                    ans[i] = 1;\\n                  \\n              }\\n        }\\n        \\n        for(int i = 0; i<n; i++){\\n            cout<<ans[i]<<\" \";\\n            if(ans[i]==1){\\n                cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3233588,
                "title": "easy-java-solution-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n       int i=0;\\n       int j=nums.length/2;\\n       while( i<=nums.length-1 && j<nums.length){\\n           if(nums[i]==-1){\\n               i++;\\n               continue;\\n           }\\n           if(nums[j]==-1){\\n               j++;\\n               continue;\\n           }\\n           int ch=2*nums[i];\\n           if(ch<=nums[j]){\\n               nums[i]=-1;\\n               nums[j]=-1;\\n               i++;\\n               j++;\\n           }else if(ch>nums[j]){\\n               j++;\\n           }\\n       }\\n       int count=0;\\n       for(int k=0; k<nums.length;k++){\\n           if(nums[k]==-1){\\n               count++;\\n           }\\n       }\\n       return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n       int i=0;\\n       int j=nums.length/2;\\n       while( i<=nums.length-1 && j<nums.length){\\n           if(nums[i]==-1){\\n               i++;\\n               continue;\\n           }\\n           if(nums[j]==-1){\\n               j++;\\n               continue;\\n           }\\n           int ch=2*nums[i];\\n           if(ch<=nums[j]){\\n               nums[i]=-1;\\n               nums[j]=-1;\\n               i++;\\n               j++;\\n           }else if(ch>nums[j]){\\n               j++;\\n           }\\n       }\\n       int count=0;\\n       for(int k=0; k<nums.length;k++){\\n           if(nums[k]==-1){\\n               count++;\\n           }\\n       }\\n       return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1814758,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1821469,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1817331,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1814725,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1846460,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1839253,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1816049,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            },
            {
                "id": 1815293,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "The problem can be solved using a greedy approach. We need to mark pairs of indices in the array such that 2 * nums[i] <= nums[j], where i and j are unmarked indices. We want to mark as many pairs as possible, so we should try to mark the pairs that allow for the most remaining pairs to be marked.\\n\\nTo achieve this, we can first sort the array in non-decreasing order. We can then use two pointers, one starting from the beginning of the array and the other starting from the middle of the array (rounded up). We can then iterate over the array from the middle pointer to the end pointer. For each pair of indices (i, j) where i is the index pointed to by the beginning pointer and j is the index pointed to by the middle pointer, we check if 2 * nums[i] <= nums[j]. If this condition is true, we can mark the indices i and j, and move the beginning pointer to the next unmarked index. Otherwise, we move the middle pointer to the next index.\\n\\nWe continue this process until the middle pointer reaches the end of the array. The maximum number of marked indices is twice the value of the beginning pointer, since we mark pairs of indices."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Took me a while to get there as I was using binary search. I kept TLE as I was reslicing two arrays rather than using pointers. Once I realized that I could use pointers (and Pythons bisect method takes a start and stop pointer as optional args to its built in binary search method) I got it. Keep searching until the insert index for \"curr_largest//2\" is -1, indicating there is no existing number small enough. "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Help:-\\nhttps://leetcode.com/problems/find-the-maximum-number-of-marked-indices/solutions/3230953/javascript-code-with-approach/"
                    },
                    {
                        "username": "halfengineer",
                        "content": "testcase 50/68\\uD83D\\uDE29"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The hints point to a more complicated solution (i.e. bisection) than the greedy approach.\\nThey should be changed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I mean, you can definitely do it with bisect. I did. "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Sorting with two pointers work well.\\nI expected more no of people to do this correct."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "Firstly sort the array, and then you have to think about your maximum possible answer. I think this will help you to do this problem. "
                    },
                    {
                        "username": "surajsingh907668",
                        "content": "TC: O(nlogn)\\nclass Solution {\\npublic:\\n    int maxNumOfMarkedIndices(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int index, sum = 0;\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            nums[i] *= 2;\\n        }\\n        for(int i = 0; i < nums.size()/2; i++) {\\n            index = lower_bound(nums.begin()+nums.size()/2, nums.end(), nums[i]) - nums.begin();\\n            if(index != nums.size()) {\\n                sum += 2;\\n                nums[index] = -1;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Don\\'t share solution in the discuss"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I have doubt regarding where to start loop in this problem.\\nI ran the code without starting the loop from `n-n/2` many times but I didn\\'t understand why this is happening. \\nWhy we should start loop from `n-n/2` instead of  `n/2`?\\nIf anybody know then please tell me"
                    },
                    {
                        "username": "subhash_27",
                        "content": "for max we have to pair the first (n/2) elements to pair that we have to check last (n/2) elements not the elements from (n/2)\\n"
                    },
                    {
                        "username": "sameershekhar100",
                        "content": "Can anybody help why this approach is failing\n  \n\n     `int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int ans=0;\n        vector<bool> vis(nums.size(),0);\n        for(int i=0;i<nums.size();i++){\n            if(vis[i]) continue;\n            int z=lower_bound(nums.begin()+i+1,nums.end(),2*nums[i])-nums.begin();\n            while(z< nums.size() and vis[z]) z++;\n            if(z<nums.size() and  vis[z]==0) {\n                ans++;\n                vis[i]=1;\n                vis[z]=1;\n            }\n            \n        }\n        return ans*2;\n    } `"
                    },
                    {
                        "username": "Steinz",
                        "content": "Your Code doesn\\'t work for sample case 2, reason being:\\nwhile iterating at index i=0, the value of z is equal to 1 as 4>=2, and it is marked as visited, now for {5, 9}, no index can be found to satisfy the condition. The answer of your code is hence 2 as the only valid pair according to it is {2, 4}.\\nBut as mentioned in the explanation, the answer should be 4, with valid pairs being, {2, 5} and {4, 9} as both satisfy the condition."
                    },
                    {
                        "username": "coder42032",
                        "content": "same thing with my code i also write this type of code but it is not working on testcase 10."
                    }
                ]
            }
        ]
    }
]