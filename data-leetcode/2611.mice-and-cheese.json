[
    {
        "title": "Mice and Cheese",
        "question_content": "There are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse.\nA point of the cheese with index i (0-indexed) is:\n\n\treward1[i] if the first mouse eats it.\n\treward2[i] if the second mouse eats it.\n\nYou are given a positive integer array reward1, a positive integer array reward2, and a non-negative integer k.\nReturn the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.\n&nbsp;\nExample 1:\n\nInput: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\nOutput: 15\nExplanation: In this example, the first mouse eats the 2nd&nbsp;(0-indexed) and the 3rd&nbsp;types of cheese, and the second mouse eats the 0th&nbsp;and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\nExample 2:\n\nInput: reward1 = [1,1], reward2 = [1,1], k = 2\nOutput: 2\nExplanation: In this example, the first mouse eats the 0th&nbsp;(0-indexed) and 1st&nbsp;types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n&nbsp;\nConstraints:\n\n\t1 <= n == reward1.length == reward2.length <= 105\n\t1 <= reward1[i],&nbsp;reward2[i] <= 1000\n\t0 <= k <= n",
        "solutions": [
            {
                "id": 3368300,
                "title": "easy-c-priority-queue-solution",
                "content": "# Intuition\\n![IMG20230402090941.jpg](https://assets.leetcode.com/users/images/a9b8b85b-6a50-48a4-8424-d9a066afd7bc_1680408070.6846004.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>&r1, vector<int>& r2, int k) {\\n       priority_queue<int>pq;\\n        long long int ans=0;\\n        for(int i=0;i<r1.size();i++){\\n           pq.push(r1[i]-r2[i]);\\n            ans+=r2[i];\\n        }\\n        while(k!=0){\\n          ans+=pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>&r1, vector<int>& r2, int k) {\\n       priority_queue<int>pq;\\n        long long int ans=0;\\n        for(int i=0;i<r1.size();i++){\\n           pq.push(r1[i]-r2[i]);\\n            ans+=r2[i];\\n        }\\n        while(k!=0){\\n          ans+=pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368322,
                "title": "java-c-python-k-largest-a-i-b-i",
                "content": "# **Explanation**\\nAssume take all from the second array.\\nCheck the difference sequence:\\n`A[0] - B[0], A[1] - B[1], ...`\\n\\nTake `k` largest from the sequence and sum up.\\n\\nReturn the `res = sum(B) + sum(k largest A[i]-B[i])`\\n<br>\\n\\n# **Complexity**\\nJava uses sort\\nTime `O(nlog)` Space `O(n)`\\n\\nPython uses heap\\nTime `O(klogk)` Space `O(k)`\\n\\nC++ uses quick select would be\\nTime `O(n)` Space `O(n)`\\n<br>\\n\\n\\n**Java**\\n```java\\n    public int miceAndCheese(int[] A, int[] B, int k) {\\n        int res = 0, n = A.length, diff[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = A[i] - B[i];\\n            res += B[i];\\n        }\\n        Arrays.sort(diff);\\n        for (int i = 0; i < k; i++)\\n            res += diff[n - 1 - i];\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int miceAndCheese(vector<int> A, vector<int>& B, int k) {\\n        int n = A.size(), res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            A[i] -= B[i];\\n            res += B[i];\\n        }\\n        nth_element(A.begin(), A.begin() + k, A.end(), greater<int>());\\n        return accumulate(A.begin(), A.begin() + k, res);\\n    }\\n```\\n**Python**\\n```py\\n    def miceAndCheese(self, A: List[int], B: List[int], k: int) -> int:\\n        return sum(B) + sum(nlargest(k, (a - b for a, b in zip(A, B))))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int miceAndCheese(int[] A, int[] B, int k) {\\n        int res = 0, n = A.length, diff[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = A[i] - B[i];\\n            res += B[i];\\n        }\\n        Arrays.sort(diff);\\n        for (int i = 0; i < k; i++)\\n            res += diff[n - 1 - i];\\n        return res;\\n    }\\n```\n```cpp\\n    int miceAndCheese(vector<int> A, vector<int>& B, int k) {\\n        int n = A.size(), res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            A[i] -= B[i];\\n            res += B[i];\\n        }\\n        nth_element(A.begin(), A.begin() + k, A.end(), greater<int>());\\n        return accumulate(A.begin(), A.begin() + k, res);\\n    }\\n```\n```py\\n    def miceAndCheese(self, A: List[int], B: List[int], k: int) -> int:\\n        return sum(B) + sum(nlargest(k, (a - b for a, b in zip(A, B))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3368552,
                "title": "dry-run-image-explanation-sorting-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Make a vector of pairs and store difference,index in each pair.\\n2. Sort the vector in descending order such that maximum values are taken in the sum.\\n3. Iterate till <k in this vector arr in which the x.second of pair stores the index of reward1. Add reward1[index] in sum.\\n4. Iterate from k till <n in this vector arr in which the x.second of pair stores the index of reward2. Add reward2[index] in sum.\\n\\n\\n![leetcode C 339.jpg](https://assets.leetcode.com/users/images/818e3ce0-50c6-488b-9df1-1ad5167d014f_1680408537.6465707.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int sum = 0, n = reward1.size();\\n        vector<pair<int,int>> arr;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int diff = reward1[i]-reward2[i];\\n            arr.push_back({diff,i}); //storing pair of difference, index\\n        }\\n        \\n        sort(arr.begin(),arr.end());\\n        reverse(arr.begin(),arr.end()); // sorted in descending order\\n        \\n        int i;\\n        for(i=0;i<k;i++) //add k values from reward1\\n        {\\n            auto x = arr[i];\\n            int index = x.second;\\n            sum += reward1[index];\\n        }\\n        \\n        for(;i<n;i++) // add remaining values from reward2\\n        {\\n            auto x = arr[i];\\n            int index = x.second;\\n            sum += reward2[index];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int sum = 0, n = reward1.size();\\n        vector<pair<int,int>> arr;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int diff = reward1[i]-reward2[i];\\n            arr.push_back({diff,i}); //storing pair of difference, index\\n        }\\n        \\n        sort(arr.begin(),arr.end());\\n        reverse(arr.begin(),arr.end()); // sorted in descending order\\n        \\n        int i;\\n        for(i=0;i<k;i++) //add k values from reward1\\n        {\\n            auto x = arr[i];\\n            int index = x.second;\\n            sum += reward1[index];\\n        }\\n        \\n        for(;i<n;i++) // add remaining values from reward2\\n        {\\n            auto x = arr[i];\\n            int index = x.second;\\n            sum += reward2[index];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368253,
                "title": "java-jerry-is-very-good-at-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy with detail and easy understanding math prove.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs $x_i \\u2208 [0,1], a_i \\u2208 reward1, b_i \\u2208 reward2$\\n$x_i=1$ means `mouse1` picks the i-th cheese of `reward1`\\n$x_i=0$ means `mouse2` picks the i-th cheese of `reward2`\\n$\\\\sum_{i = 1}^{n}x_i=x_1+x_2+...+x_n = k$\\n\\nWe can prove that the total points: `p`\\n$p=x_1a_1+x_2a_2+...+x_na_n+\\n    (1-x_1)b_1+(1-x_2)b_2+...+(1-x_n)b_n$\\n$=(b_1+b_2 +...+ b_n)+(a_1-b_1)x_1+(a_2-b_2)x_2 +...+ (a_n-b_n)x_n$\\n$=\\\\sum_{i = 1}^{n}b_i+\\\\sum_{i = 1}^{n}(a_i-b_i)x_i$\\n\\nSince $\\\\sum_{i = 1}^{n}b_i$ and $(a_i-b_i)$ are both constant, and $x_i \\u2208 [0,1]$\\nTo get maximum of `p`, we should pick top `k` value of $(a_i-b_i)$ with greedy, which means set $x_i=1$ for these $(a_i-b_i)$ and `mouse1` **only picks** these indice of cheese from `reward1`, `mouse2` pick the left indice of cheese from `reward2`.\\n\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n  public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n    final int n = reward1.length;\\n    int points = 0;\\n    for (int i = 0; i < n; i++) {\\n      reward1[i] -= reward2[i];\\n      points += reward2[i];\\n    }\\n\\n    // pick top k\\n    Arrays.sort(reward1);\\n    for (int i = 0; i < k; i++) {\\n      points += reward1[n - 1 - i];\\n    }\\n\\n    return points;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n  public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n    final int n = reward1.length;\\n    int points = 0;\\n    for (int i = 0; i < n; i++) {\\n      reward1[i] -= reward2[i];\\n      points += reward2[i];\\n    }\\n\\n    // pick top k\\n    Arrays.sort(reward1);\\n    for (int i = 0; i < k; i++) {\\n      points += reward1[n - 1 - i];\\n    }\\n\\n    return points;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368334,
                "title": "reward1-reward2-sorting-desc-easy-intuitive-explained",
                "content": "### Approach\\nThis is a Greedy approach. From 2 array I want all values from reward2 but also want to replace k values from reward1 which are greater than reward2 (the larger difference will be prioritize first) so that maximum sum can be achieved.\\n\\n### Example 1\\nLet\\'s take an example:\\n[1,9,3,4]\\n[4,4,1,1]\\n2\\n\\nReward2 sum = 10\\nso, diff vector will be : -3, 5, 2, 3\\nafter, desc sorting : 5, 3, 2, -3\\nthis represent what if we take reward1 value istead of reward2.\\nSo, just added this to the sum. So, 10 + 5 = 15; 15 + 3 = 18 (Ans)\\n\\n### Example 2\\n1, 1, 1, 1\\n4, 4, 2, 3\\nk = 2\\nso, reward 2 total sum is : 13\\n-> diff array: -3, -3, -1, -2\\n-> desc sort : -1, -2, -3, -3\\n-> after k num adding: 13 + (-1) = 12; 12 + (-2) = 10 (Ans)\\n\\n### Solution 1 (Easy Vector Sort)\\n**c++**\\n```\\nint miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n    vector<int> v;\\n    long long sum = 0;\\n    for (int i = 0; i < reward1.size(); i++) {\\n        v.push_back(reward1[i] - reward2[i]);\\n        sum += reward2[i];\\n    }\\n\\n    sort(v.begin(), v.end(), greater<int>());\\n\\n    for (int i = 0; i < k; i++)\\n        sum += v[i];\\n\\n    return sum;\\n}\\n```\\n\\n### Solution 2 (Priority Queue)\\nPriority Queue can be used for optimization.\\nRef: https://leetcode.com/problems/kth-largest-element-in-an-array/\\n```\\nint miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    long long sum = 0;\\n    for (int i = 0; i < reward1.size(); i++) {\\n        pq.push(reward1[i] - reward2[i]);\\n        sum += reward2[i];\\n        if (pq.size() > k)\\n            pq.pop();\\n    }\\n\\n    while (!pq.empty())\\n    {\\n        sum += pq.top();\\n        pq.pop();\\n    }\\n\\n    return sum;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n    vector<int> v;\\n    long long sum = 0;\\n    for (int i = 0; i < reward1.size(); i++) {\\n        v.push_back(reward1[i] - reward2[i]);\\n        sum += reward2[i];\\n    }\\n\\n    sort(v.begin(), v.end(), greater<int>());\\n\\n    for (int i = 0; i < k; i++)\\n        sum += v[i];\\n\\n    return sum;\\n}\\n```\n```\\nint miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    long long sum = 0;\\n    for (int i = 0; i < reward1.size(); i++) {\\n        pq.push(reward1[i] - reward2[i]);\\n        sum += reward2[i];\\n        if (pq.size() > k)\\n            pq.pop();\\n    }\\n\\n    while (!pq.empty())\\n    {\\n        sum += pq.top();\\n        pq.pop();\\n    }\\n\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368272,
                "title": "c-sorting",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b)\\n    {\\n        return a[0] > b[0];\\n    }\\n    int miceAndCheese(vector<int> &reward1, vector<int> &reward2, int k)\\n    {\\n        vector<vector<int>> arr;\\n        for (int i = 0; i < reward1.size(); i++)\\n        {\\n            arr.push_back({reward1[i] - reward2[i], reward1[i], reward2[i]});\\n        }\\n        sort(arr.begin(), arr.end(), comp);\\n        int ans = 0;\\n        int i = 0;\\n        while (k > 0)\\n        {\\n            ans += arr[i][1];\\n            i++;\\n            k--;\\n        }\\n        for (; i < arr.size(); i++)\\n            ans += arr[i][2];\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b)\\n    {\\n        return a[0] > b[0];\\n    }\\n    int miceAndCheese(vector<int> &reward1, vector<int> &reward2, int k)\\n    {\\n        vector<vector<int>> arr;\\n        for (int i = 0; i < reward1.size(); i++)\\n        {\\n            arr.push_back({reward1[i] - reward2[i], reward1[i], reward2[i]});\\n        }\\n        sort(arr.begin(), arr.end(), comp);\\n        int ans = 0;\\n        int i = 0;\\n        while (k > 0)\\n        {\\n            ans += arr[i][1];\\n            i++;\\n            k--;\\n        }\\n        for (; i < arr.size(); i++)\\n            ans += arr[i][2];\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368256,
                "title": "python-heap-in-depth-explanation",
                "content": "\\n\\nWe want to maximize the total reward by selecting \\'k\\' values from reward1 and everything remaining from reward2. To achieve this, we need to carefully choose values from reward1, as selecting an index in reward1 will make that index unavailable in reward2.\\n\\nTo determine the best selection, we first calculate the differences between the corresponding elements of reward2 and reward1. Then, we identify the \\'k\\' largest positive differences, which indicate the most optimal selections from reward1.\\n\\nConsider the example with reward1 = [4, 2, 1] and reward2 = [2, 5, 10]. The differences are calculated as follows: 2 - 4 = -2, 5 - 2 = 3, 10 - 1 = 9, resulting in the array [(-2, 0), (3, 1), (9, 2)]. Notice that we keep track of the index by storing tuples (value, index). In this case, if k = 2, we should select the values 4 and 2 from reward1, as they correspond to the largest positive differences. Next, we can take the remaining available value from reward2, which is 10.\\n\\nBy following this approach, we can achieve the maximum total reward, which is the sum of these values: 4 + 2 + 10 = 16.\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        output = 0\\n        n = len(reward1)\\n        heap = []\\n        for i in range(n):\\n            heap.append((reward2[i] - reward1[i], i))\\n            \\n        heapq.heapify(heap)\\n        visited = set()\\n        while k:\\n            k -= 1\\n            _, idx = heapq.heappop(heap)\\n            visited.add(idx)\\n            output += reward1[idx]\\n            \\n        # If there is anything left that has not been taken, we take it from reward2.\\n        for idx, val in enumerate(reward2):\\n            if idx in visited:\\n                continue\\n            output += val\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        output = 0\\n        n = len(reward1)\\n        heap = []\\n        for i in range(n):\\n            heap.append((reward2[i] - reward1[i], i))\\n            \\n        heapq.heapify(heap)\\n        visited = set()\\n        while k:\\n            k -= 1\\n            _, idx = heapq.heappop(heap)\\n            visited.add(idx)\\n            output += reward1[idx]\\n            \\n        # If there is anything left that has not been taken, we take it from reward2.\\n        for idx, val in enumerate(reward2):\\n            if idx in visited:\\n                continue\\n            output += val\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368332,
                "title": "go-greedy",
                "content": "# Approach\\n\\nWe will greedily pick those indices from reward1 which will incur more profit ultimately.\\n        \\n        Consider the example :\\n        reward1 = {3, 3}\\n        reward2 = {3, 5}\\n        k = 1\\n\\n        Hence we will be choosing indices which will make less loss (or more profit).\\n        \\n        reward1-reward2 = {0, -2}\\n            It means,\\n                if we choose index 0 -> it will incur 0 loss\\n                if we choose index 1 -> it will incur -2 loss\\n            Thus if we are allowed to choose a single index, we will be greedily choosing index 0. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k, int ret = 0) {\\n        int n = reward1.size(), sum = 0;\\n        priority_queue<pair<int, int>>q;\\n        for(int i = 0; i < n; i++)\\n            q.push({reward1[i]-reward2[i], i});\\n        \\n        vector<bool>visited(n, false);   \\n        while(k > 0){\\n            int ind = q.top().second;\\n            q.pop();\\n            sum += reward1[ind];\\n            visited[ind]=true;\\n            k--;\\n        }\\n        for(int i=0;i<reward1.size();i++)\\n            if(!visited[i])\\n                sum+=reward2[i];\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k, int ret = 0) {\\n        int n = reward1.size(), sum = 0;\\n        priority_queue<pair<int, int>>q;\\n        for(int i = 0; i < n; i++)\\n            q.push({reward1[i]-reward2[i], i});\\n        \\n        vector<bool>visited(n, false);   \\n        while(k > 0){\\n            int ind = q.top().second;\\n            q.pop();\\n            sum += reward1[ind];\\n            visited[ind]=true;\\n            k--;\\n        }\\n        for(int i=0;i<reward1.size();i++)\\n            if(!visited[i])\\n                sum+=reward2[i];\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368297,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n log n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        List<Pair<Integer, Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < reward1.length; i++) {\\n            ans.add(new Pair<>(reward1[i] - reward2[i], i));\\n        }\\n        Collections.sort(ans, new Comparator<Pair<Integer, Integer>>() {\\n            @Override\\n            public int compare(Pair<Integer, Integer> o1, Pair<Integer, Integer> o2) {\\n                return o2.getKey().compareTo(o1.getKey());\\n            }\\n        });\\n        //Collections.sort(ans, Collections.reverseOrder());\\n        int max = 0;\\n        for (int i = 0; i < k; i++) {\\n            max += reward1[ans.get(i).getValue()];\\n        }\\n        for (int i = k; i < ans.size(); i++) {\\n            max += reward2[ans.get(i).getValue()];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        List<Pair<Integer, Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < reward1.length; i++) {\\n            ans.add(new Pair<>(reward1[i] - reward2[i], i));\\n        }\\n        Collections.sort(ans, new Comparator<Pair<Integer, Integer>>() {\\n            @Override\\n            public int compare(Pair<Integer, Integer> o1, Pair<Integer, Integer> o2) {\\n                return o2.getKey().compareTo(o1.getKey());\\n            }\\n        });\\n        //Collections.sort(ans, Collections.reverseOrder());\\n        int max = 0;\\n        for (int i = 0; i < k; i++) {\\n            max += reward1[ans.get(i).getValue()];\\n        }\\n        for (int i = k; i < ans.size(); i++) {\\n            max += reward2[ans.get(i).getValue()];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368259,
                "title": "sort-deltas",
                "content": "We use an index array, and we sort it by `r1[i] - r2[i]`, descending.\\n\\nThen, we take `k` values from the first array, and the rest - from the second one.\\n\\n**C++**\\n```cpp\\nint miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n    vector<int> idx(r1.size());\\n    iota(begin(idx), end(idx), 0);\\n    nth_element(begin(idx), begin(idx) + k, end(idx), [&](int i, int j){\\n        return r1[i] - r2[i] > r1[j] - r2[j];\\n    });\\n    return accumulate(begin(idx), begin(idx) + k, 0, [&](int s, int i) { return s + r1[i]; }) +\\n        accumulate(begin(idx) + k, end(idx), 0, [&](int s, int i) { return s + r2[i]; });\\n}\\n```\\n**C++**\\nA nice alternative proposed by [0xFFFFFFFF](https://leetcode.com/0xFFFFFFFF/).\\n```cpp\\nint miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n    transform(begin(r1), end(r1), begin(r2), begin(r1), minus<int>());\\n    nth_element(begin(r1), begin(r1) + k, end(r1), greater<int>());\\n    return accumulate(begin(r1), begin(r1) + k, \\n        accumulate(begin(r2), end(r2), 0));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n    vector<int> idx(r1.size());\\n    iota(begin(idx), end(idx), 0);\\n    nth_element(begin(idx), begin(idx) + k, end(idx), [&](int i, int j){\\n        return r1[i] - r2[i] > r1[j] - r2[j];\\n    });\\n    return accumulate(begin(idx), begin(idx) + k, 0, [&](int s, int i) { return s + r1[i]; }) +\\n        accumulate(begin(idx) + k, end(idx), 0, [&](int s, int i) { return s + r2[i]; });\\n}\\n```\n```cpp\\nint miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n    transform(begin(r1), end(r1), begin(r2), begin(r1), minus<int>());\\n    nth_element(begin(r1), begin(r1) + k, end(r1), greater<int>());\\n    return accumulate(begin(r1), begin(r1) + k, \\n        accumulate(begin(r2), end(r2), 0));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368737,
                "title": "sorting-c-easy-solution",
                "content": "```\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int,int>> v;\\n        int n = reward1.size();\\n        \\n        for(int i=0;i<n;i++)\\n            v.push_back({reward1[i]-reward2[i],i});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        int ans = 0;\\n        int i = n-1;\\n        while(k)\\n        {\\n            ans+= reward1[v[i].second];\\n            i--;\\n            k--;\\n        }\\n        while(i>=0)\\n        {\\n            ans+= reward2[v[i].second];\\n            i--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int,int>> v;\\n        int n = reward1.size();\\n        \\n        for(int i=0;i<n;i++)\\n            v.push_back({reward1[i]-reward2[i],i});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        int ans = 0;\\n        int i = n-1;\\n        while(k)\\n        {\\n            ans+= reward1[v[i].second];\\n            i--;\\n            k--;\\n        }\\n        while(i>=0)\\n        {\\n            ans+= reward2[v[i].second];\\n            i--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368621,
                "title": "very-easy-to-understand-intuitive-approach-minimal-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn important thing to notice is that both mice will try to maximize their scores. Therefore the absolute value of the differences of their scores (mouse1_score - mouse2_score) should be minimum. So for the first mouse we pick the k cheeses such that the difference is the maximum and for the second mouse we pick n-k cheeses such that the difference is minimum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe sort the array by the difference of reward points.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Generalized Version \\nMouse 1 picks k1 items and mouse2 picks k2 items such that k1+k2<=n. See comments.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<pair<int,int>> t;\\n      for(int i=0;i<n;++i){\\n          t.push_back({reward1[i],reward2[i]});\\n      }\\n      sort(t.begin(),t.end(),[](auto &p1, auto &p2){\\n          return p1.first - p1.second > p2.first - p2.second;\\n      });\\n      int ans = 0;\\n      for(int i=0;i<n;i++){\\n          if(i<k)\\n            ans+=t[i].first;\\n          else\\n            ans+=t[i].second;\\n      }\\n      return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<pair<int,int>> t;\\n      for(int i=0;i<n;++i){\\n          t.push_back({reward1[i],reward2[i]});\\n      }\\n      sort(t.begin(),t.end(),[](auto &p1, auto &p2){\\n          return p1.first - p1.second > p2.first - p2.second;\\n      });\\n      int ans = 0;\\n      for(int i=0;i<n;i++){\\n          if(i<k)\\n            ans+=t[i].first;\\n          else\\n            ans+=t[i].second;\\n      }\\n      return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368601,
                "title": "simple-java-solution",
                "content": "This solution implements the logic used by lee215 in his approach. \\nStep1 : Assume we select all the elements in reward 2.\\nStep2: Now, we wanted to select k from reward1 so, lets pick those k elements from reward1 which are highest from their corresponding values in reward2 on the same index. In other words, just pick those elements who differ from their corresponding reward2 by max amount and add them. Now, note that since we already added the reward2 values into the answer, we just need to add the differnece of these elements. \\nTo implement step2 just create a heap of size k containing k maximum differences between reward1 and reward 2 elements at any given index.\\n    \\n\\tclass Solution {\\n        public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n            int ans = 0;\\n            for(int i : reward2) ans+=i;\\n\\n            PriorityQueue<Integer> minHeap = new PriorityQueue();\\n            for(int i=0; i<reward1.length; i++) {\\n                minHeap.offer(reward1[i] - reward2[i]);\\n                if(minHeap.size()>k) minHeap.poll();\\n            }\\n            while(!minHeap.isEmpty) ans += minHeap.poll();\\n\\n            return ans;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n            int ans = 0;\\n            for(int i : reward2) ans+=i;\\n\\n            PriorityQueue<Integer> minHeap = new PriorityQueue();\\n            for(int i=0; i<reward1.length; i++) {\\n                minHeap.offer(reward1[i] - reward2[i]);\\n                if(minHeap.size()>k) minHeap.poll();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3368476,
                "title": "c-sorting-on-difference-o-nlogn",
                "content": "# Intuition\\nWe have to take the **maximum gain** we can have, which means maximizing the k rewards from the first mouse and minimizing those rewards from the second mouse reward, which means we have to maximize the difference between the rewards of the two mice.\\n\\n# Approach\\nSimply sorting according to the profit i.e, **reward1[i] - reward2[i]** will do the trick.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //in case of tie in difference \\n    //we choose the smaller one of the 2nd reward to be ommited \\n    static bool cmp(pair<int, int> &a, pair<int, int> &b){        \\n        if(a.first - a.second == b.first - b.second) return a.second < b.second;\\n        return a.first - a.second > b.first - b.second;\\n    }\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        vector<pair<int, int>> vp;\\n        int n = r1.size();\\n        for(int i=0; i < n; i++)\\n            vp.push_back({r1[i], r2[i]});        \\n        \\n        sort(vp.begin(), vp.end(), cmp);\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            if(i < k) ans += vp[i].first;  //for the first k rewards         \\n            else ans += vp[i].second;   //next k            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //in case of tie in difference \\n    //we choose the smaller one of the 2nd reward to be ommited \\n    static bool cmp(pair<int, int> &a, pair<int, int> &b){        \\n        if(a.first - a.second == b.first - b.second) return a.second < b.second;\\n        return a.first - a.second > b.first - b.second;\\n    }\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        vector<pair<int, int>> vp;\\n        int n = r1.size();\\n        for(int i=0; i < n; i++)\\n            vp.push_back({r1[i], r2[i]});        \\n        \\n        sort(vp.begin(), vp.end(), cmp);\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            if(i < k) ans += vp[i].first;  //for the first k rewards         \\n            else ans += vp[i].second;   //next k            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379821,
                "title": "beats-90-priority-queue-c",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity: O(N log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>&r1, vector<int>& r2, int k) {\\n       priority_queue<int>pq;\\n        long long ans=0;\\n        for(int i=0;i<r1.size();i++){\\n           pq.push(r1[i]-r2[i]);\\n            ans+=r2[i];\\n        }\\n        while(k!=0){\\n          ans+=pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>&r1, vector<int>& r2, int k) {\\n       priority_queue<int>pq;\\n        long long ans=0;\\n        for(int i=0;i<r1.size();i++){\\n           pq.push(r1[i]-r2[i]);\\n            ans+=r2[i];\\n        }\\n        while(k!=0){\\n          ans+=pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368659,
                "title": "c-sort-by-difference",
                "content": "# Intuition\\njust sort by difference of ith rewards(1&2)\\nuse first reward till k and then use 2nd rewards\\n# Code\\n```\\nbool cmp(pair <int,int>a,pair <int,int>b)\\n    return (a.first-a.second)>(b.first-b.second);\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r, vector<int>& s, int k) {\\n        vector<pair <int,int>> v;\\n        int n=r.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({r[i],s[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<k) sum+=v[i].first;\\n            else sum+=v[i].second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool cmp(pair <int,int>a,pair <int,int>b)\\n    return (a.first-a.second)>(b.first-b.second);\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r, vector<int>& s, int k) {\\n        vector<pair <int,int>> v;\\n        int n=r.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({r[i],s[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<k) sum+=v[i].first;\\n            else sum+=v[i].second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368626,
                "title": "i-m-so-greedy",
                "content": "**Time Complexity: O(n * logn)**\\n**Space Complexity: O(n)** (*if you do the ar work in reward1 or reward2 array itself it\\'ll be O(1)*)\\nNow,\\n**Upvote [^]** *wish me some luck!*\\n\\n```class Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int ans = 0;\\n        int[] ar = new int[n];\\n        for(int i = 0; i < n; i++){\\n            ar[i] = reward1[i]-reward2[i];\\n            ans += reward2[i];  // adding all of reward2 to ans\\n        }\\n        \\n\\t\\t// sorting the array\\n        Arrays.sort(ar);\\n        System.out.println(Arrays.toString(ar));\\n\\t\\t\\n\\t\\t// Adding the last k because it\\'s sorted in asc order & we need largest elements\\n\\t\\t// so k elements from reward2 will be converted to reward1\\'s element\\n        for(int i = 0; i < k; i++){\\n\\t\\t\\tans += ar[n-1-i];    \\n        }\\n\\t\\t\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int ans = 0;\\n        int[] ar = new int[n];\\n        for(int i = 0; i < n; i++){\\n            ar[i] = reward1[i]-reward2[i];\\n            ans += reward2[i];  // adding all of reward2 to ans\\n        }\\n        \\n\\t\\t// sorting the array\\n        Arrays.sort(ar);\\n        System.out.println(Arrays.toString(ar));\\n\\t\\t\\n\\t\\t// Adding the last k because it\\'s sorted in asc order & we need largest elements\\n\\t\\t// so k elements from reward2 will be converted to reward1\\'s element\\n        for(int i = 0; i < k; i++){\\n\\t\\t\\tans += ar[n-1-i];    \\n        }\\n\\t\\t\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368586,
                "title": "c-simple-approach-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        priority_queue<pair<int,pair<int,int>> >pq;\\n        int n =r1.size();\\n        unordered_set<int> st;\\n        for(int i=0;i<n;i++){\\n\\t\\t     //based on the diff we are sorting in decreasing order\\n            pq.push({r1[i]-r2[i],{r1[i],i}});\\n                \\n        }\\n        int ans =0;\\n       \\n        while(k && !pq.empty()){\\n\\t\\t\\t\\t//take k max elements having more difference\\n            ans += pq.top().second.first;\\n\\t\\t\\t//mark the index as selected\\n            st.insert(pq.top().second.second);\\n            pq.pop();\\n            k--;\\n        }\\n       \\n        for(int i=0;i<n;i++){\\n\\t\\t\\t//if the index is not selected then 2nd mice will take the reward\\n          if(!st.count(i)){\\n              ans += r2[i];\\n          }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        priority_queue<pair<int,pair<int,int>> >pq;\\n        int n =r1.size();\\n        unordered_set<int> st;\\n        for(int i=0;i<n;i++){\\n\\t\\t     //based on the diff we are sorting in decreasing order\\n            pq.push({r1[i]-r2[i],{r1[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 3368559,
                "title": "simple-heap-top-k-maximum-elements",
                "content": "# Intuition\\nTo find which elements of the reward1 list should be taken, we can take out the top K maximum elements of reward1 list.\\nAnd then carry on as required.\\n\\nBut every time when we choose an index of reward1 we are discarding the corresponding reward for mice2. And since we need to maximize the collective result.\\nIt might be possible that when we are choosing some ith maximum element of the reward1 X, and there was some element at ith position of reward2 Y, \\nsuch that\\n Y >>> X\\nin such cases we are not maximizing the result.\\n\\nSo, how to handle this?\\nSimple find the difference between r1[i] and r2[i] and take indexes of top K maximum elements from there.  \\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log k)\\n\\n- Space complexity:\\nO(k)\\n\\nIf you didn\\'t understand how the space and time complexity comes out to be this, try to solve questions related to top K frequent elements\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    \\n    unordered_set<int> getIndex(vector<int>& reward1, int k) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> minHeap;\\n        for (int i=0; i<reward1.size(); i++) {\\n            int num = reward1[i];\\n            minHeap.push({num, i});\\n            if (minHeap.size() > k) {\\n                minHeap.pop();\\n            }\\n        }\\n        unordered_set<int> idx;\\n        while (!minHeap.empty()) {\\n            idx.insert(minHeap.top().second);\\n            minHeap.pop();\\n        }\\n        return idx;\\n    }\\n    \\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), ans = 0;\\n        vector<int> diff(n,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            diff[i] = reward1[i] - reward2[i];\\n        }\\n        unordered_set<int> index = getIndex(diff, k);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(index.count(i))\\n            {\\n                ans += reward1[i];\\n            }else ans += reward2[i];\\n        }\\n        if(k>=n)\\n        {\\n            ans = accumulate(reward1.begin(), reward1.end(), 0);\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public Set<Integer> getIndex(List<Integer> reward1, int k) {\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(Map.Entry.comparingByKey());\\n        for (int i = 0; i < reward1.size(); i++) {\\n            int num = reward1.get(i);\\n            minHeap.offer(new AbstractMap.SimpleEntry<>(num, i));\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        Set<Integer> idx = new HashSet<>();\\n        while (!minHeap.isEmpty()) {\\n            idx.add(minHeap.poll().getValue());\\n        }\\n        return idx;\\n    }\\n\\n    public int miceAndCheese(List<Integer> reward1, List<Integer> reward2, int k) {\\n        int n = reward1.size(), ans = 0;\\n        List<Integer> diff = new ArrayList<>(n);\\n        for (int i = 0; i < n; i++) {\\n            diff.add(reward1.get(i) - reward2.get(i));\\n        }\\n        Set<Integer> index = getIndex(diff, k);\\n        for (int i = 0; i < n; i++) {\\n            if (index.contains(i)) {\\n                ans += reward1.get(i);\\n            } else {\\n                ans += reward2.get(i);\\n            }\\n        }\\n        if (k >= n) {\\n            ans = reward1.stream().mapToInt(Integer::intValue).sum();\\n            return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def getIndex(self, reward1: List[int], k: int) -> set:\\n        minHeap = []\\n        for i, num in enumerate(reward1):\\n            heapq.heappush(minHeap, (num, i))\\n            if len(minHeap) > k:\\n                heapq.heappop(minHeap)\\n        idx = set()\\n        while minHeap:\\n            idx.add(heapq.heappop(minHeap)[1])\\n        return idx\\n    \\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        n = len(reward1)\\n        ans = 0\\n        diff = [reward1[i] - reward2[i] for i in range(n)]\\n        index = self.getIndex(diff, k)\\n        for i in range(n):\\n            if i in index:\\n                ans += reward1[i]\\n            else:\\n                ans += reward2[i]\\n        if k >= n:\\n            ans = sum(reward1)\\n            return ans\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    \\n    unordered_set<int> getIndex(vector<int>& reward1, int k) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> minHeap;\\n        for (int i=0; i<reward1.size(); i++) {\\n            int num = reward1[i];\\n            minHeap.push({num, i});\\n            if (minHeap.size() > k) {\\n                minHeap.pop();\\n            }\\n        }\\n        unordered_set<int> idx;\\n        while (!minHeap.empty()) {\\n            idx.insert(minHeap.top().second);\\n            minHeap.pop();\\n        }\\n        return idx;\\n    }\\n    \\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), ans = 0;\\n        vector<int> diff(n,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            diff[i] = reward1[i] - reward2[i];\\n        }\\n        unordered_set<int> index = getIndex(diff, k);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(index.count(i))\\n            {\\n                ans += reward1[i];\\n            }else ans += reward2[i];\\n        }\\n        if(k>=n)\\n        {\\n            ans = accumulate(reward1.begin(), reward1.end(), 0);\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public Set<Integer> getIndex(List<Integer> reward1, int k) {\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(Map.Entry.comparingByKey());\\n        for (int i = 0; i < reward1.size(); i++) {\\n            int num = reward1.get(i);\\n            minHeap.offer(new AbstractMap.SimpleEntry<>(num, i));\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        Set<Integer> idx = new HashSet<>();\\n        while (!minHeap.isEmpty()) {\\n            idx.add(minHeap.poll().getValue());\\n        }\\n        return idx;\\n    }\\n\\n    public int miceAndCheese(List<Integer> reward1, List<Integer> reward2, int k) {\\n        int n = reward1.size(), ans = 0;\\n        List<Integer> diff = new ArrayList<>(n);\\n        for (int i = 0; i < n; i++) {\\n            diff.add(reward1.get(i) - reward2.get(i));\\n        }\\n        Set<Integer> index = getIndex(diff, k);\\n        for (int i = 0; i < n; i++) {\\n            if (index.contains(i)) {\\n                ans += reward1.get(i);\\n            } else {\\n                ans += reward2.get(i);\\n            }\\n        }\\n        if (k >= n) {\\n            ans = reward1.stream().mapToInt(Integer::intValue).sum();\\n            return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def getIndex(self, reward1: List[int], k: int) -> set:\\n        minHeap = []\\n        for i, num in enumerate(reward1):\\n            heapq.heappush(minHeap, (num, i))\\n            if len(minHeap) > k:\\n                heapq.heappop(minHeap)\\n        idx = set()\\n        while minHeap:\\n            idx.add(heapq.heappop(minHeap)[1])\\n        return idx\\n    \\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        n = len(reward1)\\n        ans = 0\\n        diff = [reward1[i] - reward2[i] for i in range(n)]\\n        index = self.getIndex(diff, k)\\n        for i in range(n):\\n            if i in index:\\n                ans += reward1[i]\\n            else:\\n                ans += reward2[i]\\n        if k >= n:\\n            ans = sum(reward1)\\n            return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368554,
                "title": "well-explained-easy-python-3-solution",
                "content": "# Intuition\\nThe problem can be solved using a greedy approach. We first calculate the difference in rewards between the two mice for each type of cheese and sort them in decreasing order. Then, we select the top k differences and assume that the first mouse will eat those types of cheese. For the remaining types of cheese, we need to decide which mouse will eat them. We can do this by checking the remaining differences in decreasing order and assigning them to the mouse that has a higher reward for that type of cheese. However, we need to be careful to avoid assigning a type of cheese to the first mouse if it was not one of the top k differences.\\n# Approach\\n1. Calculate the difference in rewards between the two mice for each type of cheese.\\n2. Sort the differences in decreasing order and select the top k.\\n3. For the remaining types of cheese, iterate through them in decreasing order of the difference.\\n4. If the type of cheese was in the top k differences, assign it to the first mouse.\\n5. If the difference is positive, assign it to the mouse with the higher reward for that type of cheese.\\n6. Otherwise, assign it to the second mouse.\\n7. Calculate the total reward for the mice.\\n# Complexity\\n- Time complexity:\\nO(nlogn) for sorting the differences, where n is the number of types of cheese.\\n- Space complexity:\\n O(n) for storing the differences.\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        if k == 0:\\n            return sum(reward2)\\n        difference = [reward1[i] - reward2[i] for i in range(len(reward1))]\\n        sorted_diff = sorted(difference, reverse=True)\\n        max_diff = sorted_diff[:k][-1]\\n        skip = sorted_diff[k:].count(max_diff)\\n        i, j, res = 0, 0, 0\\n        while i < len(reward1):\\n            if j == k:\\n                res += reward2[i]\\n            elif difference[i] == max_diff and skip > 0:\\n                res += reward2[i]\\n                skip -= 1\\n            elif difference[i] >= max_diff:\\n                res += difference[i] + reward2[i]\\n                j += 1\\n            else:\\n                res += reward2[i]\\n            i += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        if k == 0:\\n            return sum(reward2)\\n        difference = [reward1[i] - reward2[i] for i in range(len(reward1))]\\n        sorted_diff = sorted(difference, reverse=True)\\n        max_diff = sorted_diff[:k][-1]\\n        skip = sorted_diff[k:].count(max_diff)\\n        i, j, res = 0, 0, 0\\n        while i < len(reward1):\\n            if j == k:\\n                res += reward2[i]\\n            elif difference[i] == max_diff and skip > 0:\\n                res += reward2[i]\\n                skip -= 1\\n            elif difference[i] >= max_diff:\\n                res += difference[i] + reward2[i]\\n                j += 1\\n            else:\\n                res += reward2[i]\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368465,
                "title": "c-sorting-and-storing-differences-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI don\\'t know why I thought that DP would be used! \\n\\nThe intuition is to consider the difference in rewards between each cheese type for the two mice. We can create a vector of pairs where the first element of the pair is the difference in rewards and the second element is the index of the cheese type.\\n\\nThen, we can sort this vector in descending order based on the difference in rewards. We can then iterate through this sorted vector and choose the k highest differences, assigning those cheese types to the first mouse and the remaining cheese types to the second mouse.\\n\\nFinally, we can calculate the total score by adding up the rewards for each cheese type assigned to the first and second mouse respectively.\\n\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(n log n), where n is the number of cheese types, due to the sorting step. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(n) because we need to store the vector of pairs.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int,int>>diff;\\n        int n=reward1.size();\\n        for(int i=0;i<n;++i){\\n            diff.push_back({reward1[i]-reward2[i],i});\\n        }\\n\\n        sort(diff.begin(),diff.end(),greater<pair<int,int>>());\\n\\n        int score=0;\\n        for(int i=0;i<n;++i){\\n            if(k>0){\\n                score+=reward1[diff[i].second];\\n                k--;\\n            }\\n            else{\\n                score+=reward2[diff[i].second];\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int,int>>diff;\\n        int n=reward1.size();\\n        for(int i=0;i<n;++i){\\n            diff.push_back({reward1[i]-reward2[i],i});\\n        }\\n\\n        sort(diff.begin(),diff.end(),greater<pair<int,int>>());\\n\\n        int score=0;\\n        for(int i=0;i<n;++i){\\n            if(k>0){\\n                score+=reward1[diff[i].second];\\n                k--;\\n            }\\n            else{\\n                score+=reward2[diff[i].second];\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418664,
                "title": "100-faster-c-sorting-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& v1, vector<int>& v2, int k) {\\n        int ans = 0,i=0,n=v1.size();\\n        vector<int> v;\\n        for(i = 0; i < n; i++){\\n            v.push_back(v1[i]-v2[i]);\\n            ans += v2[i];\\n        }\\n        sort(v.begin(),v.end());\\n        i = n-1;\\n        while(k--){\\n            ans += v[i];\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& v1, vector<int>& v2, int k) {\\n        int ans = 0,i=0,n=v1.size();\\n        vector<int> v;\\n        for(i = 0; i < n; i++){\\n            v.push_back(v1[i]-v2[i]);\\n            ans += v2[i];\\n        }\\n        sort(v.begin(),v.end());\\n        i = n-1;\\n        while(k--){\\n            ans += v[i];\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369365,
                "title": "c-python-java-5-liners",
                "content": "\\n# Complexity\\n- Time complexity:\\n`O(nlogn)`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        //if mice2 ate all cheese\\n        int ans = accumulate(reward2.begin(), reward2.end(), 0);\\n\\n        //change in reward of each cheese if mice1 ate it instead of mice2\\n        //store the difference in reward1\\n        for(int i=0; i<reward1.size(); i++) \\n            reward1[i] -= reward2[i];\\n\\n        //sort it in descending order\\n        //maximized difference will be first\\n        sort(reward1.begin(),reward1.end(),greater<int>());\\n\\n        //take top k elements (i.e mice1 eats k cheese instead of mice2)\\n        ans += accumulate(reward1.begin(), reward1.begin()+k, 0);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def miceAndCheese(self, reward1, reward2, k):\\n        //if mice2 ate all cheese\\n        ans = sum(reward2)\\n\\n        //change in reward of each cheese if mice1 ate it instead of mice2\\n        //store the difference in reward1\\n        reward1 = [(x - y) for x, y in zip(reward1, reward2)]\\n        \\n        //sort it in descending order\\n        //maximized difference will be first\\n        reward1.sort(reverse=True)\\n\\n        //take top k elements (i.e mice1 eats k cheese instead of mice2)\\n        ans +=  sum(reward1[:k])\\n\\n        return ans\\n```\\n# Java\\n```\\nclass Solution {\\n    public static int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        //if mice2 ate all cheese\\n        int ans = Arrays.stream(reward2).sum();\\n\\n        //change in reward of each cheese if mice1 ate it instead of mice2\\n        //store the difference in reward1\\n        for(int i = 0; i < reward1.length; i++) {\\n            reward1[i] -= reward2[i];\\n        }\\n\\n        //sort it in descending order\\n        //maximized difference will be at last\\n        Arrays.sort(reward1);\\n\\n        //take last k elements (i.e mice1 eats k cheese instead of mice2)\\n        int i = reward1.length-1;\\n        while(k-- > 0)\\n            ans += reward1[i--];\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        //if mice2 ate all cheese\\n        int ans = accumulate(reward2.begin(), reward2.end(), 0);\\n\\n        //change in reward of each cheese if mice1 ate it instead of mice2\\n        //store the difference in reward1\\n        for(int i=0; i<reward1.size(); i++) \\n            reward1[i] -= reward2[i];\\n\\n        //sort it in descending order\\n        //maximized difference will be first\\n        sort(reward1.begin(),reward1.end(),greater<int>());\\n\\n        //take top k elements (i.e mice1 eats k cheese instead of mice2)\\n        ans += accumulate(reward1.begin(), reward1.begin()+k, 0);\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def miceAndCheese(self, reward1, reward2, k):\\n        //if mice2 ate all cheese\\n        ans = sum(reward2)\\n\\n        //change in reward of each cheese if mice1 ate it instead of mice2\\n        //store the difference in reward1\\n        reward1 = [(x - y) for x, y in zip(reward1, reward2)]\\n        \\n        //sort it in descending order\\n        //maximized difference will be first\\n        reward1.sort(reverse=True)\\n\\n        //take top k elements (i.e mice1 eats k cheese instead of mice2)\\n        ans +=  sum(reward1[:k])\\n\\n        return ans\\n```\n```\\nclass Solution {\\n    public static int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        //if mice2 ate all cheese\\n        int ans = Arrays.stream(reward2).sum();\\n\\n        //change in reward of each cheese if mice1 ate it instead of mice2\\n        //store the difference in reward1\\n        for(int i = 0; i < reward1.length; i++) {\\n            reward1[i] -= reward2[i];\\n        }\\n\\n        //sort it in descending order\\n        //maximized difference will be at last\\n        Arrays.sort(reward1);\\n\\n        //take last k elements (i.e mice1 eats k cheese instead of mice2)\\n        int i = reward1.length-1;\\n        while(k-- > 0)\\n            ans += reward1[i--];\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368726,
                "title": "python-sort-o-n-log-n",
                "content": "1. The first mice will eat exactly `k` types, and the second mice will eat others.\\n2. Sort `reward1 - reward2` in descending order. Let the first mice eat those types with highest difference.\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        diff = [[reward1[i] - reward2[i], i] for i in range(len(reward1))]\\n        diff.sort(reverse=True)\\n        ans = 0\\n        for i in range(k):\\n            ans += reward1[diff[i][1]]\\n        for i in range(k, len(reward1)):\\n            ans += reward2[diff[i][1]]\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. The first mice will eat exactly `k` types, and the second mice will eat others.\\n2. Sort `reward1 - reward2` in descending order. Let the first mice eat those types with highest difference.\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        diff = [[reward1[i] - reward2[i], i] for i in range(len(reward1))]\\n        diff.sort(reverse=True)\\n        ans = 0\\n        for i in range(k):\\n            ans += reward1[diff[i][1]]\\n        for i in range(k, len(reward1)):\\n            ans += reward2[diff[i][1]]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3368475,
                "title": "java-priority-queue-clean-code-o-n-log-k-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n    var ans = 0;\\n    var n = reward1.length;\\n    var queue = new PriorityQueue<int[]>((a, b) -> Integer.compare(a[0], b[0]));\\n    \\n    for (var i=0; i<n; i++) {\\n      queue.offer(new int[] {reward1[i] - reward2[i], i});\\n      \\n      if (queue.size() > k)\\n        queue.poll();\\n    }\\n    while (!queue.isEmpty()) {\\n      var a = queue.poll();\\n      ans += reward1[a[1]];\\n      reward2[a[1]] = 0;\\n    }\\n    for (var a : reward2)\\n      ans += a;\\n    \\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, pleae upvote it!",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n    var ans = 0;\\n    var n = reward1.length;\\n    var queue = new PriorityQueue<int[]>((a, b) -> Integer.compare(a[0], b[0]));\\n    \\n    for (var i=0; i<n; i++) {\\n      queue.offer(new int[] {reward1[i] - reward2[i], i});\\n      \\n      if (queue.size() > k)\\n        queue.poll();\\n    }\\n    while (!queue.isEmpty()) {\\n      var a = queue.poll();\\n      ans += reward1[a[1]];\\n      reward2[a[1]] = 0;\\n    }\\n    for (var a : reward2)\\n      ans += a;\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368411,
                "title": "c-greedy-sorting-easy-55-time-9-space",
                "content": "```\\nclass Solution {\\npublic: \\n    int miceAndCheese(vector<int>& v1, vector<int>& v2, int k) {\\n      int n = v1.size(), ans = 0;\\n      vector<pair<int, int>> vp(n);\\n      for(int i = 0; i < n; i++){\\n        vp[i] = {v1[i] - v2[i], i};\\n      }\\n      sort(vp.begin(), vp.end(), greater<>());\\n      for(int i = 0; i < n; i++){\\n        int idx = vp[i].second;\\n        if(i < k) ans += v1[idx];\\n        else ans += v2[idx];\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int miceAndCheese(vector<int>& v1, vector<int>& v2, int k) {\\n      int n = v1.size(), ans = 0;\\n      vector<pair<int, int>> vp(n);\\n      for(int i = 0; i < n; i++){\\n        vp[i] = {v1[i] - v2[i], i};\\n      }\\n      sort(vp.begin(), vp.end(), greater<>());\\n      for(int i = 0; i < n; i++){\\n        int idx = vp[i].second;\\n        if(i < k) ans += v1[idx];\\n        else ans += v2[idx];\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511203,
                "title": "c-using-head-easy-to-understand",
                "content": "In question given that first rat eat k item.and remaing items eat rat2. there is no constraint that rat1 eat only these items.\\nso rat1 eat those item which have maximum diffrence (mean (v1[i]-v2[i]) > (v1[j]>v2[j]) than eat i item).\\n\\n# Complexity\\n- Time complexity:\\nO(nlogk)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int ans = 0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(int i = 0; i < reward1.size(); i++){\\n            ans += reward2[i];\\n            ans += (reward1[i]-reward2[i]);\\n            pq.push(reward1[i]-reward2[i]);\\n            if(pq.size()>k){\\n                ans -= pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int ans = 0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(int i = 0; i < reward1.size(); i++){\\n            ans += reward2[i];\\n            ans += (reward1[i]-reward2[i]);\\n            pq.push(reward1[i]-reward2[i]);\\n            if(pq.size()>k){\\n                ans -= pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385840,
                "title": "sorting-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& a, vector<int>& b, int k) {\\n        vector<pair<int,int>> v;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n            v.push_back({a[i]-b[i],i});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        int ans = 0, i = n-1;\\n        while(k){\\n            ans+= a[v[i].second];\\n            i--;\\n            k--;\\n        }\\n        while(i>=0){\\n            ans+= b[v[i].second];\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& a, vector<int>& b, int k) {\\n        vector<pair<int,int>> v;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n            v.push_back({a[i]-b[i],i});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        int ans = 0, i = n-1;\\n        while(k){\\n            ans+= a[v[i].second];\\n            i--;\\n            k--;\\n        }\\n        while(i>=0){\\n            ans+= b[v[i].second];\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370298,
                "title": "day-367-java-c-python-explained-intuition-approach-algorithm-o-n",
                "content": "# Please Upvote as it really motivates me\\n\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tIntuition: \\n##### \\u2022\\tThe problem involves finding the optimal way for mice to reach cheese in a maze. \\n##### \\u2022\\tThe goal is to minimize the total distance traveled by the mice. \\n##### \\u2022\\tApproach: \\n##### \\u2022\\tCalculate the difference between the positions of each mouse and cheese. \\n##### \\u2022\\tSort the differences in descending order. Add up the first k elements of the sorted differences array to get the sum of the positions of the k mice that are closest to the cheese. \\n##### \\u2022\\tAdd the sum of the positions of all the cheese in the maze to the sum of the positions of the k mice to get the total distance traveled. \\n##### \\u2022\\tAlgorithm: \\n##### \\u2022\\tInitialize a variable res to 0 to store the result.\\n##### \\u2022\\tCalculate the length of the input arrays A and B . \\n##### \\u2022\\tCreate a new array diff of length n to store the differences between the elements of A and B .\\n##### \\u2022\\tIterate over the elements of A and B and calculate the difference between them, storing the result in diff . \\n##### \\u2022\\tAdd up the elements of B and store the result in res . Sort the diff array in descending order. \\n##### \\u2022\\tIterate over the first k elements of the sorted diff array and add them to res . Return res as the total distance traveled.\\n\\n\\n\\n# Code\\n```python []\\n    def miceAndCheese(self, a: List[int], b: List[int], k: int) -> int:\\n        ans = 0\\n        pq = []\\n        for i in range(len(a)):\\n            heapq.heappush(pq, -(a[i]-b[i])) # difference of r1-r2\\n            ans += b[i]\\n        for i in range(k):\\n            ans -= heapq.heappop(pq)\\n        return ans\\n```\\n```java []\\npublic int miceAndCheese(int[] a, int[] b, int k) {\\n        int len =a.length,ans=0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<len;i++) {\\n            pq.offer(a[i]-b[i]);//diffrenece of r1-r2\\n            ans+=b[i];\\n        }\\n        for(int i=0;i<k;i++) ans+=pq.poll();\\n        return ans;\\n    }\\n```\\n```c++ []\\nint miceAndCheese(vector<int>& a, vector<int>& b, int k) {\\n    int n = a.size(), ans = 0;\\n    priority_queue<int> pq;\\n    for (int i = 0; i < n; i++) {\\n        pq.push(a[i] - b[i]); // difference of r1-r2\\n        ans += b[i];\\n    }\\n    for (int i = 0; i < k; i++) {\\n        ans -= pq.top();\\n        pq.pop();\\n    }\\n    return ans;\\n}\\n```\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\u2022 Thanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n\\u2022 Please give my solution an upvote! \\uD83D\\uDC4D\\n\\u2022 It\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\n    def miceAndCheese(self, a: List[int], b: List[int], k: int) -> int:\\n        ans = 0\\n        pq = []\\n        for i in range(len(a)):\\n            heapq.heappush(pq, -(a[i]-b[i])) # difference of r1-r2\\n            ans += b[i]\\n        for i in range(k):\\n            ans -= heapq.heappop(pq)\\n        return ans\\n```\n```java []\\npublic int miceAndCheese(int[] a, int[] b, int k) {\\n        int len =a.length,ans=0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<len;i++) {\\n            pq.offer(a[i]-b[i]);//diffrenece of r1-r2\\n            ans+=b[i];\\n        }\\n        for(int i=0;i<k;i++) ans+=pq.poll();\\n        return ans;\\n    }\\n```\n```c++ []\\nint miceAndCheese(vector<int>& a, vector<int>& b, int k) {\\n    int n = a.size(), ans = 0;\\n    priority_queue<int> pq;\\n    for (int i = 0; i < n; i++) {\\n        pq.push(a[i] - b[i]); // difference of r1-r2\\n        ans += b[i];\\n    }\\n    for (int i = 0; i < k; i++) {\\n        ans -= pq.top();\\n        pq.pop();\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3369041,
                "title": "golang-greedy-sorting",
                "content": "# Intuition\\nIt requires greedy approach. DP hits the time limit.\\n\\n# Approach\\nSort both lists so that:\\n```\\nreward1[i]-reward2[i] > reward1[i+1]-reward2[i+1]\\n```\\nNow the left part of `reward1` have the best rewards if the first mouse eats the cheese.\\nTake the first `k` elements from `reward1`, and last remaining `n-k` elements from `reward2`.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\nSorting lists\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\ntype S struct {\\n    reward1, reward2 []int\\n}\\nfunc (s S) Len() int {\\n    return len(s.reward1)\\n}\\nfunc (s S) Swap(i, j int) {\\n    s.reward1[i], s.reward1[j] = s.reward1[j], s.reward1[i]\\n    s.reward2[i], s.reward2[j] = s.reward2[j], s.reward2[i]\\n}\\nfunc (s S) Less(i, j int) bool {\\n    return s.reward1[i] - s.reward2[i] > s.reward1[j] - s.reward2[j]\\n}\\n\\nfunc miceAndCheese(reward1 []int, reward2 []int, k int) int {\\n    sort.Sort(S{reward1, reward2})\\n\\n    result := 0\\n    for _, r := range reward1[:k] {\\n        result += r\\n    }\\n    for _, r := range reward2[k:] {\\n        result += r\\n    }\\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nreward1[i]-reward2[i] > reward1[i+1]-reward2[i+1]\\n```\n```\\ntype S struct {\\n    reward1, reward2 []int\\n}\\nfunc (s S) Len() int {\\n    return len(s.reward1)\\n}\\nfunc (s S) Swap(i, j int) {\\n    s.reward1[i], s.reward1[j] = s.reward1[j], s.reward1[i]\\n    s.reward2[i], s.reward2[j] = s.reward2[j], s.reward2[i]\\n}\\nfunc (s S) Less(i, j int) bool {\\n    return s.reward1[i] - s.reward2[i] > s.reward1[j] - s.reward2[j]\\n}\\n\\nfunc miceAndCheese(reward1 []int, reward2 []int, k int) int {\\n    sort.Sort(S{reward1, reward2})\\n\\n    result := 0\\n    for _, r := range reward1[:k] {\\n        result += r\\n    }\\n    for _, r := range reward2[k:] {\\n        result += r\\n    }\\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368883,
                "title": "simple-and-fast-solution-easy-to-understand",
                "content": "# Intuition\\nTake the all maximum from each array one by one and then remove the (size of reward1 - k) element from total sum.\\n\\n# Approach\\nFor removing we have to take the diff of both element and remove that element which have low diff.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& v1, vector<int>& v2, int k) {\\n        int n1=v1.size();\\n        int n2=v2.size();\\n        vector<pair<int,int>>diff;\\n        for(int i=0;i<n1;++i){\\n            diff.push_back({v2[i]-v1[i],i});\\n        }\\n        sort(diff.begin(),diff.end());\\n        int ans=0;\\n        for(int i=0;i<k;++i){\\n            ans+=v1[diff[i].second];\\n        }\\n        for(int i=k;i<n1;++i){\\n            ans+=v2[diff[i].second];\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& v1, vector<int>& v2, int k) {\\n        int n1=v1.size();\\n        int n2=v2.size();\\n        vector<pair<int,int>>diff;\\n        for(int i=0;i<n1;++i){\\n            diff.push_back({v2[i]-v1[i],i});\\n        }\\n        sort(diff.begin(),diff.end());\\n        int ans=0;\\n        for(int i=0;i<k;++i){\\n            ans+=v1[diff[i].second];\\n        }\\n        for(int i=k;i<n1;++i){\\n            ans+=v2[diff[i].second];\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368740,
                "title": "python-sorting",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$: where n is the size of the array. `nlogn` is due to sorting the array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$: because store the data in a seperate list\\n\\n# Code\\n```\\nimport array\\n\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        arr = []\\n        n = len(reward1)\\n\\n        for idx in range(n):\\n            arr.append(\\n                array.array(\\'i\\', [\\n                    reward1[idx] - reward2[idx], reward1[idx], reward2[idx]\\n                ])\\n            )\\n        \\n        arr.sort(key=lambda x: x[0], reverse=True)\\n        max_profit = 0\\n        idx = 0\\n        while k > 0:\\n            k -= 1\\n            max_profit += arr[idx][1]\\n            idx += 1\\n\\n        while idx < n:\\n            max_profit += arr[idx][2]\\n            idx += 1\\n\\n        return max_profit\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport array\\n\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        arr = []\\n        n = len(reward1)\\n\\n        for idx in range(n):\\n            arr.append(\\n                array.array(\\'i\\', [\\n                    reward1[idx] - reward2[idx], reward1[idx], reward2[idx]\\n                ])\\n            )\\n        \\n        arr.sort(key=lambda x: x[0], reverse=True)\\n        max_profit = 0\\n        idx = 0\\n        while k > 0:\\n            k -= 1\\n            max_profit += arr[idx][1]\\n            idx += 1\\n\\n        while idx < n:\\n            max_profit += arr[idx][2]\\n            idx += 1\\n\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368693,
                "title": "c-easy-to-understand-using-multimap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to take k maximum rewards in reward1 arr and remaining index from reward2 arr to maximize the rewards of mice.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use multimap to store the difference (reward2-reward1) at every index so that multimap sorts them and we can add the values of first k indexes of reward1 in map. Remaining all indexes will be of reward2. The need to store diff is because of this kind of testcases:\\nreward1 = [3,3]\\nreward2 = [3,5]\\nk=1;\\nhere if you dont use diff then you will return 6 but answer is 8.\\n\\n# Complexity\\n- Time complexity: Nlog(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        multimap<int,int> m;\\n        int ans = 0;\\n        for(int i=0;i<reward1.size();i++){\\n            m.insert({reward2[i]-reward1[i],i});\\n        }\\n        int bt = 0;\\n        multimap<int, int>::iterator itr;\\n        for (itr = m.begin(); itr != m.end() ; ++itr) {\\n            if(bt<k){\\n                ans+=reward1[itr->second];\\n                bt++;\\n            }else{\\n                ans+=reward2[itr->second];\\n            }\\n    }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        multimap<int,int> m;\\n        int ans = 0;\\n        for(int i=0;i<reward1.size();i++){\\n            m.insert({reward2[i]-reward1[i],i});\\n        }\\n        int bt = 0;\\n        multimap<int, int>::iterator itr;\\n        for (itr = m.begin(); itr != m.end() ; ++itr) {\\n            if(bt<k){\\n                ans+=reward1[itr->second];\\n                bt++;\\n            }else{\\n                ans+=reward2[itr->second];\\n            }\\n    }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368638,
                "title": "c-sorting-vector-only-o-nlogn-solution",
                "content": "class Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n         int ans = 0;\\n        vector<pair<int,int>> vp;\\n        \\n        int n = reward1.size();\\n        \\n        for(int i = 0;i<n;i++){\\n            vp.emplace_back(reward1[i] - reward2[i], i);\\n        }\\n        \\n        sort(vp.begin(),vp.end());\\n        \\n        while(k--){\\n            pair<int,int> x =vp.back();\\n            ans+=reward1[x.second];\\n            vp.pop_back();\\n        }\\n        \\n        \\n        for(auto&i:vp){\\n            ans+=reward2[i.second];\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n         int ans = 0;\\n        vector<pair<int,int>> vp;\\n        \\n        int n = reward1.size();\\n        \\n        for(int i = 0;i<n;i++){\\n            vp.emplace_back(reward1[i] - reward2[i], i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3368568,
                "title": "c-ez-greedy-solution-using-priority-queue",
                "content": "Approach : \\nIts mentioned in the question that mice 1 will need to select \\'k\\' cheese and mice  2 can select the remaining cheese. We need to select the \\'k\\' cheese in such a way that the reward will be maximum.\\nI am using a priority queue **<difference between reward1[i] and reward2[i], reward1[i], reward2[i]>**\\nBy default the heap will be created based on the first element. It can be said that whenever we select reward1 \\'k\\' times, the one with maximum difference will be optimal.\\nSo we select the first \\'k\\' elements from reward1 and then the remaining elements from reward2 will give us the optimal answer.\\n\\n**Time Complexity : O(N * log (N) )\\nSpace Complexity : O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int x=0;      \\n        int len=reward1.size();\\n          priority_queue<vector<int>>q;        \\n        for(int i=0;i<len;i++)            \\n            q.push({reward1[i]-reward2[i],reward1[i],reward2[i]});\\n        while(!q.empty()&&k--){\\n            x=x+q.top()[1];\\n            //cout<<x\" \";\\n            q.pop();\\n        }        \\n        while(!q.empty()){\\n             x=x+q.top()[2];\\n            q.pop();\\n        }        \\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int x=0;      \\n        int len=reward1.size();\\n          priority_queue<vector<int>>q;        \\n        for(int i=0;i<len;i++)            \\n            q.push({reward1[i]-reward2[i],reward1[i],reward2[i]});\\n        while(!q.empty()&&k--){\\n            x=x+q.top()[1];\\n            //cout<<x\" \";\\n            q.pop();\\n        }        \\n        while(!q.empty()){\\n             x=x+q.top()[2];\\n            q.pop();\\n        }        \\n        return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3368545,
                "title": "i-was-too-young-and-did-not-pass-the-interview-because-i-did-not-give-them-an-o-n-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n    transform(reward1.begin(), reward1.end(), reward2.begin(), reward1.begin(), minus<int>());\\n    nth_element(reward1.begin(), reward1.begin() + k, reward1.end(), greater<int>());\\n    return accumulate(reward1.begin(), reward1.begin() + k, accumulate(reward2.begin(), reward2.end(), 0));\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n    transform(reward1.begin(), reward1.end(), reward2.begin(), reward1.begin(), minus<int>());\\n    nth_element(reward1.begin(), reward1.begin() + k, reward1.end(), greater<int>());\\n    return accumulate(reward1.begin(), reward1.begin() + k, accumulate(reward2.begin(), reward2.end(), 0));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368499,
                "title": "simple-c-code-sorting",
                "content": "C++ Code-\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(const pair<int,int> &a,pair<int,int>&b)\\n    {\\n       return a.first>b.first;\\n    }\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        \\n        vector<pair<int,int>> v;\\n        int n=r1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({r1[i]-r2[i],i});\\n        }\\n        sort(v.begin(),v.end(),comp);\\n        vector<bool> vis(n,0);\\n        int ans=0;\\n        int j=0;\\n        for(auto x:v)\\n        {\\n            if(j<k)\\n            {\\n              ans+=r1[x.second];\\n                vis[x.second]=1;\\n                j++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                ans+=r2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(const pair<int,int> &a,pair<int,int>&b)\\n    {\\n       return a.first>b.first;\\n    }\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        \\n        vector<pair<int,int>> v;\\n        int n=r1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({r1[i]-r2[i],i});\\n        }\\n        sort(v.begin(),v.end(),comp);\\n        vector<bool> vis(n,0);\\n        int ans=0;\\n        int j=0;\\n        for(auto x:v)\\n        {\\n            if(j<k)\\n            {\\n              ans+=r1[x.second];\\n                vis[x.second]=1;\\n                j++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                ans+=r2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368426,
                "title": "easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Storing difference and both rewards in new vector.\\n2. Then sorting on basis of difference.\\n3. Top k element with highest difference taking reward1 in ans and other as reward2.\\n\\n# Complexity\\n- Time complexity: $$O(n*Log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        int n=r1.size(),ans=0;\\n        vector<vector<int>> x(n,vector<int>(3,0));\\n        for(int i=0;i<n;i++) x[i]={r1[i]-r2[i],r1[i],r2[i]};\\n        sort(x.begin(),x.end());\\n        for(int i=0;i<n;i++){\\n            if(i>=n-k) ans+=x[i][1];\\n            else ans+=x[i][2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        int n=r1.size(),ans=0;\\n        vector<vector<int>> x(n,vector<int>(3,0));\\n        for(int i=0;i<n;i++) x[i]={r1[i]-r2[i],r1[i],r2[i]};\\n        sort(x.begin(),x.end());\\n        for(int i=0;i<n;i++){\\n            if(i>=n-k) ans+=x[i][1];\\n            else ans+=x[i][2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368425,
                "title": "python-easy-approach-diff",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        \\n        ans = 0\\n        diff = {}\\n        \\n        reward = [0] * len(reward1)\\n        \\n        for i in range(len(reward1)):\\n            diff[i] = reward1[i] - reward2[i]\\n            \\n        sortDiff = sorted(diff.items(), key = lambda x:x[1], reverse = True)\\n        \\n        for i in range(k):\\n            index = sortDiff[i][0]\\n            ans += reward1[index]\\n        \\n        for i in range(len(reward1) - k):\\n            index = sortDiff[i + k][0]\\n            ans += reward2[index]\\n        \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        \\n        ans = 0\\n        diff = {}\\n        \\n        reward = [0] * len(reward1)\\n        \\n        for i in range(len(reward1)):\\n            diff[i] = reward1[i] - reward2[i]\\n            \\n        sortDiff = sorted(diff.items(), key = lambda x:x[1], reverse = True)\\n        \\n        for i in range(k):\\n            index = sortDiff[i][0]\\n            ans += reward1[index]\\n        \\n        for i in range(len(reward1) - k):\\n            index = sortDiff[i + k][0]\\n            ans += reward2[index]\\n        \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368380,
                "title": "difference-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), ans = 0;\\n        vector<vector<int>> v;\\n        for(int i=0; i<n; i++) v.push_back({reward1[i] - reward2[i], reward1[i], reward2[i]});\\n        sort(v.begin(), v.end(), greater<vector<int>>());\\n        \\n        for(int i=0; i<n; i++) {\\n            if(k > 0) ans += v[i][1],  k--;\\n            else ans += v[i][2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), ans = 0;\\n        vector<vector<int>> v;\\n        for(int i=0; i<n; i++) v.push_back({reward1[i] - reward2[i], reward1[i], reward2[i]});\\n        sort(v.begin(), v.end(), greater<vector<int>>());\\n        \\n        for(int i=0; i<n; i++) {\\n            if(k > 0) ans += v[i][1],  k--;\\n            else ans += v[i][2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368314,
                "title": "pair-stl-sort-easy-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<pair<int,int>> cheese(n);\\n        for(int i=0;i<n;i++){\\n            cheese[i] = {reward1[i] - reward2[i], i};\\n        }\\n        sort(cheese.begin(), cheese.end(), greater<pair<int,int>>());\\n        int ans = 0;\\n        for(int i=0;i<k;i++){\\n            ans += reward1[cheese[i].second];\\n        }\\n        for(int i=k;i<n;i++){\\n            ans += reward2[cheese[i].second];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<pair<int,int>> cheese(n);\\n        for(int i=0;i<n;i++){\\n            cheese[i] = {reward1[i] - reward2[i], i};\\n        }\\n        sort(cheese.begin(), cheese.end(), greater<pair<int,int>>());\\n        int ans = 0;\\n        for(int i=0;i<k;i++){\\n            ans += reward1[cheese[i].second];\\n        }\\n        for(int i=k;i<n;i++){\\n            ans += reward2[cheese[i].second];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079454,
                "title": "three-lines-of-python-code-using-heap",
                "content": "# Intuition\\nImagine all cheese are eaten by the second mouse, so the total reward is `sum(reward2)`. Now the first mouse need to take over exactly `k` cheese, and for each time a cheese `i` is taken by the first mouse, we earn an extra reward equals to `reward1[i] - reward2[i]`. To maximize the total reward, we want to take the top `k` reward diffs.\\n\\n# Approach\\nUse heap to get the top K diffs, and these are the all extra rewards comparing to the reward2 case, so we can simply do the summation\\n```\\nmax_sum = sum(reward2) + sum(top_k_diff)\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(k))$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        top_k_diff = heapq.nlargest(k, [reward1[i] - reward2[i] for i in range(len(reward1))])\\n\\n        max_sum = sum(reward2) + sum(top_k_diff)\\n        return max_sum\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nmax_sum = sum(reward2) + sum(top_k_diff)\\n```\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        top_k_diff = heapq.nlargest(k, [reward1[i] - reward2[i] for i in range(len(reward1))])\\n\\n        max_sum = sum(reward2) + sum(top_k_diff)\\n        return max_sum\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998161,
                "title": "easy-solution-using-max-heap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int ans=0;      \\n        int n=reward1.size();\\n        priority_queue<pair<pair<int , int> , int>>pq;  \\n\\n        for(int i=0;i<n;i++)            \\n            pq.push({{reward1[i]-reward2[i],reward1[i]},reward2[i]});\\n\\n        while(!pq.empty()&&k--){\\n            ans=ans+pq.top().first.second;\\n            pq.pop();\\n        }   \\n\\n        while(!pq.empty()){\\n            ans=ans+pq.top().second;\\n            pq.pop();\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int ans=0;      \\n        int n=reward1.size();\\n        priority_queue<pair<pair<int , int> , int>>pq;  \\n\\n        for(int i=0;i<n;i++)            \\n            pq.push({{reward1[i]-reward2[i],reward1[i]},reward2[i]});\\n\\n        while(!pq.empty()&&k--){\\n            ans=ans+pq.top().first.second;\\n            pq.pop();\\n        }   \\n\\n        while(!pq.empty()){\\n            ans=ans+pq.top().second;\\n            pq.pop();\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924302,
                "title": "c-using-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        priority_queue<pair<int,pair<int,int>>>p;\\n        for(int i=0;i<r1.size();i++){\\n            p.push({r1[i]-r2[i],{r1[i],i}});\\n        }\\n        long long points=0;\\n         unordered_set<int>s;\\n        while(k--){\\n          int a,b;\\n          if(!p.empty()){\\n              a=p.top().second.first;\\n              b=p.top().second.second;\\n          }\\n          p.pop();\\n          points+=a;\\n            s.insert(b);\\n        }\\n       \\n            for(int j=0;j<r2.size();j++){\\n                if(s.find(j)==s.end())\\n                points+=r2[j];\\n                \\n            }\\n        return points;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        priority_queue<pair<int,pair<int,int>>>p;\\n        for(int i=0;i<r1.size();i++){\\n            p.push({r1[i]-r2[i],{r1[i],i}});\\n        }\\n        long long points=0;\\n         unordered_set<int>s;\\n        while(k--){\\n          int a,b;\\n          if(!p.empty()){\\n              a=p.top().second.first;\\n              b=p.top().second.second;\\n          }\\n          p.pop();\\n          points+=a;\\n            s.insert(b);\\n        }\\n       \\n            for(int j=0;j<r2.size();j++){\\n                if(s.find(j)==s.end())\\n                points+=r2[j];\\n                \\n            }\\n        return points;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619731,
                "title": "basic-observation-based-approach-fully-explained",
                "content": "# Approach\\nThe approach to this problem can be understood by seeing the pattern that all the cheese has to be eaten but who eats the cheese will affect the total score! \\nMoreover you note that mouse1 will eat cheese first, hence it is natural that we\\'d like mouse1 to eat that index of cheese which will give us a more rewarding score THAN mouse2, hence you compare both scores by using maxHeap and then mouse1 eats top k indexes cheese of that maxHeap and the rest is eaten by mouse2;\\nThe time complexity will be calculated by insertions and extraction from the priority queue (max heap)!\\n\\nPLEASE UPVOTE IF THIS HELPED YOU!\\ni\\'m a beginner so please notify if u see any mistakes! i\\'ll be grateful to y\\'all! \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(2n)$$ Although it can be easily brought down (i did it in a hurry lol sorry :P)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n        int n = reward1.size();\\n        vector<int> visited(n,0);\\n\\n        priority_queue< pair<int,int> > pq;\\n        for(int i=0; i<n; i++){\\n            pq.push({reward1[i]-reward2[i], i});\\n        }\\n\\n        int ans=0;\\n        while(k--){\\n            \\n            int index = pq.top().second;\\n            visited[index]=1;\\n            pq.pop();\\n            ans += reward1[index];\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(visited[i]==0){\\n                ans += reward2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n        int n = reward1.size();\\n        vector<int> visited(n,0);\\n\\n        priority_queue< pair<int,int> > pq;\\n        for(int i=0; i<n; i++){\\n            pq.push({reward1[i]-reward2[i], i});\\n        }\\n\\n        int ans=0;\\n        while(k--){\\n            \\n            int index = pq.top().second;\\n            visited[index]=1;\\n            pq.pop();\\n            ans += reward1[index];\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(visited[i]==0){\\n                ans += reward2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496309,
                "title": "c-priority-queue",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<int> diff;\\n        int n= reward1.size();\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            int val= (reward1[i]-reward2[i]);\\n            ans+= reward2[i];\\n            if (k==0)continue;\\n            if (pq.size()<k)pq.push(val);\\n            else{\\n                if (pq.top()<val){\\n                    pq.pop();\\n                    pq.push(val);\\n                }\\n            }\\n        }\\n        while (!pq.empty()){\\n            ans+= pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<int> diff;\\n        int n= reward1.size();\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            int val= (reward1[i]-reward2[i]);\\n            ans+= reward2[i];\\n            if (k==0)continue;\\n            if (pq.size()<k)pq.push(val);\\n            else{\\n                if (pq.top()<val){\\n                    pq.pop();\\n                    pq.push(val);\\n                }\\n            }\\n        }\\n        while (!pq.empty()){\\n            ans+= pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394420,
                "title": "max-heap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) \\n    {\\n        priority_queue<vector<int>>pq;\\n        for(int i=0;i<reward1.size();i++)\\n        {\\n            int a = reward1[i];\\n            int b = reward2[i];\\n            int diff = a - b;\\n            \\n            pq.push({diff,reward1[i],reward2[i]});\\n        }\\n        int sum = 0;\\n        while(!pq.empty())\\n        {\\n            if(k > 0)\\n            {\\n               sum = sum + pq.top()[1];\\n               k--;\\n            }\\n            else\\n            {\\n                sum = sum + pq.top()[2];\\n            }\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) \\n    {\\n        priority_queue<vector<int>>pq;\\n        for(int i=0;i<reward1.size();i++)\\n        {\\n            int a = reward1[i];\\n            int b = reward2[i];\\n            int diff = a - b;\\n            \\n            pq.push({diff,reward1[i],reward2[i]});\\n        }\\n        int sum = 0;\\n        while(!pq.empty())\\n        {\\n            if(k > 0)\\n            {\\n               sum = sum + pq.top()[1];\\n               k--;\\n            }\\n            else\\n            {\\n                sum = sum + pq.top()[2];\\n            }\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393415,
                "title": "solve-using-vector-pair-in-c",
                "content": "class Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<pair<int,pair<int,int>>>vpp;\\n        for(int i=0; i<n; i++){\\n            vpp.push_back(make_pair(reward1[i]-reward2[i],make_pair(reward1[i],i)));\\n        }\\n        sort(vpp.begin(),vpp.end());\\n        reverse(vpp.begin(),vpp.end());\\n        int i=0, ans=0;\\n        map<int,int>mpp;\\n        \\n        while(k--){\\n            ans += vpp[i].second.first;\\n            ++mpp[vpp[i].second.second];\\n            i++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(mpp[i] == 0) {\\n                ans += reward2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<pair<int,pair<int,int>>>vpp;\\n        for(int i=0; i<n; i++){\\n            vpp.push_back(make_pair(reward1[i]-reward2[i],make_pair(reward1[i],i)));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3392726,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        int ans=0;\\n        for(int i=0; i<r2.size(); i++){\\n            ans+=r2[i];\\n        }\\n        vector<int>p;\\n        for(int i=0; i<r1.size(); i++){\\n            p.push_back(r1[i]-r2[i]);\\n        }\\n        \\n        sort(p.begin(), p.end());\\n        reverse(p.begin(), p.end());\\n        for(int i=0; i<p.size(); i++){\\n            if(k==0){\\n                break;\\n            }\\n            ans+=p[i];\\n            k--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        int ans=0;\\n        for(int i=0; i<r2.size(); i++){\\n            ans+=r2[i];\\n        }\\n        vector<int>p;\\n        for(int i=0; i<r1.size(); i++){\\n            p.push_back(r1[i]-r2[i]);\\n        }\\n        \\n        sort(p.begin(), p.end());\\n        reverse(p.begin(), p.end());\\n        for(int i=0; i<p.size(); i++){\\n            if(k==0){\\n                break;\\n            }\\n            ans+=p[i];\\n            k--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377973,
                "title": "easy-and-simple-c-code",
                "content": "\\n# Complexity\\n- Time complexity:  O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& a, vector<int>& b, int k) {\\n        int ans=0,n=a.size();\\n        //ans indicates all rewards achieve by Mice 2\\n        for (int i = 0; i < n; ++i) {\\n           ans=ans+b[i];\\n        }\\n        vector<int>d;\\n        // and make the difference vector between 2 mice rewards\\n         for(int i=0;i<n;i++){\\n          d.push_back(a[i]-b[i]);\\n        }\\n        //Sort them in descending order because difference between them is maximize\\n        sort(d.begin(),d.end(),greater<int>());\\n        int i=0;\\n        //now add k rewards achieved by mice 1 \\n        // and subtract those ith reward from mice 2\\n        while(k--){\\n          // d[i] indicates difference between a[i] and b[i]\\n          // add them in ans because ans subtracts b[i] and add a[i] in it that\\'s why we add directly d[i] = a[i] - b[i] . \\n          ans=ans+d[i];\\n          i++;\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& a, vector<int>& b, int k) {\\n        int ans=0,n=a.size();\\n        //ans indicates all rewards achieve by Mice 2\\n        for (int i = 0; i < n; ++i) {\\n           ans=ans+b[i];\\n        }\\n        vector<int>d;\\n        // and make the difference vector between 2 mice rewards\\n         for(int i=0;i<n;i++){\\n          d.push_back(a[i]-b[i]);\\n        }\\n        //Sort them in descending order because difference between them is maximize\\n        sort(d.begin(),d.end(),greater<int>());\\n        int i=0;\\n        //now add k rewards achieved by mice 1 \\n        // and subtract those ith reward from mice 2\\n        while(k--){\\n          // d[i] indicates difference between a[i] and b[i]\\n          // add them in ans because ans subtracts b[i] and add a[i] in it that\\'s why we add directly d[i] = a[i] - b[i] . \\n          ans=ans+d[i];\\n          i++;\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374252,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n=reward1.length;\\n        int[]a=new int[n];\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            a[i]=reward1[i]-reward2[i];\\n            res+=reward2[i];\\n        }\\n        Arrays.sort(a);\\n        reverse(a);\\n        for(int i=0;i<k;i++)\\n            res+=a[i];\\n        return res;        \\n    }\\n    public void reverse(int[]a){\\n        int n=a.length;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            int t=a[i];\\n            a[i]=a[j];\\n            a[j]=t;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n=reward1.length;\\n        int[]a=new int[n];\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            a[i]=reward1[i]-reward2[i];\\n            res+=reward2[i];\\n        }\\n        Arrays.sort(a);\\n        reverse(a);\\n        for(int i=0;i<k;i++)\\n            res+=a[i];\\n        return res;        \\n    }\\n    public void reverse(int[]a){\\n        int n=a.length;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            int t=a[i];\\n            a[i]=a[j];\\n            a[j]=t;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371928,
                "title": "c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should order by `reward2[i] - reward1[i]` and let 1st mouse eat top `k` items\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLinq query\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, due to Linq\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MiceAndCheese(int[] reward1, int[] reward2, int k) => reward1\\n        .Zip(reward2, (r1, r2) => (r1, r2))\\n        .OrderBy(item => item.r2 - item.r1)\\n        .Select((item, index) => index <= k - 1 ? item.r1 : item.r2)\\n        .Sum();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MiceAndCheese(int[] reward1, int[] reward2, int k) => reward1\\n        .Zip(reward2, (r1, r2) => (r1, r2))\\n        .OrderBy(item => item.r2 - item.r1)\\n        .Select((item, index) => index <= k - 1 ? item.r1 : item.r2)\\n        .Sum();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371038,
                "title": "c-priority-queue-easy-understande",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe only need to know the biggest k item of the diff between reward1 and reward2, which means, these idx choose reward1 are better.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), res = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (int i = 0; i < n; i++) {\\n            pq.push({reward1[i] - reward2[i], i});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n        set<int> st;\\n        while (!pq.empty()) {\\n            auto tmp = pq.top(); pq.pop();\\n            int idx = tmp.second;\\n            st.insert(idx);\\n            res += reward1[idx];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (st.count(i) == 0) {\\n                res += reward2[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), res = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (int i = 0; i < n; i++) {\\n            pq.push({reward1[i] - reward2[i], i});\\n            if (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n        set<int> st;\\n        while (!pq.empty()) {\\n            auto tmp = pq.top(); pq.pop();\\n            int idx = tmp.second;\\n            st.insert(idx);\\n            res += reward1[idx];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (st.count(i) == 0) {\\n                res += reward2[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370537,
                "title": "c-straightforward-heap-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n * log (n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& A, vector<int>& B, int k) {\\n        priority_queue<int> pq;\\n        int n = A.size(), sum = 0, res = 0;\\n        for(int i = 0; i < n; i++)\\n            pq.push(A[i] - B[i]), sum += B[i];\\n        while(k--)\\n            res += pq.top(), pq.pop();\\n        return res + sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& A, vector<int>& B, int k) {\\n        priority_queue<int> pq;\\n        int n = A.size(), sum = 0, res = 0;\\n        for(int i = 0; i < n; i++)\\n            pq.push(A[i] - B[i]), sum += B[i];\\n        while(k--)\\n            res += pq.top(), pq.pop();\\n        return res + sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370230,
                "title": "python-shortest-code-greedy-mathematical-proof-breif-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlet a be rat1 array and b be rat2 array\\nso according to question....\\n![image.png](https://assets.leetcode.com/users/images/b93b2e58-31a3-443e-87f5-1d0beb411335_1680429987.5440614.png)\\nSince \\u2211i bi is a constant, the sum reaches the maximum if \\u2211i\\u2208I(ai\\u2212bi)\\n reaches the maximum. So we can select the k largest elements in the array a\\u2212b=(a1\\u2212b1,a2\\u2212b2,\\u22EF,an\\u2212bn). \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere we will create new array aa wehere aa[i]=a[i]-b[i]\\nsort aa in decreasing order assign ans=sum of all element of b.\\nthen add k largest element from array aa. \\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n - $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, a: List[int], b: List[int], k: int) -> int:\\n        n=len(a)\\n        aa=[a[i]-b[i] for i in range(n)]\\n        aa.sort( reverse=True)\\n        ans=sum(b)+sum(aa[:k])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, a: List[int], b: List[int], k: int) -> int:\\n        n=len(a)\\n        aa=[a[i]-b[i] for i in range(n)]\\n        aa.sort( reverse=True)\\n        ans=sum(b)+sum(aa[:k])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370202,
                "title": "python-max-heap-o-nlogn",
                "content": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        \\n        #build max heap, based on the extra we can get if we \\n        #choose reward1\\n        heap = []\\n        for i in range(0,len(reward1)):\\n            heap.append( [ -reward1[i]+reward2[i] ,i  ])\\n        heapq.heapify(heap)\\n\\n        #eat the ones where we get the most extra and store those\\n        #mark those visited\\n        visited ,res = {},0\\n        while(k):\\n            idx = heapq.heappop(heap)[1]\\n            res += reward1[idx]\\n            visited[idx] = 1\\n            k-=1\\n\\n        # eat the remaining from the reward2 \\n        for i in range(0,len(reward2)):\\n            if(visited.get(i) != None ):\\n                continue\\n            res += reward2[i]\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        \\n        #build max heap, based on the extra we can get if we \\n        #choose reward1\\n        heap = []\\n        for i in range(0,len(reward1)):\\n            heap.append( [ -reward1[i]+reward2[i] ,i  ])\\n        heapq.heapify(heap)\\n\\n        #eat the ones where we get the most extra and store those\\n        #mark those visited\\n        visited ,res = {},0\\n        while(k):\\n            idx = heapq.heappop(heap)[1]\\n            res += reward1[idx]\\n            visited[idx] = 1\\n            k-=1\\n\\n        # eat the remaining from the reward2 \\n        for i in range(0,len(reward2)):\\n            if(visited.get(i) != None ):\\n                continue\\n            res += reward2[i]\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369897,
                "title": "streaming-solution-explained-no-sorting-o-n-log-k",
                "content": "# Intuition\\nThe most important thing that matters is the advantage $$r_1[i]-r_2[i]$$ (the difference of rewards for mouse 1 and 2 respectively). We want to give mouse 1 the cheese whenever it has the greatest advantage and mouse 2 the cheese whenever it has greatest advantage. \\n\\n# Sorting Solution\\n\\nOne way to do this would be by sorting and giving mouse 1 the $$k$$ cheeses where it has the greatest advantage and mouse 2 the remaining cheese:\\n```\\nclass Solution:\\n    def miceAndCheese(self, r1: List[int], r2: List[int], k: int) -> int:\\n        adv = [(x-y,y) for x,y in zip(r1,r2)]\\n        adv.sort(reverse=True)\\n        r1 = sum(d+y for d,y in adv[:k])\\n        r2 = sum(y for _,y in adv[k:])\\n        return r1 + r2\\n```\\n\\n##### Complexity of Sorting Solution\\n- Time complexity: $$O(N \\\\log N)$$ \\n- Space complexity: $$O(N)$$\\n\\n##### Drawbacks of Sorting Solution\\nWe have to see all the data at least once before we can do anything. Additionally, the complexity is independent of $$k$$. As we shall see, we can improve both space and time complexity if we allow ourselves to take into account $$k$$ by using heaps.\\n\\n# Heap Solution (No Sorting)\\n\\nMouse 1 only needs the $$k$$ cheeses where it has the largest advantage. Let\\'s exploit this. \\n\\nLet\\'s build a min-heap where items are sorted by mouse 1\\'s advantage $$r_1[i]-r_2[i]$$. We\\'ll build this one reward pair at a time as we scan through `zip(r1,r2)`. We\\'ll also attach the reward value to each item so we can tally up the points later.\\n\\nWe can limit heap size to $$k$$ and eject the smallest element if we need to make space for an incoming item. Every time we eject an item, that means mouse 2 will be getting that cheese, so we increment the tally by $$r_2[i]$$. \\n\\nAt the end, the heap contains precisely the $$k$$ cheeses where mouse 1 has the greatest advantage. We add mouse 1\\'s rewards for those cheese to the final tally and we\\'re done.\\n\\n```python\\nfrom heapq import heappush as push, heappop as pop\\nclass Solution:\\n    def miceAndCheese(self, r1: List[int], r2: List[int], k: int) -> int:\\n        heap, ans = [], 0\\n        for x,y in zip(r1, r2):\\n            push(heap, (x-y,y))\\n            if len(heap) > k:\\n                ans += pop(heap)[1]\\n        return ans + sum(d+y for d,y in heap)\\n```\\n##### Complexity of Heap Solution\\nThe heap never gets larger than size $$k$$. Thus,\\n\\n- Time complexity: $$O(N \\\\log k)$$ \\n- Space complexity: $$O(k)$$\\n\\nSince $$k\\\\leq n$$ this is better than the sorting solution when accounting for $$k$$. \\n\\n##### This is a streaming solution\\n\\nThis means that this will still solve the problem even if we are told the reward pairs one-by-one without knowledge of how many more rewards remain. In other words, this will work even if the reward pairs are generated on the fly.",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Data Stream"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, r1: List[int], r2: List[int], k: int) -> int:\\n        adv = [(x-y,y) for x,y in zip(r1,r2)]\\n        adv.sort(reverse=True)\\n        r1 = sum(d+y for d,y in adv[:k])\\n        r2 = sum(y for _,y in adv[k:])\\n        return r1 + r2\\n```\n```python\\nfrom heapq import heappush as push, heappop as pop\\nclass Solution:\\n    def miceAndCheese(self, r1: List[int], r2: List[int], k: int) -> int:\\n        heap, ans = [], 0\\n        for x,y in zip(r1, r2):\\n            push(heap, (x-y,y))\\n            if len(heap) > k:\\n                ans += pop(heap)[1]\\n        return ans + sum(d+y for d,y in heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369654,
                "title": "java-sorting-greedy-explained",
                "content": "# Approach:\\nThe difference of rewards will tell us which cheese to feed to which mouse. \\n\\nWe will do `reward1[i] - reward2[i]`\\n\\nIf difference is positive means `reward1[i]` is greater so we will feed that index\\'s cheese to the first mouse.\\nElse that index\\'s cheese would be fed to the second mouse.\\n\\nSo we sort the data structure which holds the difference of rewards.\\n\\nThe first $$k$$ cheese would be fed to the first mouse, then the rest of the cheese after that would be fed to the second mouse.\\n\\n---\\n\\n# Solution:\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int[][] r1 = new int[n][2];\\n        // storing the indices along with the differences\\n        // because we\\'ll need to fetch the reward using the indices\\n        // from the two given arrays\\n        for (int i = 0; i < n; i++) {\\n            r1[i] = new int[] {reward1[i] - reward2[i], i};\\n        }\\n        \\n        // sort on the basis of difference (in descending order)\\n        Arrays.sort(r1, (a, b) -> b[0] - a[0]);\\n        int reward = 0;\\n        \\n        // feed the first top \\'k\\' rewarding cheese to the first mouse\\n        for (int i = 0; i < k; i++) {\\n            reward += reward1[r1[i][1]];\\n        }\\n        // feed the leftover to the second mouse\\n        for (int i = k; i < n; i++) {\\n            reward += reward2[r1[i][1]];\\n        }\\n        \\n        return reward;\\n    }\\n}\\n```\\n##### Time complexity: $$O(n) + O(2n.log2n) + O(k + n - k) => O(n.logn)$$\\n##### Space complexity: $$O(2.n) => O(n)$$",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int[][] r1 = new int[n][2];\\n        // storing the indices along with the differences\\n        // because we\\'ll need to fetch the reward using the indices\\n        // from the two given arrays\\n        for (int i = 0; i < n; i++) {\\n            r1[i] = new int[] {reward1[i] - reward2[i], i};\\n        }\\n        \\n        // sort on the basis of difference (in descending order)\\n        Arrays.sort(r1, (a, b) -> b[0] - a[0]);\\n        int reward = 0;\\n        \\n        // feed the first top \\'k\\' rewarding cheese to the first mouse\\n        for (int i = 0; i < k; i++) {\\n            reward += reward1[r1[i][1]];\\n        }\\n        // feed the leftover to the second mouse\\n        for (int i = k; i < n; i++) {\\n            reward += reward2[r1[i][1]];\\n        }\\n        \\n        return reward;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369184,
                "title": "simple-expalnation",
                "content": "# Intuition:Let the first mouse eat those particular cheese which the second mouse would have eaten with lesser reward amount.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        int ans=0;\\n        for(int i=0;i<reward1.size();i++){\\n            pq.push({reward1[i]-reward2[i],i});\\n\\n        }\\n        while(k--){\\n            auto it=pq.top();\\n            ans+=reward1[it.second];\\n            pq.pop();\\n            \\n        }\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            ans+=reward2[it.second];\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        int ans=0;\\n        for(int i=0;i<reward1.size();i++){\\n            pq.push({reward1[i]-reward2[i],i});\\n\\n        }\\n        while(k--){\\n            auto it=pq.top();\\n            ans+=reward1[it.second];\\n            pq.pop();\\n            \\n        }\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            ans+=reward2[it.second];\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368890,
                "title": "go-sort",
                "content": "# Code\\n```\\nfunc miceAndCheese(reward1 []int, reward2 []int, k int) int {\\n\\n    rewards := make([][]int, len(reward1))\\n    for i := 0; i < len(reward1); i++ {\\n        rewards[i] = []int{ reward1[i] - reward2[i], reward1[i], reward2[i] }\\n    }\\n    sort.Slice(rewards, func(i, j int) bool {\\n        return rewards[i][0] > rewards[j][0]\\n    })\\n    \\n    ans := 0\\n    for _, r := range rewards[:k] {\\n        ans += r[1]\\n    }\\n    for _, r := range rewards[k:] {\\n        ans += r[2]\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sort"
                ],
                "code": "```\\nfunc miceAndCheese(reward1 []int, reward2 []int, k int) int {\\n\\n    rewards := make([][]int, len(reward1))\\n    for i := 0; i < len(reward1); i++ {\\n        rewards[i] = []int{ reward1[i] - reward2[i], reward1[i], reward2[i] }\\n    }\\n    sort.Slice(rewards, func(i, j int) bool {\\n        return rewards[i][0] > rewards[j][0]\\n    })\\n    \\n    ans := 0\\n    for _, r := range rewards[:k] {\\n        ans += r[1]\\n    }\\n    for _, r := range rewards[k:] {\\n        ans += r[2]\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368620,
                "title": "easy-and-fast-solution-o-nlogn-time-o-n-space",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar miceAndCheese = function(reward1, reward2, k) {\\n    let arr=[];\\n    for(let i=0;i<reward1.length;i++){\\n        let x=reward1[i]-reward2[i];\\n        arr.push([x,i]);\\n    }\\n    arr.sort((a,b)=>b[0]-a[0]);\\n    let res=0;\\n    for(let i=0;i<reward1.length;i++){\\n        if(i<k) res+=reward1[arr[i][1]];\\n        else res+=reward2[arr[i][1]];    \\n    }\\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar miceAndCheese = function(reward1, reward2, k) {\\n    let arr=[];\\n    for(let i=0;i<reward1.length;i++){\\n        let x=reward1[i]-reward2[i];\\n        arr.push([x,i]);\\n    }\\n    arr.sort((a,b)=>b[0]-a[0]);\\n    let res=0;\\n    for(let i=0;i<reward1.length;i++){\\n        if(i<k) res+=reward1[arr[i][1]];\\n        else res+=reward2[arr[i][1]];    \\n    }\\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368599,
                "title": "c-1-line-solution-with-linq",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MiceAndCheese(int[] reward1, int[] reward2, int k) {\\n        return reward2.Sum() + reward1.Zip(reward2, (a, b) => a - b).OrderByDescending(p => p).Take(k).Sum();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MiceAndCheese(int[] reward1, int[] reward2, int k) {\\n        return reward2.Sum() + reward1.Zip(reward2, (a, b) => a - b).OrderByDescending(p => p).Take(k).Sum();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368535,
                "title": "c-sorting-and-compare",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int, int>> a;\\n        for(int i = 0; i < reward1.size(); i++){\\n            a.push_back({reward1[i] - reward2[i], i});\\n        }\\n    \\n        sort(a.begin(), a.end(), greater<pair<int,int>>());\\n        int sum = 0;\\n        \\n        for(int i = 0; i < k; i++){\\n            sum += reward1[a[i].second];\\n        }\\n        \\n        for(int i = k; i < a.size(); i++){\\n            sum += reward2[a[i].second];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int, int>> a;\\n        for(int i = 0; i < reward1.size(); i++){\\n            a.push_back({reward1[i] - reward2[i], i});\\n        }\\n    \\n        sort(a.begin(), a.end(), greater<pair<int,int>>());\\n        int sum = 0;\\n        \\n        for(int i = 0; i < k; i++){\\n            sum += reward1[a[i].second];\\n        }\\n        \\n        for(int i = k; i < a.size(); i++){\\n            sum += reward2[a[i].second];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368519,
                "title": "help-why-give-s-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<vector<int>> nums(reward1.size());\\n        for(int i=0;i<reward1.size();i++){\\n            nums[i] = {reward1[i]-reward2[i],reward1[i],reward2[i]};\\n        }\\n        sort(nums.begin(),nums.end(),[&](const vector<int> a,const vector<int> b){\\n            return a[0]>b[0];\\n        });\\n        long long ans=0;\\n        int i=0;\\n        while(i<k) ans += nums[i++][1];\\n        while(i<nums.size()) ans += nums[i++][2];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<vector<int>> nums(reward1.size());\\n        for(int i=0;i<reward1.size();i++){\\n            nums[i] = {reward1[i]-reward2[i],reward1[i],reward2[i]};\\n        }\\n        sort(nums.begin(),nums.end(),[&](const vector<int> a,const vector<int> b){\\n            return a[0]>b[0];\\n        });\\n        long long ans=0;\\n        int i=0;\\n        while(i<k) ans += nums[i++][1];\\n        while(i<nums.size()) ans += nums[i++][2];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368469,
                "title": "difference-array-c-sorting-explanation",
                "content": "Sort the array in desc order according to difference, remember we need the abs diff to maximise answer. Now start from max values and if more than k values are present then we can choose the max of both rewards else we are bound to choose reward1 as we need k elements\\n\\nComplexity -> O(nlogn)\\n\\n```\\nstruct data {\\n    int a, b, diff ;\\n};\\nbool comp(struct data A, struct data B){\\n    return A.diff > B.diff ;\\n}\\nclass Solution {\\npublic:\\n    \\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<struct data>v(n) ;\\n        for(int i = 0 ; i < n;i++){\\n            v[i].a = reward1[i];\\n            v[i].b = reward2[i] ;\\n            v[i].diff = abs(reward1[i] - reward2[i]);\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        int ans= 0 ;\\n        for(int i = 0 ; i < n;i++){\\n            if( k > 0){\\n                if(n-i > k){\\n                    ans += max(v[i].a, v[i].b);\\n                    if(max(v[i].a, v[i].b) == v[i].a)\\n                    k--;\\n                }\\n                else{\\n                    ans += v[i].a;\\n                    k--;\\n                }\\n                    \\n            }\\n            else\\n                ans += v[i].b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nstruct data {\\n    int a, b, diff ;\\n};\\nbool comp(struct data A, struct data B){\\n    return A.diff > B.diff ;\\n}\\nclass Solution {\\npublic:\\n    \\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<struct data>v(n) ;\\n        for(int i = 0 ; i < n;i++){\\n            v[i].a = reward1[i];\\n            v[i].b = reward2[i] ;\\n            v[i].diff = abs(reward1[i] - reward2[i]);\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        int ans= 0 ;\\n        for(int i = 0 ; i < n;i++){\\n            if( k > 0){\\n                if(n-i > k){\\n                    ans += max(v[i].a, v[i].b);\\n                    if(max(v[i].a, v[i].b) == v[i].a)\\n                    k--;\\n                }\\n                else{\\n                    ans += v[i].a;\\n                    k--;\\n                }\\n                    \\n            }\\n            else\\n                ans += v[i].b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368463,
                "title": "using-sorting-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution(object):\\n    def miceAndCheese(self, reward1, reward2, k):\\n        \"\"\"\\n        :type reward1: List[int]\\n        :type reward2: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        new_arr=[(reward1[i]-reward2[i],reward1[i] , reward2[i]) for i in range(len(reward2))]\\n        new_arr.sort(reverse=True)\\n        res = 0\\n        for i in range(k):\\n            res += new_arr[i][1]\\n            \\n        for i in range(k , len(reward1)):\\n            res += new_arr[i][2]\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def miceAndCheese(self, reward1, reward2, k):\\n        \"\"\"\\n        :type reward1: List[int]\\n        :type reward2: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        new_arr=[(reward1[i]-reward2[i],reward1[i] , reward2[i]) for i in range(len(reward2))]\\n        new_arr.sort(reverse=True)\\n        res = 0\\n        for i in range(k):\\n            res += new_arr[i][1]\\n            \\n        for i in range(k , len(reward1)):\\n            res += new_arr[i][2]\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368419,
                "title": "easy-solution-with-explaination-c",
                "content": "# Approach\\nfirst make the optimal choice by taking the maximum from both the array now check if number of target1s taking is greater or smaller than k if its greater or smaller for that array of difference if the now for compernsating those extra values (extra than k) use then diff array to take those elements which contribute to least difference in the optimal answer like :-\\n\\nfor 4 4 2\\n    6 1 1\\nif k = 1 and we took index 1,2 from a so now for extra one element chosen make that diff array that is for 1,2 index element = [-3,-1]\\nnow for that extra one element taken from take take 2 element that is contributing least negative value that is -1 and add it in optimal ans that is \\n\\noptimal ans = 6 + 4 + 2\\n\\nfinal ans = 6 + 4 + 2 - 1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        int ans = 0;\\n        \\n        vector<int> diffe , diffl;\\n        int t1 = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(reward1[i] >= reward2[i]) {\\n                ans += reward1[i];\\n                diffl.push_back(reward2[i] - reward1[i]);\\n                t1++;\\n            }\\n            else{\\n                ans += reward2[i];\\n                diffe.push_back(reward1[i] - reward2[i]);\\n            }\\n        }\\n        sort(diffe.begin() , diffe.end() , greater<int>());\\n        sort(diffl.begin() , diffl.end() , greater<int>());\\n        cout<<ans<<endl;\\n        \\n        if(t1 < k) {\\n            for(int i=0;i<(k-t1);i++) {\\n                ans += diffe[i];\\n            }\\n            return ans;\\n        }\\n        \\n        else if(t1 > k) {\\n            for(int i=0;i<(t1-k);i++) {\\n                ans += diffl[i];\\n            }\\n            return ans;\\n        }\\n        else return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        int ans = 0;\\n        \\n        vector<int> diffe , diffl;\\n        int t1 = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(reward1[i] >= reward2[i]) {\\n                ans += reward1[i];\\n                diffl.push_back(reward2[i] - reward1[i]);\\n                t1++;\\n            }\\n            else{\\n                ans += reward2[i];\\n                diffe.push_back(reward1[i] - reward2[i]);\\n            }\\n        }\\n        sort(diffe.begin() , diffe.end() , greater<int>());\\n        sort(diffl.begin() , diffl.end() , greater<int>());\\n        cout<<ans<<endl;\\n        \\n        if(t1 < k) {\\n            for(int i=0;i<(k-t1);i++) {\\n                ans += diffe[i];\\n            }\\n            return ans;\\n        }\\n        \\n        else if(t1 > k) {\\n            for(int i=0;i<(t1-k);i++) {\\n                ans += diffl[i];\\n            }\\n            return ans;\\n        }\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3368365,
                "title": "greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(),res = 0;\\n        \\n        //maximum diff \\n        vector<vector<int>> diff(n);\\n        for (int i = 0; i < n; i++)diff[i] = {reward1[i] - reward2[i], i};\\n        \\n        //sort and take vis array\\n        vector<int> vis(n);\\n        sort(diff.rbegin(), diff.rend());\\n        \\n        // take points from rewards\\n        for(int i= 0;i<k;i++)  res += reward1[diff[i][1]],vis[diff[i][1]] = 1;\\n        for(int i= 0;i<reward2.size();i++)if(!vis[i])res+=reward2[i];\\n        \\n        // we got the answer\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(),res = 0;\\n        \\n        //maximum diff \\n        vector<vector<int>> diff(n);\\n        for (int i = 0; i < n; i++)diff[i] = {reward1[i] - reward2[i], i};\\n        \\n        //sort and take vis array\\n        vector<int> vis(n);\\n        sort(diff.rbegin(), diff.rend());\\n        \\n        // take points from rewards\\n        for(int i= 0;i<k;i++)  res += reward1[diff[i][1]],vis[diff[i][1]] = 1;\\n        for(int i= 0;i<reward2.size();i++)if(!vis[i])res+=reward2[i];\\n        \\n        // we got the answer\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368336,
                "title": "simple-c-solution",
                "content": "# Intuition\\nwe have to make sure that a larger reward should not missed because of some smaller reward that is rewarded to mice 1.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo to achieve that we pair the rewards ans sort them according to thier difference\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static bool comp(vector<int> &a, vector<int> &b){\\n        return a[0]-a[1] > b[0]-b[1]; \\n    }\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        int n = r1.size(); \\n        vector<vector<int>> v(n, vector<int>(2)); \\n        for(int i=0; i<n; i++){\\n            v[i] = {r1[i], r2[i]}; \\n        }\\n        sort(v.begin(), v.end(), comp); \\n        \\n        int res = 0; \\n        for(int i=0; i<n; i++){\\n            if(i<k){\\n                res += v[i][0]; // for mice 1\\n            }\\n            else res += v[i][1]; // for mice 2\\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    static bool comp(vector<int> &a, vector<int> &b){\\n        return a[0]-a[1] > b[0]-b[1]; \\n    }\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        int n = r1.size(); \\n        vector<vector<int>> v(n, vector<int>(2)); \\n        for(int i=0; i<n; i++){\\n            v[i] = {r1[i], r2[i]}; \\n        }\\n        sort(v.begin(), v.end(), comp); \\n        \\n        int res = 0; \\n        for(int i=0; i<n; i++){\\n            if(i<k){\\n                res += v[i][0]; // for mice 1\\n            }\\n            else res += v[i][1]; // for mice 2\\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368305,
                "title": "simple-greedy-approach-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe constraints on this problem only allow for a O(n) or O(log n) solution. So using 01 knapsack or other dynamic programming approaches will give TLE.\\n\\nThis is why we need to use greedy approach.\\nFor this we need to find exactly k elements with maximum benefit to the answer from reward1 array, and then remaining can be added from reward2 matrix.\\n\\nTo find the first k elements with maximum benefit, we need to find the difference between reward1[I] and reward2[I], and store it with their index for easier addition in later stages.\\nOnce we have the differences with indices, sort the differences in descending order. This will give the best elements to be added from reward1[I] indices at the first k positions in the diff array. \\nAdd the first k elements based on indices from diff, and add the remaining elements from reward2 array to form the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n * logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        vector<pair<int, int>> diff;\\n        for(int i = 0; i < r1.size(); ++i)  diff.push_back({r1[i] - r2[i], i});\\n        sort(diff.begin(), diff.end(),[&](auto &a, auto &b){\\n            return a.first > b.first;\\n        });\\n        int ans = 0;\\n        vector<bool> vis(r1.size(), false);\\n        for(int i = 0; i < k; ++i){\\n            vis[diff[i].second] = true;\\n            ans += r1[diff[i].second];\\n        }\\n        for(int i = 0; i < r1.size(); ++i){\\n            if(vis[i] == false) ans += r2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE THE SOLUTION IF IT WAS HELPFUL",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        vector<pair<int, int>> diff;\\n        for(int i = 0; i < r1.size(); ++i)  diff.push_back({r1[i] - r2[i], i});\\n        sort(diff.begin(), diff.end(),[&](auto &a, auto &b){\\n            return a.first > b.first;\\n        });\\n        int ans = 0;\\n        vector<bool> vis(r1.size(), false);\\n        for(int i = 0; i < k; ++i){\\n            vis[diff[i].second] = true;\\n            ans += r1[diff[i].second];\\n        }\\n        for(int i = 0; i < r1.size(); ++i){\\n            if(vis[i] == false) ans += r2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368277,
                "title": "best-code-in-c-minheap",
                "content": "## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n# Complexity\\n- Time complexity:\\nO(nlogk)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n=reward1.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<n;i++){\\n            int diff=reward1[i] - reward2[i];\\n            pq.push({diff,i});\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        int ans=0;\\n        vector<int> mark(n);\\n        while(pq.size()){\\n            int ind=pq.top().second;\\n            ans += reward1[ind];\\n            pq.pop();\\n            mark[ind]=1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mark[i]==0)\\n                ans += reward2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/397c8e3f-b237-4fc9-8053-c35a27b0b49f_1680408169.4994588.png)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n=reward1.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<n;i++){\\n            int diff=reward1[i] - reward2[i];\\n            pq.push({diff,i});\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        int ans=0;\\n        vector<int> mark(n);\\n        while(pq.size()){\\n            int ind=pq.top().second;\\n            ans += reward1[ind];\\n            pq.pop();\\n            mark[ind]=1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mark[i]==0)\\n                ans += reward2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368271,
                "title": "python-two-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def miceAndCheese(self, reward1, reward2, k):\\n        \"\"\"\\n        :type reward1: List[int]\\n        :type reward2: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        diff = [reward1[i] - reward2[i] for i in range(len(reward1))]\\n        \\n        return sum(reward2) + sum( sorted(diff, reverse = True)[:k])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def miceAndCheese(self, reward1, reward2, k):\\n        \"\"\"\\n        :type reward1: List[int]\\n        :type reward2: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        diff = [reward1[i] - reward2[i] for i in range(len(reward1))]\\n        \\n        return sum(reward2) + sum( sorted(diff, reverse = True)[:k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368262,
                "title": "java-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> Integer.compare(b.getValue(), a.getValue()));\\n        for (int i = 0; i < reward1.length; i++) {\\n            int diff = reward1[i] - reward2[i];\\n            pq.offer(new Pair(i, diff));\\n        }\\n        int result = 0;\\n        Set<Integer> set = new HashSet<>();\\n        while (!pq.isEmpty() && k > 0) {\\n            Pair<Integer, Integer> pair = pq.poll();\\n            result = result + reward1[pair.getKey()];\\n            set.add(pair.getKey());\\n            k--;\\n        }\\n        for (int i = 0; i < reward2.length; i++) {\\n            if (set.contains(i)) continue;\\n            result = result + reward2[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> Integer.compare(b.getValue(), a.getValue()));\\n        for (int i = 0; i < reward1.length; i++) {\\n            int diff = reward1[i] - reward2[i];\\n            pq.offer(new Pair(i, diff));\\n        }\\n        int result = 0;\\n        Set<Integer> set = new HashSet<>();\\n        while (!pq.isEmpty() && k > 0) {\\n            Pair<Integer, Integer> pair = pq.poll();\\n            result = result + reward1[pair.getKey()];\\n            set.add(pair.getKey());\\n            k--;\\n        }\\n        for (int i = 0; i < reward2.length; i++) {\\n            if (set.contains(i)) continue;\\n            result = result + reward2[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368260,
                "title": "nlogk-greedy-hashing-heap",
                "content": "**Approch: Greedy: Pick the maximum cheese for mouse1 and rest for mouse2**\\n```\\n// TC: O(NlogK)\\n// SC: O(K)\\n#define ll long long\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& arr1, vector<int>& arr2, int k){\\n        int n = arr1.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>,greater<pair<int, int>>> pq;\\n        \\n        for(int i = 0; i < n; i++){\\n            pq.push({arr1[i] - arr2[i], i});\\n            if(pq.size() > k){\\n                pq.pop();\\n            }\\n        }\\n        \\n        unordered_set<int> set;\\n        while(pq.size()){\\n            set.insert(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        ll ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(set.count(i)){\\n                ans += arr1[i];\\n            }else{\\n                ans += arr2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// TC: O(NlogK)\\n// SC: O(K)\\n#define ll long long\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& arr1, vector<int>& arr2, int k){\\n        int n = arr1.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>,greater<pair<int, int>>> pq;\\n        \\n        for(int i = 0; i < n; i++){\\n            pq.push({arr1[i] - arr2[i], i});\\n            if(pq.size() > k){\\n                pq.pop();\\n            }\\n        }\\n        \\n        unordered_set<int> set;\\n        while(pq.size()){\\n            set.insert(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        ll ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(set.count(i)){\\n                ans += arr1[i];\\n            }else{\\n                ans += arr2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368255,
                "title": "javascript-greedy-w-sorting",
                "content": "**Solution: Greedy w/ Sorting**\\n\\nThe first mouse should always take the `k` cheese with the maximum difference (`reward1[i] - reward2[i]`).\\nThis ensures the loss is minimal.\\n\\nTime Complexity: `O(n log(n))`\\nSpace Complexity: `O(n)`\\n```\\nvar miceAndCheese = function(reward1, reward2, k) {\\n  let n = reward1.length, rewards = [];\\n  for (let i = 0; i < n; i++) {\\n    rewards.push([reward1[i], reward2[i], reward1[i] - reward2[i]]);\\n  }\\n  rewards.sort((a, b) => b[2] - a[2]);\\n  let score = 0;\\n  for (let i = 0; i < n; i++) {\\n    score += i < k ? rewards[i][0] : rewards[i][1];\\n  }\\n  return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar miceAndCheese = function(reward1, reward2, k) {\\n  let n = reward1.length, rewards = [];\\n  for (let i = 0; i < n; i++) {\\n    rewards.push([reward1[i], reward2[i], reward1[i] - reward2[i]]);\\n  }\\n  rewards.sort((a, b) => b[2] - a[2]);\\n  let score = 0;\\n  for (let i = 0; i < n; i++) {\\n    score += i < k ? rewards[i][0] : rewards[i][1];\\n  }\\n  return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038130,
                "title": "easy-c-solution-with-sort-and-accumulate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need k types of cheese from reward1 and (n-k) type of cheese from reward2 to maximize the sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Get the sume of all types of cheese in reward2\\n2. Find the top k reward1 values with maximum (reward1 - reward2) values.\\n3. Add the sum of such k values to the sum in step 1. \\n\\nPlease note that we just need the maximum sum as result, not the individual top k values or their indices.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        // Store reward diff reward1 - reward2\\n        // Calculate reward2 sum\\n        vector<int> diff12;\\n        int sum = 0;\\n        for(int i = 0; i < reward1.size(); ++i) {\\n            diff12.push_back(reward1[i] - reward2[i]);\\n            sum += reward2[i];\\n        }\\n        \\n        // Add top k diff\\'s to sum\\n        sort(diff12.begin(), diff12.end(), greater<int>());\\n        return accumulate(diff12.begin(), diff12.begin() + k, sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        // Store reward diff reward1 - reward2\\n        // Calculate reward2 sum\\n        vector<int> diff12;\\n        int sum = 0;\\n        for(int i = 0; i < reward1.size(); ++i) {\\n            diff12.push_back(reward1[i] - reward2[i]);\\n            sum += reward2[i];\\n        }\\n        \\n        // Add top k diff\\'s to sum\\n        sort(diff12.begin(), diff12.end(), greater<int>());\\n        return accumulate(diff12.begin(), diff12.begin() + k, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992379,
                "title": "easy-solution-priority-queue-c",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Priority Queue\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<vector<int>> pq;\\n        int n = reward1.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            //sorts in descending according to the difference \\n            pq.push({reward1[i]-reward2[i] , reward1[i] , reward2[i]});\\n        }\\n        while(k>0){\\n            ans += pq.top()[1];\\n            pq.pop();\\n            k--;\\n        }\\n        while(!pq.empty()){\\n            ans += pq.top()[2];\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<vector<int>> pq;\\n        int n = reward1.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            //sorts in descending according to the difference \\n            pq.push({reward1[i]-reward2[i] , reward1[i] , reward2[i]});\\n        }\\n        while(k>0){\\n            ans += pq.top()[1];\\n            pq.pop();\\n            k--;\\n        }\\n        while(!pq.empty()){\\n            ans += pq.top()[2];\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980777,
                "title": "easy-solution-after-2-wa",
                "content": "# Intuition\\nSort on basis of difference in descending order. Add reward1 untill k exhausts. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsee code\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int,int>>p;\\n        int n = reward1.size();\\n        for(int i=0;i<n;i++){\\n            p.push_back({reward1[i]-reward2[i],i});\\n        }\\n        sort(p.begin(),p.end(),greater<>());\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int ind = p[i].second;\\n            if(k) {\\n                ans+=reward1[ind];\\n                k--;\\n            }\\n            else ans+= reward2[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int,int>>p;\\n        int n = reward1.size();\\n        for(int i=0;i<n;i++){\\n            p.push_back({reward1[i]-reward2[i],i});\\n        }\\n        sort(p.begin(),p.end(),greater<>());\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int ind = p[i].second;\\n            if(k) {\\n                ans+=reward1[ind];\\n                k--;\\n            }\\n            else ans+= reward2[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938281,
                "title": "simple-math-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n       int sum=0;\\n        int n=reward1.size();\\n         vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\nsum+=reward2[i];\\n            ans[i]=reward2[i]-reward1[i];\\n        }\\n     sort(ans.begin(),ans.end());\\n        for(int i=0;i<k;i++){\\nsum-=ans[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n       int sum=0;\\n        int n=reward1.size();\\n         vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\nsum+=reward2[i];\\n            ans[i]=reward2[i]-reward1[i];\\n        }\\n     sort(ans.begin(),ans.end());\\n        for(int i=0;i<k;i++){\\nsum-=ans[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929090,
                "title": "python3-one-line",
                "content": "# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        return sum(reward2) if k==0 else sum(reward2)+sum(sorted([reward1[i]-reward2[i] for i in range(len(reward1))])[-k:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        return sum(reward2) if k==0 else sum(reward2)+sum(sorted([reward1[i]-reward2[i] for i in range(len(reward1))])[-k:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914964,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> v;\\n        int ans=0;\\n        for(int i=0;i<reward1.size();i++){\\n            v.push_back(reward1[i]-reward2[i]);\\n        }\\n        for(int i=0;i<v.size();i++){\\n            pq.push({v[i],i});\\n        }\\n        for(int i=0;i<k;i++){\\n            reward2[pq.top().second]=0;\\n            ans+=reward1[pq.top().second];\\n            pq.pop();\\n        }\\n        for(int i=0;i<reward2.size();i++){\\n            ans+=reward2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> v;\\n        int ans=0;\\n        for(int i=0;i<reward1.size();i++){\\n            v.push_back(reward1[i]-reward2[i]);\\n        }\\n        for(int i=0;i<v.size();i++){\\n            pq.push({v[i],i});\\n        }\\n        for(int i=0;i<k;i++){\\n            reward2[pq.top().second]=0;\\n            ans+=reward1[pq.top().second];\\n            pq.pop();\\n        }\\n        for(int i=0;i<reward2.size();i++){\\n            ans+=reward2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910944,
                "title": "javascript-map-sort-reduce-chaining",
                "content": "# Approach\\nhttps://leetcode.com/problems/mice-and-cheese/solutions/3368322/java-c-python-k-largest-a-i-b-i/\\n\\nTime complexity: $$O(nlogn)$$\\nSpace complexity: $$O(n)$$\\n\\n# Code\\n```\\nvar miceAndCheese = function(reward1, reward2, k) {\\n    return reward1\\n      .map((reward, idx) => [reward, reward2[idx], reward - reward2[idx]])\\n      .sort((b, a) => a[2] - b[2])\\n      .reduce((acc, [a, b], idx) => acc + (idx < k ? a : b), 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar miceAndCheese = function(reward1, reward2, k) {\\n    return reward1\\n      .map((reward, idx) => [reward, reward2[idx], reward - reward2[idx]])\\n      .sort((b, a) => a[2] - b[2])\\n      .reduce((acc, [a, b], idx) => acc + (idx < k ? a : b), 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906445,
                "title": "java-solution-o-nlog-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nLog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Pair implements Comparable<Pair>{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second){\\n        this.first = first;\\n        this.second = second;\\n    }\\n\\n    public int compareTo(Pair other){\\n        return Integer.compare(this.first, other.first);\\n    }\\n}\\n\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int[] diff = new int[reward1.length];\\n        int sum = 0;\\n\\n        for(int i = 0; i < reward1.length; i++){\\n            diff[i] = reward1[i] - reward2[i];    \\n            pq.add(new Pair(diff[i], i));\\n        }\\n\\n        for(int i = 0; i < k;){\\n            reward2[pq.peek().second] = 0;\\n            System.out.println(pq.peek().first);\\n            sum += reward1[pq.poll().second];\\n            i++;\\n        }\\n\\n        for(int i = 0; i < reward2.length; i++)\\n            sum += reward2[i];\\n\\n        return sum;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair implements Comparable<Pair>{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second){\\n        this.first = first;\\n        this.second = second;\\n    }\\n\\n    public int compareTo(Pair other){\\n        return Integer.compare(this.first, other.first);\\n    }\\n}\\n\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int[] diff = new int[reward1.length];\\n        int sum = 0;\\n\\n        for(int i = 0; i < reward1.length; i++){\\n            diff[i] = reward1[i] - reward2[i];    \\n            pq.add(new Pair(diff[i], i));\\n        }\\n\\n        for(int i = 0; i < k;){\\n            reward2[pq.peek().second] = 0;\\n            System.out.println(pq.peek().first);\\n            sum += reward1[pq.poll().second];\\n            i++;\\n        }\\n\\n        for(int i = 0; i < reward2.length; i++)\\n            sum += reward2[i];\\n\\n        return sum;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866912,
                "title": "simple-c-solution-using-max-heap",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        priority_queue<pair<int, int> > pq;\\n        int ans = 0;\\n        \\n        for(int i=0 ;i<n ;i++){\\n            ans+=reward2[i];\\n            pq.push({reward1[i]-reward2[i], i});\\n        }\\n\\n        int i=0;\\n        while(i<k){\\n            int temp = pq.top().first;\\n            pq.pop();\\n            ans += temp;\\n            i++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        priority_queue<pair<int, int> > pq;\\n        int ans = 0;\\n        \\n        for(int i=0 ;i<n ;i++){\\n            ans+=reward2[i];\\n            pq.push({reward1[i]-reward2[i], i});\\n        }\\n\\n        int i=0;\\n        while(i<k){\\n            int temp = pq.top().first;\\n            pq.pop();\\n            ans += temp;\\n            i++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846018,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        if(k >= reward1.length){\\n            int ans = 0;\\n            for(int i : reward1){\\n                ans = ans + i;\\n            }\\n            return ans;\\n        }\\n\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]) );\\n\\n        for(int i = 0; i < reward1.length; i++){\\n            pq.add(new int[]{reward1[i] - reward2[i], i });\\n            if(pq.size() > k){\\n                pq.poll();\\n            }\\n        }\\n\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        while(!pq.isEmpty()){\\n            set.add(pq.peek()[1]);\\n            pq.poll();\\n        }\\n\\n        int n = reward1.length;\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(set.contains(i)){\\n                ans = ans + reward1[i];\\n            }\\n            else{\\n                ans = ans + reward2[i]; \\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        if(k >= reward1.length){\\n            int ans = 0;\\n            for(int i : reward1){\\n                ans = ans + i;\\n            }\\n            return ans;\\n        }\\n\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]) );\\n\\n        for(int i = 0; i < reward1.length; i++){\\n            pq.add(new int[]{reward1[i] - reward2[i], i });\\n            if(pq.size() > k){\\n                pq.poll();\\n            }\\n        }\\n\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        while(!pq.isEmpty()){\\n            set.add(pq.peek()[1]);\\n            pq.poll();\\n        }\\n\\n        int n = reward1.length;\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(set.contains(i)){\\n                ans = ans + reward1[i];\\n            }\\n            else{\\n                ans = ans + reward2[i]; \\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843650,
                "title": "simple-greedy-approach-explained",
                "content": "# Overview\\nAt first, the problem might seem a bit tricky due to the condition that the first mouse eats exactly k types of cheese. A simple, brute-force solution would be just to check \\u2018every\\u2019 possibility of eating cheese; for every type, we make two choices, either the first mouse eats it or the second mouse eats it, leading to a total of `2n` possibilities and extracting the maximum from them, which is obviously not the intended solution :)\\n\\nHere, I explain a step-by-step solution on how to build upon the thinking process and come up with an optimal solution.\\n\\n\\n# Greedy Approach\\nFirst, let\\'s find the challenging part of the problem, which is nothing but the condition that the first mouse eats exactly k types of cheese, so we need to choose only k elements from the `rewards1` array and the remaining n-k from the `rewards2` array. Let\\'s make the problem a bit simpler by removing this condition altogether.\\nWhat if this condition was not there? In that case, we could greedily choose the mouse, which gives more reward for each type of cheese.\\n\\nConsider the following test case:\\n`reward1 = [1,1,3,4,4,1,6]`\\n`reward2 = [4,4,1,1,1,3,5]`\\n`k = 2`\\n\\nIn this case, for cheese of type 1, we can select mouse 2 (as 4 > 1)\\nFor type 2, we can again select mouse 2 (4 > 1)\\nAnd so on\\u2026\\n\\nSo, we choose the following sequence of mice to eat the cheese and get the maximum reward:\\n`2, 2, 1, 1, 1, 2, 1`\\nAs a result, the total reward is `4 + 4 + 3 + 4 + 4 + 4 + 3 + 6 = 28`. This is the maximum possible reward we can get without the given constraint.\\nBut in this case, the first mouse eats a total of 4 types of cheese, which is more than the given limit `k = 2` in the problem. So, what can we do to reduce this number?\\n\\nLet\\u2019s try reducing them one by one. Consider the 3rd type of cheese; if we use the second mouse here instead of the first one, we will basically shift one reward from 3 to 1, leading to a loss of 2 points `3 - 1` in the total reward. Similarly, the losses that we would suffer for the 4th, 5th, and 7th types of cheese would be 3, 3, and 1, respectively.\\nSo now, the problem reduces to minimizing this loss to get the maximum reward. \\nLet\\u2019s now store all these losses in a `loss` array:\\n`loss = [2, 3, 3, 1]`\\nBy now, you must have understood how we would choose these losses. Remember, we need to reduce the number that the first mouse eats from 4 to 2. So we only need to choose two of these losses so that the total loss is minimized.\\nClearly, we can choose the two minimum elements from the \\u2018loss\\u2019 array to minimize the total loss.\\n\\nMore generally, if we want to reduce the number from `i` to `f`, we will choose the `i-f` minimum elements from the `loss` array, in other words, the first `i-f` elements from the sorted `loss` array.\\n\\n`Sorted loss array = [1, 2, 3, 3]`\\n\\nIn this case, we choose 1 and 2 and reduce our total reward by `1 + 2 = 3`. Hence, the answer to this case would be `28 - 3 = 25`.\\n\\nWhat if the initial number was less than k and we needed to increase it to k? You must have guessed that we will proceed in the same manner as above by storing the losses that we would suffer if we chose the first mouse instead of the second and chose the minimum of these losses.\\n\\nHence, by removing the condition and considering it step by step, we made the problem much simpler.\\n\\n\\n# Time and Space Complexity Analysis\\nFinding the maximum possible reward takes `O(n)` time due to a single \\u2018for\\u2019 loop checking each type of cheese. Storing the losses will also take `O(n)` time. Sorting the loss array takes a maximum of `O(nlogn)` time since there can be a maximum of n losses in the loss array. Hence the overall time complexity is `O(nlogn)`. Since we are storing the losses, we are using `O(n)` extra space here.\\n\\n\\n***Interview tip***: *Don\\u2019t directly jump to the optimal solution. Try explaining the brute force solution first and build up on the optimal solution step by step, explaining your thought process.*\\n\\n***Exercise for the Reader***: *What if the reward values are the same for one or more types of cheese? Which mouse should we choose initially in that case? Would that even matter which mouse we choose?*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        int ans = 0;\\n        vector<int> loss;\\n        int m1 = 0, m2 = 0;\\n        for (int i = 0; i < n ;i++) {\\n            if (reward1[i] >= reward2[i]) {\\n                m1++;\\n                ans += reward1[i];\\n            }\\n            else {\\n                m2++;\\n                ans += reward2[i];\\n            }\\n        }\\n        if (m1 > k) {\\n            for (int i = 0; i < n; i++) {\\n                if (reward1[i] >= reward2[i]) loss.push_back(reward1[i]-reward2[i]);\\n            }\\n            sort(loss.begin(), loss.end());\\n            for (int i = 0; i < m1-k; i++) {\\n                ans -= loss[i];\\n            }\\n        }\\n        else if (k > m1) {\\n            for (int i = 0; i < n; i++) {\\n                if (reward2[i] > reward1[i]) loss.push_back(reward2[i]-reward1[i]);\\n            }\\n            sort(loss.begin(), loss.end());\\n            for (int i = 0; i < k-m1; i++) {\\n                ans -= loss[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        int ans = 0;\\n        vector<int> loss;\\n        int m1 = 0, m2 = 0;\\n        for (int i = 0; i < n ;i++) {\\n            if (reward1[i] >= reward2[i]) {\\n                m1++;\\n                ans += reward1[i];\\n            }\\n            else {\\n                m2++;\\n                ans += reward2[i];\\n            }\\n        }\\n        if (m1 > k) {\\n            for (int i = 0; i < n; i++) {\\n                if (reward1[i] >= reward2[i]) loss.push_back(reward1[i]-reward2[i]);\\n            }\\n            sort(loss.begin(), loss.end());\\n            for (int i = 0; i < m1-k; i++) {\\n                ans -= loss[i];\\n            }\\n        }\\n        else if (k > m1) {\\n            for (int i = 0; i < n; i++) {\\n                if (reward2[i] > reward1[i]) loss.push_back(reward2[i]-reward1[i]);\\n            }\\n            sort(loss.begin(), loss.end());\\n            for (int i = 0; i < k-m1; i++) {\\n                ans -= loss[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831839,
                "title": "simple-to-understand-greedy-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nclass Compare {\\npublic:\\n    bool operator()(const pair<int, int>& below, const pair<int, int>& above) const {\\n        if (below.first < above.first) {\\n            return true;\\n        }\\n        else if (below.first == above.first && below.second > above.second) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        for(int i=0;i<reward1.size();++i){\\n            pq.push({-reward2[i]+reward1[i],i});\\n        }\\n        int sum=0,deduct=0;\\n\\n        for(int i=0;i<k;++i){\\n             sum+=reward1[pq.top().second];\\n             deduct+=reward2[pq.top().second];\\n             pq.pop();\\n        }\\n\\n        for(auto i:reward2)sum+=i;\\n\\n        \\n        return sum-deduct;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nclass Compare {\\npublic:\\n    bool operator()(const pair<int, int>& below, const pair<int, int>& above) const {\\n        if (below.first < above.first) {\\n            return true;\\n        }\\n        else if (below.first == above.first && below.second > above.second) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        for(int i=0;i<reward1.size();++i){\\n            pq.push({-reward2[i]+reward1[i],i});\\n        }\\n        int sum=0,deduct=0;\\n\\n        for(int i=0;i<k;++i){\\n             sum+=reward1[pq.top().second];\\n             deduct+=reward2[pq.top().second];\\n             pq.pop();\\n        }\\n\\n        for(auto i:reward2)sum+=i;\\n\\n        \\n        return sum-deduct;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828724,
                "title": "beats-100-751ms-python",
                "content": "> <!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        n = len(reward1)\\n        initial = sum(reward2)\\n        diff = []\\n        for x,y in zip(reward1,reward2): diff.append(x-y)\\n        diff.sort()\\n        \\n        for i in range(k):\\n            initial += diff.pop()\\n        return initial\\n        \\n        \\n            \\n```\\n![lc_2611.png](https://assets.leetcode.com/users/images/3b91af2f-a86e-4164-ab34-9df4a469877c_1690547388.4137087.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        n = len(reward1)\\n        initial = sum(reward2)\\n        diff = []\\n        for x,y in zip(reward1,reward2): diff.append(x-y)\\n        diff.sort()\\n        \\n        for i in range(k):\\n            initial += diff.pop()\\n        return initial\\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827317,
                "title": "simplest-answer-100-fast-easy-solution-just-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        vector<pair<int,int>>p;\\n        \\n        for(int i=0;i<r1.size();i++){\\n            p.push_back({r1[i],r2[i]});\\n        }\\n        // this creates best order where mice1 takes the cheese\\n\\t\\t\\n        sort(p.begin(),p.end(),[&](pair<int,int>a,pair<int,int>b){\\n            return a.first-a.second>b.first-b.second;\\n        });\\n        \\n        int ans=0;\\n        for(int i=0;i<r1.size();i++){\\n            if(i<k){\\n\\t\\t\\t//for k times mice1 takes the cheese , then after k-times mice2 takes cheese\\n                ans+=p[i].first;\\n            }\\n            else ans+=p[i].second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n# pls upvote, till now no one has upvoted me",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        vector<pair<int,int>>p;\\n        \\n        for(int i=0;i<r1.size();i++){\\n            p.push_back({r1[i],r2[i]});\\n        }\\n        // this creates best order where mice1 takes the cheese\\n\\t\\t\\n        sort(p.begin(),p.end(),[&](pair<int,int>a,pair<int,int>b){\\n            return a.first-a.second>b.first-b.second;\\n        });\\n        \\n        int ans=0;\\n        for(int i=0;i<r1.size();i++){\\n            if(i<k){\\n\\t\\t\\t//for k times mice1 takes the cheese , then after k-times mice2 takes cheese\\n                ans+=p[i].first;\\n            }\\n            else ans+=p[i].second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816052,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int miceAndCheese(List<int> reward1, List<int> reward2, int k) {\\n      List<int> diff = [];\\n      int output = 0;\\n      for (int i = 0; i< reward1.length; i++){\\n          diff.add(reward1[i] - reward2[i]);\\n          output += reward2[i];\\n      }\\n      diff.sort((a,b) => b.compareTo(a));\\n      for (int j = 0; j < k; j++){\\n          output += diff[j];\\n      }\\n      return output;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int miceAndCheese(List<int> reward1, List<int> reward2, int k) {\\n      List<int> diff = [];\\n      int output = 0;\\n      for (int i = 0; i< reward1.length; i++){\\n          diff.add(reward1[i] - reward2[i]);\\n          output += reward2[i];\\n      }\\n      diff.sort((a,b) => b.compareTo(a));\\n      for (int j = 0; j < k; j++){\\n          output += diff[j];\\n      }\\n      return output;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809294,
                "title": "greedy",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nint miceAndCheese(vector<int>& x, vector<int>& y, int k) \\n{\\n\\tint out{};\\n\\tfor(int i{}; i<size(x); ++i)\\n\\t\\tout+=x[i]+y[i], x[i]-=y[i];\\n\\tnth_element(begin(x), begin(x)+k, end(x), greater{});\\n\\treturn (out+accumulate(begin(x), begin(x)+k, 0)-accumulate(begin(x)+k, end(x), 0))/2;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint miceAndCheese(vector<int>& x, vector<int>& y, int k) \\n{\\n\\tint out{};\\n\\tfor(int i{}; i<size(x); ++i)\\n\\t\\tout+=x[i]+y[i], x[i]-=y[i];\\n\\tnth_element(begin(x), begin(x)+k, end(x), greater{});\\n\\treturn (out+accumulate(begin(x), begin(x)+k, 0)-accumulate(begin(x)+k, end(x), 0))/2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765071,
                "title": "golang-simple-sorting-solution",
                "content": "# Code\\n```go\\nfunc miceAndCheese(reward1 []int, reward2 []int, k int) int {\\n    award := make([]int, 0, len(reward1))\\n    cheese := 0\\n    for i := range reward1 {\\n        award = append(award, reward1[i]-reward2[i])\\n        cheese += reward2[i]\\n    }\\n   \\n    sort.Sort(sort.Reverse(sort.IntSlice(award)))\\n    for i := 0; i < k; i++ {\\n        cheese += award[i]\\n    }\\n    return cheese\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc miceAndCheese(reward1 []int, reward2 []int, k int) int {\\n    award := make([]int, 0, len(reward1))\\n    cheese := 0\\n    for i := range reward1 {\\n        award = append(award, reward1[i]-reward2[i])\\n        cheese += reward2[i]\\n    }\\n   \\n    sort.Sort(sort.Reverse(sort.IntSlice(award)))\\n    for i := 0; i < k; i++ {\\n        cheese += award[i]\\n    }\\n    return cheese\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764318,
                "title": "must-see-solution-priority-queue-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<vector<int>> pq;\\n        int n=reward1.size();\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            pq.push({reward1[i]-reward2[i],reward1[i],reward2[i]});\\n        }\\n        while(!pq.empty() && k>0){\\n            ans+=pq.top()[1];\\n            pq.pop();\\n            k--;\\n        }\\n        while(!pq.empty()){\\n            ans+=pq.top()[2];\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<vector<int>> pq;\\n        int n=reward1.size();\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            pq.push({reward1[i]-reward2[i],reward1[i],reward2[i]});\\n        }\\n        while(!pq.empty() && k>0){\\n            ans+=pq.top()[1];\\n            pq.pop();\\n            k--;\\n        }\\n        while(!pq.empty()){\\n            ans+=pq.top()[2];\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741201,
                "title": "most-intuitive-no-sorting-explained-in-comments",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int ans = 0, n = reward1.size();\\n        unordered_map<int,bool> m;\\n        for(int i=0; i<n; i++)\\n        {\\n            pq.push({reward1[i]-reward2[i],i}); //maximize diff. using a pq\\n        }\\n\\n        while(k--)\\n        {\\n            int index = pq.top().second;\\n            pq.pop();\\n            ans += reward1[index]; //take \\'k\\' no. of max cheese from reward1\\n            m[index] = true; //Mouse1 visits this index so that Mouse2 does not eat cheese from this index\\n        }\\n\\n        for(int i=0; i<n; i++)\\n         {  //Mouse2 eats cheese from all the non-visited indices of reward2\\n             ans += !m[i] ? reward2[i] : 0;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int ans = 0, n = reward1.size();\\n        unordered_map<int,bool> m;\\n        for(int i=0; i<n; i++)\\n        {\\n            pq.push({reward1[i]-reward2[i],i}); //maximize diff. using a pq\\n        }\\n\\n        while(k--)\\n        {\\n            int index = pq.top().second;\\n            pq.pop();\\n            ans += reward1[index]; //take \\'k\\' no. of max cheese from reward1\\n            m[index] = true; //Mouse1 visits this index so that Mouse2 does not eat cheese from this index\\n        }\\n\\n        for(int i=0; i<n; i++)\\n         {  //Mouse2 eats cheese from all the non-visited indices of reward2\\n             ans += !m[i] ? reward2[i] : 0;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732628,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) \\n    {\\n        int n,ans;\\n        n=reward1.size();\\n        ans=0;\\n\\n        vector<pair<int,int>> v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({reward1[i]-reward2[i],i});\\n        }    \\n\\n        sort(v.rbegin(),v.rend());\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            ans+=reward1[v[i].second];\\n        }\\n\\n        for(int i=k;i<n;i++)\\n        {\\n            ans+=reward2[v[i].second];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) \\n    {\\n        int n,ans;\\n        n=reward1.size();\\n        ans=0;\\n\\n        vector<pair<int,int>> v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({reward1[i]-reward2[i],i});\\n        }    \\n\\n        sort(v.rbegin(),v.rend());\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            ans+=reward1[v[i].second];\\n        }\\n\\n        for(int i=k;i<n;i++)\\n        {\\n            ans+=reward2[v[i].second];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731556,
                "title": "most-unique-approach-own-intuitive-solution",
                "content": "\\n```\\nclass Solution\\n{\\n    public:\\n        int miceAndCheese(vector<int> &reward1, vector<int> &reward2, int k)\\n        {\\n            int n = reward1.size();\\n            priority_queue<pair<int, int>> pq;\\n            for (int i = 0; i < n; i++)\\n            {\\n                pq.push({ reward1[i] - reward2[i],\\n                    reward2[i] });\\n            }\\n            int sum = 0;\\n            while (k--)\\n            {\\n                int a = pq.top().first;\\n                int b = pq.top().second;\\n                sum += a;\\n                sum += b;\\n                pq.pop();\\n            }\\n            while (!pq.empty())\\n            {\\n                int b = pq.top().second;\\n                sum += b;\\n                pq.pop();\\n            }\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int miceAndCheese(vector<int> &reward1, vector<int> &reward2, int k)\\n        {\\n            int n = reward1.size();\\n            priority_queue<pair<int, int>> pq;\\n            for (int i = 0; i < n; i++)\\n            {\\n                pq.push({ reward1[i] - reward2[i],\\n                    reward2[i] });\\n            }\\n            int sum = 0;\\n            while (k--)\\n            {\\n                int a = pq.top().first;\\n                int b = pq.top().second;\\n                sum += a;\\n                sum += b;\\n                pq.pop();\\n            }\\n            while (!pq.empty())\\n            {\\n                int b = pq.top().second;\\n                sum += b;\\n                pq.pop();\\n            }\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727924,
                "title": "easy-sorting",
                "content": "# Approach\\nSorting\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n        int sum=0 , n=reward1.size();\\n        for(int r:reward2)\\n            sum+=r;\\n        for(int i=0;i<n;i++)\\n            reward1[i]-=reward2[i];\\n        sort(reward1.rbegin(),reward1.rend());\\n        for(int i=0;i<k &&i <n;i++)\\n            sum+=reward1[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n        int sum=0 , n=reward1.size();\\n        for(int r:reward2)\\n            sum+=r;\\n        for(int i=0;i<n;i++)\\n            reward1[i]-=reward2[i];\\n        sort(reward1.rbegin(),reward1.rend());\\n        for(int i=0;i<k &&i <n;i++)\\n            sum+=reward1[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725227,
                "title": "c-min-heap",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n + klogn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        int n = reward1.size(), sum = 0;\\n        for (auto &num : reward2)\\n            sum += num;\\n        for (int i = 0; i < n; i++) {\\n            pq.push(reward1[i] - reward2[i]);\\n            sum += reward1[i] - reward2[i];\\n            if (pq.size() > k) {\\n                sum -= pq.top();\\n                pq.pop();\\n            } \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        int n = reward1.size(), sum = 0;\\n        for (auto &num : reward2)\\n            sum += num;\\n        for (int i = 0; i < n; i++) {\\n            pq.push(reward1[i] - reward2[i]);\\n            sum += reward1[i] - reward2[i];\\n            if (pq.size() > k) {\\n                sum -= pq.top();\\n                pq.pop();\\n            } \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716887,
                "title": "easy-approach-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n    // we need to find the maximum points when the both mice finished n type of cheese.\\n    // But the mice1 can only eat k types of cheese.\\n    // Therfore remaining cheese will be eaten by mice2.\\n    // First find the total reward for mice2, then add the maximum k reward from reward1 in that sum and subtract the\\n    // corresponding reward of maximum k from reward2\\n    //  or we can sort reward1-reward2 and add k times maximum from that difference;\\n\\n        int ans=0;\\n        for(auto it:reward2) ans+=it;\\n        for(int i=0;i<reward1.size();i++)  reward2[i]=reward1[i]-reward2[i];\\n        sort(reward2.begin(),reward2.end());\\n        int i=reward2.size()-1;\\n        while(k--)\\n        {\\n            ans+=reward2[i];\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n    // we need to find the maximum points when the both mice finished n type of cheese.\\n    // But the mice1 can only eat k types of cheese.\\n    // Therfore remaining cheese will be eaten by mice2.\\n    // First find the total reward for mice2, then add the maximum k reward from reward1 in that sum and subtract the\\n    // corresponding reward of maximum k from reward2\\n    //  or we can sort reward1-reward2 and add k times maximum from that difference;\\n\\n        int ans=0;\\n        for(auto it:reward2) ans+=it;\\n        for(int i=0;i<reward1.size();i++)  reward2[i]=reward1[i]-reward2[i];\\n        sort(reward2.begin(),reward2.end());\\n        int i=reward2.size()-1;\\n        while(k--)\\n        {\\n            ans+=reward2[i];\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691431,
                "title": "sort-is-faster-than-heap",
                "content": "# Intuition\\nHere I have 2 approaches, sort, heap\\n1. sort the difference between the rewards \\n2. get the sum of top k diffs\\n3. add sum of reward2\\n\\nI thought it would be faster if we use a heap instead of sorting. However, when I submited the solutions Leetcode indicated sort is faster (beats 81%) than heap(beats 60%).\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        diff, r = [], 0\\n        for i in range(len(reward1)):\\n            diff.append(reward1[i] - reward2[i])\\n        diff.sort(reverse=True)\\n        for i in range(k):\\n            r += diff[i]\\n        r += sum(reward2)\\n        return r\\n\\nUsing heap:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        diff, r = [], 0\\n        for i in range(len(reward1)):\\n            heapq.heappush(diff, reward2[i] - reward1[i])\\n        for i in range(k):\\n            r += -heapq.heappop(diff)\\n        r += sum(reward2)\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        diff, r = [], 0\\n        for i in range(len(reward1)):\\n            diff.append(reward1[i] - reward2[i])\\n        diff.sort(reverse=True)\\n        for i in range(k):\\n            r += diff[i]\\n        r += sum(reward2)\\n        return r\\n\\nUsing heap:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        diff, r = [], 0\\n        for i in range(len(reward1)):\\n            heapq.heappush(diff, reward2[i] - reward1[i])\\n        for i in range(k):\\n            r += -heapq.heappop(diff)\\n        r += sum(reward2)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685600,
                "title": "simple-solution-using-heap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n       priority_queue<pair<int,int>>pq1;\\n       \\n       \\n       for(int i=0;i<reward1.size();i++){\\n           pq1.push({(reward1[i]-reward2[i]),i});\\n       }\\n       int ans=0;\\n       while(k--){\\n           auto it =pq1.top();\\n           pq1.pop();\\n           ans+=reward1[it.second];\\n       }\\n       while(!pq1.empty()){\\n           auto it=pq1.top();\\n           pq1.pop();\\n           ans+=reward2[it.second];\\n       }\\n       \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n       priority_queue<pair<int,int>>pq1;\\n       \\n       \\n       for(int i=0;i<reward1.size();i++){\\n           pq1.push({(reward1[i]-reward2[i]),i});\\n       }\\n       int ans=0;\\n       while(k--){\\n           auto it =pq1.top();\\n           pq1.pop();\\n           ans+=reward1[it.second];\\n       }\\n       while(!pq1.empty()){\\n           auto it=pq1.top();\\n           pq1.pop();\\n           ans+=reward2[it.second];\\n       }\\n       \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673686,
                "title": "c-simple-approach-explained-with-comments-by-solving-test-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n=reward1.size();\\n        vector<pair<int,int>>diff(n);\\n\\n        for(int i=0;i<n;++i){\\n            diff[i]={reward1[i]-reward2[i],i};   // diff[]=({-3,0},{-3,1},{2,2},{3,3})\\n        }\\n        sort(diff.rbegin(),diff.rend());     // diff[]=({3,3},{2,2},{-3,1},{-3,0})\\n        \\n        int sum=0;\\n        for(int i=0;i<k;++i){\\n         sum += reward1[diff[i].second]; //sum = 0 + r1[diff[0].second] = 0+r1[3]=0+4=4\\n                                        // sum = 4+r1[diff[1].second]=4+r1[2] =4+3=7\\n\\n          reward2[diff[i].second]=0; // r2[diff[0].second]=0 => r2[3] = 0 \\n                                    // r2[diff[1].second]=0 => r2[2] =0\\n        }\\n          \\n        //reward2 = [4,4,0,0]\\n        //           0 1 2 3\\n        for(int i=0;i<reward2.size();++i){\\n            sum += reward2[i];    //sum = 7 + reward2[0] = 7 + 4 =11 \\\\\\n                                  // sum = 11+4=15 \\n                                  //sum = 15+0=15\\n                                  //sum= 15+0=15\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n=reward1.size();\\n        vector<pair<int,int>>diff(n);\\n\\n        for(int i=0;i<n;++i){\\n            diff[i]={reward1[i]-reward2[i],i};   // diff[]=({-3,0},{-3,1},{2,2},{3,3})\\n        }\\n        sort(diff.rbegin(),diff.rend());     // diff[]=({3,3},{2,2},{-3,1},{-3,0})\\n        \\n        int sum=0;\\n        for(int i=0;i<k;++i){\\n         sum += reward1[diff[i].second]; //sum = 0 + r1[diff[0].second] = 0+r1[3]=0+4=4\\n                                        // sum = 4+r1[diff[1].second]=4+r1[2] =4+3=7\\n\\n          reward2[diff[i].second]=0; // r2[diff[0].second]=0 => r2[3] = 0 \\n                                    // r2[diff[1].second]=0 => r2[2] =0\\n        }\\n          \\n        //reward2 = [4,4,0,0]\\n        //           0 1 2 3\\n        for(int i=0;i<reward2.size();++i){\\n            sum += reward2[i];    //sum = 7 + reward2[0] = 7 + 4 =11 \\\\\\n                                  // sum = 11+4=15 \\n                                  //sum = 15+0=15\\n                                  //sum= 15+0=15\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666632,
                "title": "beats-99-explained-easy-to-understand",
                "content": "# Approach\\nObservation: since ques says mice1 has to eat only K cheese, but there is no boundation for mice2\\nSo, approach is at first let all rewards be added for mice2, later we\\'ll add the rewards for mice1 (where its max for k cheese for mice1 & subtract the same from mice2 rewards).\\nI\\'ll do that by maintaining a difference between reward1$$i$$ - reward2$$i$$\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$, since we are sorting\\n\\n- Space complexity: $$O(n)$$, taking extra array for storing diffReward\\n\\n# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int[] diffReward = new int[n];\\n\\n        int maxReward = 0;\\n        for(int i=0; i<n; i++) {\\n            diffReward[i] = reward1[i] - reward2[i];\\n            maxReward += reward2[i];      // intially addin all cheese reward for mice2\\n        }\\n\\n        Arrays.sort(diffReward);\\n\\n        for(int i=0; i<k; i++) {\\n            // picking elements from last index, since its in ascending order\\n            maxReward += diffReward[n-i-1];  \\n        }\\n\\n        return maxReward;\\n    }\\n}\\n```\\n\\n### If you liked the solution, please leave a upvote !!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int[] diffReward = new int[n];\\n\\n        int maxReward = 0;\\n        for(int i=0; i<n; i++) {\\n            diffReward[i] = reward1[i] - reward2[i];\\n            maxReward += reward2[i];      // intially addin all cheese reward for mice2\\n        }\\n\\n        Arrays.sort(diffReward);\\n\\n        for(int i=0; i<k; i++) {\\n            // picking elements from last index, since its in ascending order\\n            maxReward += diffReward[n-i-1];  \\n        }\\n\\n        return maxReward;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640117,
                "title": "simple-python-solution-using-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe differences between the rewards helps us pick the k largest from reward1 and n-k from reward2\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a dictionary which has the indices as key and values as the differences for reward1 - reward2. Sort the dictionary based on the rewards and then iterate reward1 adding all values with the maximum differences at the stored indices in the sorted array. Similary add all values from reward2 after k types of cheese have been consumed by mouse 1.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        if k==0:\\n            return sum(reward2)\\n        diff_dict = {}\\n        for i in range(len(reward1)):\\n            diff_dict[i] = reward1[i] - reward2[i]\\n        \\n        sorted_dict = sorted(diff_dict.items(), key=lambda x:x[1], reverse = True)\\n        res = 0\\n        for i in range(k):\\n            res+= reward1[sorted_dict[i][0]]\\n        for i in range(k,len(reward2)):\\n            res+=reward2[sorted_dict[i][0]]\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        if k==0:\\n            return sum(reward2)\\n        diff_dict = {}\\n        for i in range(len(reward1)):\\n            diff_dict[i] = reward1[i] - reward2[i]\\n        \\n        sorted_dict = sorted(diff_dict.items(), key=lambda x:x[1], reverse = True)\\n        res = 0\\n        for i in range(k):\\n            res+= reward1[sorted_dict[i][0]]\\n        for i in range(k,len(reward2)):\\n            res+=reward2[sorted_dict[i][0]]\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633951,
                "title": "java-easy-solution-using-greedy-approach-sc-o-1-tc-o-n",
                "content": "**Please Upvote!!**\\n\\n# Approach\\nCalculate and store the difference between reward1 and reward two array. Now imagine that the second mouse eats all the cheese and caluculated sum of reward two.\\nSort the diff array and, then we should choose k types of cheese from diff array and calculate sum += k maximum element from diff array.\\n\\nReturn Sum.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        \\n        int n = reward1.length;\\n        int diff[] = new int[reward1.length];\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            diff[i] = reward1[i]-reward2[i];\\n            sum += reward2[i];\\n        }\\n        Arrays.sort(diff);\\n        int i =0;\\n        while(k>0){\\n           sum += diff[n-1-i];\\n           k--;\\n           i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        \\n        int n = reward1.length;\\n        int diff[] = new int[reward1.length];\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            diff[i] = reward1[i]-reward2[i];\\n            sum += reward2[i];\\n        }\\n        Arrays.sort(diff);\\n        int i =0;\\n        while(k>0){\\n           sum += diff[n-1-i];\\n           k--;\\n           i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630963,
                "title": "java-well-explained-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to pick k index in reward1, so take two array\\'s and find out the difference we need to maxmize the result so pick index which have greater difference in reward1\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n\\n        //difference array\\n        int[] diff = new int[n];\\n        for(int i = 0; i<n; i++){\\n            diff[i] = reward1[i] - reward2[i];\\n        }\\n\\n        //Help to sort in descending order with index as value\\n        TreeMap<Integer, ArrayList<Integer>> map = new TreeMap<>(Collections.reverseOrder());\\n\\n        for(int i = 0; i<n; i++){\\n            if(!map.containsKey(diff[i]))\\n            map.put(diff[i], new ArrayList<Integer>());\\n            map.get(diff[i]).add(i);\\n        }\\n\\n        //process exactly k index\\n        int sum = 0;\\n        int count = 0;\\n        for(Map.Entry<Integer, ArrayList<Integer>> m : map.entrySet()){\\n            for(int i : m.getValue()){\\n                if(count == k) break;\\n                sum += reward1[i];\\n                reward2[i] = 0;\\n                \\n                count++;\\n            }\\n        }\\n\\n        //process reward2\\n        for(int i : reward2) sum += i;\\n\\n        //this is the final sum having max reward\\n        return sum;\\n\\n        \\n    }\\n}\\n\\nPLS UPVOTE\\u2B06\\uFE0F IF YOU GOT SOME IDEA IN THIS EXPLANATION\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n\\n        //difference array\\n        int[] diff = new int[n];\\n        for(int i = 0; i<n; i++){\\n            diff[i] = reward1[i] - reward2[i];\\n        }\\n\\n        //Help to sort in descending order with index as value\\n        TreeMap<Integer, ArrayList<Integer>> map = new TreeMap<>(Collections.reverseOrder());\\n\\n        for(int i = 0; i<n; i++){\\n            if(!map.containsKey(diff[i]))\\n            map.put(diff[i], new ArrayList<Integer>());\\n            map.get(diff[i]).add(i);\\n        }\\n\\n        //process exactly k index\\n        int sum = 0;\\n        int count = 0;\\n        for(Map.Entry<Integer, ArrayList<Integer>> m : map.entrySet()){\\n            for(int i : m.getValue()){\\n                if(count == k) break;\\n                sum += reward1[i];\\n                reward2[i] = 0;\\n                \\n                count++;\\n            }\\n        }\\n\\n        //process reward2\\n        for(int i : reward2) sum += i;\\n\\n        //this is the final sum having max reward\\n        return sum;\\n\\n        \\n    }\\n}\\n\\nPLS UPVOTE\\u2B06\\uFE0F IF YOU GOT SOME IDEA IN THIS EXPLANATION\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620567,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<reward1.size();i++){\\n            pq.push({reward1[i]-reward2[i],i});\\n        }\\n        vector<bool>v(reward1.size(),false);\\n        int ans = 0;\\n        while(k!=0){\\n            ans+=reward1[pq.top().second];\\n            v[pq.top().second]=true;\\n            pq.pop();\\n            k--;\\n        }\\n        for(int i=0;i<reward2.size();i++){\\n            if(v[i]==false){\\n                ans+=reward2[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<reward1.size();i++){\\n            pq.push({reward1[i]-reward2[i],i});\\n        }\\n        vector<bool>v(reward1.size(),false);\\n        int ans = 0;\\n        while(k!=0){\\n            ans+=reward1[pq.top().second];\\n            v[pq.top().second]=true;\\n            pq.pop();\\n            k--;\\n        }\\n        for(int i=0;i<reward2.size();i++){\\n            if(v[i]==false){\\n                ans+=reward2[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613424,
                "title": "sorting-greedy",
                "content": "# Intuition\\n Greedy =  for maximum points mouse1 should first pick cheese\\n with max reward from r1 realtive to r2 at same i. \\n\\n# Approach\\nmouse 1 pick reward from r1 at i which has max diff (r1[i]-r2[i]) , \\nthen remaining n-k cheese will be picked by mouse2.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n       \\n       \\n       //diff vector : \\n     vector<pair<int,int>> diff;\\n    \\n    int n = r1.size();\\n    \\n    for(int i = 0;i<n;i++){\\n        diff.emplace_back(r1[i] - r2[i], i);\\n    }\\n    \\n    //sort in max-->min : \\n    sort(diff.begin(),diff.end(), greater<pair<int,int>>());\\n\\n    int maxP = 0;\\n// //for mouse 1 : \\n//   for( int i =0 ; i<k ;i++) maxP = maxP + r1[diff[i].second];\\n// //for mouse 2 : \\n// for( int i =k ; i<n ;i++) maxP = maxP + r2[diff[i].second];\\n\\n// or after merging above 2 for loop : \\n\\nfor( int i =0 ; i<n ;i++) \\n{\\n    if(i<k)\\n        maxP = maxP + r1[diff[i].second];\\n    else\\n        maxP = maxP + r2[diff[i].second];\\n\\n}\\n\\nreturn maxP;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n       \\n       \\n       //diff vector : \\n     vector<pair<int,int>> diff;\\n    \\n    int n = r1.size();\\n    \\n    for(int i = 0;i<n;i++){\\n        diff.emplace_back(r1[i] - r2[i], i);\\n    }\\n    \\n    //sort in max-->min : \\n    sort(diff.begin(),diff.end(), greater<pair<int,int>>());\\n\\n    int maxP = 0;\\n// //for mouse 1 : \\n//   for( int i =0 ; i<k ;i++) maxP = maxP + r1[diff[i].second];\\n// //for mouse 2 : \\n// for( int i =k ; i<n ;i++) maxP = maxP + r2[diff[i].second];\\n\\n// or after merging above 2 for loop : \\n\\nfor( int i =0 ; i<n ;i++) \\n{\\n    if(i<k)\\n        maxP = maxP + r1[diff[i].second];\\n    else\\n        maxP = maxP + r2[diff[i].second];\\n\\n}\\n\\nreturn maxP;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608893,
                "title": "java-javascript-c-c-solution",
                "content": "**Java, Heap**\\n```\\nimport java.util.PriorityQueue;\\n\\npublic class Solution {\\n\\n    public int miceAndCheese(int[] firstReward, int[] seondReward, int numberOfTypesOfCheeseForFirstMouse) {\\n\\n        int maximumPoints = 0;\\n        final int totalTypesOfCheese = firstReward.length;\\n        PriorityQueue<Integer> minHeapDifferenceInRewards = new PriorityQueue<>();\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i) {\\n            maximumPoints += firstReward[i];\\n            minHeapDifferenceInRewards.add(firstReward[i] - seondReward[i]);\\n            if (minHeapDifferenceInRewards.size() > numberOfTypesOfCheeseForFirstMouse) {\\n                maximumPoints -= minHeapDifferenceInRewards.poll();\\n            }\\n        }\\n\\n        return maximumPoints;\\n    }\\n}\\n```\\n**Java, Sorting**\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    public int miceAndCheese(int[] firstReward, int[] seondReward, int numberOfTypesOfCheeseForFirstMouse) {\\n\\n        int maximumPoints = 0;\\n        final int totalTypesOfCheese = firstReward.length;\\n        int[] differenceInRewards = new int[totalTypesOfCheese];\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i) {\\n            differenceInRewards[i] = firstReward[i] - seondReward[i];\\n            maximumPoints += seondReward[i];\\n        }\\n        Arrays.sort(differenceInRewards);\\n\\n        for (int i = totalTypesOfCheese - 1; i > totalTypesOfCheese - numberOfTypesOfCheeseForFirstMouse - 1; --i) {\\n            maximumPoints += differenceInRewards[i];\\n        }\\n\\n        return maximumPoints;\\n    }\\n}\\n```\\n**JavaScript, Heap**\\n```\\n/**\\n * @param {number[]} firstReward\\n * @param {number[]} seondReward\\n * @param {number} numberOfTypesOfCheeseForFirstMouse\\n * @return {number}\\n */\\nvar miceAndCheese = function (firstReward, seondReward, numberOfTypesOfCheeseForFirstMouse) {\\n\\n    let maximumPoints = 0;\\n    const totalTypesOfCheese = firstReward.length;\\n    //const {MinPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n    //MinPriorityQueue<number>\\n    const minHeapDifferenceInRewards = new MinPriorityQueue({compare: (x, y) => x - y});\\n\\n    for (let i = 0; i < totalTypesOfCheese; ++i) {\\n        maximumPoints += firstReward[i];\\n        minHeapDifferenceInRewards.enqueue(firstReward[i] - seondReward[i]);\\n        if (minHeapDifferenceInRewards.size() > numberOfTypesOfCheeseForFirstMouse) {\\n            maximumPoints -= minHeapDifferenceInRewards.dequeue();\\n        }\\n    }\\n\\n    return maximumPoints;\\n};\\n```\\n**JavaScript, Sorting**\\n```\\n/**\\n * @param {number[]} firstReward\\n * @param {number[]} seondReward\\n * @param {number} numberOfTypesOfCheeseForFirstMouse\\n * @return {number}\\n */\\nvar miceAndCheese = function (firstReward, seondReward, numberOfTypesOfCheeseForFirstMouse) {\\n\\n    let maximumPoints = 0;\\n    const totalTypesOfCheese = firstReward.length;\\n    const differenceInRewards = new Array(totalTypesOfCheese);\\n\\n    for (let i = 0; i < totalTypesOfCheese; ++i) {\\n        differenceInRewards[i] = firstReward[i] - seondReward[i];\\n        maximumPoints += seondReward[i];\\n    }\\n    differenceInRewards.sort((x, y) => x - y);\\n\\n    for (let i = totalTypesOfCheese - 1; i > totalTypesOfCheese - numberOfTypesOfCheeseForFirstMouse - 1; --i) {\\n        maximumPoints += differenceInRewards[i];\\n    }\\n\\n    return maximumPoints;\\n};\\n```\\n**C++, Heap**\\n```\\n#include <queue>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    int miceAndCheese(const vector<int>& firstReward, const vector<int>& seondReward, int numberOfTypesOfCheeseForFirstMouse) const {\\n\\n        int maximumPoints = 0;\\n        const int totalTypesOfCheese = firstReward.size();\\n        \\n        //It is recommended to always use transparent operators (greater<> instead of greater<typename>, etc) \\n        //by Standard Library Containers that accept a comparator type. \\n        //It certain cases, performance could be better than with non-transparent comparators.\\n        priority_queue<int, vector<int>, greater<>> minHeapDifferenceInRewards;\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i) {\\n            maximumPoints += firstReward[i];\\n            minHeapDifferenceInRewards.push(firstReward[i] - seondReward[i]);\\n            if (minHeapDifferenceInRewards.size() > numberOfTypesOfCheeseForFirstMouse) {\\n                maximumPoints -= minHeapDifferenceInRewards.top();\\n                minHeapDifferenceInRewards.pop();\\n            }\\n        }\\n\\n        return maximumPoints;\\n    }\\n};\\n```\\n**C++, Sorting**\\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    int miceAndCheese(const vector<int>& firstReward, const vector<int>& seondReward, int numberOfTypesOfCheeseForFirstMouse) const {\\n       \\n        int maximumPoints = 0;\\n        const int totalTypesOfCheese = firstReward.size();\\n        vector<int> differenceInRewards(totalTypesOfCheese);\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i) {\\n            differenceInRewards[i] = firstReward[i] - seondReward[i];\\n            maximumPoints += seondReward[i];\\n        }\\n        //C++20: std::ranges::sort(differenceInRewards);\\n        sort(differenceInRewards.begin(), differenceInRewards.end());\\n\\n        for (int i = totalTypesOfCheese - 1; i > totalTypesOfCheese - numberOfTypesOfCheeseForFirstMouse - 1; --i) {\\n            maximumPoints += differenceInRewards[i];\\n        }\\n\\n        return maximumPoints;\\n    }\\n};\\n```\\n**C#, Heap**\\n```\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution\\n{\\n    public int MiceAndCheese(int[] firstReward, int[] seondReward, int numberOfTypesOfCheeseForFirstMouse)\\n    {\\n        int maximumPoints = 0;\\n        int totalTypesOfCheese = firstReward.Length;\\n        PriorityQueue<int, int> minHeapDifferenceInRewards = new PriorityQueue<int, int>();\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i)\\n        {\\n            maximumPoints += firstReward[i];\\n            minHeapDifferenceInRewards.Enqueue(firstReward[i] - seondReward[i], firstReward[i] - seondReward[i]);\\n            if (minHeapDifferenceInRewards.Count > numberOfTypesOfCheeseForFirstMouse)\\n            {\\n                maximumPoints -= minHeapDifferenceInRewards.Dequeue();\\n            }\\n        }\\n\\n        return maximumPoints;\\n    }\\n}\\n```\\n**C#, Sorting**\\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    public int MiceAndCheese(int[] firstReward, int[] seondReward, int numberOfTypesOfCheeseForFirstMouse)\\n    {\\n        int maximumPoints = 0;\\n        int totalTypesOfCheese = firstReward.Length;\\n        int[] differenceInRewards = new int[totalTypesOfCheese];\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i)\\n        {\\n            differenceInRewards[i] = firstReward[i] - seondReward[i];\\n            maximumPoints += seondReward[i];\\n        }\\n        Array.Sort(differenceInRewards);\\n\\n        for (int i = totalTypesOfCheese - 1; i > totalTypesOfCheese - numberOfTypesOfCheeseForFirstMouse - 1; --i)\\n        {\\n            maximumPoints += differenceInRewards[i];\\n        }\\n\\n        return maximumPoints;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.PriorityQueue;\\n\\npublic class Solution {\\n\\n    public int miceAndCheese(int[] firstReward, int[] seondReward, int numberOfTypesOfCheeseForFirstMouse) {\\n\\n        int maximumPoints = 0;\\n        final int totalTypesOfCheese = firstReward.length;\\n        PriorityQueue<Integer> minHeapDifferenceInRewards = new PriorityQueue<>();\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i) {\\n            maximumPoints += firstReward[i];\\n            minHeapDifferenceInRewards.add(firstReward[i] - seondReward[i]);\\n            if (minHeapDifferenceInRewards.size() > numberOfTypesOfCheeseForFirstMouse) {\\n                maximumPoints -= minHeapDifferenceInRewards.poll();\\n            }\\n        }\\n\\n        return maximumPoints;\\n    }\\n}\\n```\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    public int miceAndCheese(int[] firstReward, int[] seondReward, int numberOfTypesOfCheeseForFirstMouse) {\\n\\n        int maximumPoints = 0;\\n        final int totalTypesOfCheese = firstReward.length;\\n        int[] differenceInRewards = new int[totalTypesOfCheese];\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i) {\\n            differenceInRewards[i] = firstReward[i] - seondReward[i];\\n            maximumPoints += seondReward[i];\\n        }\\n        Arrays.sort(differenceInRewards);\\n\\n        for (int i = totalTypesOfCheese - 1; i > totalTypesOfCheese - numberOfTypesOfCheeseForFirstMouse - 1; --i) {\\n            maximumPoints += differenceInRewards[i];\\n        }\\n\\n        return maximumPoints;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} firstReward\\n * @param {number[]} seondReward\\n * @param {number} numberOfTypesOfCheeseForFirstMouse\\n * @return {number}\\n */\\nvar miceAndCheese = function (firstReward, seondReward, numberOfTypesOfCheeseForFirstMouse) {\\n\\n    let maximumPoints = 0;\\n    const totalTypesOfCheese = firstReward.length;\\n    //const {MinPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n    //MinPriorityQueue<number>\\n    const minHeapDifferenceInRewards = new MinPriorityQueue({compare: (x, y) => x - y});\\n\\n    for (let i = 0; i < totalTypesOfCheese; ++i) {\\n        maximumPoints += firstReward[i];\\n        minHeapDifferenceInRewards.enqueue(firstReward[i] - seondReward[i]);\\n        if (minHeapDifferenceInRewards.size() > numberOfTypesOfCheeseForFirstMouse) {\\n            maximumPoints -= minHeapDifferenceInRewards.dequeue();\\n        }\\n    }\\n\\n    return maximumPoints;\\n};\\n```\n```\\n/**\\n * @param {number[]} firstReward\\n * @param {number[]} seondReward\\n * @param {number} numberOfTypesOfCheeseForFirstMouse\\n * @return {number}\\n */\\nvar miceAndCheese = function (firstReward, seondReward, numberOfTypesOfCheeseForFirstMouse) {\\n\\n    let maximumPoints = 0;\\n    const totalTypesOfCheese = firstReward.length;\\n    const differenceInRewards = new Array(totalTypesOfCheese);\\n\\n    for (let i = 0; i < totalTypesOfCheese; ++i) {\\n        differenceInRewards[i] = firstReward[i] - seondReward[i];\\n        maximumPoints += seondReward[i];\\n    }\\n    differenceInRewards.sort((x, y) => x - y);\\n\\n    for (let i = totalTypesOfCheese - 1; i > totalTypesOfCheese - numberOfTypesOfCheeseForFirstMouse - 1; --i) {\\n        maximumPoints += differenceInRewards[i];\\n    }\\n\\n    return maximumPoints;\\n};\\n```\n```\\n#include <queue>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    int miceAndCheese(const vector<int>& firstReward, const vector<int>& seondReward, int numberOfTypesOfCheeseForFirstMouse) const {\\n\\n        int maximumPoints = 0;\\n        const int totalTypesOfCheese = firstReward.size();\\n        \\n        //It is recommended to always use transparent operators (greater<> instead of greater<typename>, etc) \\n        //by Standard Library Containers that accept a comparator type. \\n        //It certain cases, performance could be better than with non-transparent comparators.\\n        priority_queue<int, vector<int>, greater<>> minHeapDifferenceInRewards;\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i) {\\n            maximumPoints += firstReward[i];\\n            minHeapDifferenceInRewards.push(firstReward[i] - seondReward[i]);\\n            if (minHeapDifferenceInRewards.size() > numberOfTypesOfCheeseForFirstMouse) {\\n                maximumPoints -= minHeapDifferenceInRewards.top();\\n                minHeapDifferenceInRewards.pop();\\n            }\\n        }\\n\\n        return maximumPoints;\\n    }\\n};\\n```\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    int miceAndCheese(const vector<int>& firstReward, const vector<int>& seondReward, int numberOfTypesOfCheeseForFirstMouse) const {\\n       \\n        int maximumPoints = 0;\\n        const int totalTypesOfCheese = firstReward.size();\\n        vector<int> differenceInRewards(totalTypesOfCheese);\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i) {\\n            differenceInRewards[i] = firstReward[i] - seondReward[i];\\n            maximumPoints += seondReward[i];\\n        }\\n        //C++20: std::ranges::sort(differenceInRewards);\\n        sort(differenceInRewards.begin(), differenceInRewards.end());\\n\\n        for (int i = totalTypesOfCheese - 1; i > totalTypesOfCheese - numberOfTypesOfCheeseForFirstMouse - 1; --i) {\\n            maximumPoints += differenceInRewards[i];\\n        }\\n\\n        return maximumPoints;\\n    }\\n};\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution\\n{\\n    public int MiceAndCheese(int[] firstReward, int[] seondReward, int numberOfTypesOfCheeseForFirstMouse)\\n    {\\n        int maximumPoints = 0;\\n        int totalTypesOfCheese = firstReward.Length;\\n        PriorityQueue<int, int> minHeapDifferenceInRewards = new PriorityQueue<int, int>();\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i)\\n        {\\n            maximumPoints += firstReward[i];\\n            minHeapDifferenceInRewards.Enqueue(firstReward[i] - seondReward[i], firstReward[i] - seondReward[i]);\\n            if (minHeapDifferenceInRewards.Count > numberOfTypesOfCheeseForFirstMouse)\\n            {\\n                maximumPoints -= minHeapDifferenceInRewards.Dequeue();\\n            }\\n        }\\n\\n        return maximumPoints;\\n    }\\n}\\n```\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    public int MiceAndCheese(int[] firstReward, int[] seondReward, int numberOfTypesOfCheeseForFirstMouse)\\n    {\\n        int maximumPoints = 0;\\n        int totalTypesOfCheese = firstReward.Length;\\n        int[] differenceInRewards = new int[totalTypesOfCheese];\\n\\n        for (int i = 0; i < totalTypesOfCheese; ++i)\\n        {\\n            differenceInRewards[i] = firstReward[i] - seondReward[i];\\n            maximumPoints += seondReward[i];\\n        }\\n        Array.Sort(differenceInRewards);\\n\\n        for (int i = totalTypesOfCheese - 1; i > totalTypesOfCheese - numberOfTypesOfCheeseForFirstMouse - 1; --i)\\n        {\\n            maximumPoints += differenceInRewards[i];\\n        }\\n\\n        return maximumPoints;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3594691,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        total = 0\\n        heap = []\\n\\n        for x,y in zip(reward1,reward2):\\n            heapq.heappush(heap, (-(x-y), x, y))\\n        \\n        for _ in range(k):\\n            total += heapq.heappop(heap)[1]\\n        \\n        while heap:\\n            total += heapq.heappop(heap)[2]\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        total = 0\\n        heap = []\\n\\n        for x,y in zip(reward1,reward2):\\n            heapq.heappush(heap, (-(x-y), x, y))\\n        \\n        for _ in range(k):\\n            total += heapq.heappop(heap)[1]\\n        \\n        while heap:\\n            total += heapq.heappop(heap)[2]\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579073,
                "title": "java-class-comparable-solution",
                "content": "# Class PO\\nPO has reward1, reward2, reward diff, reward position\\nsort by diff.\\n\\nk times get p1 values from biggest diff.\\nnext length - k times get p2 values.\\n\\n# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PO[] POS = new PO[reward1.length];\\n        \\n        for(int i = 0 ; i < reward1.length ; i++) {\\n            POS[i] = new PO(reward1[i], reward2[i], i);            \\n        }\\n\\n        Arrays.sort(POS);\\n\\n        int result = 0;\\n        for(int i  = 0 ; i < k ; i ++) {\\n            result += POS[i].getp1();\\n        }\\n        for(int i = k ; i < POS.length ; i++) {\\n            result += POS[i].getp2();\\n        }\\n        return result;\\n    }\\n\\n\\n    public class PO implements Comparable<PO> {\\n        int p1;\\n        int p2;\\n        int po;\\n        public PO(int p1, int p2, int po){\\n            this.p1 = p1;\\n            this.p2 = p2;\\n            this.po = po;\\n        }\\n\\n        public int getDiff() {return p1-p2;}\\n        public int getp1() {return p1;}\\n        public int getp2() {return p2;}\\n\\n        @Override\\n        public int compareTo(PO o1){\\n            return o1.getDiff() - this.getDiff();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PO[] POS = new PO[reward1.length];\\n        \\n        for(int i = 0 ; i < reward1.length ; i++) {\\n            POS[i] = new PO(reward1[i], reward2[i], i);            \\n        }\\n\\n        Arrays.sort(POS);\\n\\n        int result = 0;\\n        for(int i  = 0 ; i < k ; i ++) {\\n            result += POS[i].getp1();\\n        }\\n        for(int i = k ; i < POS.length ; i++) {\\n            result += POS[i].getp2();\\n        }\\n        return result;\\n    }\\n\\n\\n    public class PO implements Comparable<PO> {\\n        int p1;\\n        int p2;\\n        int po;\\n        public PO(int p1, int p2, int po){\\n            this.p1 = p1;\\n            this.p2 = p2;\\n            this.po = po;\\n        }\\n\\n        public int getDiff() {return p1-p2;}\\n        public int getp1() {return p1;}\\n        public int getp2() {return p2;}\\n\\n        @Override\\n        public int compareTo(PO o1){\\n            return o1.getDiff() - this.getDiff();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566774,
                "title": "python-greedy-sorting",
                "content": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        rewards = sorted(zip(reward1, reward2), key = lambda t : t[1]-t[0])\\n        return sum(rewards[i][i >= k] for i in range(len(reward1)))\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        rewards = sorted(zip(reward1, reward2), key = lambda t : t[1]-t[0])\\n        return sum(rewards[i][i >= k] for i in range(len(reward1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563614,
                "title": "easy-solution-one-line",
                "content": "# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        return sum(reward2) + sum(sorted([reward1[i]-reward2[i] for i in range(len(reward1))], reverse=True)[:k])\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        return sum(reward2) + sum(sorted([reward1[i]-reward2[i] for i in range(len(reward1))], reverse=True)[:k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560076,
                "title": "python-solution-simple-approach-greedy",
                "content": "Here is the solution using a ***Greedy approach*** where we will find the difference of rewards between the mices  and based on the difference we will keep track of the index and value which are optimal for the first mouse to  eat and get reward and  finally just add the rest of the rewards2 on our res.\\n\\n**Here is the solution**\\n\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n       \\n        dif =[[]]*len(reward1)\\n        res = 0\\n        \\n\\t\\t#find the difference of rewards between the mices and store the result and index together \\n        for i in range(0,len(reward1)):\\n            dif[i] =[reward2[i]-reward1[i], i]\\n        \\n\\t\\t# sort to find the most optimal one for mouse 1\\n        dif.sort(key =lambda x:x[0])\\n       \\n        seen = [False]*len(dif)#store the value of the index used from reward1 \\n        for i in range(k):\\n            res += reward1[dif[i][1]]\\n            idx = dif[i][1]\\n            seen[idx]= True\\n        \\n\\t\\t#add the remaning of the value from reward2 to our  answer\\n        for i in range(len(reward2)):\\n            if seen[i] == True:\\n                continue\\n            res += reward2[i]\\n            \\n        return res\\n           \\n            \\n   \\n```\\n**Time Complexity:** o(nlogn)(for sort) + o(n)(to find the difference between two array) +o(k)(to get the optimal values  from reward1 till k) + o(n-k)(to  add the rest of  the value from reward2), over all  its  ***o(nlogn)*** .\\n**Space Complexity:** o(n) (for storing the diff)\\n\\nThanks and upvote if you like the solution!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n       \\n        dif =[[]]*len(reward1)\\n        res = 0\\n        \\n\\t\\t#find the difference of rewards between the mices and store the result and index together \\n        for i in range(0,len(reward1)):\\n            dif[i] =[reward2[i]-reward1[i], i]\\n        \\n\\t\\t# sort to find the most optimal one for mouse 1\\n        dif.sort(key =lambda x:x[0])\\n       \\n        seen = [False]*len(dif)#store the value of the index used from reward1 \\n        for i in range(k):\\n            res += reward1[dif[i][1]]\\n            idx = dif[i][1]\\n            seen[idx]= True\\n        \\n\\t\\t#add the remaning of the value from reward2 to our  answer\\n        for i in range(len(reward2)):\\n            if seen[i] == True:\\n                continue\\n            res += reward2[i]\\n            \\n        return res\\n           \\n            \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559939,
                "title": "greedy-well-explained",
                "content": "# Approach\\nMain idea is Greedy\\nWe should pick optimal rewards for mouse 1\\n1) Greedy sort reward1 by picking the most difference between reward1 and reward2\\nE.g \\nreward1: [8,1,3,4], reward2: [4,2,1,5], k=2\\nSorted result will contain [ 8, 3, 1, 4 ]\\n \\n2) Pick first k, 8, and 3  then create a map where the key is an index from reward1 {0:true, 2:true}. We need this map for an optimal lookup in step 3\\n\\n3) Iterate over  reward2 and compute a sum by ignoring already picked indexes in the map\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(NLogN)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar miceAndCheese = function(reward1, reward2, k) {\\n\\n    // Step 1\\n    const sorted = [...Array(reward1.length).keys()]\\n    .sort((i1,i2)=> (reward1[i2]-reward2[i2])-(reward1[i1]-reward2[i1]));\\n   \\n    // Step 2\\n    const firstMouseMap={};\\n    for(const i of sorted.slice(0,k)) firstMouseMap[i]=true;\\n\\n    // sum = first mouse rewards\\n    let sum=Object.keys(firstMouseMap).reduce((acc,curr)=>parseInt(reward1[curr])+acc,0);\\n\\n    // Step 3\\n    for(let i=0;i<reward2.length;i++)\\n      if(!firstMouseMap[i]) sum+=reward2[i];\\n\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar miceAndCheese = function(reward1, reward2, k) {\\n\\n    // Step 1\\n    const sorted = [...Array(reward1.length).keys()]\\n    .sort((i1,i2)=> (reward1[i2]-reward2[i2])-(reward1[i1]-reward2[i1]));\\n   \\n    // Step 2\\n    const firstMouseMap={};\\n    for(const i of sorted.slice(0,k)) firstMouseMap[i]=true;\\n\\n    // sum = first mouse rewards\\n    let sum=Object.keys(firstMouseMap).reduce((acc,curr)=>parseInt(reward1[curr])+acc,0);\\n\\n    // Step 3\\n    for(let i=0;i<reward2.length;i++)\\n      if(!firstMouseMap[i]) sum+=reward2[i];\\n\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3553418,
                "title": "priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n        for(int i=0; i<n; i++)\\n        {\\n          pq.push( make_pair(reward1[i]-reward2[i], i) );\\n          if(pq.size() > k)\\n          pq.pop();\\n        }\\n        int sum=0;\\n        while(!pq.empty())\\n        {\\n           auto p = pq.top(); pq.pop();\\n           sum += reward1[p.second];\\n           reward1[p.second]=0;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(reward1[i] == 0)\\n            continue;\\n\\n            sum += reward2[i];\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n        for(int i=0; i<n; i++)\\n        {\\n          pq.push( make_pair(reward1[i]-reward2[i], i) );\\n          if(pq.size() > k)\\n          pq.pop();\\n        }\\n        int sum=0;\\n        while(!pq.empty())\\n        {\\n           auto p = pq.top(); pq.pop();\\n           sum += reward1[p.second];\\n           reward1[p.second]=0;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(reward1[i] == 0)\\n            continue;\\n\\n            sum += reward2[i];\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548857,
                "title": "rust-quickselect-on-the-diffs-beats-100",
                "content": "# Intuition\\nIf k = 0, then the second mouse would eat all the cheese and the only answer is the sum of reward2.\\n\\nIf k = 1, then we choose one piece of cheese i, and we lose reward2[i] but gain reward1[i] instead. We should choose the piece of cheese that has the greatest difference between reward1[i] and reward2[i], and our total reward would be reward2_sum + reward1[i] - reward2[i].\\n\\nThis is true in general (greedy) so we should\\n\\n# Approach\\nHandle the edge cases (k==n and k==0), these just require summing one of the two lists.\\n\\nThen, we need to iterate over both lists to get the diffs between rewards. We\\'re looking for the k values where reward1[i] - reward2[i] is the greatest; equivalently, the k values where reward2[i] - reward1[i] is the smallest.\\n\\nBut because we don\\'t care about the order of these k elements, and we don\\'t care about the order of the other n-k elements either, we don\\'t need to do a full sort. So instead of calling .sort_unstable(), we can call .select_nth_unstable(). We don\\'t need stability here (it\\'s just integers).\\n\\n\\n# Complexity\\n- Time complexity: O(n log n) in the worst case for the quickselect operation.\\n\\n- Space complexity: O(n), we need to allocate temporary space for the reward diffs. We could theoretically reduce this to O(k) by using heapselect, but heapselect generally has worse performance than quickselect and O(n) is still pretty good.\\n\\n# Code\\n```\\n\\nimpl Solution {\\n    pub fn mice_and_cheese(reward1: Vec<i32>, reward2: Vec<i32>, k: i32) -> i32 {\\n        let n = reward1.len();\\n        let k = k as usize;\\n\\n        // Edge case: we don\\'t need to look at reward2\\n        if k == n {\\n            return reward1.iter().sum();\\n        } \\n        \\n        let reward2_sum = reward2.iter().sum();\\n        \\n        // Edge case: we don\\'t need to look at reward1\\n        if k == 0 {\\n            return reward2_sum;\\n        }\\n        \\n        // Get the inverse of the diffs we want\\n        let mut reward_diffs = reward1\\n            .into_iter()\\n            .zip(reward2.into_iter())\\n            .map(|(r1, r2)| r2-r1)\\n            .collect::<Vec<i32>>();\\n\\n        // Quickselect to find the kth smallest\\n        reward_diffs.select_nth_unstable(k);\\n\\n        // Subtract out the sum of inverse diffs\\n        reward2_sum - reward_diffs[0..k].iter().sum::<i32>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nimpl Solution {\\n    pub fn mice_and_cheese(reward1: Vec<i32>, reward2: Vec<i32>, k: i32) -> i32 {\\n        let n = reward1.len();\\n        let k = k as usize;\\n\\n        // Edge case: we don\\'t need to look at reward2\\n        if k == n {\\n            return reward1.iter().sum();\\n        } \\n        \\n        let reward2_sum = reward2.iter().sum();\\n        \\n        // Edge case: we don\\'t need to look at reward1\\n        if k == 0 {\\n            return reward2_sum;\\n        }\\n        \\n        // Get the inverse of the diffs we want\\n        let mut reward_diffs = reward1\\n            .into_iter()\\n            .zip(reward2.into_iter())\\n            .map(|(r1, r2)| r2-r1)\\n            .collect::<Vec<i32>>();\\n\\n        // Quickselect to find the kth smallest\\n        reward_diffs.select_nth_unstable(k);\\n\\n        // Subtract out the sum of inverse diffs\\n        reward2_sum - reward_diffs[0..k].iter().sum::<i32>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542016,
                "title": "c-priority-queue",
                "content": "We will use priority queue. Push difference of rewards of all index i.e. r1[i]-r2[i]. Take s as sum of vector reward2.\\nNow priority queue will contain difference of both rewards so the index where difference of reward is max will be added in final ans i.e. s.\\nFor Example-> reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\\nelements pushing in pq will be -3, -3, 2, 3 and s will be 10(sum of reward2)\\nnow k times add top element of pq i.e. add 3 and 2 in s. \\ns becomes 15\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        priority_queue<int> pq;\\n        int s,i,n=r1.size();\\n        for(i=0;i<n;i++){\\n            pq.push(r1[i]-r2[i]);\\n            s+=r2[i];\\n        }\\n        while(k--){\\n            s+=pq.top();\\n            pq.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        priority_queue<int> pq;\\n        int s,i,n=r1.size();\\n        for(i=0;i<n;i++){\\n            pq.push(r1[i]-r2[i]);\\n            s+=r2[i];\\n        }\\n        while(k--){\\n            s+=pq.top();\\n            pq.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538359,
                "title": "rust-solution-using-greedy",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn mice_and_cheese(reward1: Vec<i32>, reward2: Vec<i32>, k: i32) -> i32 {\\n    let n = reward1.len();\\n    let mut temp = vec![(0,0);n];\\n    for i in 0..n {\\n      temp[i] = (reward1[i]-reward2[i], i);\\n    }\\n    temp.sort();\\n    temp.reverse();\\n\\n    let k = k as usize;\\n    let mut result = 0;\\n    for i in 0..k {\\n      result += reward1[temp[i].1];\\n    }\\n    for i in k..n {\\n      result += reward2[temp[i].1];\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn mice_and_cheese(reward1: Vec<i32>, reward2: Vec<i32>, k: i32) -> i32 {\\n    let n = reward1.len();\\n    let mut temp = vec![(0,0);n];\\n    for i in 0..n {\\n      temp[i] = (reward1[i]-reward2[i], i);\\n    }\\n    temp.sort();\\n    temp.reverse();\\n\\n    let k = k as usize;\\n    let mut result = 0;\\n    for i in 0..k {\\n      result += reward1[temp[i].1];\\n    }\\n    for i in k..n {\\n      result += reward2[temp[i].1];\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537845,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to record the difference(reward1 - reward2), then mice1 eat the topK difference, mice2 eat the others.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int, int>> vec;\\n        for(int i = 0; i < reward1.size(); i++) vec.push_back({reward1[i] - reward2[i], i});\\n        sort(vec.begin(), vec.end(), greater<pair<int, int>>());\\n        int res = 0;\\n        for(int i = 0; i < k; i++) res += reward1[vec[i].second];\\n        for(int i = k; i < reward1.size(); i++) res += reward2[vec[i].second];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int, int>> vec;\\n        for(int i = 0; i < reward1.size(); i++) vec.push_back({reward1[i] - reward2[i], i});\\n        sort(vec.begin(), vec.end(), greater<pair<int, int>>());\\n        int res = 0;\\n        for(int i = 0; i < k; i++) res += reward1[vec[i].second];\\n        for(int i = k; i < reward1.size(); i++) res += reward2[vec[i].second];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520717,
                "title": "java-simple-solution-greedy-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int ans = 0;\\n        int[][] diff = new int[n][2];\\n        for(int i=0;i<n;i++)\\n            diff[i] = new int[] {reward1[i]-reward2[i], i};\\n        Arrays.sort(diff, (a,b)->b[0]-a[0]);\\n        for(int i=0;i<k;i++) {\\n            ans += reward1[diff[i][1]];\\n            reward2[diff[i][1]] = 0;\\n        }\\n        for(int i=0;i<n;i++)\\n            ans += reward2[i];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int ans = 0;\\n        int[][] diff = new int[n][2];\\n        for(int i=0;i<n;i++)\\n            diff[i] = new int[] {reward1[i]-reward2[i], i};\\n        Arrays.sort(diff, (a,b)->b[0]-a[0]);\\n        for(int i=0;i<k;i++) {\\n            ans += reward1[diff[i][1]];\\n            reward2[diff[i][1]] = 0;\\n        }\\n        for(int i=0;i<n;i++)\\n            ans += reward2[i];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520716,
                "title": "java-simple-solution-greedy-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int ans = 0;\\n        int[][] diff = new int[n][2];\\n        for(int i=0;i<n;i++)\\n            diff[i] = new int[] {reward1[i]-reward2[i], i};\\n        Arrays.sort(diff, (a,b)->b[0]-a[0]);\\n        for(int i=0;i<k;i++) {\\n            ans += reward1[diff[i][1]];\\n            reward2[diff[i][1]] = 0;\\n        }\\n        for(int i=0;i<n;i++)\\n            ans += reward2[i];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int ans = 0;\\n        int[][] diff = new int[n][2];\\n        for(int i=0;i<n;i++)\\n            diff[i] = new int[] {reward1[i]-reward2[i], i};\\n        Arrays.sort(diff, (a,b)->b[0]-a[0]);\\n        for(int i=0;i<k;i++) {\\n            ans += reward1[diff[i][1]];\\n            reward2[diff[i][1]] = 0;\\n        }\\n        for(int i=0;i<n;i++)\\n            ans += reward2[i];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489970,
                "title": "c-greedy-maxheap-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor a particular cheese index we have to choose max reward from both reward Array and also we have to take atleast k elements from reward1\\n\\nso to achive the optimal solution we have to take care of two things while selecting k elements from reward1\\n1 the element should be greater than other elements in reward1 \\n2 the element should be less than or equal to the element present at particular index in reward2   \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will store the diffrence of both rewards in max heap this will make sure the element we are selecting is greater in reward in its own array and also it is greater than the element of other array at perticular idx\\n\\npop the elements from max heap, add the points from reward 1 untill k > 0 then add from reward 2\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# o(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<vector<int>>allReward;\\n        for(int i = 0; i < reward1.size(); i++){\\n            allReward.push({reward1[i]-reward2[i],i});\\n        }\\n        int totalPoints = 0;\\n        while(!allReward.empty()){\\n            if(k > 0){\\n               totalPoints += reward1[allReward.top()[1]];\\n               k--;\\n            }else{\\n               totalPoints += reward2[allReward.top()[1]];\\n            }\\n            allReward.pop();\\n        }\\n        return totalPoints;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<vector<int>>allReward;\\n        for(int i = 0; i < reward1.size(); i++){\\n            allReward.push({reward1[i]-reward2[i],i});\\n        }\\n        int totalPoints = 0;\\n        while(!allReward.empty()){\\n            if(k > 0){\\n               totalPoints += reward1[allReward.top()[1]];\\n               k--;\\n            }else{\\n               totalPoints += reward2[allReward.top()[1]];\\n            }\\n            allReward.pop();\\n        }\\n        return totalPoints;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485474,
                "title": "c-solution-using-priority-queue",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n    public int MiceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PriorityQueue<int,int> pq = new(Comparer<int>.Create((a, b) => a.CompareTo(b)));\\n        for(int i = 0; i < reward1.Length;i++)\\n            pq.Enqueue(i,reward2[i] -  reward1[i]);\\n        int res = 0;\\n        while(pq.Count > 0){\\n            if(k-- > 0) res+= reward1[pq.Dequeue()];\\n            else res+=reward2[pq.Dequeue()];\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MiceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PriorityQueue<int,int> pq = new(Comparer<int>.Create((a, b) => a.CompareTo(b)));\\n        for(int i = 0; i < reward1.Length;i++)\\n            pq.Enqueue(i,reward2[i] -  reward1[i]);\\n        int res = 0;\\n        while(pq.Count > 0){\\n            if(k-- > 0) res+= reward1[pq.Dequeue()];\\n            else res+=reward2[pq.Dequeue()];\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466488,
                "title": "c-easy-solution-push-the-difference-in-the-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) \\n    {\\n        int point=0;\\n        for(int i=0;i<r2.size();i++) point+=r2[i];\\n        \\n        priority_queue<int> pq;\\n        for(int i=0;i<r1.size();i++) pq.push(r1[i]-r2[i]);\\n        \\n        while(k--)\\n        {\\n            point+=pq.top();\\n            pq.pop();\\n        }\\n        return point;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) \\n    {\\n        int point=0;\\n        for(int i=0;i<r2.size();i++) point+=r2[i];\\n        \\n        priority_queue<int> pq;\\n        for(int i=0;i<r1.size();i++) pq.push(r1[i]-r2[i]);\\n        \\n        while(k--)\\n        {\\n            point+=pq.top();\\n            pq.pop();\\n        }\\n        return point;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462502,
                "title": "c-linq",
                "content": "# Intuition\\nSum up all scores of `reward2`, then add the largest `k` score differences between `reward1[i]` and `reward2[i]` to it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MiceAndCheese(int[] reward1, int[] reward2, int k) => reward2.Sum() + reward1.Select((reward, i) => reward - reward2[i]).OrderByDescending(d => d).Take(k).Sum();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MiceAndCheese(int[] reward1, int[] reward2, int k) => reward2.Sum() + reward1.Select((reward, i) => reward - reward2[i]).OrderByDescending(d => d).Take(k).Sum();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460766,
                "title": "fast-solution-c-you-ever-seen-o-n-officialhemant-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<int>p;\\n        int sum=0;\\n        \\n        for(int i=0;i<reward1.size();i++){\\n            p.push(reward1[i]-reward2[i]);\\n            sum += reward2[i];\\n        }\\n        \\n        while(k--){\\n            sum+=p.top();\\n            p.pop();\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<int>p;\\n        int sum=0;\\n        \\n        for(int i=0;i<reward1.size();i++){\\n            p.push(reward1[i]-reward2[i]);\\n            sum += reward2[i];\\n        }\\n        \\n        while(k--){\\n            sum+=p.top();\\n            p.pop();\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455013,
                "title": "c-4-lines-greedy-with-difference-arrays",
                "content": "# Intuition\\n\\nFor any two cheese pieces, `i` and `j`, we want to determine which mouse should eat which cheese to maximize the total reward. We can achieve this by comparing the sum of rewards for the two possible pairings of the mice and cheeses: `reward1[i] + reward2[j] and reward1[j] + reward2[i]`.\\n\\nTo simplify this comparison, we can reformulate it as `reward1[i] - reward2[i] > reward1[j] - reward2[j]`. This is equivalent to saying that mouse `i` should eat the cheese with the higher net reward (`reward1[i] - reward2[i]`), as compared to mouse `j` eating the cheese with the higher net reward (`reward1[j] - reward2[j]`).\\n\\nWe can create a difference array `diff` that stores the net rewards for each mouse and cheese pair, where `diff[i] = reward1[i] - reward2[i]`. This allows us to directly compare the net rewards of different pairs of mice and cheeses by comparing the corresponding values in `diff`.\\n\\nFinally, we can find the `k` largest values in `diff` using a heap or sorting and add them to the result.\\n\\n# Approach\\n\\n- Initialize the result `res` to the sum of all the rewards in `reward2`.\\n- Subtract the rewards in `reward2` from the corresponding rewards in `reward1`.\\n- Create a difference array `diff` as `diff[i] = reward1[i] - reward2[i]`.\\n- Sort the difference array in descending order.\\n- Add the `k` largest elements of `diff` to `res`.\\n- Return `res`.\\n\\n# Complexity\\n\\n- Time complexity: $O(n \\\\log n)$, due to sorting the `diff` array.\\n- Space complexity: $O(n)$, to store the `diff` array.\\n\\n# Code\\n## Full Version\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        \\n        // Step 1: Subtract each element of reward2 from reward1\\n        for (int i = 0; i < n; ++i)\\n            reward1[i] -= reward2[i];\\n        \\n        // Step 2: Create the difference array diff\\n        vector<int> diff(n);\\n        for (int i = 0; i < n; ++i)\\n            diff[i] = reward1[i];\\n        \\n        // Step 3: Sort the difference array in decreasing order\\n        sort(diff.rbegin(), diff.rend());\\n        \\n        // Step 4: Calculate the result\\n        int res = accumulate(reward2.begin(), reward2.end(), 0);\\n        for (int i = 0; i < k; ++i)\\n            res += diff[i];\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n\\n<br/>\\nOnce we get the hang of the quirk to solve this problem, we can construct the difference array in place, which makes the space complexity `O(1)`.\\n\\n## Shorter Version\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), sum = reduce(reward2.begin(), reward2.end(), 0);\\n        for (int i = 0; i < n; ++i) reward1[i] -= reward2[i];\\n        sort(reward1.rbegin(), reward1.rend());\\n        return reduce(reward1.begin(), reward1.begin() + k, sum);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        \\n        // Step 1: Subtract each element of reward2 from reward1\\n        for (int i = 0; i < n; ++i)\\n            reward1[i] -= reward2[i];\\n        \\n        // Step 2: Create the difference array diff\\n        vector<int> diff(n);\\n        for (int i = 0; i < n; ++i)\\n            diff[i] = reward1[i];\\n        \\n        // Step 3: Sort the difference array in decreasing order\\n        sort(diff.rbegin(), diff.rend());\\n        \\n        // Step 4: Calculate the result\\n        int res = accumulate(reward2.begin(), reward2.end(), 0);\\n        for (int i = 0; i < k; ++i)\\n            res += diff[i];\\n        \\n        return res;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), sum = reduce(reward2.begin(), reward2.end(), 0);\\n        for (int i = 0; i < n; ++i) reward1[i] -= reward2[i];\\n        sort(reward1.rbegin(), reward1.rend());\\n        return reduce(reward1.begin(), reward1.begin() + k, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453363,
                "title": "one-line-python-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def miceAndCheese(self, reward1, reward2, k):\\n        return sum(reward2) + sum(sorted([r1 - r2 for (r1, r2) in zip(reward1, reward2)], key = lambda x: -x)[:k])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def miceAndCheese(self, reward1, reward2, k):\\n        return sum(reward2) + sum(sorted([r1 - r2 for (r1, r2) in zip(reward1, reward2)], key = lambda x: -x)[:k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446695,
                "title": "easy-understanding-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        /*\\n        Here the thing is ice 2 will eat everything that is reaming so i want to sum up with maximum amount of cheese eaten by them \\n\\n        For te same i will be using priority quwue but now i need to know thae difference as well \\n        */\\n        int ans =0;\\n        priority_queue<int>pq;\\n        for(auto x: reward2)\\n        {\\n            ans+=x;\\n        }\\n\\n        //Now  i iwll sotre the difference of the reward such that the amount of cheeses eaten by mouse 1 is more as compare to mouse2 \\n        for(int i =0;i<reward1.size();i++)\\n        {\\n            pq.push(reward1[i]-reward2[i]);\\n        }\\n\\n        while(k--)\\n        {\\n            int x = pq.top();\\n            pq.pop();\\n            ans+=x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        /*\\n        Here the thing is ice 2 will eat everything that is reaming so i want to sum up with maximum amount of cheese eaten by them \\n\\n        For te same i will be using priority quwue but now i need to know thae difference as well \\n        */\\n        int ans =0;\\n        priority_queue<int>pq;\\n        for(auto x: reward2)\\n        {\\n            ans+=x;\\n        }\\n\\n        //Now  i iwll sotre the difference of the reward such that the amount of cheeses eaten by mouse 1 is more as compare to mouse2 \\n        for(int i =0;i<reward1.size();i++)\\n        {\\n            pq.push(reward1[i]-reward2[i]);\\n        }\\n\\n        while(k--)\\n        {\\n            int x = pq.top();\\n            pq.pop();\\n            ans+=x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442314,
                "title": "java-records-approach-comparator-lambda",
                "content": "# Intuition\\nUse a prioQ, with a java records and a comparator to make the data access a bit easier. \\n\\n# Code\\n```\\nclass Solution {\\n\\npublic int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        //reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\\n\\n        //1 =     [1,1,3,4]\\n        //2 =     [4,4,1,1]\\n        //delta = [-3,-3,2,3]\\n\\n        var prioQ = new PriorityQueue<>(Comparator.comparingInt(Delta::delta).reversed());\\n        for (int i = 0; i < reward1.length; i++) {\\n            prioQ.add(new Delta(reward1[i], reward2[i], reward1[i] - reward2[i], i));\\n        }\\n\\n        int totalToReturn = 0;\\n        var usedIndex = new HashSet<Integer>();\\n        int localK = k;\\n        //have first mouse eat k types of cheese\\n        while (localK > 0) {\\n            //pop highest reward 1 cheeses\\n            Delta currenthighest = prioQ.poll();\\n            totalToReturn += currenthighest.r1;\\n            usedIndex.add(currenthighest.index);\\n            localK--;\\n        }\\n\\n\\n        //have second mouse eat the remaining cheese\\n\\n\\n        int remaining = reward1.length - k;\\n        while (remaining > 0) {\\n            Delta current = prioQ.poll();\\n            if (usedIndex.contains(current.index)) {\\n                continue;\\n            }\\n\\n            totalToReturn += current.r2;\\n            remaining--;\\n        }\\n\\n\\n        return totalToReturn;\\n    }\\n\\n    record Delta(int r1, int r2, int delta, int index) {\\n    }\\n\\n    ;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\npublic int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        //reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\\n\\n        //1 =     [1,1,3,4]\\n        //2 =     [4,4,1,1]\\n        //delta = [-3,-3,2,3]\\n\\n        var prioQ = new PriorityQueue<>(Comparator.comparingInt(Delta::delta).reversed());\\n        for (int i = 0; i < reward1.length; i++) {\\n            prioQ.add(new Delta(reward1[i], reward2[i], reward1[i] - reward2[i], i));\\n        }\\n\\n        int totalToReturn = 0;\\n        var usedIndex = new HashSet<Integer>();\\n        int localK = k;\\n        //have first mouse eat k types of cheese\\n        while (localK > 0) {\\n            //pop highest reward 1 cheeses\\n            Delta currenthighest = prioQ.poll();\\n            totalToReturn += currenthighest.r1;\\n            usedIndex.add(currenthighest.index);\\n            localK--;\\n        }\\n\\n\\n        //have second mouse eat the remaining cheese\\n\\n\\n        int remaining = reward1.length - k;\\n        while (remaining > 0) {\\n            Delta current = prioQ.poll();\\n            if (usedIndex.contains(current.index)) {\\n                continue;\\n            }\\n\\n            totalToReturn += current.r2;\\n            remaining--;\\n        }\\n\\n\\n        return totalToReturn;\\n    }\\n\\n    record Delta(int r1, int r2, int delta, int index) {\\n    }\\n\\n    ;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435812,
                "title": "javascript-o-n-time-o-1-space-uint16array",
                "content": "# Intuition\\nWe need to calc differents between `i-th` items of 2 arrays. `reward1[i] - reward2[i] (xx[i] - yy[i])`. For `k` maximum of them choose items from `reward1 (xx)` and others get from `reward2 (yy)`.\\n```\\n                if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\\nxx = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \\nyy = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \\n                ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\\n```\\nThis is the same as if we sum all the elements from the second array and add to it `k` maximum differences from the first.\\nComplexity is limited by sort type. Real time and memory costs are lower using a typed array\\n# Algo\\n1. Sum all items from `reward2 (yy)`\\n2. Calc and store diffs `reward1[i] - reward2[i] (xx[i] - yy[i])`\\n3. Sort diffs in desc using counting sort. That gives us $$O(n)$$ time instead of $$O(n\\u2022logn)$$\\n4. Add `k` first items from diffs to the sum\\n\\n\\n# Code\\n```\\nvar miceAndCheese = function(xx, yy, k) {\\n  const n = xx.length;  \\n  const cnt = new Uint16Array(2e3+1)\\n  let ans = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    ans += yy[i]\\n    cnt[xx[i] - yy[i] + 1e3]++  \\n  }\\n\\n  for (let i = 2e3; i >= 0; i--) {\\n    while (k && cnt[i]--) {\\n      ans += i - 1e3;\\n      k--\\n    }\\n  }\\n\\n  return ans\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ for counting sort here\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ for 2001 items of counting sort array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Upvote if helpfull \\uD83E\\uDD73",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Greedy",
                    "Counting Sort"
                ],
                "code": "```\\n                if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\\nxx = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \\nyy = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \\n                ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\\n```\n```\\nvar miceAndCheese = function(xx, yy, k) {\\n  const n = xx.length;  \\n  const cnt = new Uint16Array(2e3+1)\\n  let ans = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    ans += yy[i]\\n    cnt[xx[i] - yy[i] + 1e3]++  \\n  }\\n\\n  for (let i = 2e3; i >= 0; i--) {\\n    while (k && cnt[i]--) {\\n      ans += i - 1e3;\\n      k--\\n    }\\n  }\\n\\n  return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424586,
                "title": "easy-c-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<pair<int,int>> temp;\\n        for(int i = 0;i<n;i++)\\n        {\\n            temp.push_back({reward1[i]-reward2[i],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        int ans = 0;\\n        int i = 0;\\n        while(k>0)\\n        {\\n            ans+=reward1[temp[i].second];\\n            k--;\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            ans+= reward2[temp[i].second];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        vector<pair<int,int>> temp;\\n        for(int i = 0;i<n;i++)\\n        {\\n            temp.push_back({reward1[i]-reward2[i],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        int ans = 0;\\n        int i = 0;\\n        while(k>0)\\n        {\\n            ans+=reward1[temp[i].second];\\n            k--;\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            ans+= reward2[temp[i].second];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424383,
                "title": "c-solution",
                "content": "# Intuition\\nGiven 2 cheeses, how would we allocate 1 cheese to rat1? Consider the example below (sorted by rat 1)\\nreward1 = [10, 5]\\nreward2 = [9, 3]\\n\\nThe optimal allocation is cheese 1 for rat1 and cheese 0 for rat2. If we instead gave cheese 0 to rat1, we have \"gained\" 1 point for cheese 0, but then lose 2 points when allocating cheese 1 to rat2 (3-5 = -2, total is 1 - 2 = -1)\\n\\nThe idea is to maximize the sum of differences in points. In other words, the optimal allocation for rat 1 is to pick the first k cheeses after sorting by the difference in rewards (in descending order). For the example above with k=1, the max difference is (9-10) + (5-3) = 1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int, int>> rewards;\\n        for (int i = 0; i < reward1.size(); ++i)\\n            rewards.emplace_back(reward1[i], reward2[i]);\\n\\n        sort(begin(rewards), end(rewards), [&](const auto& a, const auto& b) {\\n            return a.first - a.second > b.first - b.second;\\n        });\\n\\n        int res = 0;\\n        int i = 0;\\n        for (; i < k; ++i) {\\n            res += rewards[i].first;\\n        }\\n        for (; i < reward1.size(); ++i) {\\n            res += rewards[i].second;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<pair<int, int>> rewards;\\n        for (int i = 0; i < reward1.size(); ++i)\\n            rewards.emplace_back(reward1[i], reward2[i]);\\n\\n        sort(begin(rewards), end(rewards), [&](const auto& a, const auto& b) {\\n            return a.first - a.second > b.first - b.second;\\n        });\\n\\n        int res = 0;\\n        int i = 0;\\n        for (; i < k; ++i) {\\n            res += rewards[i].first;\\n        }\\n        for (; i < reward1.size(); ++i) {\\n            res += rewards[i].second;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424006,
                "title": "using-greedy-and-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        for(int i=0;i<reward1.size();i++){\\n            pq.push({(reward1[i]-reward2[i]),i});\\n\\n        }\\n        int ans=0;\\n        \\n       for(int i=0;i<k;i++){\\n           ans+=reward1[pq.top().second];\\n           reward2[pq.top().second]=0;\\n           pq.pop();\\n       }\\n       for(int i=0;i<reward2.size();i++){\\n           ans+=reward2[i];\\n       }     \\n       return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        for(int i=0;i<reward1.size();i++){\\n            pq.push({(reward1[i]-reward2[i]),i});\\n\\n        }\\n        int ans=0;\\n        \\n       for(int i=0;i<k;i++){\\n           ans+=reward1[pq.top().second];\\n           reward2[pq.top().second]=0;\\n           pq.pop();\\n       }\\n       for(int i=0;i<reward2.size();i++){\\n           ans+=reward2[i];\\n       }     \\n       return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418849,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public int miceAndCheese(int[] A, int[] B, int k) {\\n        int res = 0, n = A.length, diff[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = A[i] - B[i];\\n            res += B[i];\\n        }\\n        Arrays.sort(diff);\\n        for (int i = 0; i < k; i++)\\n            res += diff[n - 1 - i];\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int miceAndCheese(int[] A, int[] B, int k) {\\n        int res = 0, n = A.length, diff[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = A[i] - B[i];\\n            res += B[i];\\n        }\\n        Arrays.sort(diff);\\n        for (int i = 0; i < k; i++)\\n            res += diff[n - 1 - i];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417948,
                "title": "greedy-approach-o-nlogn-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given two reward arrays representing the points earned when a mouse eats a specific type of cheese. Our goal is to maximize the total points by having the first mouse eat exactly k types of cheese, and the second mouse eats the remaining cheese. A greedy approach can be applied to find the maximum total points.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the sum of the second mouse\\'s rewards, as this mouse will eat some of the cheese.\\n1. Modify the first reward array to hold the difference between the reward1 and reward2 arrays, which represents the potential gain if the first mouse eats the corresponding cheese.\\n1. Sort the modified reward1 array in ascending order.\\n1. Iterate through the last k elements of the sorted reward1 array, adding the values to the sum.\\n1. Return the sum as the maximum points the mice can achieve.\\n# Complexity\\n- Time complexity: O(nlogn), as the dominating factor is the time complexity of the sorting step.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1), since we only use a constant amount of extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int sum = 0;\\n        for (int num : reward2) {\\n            sum = sum + num;\\n        }\\n        for (int i = 0 ; i < reward1.length; i++) {\\n            reward1[i] = reward1[i] - reward2[i];\\n        }\\n        \\n        Arrays.sort(reward1);\\n        int index = reward1.length - 1;\\n        for (int i = 0; i < k; i++) {\\n            sum += reward1[index--];\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int sum = 0;\\n        for (int num : reward2) {\\n            sum = sum + num;\\n        }\\n        for (int i = 0 ; i < reward1.length; i++) {\\n            reward1[i] = reward1[i] - reward2[i];\\n        }\\n        \\n        Arrays.sort(reward1);\\n        int index = reward1.length - 1;\\n        for (int i = 0; i < k; i++) {\\n            sum += reward1[index--];\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415243,
                "title": "c-solution-minheap-easy-to-understand-2023",
                "content": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n        int n = reward1.size();\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        \\n        for (int i=0; i < n; i++){\\n            pq.push({reward1[i] - reward2[i], i});\\n            \\n            if (pq.size() > k){\\n                pq.pop();\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        while (!pq.empty()){\\n            ans += reward1[pq.top().second];\\n            reward2[pq.top().second] = 0;\\n            pq.pop();\\n        }\\n        \\n        for (int i=0; i < n; i++){\\n            ans += reward2[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n        int n = reward1.size();\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        \\n        for (int i=0; i < n; i++){\\n            pq.push({reward1[i] - reward2[i], i});\\n            \\n            if (pq.size() > k){\\n                pq.pop();\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        while (!pq.empty()){\\n            ans += reward1[pq.top().second];\\n            reward2[pq.top().second] = 0;\\n            pq.pop();\\n        }\\n        \\n        for (int i=0; i < n; i++){\\n            ans += reward2[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414594,
                "title": "c-6-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        int res = 0;\\n        vector<tuple<int,int,int>> v;\\n        for(int i=0;i<r1.size();i++) v.emplace_back(r2[i] - r1[i], r1[i], r2[i]);\\n        sort(v.begin(), v.end());\\n        for(int i=0;i<v.size();i++) res += (i<k) ? get<1>(v[i]) : get<2>(v[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {\\n        int res = 0;\\n        vector<tuple<int,int,int>> v;\\n        for(int i=0;i<r1.size();i++) v.emplace_back(r2[i] - r1[i], r1[i], r2[i]);\\n        sort(v.begin(), v.end());\\n        for(int i=0;i<v.size();i++) res += (i<k) ? get<1>(v[i]) : get<2>(v[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412233,
                "title": "simple-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int ans=0;\\n        for(auto x:reward2){ans=ans+x;}\\n        int n=reward1.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++){pq.push(reward1[i]-reward2[i]);}\\n        for(int i=0;i<k;i++){  ans=ans+pq.top(); pq.pop();}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int ans=0;\\n        for(auto x:reward2){ans=ans+x;}\\n        int n=reward1.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++){pq.push(reward1[i]-reward2[i]);}\\n        for(int i=0;i<k;i++){  ans=ans+pq.top(); pq.pop();}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411388,
                "title": "easy-marked-medium-k-from-max-r1-r2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        l=len(reward1)\\n        diff=[]\\n        idx=[]\\n        ans=0\\n        if k==0:\\n            return sum(reward2)\\n            \\n        for i in range(l):\\n            idx.append(i)\\n            diff.append(reward1[i]-reward2[i])\\n        r1=[1]*l\\n        for i in sorted(zip(diff,idx),reverse=True):\\n            r1[i[1]]=-1\\n            k-=1\\n            if k==0:\\n                break\\n        \\n        for i in range(l):\\n            if r1[i]<0:\\n                ans+=reward1[i]\\n            else:\\n                ans+=reward2[i]\\n        return ans\\n                \\n        \\n\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        l=len(reward1)\\n        diff=[]\\n        idx=[]\\n        ans=0\\n        if k==0:\\n            return sum(reward2)\\n            \\n        for i in range(l):\\n            idx.append(i)\\n            diff.append(reward1[i]-reward2[i])\\n        r1=[1]*l\\n        for i in sorted(zip(diff,idx),reverse=True):\\n            r1[i[1]]=-1\\n            k-=1\\n            if k==0:\\n                break\\n        \\n        for i in range(l):\\n            if r1[i]<0:\\n                ans+=reward1[i]\\n            else:\\n                ans+=reward2[i]\\n        return ans\\n                \\n        \\n\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407400,
                "title": "c-heap-faster-easy-to-understand",
                "content": "* ***Heap***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n        int n = reward1.size();\\n        \\n        int res = 0;\\n        \\n        // first of all include all the elements of reward2 into res \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            res += reward2[i];\\n        }\\n        \\n        // declare a max. heap\\n        \\n        priority_queue<int> pq;\\n        \\n        // push the difference of (reward1[i] - reward2[i]) into pq\\n         \\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push((reward1[i] - reward2[i]));\\n        }\\n        \\n        // now take out top k elements from pq\\n        \\n        while(k--)\\n        {\\n            res += pq.top();\\n            \\n            pq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        \\n        int n = reward1.size();\\n        \\n        int res = 0;\\n        \\n        // first of all include all the elements of reward2 into res \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            res += reward2[i];\\n        }\\n        \\n        // declare a max. heap\\n        \\n        priority_queue<int> pq;\\n        \\n        // push the difference of (reward1[i] - reward2[i]) into pq\\n         \\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push((reward1[i] - reward2[i]));\\n        }\\n        \\n        // now take out top k elements from pq\\n        \\n        while(k--)\\n        {\\n            res += pq.top();\\n            \\n            pq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404896,
                "title": "c-6-line-solution-t-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), ret = 0;\\n        if (k > n/2) return miceAndCheese(reward2,reward1,n-k);\\n        priority_queue<int> pq;\\n        for (int i = 0; i < n; ret += reward2[i++]) pq.push(reward1[i]-reward2[i]);\\n        for (int i = 0; i < k; i++, pq.pop()) ret += pq.top();\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size(), ret = 0;\\n        if (k > n/2) return miceAndCheese(reward2,reward1,n-k);\\n        priority_queue<int> pq;\\n        for (int i = 0; i < n; ret += reward2[i++]) pq.push(reward1[i]-reward2[i]);\\n        for (int i = 0; i < k; i++, pq.pop()) ret += pq.top();\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404607,
                "title": "very-naive-approach-and-simple-solution-using-sorting",
                "content": "# Intuition\\n\\n\\n# Approach\\nfirst we find the sum of reward2 then denpending on k we will remove reward2[i] and add reward1[i] such that our total sum be maximum.\\nnow we will find the differce (reward1[i]-reward2[i]) and push into a vector then sort the vector and remove the diff.\\n\\n# Complexity\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\nn\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n=reward1.size();\\n        vector<int>diff;\\n        for(int i=0;i<n;i++){\\n            int temp=reward1[i]-reward2[i];\\n            diff.push_back(temp);\\n        }\\n        sort(diff.begin(),diff.end());\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=reward2[i];\\n        }\\n        int j=n-1;\\n        while(k){\\n            sum+=diff[j];\\n            j--,k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n=reward1.size();\\n        vector<int>diff;\\n        for(int i=0;i<n;i++){\\n            int temp=reward1[i]-reward2[i];\\n            diff.push_back(temp);\\n        }\\n        sort(diff.begin(),diff.end());\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=reward2[i];\\n        }\\n        int j=n-1;\\n        while(k){\\n            sum+=diff[j];\\n            j--,k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404395,
                "title": "easy-python-and-c-solution-o-n-log-n",
                "content": "# Intuition\\n\\n# Approach\\nAs we need to get the maximum sum so basically if we are choosing any index in reward1 we are denying to add the element in reward2 at that index which may be greater than element in reward1 which will have increased the total sum more. so I have taken the difference at all index and stored it in a vector having difference and index. Then i sort the array diff_and_index as the difference is reward2-reward1 so if difference is more negative that means reward1 is more till k number then we have to simply add the remaining element in reward2.\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\ndue to sorting \\n\\n- Space complexity:\\nO(N)\\n\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<vector<int>> diff_and_index;\\n        for (int i=0;i<reward1.size();i++){\\n            vector<int> ele;\\n            ele.push_back(reward2[i]-reward1[i]);\\n            ele.push_back(i);\\n            diff_and_index.push_back(ele);\\n        }\\n        sort(diff_and_index.begin(),diff_and_index.end());\\n        int ans=0;\\n        for (int i=0; i<reward1.size(); i++){\\n            int indx=diff_and_index[i][1];\\n            if (k>0){\\n                ans+=reward1[indx];\\n                k--;\\n            }else{\\n                ans+=reward2[indx];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        diff_and_index=[]\\n        for i in range(len(reward1)):\\n            ele=[]\\n            ele.append(reward2[i]-reward1[i])\\n            ele.append(i)\\n            diff_and_index.append(ele)\\n        diff_and_index.sort()\\n        ans=0\\n        for i in range(len(reward1)):\\n            if k>0:\\n                ans+=reward1[diff_and_index[i][1]]\\n                k-=1\\n            else:\\n                ans+=reward2[diff_and_index[i][1]]\\n        return ans\\n```\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        vector<vector<int>> diff_and_index;\\n        for (int i=0;i<reward1.size();i++){\\n            vector<int> ele;\\n            ele.push_back(reward2[i]-reward1[i]);\\n            ele.push_back(i);\\n            diff_and_index.push_back(ele);\\n        }\\n        sort(diff_and_index.begin(),diff_and_index.end());\\n        int ans=0;\\n        for (int i=0; i<reward1.size(); i++){\\n            int indx=diff_and_index[i][1];\\n            if (k>0){\\n                ans+=reward1[indx];\\n                k--;\\n            }else{\\n                ans+=reward2[indx];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        diff_and_index=[]\\n        for i in range(len(reward1)):\\n            ele=[]\\n            ele.append(reward2[i]-reward1[i])\\n            ele.append(i)\\n            diff_and_index.append(ele)\\n        diff_and_index.sort()\\n        ans=0\\n        for i in range(len(reward1)):\\n            if k>0:\\n                ans+=reward1[diff_and_index[i][1]]\\n                k-=1\\n            else:\\n                ans+=reward2[diff_and_index[i][1]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402418,
                "title": "python-greedy-explained-with-sorting",
                "content": "Let M2 pick all the cheese first, then `res = sum(reward2)`.\\nThen let M1 pick all K cheeses. To maximize the total reward, M1 will pick the max gain cheese, which is the max diff of all pairs `max(a - b for (a,b) in zip(reward1, reward2)))`. Add this `max_gain` to `res`, and repeat for all `K` steps. Since `0 <= K <= N`, it may be better to sort the `gains` first to avoid recomputing the `max_gain` each time.\\n\\nNotice that the order of types of cheese do not matter (as long as the pairs are aligned). \\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        n = len(reward1)\\n        gains = sorted([a - b for (a, b) in zip(reward1, reward2)])\\n        return sum(reward2) + sum(gains[n - k:])\\n```\\n\\nOne liner:\\n```\\nreturn sum(reward2) + sum(sorted([a - b for (a, b) in zip(reward1, reward2)])[len(reward1) - k:])\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        n = len(reward1)\\n        gains = sorted([a - b for (a, b) in zip(reward1, reward2)])\\n        return sum(reward2) + sum(gains[n - k:])\\n```\n```\\nreturn sum(reward2) + sum(sorted([a - b for (a, b) in zip(reward1, reward2)])[len(reward1) - k:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399636,
                "title": "python3-o-nlogn-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer is sum(reward2) + sum(v1 - v2), where v1 is first mouse eats, v2 is the cheese having the same position as v1. In order to maximum the answer, we need to max sum(v1 - v2), which can be obtain by sorting.\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        return sum(reward2) + (sum(sorted([v1 - v2 for v1, v2 in zip(reward1, reward2)])[-k:]) if k else 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        return sum(reward2) + (sum(sorted([v1 - v2 for v1, v2 in zip(reward1, reward2)])[-k:]) if k else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398416,
                "title": "python-simple-solution",
                "content": "```\\ndef miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        arr = zip(reward1, reward2)\\n        re = 0\\n        for pair in sorted(arr, key=lambda x: x[0] - x[1], reverse = True):\\n            if k:\\n                k -= 1\\n                re += pair[0]\\n            else:\\n                re += pair[1]\\n        return re\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        arr = zip(reward1, reward2)\\n        re = 0\\n        for pair in sorted(arr, key=lambda x: x[0] - x[1], reverse = True):\\n            if k:\\n                k -= 1\\n                re += pair[0]\\n            else:\\n                re += pair[1]\\n        return re\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3396857,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        priority_queue <pair<int,int>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({reward2[i]-reward1[i],i});\\n            if(pq.size() > k)\\n                pq.pop();\\n        }\\n        int ans = 0,tmp;\\n        vector <bool> vis(n,false);\\n        while(k--){\\n            tmp = pq.top().second;\\n            pq.pop();\\n            ans += reward1[tmp];\\n            vis[tmp] = true;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n                ans += reward2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\\n        int n = reward1.size();\\n        priority_queue <pair<int,int>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({reward2[i]-reward1[i],i});\\n            if(pq.size() > k)\\n                pq.pop();\\n        }\\n        int ans = 0,tmp;\\n        vector <bool> vis(n,false);\\n        while(k--){\\n            tmp = pq.top().second;\\n            pq.pop();\\n            ans += reward1[tmp];\\n            vis[tmp] = true;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n                ans += reward2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395522,
                "title": "sorted-zip-lambda",
                "content": "-  zipped\\n- a = [1,2,3]\\n b = [4,5,6]\\n c = [4,5,6,7,8]\\n zipped = zip(a,b)     # \\u6253\\u5305\\u4E3A\\u5143\\u7EC4\\u7684\\u5217\\u8868\\n[(1, 4), (2, 5), (3, 6)]\\nzip(a,c)              # \\u5143\\u7D20\\u4E2A\\u6570\\u4E0E\\u6700\\u77ED\\u7684\\u5217\\u8868\\u4E00\\u81F4\\n[(1, 4), (2, 5), (3, 6)]\\n\\n- sorted\\u51FD\\u6570\\n![\\u5FAE\\u4FE1\\u622A\\u56FE_20230409093244.png](https://assets.leetcode.com/users/images/d354b04a-0a21-4fed-b9ec-628d83c6b931_1681003975.5128512.png)\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        a = sorted(zip(reward1, reward2), key = lambda p: p[1] - p[0])\\n        return sum(p[0] for p in a[:k]) + sum(p[1] for p in a[k:]) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\\n        a = sorted(zip(reward1, reward2), key = lambda p: p[1] - p[0])\\n        return sum(p[0] for p in a[:k]) + sum(p[1] for p in a[k:]) \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1851296,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851159,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851070,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1850934,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851131,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851152,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851209,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1868573,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1852491,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1850991,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851296,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851159,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851070,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1850934,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851131,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851152,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1851209,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1868573,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1852491,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            },
            {
                "id": 1850991,
                "content": [
                    {
                        "username": "mufia001",
                        "content": "The description is a little confusing. To those who were confused just like me, hope this makes it a little better.\\n\\nYou\\'re given two arrays  `reward1` and `reward2` of length `n`. You can either choose a value from `reward1` or `reward2` at specific index i.e. you can only choose from one array at specific index.\\n\\nYou need to `maximize` the `sum` of values chosen from `reward1` and `reward2` with a condition:\\n\\n- You can only chose `k` value from `reward1` and the remaining i.e. `n-k` must be chosen from `reward2`"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This comment is very insightful! I was not able to understand the second point at the time of contest. Really helps!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Tip: Don\\'t freakin overthink!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "Am I the only one who makes a simple greedy question so tough "
                    },
                    {
                        "username": "coder_sd",
                        "content": "no bro me aslo"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "yes"
                    },
                    {
                        "username": "Mek_san",
                        "content": "no bro i am with you dont worry :)"
                    },
                    {
                        "username": "HariKrishnan00",
                        "content": "can anyone explain this testcase \\nInput:\\n[1,4,4,6,4]\\n[6,5,3,6,1]\\n1\\nOutput:\\n12\\nExpected:\\n24"
                    },
                    {
                        "username": "quandaica",
                        "content": "the 2nd mouse can eat all cheese except the position that eaten by 1st mouse.\nthe cost of eating reward1 on position i is  `reward2[i] - reward1[i]`\nfor your test case, the 4th position has the lowest cost: `cost = 1 - 4 = -3` -> take the lowest cost\nthen `result = sum(reward2) - cost  = 24`"
                    },
                    {
                        "username": "praneeth_nellut1",
                        "content": "yeah in this testcase the k value is 1 so the first mice can eat only 1 type of cheese so it eats the the one which is the type less from reward2. In reward 2 the less type of cheese is 1 so inorder to maximize the result we need to include the 4th type cheese in 1st reward so that is 4 and remaining types of cheese are consumed by mouse 2 so the final result is 6+5+3+6+4 = 24"
                    },
                    {
                        "username": "arghyadas",
                        "content": "failed on 550/564\\uD83E\\uDD72"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Damn, didn\\'t notice it was greedy, my DP solution hits the time limit with n=79512 k=66584"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@Dmitrii Kochetov](/dkochetov) it should be of O(n^2) solution , as before solving the problem do look at constraints like here it was 10^5 which means nlogn will work"
                    },
                    {
                        "username": "shakthisri",
                        "content": "https://leetcode.com/problems/mice-and-cheese/solutions/3369365/c-python-java-5-liners/"
                    },
                    {
                        "username": "dsacj",
                        "content": "Can you share your approach for DP solution? \\nGood solution if you get TLE for this large of a test case:)"
                    },
                    {
                        "username": "roshan_leet_200",
                        "content": "Is there anyone who is getting wrong ans for [1,1] [1,1] 2?"
                    },
                    {
                        "username": "fedyashumov",
                        "content": "### Everything we need to know is\nWe must choose `k` items from `reward1` and others from `reward2`. For example:\n```\n                     if k == 0  if k == 1  if k == 2  if k == 3  if k == 4\nreward1 = [1,1,3,4]  [_,_,_,_]  [_,_,_,4]  [_,_,3,4]  [1,_,3,4]  [1,1,3,4]  \nreward2 = [4,4,1,1]  [4,4,1,1]  [4,4,1,_]  [4,4,_,_]  [_,4,_,_]  [_,_,_,_]  \n                     ans == 10  ans == 13  ans == 15  ans == 12  ans == 13\n```"
                    },
                    {
                        "username": "rnishant29",
                        "content": "hats off to @srikkanthr approach!!!!\\n\\nhttps://leetcode.com/contest/weekly-contest-339/submissions/detail/926280190/"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Sort based on reward1[i] - reward2[i] and choose k largest"
                    }
                ]
            }
        ]
    }
]