[
    {
        "title": "Disconnect Path in a Binary Matrix by at Most One Flip",
        "question_content": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.&nbsp;The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 1000\n\t1 <= m * n <= 105\n\tgrid[i][j] is either 0 or 1.\n\tgrid[0][0] == grid[m - 1][n - 1] == 1",
        "solutions": [
            {
                "id": 3141656,
                "title": "explained-run-dfs-2-times-very-simple-and-easy-to-understand-solution",
                "content": "UP vote if you like the solution !!!\\n# Approach\\nThere are two cases:\\n1. When there is no path at all from (0,0) to (m-1, n-1) position, so simply return true;\\n2. When there is one path but after fliping one value we will not able to reach the destination.\\n   - In the first traversal we will simply set all trqavesed node to 0\\n   - By doing this, if there is any alternate path thats not depends on the first one then \\n     its not possible to flip a single value to 0 and we won\\'t be reaching.\\n     \\n# Complexity\\n- Time complexity: O(M * N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>> &grid, int i, int j){ \\n        if(i+1 == grid.size() && j+1 == grid[0].size()) return true;\\n        if(i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return false;\\n        grid[i][j] = 0;\\n        return dfs(grid, i+1, j) || dfs(grid, i, j+1);\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) { \\n        if(dfs(grid, 0, 0) == false) return true;\\n        grid[0][0] = 1;\\n        return !dfs(grid, 0, 0);\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience at Amazon, you may like : \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>> &grid, int i, int j){ \\n        if(i+1 == grid.size() && j+1 == grid[0].size()) return true;\\n        if(i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return false;\\n        grid[i][j] = 0;\\n        return dfs(grid, i+1, j) || dfs(grid, i, j+1);\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) { \\n        if(dfs(grid, 0, 0) == false) return true;\\n        grid[0][0] = 1;\\n        return !dfs(grid, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141667,
                "title": "dp-count-number-of-path-simple-solution",
                "content": "# Intuition\\nIf there exist a point `(i, j)` which is not `(0, 0)` or `(m-1, n-1)`, such that the number of the paths from `(0, 0)` to `(m-1, n-1)` go through `(i, j)`equals the number of paths from `(0, 0)` to `(m-1, n-1)` without any constraint, return True.\\n\\n# Approach\\n\\nTo count the numbers of paths go through `(i, j)`. We just calculate number of paths from `(0, 0)` to `(i, j)` and number of paths from `(i, j)` to `(m-1, n-1)`, then multiply them up.\\n\\n# Complexity\\n- Time complexity:\\n$O(n*m)$\\n- Space complexity:\\n$O(n*m)$\\n\\n# Code\\n```python\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        #  number of paths from (0, 0) to (i, j)\\n        dp1 = [[0] * (n+1) for _ in range(m + 1)]\\n        dp1[1][1] = 1\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if grid[i-1][j-1]:\\n                    dp1[i][j] += dp1[i-1][j] + dp1[i][j-1]\\n        \\n        #  number of paths from (i, j) to (m-1, n-1)      \\n        dp2 = [[0] * (n+1) for _ in range(m + 1)]\\n        dp2[-2][-2] = 1\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if grid[i][j]:\\n                    dp2[i][j] += dp2[i+1][j] + dp2[i][j+1]\\n        \\n        # number of paths from (0, 0) to (m-1, n-1)     \\n        target = dp1[-1][-1]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if (i!=0 or j!=0) and (i!=m-1 or j!=n-1):\\n                    if dp1[i+1][j+1] * dp2[i][j] == target: \\n                        return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        #  number of paths from (0, 0) to (i, j)\\n        dp1 = [[0] * (n+1) for _ in range(m + 1)]\\n        dp1[1][1] = 1\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if grid[i-1][j-1]:\\n                    dp1[i][j] += dp1[i-1][j] + dp1[i][j-1]\\n        \\n        #  number of paths from (i, j) to (m-1, n-1)      \\n        dp2 = [[0] * (n+1) for _ in range(m + 1)]\\n        dp2[-2][-2] = 1\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if grid[i][j]:\\n                    dp2[i][j] += dp2[i+1][j] + dp2[i][j+1]\\n        \\n        # number of paths from (0, 0) to (m-1, n-1)     \\n        target = dp1[-1][-1]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if (i!=0 or j!=0) and (i!=m-1 or j!=n-1):\\n                    if dp1[i+1][j+1] * dp2[i][j] == target: \\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142814,
                "title": "clever-diagonals-with-diagram-explanation",
                "content": "# Overview\\n- The brute force solution would be to search the grid for every $$1$$ that can be flipped. However, this solution would lead to TLE. \\n    - Instead, we can do this problem in $$O(mn)$$. Precisely 3 iterations of the entire grid. \\n    - All we need is $$O(m+n)$$ extra space for a list of diagonals. \\n- It is important to know that the path only has ****2 directions****: down and right. This is an important constraint that makes this solution work. \\n- First, we prune the possible paths so that our grid is simplified.\\n- We keep track of **diagonal counts** (see example) which determine whether or not a graph can be disconnected. \\n\\n# Example\\n\\n- Let us take a look at the given **Example 1:**\\n- The first two steps are used to [prune](https://en.wikipedia.org/wiki/Decision_tree_pruning#:~:text=Pruning%20is%20a%20data%20compression,and%20redundant%20to%20classify%20instances.) our grid so that useless $$1$$\\'s are removed from our grid. \\n\\n\\n![1.jpg](https://assets.leetcode.com/users/images/a28238bf-0729-48b7-92fa-4ccdd6075b0b_1675578847.3532205.jpeg)\\n- The first step prunes the tree by looking at all possible previous steps to that index. So we look at the index above and to the left. \\n- The second step prunes the tree by looking at all possible moves for that index. So we look at the index below and to the right. \\n\\n![2.jpg](https://assets.leetcode.com/users/images/2c8f0fe6-43de-44c2-9260-181debf447f6_1675578859.351846.jpeg)\\n- These two steps require us to iterate through our grid twice. \\n- Now that we have pruned our grid, we will pass this result to the next step which involves diagonal counting. \\n- *Note: motivation for pruning is given at the end of solution.*\\n\\n\\n![3.jpg](https://assets.leetcode.com/users/images/84d30a7b-79d3-4808-8c4b-e157ed2c01f7_1675579201.80358.jpeg)\\n\\n- Notice we do not care about diagonal count for the begin and end. \\n\\n\\n![4.jpg](https://assets.leetcode.com/users/images/ae9dda0d-f8ae-4103-bb70-19beb6f593c0_1675579320.1386802.jpeg)\\n\\n- Think of the diagonals as gates: $$1$$\\'s represent gate openings and $$0$$\\'s represent closed gates. \\n- **If a diagonal does not contain at least 2 openings then it can be disconnected.** \\n- The reason is because if there are 0 openings then there are no paths to $$(n-1, m-1)$$ without any flips. If there is exactly 1 opening for that diagonal, then it can be flipped to make it 0 openings. \\n- What make diagonals special is that the sum of their column and row indices are equivalent. Thus, `diagonals[i+j]` is the same for all that belong in the same diagonal.  \\n# Code\\n\\n```C++ []\\nbool isPossibleToCutPath(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    // Initial pruning\\n    // Forward checking\\n    for (int i = 0; i < m; i++){\\n        for (int j = 0; j < n; j++){\\n            if (i == 0 && j == 0 || grid[i][j] == 0) continue;\\n            if ((i == 0 || grid[i-1][j] == 0) && (j == 0 || grid[i][j-1] == 0)){\\n                grid[i][j] = 0;\\n            }\\n        }\\n    }\\n\\n    // Backwards checking\\n    for (int i = m-1; i >= 0; i--){\\n        for (int j = n-1; j >= 0; j--){\\n            if (i == m-1 && j == n-1 || grid[i][j] == 0) continue;\\n            if ((i == m-1 || grid[i+1][j] == 0) && (j == n-1 || grid[i][j+1] == 0)){\\n                grid[i][j] = 0;\\n            }\\n        }\\n    }\\n\\n    // Diagonal counting\\n    vector<int> diagonal(m+n-1);\\n    for (int i = 0; i < m; i++){\\n        for (int j = 0; j < n; j++){\\n            if (grid[i][j]) diagonal[i+j]++;\\n        }\\n    }\\n\\n    // Final count check\\n    for (int i = 1; i < m+n-2; i++){ \\n        if (diagonal[i] < 2) return true;\\n    }\\n    return false;\\n}\\n```\\n```python3 []\\ndef isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n    m, n = len(grid), len(grid[0])\\n    # Forward checking\\n    for i in range(m):\\n        for j in range(n):\\n            if (i == 0 and j == 0) or (grid[i][j] == 0):\\n                continue\\n            if (i == 0 or grid[i-1][j] == 0) and (j == 0 or grid[i][j-1] == 0):\\n                grid[i][j] = 0\\n\\n    # Backward checking\\n    for i in range(m-1, -1, -1):\\n        for j in range(n-1, -1, -1):\\n            if (i == m-1 and j == n-1) or (grid[i][j] == 0):\\n                continue\\n            if (i == m-1 or grid[i+1][j] == 0) and (j == n-1 or grid[i][j+1] == 0):\\n                grid[i][j] = 0\\n    \\n    # Diagonal counting\\n    diagonal = [0] * (m + n - 1)\\n    for i in range(m):\\n        for j in range(n):\\n            if (grid[i][j] != 0):\\n                diagonal[i + j] += 1\\n\\n    # Final check\\n    for i in range(1, m + n - 2):\\n        if (diagonal[i] < 2):\\n            return True\\n    return False\\n```\\n\\n\\nAdditional note: If you skip pruning, solution will still AC. That is because cases such as the ones below are not being tested. \\n\\n# Motivation for Pruning\\n\\n- Consider the example below: \\n-  `[[1,1,1,0,1],[1,0,1,0,0],[1,1,0,1,1],[0,0,1,0,1],[1,0,1,1,1]]`\\n\\n![1.jpg](https://assets.leetcode.com/users/images/ef49c06d-16ed-4ee5-a579-3f7bb418df24_1675618412.7549036.jpeg)\\n - In this case, the grid is already disconnected. Due to the arrangement of the $$0$$\\'s, diagonal counting will not catch any issues since each diagonal would have 2 openings.  \\n - Example where forward and backward are needed:\\n -  `[[1,1,0,0,1],[1,1,1,1,0],[1,1,0,1,1],[1,0,1,1,1],[1,1,0,1,1]]`\\n \\n![1.jpg](https://assets.leetcode.com/users/images/55b6cc66-8b68-496e-b320-50dc07f54bc2_1675618904.3875883.jpeg)\\n- Notice that after forward checking our grid is still not acceptable for diagonal counting. Only after backward checking is it good. \\n\\n\\n### Please upvote if this helped. Thanks!\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```C++ []\\nbool isPossibleToCutPath(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    // Initial pruning\\n    // Forward checking\\n    for (int i = 0; i < m; i++){\\n        for (int j = 0; j < n; j++){\\n            if (i == 0 && j == 0 || grid[i][j] == 0) continue;\\n            if ((i == 0 || grid[i-1][j] == 0) && (j == 0 || grid[i][j-1] == 0)){\\n                grid[i][j] = 0;\\n            }\\n        }\\n    }\\n\\n    // Backwards checking\\n    for (int i = m-1; i >= 0; i--){\\n        for (int j = n-1; j >= 0; j--){\\n            if (i == m-1 && j == n-1 || grid[i][j] == 0) continue;\\n            if ((i == m-1 || grid[i+1][j] == 0) && (j == n-1 || grid[i][j+1] == 0)){\\n                grid[i][j] = 0;\\n            }\\n        }\\n    }\\n\\n    // Diagonal counting\\n    vector<int> diagonal(m+n-1);\\n    for (int i = 0; i < m; i++){\\n        for (int j = 0; j < n; j++){\\n            if (grid[i][j]) diagonal[i+j]++;\\n        }\\n    }\\n\\n    // Final count check\\n    for (int i = 1; i < m+n-2; i++){ \\n        if (diagonal[i] < 2) return true;\\n    }\\n    return false;\\n}\\n```\n```python3 []\\ndef isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n    m, n = len(grid), len(grid[0])\\n    # Forward checking\\n    for i in range(m):\\n        for j in range(n):\\n            if (i == 0 and j == 0) or (grid[i][j] == 0):\\n                continue\\n            if (i == 0 or grid[i-1][j] == 0) and (j == 0 or grid[i][j-1] == 0):\\n                grid[i][j] = 0\\n\\n    # Backward checking\\n    for i in range(m-1, -1, -1):\\n        for j in range(n-1, -1, -1):\\n            if (i == m-1 and j == n-1) or (grid[i][j] == 0):\\n                continue\\n            if (i == m-1 or grid[i+1][j] == 0) and (j == n-1 or grid[i][j+1] == 0):\\n                grid[i][j] = 0\\n    \\n    # Diagonal counting\\n    diagonal = [0] * (m + n - 1)\\n    for i in range(m):\\n        for j in range(n):\\n            if (grid[i][j] != 0):\\n                diagonal[i + j] += 1\\n\\n    # Final check\\n    for i in range(1, m + n - 2):\\n        if (diagonal[i] < 2):\\n            return True\\n    return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3141701,
                "title": "python-count-points-on-diagonal",
                "content": "# **Preword**\\nTo save your time, all O(m + n) solutions are wrong.\\n<br>\\n\\n# **Explanation**\\n![image](https://assets.leetcode.com/users/images/24890b5e-ba67-4c2e-9096-2e9b39e0b92d_1675529462.9754477.png)\\n\\n# **Explanation**\\nKeep `A[i][j] == 1` for points that\\non the cnnected path from `(0,0)` to `(m-1, n-1)`,\\nassigne all other `A[i][j] = 0`,\\nsince we won\\'t use them in the path.\\n\\nIf we can\\'t disconnect `(0,0)` and `(m-1, n-1)`,\\nthis means we can always have 2 candidates,\\nwe don\\'t have to pass a specific point.\\n\\nNotice all points on the diagonal from top-right to bottom-left,\\nhave same distance from `(0,0)`,\\nhave same distance from `(0,0)`.\\n\\nSo we count the point on each diagonal,\\nwe should always have at lease points as candidates at each time point.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`\\nSpace `O(mn)`\\n<br>\\n\\n**Python**\\n```py\\n    def isPossibleToCutPath(self, A: List[List[int]]) -> bool:\\n        m, n = len(A), len(A[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if i == j == 0 or A[i][j] == 0:\\n                    continue\\n                if (i == 0 or A[i - 1][j] == 0) and (j == 0 or A[i][j - 1] == 0):\\n                    A[i][j] = 0\\n\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if (i == m - 1 and j == n - 1) or A[i][j] == 0:\\n                    continue\\n                if (i == m - 1 or A[i + 1][j] == 0) and (j == n - 1 or A[i][j + 1] == 0):\\n                    A[i][j] = 0\\n        count = Counter(i + j for i in range(m) for j in range(n) if A[i][j])\\n        return any(count[i] < 2 for i in range(1, n + m - 2))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def isPossibleToCutPath(self, A: List[List[int]]) -> bool:\\n        m, n = len(A), len(A[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if i == j == 0 or A[i][j] == 0:\\n                    continue\\n                if (i == 0 or A[i - 1][j] == 0) and (j == 0 or A[i][j - 1] == 0):\\n                    A[i][j] = 0\\n\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if (i == m - 1 and j == n - 1) or A[i][j] == 0:\\n                    continue\\n                if (i == m - 1 or A[i + 1][j] == 0) and (j == n - 1 or A[i][j + 1] == 0):\\n                    A[i][j] = 0\\n        count = Counter(i + j for i in range(m) for j in range(n) if A[i][j])\\n        return any(count[i] < 2 for i in range(1, n + m - 2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3141541,
                "title": "java-o-n-100-straightforward-dfs",
                "content": "\\n# Approach\\nAs only single cell flip checking is required..we can do two pass dfs() and check if there exists more than one path from (0,0) to (m-1,n-1)\\n\\n> **Note: Not finding more than one path in single dfs()...consider there is a critical cell and thr exists two paths from that critical cell..hence doing two-pass to keep code clean...**\\n\\n**Edit: Critical cell example:**\\nI/p:\\n[1,1,1,0,0]\\n[1,0,1,0,0]\\n[1,1,1,1,1]\\n[0,0,1,1,1]\\n[0,0,1,1,1]\\n\\nhere critical cell is **(2,2)**\\n\\nAs you can see there exists many paths from (2,2)\\nE.x: \\n1) (0,0)...(2,2) (3,2)... (m-1,n-1)\\n2) (0,0)...(2,2) (2,3)...(m-1,n-1)\\nand so on... so if all paths possible are only through this critical cell then our answer will be true...\\n\\nHere O/p should be: True\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nRecursion Auxiliary Space\\n\\nPlease upvote if you find useful..thanks for dropping-by.. :-)\\n\\n//code updated\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int first=dfs(grid,0,0);\\n        grid[0][0]=1; //reset for 2nd dfs() as got updated above\\n        int second=dfs(grid,0,0);\\n        return second >= 1 ? false : true;\\n    }\\n    \\n    private int dfs(int[][] g, int r, int c) {\\n        if(r == g.length-1 && c == g[0].length-1)\\n            return 1;\\n        if(r == g.length || c == g[0].length || g[r][c] == 0)\\n            return 0;\\n        \\n        g[r][c]=0;\\n        if(dfs(g,r+1,c) == 1)\\n            return 1;\\n        return dfs(g,r,c+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int first=dfs(grid,0,0);\\n        grid[0][0]=1; //reset for 2nd dfs() as got updated above\\n        int second=dfs(grid,0,0);\\n        return second >= 1 ? false : true;\\n    }\\n    \\n    private int dfs(int[][] g, int r, int c) {\\n        if(r == g.length-1 && c == g[0].length-1)\\n            return 1;\\n        if(r == g.length || c == g[0].length || g[r][c] == 0)\\n            return 0;\\n        \\n        g[r][c]=0;\\n        if(dfs(g,r+1,c) == 1)\\n            return 1;\\n        return dfs(g,r,c+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141835,
                "title": "simple-bfs-o-n-m-detailed-explanation",
                "content": "# Intuition\\nThe first thought for this problem is that only one cell can be flipped to zero. So all we need to do is find out that whether there is a single cell which exists in all paths. If there exists such a cell then we can flip it to zero, else even if we flip a cell there will still be a path.\\n\\n# Approach\\nIn this case we use a **BFS** traversal, and during the traversal if we ever find that the size of the queue is less than 2, then it implies that there is only a single cell which exists in every path, i.e, there is only one possible path ahead. In this case we flip that to zero thereby barricading any possible traversal.\\n\\n# Missing Test Case \\n    [[1,1,1,1,1,1,1,1],\\n    [1,0,1,0,0,0,0,0],\\n    [1,1,1,1,1,1,1,1],\\n    [0,0,1,1,1,1,1,1],\\n    [0,0,1,1,1,1,1,1]]\\n    Expected : true \\n    Output : false\\nThis code does not work for this test case. It is not included in the test cases provided by leetcode so the code has been accepted\\n\\n# Complexity\\n- Time complexity: O (M*N)\\n- In the worst case complexity we will traverse each cell exactly once.\\n\\n\\n- Space complexity:\\n- O (M*N) : The size of grid and the visited array is N X M. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        // Here we maintain a visited array to check if we have \\n        // traversed this node before\\n        vector <vector <int>> vis(n+1,vector <int>(m+1,0));\\n        queue <pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0]=1;\\n        int flag = 0;\\n        // The flag maintains if the size of the queue was less than 2\\n        while(!q.empty())\\n        {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            // to traverse downwards if possible\\n            if(row<n-1 && grid[row+1][col]==1 && vis[row+1][col]==0)\\n            {\\n                q.push({row+1,col});\\n                // If we have reached the destination then it \\n                // implies that there were always more than 1 path\\n                // that existed.\\n                if(row+1==n-1 && col==m-1)\\n                    break;\\n                vis[row+1][col]=1;\\n            }\\n            // to traverse rightwards if possible\\n            if(col<m-1 && grid[row][col+1]==1 && vis[row][col+1]==0)\\n            {\\n                q.push({row,col+1});\\n                // If we have reached the destination then it \\n                // implies that there were always more than 1 path\\n                // that existed.\\n                if(row==n-1 && col+1==m-1)\\n                    break;\\n                vis[row][col+1]=1;\\n            }\\n            if(q.size()<=1)\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        // Here we maintain a visited array to check if we have \\n        // traversed this node before\\n        vector <vector <int>> vis(n+1,vector <int>(m+1,0));\\n        queue <pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0]=1;\\n        int flag = 0;\\n        // The flag maintains if the size of the queue was less than 2\\n        while(!q.empty())\\n        {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            // to traverse downwards if possible\\n            if(row<n-1 && grid[row+1][col]==1 && vis[row+1][col]==0)\\n            {\\n                q.push({row+1,col});\\n                // If we have reached the destination then it \\n                // implies that there were always more than 1 path\\n                // that existed.\\n                if(row+1==n-1 && col==m-1)\\n                    break;\\n                vis[row+1][col]=1;\\n            }\\n            // to traverse rightwards if possible\\n            if(col<m-1 && grid[row][col+1]==1 && vis[row][col+1]==0)\\n            {\\n                q.push({row,col+1});\\n                // If we have reached the destination then it \\n                // implies that there were always more than 1 path\\n                // that existed.\\n                if(row==n-1 && col+1==m-1)\\n                    break;\\n                vis[row][col+1]=1;\\n            }\\n            if(q.size()<=1)\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154733,
                "title": "priority-of-directions",
                "content": "Our search starts from points `[0, 1]` - left, and `[1,0]` - down. We search for two non-intersecting paths from those points.\\n\\nFor the first search, we try to go left first. We go down only if we cannot reach the last cell by going left.\\n\\nFor the second search, the priority of direction is flipped - we go down first.\\n\\nThat way, the first path is closest to the top-right borders of the grid, and the second path - to the bottom-left border.\\n\\nIf we find both paths, then we cannot make the matrix disconnected.\\n\\n> When we traverse a path, we change values in the matrix to zero, so we cannot reuse the same cell the second time.\\n\\nAs [Chasey](https://leetcode.com/Chasey/) noted, since we flip values for the first path, we do not even need to flip directions for the second one.\\n\\nThis simplifies the code, and paves a way for generalized problem when we need to find more than two paths. \\n\\n**C++**\\n```cpp\\nbool dfs(vector<vector<int>>& g, int i, int j) {\\n    int m = g.size(), n = g[0].size();\\n    if (i == m || j == n || g[i][j] == 0)\\n        return false;\\n    if (i == m - 1 && j == n - 1)\\n        return true;\\n    if (i != 0 || j != 0)\\n        g[i][j] = 0;\\n    return dfs(g, i, j + 1) || dfs(g, i + 1, j);\\n}\\nbool isPossibleToCutPath(vector<vector<int>>& g) {\\n    return !(dfs(g, 0, 0) && dfs(g, 0, 0));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool dfs(vector<vector<int>>& g, int i, int j) {\\n    int m = g.size(), n = g[0].size();\\n    if (i == m || j == n || g[i][j] == 0)\\n        return false;\\n    if (i == m - 1 && j == n - 1)\\n        return true;\\n    if (i != 0 || j != 0)\\n        g[i][j] = 0;\\n    return dfs(g, i, j + 1) || dfs(g, i + 1, j);\\n}\\nbool isPossibleToCutPath(vector<vector<int>>& g) {\\n    return !(dfs(g, 0, 0) && dfs(g, 0, 0));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141502,
                "title": "python-simple-dfs-remember-the-path-and-remove-the-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nGeneral approach is simple: 3 steps\\n\\n#1\\ndo a DFS to reach the end (M-1,N-1) and remember the path.\\n\\n#2\\nRemove the path by setting 0 all the way.\\n\\n#3\\nTry DFS again to see if there is still a connected path.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        M = len(grid)\\n        N = len(grid[0])\\n\\n        #visited set, to not visit the same nodes again\\n        v= set()\\n\\n        dirs=[[0,1],[1,0]]\\n\\n        path = set()\\n        \\n        v.add((0,0))\\n        path.add((0,0))\\n        \\n        def dfs(x,y):\\n            \\n            if x == M -1 and y == N -1:\\n                return True\\n            \\n            for d in dirs:\\n                nx = x + d[0]\\n                ny = y + d[1]\\n                \\n                if nx < M and ny < N and (nx,ny) not in v and grid[nx][ny] == 1:\\n                    v.add((nx,ny))\\n                    path.add((nx,ny))\\n                    if dfs(nx,ny):\\n                        return True\\n                    path.remove((nx,ny))\\n            return False\\n\\n        # 1 do a dfs from (0,0) to (M-1,N-1) \\n        res =  dfs(0,0)\\n        \\n        # if there is no path the it\\'s already disconnectd, return True\\n        if not res:\\n            return True\\n        \\n        # remove the first and last node from the path\\n        if (0,0) in path:\\n            path.remove((0,0))\\n        if (M-1,N-1) in path:\\n            path.remove((M-1,N-1))\\n        \\n        # 2 remove the path from the grid\\n        for p in path:\\n            grid[p[0]][p[1]] = 0\\n        \\n        #reset the visited set\\n        v= set()\\n        v.add((0,0))\\n\\n        # 3 try again DFS, if it\\'s not connected, return True\\n        return not dfs(0,0)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        M = len(grid)\\n        N = len(grid[0])\\n\\n        #visited set, to not visit the same nodes again\\n        v= set()\\n\\n        dirs=[[0,1],[1,0]]\\n\\n        path = set()\\n        \\n        v.add((0,0))\\n        path.add((0,0))\\n        \\n        def dfs(x,y):\\n            \\n            if x == M -1 and y == N -1:\\n                return True\\n            \\n            for d in dirs:\\n                nx = x + d[0]\\n                ny = y + d[1]\\n                \\n                if nx < M and ny < N and (nx,ny) not in v and grid[nx][ny] == 1:\\n                    v.add((nx,ny))\\n                    path.add((nx,ny))\\n                    if dfs(nx,ny):\\n                        return True\\n                    path.remove((nx,ny))\\n            return False\\n\\n        # 1 do a dfs from (0,0) to (M-1,N-1) \\n        res =  dfs(0,0)\\n        \\n        # if there is no path the it\\'s already disconnectd, return True\\n        if not res:\\n            return True\\n        \\n        # remove the first and last node from the path\\n        if (0,0) in path:\\n            path.remove((0,0))\\n        if (M-1,N-1) in path:\\n            path.remove((M-1,N-1))\\n        \\n        # 2 remove the path from the grid\\n        for p in path:\\n            grid[p[0]][p[1]] = 0\\n        \\n        #reset the visited set\\n        v= set()\\n        v.add((0,0))\\n\\n        # 3 try again DFS, if it\\'s not connected, return True\\n        return not dfs(0,0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141935,
                "title": "c-simple-dfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo there can be 3 cases which we are concerned with\\n- No Path (Our answer will be true)\\n- 1 path  (Our answer will be true)\\n- 2 or more than 2 paths (Our answer will be false)\\n\\n**The Intuition is that the path used for DFS once can\\'t be used again**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo a Simple DFS \\n\\nYour starting node is **(0, 0)**\\nYour destination is **(n-1, m-1)**\\n\\n\\n---\\n\\n\\n\\nFor your 1st DFS call if it returns `false` it means no paths exists so your answer is true;\\n\\nIf it returns `true`, there is atleast one path, and this path can\\'t be traversed again as we are setting `grid[i][j]=0;` in our DFS call\\n\\n\\n---\\n\\nNow try for the 2nd DFS call.\\n\\n**REMEMBER:** We call this DFS call only if our previous DFS call returned us True. (Which means we are sure that there is atleast one path)\\n\\nIf the second DFS call returns `false`, it means there are no more paths now. So in total there is only one path. So we return `true`, as we can flip one grid value from `1 to 0`\\n\\n\\n---\\nIf the second DFS call returns `true`, there are more than 1 paths, so we can\\'t help it and return `false`\\n\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int> >& grid,int i, int j, int n, int m)\\n    {\\n        if(i==n-1&&j==m-1)\\n            return true;\\n        \\n        grid[i][j]=0;\\n        \\n        int dc[2] = {0,1};\\n        int dr[2] = {1,0};\\n        \\n        for(int k=0;k<2;k++)\\n        {\\n            int newX = i + dr[k];\\n            int newY = j + dc[k];\\n            \\n            if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1)\\n            {\\n                if (dfs(grid, newX, newY, n, m))\\n                {\\n                    return true;\\n                }\\n                    \\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(dfs(grid,0,0,n,m)==false)\\n        {\\n            return true;\\n        }\\n            \\n        if(dfs(grid,0,0,n,m)==false)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int> >& grid,int i, int j, int n, int m)\\n    {\\n        if(i==n-1&&j==m-1)\\n            return true;\\n        \\n        grid[i][j]=0;\\n        \\n        int dc[2] = {0,1};\\n        int dr[2] = {1,0};\\n        \\n        for(int k=0;k<2;k++)\\n        {\\n            int newX = i + dr[k];\\n            int newY = j + dc[k];\\n            \\n            if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1)\\n            {\\n                if (dfs(grid, newX, newY, n, m))\\n                {\\n                    return true;\\n                }\\n                    \\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(dfs(grid,0,0,n,m)==false)\\n        {\\n            return true;\\n        }\\n            \\n        if(dfs(grid,0,0,n,m)==false)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141930,
                "title": "c-java-python-dp-and-then-count-diagonals",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n1. Immediately it comes to mind that we have no reason to change $0$ to $1$.\\n2. Note that only from left to right or from top to bottom, dynamic programming could be considered at first.\\n2. Using DP we can get the connectivity from $(0,0)$ to $(i,j)$ and from $(i,j)$ to $(m-1,n-1)$, but it\\'s hard to handle the remove operation.\\n3. It seems that all graphs that can be cut off satisfy a property: **all paths must pass through the same point**.\\n4. **Notice that at the same distance on each path, the candidate points are distributed on the same diagonal.**:\\n![image.png](https://assets.leetcode.com/users/images/feb6f411-e47a-4c45-a6f5-d6e1db37de0c_1675530965.8921776.png)\\n    *The 3rd point of each path must be chosen from green points.*\\n    *The 7th point of each path must be chosen from yellow points.*\\n    *The 11th point of each path must be chosen from red points.*\\n\\n5. If you find that there is a distance which has less than two candidate points, this single one will be the removed point, so return true; otherwise if you can\\'t find this point, return false.\\n\\n# Approach\\n1. First, using dynamic programming to get two tables which `vis1[i+1][j+1]` means if there is at least one path from $(0,0)$ to $(i,j)$, and `vis2[i+1][j+1]` means if there is at least one path from $(i,j)$ to $(m-1,n-1)$.\\n2. Count how much points can be occuried on distant $i$, saved in an array `cnt`.\\n3. Find if there has $1$ in `cnt[1:m+n-2]`.\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& a) {\\n        int m = a.size(), n = a[0].size();\\n        vector<int> cnt(m+n, 0);\\n        vector<vector<bool>> vis1(m+2, vector<bool>(n+2, false));\\n        vector<vector<bool>> vis2(m+2, vector<bool>(n+2, false));\\n        vis1[0][1] = true, vis2[m+1][n] = true;\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                vis1[i][j] = a[i-1][j-1] && (vis1[i-1][j] || vis1[i][j-1]);\\n            }\\n        }\\n        for (int i = m; i >= 1; --i) {\\n            for (int j = n; j >= 1; --j) {\\n                vis2[i][j] = a[i-1][j-1] && (vis2[i+1][j] || vis2[i][j+1]);\\n                cnt[i+j-2] += vis1[i][j] && vis2[i][j];\\n            }\\n        }\\n        for (int i = 1; i < m+n-2; ++i) {\\n            if (cnt[i] <= 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] a) {\\n        int m = a.length, n = a[0].length;\\n        boolean [][]vis1 = new boolean[m+2][n+2];\\n        boolean [][]vis2 = new boolean[m+2][n+2];\\n        vis1[0][1] = true;\\n        vis2[m+1][n] = true;\\n        int []cnt = new int[m+n];\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                vis1[i][j] = a[i-1][j-1] == 1 && (vis1[i-1][j] || vis1[i][j-1]);\\n            }\\n        }\\n        for (int i = m; i >= 1; --i) {\\n            for (int j = n; j >= 1; --j) {\\n                vis2[i][j] = a[i-1][j-1] == 1 && (vis2[i+1][j] || vis2[i][j+1]);\\n                if (vis1[i][j] && vis2[i][j]) cnt[i+j-2]++;\\n            }\\n        }\\n        for (int i = 1; i < m+n-2; ++i) {\\n            if (cnt[i] <= 1) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def isPossibleToCutPath(self, a: List[List[int]]) -> bool:\\n        m, n = len(a), len(a[0])\\n        vis1 = [[0 for i in range(n+2)] for j in range(m+2)]\\n        vis2 = [[0 for i in range(n+2)] for j in range(m+2)]\\n        vis1[0][1], vis2[m][n+1] = 1, 1\\n        cnt = [0] * (m+n-1)\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                vis1[i][j] = a[i-1][j-1] and (vis1[i-1][j] or vis1[i][j-1])\\n        for i in range(m, 0, -1):\\n            for j in range(n, 0, -1):\\n                vis2[i][j] = a[i-1][j-1] and (vis2[i+1][j] or vis2[i][j+1])\\n                cnt[i+j-2] += vis1[i][j] and vis2[i][j]\\n        return any(cnt[i] < 2 for i in range(1, n + m - 2))\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& a) {\\n        int m = a.size(), n = a[0].size();\\n        vector<int> cnt(m+n, 0);\\n        vector<vector<bool>> vis1(m+2, vector<bool>(n+2, false));\\n        vector<vector<bool>> vis2(m+2, vector<bool>(n+2, false));\\n        vis1[0][1] = true, vis2[m+1][n] = true;\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                vis1[i][j] = a[i-1][j-1] && (vis1[i-1][j] || vis1[i][j-1]);\\n            }\\n        }\\n        for (int i = m; i >= 1; --i) {\\n            for (int j = n; j >= 1; --j) {\\n                vis2[i][j] = a[i-1][j-1] && (vis2[i+1][j] || vis2[i][j+1]);\\n                cnt[i+j-2] += vis1[i][j] && vis2[i][j];\\n            }\\n        }\\n        for (int i = 1; i < m+n-2; ++i) {\\n            if (cnt[i] <= 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] a) {\\n        int m = a.length, n = a[0].length;\\n        boolean [][]vis1 = new boolean[m+2][n+2];\\n        boolean [][]vis2 = new boolean[m+2][n+2];\\n        vis1[0][1] = true;\\n        vis2[m+1][n] = true;\\n        int []cnt = new int[m+n];\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                vis1[i][j] = a[i-1][j-1] == 1 && (vis1[i-1][j] || vis1[i][j-1]);\\n            }\\n        }\\n        for (int i = m; i >= 1; --i) {\\n            for (int j = n; j >= 1; --j) {\\n                vis2[i][j] = a[i-1][j-1] == 1 && (vis2[i+1][j] || vis2[i][j+1]);\\n                if (vis1[i][j] && vis2[i][j]) cnt[i+j-2]++;\\n            }\\n        }\\n        for (int i = 1; i < m+n-2; ++i) {\\n            if (cnt[i] <= 1) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def isPossibleToCutPath(self, a: List[List[int]]) -> bool:\\n        m, n = len(a), len(a[0])\\n        vis1 = [[0 for i in range(n+2)] for j in range(m+2)]\\n        vis2 = [[0 for i in range(n+2)] for j in range(m+2)]\\n        vis1[0][1], vis2[m][n+1] = 1, 1\\n        cnt = [0] * (m+n-1)\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                vis1[i][j] = a[i-1][j-1] and (vis1[i-1][j] or vis1[i][j-1])\\n        for i in range(m, 0, -1):\\n            for j in range(n, 0, -1):\\n                vis2[i][j] = a[i-1][j-1] and (vis2[i+1][j] or vis2[i][j+1])\\n                cnt[i+j-2] += vis1[i][j] and vis2[i][j]\\n        return any(cnt[i] < 2 for i in range(1, n + m - 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141843,
                "title": "easy-c-solution-comparing-diagonals-only",
                "content": "# Intuition\\nThe idea is that if there is any diagonal in the matrix with all elements equal to zero, then there is no way to reach the last element.\\n\\nhere we will traverse the matrix diagonaly as shown in the picture below except for the last and first diagnonal cuz we can not do any operation on them: \\n![image.png](https://assets.leetcode.com/users/images/51a118c2-f18a-40cb-975f-fe19c7d84dd5_1675529465.5164602.png)\\n\\n\\n# Complexity\\n- Time complexity:$$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        const int m = size(grid);\\n        const int n = size(grid[0]);\\n        // check if we can reach the first row elements\\n        for (int i = 1; i < m; ++i)\\n            grid[i][0] &= grid[i - 1][0];\\n        // check if we can reach the first column elements\\n        for (int i = 1; i < n; ++i)\\n            grid[0][i] &= grid[0][i - 1];\\n        // check for how long each element can reach\\n        for (int i = 0; i < m-1; ++i)\\n            for (int j = 0; j < n-1; ++j)\\n                grid[i][j] &= grid[i + 1][j] | grid[i][j + 1];\\n        // checking for the parent of each element to see whether this element is reachable or not\\n        for (int i = 1; i < m; ++i)\\n            for (int j = 1; j < n; ++j)\\n                grid[i][j] &= grid[i - 1][j] | grid[i][j - 1];\\n        \\n        // starting from 2 to skip the first diagonal.\\n        // iteration will stop before reaching the final diagonal.\\n        for (int line = 2; line <= (m + n - 2); ++line) {\\n            int start_col =  max(0, line - m);\\n            int count = min({line, (n - start_col), m});\\n            int check = 0;\\n            for (int j = 0; j < count; ++j) {\\n                check += grid[min(m, line) - j - 1][start_col + j];\\n            }\\n            if (check < 2)  // zero or one are valid cuz we have one operation to apply\\n                return true;\\n        }\\n        // check if we cannot reach the final cell\\n        return grid[m - 1][n - 1] == 0 || grid[0][0] == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        const int m = size(grid);\\n        const int n = size(grid[0]);\\n        // check if we can reach the first row elements\\n        for (int i = 1; i < m; ++i)\\n            grid[i][0] &= grid[i - 1][0];\\n        // check if we can reach the first column elements\\n        for (int i = 1; i < n; ++i)\\n            grid[0][i] &= grid[0][i - 1];\\n        // check for how long each element can reach\\n        for (int i = 0; i < m-1; ++i)\\n            for (int j = 0; j < n-1; ++j)\\n                grid[i][j] &= grid[i + 1][j] | grid[i][j + 1];\\n        // checking for the parent of each element to see whether this element is reachable or not\\n        for (int i = 1; i < m; ++i)\\n            for (int j = 1; j < n; ++j)\\n                grid[i][j] &= grid[i - 1][j] | grid[i][j - 1];\\n        \\n        // starting from 2 to skip the first diagonal.\\n        // iteration will stop before reaching the final diagonal.\\n        for (int line = 2; line <= (m + n - 2); ++line) {\\n            int start_col =  max(0, line - m);\\n            int count = min({line, (n - start_col), m});\\n            int check = 0;\\n            for (int j = 0; j < count; ++j) {\\n                check += grid[min(m, line) - j - 1][start_col + j];\\n            }\\n            if (check < 2)  // zero or one are valid cuz we have one operation to apply\\n                return true;\\n        }\\n        // check if we cannot reach the final cell\\n        return grid[m - 1][n - 1] == 0 || grid[0][0] == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143039,
                "title": "java-dfs-very-detailed-explanation",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\nFirst we will check if we are able to reach our final position at all by callng a DFS. There can be multiple paths, and while going through a path, we will flip every `1` to `0` to make the path unusable. If we can\\'t reach the end point, we return `true` directly because the matrix is already disconnected. \\n\\nBut if we reach the end point, the situation would be concerning. \\nNow the way DFS works, it\\'ll go through each path one by one and try to reach the end point. If it can\\'t reach the end point by going through a path (say by going to (`i + 1, j`)), it\\'ll try the next path (`i, j + 1`). Now right when it reaches the end point it\\'ll return true right away which means it\\'ll not go through any other possible paths.\\n\\nWe know while moving through paths, we have made the paths unusable by setting `0`s. So as soon as we reach the end point, the path used reach it would be all set to `0` but not the next possible path because it did\\'t get a chance to explore (because we returned true as soon as we reached the end point). So that means that we have found only **ONE** possible path that can lead us to the end point and we have wiped that path out of existence.\\n\\nNow what our question says is, we can only make **one** flip.\\nThis one flip can be made at such a point through which multiple paths pass. If that point is flipped to a `0`, all other potential paths passing through that point would be broken hence we won\\'t be able to reach the end point.\\n\\nAs we know, the DFS would return a true from the first path itself, and it would also set that specific point to `0` as well.\\n\\nNow when we would run the DFS again, it\\'ll try to move through the other available paths and if anyhow it\\'s able to reach the end point, means there exists another such special point (or atleast a single path) that can reach the destination, which means our matrix is not possible to be disconnected, because we cannot make two flips at two different places.\\n\\n---\\n![image.png](https://assets.leetcode.com/users/images/54c7db7a-941d-43a0-b131-b2eb468d34ac_1675547370.756396.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/166c199c-9fef-46ce-be99-402c00a37726_1675549939.0630946.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/a7ddbabf-bc88-4c13-aae6-d5682b4fb3b2_1675548806.1801443.png)\\n\\n---\\n\\n### Code:\\n``` java []\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        // check if path exists\\n        if (!isReachable(grid, 0, 0)) {\\n            return true;    // if not, return true\\n        }\\n\\n        // we have set the first path that the DFS travelled to all 0s\\n        grid[0][0] = 1; // starting point needs to be a 1\\n        // check if any more paths exists or not\\n        if (!isReachable(grid, 0, 0)) {\\n            return true;    // if not, return true\\n        }\\n        \\n        // otherwise we have learned, 1 flip isn\\'t sufficient\\n        // so matrix can\\'t be disconnected\\n        return false;\\n    }\\n\\n    private boolean isReachable(int[][] grid, int i, int j) {\\n        // end point is last cell of last row and column\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            return true;    // reached the end point, return true\\n        }\\n        // moved out of bounds, or encountered a 0 means path is blocked\\n        if (i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return false;   // con\\'t move so return false\\n        }\\n        grid[i][j] = 0; // block the path\\n        // move down, move right, Either or both can reach the end point\\n        return isReachable(grid, i + 1, j) || isReachable(grid, i, j + 1);\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if (!isReachable(grid, 0, 0)) {\\n            return true;   \\n        }\\n        grid[0][0] = 1; \\n        if (!isReachable(grid, 0, 0)) {\\n            return true; \\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean isReachable(int[][] grid, int i, int j) {\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            return true;    \\n        }\\n        if (i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return false;   \\n        }\\n        grid[i][j] = 0;\\n        return isReachable(grid, i + 1, j) || isReachable(grid, i, j + 1);\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(m * n)$$\\n### Space complexity: $$O(m * n)$$",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        // check if path exists\\n        if (!isReachable(grid, 0, 0)) {\\n            return true;    // if not, return true\\n        }\\n\\n        // we have set the first path that the DFS travelled to all 0s\\n        grid[0][0] = 1; // starting point needs to be a 1\\n        // check if any more paths exists or not\\n        if (!isReachable(grid, 0, 0)) {\\n            return true;    // if not, return true\\n        }\\n        \\n        // otherwise we have learned, 1 flip isn\\'t sufficient\\n        // so matrix can\\'t be disconnected\\n        return false;\\n    }\\n\\n    private boolean isReachable(int[][] grid, int i, int j) {\\n        // end point is last cell of last row and column\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            return true;    // reached the end point, return true\\n        }\\n        // moved out of bounds, or encountered a 0 means path is blocked\\n        if (i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return false;   // con\\'t move so return false\\n        }\\n        grid[i][j] = 0; // block the path\\n        // move down, move right, Either or both can reach the end point\\n        return isReachable(grid, i + 1, j) || isReachable(grid, i, j + 1);\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if (!isReachable(grid, 0, 0)) {\\n            return true;   \\n        }\\n        grid[0][0] = 1; \\n        if (!isReachable(grid, 0, 0)) {\\n            return true; \\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean isReachable(int[][] grid, int i, int j) {\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            return true;    \\n        }\\n        if (i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return false;   \\n        }\\n        grid[i][j] = 0;\\n        return isReachable(grid, i + 1, j) || isReachable(grid, i, j + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142387,
                "title": "c-easiest-explanation-with-comments-tc-o-m-n",
                "content": "# Intuition\\nThe idea is to Traverse Using Level Order Traversal .i.e. we will be standing on one or more cell simultaneously . We will use Queue for it.\\n\\n# Approach\\nWe start from (0,0) and then move to to each possible next cell and mark them 0 (visited) , so that we dont reach same cell twice .\\n\\nNow We May come across three cases -->\\nCase 1 :\\nIf we are standing at a single cell only and it is neither of starting cell nor ending cell then we return true as we can flip that cell to disconnect the path.\\n\\nCase 2 :\\nWe can\\'t move ahead . Then Path is already disconnected thus we return true.\\n\\nCase 3 :\\nIf we reach to endpoint , then we were not able able to disconnect the path . So return false.\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n\\nHope you understood it well, Upvotes are always appreciated !!\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        //For Cases Like:\\n        // [[1]] , [[1,1]]  ,  [[1],[1]] \\n        if((m == 1 && n == 1) || (m == 1 && n == 2) || (m == 2 && n == 1) )\\n            return false;\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0,0});\\n\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n\\n            // Check If we are standing only at a single cell or not   \\n            if(s == 1)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                \\n            // When You are standing only at one cell \\n            //and this cell is neither your starting point and nor an ending point \\n            //Then this will definitely be your that cell \\n            //which you can delete to disconnect path \\n                if( !((x == 0 && y == 0) || (x == m-1 && y == n-1) ) )\\n                    return true;\\n            }\\n            \\n            \\n            for(int  i = 0 ; i<s; i++)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                if(x == m-1 && y == n-1)\\n                {\\n                    // If you are at ending point then \\n                    // You were not able to delete any cell to disconnect path \\n                    //Thus return false\\n                    return false;\\n                }\\n                \\n                if(x+1<m && grid[x+1][y])\\n                {\\n                    grid[x+1][y] = 0;\\n\\n                    //Queue next cell\\n                    q.push({x+1,y});\\n                }\\n                \\n                if(y+1<n && grid[x][y+1])\\n                {\\n                    grid[x][y+1] = 0;\\n                    \\n                    //Queue next cell\\n                    q.push({x,y+1});\\n\\n                }\\n            }\\n        }\\n        \\n\\n        // If You came out of Loop that means\\n        // path was alredy disconnected thus return true\\n        return true;\\n        \\n     \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        //For Cases Like:\\n        // [[1]] , [[1,1]]  ,  [[1],[1]] \\n        if((m == 1 && n == 1) || (m == 1 && n == 2) || (m == 2 && n == 1) )\\n            return false;\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0,0});\\n\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n\\n            // Check If we are standing only at a single cell or not   \\n            if(s == 1)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                \\n            // When You are standing only at one cell \\n            //and this cell is neither your starting point and nor an ending point \\n            //Then this will definitely be your that cell \\n            //which you can delete to disconnect path \\n                if( !((x == 0 && y == 0) || (x == m-1 && y == n-1) ) )\\n                    return true;\\n            }\\n            \\n            \\n            for(int  i = 0 ; i<s; i++)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                if(x == m-1 && y == n-1)\\n                {\\n                    // If you are at ending point then \\n                    // You were not able to delete any cell to disconnect path \\n                    //Thus return false\\n                    return false;\\n                }\\n                \\n                if(x+1<m && grid[x+1][y])\\n                {\\n                    grid[x+1][y] = 0;\\n\\n                    //Queue next cell\\n                    q.push({x+1,y});\\n                }\\n                \\n                if(y+1<n && grid[x][y+1])\\n                {\\n                    grid[x][y+1] = 0;\\n                    \\n                    //Queue next cell\\n                    q.push({x,y+1});\\n\\n                }\\n            }\\n        }\\n        \\n\\n        // If You came out of Loop that means\\n        // path was alredy disconnected thus return true\\n        return true;\\n        \\n     \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141457,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n* Let `a[i][j]` denote the count of ways to reach each cell `i`,`j` of the input matrix `A` from `0`,`0` \\uD83D\\uDC49 `M - 1`,`N - 1`\\n\\t* ie. this is the number of paths from `0`,`0` to `i`,`j` (computed from top-left to bottom-right)\\n* Let `b[i][j]` denote the count of ways to reach each cell `i`,`j` of the input matrix `A` from `M - 1`,`N - 1` \\uD83D\\uDC49 `0`,`0`\\n\\t* ie. this is the number of paths from `i`,`j` to `M - 1`,`N - 1` (computed from bottom-right to top-left)\\n\\nReturn `true` if-and-only-if there exists any `i`,`j` cell (other than `0`,`0` and `M - 1`,`N - 1`) where `a[i][j] * b[i][j] == a[M - 1][N - 1]`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun isPossibleToCutPath(A: Array<IntArray>): Boolean {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var a = Array(M) { IntArray(N) { 0 } }\\n        a[0][0] = 1\\n        for (i in 0 until M)\\n            for (j in 0 until N)\\n                a[i][j] += if (A[i][j] == 1) { (if (0 <= i - 1) a[i - 1][j] else 0) + (if (0 <= j - 1) a[i][j - 1] else 0) } else { 0 }\\n        var b = Array(M) { IntArray(N) { 0 } }\\n        b[M - 1][N - 1] = 1\\n        for (i in M - 1 downTo 0)\\n            for (j in N - 1 downTo 0)\\n                b[i][j] += if (A[i][j] == 1) { (if (i + 1 < M) b[i + 1][j] else 0) + (if (j + 1 < N) b[i][j + 1] else 0) } else { 0 }\\n        return (0 until M).any{ i -> (0 until N).any{ j -> !(i == 0 && j == 0) && !(i == M - 1 && j == N - 1) && a[i][j] * b[i][j] == a[M - 1][N - 1] } }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet isPossibleToCutPath = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let a = [...Array(M)].map(_ => Array(N).fill(0));\\n    a[0][0] = 1;\\n    for (let i = 0; i < M; ++i)\\n        for (let j = 0; j < N; ++j)\\n            a[i][j] += !A[i][j] ? 0 : ((0 <= i - 1 ? a[i - 1][j] : 0) + (0 <= j - 1 ? a[i][j - 1] : 0));\\n    let b = [...Array(M)].map(_ => Array(N).fill(0));\\n    b[M - 1][N - 1] = 1;\\n    for (let i = M - 1; 0 <= i; --i)\\n        for (let j = N - 1; 0 <= j; --j)\\n            b[i][j] += !A[i][j] ? 0 : ((i + 1 < M ? b[i + 1][j] : 0) + (j + 1 < N ? b[i][j + 1] : 0));\\n    return [...Array(M).keys()].some(i => [...Array(N).keys()].some(j => !(i == 0 && j == 0) && !(i == M - 1 && j == N - 1) && a[i][j] * b[i][j] == a[M - 1][N - 1]));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, A: List[List[int]]) -> bool:\\n        M, N = len(A), len(A[0])\\n        a = [[0] * N for _ in range(M)]\\n        a[0][0] = 1\\n        for i in range(M):\\n            for j in range(N):\\n                a[i][j] += ((a[i - 1][j] if 0 <= i - 1 else 0) + (a[i][j - 1] if 0 <= j - 1 else 0)) if A[i][j] else 0\\n        b = [[0] * N for _ in range(M)]\\n        b[M - 1][N - 1] = 1\\n        for i in range(M - 1, -1, -1):\\n            for j in range(N - 1, -1, -1):\\n                b[i][j] += ((b[i + 1][j] if i + 1 < M else 0) + (b[i][j + 1] if j + 1 < N else 0)) if A[i][j] else 0\\n        return any(not (i == 0 and j == 0) and not (i == M - 1 and j == N - 1) and a[i][j] * b[i][j] == a[M - 1][N - 1] for j in range(N) for i in range(M))\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn is_possible_to_cut_path(A: Vec<Vec<i32>>) -> bool {\\n        let (M, N) = (A.len(), A[0].len());\\n        let mut a = vec![vec![0; N]; M];\\n        a[0][0] = 1;\\n        for i in 0..M {\\n            for j in 0..N {\\n                a[i][j] += if A[i][j] == 1 { (if 0 < i { a[i - 1][j] } else { 0 }) + (if 0 < j { a[i][j - 1] } else { 0 }) } else { 0 };\\n            }\\n        }\\n        let mut b = vec![vec![0; N]; M];\\n        b[M - 1][N - 1] = 1;\\n        for i in (0..M).rev() {\\n            for j in (0..N).rev() {\\n                b[i][j] += if A[i][j] == 1 { (if i + 1 < M { b[i + 1][j] } else { 0 }) + (if j + 1 < N { b[i][j + 1] } else { 0 }) } else { 0 };\\n            }\\n        }\\n        (0..M).any(|i| (0..N).any(|j| !(i == 0 && j == 0) && !(i == M - 1 && j == N - 1) && a[i][j] * b[i][j] == a[M - 1][N - 1]))\\n    }\\n}\\n```\\n\\n*C++ (note: this solution results in integer overflow, its strange that doesn\\'t occur in the other languages [not including Python3])*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool isPossibleToCutPath(VVI& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVI a(M, VI(N));\\n        a[0][0] = 1;\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                a[i][j] += A[i][j] ? ((0 <= i - 1 ? a[i - 1][j] : 0) + (0 <= j - 1 ? a[i][j - 1] : 0)) : 0;\\n        VVI b(M, VI(N));\\n        b[M - 1][N - 1] = 1;\\n        for (auto i{ M - 1 }; 0 <= i; --i)\\n            for (auto j{ N - 1 }; 0 <= j; --j)\\n                b[i][j] += A[i][j] ? ((i + 1 < M ? b[i + 1][j] : 0) + (j + 1 < N ? b[i][j + 1] : 0)) : 0;\\n        return any_of(A.begin(), A.end(), [i = -1, &a, &b, &A, M, N](auto& _) mutable {\\n            ++i; return any_of(A[0].begin(), A[0].end(), [i, j = -1, &a, &b, M, N](auto& _) mutable {\\n                ++j; return !(i == 0 && j == 0) && !(i == M - 1 && j == N - 1) && a[i][j] * b[i][j] == a[M - 1][N - 1];\\n            });\\n        });\\n    }\\n};\\n```\\n\\n---\\n\\n**DFS Solutions:** we can perform DFS + BT to \"remove\" valid paths from `0`,`0` \\uD83D\\uDC49 `M - 1`,`N - 1`\\n* Return `true` if-and-only-if we *cannot* reach `M - 1`, `N - 1` on the first inclusive-or second traversal.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun isPossibleToCutPath(A: Array<IntArray>): Boolean {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var key = { i: Int, j: Int -> \"$i,$j\" }\\n        fun go(i: Int = 0, j: Int = 0, seen: MutableSet<String> = mutableSetOf<String>()): Boolean {\\n            if (i == M - 1 && j == N - 1)\\n                return true\\n            var k = key(i, j)\\n            if (i < 0 || i == M || j < 0 || j == N || A[i][j] == 0 || seen.contains(k))\\n                return false\\n            seen.add(k)\\n            A[i][j] = if (0 < i + j) 0 else 1\\n            for ((u, v) in listOf(Pair(i + 1, j), Pair(i, j + 1)))\\n                if (go(u, v, seen))\\n                    return true\\n            A[i][j] = 1\\n            return false\\n        }\\n        return !go() || !go()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet isPossibleToCutPath = (A, found = false) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let key = (i, j) => `${i},${j}`;\\n    let go = (i = 0, j = 0, seen = new Set()) => {\\n        if (i == M - 1 && j == N - 1)\\n            return true;\\n        let k = key(i, j);\\n        if (i < 0 || i == M || j < 0 || j == N || !A[i][j] || seen.has(k))\\n            return false;\\n        seen.add(k);\\n        A[i][j] = i | j ? 0 : 1;\\n        for (let [u, v] of [[i + 1, j], [i, j + 1]])\\n            if (go(u, v, seen))\\n                return true;\\n        A[i][j] = 1;\\n        return false;\\n    };\\n    return !go() || !go();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, A: List[List[int]]) -> bool:\\n        M, N = len(A), len(A[0])\\n        def go(i, j, seen):\\n            if i == M - 1 and j == N - 1:\\n                return True\\n            if i < 0 or i == M or j < 0 or j == N or (i, j) in seen or not A[i][j]:\\n                return False\\n            seen.add((i, j))\\n            A[i][j] = 0 if i or j else 1\\n            for u, v in [(i + 1, j), (i, j + 1)]:\\n                if go(u, v, seen):\\n                    return True\\n            A[i][j] = 1\\n            return False\\n        return not go(0, 0, set()) or not go(0, 0, set())\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Seen = unordered_map<int, unordered_map<int, bool>>;\\n    using fun = function<bool(int, int, Seen&&)>;\\n    bool isPossibleToCutPath(VVI& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j, auto&& seen) {\\n            if (i == M - 1 && j == N - 1)\\n                return true;\\n            if (i < 0 || i == M || j < 0 || j == N || !A[i][j] || seen[i][j])\\n                return false;\\n            seen[i][j] = true;\\n            A[i][j] = i | j ? 0 : 1;\\n            for (auto [u, v]: {make_pair(i + 1, j), make_pair(i, j + 1)})\\n                if (go(u, v, move(seen)))\\n                    return true;\\n            A[i][j] = 1;\\n            return false;\\n        };\\n        return !go(0, 0, {}) || !go(0, 0, {});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun isPossibleToCutPath(A: Array<IntArray>): Boolean {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var a = Array(M) { IntArray(N) { 0 } }\\n        a[0][0] = 1\\n        for (i in 0 until M)\\n            for (j in 0 until N)\\n                a[i][j] += if (A[i][j] == 1) { (if (0 <= i - 1) a[i - 1][j] else 0) + (if (0 <= j - 1) a[i][j - 1] else 0) } else { 0 }\\n        var b = Array(M) { IntArray(N) { 0 } }\\n        b[M - 1][N - 1] = 1\\n        for (i in M - 1 downTo 0)\\n            for (j in N - 1 downTo 0)\\n                b[i][j] += if (A[i][j] == 1) { (if (i + 1 < M) b[i + 1][j] else 0) + (if (j + 1 < N) b[i][j + 1] else 0) } else { 0 }\\n        return (0 until M).any{ i -> (0 until N).any{ j -> !(i == 0 && j == 0) && !(i == M - 1 && j == N - 1) && a[i][j] * b[i][j] == a[M - 1][N - 1] } }\\n    }\\n}\\n```\n```\\nlet isPossibleToCutPath = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let a = [...Array(M)].map(_ => Array(N).fill(0));\\n    a[0][0] = 1;\\n    for (let i = 0; i < M; ++i)\\n        for (let j = 0; j < N; ++j)\\n            a[i][j] += !A[i][j] ? 0 : ((0 <= i - 1 ? a[i - 1][j] : 0) + (0 <= j - 1 ? a[i][j - 1] : 0));\\n    let b = [...Array(M)].map(_ => Array(N).fill(0));\\n    b[M - 1][N - 1] = 1;\\n    for (let i = M - 1; 0 <= i; --i)\\n        for (let j = N - 1; 0 <= j; --j)\\n            b[i][j] += !A[i][j] ? 0 : ((i + 1 < M ? b[i + 1][j] : 0) + (j + 1 < N ? b[i][j + 1] : 0));\\n    return [...Array(M).keys()].some(i => [...Array(N).keys()].some(j => !(i == 0 && j == 0) && !(i == M - 1 && j == N - 1) && a[i][j] * b[i][j] == a[M - 1][N - 1]));\\n};\\n```\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, A: List[List[int]]) -> bool:\\n        M, N = len(A), len(A[0])\\n        a = [[0] * N for _ in range(M)]\\n        a[0][0] = 1\\n        for i in range(M):\\n            for j in range(N):\\n                a[i][j] += ((a[i - 1][j] if 0 <= i - 1 else 0) + (a[i][j - 1] if 0 <= j - 1 else 0)) if A[i][j] else 0\\n        b = [[0] * N for _ in range(M)]\\n        b[M - 1][N - 1] = 1\\n        for i in range(M - 1, -1, -1):\\n            for j in range(N - 1, -1, -1):\\n                b[i][j] += ((b[i + 1][j] if i + 1 < M else 0) + (b[i][j + 1] if j + 1 < N else 0)) if A[i][j] else 0\\n        return any(not (i == 0 and j == 0) and not (i == M - 1 and j == N - 1) and a[i][j] * b[i][j] == a[M - 1][N - 1] for j in range(N) for i in range(M))\\n```\n```\\nimpl Solution {\\n    pub fn is_possible_to_cut_path(A: Vec<Vec<i32>>) -> bool {\\n        let (M, N) = (A.len(), A[0].len());\\n        let mut a = vec![vec![0; N]; M];\\n        a[0][0] = 1;\\n        for i in 0..M {\\n            for j in 0..N {\\n                a[i][j] += if A[i][j] == 1 { (if 0 < i { a[i - 1][j] } else { 0 }) + (if 0 < j { a[i][j - 1] } else { 0 }) } else { 0 };\\n            }\\n        }\\n        let mut b = vec![vec![0; N]; M];\\n        b[M - 1][N - 1] = 1;\\n        for i in (0..M).rev() {\\n            for j in (0..N).rev() {\\n                b[i][j] += if A[i][j] == 1 { (if i + 1 < M { b[i + 1][j] } else { 0 }) + (if j + 1 < N { b[i][j + 1] } else { 0 }) } else { 0 };\\n            }\\n        }\\n        (0..M).any(|i| (0..N).any(|j| !(i == 0 && j == 0) && !(i == M - 1 && j == N - 1) && a[i][j] * b[i][j] == a[M - 1][N - 1]))\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool isPossibleToCutPath(VVI& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVI a(M, VI(N));\\n        a[0][0] = 1;\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                a[i][j] += A[i][j] ? ((0 <= i - 1 ? a[i - 1][j] : 0) + (0 <= j - 1 ? a[i][j - 1] : 0)) : 0;\\n        VVI b(M, VI(N));\\n        b[M - 1][N - 1] = 1;\\n        for (auto i{ M - 1 }; 0 <= i; --i)\\n            for (auto j{ N - 1 }; 0 <= j; --j)\\n                b[i][j] += A[i][j] ? ((i + 1 < M ? b[i + 1][j] : 0) + (j + 1 < N ? b[i][j + 1] : 0)) : 0;\\n        return any_of(A.begin(), A.end(), [i = -1, &a, &b, &A, M, N](auto& _) mutable {\\n            ++i; return any_of(A[0].begin(), A[0].end(), [i, j = -1, &a, &b, M, N](auto& _) mutable {\\n                ++j; return !(i == 0 && j == 0) && !(i == M - 1 && j == N - 1) && a[i][j] * b[i][j] == a[M - 1][N - 1];\\n            });\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun isPossibleToCutPath(A: Array<IntArray>): Boolean {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var key = { i: Int, j: Int -> \"$i,$j\" }\\n        fun go(i: Int = 0, j: Int = 0, seen: MutableSet<String> = mutableSetOf<String>()): Boolean {\\n            if (i == M - 1 && j == N - 1)\\n                return true\\n            var k = key(i, j)\\n            if (i < 0 || i == M || j < 0 || j == N || A[i][j] == 0 || seen.contains(k))\\n                return false\\n            seen.add(k)\\n            A[i][j] = if (0 < i + j) 0 else 1\\n            for ((u, v) in listOf(Pair(i + 1, j), Pair(i, j + 1)))\\n                if (go(u, v, seen))\\n                    return true\\n            A[i][j] = 1\\n            return false\\n        }\\n        return !go() || !go()\\n    }\\n}\\n```\n```\\nlet isPossibleToCutPath = (A, found = false) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let key = (i, j) => `${i},${j}`;\\n    let go = (i = 0, j = 0, seen = new Set()) => {\\n        if (i == M - 1 && j == N - 1)\\n            return true;\\n        let k = key(i, j);\\n        if (i < 0 || i == M || j < 0 || j == N || !A[i][j] || seen.has(k))\\n            return false;\\n        seen.add(k);\\n        A[i][j] = i | j ? 0 : 1;\\n        for (let [u, v] of [[i + 1, j], [i, j + 1]])\\n            if (go(u, v, seen))\\n                return true;\\n        A[i][j] = 1;\\n        return false;\\n    };\\n    return !go() || !go();\\n};\\n```\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, A: List[List[int]]) -> bool:\\n        M, N = len(A), len(A[0])\\n        def go(i, j, seen):\\n            if i == M - 1 and j == N - 1:\\n                return True\\n            if i < 0 or i == M or j < 0 or j == N or (i, j) in seen or not A[i][j]:\\n                return False\\n            seen.add((i, j))\\n            A[i][j] = 0 if i or j else 1\\n            for u, v in [(i + 1, j), (i, j + 1)]:\\n                if go(u, v, seen):\\n                    return True\\n            A[i][j] = 1\\n            return False\\n        return not go(0, 0, set()) or not go(0, 0, set())\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Seen = unordered_map<int, unordered_map<int, bool>>;\\n    using fun = function<bool(int, int, Seen&&)>;\\n    bool isPossibleToCutPath(VVI& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j, auto&& seen) {\\n            if (i == M - 1 && j == N - 1)\\n                return true;\\n            if (i < 0 || i == M || j < 0 || j == N || !A[i][j] || seen[i][j])\\n                return false;\\n            seen[i][j] = true;\\n            A[i][j] = i | j ? 0 : 1;\\n            for (auto [u, v]: {make_pair(i + 1, j), make_pair(i, j + 1)})\\n                if (go(u, v, move(seen)))\\n                    return true;\\n            A[i][j] = 1;\\n            return false;\\n        };\\n        return !go(0, 0, {}) || !go(0, 0, {});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146474,
                "title": "explained-m-n-dfs-javascript-solution",
                "content": "# Intuition\\nTo make the grid disconnect in one removal there should be a cell in a grid that belongs to every path from (0,0) to (N - 1, M - 1). In this case, setting this cell to 0 will break every path.\\n# Approach\\nWe can try to build some path from (0, 0) to (N-1, M-1). We can use DFS to do that. If we are not able to build the path - the matrix is already disconnected. If we were able to build some path, we remove it from the matrix by setting every cell of the path, except ends, to 0. Following our intuition, if the was a cell in a grid that belongs to every path it also belongs to the found path, so if we will set it to 0 the matrix should become disconnected. After removal, we try to build the new path from (0, 0) to (N-1, M-1). If the path is found the grid could not be made disconnected in one removal. If not it could.\\n\\n# Complexity\\n- Time complexity:\\nO(M * N) \\u2014 in worst case we will visit almost all the grid cells during the DFS. It is not obvious for this case as we can only move right and down in the problem. It could feel like it should be O(m + n) but let look to the following example:\\n![image.png](https://assets.leetcode.com/users/images/38616411-5043-4a6a-a324-278b2fb0c06f_1675630481.4521303.png)\\nIn this case the DFS will spread like this:\\n![image.png](https://assets.leetcode.com/users/images/7e708d53-1185-4375-8deb-b3dba7a23565_1675630499.99471.png)\\nWe will have to visit > (n*m /2) cels which is equal to O(n*m) complexity.\\n\\n\\n- Space complexity:\\nO (M*N) - we need to store all the visited previously cells during the DFS.\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\n\\nvar isPossibleToCutPath = function(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length\\n    \\n    // We will store visited cels in set\\n    let set = new Set();\\n    // Add start point to visited.\\n    set.add(`0_0`);\\n    // Add start point to path.\\n    let path = [[0,0]];\\n    // Possible move directiond down and right.\\n    let moves = [[0,1], [1,0]];\\n    \\n    // DFS implementation\\n    let dfs = (i, j) => {\\n        if(i === n-1 && j === m - 1) {\\n            // We reached bottom right corner - matrix connected.\\n            return true;\\n        }\\n        \\n        // Generate possible moves from current point\\n        for (let move of moves) {\\n            let ni = i + move[0];\\n            let nj = j + move[1];\\n            let key = `${ni}_${nj}`\\n            // Next move should be inside the grid bounds\\n            // Next move value should be 1. We can only move by 1 cells.\\n            if( ni < n && nj < m && !set.has(key) && grid[ni][nj] === 1) {\\n                // Remember next move to not visit it twice.\\n                set.add(key);\\n                // Add next move to path\\n                path.push([ni, nj])\\n                // Run DFS for next move.\\n                if(dfs(ni, nj)){\\n                    // If one of next moves reached the (n-1, m-1) the matrix is connected\\n                    return true;\\n                }\\n                // Current cell is not part of any path. Remove it from path.\\n                path.pop();\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    // Run DFS\\n    if(!dfs(0, 0)){\\n        // Initial matrix is already disconnected\\n        return true;\\n    }\\n    \\n    // Matrix is connected. We have some path.\\n    path.shift(); // remove [0, 0]\\n    path.pop(); // remove [n-1, m-1]\\n    \\n    // Set every cell of found path to 0\\n    for (let p of path) {\\n        grid[p[0]][p[1]] = 0;\\n    }\\n    \\n    // Run DFS for updated matrix once again.\\n    set = new Set();\\n    set.add(`0_0`);\\n    return !dfs(0, 0);\\n};\\n\\n```\\n\\n# Improved Solution\\nWe can avoid memorize visited cells in separate structure. We can update them in place in grid by setting it value to 0. (Improvement was inspired by [this](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3149979/clear-dfs-javascript-solution-without-additional-memory/) solution)\\n\\n# Improved Code\\n```\\nvar isPossibleToCutPath = function(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length\\n    let moves = [[0,1], [1,0]];\\n    let dfs = (i, j) => {\\n        if(i === n-1 && j === m - 1) {\\n            return true;\\n        }\\n        \\n        for (let move of moves) {\\n            let ni = i + move[0];\\n            let nj = j + move[1];\\n            if( ni < n && nj < m && grid[ni][nj] === 1) {\\n                grid[ni][nj] = 0;\\n                if(dfs(ni, nj)){\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    if(!dfs(0, 0)){\\n        return true;\\n    }\\n    grid[n-1][m-1] = 1;\\n    return !dfs(0, 0);\\n};\\n```\\n# Improved complexity\\n- Time complexity still O(N * M)\\n- Space complexity O(N + M) - the size of call stack to find path in grid.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\n\\nvar isPossibleToCutPath = function(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length\\n    \\n    // We will store visited cels in set\\n    let set = new Set();\\n    // Add start point to visited.\\n    set.add(`0_0`);\\n    // Add start point to path.\\n    let path = [[0,0]];\\n    // Possible move directiond down and right.\\n    let moves = [[0,1], [1,0]];\\n    \\n    // DFS implementation\\n    let dfs = (i, j) => {\\n        if(i === n-1 && j === m - 1) {\\n            // We reached bottom right corner - matrix connected.\\n            return true;\\n        }\\n        \\n        // Generate possible moves from current point\\n        for (let move of moves) {\\n            let ni = i + move[0];\\n            let nj = j + move[1];\\n            let key = `${ni}_${nj}`\\n            // Next move should be inside the grid bounds\\n            // Next move value should be 1. We can only move by 1 cells.\\n            if( ni < n && nj < m && !set.has(key) && grid[ni][nj] === 1) {\\n                // Remember next move to not visit it twice.\\n                set.add(key);\\n                // Add next move to path\\n                path.push([ni, nj])\\n                // Run DFS for next move.\\n                if(dfs(ni, nj)){\\n                    // If one of next moves reached the (n-1, m-1) the matrix is connected\\n                    return true;\\n                }\\n                // Current cell is not part of any path. Remove it from path.\\n                path.pop();\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    // Run DFS\\n    if(!dfs(0, 0)){\\n        // Initial matrix is already disconnected\\n        return true;\\n    }\\n    \\n    // Matrix is connected. We have some path.\\n    path.shift(); // remove [0, 0]\\n    path.pop(); // remove [n-1, m-1]\\n    \\n    // Set every cell of found path to 0\\n    for (let p of path) {\\n        grid[p[0]][p[1]] = 0;\\n    }\\n    \\n    // Run DFS for updated matrix once again.\\n    set = new Set();\\n    set.add(`0_0`);\\n    return !dfs(0, 0);\\n};\\n\\n```\n```\\nvar isPossibleToCutPath = function(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length\\n    let moves = [[0,1], [1,0]];\\n    let dfs = (i, j) => {\\n        if(i === n-1 && j === m - 1) {\\n            return true;\\n        }\\n        \\n        for (let move of moves) {\\n            let ni = i + move[0];\\n            let nj = j + move[1];\\n            if( ni < n && nj < m && grid[ni][nj] === 1) {\\n                grid[ni][nj] = 0;\\n                if(dfs(ni, nj)){\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    if(!dfs(0, 0)){\\n        return true;\\n    }\\n    grid[n-1][m-1] = 1;\\n    return !dfs(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141553,
                "title": "c-greedy-easy-solution",
                "content": "**Please Upvote :))**\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/89c5608c-de18-45a2-8f87-47798b591e25_1675528598.5841.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>v(m+n-1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                    v[i+j]++;\\n            }\\n        }\\n        for(int i=1;i<v.size()-1;i++)\\n        {\\n            \\n            if(v[i]<=1) return true; \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>v(m+n-1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                    v[i+j]++;\\n            }\\n        }\\n        for(int i=1;i<v.size()-1;i++)\\n        {\\n            \\n            if(v[i]<=1) return true; \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147322,
                "title": "simple-c-code-without-using-dfs",
                "content": "In the first loop, I am checking for all the discontinuos or continuos rows that can be made continuos.\\nIn the second loop, I am doing the same for columns.\\nIn the third part, I am checking the same for diagonal rows.\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int t;\\n        int sum=0;\\n        for(t=1;t<m-1;t++)\\n        {\\n            sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                sum+=grid[t][i];\\n            }\\n            if(sum<=1)\\n                return true;\\n        }\\n        for(t=1;t<n-1;t++)\\n        {\\n            sum=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                sum+=grid[i][t];\\n            }\\n            if(sum<=1)\\n                return true;\\n        }\\n        \\n        if(m==n)\\n        {m--;\\n            for(t=0,sum=0;m>=0;m--,t++)\\n        {\\n            sum+=grid[m][t];\\n            cout<<0<<endl;\\n        }\\n        if(sum<=1)\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int t;\\n        int sum=0;\\n        for(t=1;t<m-1;t++)\\n        {\\n            sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                sum+=grid[t][i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3142497,
                "title": "java-check-the-number-of-paths-explained-with-graph-and-proof",
                "content": "# Intuition\\nWhen can we flip a cell to make the matrix disconnected?\\nThe graph shown below is the only case.\\n![Graph.png](https://assets.leetcode.com/users/images/62cd64b5-5459-47fd-9424-edf7c8b8e0bc_1675535712.5305872.png)\\nHence, if all the paths contain a common point $$(i, j)$$, then we can flip $$(i, j)$$ to disconnect the matrix.\\n\\n# Approach\\nThe problem becomes how to check if all the paths contain a common point $$(i, j)$$.\\nWe can calculate the number of paths from $$(0, 0)$$ to $$(i ,j)$$ and the number of paths from $$(i, j)$$ to $$(m - 1, n - 1)$$. We return `true` when the multiplication of those two numbers is equal to the number of paths from $$(0, 0)$$ to $$(m - 1, n - 1)$$.\\n\\n# Proof\\nTheorem: If $$A\\\\subset B$$ and $$B\\\\subset A$$, then $$A = B$$.\\nLet $$A:=$$ the paths from $$(0, 0)$$ to $$(m - 1, n - 1)$$ contain a common point $$(i, j)$$ and $$B:=$$ paths from $$(0, 0)$$ to $$(m - 1, n - 1)$$.\\nBy definition, if $$a \\\\in A$$, then $$a \\\\in B$$. Hence $$A \\\\subset B$$.\\nIf $$b \\\\in B$$, suppose for contradiction, path $$b$$ does not contain $$(i, j)$$. Let $$n(S)$$ denote the size of set $$S$$. Then $$n(B) = n(A) + 1$$, which is a contradiction. Hence, $$b \\\\in A$$ and thus $$A \\\\subset B$$.\\nWe conclude $$A = B$$.\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int dp1[][] = new int[m][n], dp2[][] = new int[m][n];\\n\\n        // from (0, 0) to (m - 1, n - 1)\\n        dp1[0][0] = 1;\\n        for (int i = 1; i < m; i++) {\\n            if (grid[i][0] == 0) break;\\n            dp1[i][0] = dp1[i - 1][0];\\n        }\\n        for (int j = 1; j < n; j++) {\\n            if (grid[0][j] == 0) break;\\n            dp1[0][j] = dp1[0][j - 1];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    dp1[i][j] = dp1[i - 1][j] + dp1[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        // from (m - 1, n - 1) to (0, 0)\\n        dp2[m - 1][n - 1] = 1;\\n        for (int i = m - 2; i >= 0; i--) {\\n            if (grid[i][n - 1] == 0) break;\\n            dp2[i][n - 1] = dp2[i + 1][n - 1];\\n        }\\n        for (int j = n - 2; j >= 0; j--) {\\n            if (grid[m - 1][j] == 0) break;\\n            dp2[m - 1][j] = dp2[m - 1][j + 1];\\n        }\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    dp2[i][j] = dp2[i + 1][j] + dp2[i][j + 1];\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) continue;\\n                if (i == m - 1 && j == n - 1) continue;\\n                if (dp1[i][j] * dp2[i][j] == dp1[m - 1][n - 1]) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int dp1[][] = new int[m][n], dp2[][] = new int[m][n];\\n\\n        // from (0, 0) to (m - 1, n - 1)\\n        dp1[0][0] = 1;\\n        for (int i = 1; i < m; i++) {\\n            if (grid[i][0] == 0) break;\\n            dp1[i][0] = dp1[i - 1][0];\\n        }\\n        for (int j = 1; j < n; j++) {\\n            if (grid[0][j] == 0) break;\\n            dp1[0][j] = dp1[0][j - 1];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    dp1[i][j] = dp1[i - 1][j] + dp1[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        // from (m - 1, n - 1) to (0, 0)\\n        dp2[m - 1][n - 1] = 1;\\n        for (int i = m - 2; i >= 0; i--) {\\n            if (grid[i][n - 1] == 0) break;\\n            dp2[i][n - 1] = dp2[i + 1][n - 1];\\n        }\\n        for (int j = n - 2; j >= 0; j--) {\\n            if (grid[m - 1][j] == 0) break;\\n            dp2[m - 1][j] = dp2[m - 1][j + 1];\\n        }\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    dp2[i][j] = dp2[i + 1][j] + dp2[i][j + 1];\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) continue;\\n                if (i == m - 1 && j == n - 1) continue;\\n                if (dp1[i][j] * dp2[i][j] == dp1[m - 1][n - 1]) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141488,
                "title": "dfs-python3-o-m-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we need to disconnect them then we just need to block the node which we visit. If still we can reach the end node more than once, then we can not disconnect them in a single flip.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse DFS to traverse the graph and block the point once visited by setting it to zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        if m == 1 and n == 2:\\n            return False\\n        \\n        \\n        def dfs(i=0,j=0):\\n            if i == m-1 and j == n-1:\\n                return True\\n            \\n            if i >= m or j >= n or grid[i][j]==0:\\n                return False\\n            \\n            grid[i][j]=0 #Blocking the point. So we do not visit it later.\\n            \\n            if (i, j) != (0, 0):\\n                #If we are not at start, we need to only check that whether this path leads to the end or not. We do not need to check whether more than one path leads to the end or not because if we flip this point, all the paths will be blocked going through the point.\\n                if dfs(i+1, j):\\n                    return True\\n                return dfs(i, j+1)\\n\\n            #In case of start, if only one path leads to end, we can flip that so to be impossible in one flip both the paths must go to the end.\\n            return not(dfs(i+1, j) and dfs(i, j+1))\\n            \\n        return dfs()\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        if m == 1 and n == 2:\\n            return False\\n        \\n        \\n        def dfs(i=0,j=0):\\n            if i == m-1 and j == n-1:\\n                return True\\n            \\n            if i >= m or j >= n or grid[i][j]==0:\\n                return False\\n            \\n            grid[i][j]=0 #Blocking the point. So we do not visit it later.\\n            \\n            if (i, j) != (0, 0):\\n                #If we are not at start, we need to only check that whether this path leads to the end or not. We do not need to check whether more than one path leads to the end or not because if we flip this point, all the paths will be blocked going through the point.\\n                if dfs(i+1, j):\\n                    return True\\n                return dfs(i, j+1)\\n\\n            #In case of start, if only one path leads to end, we can flip that so to be impossible in one flip both the paths must go to the end.\\n            return not(dfs(i+1, j) and dfs(i, j+1))\\n            \\n        return dfs()\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806177,
                "title": "python-3-dfs-bfs-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153976,
                "title": "beginner-friendly-solution-and-very-simple-to-understand",
                "content": "```\\n/*\\njust try it on 2nd test case you easily able to understand the approach\\n*/\\nclass Solution {\\npublic:\\n    \\n   bool dfs(vector<vector<int> >& grid,int i, int j, int n, int m)\\n    {\\n        if(i==n-1&&j==m-1){\\n            return true;\\n        }\\n\\t\\t grid[i][j]=0;\\n    \\n         if(i >= 0 && i < n && j+1 >= 0 && j+1 < m && grid[i][j+1] == 1){\\n               if(dfs(grid, i, j+1, n, m)){\\n                   return true;\\n               }\\n         }\\n         if(i+1 >= 0 && i+1 < n && j >= 0 && j < m && grid[i+1][j] == 1){\\n               if(dfs(grid, i+1, j, n, m)){\\n                   return true;\\n               } \\n         }\\n\\t\\t \\n        return false;\\n    }\\n\\t\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(dfs(grid,0,0,n,m)==false)\\n        {\\n            return true;\\n        }\\n            \\n        if(dfs(grid,0,0,n,m)==false)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\njust try it on 2nd test case you easily able to understand the approach\\n*/\\nclass Solution {\\npublic:\\n    \\n   bool dfs(vector<vector<int> >& grid,int i, int j, int n, int m)\\n    {\\n        if(i==n-1&&j==m-1){\\n            return true;\\n        }\\n\\t\\t grid[i][j]=0;\\n    \\n         if(i >= 0 && i < n && j+1 >= 0 && j+1 < m && grid[i][j+1] == 1){\\n               if(dfs(grid, i, j+1, n, m)){\\n                   return true;\\n               }\\n         }\\n         if(i+1 >= 0 && i+1 < n && j >= 0 && j < m && grid[i+1][j] == 1){\\n               if(dfs(grid, i+1, j, n, m)){\\n                   return true;\\n               } \\n         }\\n\\t\\t \\n        return false;\\n    }\\n\\t\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(dfs(grid,0,0,n,m)==false)\\n        {\\n            return true;\\n        }\\n            \\n        if(dfs(grid,0,0,n,m)==false)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147366,
                "title": "complete-explanation-c-cinch-solution",
                "content": "# Intuition\\n1. We can make a matrix disconnect only when number of paths in any diagonal is 1.\\n2. Therefore, we traverse through entire array and store frequency of each diagonal in map.\\n3. Map also contains [0,0] and [n-1, m-1] cell which must be removed before iterating it. \\n4. If any diagonal contains only 1 path to move ahead, return true.\\n\\n---\\n \\n**In the following image, diag. 1 and 2 can be disconnected since there are diagonal present in each image which has only 1 path to move whereas in diag. 3 no such diagonal exist.**\\n\\n![Screenshot 2023-02-05 at 10.53.43 PM.png](https://assets.leetcode.com/users/images/8492ef53-90ea-41f5-8258-d62839c1e523_1675617978.817591.png)\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        map<int, int> mp;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                mp[i+j] += grid[i][j];\\n            }\\n        }\\n\\n        mp.erase(0);\\n        mp.erase(n+m-2);\\n        \\n        for(auto [a,b] : mp){\\n            if(b <= 1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        map<int, int> mp;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                mp[i+j] += grid[i][j];\\n            }\\n        }\\n\\n        mp.erase(0);\\n        mp.erase(n+m-2);\\n        \\n        for(auto [a,b] : mp){\\n            if(b <= 1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145456,
                "title": "well-commented-easy-to-understand-c",
                "content": "# Intuition\\nIf there exists more than one independent path from (0,0) to (m-1,n-1) then the answer is false. In any other case, the answer will always be true.\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int flag=0, rows, cols;\\n    int dp[1011][1011];\\n\\n    // First finding a valid path from (0,0) to (m-1,n-1) and \\n    // marking the cells forming the path as zero \\n    // (marking the path as visited)\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid) \\n    {\\n        if(r==rows-1 && c==cols-1)\\n        {\\n            flag=1;\\n            return;\\n        }\\n        grid[r][c]=0;\\n        if(r+1<rows && grid[r+1][c]) dfs(r+1,c,grid);\\n        if(!flag && c+1<cols && grid[r][c+1]) dfs(r,c+1,grid);\\n    }\\n\\n    // Then again performing dfs to check if another \\n    // (independent) path exists from (0,0) to (m-1,n-1)\\n\\n    bool pathExists(int r, int c, vector<vector<int>> &grid) \\n    {\\n        if(r==rows-1 && c==cols-1) return true;\\n        if(r>=rows || c>=cols || !grid[r][c]) return false;\\n        if(dp[r][c]!=-1) return dp[r][c];\\n        return dp[r][c]=(pathExists(r+1,c,grid) || pathExists(r,c+1,grid));\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        rows=grid.size(), cols=grid[0].size();\\n        dfs(0,0,grid);\\n        grid[0][0]=1;\\n        return !pathExists(0,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int flag=0, rows, cols;\\n    int dp[1011][1011];\\n\\n    // First finding a valid path from (0,0) to (m-1,n-1) and \\n    // marking the cells forming the path as zero \\n    // (marking the path as visited)\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid) \\n    {\\n        if(r==rows-1 && c==cols-1)\\n        {\\n            flag=1;\\n            return;\\n        }\\n        grid[r][c]=0;\\n        if(r+1<rows && grid[r+1][c]) dfs(r+1,c,grid);\\n        if(!flag && c+1<cols && grid[r][c+1]) dfs(r,c+1,grid);\\n    }\\n\\n    // Then again performing dfs to check if another \\n    // (independent) path exists from (0,0) to (m-1,n-1)\\n\\n    bool pathExists(int r, int c, vector<vector<int>> &grid) \\n    {\\n        if(r==rows-1 && c==cols-1) return true;\\n        if(r>=rows || c>=cols || !grid[r][c]) return false;\\n        if(dp[r][c]!=-1) return dp[r][c];\\n        return dp[r][c]=(pathExists(r+1,c,grid) || pathExists(r,c+1,grid));\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        rows=grid.size(), cols=grid[0].size();\\n        dfs(0,0,grid);\\n        grid[0][0]=1;\\n        return !pathExists(0,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144771,
                "title": "0ms-100-faster-java-solution-dfs-short-code",
                "content": "* We will travel the matrix once and check if it is possible to reach to the endpoint and while travelling we will fill all the 1\\'s to 0\\'s (similar to earsing our once travelled path)\\n* Now again we will travel and check if it is possible to reach the end point if it is possible that means it is not possible to disconnect the graph by just one flip so now we will return true\\n\\n\\nTIME COMPLEXITY - O(N x M)\\n```\\nclass Solution {\\n    public boolean dfs(int [][] grid,int i,int j){\\n        if(i==grid.length-1&&j==grid[0].length-1)return true;\\n        if(i>=grid.length||j>=grid[0].length||grid[i][j]==0)return false;\\n        grid[i][j]=0;\\n        return dfs(grid,i+1,j) || dfs(grid,i,j+1);\\n    }\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if(!dfs(grid,0,0))return true;\\n        grid[0][0]=1;\\n        if(!dfs(grid,0,0))return true;\\n        return false;\\n    }\\n}\\n```\\n\\n**UPVOTE IF YOU UNDERSTOOD THE SOLUTION \\uD83D\\uDD3C\\n\\uD83D\\uDCACALSO COMMENT FOR ANY IMPROVEMENT**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean dfs(int [][] grid,int i,int j){\\n        if(i==grid.length-1&&j==grid[0].length-1)return true;\\n        if(i>=grid.length||j>=grid[0].length||grid[i][j]==0)return false;\\n        grid[i][j]=0;\\n        return dfs(grid,i+1,j) || dfs(grid,i,j+1);\\n    }\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if(!dfs(grid,0,0))return true;\\n        grid[0][0]=1;\\n        if(!dfs(grid,0,0))return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144361,
                "title": "short-c-bfs-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf paths converge, then removing one point is enough. Try drawing paths on paper.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPut the starting two points in the queue. Now propogating from these two points, keep inserting the new points while popping the old ones. If there comes a time, when theres just one point in the queue and it is not the destination point, then it can be said that the point can be removed to make the path disconnected. We should also check that if is it even possible to reach the destination without modification.\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> q;\\n        int n=grid.size(), m=grid[0].size(), i, j;\\n        vector<vector<bool>> vis(n, vector<bool> (m, false));\\n        if(grid[0][0]){\\n            if(n>1 && grid[1][0]){q.push({1, 0}); vis[1][0] = true;}\\n            if(m>1 && grid[0][1]){q.push({0, 1}); vis[0][1] = true;}\\n        }\\n\\n        while(!q.empty()){\\n            int sz = q.size();\\n            if(sz==1 && q.front()!=(pair<int, int>){n-1, m-1}){return true;}\\n            while(sz--){\\n                auto [f, s] = q.front();\\n                q.pop();\\n                if(n>f+1 && grid[f+1][s] && !vis[f+1][s]){q.push({f+1, s}); vis[f+1][s] = true;}\\n                if(m>s+1 && grid[f][s+1] && !vis[f][s+1]){q.push({f, s+1}); vis[f][s+1] = true;}\\n            }\\n        }\\n\\n        return !vis[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> q;\\n        int n=grid.size(), m=grid[0].size(), i, j;\\n        vector<vector<bool>> vis(n, vector<bool> (m, false));\\n        if(grid[0][0]){\\n            if(n>1 && grid[1][0]){q.push({1, 0}); vis[1][0] = true;}\\n            if(m>1 && grid[0][1]){q.push({0, 1}); vis[0][1] = true;}\\n        }\\n\\n        while(!q.empty()){\\n            int sz = q.size();\\n            if(sz==1 && q.front()!=(pair<int, int>){n-1, m-1}){return true;}\\n            while(sz--){\\n                auto [f, s] = q.front();\\n                q.pop();\\n                if(n>f+1 && grid[f+1][s] && !vis[f+1][s]){q.push({f+1, s}); vis[f+1][s] = true;}\\n                if(m>s+1 && grid[f][s+1] && !vis[f][s+1]){q.push({f, s+1}); vis[f][s+1] = true;}\\n            }\\n        }\\n\\n        return !vis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142765,
                "title": "typescript-dfs-time-85-ms-space-50-3-mb",
                "content": "# Intuition\\nWe will need to traverse the grid until we reach the end.\\n\\n# Approach\\nWe will use the DFS algorithm to move right and down the grid and flag visited cells as `0`. If we traverse the grid again and there is another path to reach the end, it means that we would need to flip more than one cell to disconnect from the end, then we return false, as we know it is impossible to cut the path with only one flip.\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n- Space complexity: $$O(m + n)$$\\n\\n# Code\\n```\\nconst isPossibleToCutPath = (grid: number[][]): boolean => {\\n    // Support variables\\n    const maxX = grid[0].length - 1;\\n    const maxY = grid.length - 1;\\n    let canReachEnd = false;\\n    // DFS helper\\n    const dfs = (col = 0, row = 0) => {\\n        // Base case: stop when we have reached the end of the grid\\n        if (canReachEnd) return;\\n        // Base case: end destination reached \\n        if (col === maxX && row === maxY) {\\n            canReachEnd = true;\\n            return;\\n        }\\n        // Flagging the current cell as not visitable again\\n        grid[row][col] = 0;\\n        // Moving right\\n        if (col < maxX && grid[row][col + 1]) {\\n            dfs(col + 1, row);\\n        }\\n        // Moving down\\n        if (row < maxY && grid[row + 1][col]) {\\n            dfs(col, row + 1);\\n        }\\n    }\\n    // First DFS traversal to check if we can reach the end\\n    dfs();\\n    // Check if we are already disconnected\\n    if (!canReachEnd) return true;\\n    // Second run\\n    canReachEnd = false;\\n    dfs();\\n    return !canReachEnd;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nconst isPossibleToCutPath = (grid: number[][]): boolean => {\\n    // Support variables\\n    const maxX = grid[0].length - 1;\\n    const maxY = grid.length - 1;\\n    let canReachEnd = false;\\n    // DFS helper\\n    const dfs = (col = 0, row = 0) => {\\n        // Base case: stop when we have reached the end of the grid\\n        if (canReachEnd) return;\\n        // Base case: end destination reached \\n        if (col === maxX && row === maxY) {\\n            canReachEnd = true;\\n            return;\\n        }\\n        // Flagging the current cell as not visitable again\\n        grid[row][col] = 0;\\n        // Moving right\\n        if (col < maxX && grid[row][col + 1]) {\\n            dfs(col + 1, row);\\n        }\\n        // Moving down\\n        if (row < maxY && grid[row + 1][col]) {\\n            dfs(col, row + 1);\\n        }\\n    }\\n    // First DFS traversal to check if we can reach the end\\n    dfs();\\n    // Check if we are already disconnected\\n    if (!canReachEnd) return true;\\n    // Second run\\n    canReachEnd = false;\\n    dfs();\\n    return !canReachEnd;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3142680,
                "title": "c-double-dfs-run-66ms-37-2mb",
                "content": "Funny problem that can be solved in multiple ways; in my approach I tried to reach the destination first and then flag all the cells we found on the way as non-walkable again (ie: set to `0`).\\n\\nThen if we found that the end can\\'t be reached, great - we can just `return` `true` since the problem specifies we can work also with no flips at all.\\n\\nIf not, we try to reach the destination again and since this time we will have to use different cells, we know that if the target can\\'t be reached, then at least one cell was fundamental and we can `return` `true` - or `false` if we can still reach it.\\n\\nTo do so, we will start declaring a few instance variables:\\n* `maxX` and `maxY` will store the maximum values of `x` and `y`, respectively;\\n* `canReachEnd` will keep track of whether or not we can reach the last square;\\n* `grid` will store the initial input board.\\n\\nIn our main function, we will assign values to all the instance variables and then call our helper function `dfs`.\\n\\nThis function will take two parameters, `x` and `y`, both defaulted to `0` and:\\n* exit immediately if we reached the end (ie: `canReachEnd == true`);\\n* check if we reached the end and, in case:\\n    * flag `canReachEnd` as `true`;\\n    * exit with `return`;\\n* mark the current cell (ie: `grid[y][x]`) as non-walkable (ie: set to `0`);\\n* check if we can go south by not exiting the boundaries (ie: `y < maxY`) and having a walkable square (ie: `grid[y + 1][x]`) and if so, call `dfs` with `x` and `y + 1`;\\n* check if we can go east by not exiting the boundaries (ie: `x < maxX`) and having a walkable square (ie: `grid[y][x + 1]`) and if so, call `dfs` with `x + 1` and `y`.\\n\\nBack in our main function, as anticipated, we will first of all check if first and last cell were already disconnected (ie: `canReachEnd` is still `false`) and, if so, just `return` `true` (condition met with `0` flips!).\\n\\nIf not, we will reset `canReachEnd` to `false`, run `dfs` again and this time `return` `true` if we cannot reach the end with the second run (ie: `canReachEnd == false`), `false` otherwise.\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n- Space complexity: $$O(n + m)$$ (with the recursive stack)\\n\\n# Code\\n```\\nclass Solution {\\n    // support variables\\n    int maxX, maxY;\\n    bool canReachEnd = false;\\n    vector<vector<int>> grid;\\n    void dfs(int x = 0, int y = 0) {\\n        // exit case\\n        if (canReachEnd) return;\\n        // destination reached\\n        if (x == maxX && y == maxY) {\\n            canReachEnd = true;\\n            return;\\n        }\\n        // marking the current node as visited\\n        grid[y][x] = 0;\\n        // going south\\n        if (y < maxY && grid[y + 1][x]) dfs(x, y + 1);\\n        // going east\\n        if (x < maxX && grid[y][x + 1]) dfs(x + 1, y);\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>> &tmp) {\\n        // giving values to instance variables\\n        swap(grid, tmp);\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // first run\\n        dfs();\\n        // destination and end were already disconnected\\n        if (!canReachEnd) return true;\\n        // second run\\n        canReachEnd = false;\\n        dfs();\\n        return !canReachEnd;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    // support variables\\n    int maxX, maxY;\\n    bool canReachEnd = false;\\n    vector<vector<int>> grid;\\n    void dfs(int x = 0, int y = 0) {\\n        // exit case\\n        if (canReachEnd) return;\\n        // destination reached\\n        if (x == maxX && y == maxY) {\\n            canReachEnd = true;\\n            return;\\n        }\\n        // marking the current node as visited\\n        grid[y][x] = 0;\\n        // going south\\n        if (y < maxY && grid[y + 1][x]) dfs(x, y + 1);\\n        // going east\\n        if (x < maxX && grid[y][x + 1]) dfs(x + 1, y);\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>> &tmp) {\\n        // giving values to instance variables\\n        swap(grid, tmp);\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // first run\\n        dfs();\\n        // destination and end were already disconnected\\n        if (!canReachEnd) return true;\\n        // second run\\n        canReachEnd = false;\\n        dfs();\\n        return !canReachEnd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142413,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if(!dfs(grid,0,0)) return true;\\n        grid[0][0]=1;\\n        if(!dfs(grid,0,0)) return true;\\n        return false;\\n    }\\n    \\n    private boolean dfs(int[][] grid,int x,int y){\\n        if(x==grid.length || y==grid[0].length || grid[x][y]==0) return false;\\n        if(x==grid.length-1 && y==grid[0].length-1) return true;\\n        grid[x][y]=0;\\n        return dfs(grid,x+1,y) || dfs(grid,x,y+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if(!dfs(grid,0,0)) return true;\\n        grid[0][0]=1;\\n        if(!dfs(grid,0,0)) return true;\\n        return false;\\n    }\\n    \\n    private boolean dfs(int[][] grid,int x,int y){\\n        if(x==grid.length || y==grid[0].length || grid[x][y]==0) return false;\\n        if(x==grid.length-1 && y==grid[0].length-1) return true;\\n        grid[x][y]=0;\\n        return dfs(grid,x+1,y) || dfs(grid,x,y+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142234,
                "title": "c-very-easy-to-understand-solution-explained-with-comments",
                "content": "# Code\\n```\\n// The four direction coordinates changes\\n// from the current cell\\nint direction[][2] = {{0, 1}, { 1, 0 } };\\n\\n// Function that returns true if there\\n// exists any path from the top-left to\\n// the bottom-right cell of 0s\\nbool dfs(vector<vector<int> >& matrix,\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int i, int j, int N, int M)\\n{\\n\\n\\xA0\\xA0\\xA0 // If the bottom-right cell is\\n\\xA0\\xA0\\xA0 // reached\\n\\xA0\\xA0\\xA0 if (i == N - 1 and j == M - 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return true;\\n\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 // Update the cell to 1\\n\\xA0\\xA0\\xA0 matrix[i][j] = 0;\\n\\n\\xA0\\xA0\\xA0 // Traverse in all four directions\\n\\xA0\\xA0\\xA0 for (int k = 0; k < 2; k++) {\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Find the new coordinates\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int newX = i + direction[k][0];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int newY = j + direction[k][1];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // If the new cell is valid\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (newX >= 0 and newX < N\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 and newY >= 0 and newY < M\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 and matrix[newX][newY] == 1) {\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Recursively call DFS\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (dfs(matrix, newX,\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 newY, N, M)) {\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // If path exists, then\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // return true\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return true;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 // Return false, if there doesn\\'t\\n\\xA0\\xA0\\xA0 // exists any such path\\n\\xA0\\xA0\\xA0 return false;\\n}\\n\\n// Function to flip the minimum number\\n// of cells such that there doesn\\'t\\n// exists any such path from (0, 0) to\\n// (N - 1, M - 1) cell consisting of 0s\\nint solve(vector<vector<int> >& matrix)\\n{\\n\\n\\xA0\\xA0\\xA0 int N = matrix.size();\\n\\xA0\\xA0\\xA0 int M = matrix[0].size();\\n\\n\\xA0\\xA0\\xA0 // Case 1: If no such path exists\\n\\xA0\\xA0\\xA0 // already\\n\\xA0\\xA0\\xA0 if (!dfs(matrix, 0, 0, N, M)) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return 0;\\n\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 // Case 2: If there exists only\\n\\xA0\\xA0\\xA0 // one path\\n\\xA0\\xA0\\xA0 if (!dfs(matrix, 0, 0, N, M)) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return 1;\\n\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 // Case 3: If there exists two-path\\n\\xA0\\xA0\\xA0 return 2;\\n}\\n\\nclass Solution {\\npublic:\\n\\n\\n\\xA0\\xA0\\xA0 bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size(), m = grid[0].size();\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // cout << solve(grid)<<endl;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(solve(grid) <= 1) return true;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return false;\\n\\xA0\\xA0\\xA0 }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\n// The four direction coordinates changes\\n// from the current cell\\nint direction[][2] = {{0, 1}, { 1, 0 } };\\n\\n// Function that returns true if there\\n// exists any path from the top-left to\\n// the bottom-right cell of 0s\\nbool dfs(vector<vector<int> >& matrix,\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int i, int j, int N, int M)\\n{\\n\\n\\xA0\\xA0\\xA0 // If the bottom-right cell is\\n\\xA0\\xA0\\xA0 // reached\\n\\xA0\\xA0\\xA0 if (i == N - 1 and j == M - 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return true;\\n\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 // Update the cell to 1\\n\\xA0\\xA0\\xA0 matrix[i][j] = 0;\\n\\n\\xA0\\xA0\\xA0 // Traverse in all four directions\\n\\xA0\\xA0\\xA0 for (int k = 0; k < 2; k++) {\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Find the new coordinates\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int newX = i + direction[k][0];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int newY = j + direction[k][1];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // If the new cell is valid\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (newX >= 0 and newX < N\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 and newY >= 0 and newY < M\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 and matrix[newX][newY] == 1) {\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Recursively call DFS\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (dfs(matrix, newX,\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 newY, N, M)) {\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // If path exists, then\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // return true\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return true;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 // Return false, if there doesn\\'t\\n\\xA0\\xA0\\xA0 // exists any such path\\n\\xA0\\xA0\\xA0 return false;\\n}\\n\\n// Function to flip the minimum number\\n// of cells such that there doesn\\'t\\n// exists any such path from (0, 0) to\\n// (N - 1, M - 1) cell consisting of 0s\\nint solve(vector<vector<int> >& matrix)\\n{\\n\\n\\xA0\\xA0\\xA0 int N = matrix.size();\\n\\xA0\\xA0\\xA0 int M = matrix[0].size();\\n\\n\\xA0\\xA0\\xA0 // Case 1: If no such path exists\\n\\xA0\\xA0\\xA0 // already\\n\\xA0\\xA0\\xA0 if (!dfs(matrix, 0, 0, N, M)) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return 0;\\n\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 // Case 2: If there exists only\\n\\xA0\\xA0\\xA0 // one path\\n\\xA0\\xA0\\xA0 if (!dfs(matrix, 0, 0, N, M)) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return 1;\\n\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0 // Case 3: If there exists two-path\\n\\xA0\\xA0\\xA0 return 2;\\n}\\n\\nclass Solution {\\npublic:\\n\\n\\n\\xA0\\xA0\\xA0 bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size(), m = grid[0].size();\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // cout << solve(grid)<<endl;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(solve(grid) <= 1) return true;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return false;\\n\\xA0\\xA0\\xA0 }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3141925,
                "title": "easy-bfs-solution-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can cross the path by one, it looks like some percolation problem, we can try to erode the graph to test if it satisfy.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS\\n\\n# Complexity\\n- Time complexity:$$O((m+n)\\\\times mn\\\\times log(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(3mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n    class Solution {\\n// this is BFS path for erosion\\n        private final int[]check={0,1,1,-1,0,-1,-1,1,0};\\n// this is BFS path to test if the matrix is connected\\n        private final int[]flow={0,1,0};\\n\\n//BFS for matrix connection\\n        private boolean testPath(int m, int n,int[][]grid){\\n            boolean[][]isCheck=new boolean[m][n];\\n            LinkedList<int[]>queue=new LinkedList<int[]>();\\n            queue.add(new int[]{0,0});\\n            isCheck[0][0]=true;\\n            while(!queue.isEmpty()){\\n                int[] temp=queue.poll();\\n                for(int i=1;i<3;i++){\\n                    int x=temp[0]+flow[i-1];\\n                    int y=temp[1]+flow[i];\\n                    if(x<m&&x>=0&&y<n&&y>=0&&grid[x][y]==1&&isCheck[x][y]==false){\\n                        isCheck[x][y]=true;\\n                        queue.add(new int[]{x,y});\\n                        if(x==m-1&&y==n-1){\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n\\n//BFS for erosion\\n        private void erode(int[]start,int m,int n,int[][]grid,int[][]erodeMap){\\n            //bfs + 1 step\\n            LinkedList<int[]>queue=new LinkedList<int[]>();\\n            queue.add(start);\\n            erodeMap[start[0]][start[1]]=0;\\n            \\n            while(!queue.isEmpty()){\\n                int[] temp=queue.poll();\\n                for(int i=1;i<9;i++){\\n                    int x=temp[0]+check[i-1];\\n                    int y=temp[1]+check[i];\\n                    if(x<m&&x>=0&&y<n&&y>=0&&erodeMap[x][y]==1){\\n                        erodeMap[x][y]=0;\\n                        if(grid[x][y]==0){\\n                            queue.add(new int[]{x,y});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n// Main function\\n        public boolean isPossibleToCutPath(int[][] grid) {\\n            // cut from up to down and cut from down to up\\n            int m=grid.length,n=grid[0].length;\\n            // if there is only one path\\n            if(m==1||n==1){\\n                if(m+n==3){\\n                    return false;\\n                }\\n                return true;\\n            }\\n            int[][]erodeMap=new int[m][n];\\n                 for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    erodeMap[i][j]=1;\\n                }\\n            }\\n            //erode on four edge\\n            if(!testPath(m, n, grid)){\\n                return true;\\n            }\\n            for(int i=1;i<m;i++){\\n                if(grid[i][0]==0){\\n                    erode(new int[]{i,0}, m, n, grid, erodeMap);\\n                }\\n            }\\n            for(int i=1;i<n;i++){\\n                if(grid[0][i]==0){\\n                    erode(new int[]{0,i}, m, n, grid, erodeMap);\\n                }\\n            }\\n            for(int i=0;i<n-1;i++){\\n                if(grid[m-1][i]==0){\\n                    erode(new int[]{m-1,i}, m, n, grid, erodeMap);\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                if(grid[i][n-1]==0){\\n                    erode(new int[]{i,n-1}, m, n, grid, erodeMap);\\n                }\\n            }\\n            return !testPath(m,n,erodeMap);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    class Solution {\\n// this is BFS path for erosion\\n        private final int[]check={0,1,1,-1,0,-1,-1,1,0};\\n// this is BFS path to test if the matrix is connected\\n        private final int[]flow={0,1,0};\\n\\n//BFS for matrix connection\\n        private boolean testPath(int m, int n,int[][]grid){\\n            boolean[][]isCheck=new boolean[m][n];\\n            LinkedList<int[]>queue=new LinkedList<int[]>();\\n            queue.add(new int[]{0,0});\\n            isCheck[0][0]=true;\\n            while(!queue.isEmpty()){\\n                int[] temp=queue.poll();\\n                for(int i=1;i<3;i++){\\n                    int x=temp[0]+flow[i-1];\\n                    int y=temp[1]+flow[i];\\n                    if(x<m&&x>=0&&y<n&&y>=0&&grid[x][y]==1&&isCheck[x][y]==false){\\n                        isCheck[x][y]=true;\\n                        queue.add(new int[]{x,y});\\n                        if(x==m-1&&y==n-1){\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n\\n//BFS for erosion\\n        private void erode(int[]start,int m,int n,int[][]grid,int[][]erodeMap){\\n            //bfs + 1 step\\n            LinkedList<int[]>queue=new LinkedList<int[]>();\\n            queue.add(start);\\n            erodeMap[start[0]][start[1]]=0;\\n            \\n            while(!queue.isEmpty()){\\n                int[] temp=queue.poll();\\n                for(int i=1;i<9;i++){\\n                    int x=temp[0]+check[i-1];\\n                    int y=temp[1]+check[i];\\n                    if(x<m&&x>=0&&y<n&&y>=0&&erodeMap[x][y]==1){\\n                        erodeMap[x][y]=0;\\n                        if(grid[x][y]==0){\\n                            queue.add(new int[]{x,y});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n// Main function\\n        public boolean isPossibleToCutPath(int[][] grid) {\\n            // cut from up to down and cut from down to up\\n            int m=grid.length,n=grid[0].length;\\n            // if there is only one path\\n            if(m==1||n==1){\\n                if(m+n==3){\\n                    return false;\\n                }\\n                return true;\\n            }\\n            int[][]erodeMap=new int[m][n];\\n                 for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    erodeMap[i][j]=1;\\n                }\\n            }\\n            //erode on four edge\\n            if(!testPath(m, n, grid)){\\n                return true;\\n            }\\n            for(int i=1;i<m;i++){\\n                if(grid[i][0]==0){\\n                    erode(new int[]{i,0}, m, n, grid, erodeMap);\\n                }\\n            }\\n            for(int i=1;i<n;i++){\\n                if(grid[0][i]==0){\\n                    erode(new int[]{0,i}, m, n, grid, erodeMap);\\n                }\\n            }\\n            for(int i=0;i<n-1;i++){\\n                if(grid[m-1][i]==0){\\n                    erode(new int[]{m-1,i}, m, n, grid, erodeMap);\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                if(grid[i][n-1]==0){\\n                    erode(new int[]{i,n-1}, m, n, grid, erodeMap);\\n                }\\n            }\\n            return !testPath(m,n,erodeMap);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426483,
                "title": "java-easy-understanding-dfs-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n=grid.length,m=grid[0].length;\\n        boolean res1=false,res2=false;\\n        res1=dfs(0,0,grid,n,m);\\n        grid[0][0]=1;\\n        res2=dfs(0,0,grid,n,m);\\n        return res2==false?true:false;\\n    }\\n    public static boolean dfs(int i,int j,int a[][],int n,int m){\\n        if(i>=n||j>=m||i<0||j<0||a[i][j]==0) return false;\\n        if(i==n-1&&j==m-1) return true;\\n        a[i][j]=0;\\n        return dfs(i+1,j,a,n,m)||dfs(i,j+1,a,n,m);\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n=grid.length,m=grid[0].length;\\n        boolean res1=false,res2=false;\\n        res1=dfs(0,0,grid,n,m);\\n        grid[0][0]=1;\\n        res2=dfs(0,0,grid,n,m);\\n        return res2==false?true:false;\\n    }\\n    public static boolean dfs(int i,int j,int a[][],int n,int m){\\n        if(i>=n||j>=m||i<0||j<0||a[i][j]==0) return false;\\n        if(i==n-1&&j==m-1) return true;\\n        a[i][j]=0;\\n        return dfs(i+1,j,a,n,m)||dfs(i,j+1,a,n,m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171105,
                "title": "python-3-greedy-dfs-explanation",
                "content": "# Intuition\\n- If there are two paths that \\n    - can reach from top-left to bottom-right\\n    - has no overlap (except starting & ending point)\\n- Then, it\\'s not possible to disconnect the graph with one flip\\n\\n# Approach\\n- The intuition is straight forward, but how do we do that? \\n    - Find out all paths and compare is definitely not possible with scale given\\n- But note this, **if there is a valid `path A`, then any other paths `B` that share any points with `path A` are not what we are looking for.**\\n- We can achieve this by using DFS with modifying the original matrix\\n    - We will make sure that each point (except starting & ending points) are fliped for `paht A`\\n    - Then do the same DFS again\\n        - If this DFS is able to find a `path B`, then it\\'s not possible to disconnect graph with one flip, thus return `False`\\n        - Otherwise, we know that all possible `path B` share at least some points (if appliable) with `path A`. There will be some critical points can be fliped on `path A`, thus return `True`\\n\\n# Complexity\\n- Time complexity:\\n`O(m*n)`\\n\\n- Space complexity:\\n`O(m*n)` for stack used\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        def dfs(x, y):\\n            nonlocal m, n, grid\\n            if not grid[x][y]:\\n                return False\\n            if x == m-1 and y == n-1:\\n                return True\\n            grid[x][y] = 0    \\n            if x + 1 < m and dfs(x + 1, y):\\n                return True\\n            if y + 1 < n and dfs(x, y + 1):\\n                return True\\n            return False\\n        dfs(0, 0)            # destroy one path\\n        grid[0][0] = 1       # reset origin\\n        return not dfs(0, 0) # try to find another path, if not possible, then such a point exists\\n                            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        def dfs(x, y):\\n            nonlocal m, n, grid\\n            if not grid[x][y]:\\n                return False\\n            if x == m-1 and y == n-1:\\n                return True\\n            grid[x][y] = 0    \\n            if x + 1 < m and dfs(x + 1, y):\\n                return True\\n            if y + 1 < n and dfs(x, y + 1):\\n                return True\\n            return False\\n        dfs(0, 0)            # destroy one path\\n        grid[0][0] = 1       # reset origin\\n        return not dfs(0, 0) # try to find another path, if not possible, then such a point exists\\n                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154619,
                "title": "all-bfs-solutions-are-wrong",
                "content": "```\\n// Test Case:\\n\\n[[1,1,1],\\n [1,0,0],\\n [1,1,1],\\n [1,1,1]]\\n \\n // As shown below:\\n\\n// 2 can be disconnected, but I can\\'t find any formula to describe this pattern.\\n \\n[[1,2,3],\\n [2,0,0],\\n [3,4,5],\\n [4,5,6]]\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n// Test Case:\\n\\n[[1,1,1],\\n [1,0,0],\\n [1,1,1],\\n [1,1,1]]\\n \\n // As shown below:\\n\\n// 2 can be disconnected, but I can\\'t find any formula to describe this pattern.\\n \\n[[1,2,3],\\n [2,0,0],\\n [3,4,5],\\n [4,5,6]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152843,
                "title": "video-walkthrough-python-7-line-solution",
                "content": "[Click Here For Video Walkthrough]( https://youtu.be/YFrhZDWeQZY)\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        def dfs(i,j):\\n            if i == len(grid) - 1 and j == len(grid[0]) - 1: return True\\n            if not (0 <= i < len(grid)) or not (0 <= j < len(grid[0])) or grid[i][j] == 0: return False\\n            grid[i][j] = 0\\n            return any(dfs(k,l) for k,l in [(i+1,j),(i,j+1)])\\n        grid[0][0],_ = 1, dfs(0,0)\\n        return not dfs(0,0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        def dfs(i,j):\\n            if i == len(grid) - 1 and j == len(grid[0]) - 1: return True\\n            if not (0 <= i < len(grid)) or not (0 <= j < len(grid[0])) or grid[i][j] == 0: return False\\n            grid[i][j] = 0\\n            return any(dfs(k,l) for k,l in [(i+1,j),(i,j+1)])\\n        grid[0][0],_ = 1, dfs(0,0)\\n        return not dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149979,
                "title": "clear-dfs-javascript-solution-without-additional-memory",
                "content": "# Intuition\\nMain idea is to check at first is there at least one path to the target node and if there is no path we can return true (matrix is disconnected by default). If there is a path, we can check is there another path and if there is we return false (no way to made matrix disconnected with one flip).\\n\\n# Approach\\nSolution doesn\\'t required any additional DS to store path (or visited nodes). We just can set 0 to each position we visited when looked for a path initialy (except `grid[0][0]` and `grid[n-1][m-1]`) so our algorithm will not revisit already visited cells.\\n\\n# Complexity\\n- Time complexity:\\n $$O(N + M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(1)$$ additional space or $$O(N + M)$$ if we also think about the call stack;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst hasPath = (i, j, grid) => {\\n    if (i >= grid.length || j >= grid[0].length) return false;\\n    if (grid[i][j] === 0) return false;\\n\\n    if (i === grid.length - 1 && j === grid[0].length - 1) return true;\\n\\n    if (i > 0 || j > 0) {    \\n      grid[i][j] = 0;\\n    }\\n\\n    const steps = [[1,0],[0,1]];\\n\\n    for (const [r, c] of steps) {\\n        if (hasPath(i + r, j + c, grid)) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar isPossibleToCutPath = function(grid) {\\n    const path = hasPath(0, 0, grid);\\n\\n    if (!path) return true;\\n    \\n    return !hasPath(0, 0, grid);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst hasPath = (i, j, grid) => {\\n    if (i >= grid.length || j >= grid[0].length) return false;\\n    if (grid[i][j] === 0) return false;\\n\\n    if (i === grid.length - 1 && j === grid[0].length - 1) return true;\\n\\n    if (i > 0 || j > 0) {    \\n      grid[i][j] = 0;\\n    }\\n\\n    const steps = [[1,0],[0,1]];\\n\\n    for (const [r, c] of steps) {\\n        if (hasPath(i + r, j + c, grid)) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar isPossibleToCutPath = function(grid) {\\n    const path = hasPath(0, 0, grid);\\n\\n    if (!path) return true;\\n    \\n    return !hasPath(0, 0, grid);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3146593,
                "title": "10-line-easy-python-solution-o-m-n-count-ones-on-diagonal-lines",
                "content": "[Intuition]\\nIf the matrix is connected, there must be at least a 1 in each diagonal line that spreads from top right to bottom left.\\nA diagonal line consists of all 0s will divide the matrix into two unconnected part: top left part and bottom right part.\\nEx. \\n1 1 0 1 1\\n1 0 1 1 1\\n0 1 1 1 1\\nNote. For a m x n matrix, there are (m+n-1) diagonal lines spreading from top right to bottom left.\\nFor all elements on the ith diagonal line, their x-axis and y-axis indices sum up to i.\\n\\nStrategy:\\nIf we can make the matrix unconnected by at most one flip, it means there must be a diagonal line that has zero or only one occurence of 1.\\nCount the number of 1s on each diagnal, if that number is less than 2, return True.\\nRemember to exclude the first and last diagonal as they always have a 1.\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        diag = [0]*(m+n-1)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    diag[i+j] += 1\\n                    \\n        for i in range(1, m+n-2):\\n            if diag[i] < 2:\\n                return True\\n            \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        diag = [0]*(m+n-1)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    diag[i+j] += 1\\n                    \\n        for i in range(1, m+n-2):\\n            if diag[i] < 2:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143022,
                "title": "easiest-solution-using-dfs-o-n-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int n,m;\\n    \\n    \\n    bool dfs(vector<vector<int>>&grid,int i,int j){\\n        if(i>=n || j>=m || grid[i][j] == 0) return false;\\n        if(i == n-1 and j==m-1){\\n            return true;\\n        }\\n\\n        grid[i][j] = 0;\\n        return dfs(grid,i+1,j) || dfs(grid,i,j+1);\\n    }\\n\\n    \\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        if(grid[0][0] == 0 ) return true;\\n        int ans = 0;\\n        ans = dfs(grid,0,0);\\n        grid[0][0] = 1;\\n        ans += dfs(grid,0,0);\\n        return ans<2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int n,m;\\n    \\n    \\n    bool dfs(vector<vector<int>>&grid,int i,int j){\\n        if(i>=n || j>=m || grid[i][j] == 0) return false;\\n        if(i == n-1 and j==m-1){\\n            return true;\\n        }\\n\\n        grid[i][j] = 0;\\n        return dfs(grid,i+1,j) || dfs(grid,i,j+1);\\n    }\\n\\n    \\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        if(grid[0][0] == 0 ) return true;\\n        int ans = 0;\\n        ans = dfs(grid,0,0);\\n        grid[0][0] = 1;\\n        ans += dfs(grid,0,0);\\n        return ans<2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142701,
                "title": "this-should-be-labelled-hard",
                "content": "Man this should be labelled hard.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3142621,
                "title": "java-and-python-simple-easy-and-100-fast-solution",
                "content": "Please upvote if understood \\nLogic ==> If there are more than one distinct paths that don\\'t have any common point then we can\\'t disconnect them \\n\\n**Java **\\n\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        boolean ans = DFS(grid,0,0,grid.length , grid[0].length);\\n        if(ans == false) return true ;\\n        grid[0][0]=1;\\n        boolean res = DFS(grid,0,0,grid.length , grid[0].length);\\n        return !res;\\n    }\\n    public boolean DFS(int [][] grid , int r , int c , int m , int n){\\n        if(r>=m || c>=n || grid[r][c]==0)return false ;\\n        if(r==m-1 && c==n-1)return true ;\\n        grid[r][c]= 0;\\n        return DFS(grid,r,c+1,m,n) || DFS(grid,r+1,c,m,n);\\n    }\\n\\n\\nPython \\n\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        def DFS (grid ,r ,c ,m , n):\\n            if r>=m or c>=n or grid[r][c] == 0: return False;\\n            if r==m-1 and c ==n-1: return True ;\\n            grid[r][c]= 0;\\n            return DFS(grid,r,c+1,m,n) or DFS(grid,r+1,c,m,n);\\n        \\n        ans = DFS(grid,0,0,len(grid),len(grid[0]));\\n        if ans == False : return True ;\\n        grid[0][0] = True ;\\n        res = DFS(grid,0,0,len(grid),len(grid[0]));\\n        return not res;",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "Please upvote if understood \\nLogic ==> If there are more than one distinct paths that don\\'t have any common point then we can\\'t disconnect them \\n\\n**Java **\\n\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        boolean ans = DFS(grid,0,0,grid.length , grid[0].length);\\n        if(ans == false) return true ;\\n        grid[0][0]=1;\\n        boolean res = DFS(grid,0,0,grid.length , grid[0].length);\\n        return !res;\\n    }\\n    public boolean DFS(int [][] grid , int r , int c , int m , int n){\\n        if(r>=m || c>=n || grid[r][c]==0)return false ;\\n        if(r==m-1 && c==n-1)return true ;\\n        grid[r][c]= 0;\\n        return DFS(grid,r,c+1,m,n) || DFS(grid,r+1,c,m,n);\\n    }\\n\\n\\nPython \\n\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        def DFS (grid ,r ,c ,m , n):\\n            if r>=m or c>=n or grid[r][c] == 0: return False;\\n            if r==m-1 and c ==n-1: return True ;\\n            grid[r][c]= 0;\\n            return DFS(grid,r,c+1,m,n) or DFS(grid,r+1,c,m,n);\\n        \\n        ans = DFS(grid,0,0,len(grid),len(grid[0]));\\n        if ans == False : return True ;\\n        grid[0][0] = True ;\\n        res = DFS(grid,0,0,len(grid),len(grid[0]));\\n        return not res;",
                "codeTag": "Python3"
            },
            {
                "id": 3142446,
                "title": "python-diagonal-trick-simple-and-intuitive-solution",
                "content": "# Intuition\\nNotice that every path has to go through one of the antidiagonals (those that go from the bottom left to the top right). So if we can block at least one of these diagonals, a.k.a. assign zeros to all of its elements, there won\\'t be any path.\\n\\n# Approach\\nCount the number of ones for each antidiagonal. Then just check if there is at least one diagonal with at most one value $1$. If it\\'s the case, we can flip this value to $0$, and there won\\'t be any path. Also, take into account that we don\\'t count the topmost $(0, 0)$ and the bottommost $(m - 1, n - 1)$ diagonals as they always consist of one value $1$ each and shouldn\\'t be counted.\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n\\n- Space complexity: $O(m + n)$ - to store all the antidiagonals.\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, M: list[list[int]]) -> bool:\\n        m, n = len(M), len(M[0])\\n        diag = Counter()\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if i + j not in (0, m + n - 2):\\n                    diag[i + j] += M[i][j]\\n\\n        return any(c < 2 for c in diag.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, M: list[list[int]]) -> bool:\\n        m, n = len(M), len(M[0])\\n        diag = Counter()\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if i + j not in (0, m + n - 2):\\n                    diag[i + j] += M[i][j]\\n\\n        return any(c < 2 for c in diag.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142018,
                "title": "java-0ms-dfs-clean-clode",
                "content": "class Solution {\\n    \\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int a = helper(grid, 0, 0, m - 1, n - 1);\\n        int b = helper(grid, 0, 0, m - 1, n - 1);\\n        \\n        return b >= 1 ? false : true;\\n    }\\n    \\n    private int helper(int[][] grid, int i, int j, int m, int n){\\n        \\n        if(i > m || j > n)return 0;\\n        \\n        if(grid[i][j] == 0)return 0;\\n        \\n        if(i == m && j == n)return 1;\\n        \\n        if(!(i == 0 && j == 0))grid[i][j] = 0;\\n        \\n        int cnt = 0;\\n        cnt += helper(grid, i + 1, j, m, n);\\n        \\n        if(cnt == 0)\\n            cnt += helper(grid, i, j + 1, m, n);\\n        \\n        if(cnt >= 1)cnt = 1;\\n        \\n        return cnt;\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int a = helper(grid, 0, 0, m - 1, n - 1);\\n        int b = helper(grid, 0, 0, m - 1, n - 1);\\n        \\n        return b >= 1 ? false : true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3141942,
                "title": "simple-java-solution-using-count-path-method",
                "content": "```\\nclass Solution {\\n    private static final int[][] dirs={{0,1}, {1,0}};\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int first=dfs(grid,0,0);\\n        int second=dfs(grid,0,0);\\n        return second >= 1 ? false : true;\\n    }\\n    \\n    private int dfs(int[][] g, int r, int c) {\\n        if(r < 0 || r == g.length || c < 0 || c == g[0].length || g[r][c] == 0)\\n            return 0;\\n        if(r == g.length-1 && c == g[0].length-1)\\n            return 1;\\n        \\n        if(!(r == 0 && c == 0))\\n            g[r][c]=0;\\n\\n        int count=0;\\n        for(int[] dir:dirs) {\\n            count += dfs(g,r+dir[0],c+dir[1]);\\n            if(count >= 1)\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[][] dirs={{0,1}, {1,0}};\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int first=dfs(grid,0,0);\\n        int second=dfs(grid,0,0);\\n        return second >= 1 ? false : true;\\n    }\\n    \\n    private int dfs(int[][] g, int r, int c) {\\n        if(r < 0 || r == g.length || c < 0 || c == g[0].length || g[r][c] == 0)\\n            return 0;\\n        if(r == g.length-1 && c == g[0].length-1)\\n            return 1;\\n        \\n        if(!(r == 0 && c == 0))\\n            g[r][c]=0;\\n\\n        int count=0;\\n        for(int[] dir:dirs) {\\n            count += dfs(g,r+dir[0],c+dir[1]);\\n            if(count >= 1)\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141908,
                "title": "java-math-dp-solution-no-bfs-dfs",
                "content": "# Intuition\\nThis function returns true if\\n\\n1. We cannot move from $$(0, 0)$$ to $$(m - 1, n - 1)$$, or\\n2. There is at one cell that we have to go through\\n\\n1 can be easily checked by computing how many paths from $$(0, 0)$$ to $$(i, j)$$.\\n\\nTo check 2, we first need to realize that the paths from $$(0, 0)$$ to a cell $$(i, j)$$ and those from $$(i, j)$$ to $$(m - 1, n - 1)$$ are mutually excluded and do not share a cell.\\n\\nThen assume $$n1$$ is the number of paths from $$(0, 0)$$ to $$(i, j)$$ and $$n2$$ from $$(i, j)$$ to $$(m - 1, n - 1)$$, the number of paths going through $$(i, j)$$ is $$n3 = n1 * n2$$. We just need to find if there is a cell where $$n3$$ equals the total number of paths from $$(0, 0)$$ to $$(i, j)$$, which you can get when checking for 1.\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] dp = new int[m][n][2];\\n        dp[0][0][0] = 1;\\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if ((i > 0 || j > 0) && grid[i][j] == 1) {\\n            if (i > 0) dp[i][j][0] += dp[i - 1][j][0];\\n            if (j > 0) dp[i][j][0] += dp[i][j - 1][0];\\n        }\\n        if (dp[m - 1][n - 1][0] == 0) return true;\\n        dp[m - 1][n - 1][1] = 1;\\n        for (int i = m - 1; i > -1; i--) for (int j = n - 1; j > -1; j--) if ((i < m - 1 || j < n - 1) && grid[i][j] == 1) {\\n            if (i < m - 1) dp[i][j][1] += dp[i + 1][j][1];\\n            if (j < n - 1) dp[i][j][1] += dp[i][j + 1][1];\\n            if ((i > 0 || j > 0) && dp[i][j][0] * dp[i][j][1] == dp[m - 1][n - 1][0]) return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] dp = new int[m][n][2];\\n        dp[0][0][0] = 1;\\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if ((i > 0 || j > 0) && grid[i][j] == 1) {\\n            if (i > 0) dp[i][j][0] += dp[i - 1][j][0];\\n            if (j > 0) dp[i][j][0] += dp[i][j - 1][0];\\n        }\\n        if (dp[m - 1][n - 1][0] == 0) return true;\\n        dp[m - 1][n - 1][1] = 1;\\n        for (int i = m - 1; i > -1; i--) for (int j = n - 1; j > -1; j--) if ((i < m - 1 || j < n - 1) && grid[i][j] == 1) {\\n            if (i < m - 1) dp[i][j][1] += dp[i + 1][j][1];\\n            if (j < n - 1) dp[i][j][1] += dp[i][j + 1][1];\\n            if ((i > 0 || j > 0) && dp[i][j][0] * dp[i][j][1] == dp[m - 1][n - 1][0]) return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141690,
                "title": "using-only-count-of-ways",
                "content": "\\n# Approach\\nFor each point (i,j) lets say the number of ways to reach (0,0) -> (i,j) = `way1` , and number of ways to reach (i,j) -> (m-1, n-1) = `way2`. Also total ways to reach (0,0) -> (m-1, n-1) are `total_ways`.\\n\\nIf for any point (i,j) other than (0,0) and (m-1, n-1), `way1 * way2 == total_ways` is true. That mean that this point is essential to connect (0,0) and (m-1, n-1). \\nHence removing this point will successfully disconnect the grid.\\n\\nWe need to use modulos to comapare values cause value could become very big.\\n\\nProbalilty for  `((x%m) * (y%m)) % m = (z%m)` and `(x*y) != z` is `1/m`. That is the probability of getting false positive result when comparing values by taking their mod.\\n\\nSince we used two mods, the probability of our solution giving wrong answer is `1/(mod[0] * mod1[1])` which is order of `10^(-18)`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        const int nmod = 2;\\n        int mod[nmod] = {(int)1e9+9, (int)1e9+7};\\n        \\n        \\n        int way1[m][n][nmod]; // from (0,0) to all points \\n        int way2[m][n][nmod]; // from (m-1, n-1)\\n        \\n        // find way1\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                for(int k=0; k<nmod; k++){\\n                    if(i==0 && j==0) {\\n                        way1[i][j][k] = 1;\\n                        continue;\\n                    }\\n                    else if(grid[i][j] == 0){\\n                        way1[i][j][k] = 0;\\n                        continue;\\n                    }         \\n                    way1[i][j][k] = 0;\\n                    if(i>0){\\n                        way1[i][j][k] = (way1[i][j][k] + way1[i-1][j][k]) % mod[k];\\n                    }\\n                    if(j>0){\\n                        way1[i][j][k] = (way1[i][j][k] + way1[i][j-1][k]) % mod[k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // find way2\\n        for(int i=m-1; i>=0; i--){\\n            for(int j=n-1; j>=0; j--){\\n                for(int k=0; k<nmod; k++){\\n                    if(i==m-1 && j==n-1) {\\n                        way2[i][j][k] = 1;\\n                        continue;\\n                    }\\n                    else if(grid[i][j] == 0){\\n                        way2[i][j][k] = 0;\\n                        continue;\\n                    } \\n                    \\n                    way2[i][j][k] = 0;\\n                    if(i<m-1){\\n                        way2[i][j][k] = (way2[i][j][k] + way2[i+1][j][k]) % mod[k];\\n                    }\\n                    if(j<n-1){\\n                        way2[i][j][k] = (way2[i][j][k] + way2[i][j+1][k]) % mod[k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        bool possible = false;\\n        \\n        for(int i=0; i<m && !possible; i++){\\n            for(int j=0; j<n && !possible; j++){\\n                \\n                if(i==0 && j==0) continue;\\n                if(i==m-1 && j==n-1) continue;\\n\\n                bool same = true;\\n                for(int k=0; k<nmod && same; k++){\\n                    // 0,0 -> (m-1. n-1) through (i,j)\\n                    \\n                    int way_through = ( way1[i][j][k] * (long long)way2[i][j][k]) % mod[k];\\n                    if(way_through != way1[m-1][n-1][k]){\\n                        same = false;\\n                    }\\n                }\\n                \\n                if(same) {\\n                    possible = true;\\n                }\\n            }\\n        }\\n        \\n        return possible;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        const int nmod = 2;\\n        int mod[nmod] = {(int)1e9+9, (int)1e9+7};\\n        \\n        \\n        int way1[m][n][nmod]; // from (0,0) to all points \\n        int way2[m][n][nmod]; // from (m-1, n-1)\\n        \\n        // find way1\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                for(int k=0; k<nmod; k++){\\n                    if(i==0 && j==0) {\\n                        way1[i][j][k] = 1;\\n                        continue;\\n                    }\\n                    else if(grid[i][j] == 0){\\n                        way1[i][j][k] = 0;\\n                        continue;\\n                    }         \\n                    way1[i][j][k] = 0;\\n                    if(i>0){\\n                        way1[i][j][k] = (way1[i][j][k] + way1[i-1][j][k]) % mod[k];\\n                    }\\n                    if(j>0){\\n                        way1[i][j][k] = (way1[i][j][k] + way1[i][j-1][k]) % mod[k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // find way2\\n        for(int i=m-1; i>=0; i--){\\n            for(int j=n-1; j>=0; j--){\\n                for(int k=0; k<nmod; k++){\\n                    if(i==m-1 && j==n-1) {\\n                        way2[i][j][k] = 1;\\n                        continue;\\n                    }\\n                    else if(grid[i][j] == 0){\\n                        way2[i][j][k] = 0;\\n                        continue;\\n                    } \\n                    \\n                    way2[i][j][k] = 0;\\n                    if(i<m-1){\\n                        way2[i][j][k] = (way2[i][j][k] + way2[i+1][j][k]) % mod[k];\\n                    }\\n                    if(j<n-1){\\n                        way2[i][j][k] = (way2[i][j][k] + way2[i][j+1][k]) % mod[k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        bool possible = false;\\n        \\n        for(int i=0; i<m && !possible; i++){\\n            for(int j=0; j<n && !possible; j++){\\n                \\n                if(i==0 && j==0) continue;\\n                if(i==m-1 && j==n-1) continue;\\n\\n                bool same = true;\\n                for(int k=0; k<nmod && same; k++){\\n                    // 0,0 -> (m-1. n-1) through (i,j)\\n                    \\n                    int way_through = ( way1[i][j][k] * (long long)way2[i][j][k]) % mod[k];\\n                    if(way_through != way1[m-1][n-1][k]){\\n                        same = false;\\n                    }\\n                }\\n                \\n                if(same) {\\n                    possible = true;\\n                }\\n            }\\n        }\\n        \\n        return possible;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141666,
                "title": "java-simple-solution-for-beginner-for-loop-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthree points to check :\\n1.If all the elements of a row become 0 , then path will be disconnected.\\n2.If all the elements of a column become 0 , then path will be disconnected.\\n3.If any of the dialogonal sum becomes 0, then it is possible \\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int rows = grid.length;    \\n        int cols = grid[0].length;    \\n        if(rows == 1 && cols <=2 ) return false;\\n        if(rows == 1){\\n            int summ=0;\\n             for(int j = 0; j < cols; j++){    \\n              summ += grid[0][j];    \\n            } \\n            if(summ <= cols) return true;\\n            \\n        }\\n        for(int i = 0; i < rows; i++){    \\n            int sumr = 0;    \\n            for(int j = 0; j < cols; j++){    \\n              sumr += grid[i][j];    \\n            }    \\n           if(sumr <= 1) return true;    \\n        }    \\n              \\n        for(int i = 0; i < cols; i++){    \\n            int sumCol = 0;    \\n            for(int j = 0; j < rows; j++){    \\n              sumCol = sumCol + grid[j][i];    \\n            }    \\n           if(sumCol <= 1) return true;   \\n        }    \\n        int row_sum=0;\\n        int col_sum=0;\\n        if(rows == cols && rows%2 != 0){\\n        for (int k = 0; k < rows; k++) {\\n            for (int l = 0; l < rows; l++) {\\n                if (k == l)\\n                    row_sum += grid[k][l];\\n                if ((k + l) == (rows - 1))\\n                    col_sum += grid[k][l];\\n            }\\n        }\\n        if(row_sum <=1  || col_sum <=1 ) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int rows = grid.length;    \\n        int cols = grid[0].length;    \\n        if(rows == 1 && cols <=2 ) return false;\\n        if(rows == 1){\\n            int summ=0;\\n             for(int j = 0; j < cols; j++){    \\n              summ += grid[0][j];    \\n            } \\n            if(summ <= cols) return true;\\n            \\n        }\\n        for(int i = 0; i < rows; i++){    \\n            int sumr = 0;    \\n            for(int j = 0; j < cols; j++){    \\n              sumr += grid[i][j];    \\n            }    \\n           if(sumr <= 1) return true;    \\n        }    \\n              \\n        for(int i = 0; i < cols; i++){    \\n            int sumCol = 0;    \\n            for(int j = 0; j < rows; j++){    \\n              sumCol = sumCol + grid[j][i];    \\n            }    \\n           if(sumCol <= 1) return true;   \\n        }    \\n        int row_sum=0;\\n        int col_sum=0;\\n        if(rows == cols && rows%2 != 0){\\n        for (int k = 0; k < rows; k++) {\\n            for (int l = 0; l < rows; l++) {\\n                if (k == l)\\n                    row_sum += grid[k][l];\\n                if ((k + l) == (rows - 1))\\n                    col_sum += grid[k][l];\\n            }\\n        }\\n        if(row_sum <=1  || col_sum <=1 ) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141464,
                "title": "graph-precompute-number-of-paths",
                "content": "# Intution\\n\\nA cell (x, y) is one of possible cells, if\\n\\n`#path to reach end from (0, 0) = #path to reach end from (0, 0) with (x, y) being an element of path`\\ni.e, required condition for each cell is:\\n`#path to reach end from (0, 0) = (#path to reach (x, y) from (0, 0)) * (#path to reach end from (x, y))`\\n\\nAnd both values can be precomputed\\n\\n```cpp\\nusing ll = long long;\\n\\nconstexpr ll mod = 1e9 + 7;\\n\\nclass Solution {\\n public:\\n  bool isPossibleToCutPath(std::vector<std::vector<int>>& grid) {\\n    ll const m = grid.size();\\n    ll const n = grid[0].size();\\n    std::vector to_reach_end(m, std::vector(n, 0ll));\\n    std::vector to_reach(m, std::vector(n, 0ll));\\n    to_reach[0][0] = 1;\\n    for (ll i = 1; i < m; ++i) {\\n      if (grid[i][0] == 1) to_reach[i][0] += to_reach[i - 1][0];\\n    }\\n    for (ll j = 1; j < n; ++j) {\\n      if (grid[0][j] == 1) {\\n        to_reach[0][j] += to_reach[0][j - 1];\\n      }\\n    }\\n    to_reach_end[m - 1][n - 1] = 1;\\n    for (ll i = m - 2; i >= 0; --i) {\\n      if (grid[i][n - 1] == 1)\\n        to_reach_end[i][n - 1] += to_reach_end[i + 1][n - 1];\\n    }\\n    for (ll j = n - 2; j >= 0; --j) {\\n      if (grid[m - 1][j] == 1) {\\n        to_reach_end[m - 1][j] += to_reach_end[m - 1][j + 1];\\n      }\\n    }\\n    for (ll i = 1; i < m; ++i) {\\n      for (ll j = 1; j < n; ++j) {\\n        if (grid[i][j] != 0) {\\n          to_reach[i][j] = (to_reach[i - 1][j] + to_reach[i][j - 1]) % mod;\\n        }\\n      }\\n    }\\n    for (ll i = m - 2; i >= 0; --i) {\\n      for (ll j = n - 2; j >= 0; --j) {\\n        if (grid[i][j] != 0) {\\n          to_reach_end[i][j] =\\n              (to_reach_end[i + 1][j] + to_reach_end[i][j + 1]) % mod;\\n        }\\n      }\\n    }\\n    ll const total_init_path = to_reach_end[0][0];\\n    for (ll i = 0; i < m; ++i) {\\n      for (ll j = 0; j < n; ++j) {\\n        if (i == 0 && j == 0) continue;\\n        if (i == m - 1 && j == n - 1) continue;\\n        ll const to_reach_cur = to_reach[i][j];\\n        ll const to_reach_last = to_reach_end[i][j];\\n        if (total_init_path == (to_reach_cur * to_reach_last) % mod)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nusing ll = long long;\\n\\nconstexpr ll mod = 1e9 + 7;\\n\\nclass Solution {\\n public:\\n  bool isPossibleToCutPath(std::vector<std::vector<int>>& grid) {\\n    ll const m = grid.size();\\n    ll const n = grid[0].size();\\n    std::vector to_reach_end(m, std::vector(n, 0ll));\\n    std::vector to_reach(m, std::vector(n, 0ll));\\n    to_reach[0][0] = 1;\\n    for (ll i = 1; i < m; ++i) {\\n      if (grid[i][0] == 1) to_reach[i][0] += to_reach[i - 1][0];\\n    }\\n    for (ll j = 1; j < n; ++j) {\\n      if (grid[0][j] == 1) {\\n        to_reach[0][j] += to_reach[0][j - 1];\\n      }\\n    }\\n    to_reach_end[m - 1][n - 1] = 1;\\n    for (ll i = m - 2; i >= 0; --i) {\\n      if (grid[i][n - 1] == 1)\\n        to_reach_end[i][n - 1] += to_reach_end[i + 1][n - 1];\\n    }\\n    for (ll j = n - 2; j >= 0; --j) {\\n      if (grid[m - 1][j] == 1) {\\n        to_reach_end[m - 1][j] += to_reach_end[m - 1][j + 1];\\n      }\\n    }\\n    for (ll i = 1; i < m; ++i) {\\n      for (ll j = 1; j < n; ++j) {\\n        if (grid[i][j] != 0) {\\n          to_reach[i][j] = (to_reach[i - 1][j] + to_reach[i][j - 1]) % mod;\\n        }\\n      }\\n    }\\n    for (ll i = m - 2; i >= 0; --i) {\\n      for (ll j = n - 2; j >= 0; --j) {\\n        if (grid[i][j] != 0) {\\n          to_reach_end[i][j] =\\n              (to_reach_end[i + 1][j] + to_reach_end[i][j + 1]) % mod;\\n        }\\n      }\\n    }\\n    ll const total_init_path = to_reach_end[0][0];\\n    for (ll i = 0; i < m; ++i) {\\n      for (ll j = 0; j < n; ++j) {\\n        if (i == 0 && j == 0) continue;\\n        if (i == m - 1 && j == n - 1) continue;\\n        ll const to_reach_cur = to_reach[i][j];\\n        ll const to_reach_last = to_reach_end[i][j];\\n        if (total_init_path == (to_reach_cur * to_reach_last) % mod)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096993,
                "title": "dfs-for-two-paths",
                "content": "# Approach\\nWe can\\'t make matrix disconnected in case when two independent paths from (0, 0) to (m-1, n-1) exist.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$.\\n\\n- Space complexity: $$O(m+n)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        if m == 1 and n > 2 or m > 2 and n == 1:\\n            return True\\n        elif grid[0][0] == 0 or grid[m-1][n-1] == 0:\\n            return True\\n        elif m <= 2 and n == 1 or m == 1 and n <= 2:\\n            return False\\n\\n        def dfs(i, j, d1, d2, path):\\n            if (i, j) == (m-1, n-1):\\n                return True\\n            elif not (0 <= i < m and 0 <= j < n) or grid[i][j] == 0:\\n                return False\\n\\n            path.add((i, j))\\n            if dfs(i+d1, j+d2, d1, d2, path):\\n                return True\\n            elif dfs(i+d2, j+d1, d1, d2, path):\\n                return True\\n            path.remove((i, j))\\n\\n            return False\\n                \\n        pathHigh, pathLow = set(), set()\\n        if not dfs(0, 1, 0, 1, pathHigh):\\n            return True\\n        if not dfs(1, 0, 1, 0, pathLow):\\n            return True\\n\\n        return pathHigh & pathLow\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        if m == 1 and n > 2 or m > 2 and n == 1:\\n            return True\\n        elif grid[0][0] == 0 or grid[m-1][n-1] == 0:\\n            return True\\n        elif m <= 2 and n == 1 or m == 1 and n <= 2:\\n            return False\\n\\n        def dfs(i, j, d1, d2, path):\\n            if (i, j) == (m-1, n-1):\\n                return True\\n            elif not (0 <= i < m and 0 <= j < n) or grid[i][j] == 0:\\n                return False\\n\\n            path.add((i, j))\\n            if dfs(i+d1, j+d2, d1, d2, path):\\n                return True\\n            elif dfs(i+d2, j+d1, d1, d2, path):\\n                return True\\n            path.remove((i, j))\\n\\n            return False\\n                \\n        pathHigh, pathLow = set(), set()\\n        if not dfs(0, 1, 0, 1, pathHigh):\\n            return True\\n        if not dfs(1, 0, 1, 0, pathLow):\\n            return True\\n\\n        return pathHigh & pathLow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077096,
                "title": "fastest-java-solution-dfs-explained-in-details",
                "content": "# Intuition\\nBasically it all boils down to one crucial point - which is if there are 2 or more unique paths exists, then you can\\'t disconnect them with one point.\\nSo, here we need to make sure that at least two of the exists.\\n***Case 1:*** Now, suppose that there are two roads from point A to point B, which don\\'t have intersections, then it\\'s clear that you can\\'t disconnect them.\\n***Case 2:*** Suppose now, that you have two roads which have one intersection at the same point which both ways go through - then it\\'s clear that we can delete that point and be able to find disconnection point.\\n***Case 3:*** What if there are two roads that have same intersections, but with more that one point, let\\'s say two or three and so on - then we it\\'s not enough for us to disconnect it with one point.\\n\\nAnd this all comes to two unique paths challenge.\\n\\n# Approach\\n***Step 1:*** Run dfs once and find unique path from source to destination by marking used points as 0, so that you won\\'t visit them again. *Note*: you can mark with 0 even points that you weren\\'t able to find the path with, because it\\'s okay if you don\\'t follow them again on the second iteration on step 2.\\n***Step 2:*** Run dfs again and try to find the second path, and make you decision\\n# Complexity\\n- Time complexity:\\nO(n*m) - we don\\'t reiterate same paths again because of marking them\\n\\n- Space complexity:\\nO(n + m) - at most recursion calls will be n + m times\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean firstUniquePathExists = dfs(n-1, m-1, grid);\\n        if (!firstUniquePathExists) return true;\\n\\n        grid[n-1][m-1] = 1;\\n        boolean secondUniquePathExists = dfs(n-1, m-1, grid);\\n        return !secondUniquePathExists;\\n    }\\n\\n    private static boolean dfs(int i, int j, int[][] grid) {\\n        if (i == 0 && j == 0) return true;\\n        if (i < 0 || j < 0 || grid[i][j] == 0) return false;\\n\\n        grid[i][j] = 0;\\n        return dfs(i-1, j, grid) || dfs(i, j-1, grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean firstUniquePathExists = dfs(n-1, m-1, grid);\\n        if (!firstUniquePathExists) return true;\\n\\n        grid[n-1][m-1] = 1;\\n        boolean secondUniquePathExists = dfs(n-1, m-1, grid);\\n        return !secondUniquePathExists;\\n    }\\n\\n    private static boolean dfs(int i, int j, int[][] grid) {\\n        if (i == 0 && j == 0) return true;\\n        if (i < 0 || j < 0 || grid[i][j] == 0) return false;\\n\\n        grid[i][j] = 0;\\n        return dfs(i-1, j, grid) || dfs(i, j-1, grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032603,
                "title": "easy-c-solution-dfs-visited-matrix",
                "content": "# Intuition\\nThe idea is to find a chicken neck on fliping which the path gets disconnected, for the existance of chicken neck happens when all the paths will have a point in common, we have to find that point. \\n\\n# Approach\\nWe will use dfs, if no path exist then the answer will be surely yes, else we have to mark the first path and see whether we are able to generate another path without using those marked points, if we are then no chicken neck exist, else we have got a chicken neck.Now to mark the path we can use a visited matrix, but here to save the space we are altering the data of the given grid. \\n\\n# Complexity\\n- Time complexity:\\nO(n*m)-->dfs complexity\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int dx[2] = {-1, 0};\\n    int dy[2] = {0, -1};\\n    bool dfs(int i, int j, vector<vector<int>> &grid) {\\n        if (i==0 && j==0) return true;\\n        grid[i][j] = 0;\\n\\n        for (int k=0; k<2; k++) {\\n            int newR = i+dx[k];\\n            int newC = j+dy[k];\\n\\n            if (newR>=0 && newR<n && newC>=0 && newC<m && grid[newR][newC] == 1) {\\n                if (dfs(newR, newC, grid)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        if (!dfs(n-1, m-1, grid)) return true;\\n\\n        if (!dfs(n-1, m-1, grid)) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int dx[2] = {-1, 0};\\n    int dy[2] = {0, -1};\\n    bool dfs(int i, int j, vector<vector<int>> &grid) {\\n        if (i==0 && j==0) return true;\\n        grid[i][j] = 0;\\n\\n        for (int k=0; k<2; k++) {\\n            int newR = i+dx[k];\\n            int newC = j+dy[k];\\n\\n            if (newR>=0 && newR<n && newC>=0 && newC<m && grid[newR][newC] == 1) {\\n                if (dfs(newR, newC, grid)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        if (!dfs(n-1, m-1, grid)) return true;\\n\\n        if (!dfs(n-1, m-1, grid)) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009624,
                "title": "easy-solution-dfs",
                "content": "# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n) (depth of the recursive call stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```javascript []\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar isPossibleToCutPath = function(grid) {\\n    const dirs = [[1, 0], [0, 1]];\\n    const m = grid.length, n = grid[0].length;\\n\\n    const dfs = function(i, j) {\\n        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) {\\n            return false;\\n        }\\n\\n        if (i === m - 1 && j === n - 1) {\\n            return true;\\n        }\\n\\n        grid[i][j] = 0;\\n\\n        for (let [dx, dy] of dirs) {\\n            if(dfs(i + dx, j + dy)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    dfs(0, 0)\\n    grid[0][0] = 1;\\n    return !dfs(0, 0);\\n};\\n```\\n```python []\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(1, 0), (0, 1)]\\n        \\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0:\\n                return False\\n\\n            if i == m - 1 and j == n - 1:\\n                return True\\n\\n            grid[i][j] = 0\\n\\n            for dx, dy in dirs:\\n                if dfs(i + dx, j + dy):\\n                    return True\\n            \\n            return False\\n        \\n        dfs(0, 0)\\n        grid[0][0] = 1\\n        return not dfs(0, 0)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar isPossibleToCutPath = function(grid) {\\n    const dirs = [[1, 0], [0, 1]];\\n    const m = grid.length, n = grid[0].length;\\n\\n    const dfs = function(i, j) {\\n        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) {\\n            return false;\\n        }\\n\\n        if (i === m - 1 && j === n - 1) {\\n            return true;\\n        }\\n\\n        grid[i][j] = 0;\\n\\n        for (let [dx, dy] of dirs) {\\n            if(dfs(i + dx, j + dy)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    dfs(0, 0)\\n    grid[0][0] = 1;\\n    return !dfs(0, 0);\\n};\\n```\n```python []\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(1, 0), (0, 1)]\\n        \\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0:\\n                return False\\n\\n            if i == m - 1 and j == n - 1:\\n                return True\\n\\n            grid[i][j] = 0\\n\\n            for dx, dy in dirs:\\n                if dfs(i + dx, j + dy):\\n                    return True\\n            \\n            return False\\n        \\n        dfs(0, 0)\\n        grid[0][0] = 1\\n        return not dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997850,
                "title": "c-2-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n , m;\\n    \\n    bool dfs(int i , int j , vector<vector<int>>& grid )\\n    {\\n    \\n        if(i==n-1 && j==m-1)\\n            return true ; \\n        \\n       if( i>=n || j>=m)\\n            return false ;\\n        \\n        if(grid[i][j]==1)\\n        {\\n            grid[i][j]= 0; \\n            return dfs(i+1, j , grid ) || dfs(i, j+1, grid ) ;\\n        }\\n        else\\n            return false ;\\n       \\n    }\\n    \\n    \\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n       \\n        n = grid.size() ,m =grid[0].size() ;\\n    \\n        bool a = dfs(0 ,0 , grid ) ;\\n        \\n        if(!a)\\n            return true ;\\n        \\n        grid[0][0]=1 ;\\n        \\n        bool b = dfs(0 ,0 , grid ) ;\\n     \\n        if(b)\\n            return false ;\\n            \\n        return true ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n , m;\\n    \\n    bool dfs(int i , int j , vector<vector<int>>& grid )\\n    {\\n    \\n        if(i==n-1 && j==m-1)\\n            return true ; \\n        \\n       if( i>=n || j>=m)\\n            return false ;\\n        \\n        if(grid[i][j]==1)\\n        {\\n            grid[i][j]= 0; \\n            return dfs(i+1, j , grid ) || dfs(i, j+1, grid ) ;\\n        }\\n        else\\n            return false ;\\n       \\n    }\\n    \\n    \\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n       \\n        n = grid.size() ,m =grid[0].size() ;\\n    \\n        bool a = dfs(0 ,0 , grid ) ;\\n        \\n        if(!a)\\n            return true ;\\n        \\n        grid[0][0]=1 ;\\n        \\n        bool b = dfs(0 ,0 , grid ) ;\\n     \\n        if(b)\\n            return false ;\\n            \\n        return true ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882999,
                "title": "simple-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we need to flip atmost one zero\\nSo let\\'s first traverse the graph and mark vis a path where we can reach from top to bottom.\\n\\nThen we again find if another path is also possible then we cannot do anything as we can flip only one zero.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple dfs traversal\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n2 * O(DFS)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int delr[2] = {0,1};\\n    int delc[4] = {1,0};\\n\\n    bool isSafe(int i , int j , int n , int m){\\n        return (i>=0 && i<n && j>=0 && j<m);\\n    }\\n\\n    bool dfs(int i , int j , int n , int m , vector<vector<int>> &grid){\\n        if(i == n-1 && j == m-1) return true;\\n\\n        grid[i][j] = 0;\\n\\n        for(int k=0 ; k<=1 ; k++){\\n            int r = delr[k] + i;\\n            int c = delc[k] + j;\\n\\n            if(isSafe(r,c,n,m) && grid[r][c] == 1){\\n                if(dfs(r,c,n,m,grid)) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(!dfs(0,0,n,m,grid)){\\n            return true;\\n        }\\n\\n        if(!dfs(0,0,n,m,grid)){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int delr[2] = {0,1};\\n    int delc[4] = {1,0};\\n\\n    bool isSafe(int i , int j , int n , int m){\\n        return (i>=0 && i<n && j>=0 && j<m);\\n    }\\n\\n    bool dfs(int i , int j , int n , int m , vector<vector<int>> &grid){\\n        if(i == n-1 && j == m-1) return true;\\n\\n        grid[i][j] = 0;\\n\\n        for(int k=0 ; k<=1 ; k++){\\n            int r = delr[k] + i;\\n            int c = delc[k] + j;\\n\\n            if(isSafe(r,c,n,m) && grid[r][c] == 1){\\n                if(dfs(r,c,n,m,grid)) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(!dfs(0,0,n,m,grid)){\\n            return true;\\n        }\\n\\n        if(!dfs(0,0,n,m,grid)){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870285,
                "title": "clean-o-n-m-time-o-1-space-dfs-diagonal-traversal",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> g;\\n    int n,m;\\n    void dfs(int x, int y){\\n        if(x+1<n){\\n            if(g[x+1][y]==1)\\n                dfs(x+1,y);\\n            g[x][y]=max(g[x+1][y],g[x][y]);\\n            if(g[x+1][y]!=2)\\n                g[x+1][y]=0;\\n        }\\n        if(y+1<m){\\n            if(g[x][y+1]==1)\\n                dfs(x,y+1);\\n            g[x][y]=max(g[x][y+1],g[x][y]);\\n            if(g[x][y+1]!=2)\\n                g[x][y+1]=0;\\n        }\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        g=grid;\\n        n=grid.size();\\n        m=grid[0].size();\\n        g[n-1][m-1]=2;\\n        dfs(0,0);\\n        if(g[0][0]<2)\\n            return true;\\n        for(int d=1;d<=(m+n-3);d++){\\n            int x=min(d,n-1);\\n            int y=d-x;\\n            int c=0;\\n            while(x>=0 and y<m){\\n                c+=(g[x][y]==2);\\n                x--;\\n                y++;\\n            }\\n            if(c==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> g;\\n    int n,m;\\n    void dfs(int x, int y){\\n        if(x+1<n){\\n            if(g[x+1][y]==1)\\n                dfs(x+1,y);\\n            g[x][y]=max(g[x+1][y],g[x][y]);\\n            if(g[x+1][y]!=2)\\n                g[x+1][y]=0;\\n        }\\n        if(y+1<m){\\n            if(g[x][y+1]==1)\\n                dfs(x,y+1);\\n            g[x][y]=max(g[x][y+1],g[x][y]);\\n            if(g[x][y+1]!=2)\\n                g[x][y+1]=0;\\n        }\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        g=grid;\\n        n=grid.size();\\n        m=grid[0].size();\\n        g[n-1][m-1]=2;\\n        dfs(0,0);\\n        if(g[0][0]<2)\\n            return true;\\n        for(int d=1;d<=(m+n-3);d++){\\n            int x=min(d,n-1);\\n            int y=d-x;\\n            int c=0;\\n            while(x>=0 and y<m){\\n                c+=(g[x][y]==2);\\n                x--;\\n                y++;\\n            }\\n            if(c==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762911,
                "title": "simple-dfs-checking-for-two-unique-paths-c-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,vector<vector<int>>&vis,vector<vector<int>>&grid,int n,int m)\\n    {\\n        if(i<0 || i>=n || j<0 || j>=m || vis[i][j]==1 || grid[i][j]==0) return 0;\\n        vis[i][j]=1;\\n        if(i==n-1 && j==m-1) return 1;\\n        bool f=0;\\n        f=f || dfs(i+1,j,vis,grid,n,m);\\n        f= f|| dfs(i,j+1,vis,grid,n,m);\\n        return f;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n    \\n       int n=grid.size();\\n       int m=grid[0].size();\\n       vector<vector<int>>vis(n,vector<int>(m,0));\\n       bool f=dfs(0,0,vis,grid,n,m);\\n       if(f==0) return 1;\\n       vis[0][0]=0;\\n       vis[n-1][m-1]=0;\\n       bool gh=dfs(0,0,vis,grid,n,m);\\n       if(gh==0) return 1;\\n       return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,vector<vector<int>>&vis,vector<vector<int>>&grid,int n,int m)\\n    {\\n        if(i<0 || i>=n || j<0 || j>=m || vis[i][j]==1 || grid[i][j]==0) return 0;\\n        vis[i][j]=1;\\n        if(i==n-1 && j==m-1) return 1;\\n        bool f=0;\\n        f=f || dfs(i+1,j,vis,grid,n,m);\\n        f= f|| dfs(i,j+1,vis,grid,n,m);\\n        return f;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n    \\n       int n=grid.size();\\n       int m=grid[0].size();\\n       vector<vector<int>>vis(n,vector<int>(m,0));\\n       bool f=dfs(0,0,vis,grid,n,m);\\n       if(f==0) return 1;\\n       vis[0][0]=0;\\n       vis[n-1][m-1]=0;\\n       bool gh=dfs(0,0,vis,grid,n,m);\\n       if(gh==0) return 1;\\n       return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752460,
                "title": "c-2-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n      m = grid.size(), n = grid[0].size();\\n      {\\n        vector<pair<int, int>> path;\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        path.push_back({0,0});\\n        if (!dfs(grid, path, vis))\\n          return true;\\n        for (int i = 1; i < path.size()-1; i++) {\\n          int ii = path[i].first, jj = path[i].second;\\n          grid[ii][jj] = 0;\\n        }\\n      }\\n      {\\n        vector<pair<int, int>> path;\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        path.push_back({0,0});\\n        if (!dfs(grid, path, vis))\\n          return true;\\n      }\\n      return false;\\n    }\\n\\n  private:\\n    bool dfs(vector<vector<int>>& grid, vector<pair<int, int>>& path, vector<vector<int>>& vis) {\\n      if (path.empty())\\n        return false;\\n      int i = path.back().first, j = path.back().second;\\n      vis[i][j] = true;\\n      if (i == m-1 && j == n-1)\\n        return true;\\n      if (i+1 < m && grid[i+1][j] && !vis[i+1][j]) {\\n        path.push_back({i+1,j});\\n        if (dfs(grid, path, vis))\\n          return true;\\n        path.pop_back();\\n      }\\n      if (j+1 < n && grid[i][j+1] && !vis[i][j+1]) {\\n        path.push_back({i,j+1});\\n        if (dfs(grid, path, vis))\\n          return true;\\n        path.pop_back();\\n      }\\n      return false;\\n    }\\n    int m, n;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n      m = grid.size(), n = grid[0].size();\\n      {\\n        vector<pair<int, int>> path;\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        path.push_back({0,0});\\n        if (!dfs(grid, path, vis))\\n          return true;\\n        for (int i = 1; i < path.size()-1; i++) {\\n          int ii = path[i].first, jj = path[i].second;\\n          grid[ii][jj] = 0;\\n        }\\n      }\\n      {\\n        vector<pair<int, int>> path;\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        path.push_back({0,0});\\n        if (!dfs(grid, path, vis))\\n          return true;\\n      }\\n      return false;\\n    }\\n\\n  private:\\n    bool dfs(vector<vector<int>>& grid, vector<pair<int, int>>& path, vector<vector<int>>& vis) {\\n      if (path.empty())\\n        return false;\\n      int i = path.back().first, j = path.back().second;\\n      vis[i][j] = true;\\n      if (i == m-1 && j == n-1)\\n        return true;\\n      if (i+1 < m && grid[i+1][j] && !vis[i+1][j]) {\\n        path.push_back({i+1,j});\\n        if (dfs(grid, path, vis))\\n          return true;\\n        path.pop_back();\\n      }\\n      if (j+1 < n && grid[i][j+1] && !vis[i][j+1]) {\\n        path.push_back({i,j+1});\\n        if (dfs(grid, path, vis))\\n          return true;\\n        path.pop_back();\\n      }\\n      return false;\\n    }\\n    int m, n;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731107,
                "title": "golang-two-rounds-of-dfs",
                "content": "# Code\\n```\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n  m, n := len(grid),len(grid[0]) \\n  visited := make([][]bool, m)\\n  for i := 0; i < len(visited); i++ {\\n    visited[i] = make([]bool, n)\\n  }\\n  if !dfs(grid, visited, 0, 0) {\\n    return true // can\\'t visit; no need to flip a bit\\n  }\\n  // unset the last cell\\n  visited[m-1][n-1] = false\\n  return !dfs(grid, visited, 0, 0) // try another round by just using unvisited path\\n  \\n}\\n\\nfunc dfs(grid [][]int, visited [][]bool, row, col int) bool {\\n  m, n := len(grid), len(grid[0])\\n  if row == m-1 && col == n-1 {\\n    return true\\n  }\\n  if row+1 < m && grid[row+1][col] == 1 && !visited[row+1][col] {\\n    visited[row+1][col] = true\\n    if dfs(grid, visited, row+1, col) {\\n      return true\\n    }\\n  }\\n  if col+1 < n && grid[row][col+1] == 1 && !visited[row][col+1] {\\n    visited[row][col+1] = true\\n    if dfs(grid, visited, row, col+1) {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n  m, n := len(grid),len(grid[0]) \\n  visited := make([][]bool, m)\\n  for i := 0; i < len(visited); i++ {\\n    visited[i] = make([]bool, n)\\n  }\\n  if !dfs(grid, visited, 0, 0) {\\n    return true // can\\'t visit; no need to flip a bit\\n  }\\n  // unset the last cell\\n  visited[m-1][n-1] = false\\n  return !dfs(grid, visited, 0, 0) // try another round by just using unvisited path\\n  \\n}\\n\\nfunc dfs(grid [][]int, visited [][]bool, row, col int) bool {\\n  m, n := len(grid), len(grid[0])\\n  if row == m-1 && col == n-1 {\\n    return true\\n  }\\n  if row+1 < m && grid[row+1][col] == 1 && !visited[row+1][col] {\\n    visited[row+1][col] = true\\n    if dfs(grid, visited, row+1, col) {\\n      return true\\n    }\\n  }\\n  if col+1 < n && grid[row][col+1] == 1 && !visited[row][col+1] {\\n    visited[row][col+1] = true\\n    if dfs(grid, visited, row, col+1) {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726476,
                "title": "simple-dfs-code-no-dp",
                "content": "# Intuition\\nStart a dfs traversal from begining and marked all visited node 0 in the grid itself.Now again perform DFS , if we could reach at the end we have two ways to end.Hence not possible to disconnect start to end.\\n\\n# Approach\\ndfs(0,0) ----> return !dfs(0,0);\\n\\n# Complexity\\n- Time complexity:\\nO(2(N+M));\\n\\n- Space complexity:\\nO(2(N+M))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i , int j , vector<vector<int>>&grid){   // if we can reach end\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i==m-1 and j==n-1) return true;  // reach end\\n        if(i<0 or i>=m or j<0 or j>=n) return false;\\n        \\n        if(grid[i][j]==1){\\n            grid[i][j]=0;\\n            return dfs(i+1, j, grid) or dfs(i , j+1 , grid);\\n        }else{\\n            return false;\\n        }\\n    }\\n    \\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // explore a path and mark all visited node as 0\\n        dfs(0 , 0, grid);\\n        \\n        grid[0][0] = 1 ;\\n        grid[m-1][n-1] = 1;\\n        \\n        // if we can again reach end , it means we have more than one path, so we cant block it,\\n        // else we can block it, thus return not(if we can reach end)\\n        return !dfs(0 , 0, grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i , int j , vector<vector<int>>&grid){   // if we can reach end\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i==m-1 and j==n-1) return true;  // reach end\\n        if(i<0 or i>=m or j<0 or j>=n) return false;\\n        \\n        if(grid[i][j]==1){\\n            grid[i][j]=0;\\n            return dfs(i+1, j, grid) or dfs(i , j+1 , grid);\\n        }else{\\n            return false;\\n        }\\n    }\\n    \\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // explore a path and mark all visited node as 0\\n        dfs(0 , 0, grid);\\n        \\n        grid[0][0] = 1 ;\\n        grid[m-1][n-1] = 1;\\n        \\n        // if we can again reach end , it means we have more than one path, so we cant block it,\\n        // else we can block it, thus return not(if we can reach end)\\n        return !dfs(0 , 0, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719061,
                "title": "finding-path-2-times-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<int>>& grid,int i,int j){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i==n-1 && j==m-1){\\n            return true;\\n        }\\n        if(i<0||j<0||i>=n||j>=m){\\n            return false;\\n        }\\n        grid[i][j] = 0;\\n        if(i+1<n && grid[i+1][j] == 1){\\n            if(solve(grid,i+1,j)){\\n                return true;\\n            }\\n        }\\n        if(j+1<m && grid[i][j+1] == 1){\\n            if(solve(grid,i,j+1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if((grid.size()==2&&grid[0].size()==1)||(grid.size()==1&&grid[0].size()==2)){\\n            return false;\\n        }\\n//      searching for a path first time ans marking that path 0\\n        bool x = solve(grid,0,0);\\n//      searching for the second path......if second path exist then we can\\'t disconect the graph\\n        if(solve(grid,0,0)){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<int>>& grid,int i,int j){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i==n-1 && j==m-1){\\n            return true;\\n        }\\n        if(i<0||j<0||i>=n||j>=m){\\n            return false;\\n        }\\n        grid[i][j] = 0;\\n        if(i+1<n && grid[i+1][j] == 1){\\n            if(solve(grid,i+1,j)){\\n                return true;\\n            }\\n        }\\n        if(j+1<m && grid[i][j+1] == 1){\\n            if(solve(grid,i,j+1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if((grid.size()==2&&grid[0].size()==1)||(grid.size()==1&&grid[0].size()==2)){\\n            return false;\\n        }\\n//      searching for a path first time ans marking that path 0\\n        bool x = solve(grid,0,0);\\n//      searching for the second path......if second path exist then we can\\'t disconect the graph\\n        if(solve(grid,0,0)){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669140,
                "title": "simply-do-2-times-dfs-graph-c-beats-98",
                "content": "# Intuition\\n\\nJust check if there are two different path exist then answer is false otherwise answer is true.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid dfs(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& visited, bool &ans){\\n    if(i>=grid.size() || j>=grid[0].size() || ans==1 || grid[i][j]==0 || visited[i][j] == 1)\\n    return;\\n    if(i==grid.size()-1 && j==grid[0].size()-1){\\n        ans = 1;\\n        return;\\n    }\\n\\n    visited[i][j] = 1;\\n\\n    dfs(grid, i+1, j, visited, ans);\\n    dfs(grid, i, j+1, visited, ans);\\n}\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n= grid.size() , m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0) );\\n\\n        bool ans1=0, ans2 = 0;\\n\\n        dfs(grid, 0, 0, visited, ans1);\\n        \\n        visited[0][0] = 0;\\n\\n        dfs(grid, 0, 0, visited, ans2);\\n      \\n        if(ans1&&ans2)\\n        return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid dfs(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& visited, bool &ans){\\n    if(i>=grid.size() || j>=grid[0].size() || ans==1 || grid[i][j]==0 || visited[i][j] == 1)\\n    return;\\n    if(i==grid.size()-1 && j==grid[0].size()-1){\\n        ans = 1;\\n        return;\\n    }\\n\\n    visited[i][j] = 1;\\n\\n    dfs(grid, i+1, j, visited, ans);\\n    dfs(grid, i, j+1, visited, ans);\\n}\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n= grid.size() , m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0) );\\n\\n        bool ans1=0, ans2 = 0;\\n\\n        dfs(grid, 0, 0, visited, ans1);\\n        \\n        visited[0][0] = 0;\\n\\n        dfs(grid, 0, 0, visited, ans2);\\n      \\n        if(ans1&&ans2)\\n        return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641863,
                "title": "explained-solution",
                "content": "**Solution**\\n\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        def dfs(x, y):\\n            \\n            if x == len(grid) - 1 and y == len(grid[0]) - 1:\\n                grid[x][y] = 2\\n                return True\\n            \\n            if grid[x][y] == 2:\\n                return True\\n            grid[x][y] = 0\\n            for dx, dy in ((1, 0), (0, 1)):\\n                new_x, new_y = x + dx, y + dy\\n                if new_x < 0 or new_x >= len(grid) or new_y < 0 or new_y >= len(grid[0]) or grid[new_x][new_y] == 0:\\n                    continue\\n                elif grid[new_x][new_y] == 2:\\n                    grid[x][y] = 2\\n                elif grid[new_x][new_y] == 1 and dfs(new_x, new_y):\\n                    grid[x][y] = 2\\n            return grid[x][y] == 2\\n        \\n        dfs(0, 0)\\n        \\n        q = deque([(0,0)])\\n        visited = set([(0,0)])\\n\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                x, y = q.popleft()\\n                for dx, dy in ((1, 0), (0, 1)):\\n                    x_new, y_new = x + dx, y + dy\\n                    if 0 <= x_new < len(grid) and 0 <= y_new < len(grid[0]) and grid[x_new][y_new] == 2 and (x_new, y_new) not in visited:\\n                        visited.add((x_new, y_new))\\n                        q.append((x_new, y_new))\\n            if len(q) == 0:\\n                return True\\n            if len(q) == 1 and q[0][0] == len(grid) - 1 and q[0][1] == len(grid[0]) - 1:\\n                return False\\n            if len(q) == 1:\\n                return True\\n        \\n        return\\n```\\n\\n\\nIn this article, we are going to explore a solution for a particular algorithmic problem involving binary matrices. The problem goes as follows:\\n\\n**Problem Statement:**\\n\\nYou are given a 0-indexed `m x n` binary matrix `grid`. You can move from a cell `(row, col)` to any of the cells `(row + 1, col)` or `(row, col + 1)` that has the value `1`. The matrix is disconnected if there is no path from `(0, 0)` to `(m - 1, n - 1)`.\\n\\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells `(0, 0)` and `(m - 1, n - 1)`.\\n\\nReturn `true` if it is possible to make the matrix disconnect or `false` otherwise.\\n\\nThe solution provided here uses a combination of depth-first search (DFS) and breadth-first search (BFS) to determine if it\\'s possible to disconnect the path from `(0, 0)` to `(m - 1, n - 1)`.\\n\\n**Main Idea:**\\n\\nThe main idea is to first use DFS to identify all cells that can reach the destination cell `(m - 1, n - 1)`. These cells are then marked with a `2` to signify they belong to a valid path. After this, BFS is used to navigate through the valid path cells and see if we can \"disconnect\" the path by not allowing any cells to be visited more than once.\\n\\n**Solution Steps:**\\n\\n1. **DFS phase:** Starting from `(0, 0)`, use DFS to mark all cells that can reach the destination cell `(m - 1, n - 1)`. These cells are marked with a `2`.\\n\\n2. **BFS phase:** Starting again from `(0, 0)`, use BFS to navigate through the cells marked with `2`. Keep a visited set to ensure no cell is visited more than once. The goal is to reach the destination `(m - 1, n - 1)` without encountering any cell that can lead to another valid path cell. If at any point during BFS, the queue becomes empty before reaching the destination, that means the path has been disconnected, and we return `True`. If the queue only has the destination cell left, return `False` as we couldn\\'t disconnect the path.\\n\\n**Why It Works:**\\n\\nThis solution works because it carefully uses two different search strategies for different parts of the problem. DFS is used to identify all cells that belong to a valid path to the destination. Then BFS is used to simulate the process of trying to disconnect the path by only allowing one visit to each cell. This is a clever way of simulating the \"flipping\" of cells without actually flipping them.\\n\\n**Time Complexity:**\\n\\nThe time complexity of this solution is `O(m*n)`, where `m` is the number of rows in the grid and `n` is the number of columns. This is because each cell is visited at most three times - once during the DFS phase, once during the BFS phase, and potentially once more when checking if the current BFS cell can lead to another valid path cell.\\n\\n**Conclusion:**\\n\\nThis solution is a great example of how to cleverly use DFS and BFS together to solve a complex problem. The key trick is to mark all cells that can reach the destination during the DFS phase, and then simulate the flipping of cells during the BFS phase by not allowing any cell to be visited more than once.\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        def dfs(x, y):\\n            \\n            if x == len(grid) - 1 and y == len(grid[0]) - 1:\\n                grid[x][y] = 2\\n                return True\\n            \\n            if grid[x][y] == 2:\\n                return True\\n            grid[x][y] = 0\\n            for dx, dy in ((1, 0), (0, 1)):\\n                new_x, new_y = x + dx, y + dy\\n                if new_x < 0 or new_x >= len(grid) or new_y < 0 or new_y >= len(grid[0]) or grid[new_x][new_y] == 0:\\n                    continue\\n                elif grid[new_x][new_y] == 2:\\n                    grid[x][y] = 2\\n                elif grid[new_x][new_y] == 1 and dfs(new_x, new_y):\\n                    grid[x][y] = 2\\n            return grid[x][y] == 2\\n        \\n        dfs(0, 0)\\n        \\n        q = deque([(0,0)])\\n        visited = set([(0,0)])\\n\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                x, y = q.popleft()\\n                for dx, dy in ((1, 0), (0, 1)):\\n                    x_new, y_new = x + dx, y + dy\\n                    if 0 <= x_new < len(grid) and 0 <= y_new < len(grid[0]) and grid[x_new][y_new] == 2 and (x_new, y_new) not in visited:\\n                        visited.add((x_new, y_new))\\n                        q.append((x_new, y_new))\\n            if len(q) == 0:\\n                return True\\n            if len(q) == 1 and q[0][0] == len(grid) - 1 and q[0][1] == len(grid[0]) - 1:\\n                return False\\n            if len(q) == 1:\\n                return True\\n        \\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619628,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dr[2]={0,1},dc[2]={1,0};\\nbool dfs(int x,int y,vector<vector<int>>& grid,int &m,int &n,vector<vector<int>> &vis){\\n   if(x==n-1 and y==m-1)\\n   {\\n       return false;\\n   }\\n   vis[x][y]=1;\\n   for(int i=0;i<2;i++)\\n   {\\n       int xc=x+dr[i],yc=y+dc[i];\\n       if(xc>=0 and xc<n and yc<m and yc>=0 and !vis[xc][yc] and grid[xc][yc]==1){\\n           if(dfs(xc,yc,grid,m,n,vis)==false)\\n           {\\n               return false;\\n           }\\n       }\\n   }\\nreturn true;\\n}\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n    int n=grid.size(),m=grid[0].size();\\n    bool k=true;\\n    vector<vector<int>> vis(n,vector<int>(m,0));\\n    if(dfs(0,0,grid,m,n,vis)){\\n        return true;\\n    } \\n    if(dfs(0,0,grid,m,n,vis)){\\n        return true;\\n    }   \\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dr[2]={0,1},dc[2]={1,0};\\nbool dfs(int x,int y,vector<vector<int>>& grid,int &m,int &n,vector<vector<int>> &vis){\\n   if(x==n-1 and y==m-1)\\n   {\\n       return false;\\n   }\\n   vis[x][y]=1;\\n   for(int i=0;i<2;i++)\\n   {\\n       int xc=x+dr[i],yc=y+dc[i];\\n       if(xc>=0 and xc<n and yc<m and yc>=0 and !vis[xc][yc] and grid[xc][yc]==1){\\n           if(dfs(xc,yc,grid,m,n,vis)==false)\\n           {\\n               return false;\\n           }\\n       }\\n   }\\nreturn true;\\n}\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n    int n=grid.size(),m=grid[0].size();\\n    bool k=true;\\n    vector<vector<int>> vis(n,vector<int>(m,0));\\n    if(dfs(0,0,grid,m,n,vis)){\\n        return true;\\n    } \\n    if(dfs(0,0,grid,m,n,vis)){\\n        return true;\\n    }   \\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571154,
                "title": "super-solution-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int r, int c, int n, int m, vector<vector<int>> &grid) {\\n        if(r == n - 1 and c == m - 1) \\n            return true;\\n\\n        if(r >= n or c >= m or grid[r][c] == 0) \\n            return false;\\n\\n        grid[r][c] = 0;\\n        \\n        return solve(r + 1, c, n, m, grid) or solve(r, c + 1, n, m, grid);\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        /* Making all 1 along that path to zeros */\\n        if(!solve(0, 0, n, m, grid)) return true;\\n\\n        grid[0][0] = 1;\\n\\n        /* If there is a path still after making all ones to zero then return the dfs will return true means there exists two path hence make not of dfs */\\n        return !solve(0, 0, n, m, grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int r, int c, int n, int m, vector<vector<int>> &grid) {\\n        if(r == n - 1 and c == m - 1) \\n            return true;\\n\\n        if(r >= n or c >= m or grid[r][c] == 0) \\n            return false;\\n\\n        grid[r][c] = 0;\\n        \\n        return solve(r + 1, c, n, m, grid) or solve(r, c + 1, n, m, grid);\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        /* Making all 1 along that path to zeros */\\n        if(!solve(0, 0, n, m, grid)) return true;\\n\\n        grid[0][0] = 1;\\n\\n        /* If there is a path still after making all ones to zero then return the dfs will return true means there exists two path hence make not of dfs */\\n        return !solve(0, 0, n, m, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458927,
                "title": "o-n-m-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<long long>>> t(grid.size(),vector<vector<long long>>(grid[0].size(),vector<long long>(2,0)));\\n        int mod=INT_MAX;\\n        for(int i=grid.size()-1;i>=0;i--)\\n        {\\n            for(int j=grid[0].size()-1;j>=0;j--)\\n            {\\n                if(i==grid.size()-1 && j==grid[0].size()-1)\\n                 { \\n                 t[i][j][0]=1;\\n                continue;\\n                 }\\n                 if(grid[i][j]==0)\\n                 continue;\\n                if(i<grid.size()-1 && grid[i+1][j]==1)\\n                t[i][j][0]=(t[i][j][0]+t[i+1][j][0])%mod;\\n                if(j<grid[0].size()-1 && grid[i][j+1]==1)\\n                t[i][j][0]=(t[i][j][0]+t[i][j+1][0])%mod;\\n            }\\n        }\\n        bool f1=0,f2=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                f1=0,f2=0;\\n                if(i==0 && j==0)\\n                {\\n                    if(t[0][0][0]==0)\\n                    return 1;\\n                t[i][j][1]=1;\\n                continue;\\n                }\\n                if(i==grid.size()-1 && j==grid[0].size()-1)\\n                return grid[i][j]==0;\\n                if(grid[i][j]==0)\\n                continue;\\n                if(i>0 && grid[i-1][j]==1)\\n                f1=1,t[i][j][1]=(t[i][j][1]+t[i-1][j][1])%mod;\\n                if(j>0 && grid[i][j-1]==1)\\n                f2=1,t[i][j][1]=(t[i][j][1]+t[i][j-1][1])%mod;\\n                if(t[i][j][1]==t[0][0][0]||t[0][0][0]==t[i][j][0])\\n                return 1;\\n                if(f1&&f2 && (t[i][j][0]*2)%mod==t[0][0][0])\\n                return 1;\\n\\n\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<long long>>> t(grid.size(),vector<vector<long long>>(grid[0].size(),vector<long long>(2,0)));\\n        int mod=INT_MAX;\\n        for(int i=grid.size()-1;i>=0;i--)\\n        {\\n            for(int j=grid[0].size()-1;j>=0;j--)\\n            {\\n                if(i==grid.size()-1 && j==grid[0].size()-1)\\n                 { \\n                 t[i][j][0]=1;\\n                continue;\\n                 }\\n                 if(grid[i][j]==0)\\n                 continue;\\n                if(i<grid.size()-1 && grid[i+1][j]==1)\\n                t[i][j][0]=(t[i][j][0]+t[i+1][j][0])%mod;\\n                if(j<grid[0].size()-1 && grid[i][j+1]==1)\\n                t[i][j][0]=(t[i][j][0]+t[i][j+1][0])%mod;\\n            }\\n        }\\n        bool f1=0,f2=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                f1=0,f2=0;\\n                if(i==0 && j==0)\\n                {\\n                    if(t[0][0][0]==0)\\n                    return 1;\\n                t[i][j][1]=1;\\n                continue;\\n                }\\n                if(i==grid.size()-1 && j==grid[0].size()-1)\\n                return grid[i][j]==0;\\n                if(grid[i][j]==0)\\n                continue;\\n                if(i>0 && grid[i-1][j]==1)\\n                f1=1,t[i][j][1]=(t[i][j][1]+t[i-1][j][1])%mod;\\n                if(j>0 && grid[i][j-1]==1)\\n                f2=1,t[i][j][1]=(t[i][j][1]+t[i][j-1][1])%mod;\\n                if(t[i][j][1]==t[0][0][0]||t[0][0][0]==t[i][j][0])\\n                return 1;\\n                if(f1&&f2 && (t[i][j][0]*2)%mod==t[0][0][0])\\n                return 1;\\n\\n\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411379,
                "title": "easy-c-solution-with-running-bfs-two-times-one-from-source-and-one-destination",
                "content": "# Intuition\\n\\n\\nRunning bfs two times one from source and one from destination\\nand for each level push the visited cell into a hashmap.\\n\\nif for any level(except source and destination cause we can\\'t flip that) less than or equal to one cell is reapeated in both the direction then we can assure that by fliping that cell we can make the graph disconneced.\\n\\n\\n# Approach\\n\\nstep 1: make a map from level to multiset of cell(map<int,multiset<pair<int,int>>>)\\n\\nstep 2:run bfs from 0,0 and store the level of each cell and push the cell in corresponding level in map.\\n\\nstep 3: run bfs in opposite direction from n-1,m-1 and initial level of n-1,m-1 will be same as the level we got from first bfs and we will decrease the level for neighbours.\\n\\n1,1,1\\n1,0,0\\n1,1,1\\n\\nfor this case our map will look like\\nfor level 1 -> 0,0 0,0\\nfor level 2 -> 0,2 1,0 1,0\\nfor level 3 -> 0,3 2,0 2,0\\nfor level 4 -> 2,1 2,1 \\nfor level 5 -> 2,2 2,2 \\n\\nnow we can clearly see fliping any of the cell 1,0 2,0 2,1 will make the graph disconnected.\\n# Complexity\\n- Time complexity:\\n(n+m)*log(n+m)\\n\\n- Space complexity:\\n(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int level[n][m];\\n        memset(level,0,sizeof(level));\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        level[0][0]=1;\\n        map<int,multiset<pair<int,int>>>mp;\\n        while(q.size()){\\n            auto src=q.front();\\n            int i=src.first;\\n            int j=src.second;\\n            mp[level[i][j]].insert({i,j});\\n            if(i+1<n && grid[i+1][j]==1 && level[i+1][j]==0){\\n                level[i+1][j]=level[i][j]+1;\\n                q.push({i+1,j});\\n            }\\n            if(j+1<m && grid[i][j+1]==1 && level[i][j+1]==0){\\n                level[i][j+1]=level[i][j]+1;\\n                q.push({i,j+1});\\n            }\\n            q.pop();\\n        }\\n        if(level[n-1][m-1]==0) return true;\\n        int level2[n][m];\\n        memset(level2,0,sizeof(level2));\\n        level2[n-1][m-1]=level[n-1][m-1];\\n        q.push({n-1,m-1});\\n        while(q.size()){\\n            auto src=q.front();\\n            q.pop();\\n            int i=src.first;\\n            int j=src.second;\\n            mp[level2[i][j]].insert({i,j});\\n            if(i-1>=0 && grid[i-1][j]==1 && level2[i-1][j]==0){\\n                level2[i-1][j]=level2[i][j]-1;\\n                q.push({i-1,j});\\n            }\\n            if(j-1>=0 && grid[i][j-1]==1 && level2[i][j-1]==0){\\n                level2[i][j-1]=level2[i][j]-1;\\n                q.push({i,j-1});\\n            }\\n        }\\n        // for(auto x:mp){\\n        //     cout<<x.first<<\" -> \";\\n        //     for(auto y:x.second){\\n        //         cout<<y.first<<\",\"<<y.second<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        for(auto x:mp){\\n            if(x.first==1 ||  x.first==level[n-1][m-1]) continue;\\n            int cnt=0;\\n            for(auto y:x.second){\\n                int c=(x.second).count(y);\\n                if(c>1) cnt++;\\n            }\\n            if(cnt<=2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int level[n][m];\\n        memset(level,0,sizeof(level));\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        level[0][0]=1;\\n        map<int,multiset<pair<int,int>>>mp;\\n        while(q.size()){\\n            auto src=q.front();\\n            int i=src.first;\\n            int j=src.second;\\n            mp[level[i][j]].insert({i,j});\\n            if(i+1<n && grid[i+1][j]==1 && level[i+1][j]==0){\\n                level[i+1][j]=level[i][j]+1;\\n                q.push({i+1,j});\\n            }\\n            if(j+1<m && grid[i][j+1]==1 && level[i][j+1]==0){\\n                level[i][j+1]=level[i][j]+1;\\n                q.push({i,j+1});\\n            }\\n            q.pop();\\n        }\\n        if(level[n-1][m-1]==0) return true;\\n        int level2[n][m];\\n        memset(level2,0,sizeof(level2));\\n        level2[n-1][m-1]=level[n-1][m-1];\\n        q.push({n-1,m-1});\\n        while(q.size()){\\n            auto src=q.front();\\n            q.pop();\\n            int i=src.first;\\n            int j=src.second;\\n            mp[level2[i][j]].insert({i,j});\\n            if(i-1>=0 && grid[i-1][j]==1 && level2[i-1][j]==0){\\n                level2[i-1][j]=level2[i][j]-1;\\n                q.push({i-1,j});\\n            }\\n            if(j-1>=0 && grid[i][j-1]==1 && level2[i][j-1]==0){\\n                level2[i][j-1]=level2[i][j]-1;\\n                q.push({i,j-1});\\n            }\\n        }\\n        // for(auto x:mp){\\n        //     cout<<x.first<<\" -> \";\\n        //     for(auto y:x.second){\\n        //         cout<<y.first<<\",\"<<y.second<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        for(auto x:mp){\\n            if(x.first==1 ||  x.first==level[n-1][m-1]) continue;\\n            int cnt=0;\\n            for(auto y:x.second){\\n                int c=(x.second).count(y);\\n                if(c>1) cnt++;\\n            }\\n            if(cnt<=2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3396974,
                "title": "c-dfs-dp-easily-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint flag =0,rows,cols;\\nint dp[1001][1011];\\n\\nvoid dfs(int r,int c,vector<vector<int>>&grid){\\n    if(r==rows-1 && c==cols-1){\\n        flag =1;\\n        return;\\n    }\\n\\n    grid[r][c] =0;\\n\\n    if(r+1<rows && grid[r+1][c])\\n    dfs(r+1,c,grid);\\n\\n    if(!flag && c+1<cols && grid[r][c+1])\\n    dfs(r,c+1,grid);\\n}\\n\\nbool pathExists(int r,int c,vector<vector<int>>&grid){\\n    if(r==rows-1 && c==cols-1)\\n    return true;\\n    if(r>=rows || c>=cols || !grid[r][c])\\n    return false;\\n\\n    if(dp[r][c]!=-1)\\n    return dp[r][c];\\n\\n    return dp[r][c] = (pathExists(r+1,c,grid)||pathExists(r,c+1,grid));\\n}\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        rows = grid.size(),cols = grid[0].size();\\n        dfs(0,0,grid);\\n        grid[0][0]=1;\\n\\n        return !pathExists(0,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint flag =0,rows,cols;\\nint dp[1001][1011];\\n\\nvoid dfs(int r,int c,vector<vector<int>>&grid){\\n    if(r==rows-1 && c==cols-1){\\n        flag =1;\\n        return;\\n    }\\n\\n    grid[r][c] =0;\\n\\n    if(r+1<rows && grid[r+1][c])\\n    dfs(r+1,c,grid);\\n\\n    if(!flag && c+1<cols && grid[r][c+1])\\n    dfs(r,c+1,grid);\\n}\\n\\nbool pathExists(int r,int c,vector<vector<int>>&grid){\\n    if(r==rows-1 && c==cols-1)\\n    return true;\\n    if(r>=rows || c>=cols || !grid[r][c])\\n    return false;\\n\\n    if(dp[r][c]!=-1)\\n    return dp[r][c];\\n\\n    return dp[r][c] = (pathExists(r+1,c,grid)||pathExists(r,c+1,grid));\\n}\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        rows = grid.size(),cols = grid[0].size();\\n        dfs(0,0,grid);\\n        grid[0][0]=1;\\n\\n        return !pathExists(0,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395521,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def isPossibleToCutPath(grid: Array[Array[Int]]): Boolean = {\\n        def isReachable(grid: Array[Array[Int]], i: Int, j: Int):Boolean = {\\n            if(i == grid.length - 1 && j == grid(0).length - 1) return true\\n            if(i >= grid.length || j >= grid(0).length || grid(i)(j) == 0) return false\\n            grid(i)(j) = 0\\n            isReachable(grid, i + 1, j) || isReachable(grid, i, j + 1)\\n        }\\n        if (!isReachable(grid, 0, 0)) return true\\n        grid(0)(0) = 1\\n        if (!isReachable(grid, 0, 0)) return true\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def isPossibleToCutPath(grid: Array[Array[Int]]): Boolean = {\\n        def isReachable(grid: Array[Array[Int]], i: Int, j: Int):Boolean = {\\n            if(i == grid.length - 1 && j == grid(0).length - 1) return true\\n            if(i >= grid.length || j >= grid(0).length || grid(i)(j) == 0) return false\\n            grid(i)(j) = 0\\n            isReachable(grid, i + 1, j) || isReachable(grid, i, j + 1)\\n        }\\n        if (!isReachable(grid, 0, 0)) return true\\n        grid(0)(0) = 1\\n        if (!isReachable(grid, 0, 0)) return true\\n        false\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3281747,
                "title": "java-dfs-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    int N, M;\\n    public boolean isPossibleToCutPath(int[][] G) {\\n        N = G.length; M = G[0].length;\\n        if(!dfs(0, 0, G)) return true;\\n        G[0][0] = 1;\\n        return !dfs(0, 0, G);\\n    }\\n    boolean dfs(int r, int c, int[][] G){\\n        if(r == N-1 && c == M-1)\\n            return true;\\n        if(r == N || c == M || G[r][c] == 0)\\n            return false;\\n        G[r][c] = 0;\\n        return dfs(r, c+1, G) || dfs(r+1, c, G);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int N, M;\\n    public boolean isPossibleToCutPath(int[][] G) {\\n        N = G.length; M = G[0].length;\\n        if(!dfs(0, 0, G)) return true;\\n        G[0][0] = 1;\\n        return !dfs(0, 0, G);\\n    }\\n    boolean dfs(int r, int c, int[][] G){\\n        if(r == N-1 && c == M-1)\\n            return true;\\n        if(r == N || c == M || G[r][c] == 0)\\n            return false;\\n        G[r][c] = 0;\\n        return dfs(r, c+1, G) || dfs(r+1, c, G);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280932,
                "title": "works-100-easy-approach-a-four-line-approach-dfs-depth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this problem we need make max of 1 flip, which is only possible , \\n    only if there is single path from start to end, if there are multiple paths it is not possible,\\n    therefore we check if the grid contains single path or multiple paths which is possible only by using dfs method\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean dfs(int[][] grid,int i,int j){\\n        if(i == grid.length-1 && j == grid[0].length-1) return true;\\n        if(i>=grid.length || j>= grid[0].length || grid[i][j]==0) return false;\\n        grid[i][j]=0;\\n        return dfs(grid,i+1,j) || dfs(grid,i,j+1);\\n    }\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if(!dfs(grid,0,0)) return true;\\n        grid[0][0] = 1;\\n        if(!dfs(grid,0,0)) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean dfs(int[][] grid,int i,int j){\\n        if(i == grid.length-1 && j == grid[0].length-1) return true;\\n        if(i>=grid.length || j>= grid[0].length || grid[i][j]==0) return false;\\n        grid[i][j]=0;\\n        return dfs(grid,i+1,j) || dfs(grid,i,j+1);\\n    }\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if(!dfs(grid,0,0)) return true;\\n        grid[0][0] = 1;\\n        if(!dfs(grid,0,0)) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272634,
                "title": "independent-paths-dfs",
                "content": "# Approach\\nWe need to check if there exist atleast two of more disconnected path haveing no common node exept first and last to do so, \\n1. first take a path if it is complete then mark full path 0 \\n2. Then again run a dfs and find a complete path if it exist ans is NO else ans is YES\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nint dx[2] = {1, 0};\\nint dy[2] = {0, 1};\\nclass Solution {\\nprivate:\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &arr)\\n    {\\n        if(arr[i][j] != 1)\\n        {\\n            return 0;\\n        }\\n\\n        if(i == n-1 and j == m-1)\\n        {\\n            return 1;\\n        }\\n\\n        int cnt = 0;\\n        arr[i][j] = 0;\\n        for(int idx=0;idx<2;idx++)\\n        {\\n            int x = i + dx[idx];\\n            int y = j + dy[idx];\\n            if((x >= 0 and x <= n-1) and (y >= 0 and y <= m-1))\\n            {\\n                int temp = dfs(x, y, n, m, arr);\\n                if(temp == 1)\\n                {\\n                    return 1;\\n                }\\n            }\\n        }\\n\\n        return (cnt >= 1);\\n    \\n    }\\n\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n\\n        // First path from {0,0} --> {n-1,m-1}\\n        if(dfs(0, 0, n, m, arr) == 0)\\n        {\\n            return true;\\n        }\\n\\n        // Second Independent path from {0,0} --> {n-1, m-1}\\n        arr[0][0] = 1;\\n        if(dfs(0, 0, n, m, arr))\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return true;\\n        }\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dx[2] = {1, 0};\\nint dy[2] = {0, 1};\\nclass Solution {\\nprivate:\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &arr)\\n    {\\n        if(arr[i][j] != 1)\\n        {\\n            return 0;\\n        }\\n\\n        if(i == n-1 and j == m-1)\\n        {\\n            return 1;\\n        }\\n\\n        int cnt = 0;\\n        arr[i][j] = 0;\\n        for(int idx=0;idx<2;idx++)\\n        {\\n            int x = i + dx[idx];\\n            int y = j + dy[idx];\\n            if((x >= 0 and x <= n-1) and (y >= 0 and y <= m-1))\\n            {\\n                int temp = dfs(x, y, n, m, arr);\\n                if(temp == 1)\\n                {\\n                    return 1;\\n                }\\n            }\\n        }\\n\\n        return (cnt >= 1);\\n    \\n    }\\n\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n\\n        // First path from {0,0} --> {n-1,m-1}\\n        if(dfs(0, 0, n, m, arr) == 0)\\n        {\\n            return true;\\n        }\\n\\n        // Second Independent path from {0,0} --> {n-1, m-1}\\n        arr[0][0] = 1;\\n        if(dfs(0, 0, n, m, arr))\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return true;\\n        }\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264264,
                "title": "dfs-o-m-n-see-how-many-unique-paths-to-grid-m-1-n-1",
                "content": "The idea here to find total number of unique paths from (0,0) till (m-1, n-1). By unique paths i mean that no cell should be repeated in another path except for start and end cells. To deal with test cases like [[1]], [[1,1]] etc we can say that total number of elements in path should be greater than 2.  \\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        seen, count = {}, 0\\n        count = self.depthFirstSearch((0,0), seen, count,grid)\\n        return count <= 1 and len(grid)*len(grid[0]) > 2\\n    \\n    def depthFirstSearch(self, node, seen, count,grid):\\n        \\n        if node in seen or grid[node[0]][node[1]] == 0:\\n            return count\\n        if node == (len(grid)-1, len(grid[0])-1):\\n            return count+1\\n        \\n        seen[node] = True\\n        children = self.findChildren(node,grid)\\n        \\n        for child in children:\\n            newCount = self.depthFirstSearch(child, seen, count, grid, path)\\n            if newCount > count:\\n                count = newCount\\n                if node != (0,0):\\n                     break\\n        return count\\n        \\n    def findChildren(self, node, grid):\\n        row, col = node\\n        result = []\\n        for newRow, newCol in [(row+1,col), (row,col+1)]:\\n            if newRow < len(grid) and newCol < len(grid[0]):\\n                result.append((newRow, newCol))\\n        return result\\n\\t\\t\\n\\t\\t```\\n        If you find the solution helpful, please upvote. Your suggestions are also welcomed.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        seen, count = {}, 0\\n        count = self.depthFirstSearch((0,0), seen, count,grid)\\n        return count <= 1 and len(grid)*len(grid[0]) > 2\\n    \\n    def depthFirstSearch(self, node, seen, count,grid):\\n        \\n        if node in seen or grid[node[0]][node[1]] == 0:\\n            return count\\n        if node == (len(grid)-1, len(grid[0])-1):\\n            return count+1\\n        \\n        seen[node] = True\\n        children = self.findChildren(node,grid)\\n        \\n        for child in children:\\n            newCount = self.depthFirstSearch(child, seen, count, grid, path)\\n            if newCount > count:\\n                count = newCount\\n                if node != (0,0):\\n                     break\\n        return count\\n        \\n    def findChildren(self, node, grid):\\n        row, col = node\\n        result = []\\n        for newRow, newCol in [(row+1,col), (row,col+1)]:\\n            if newRow < len(grid) and newCol < len(grid[0]):\\n                result.append((newRow, newCol))\\n        return result\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3263555,
                "title": "short-c-o-mn",
                "content": "\\n# Approach\\n1. Traverse the graph, using `dfs` or `bfs`, in such a way that once you find one path, then return true, and mark each value in the path to `0`.\\n2. If you don\\'t find the path in first traversal, then do one more similar traversal, if you get a path, then its not possible to make grid disconnected.\\n\\n**Note** : Don\\'t make first element i.e `grid[0][0]` to `0`, while traversing\\n\\n# Complexity\\n- Time complexity:\\n$$O(NM)$$\\n\\n- Space complexity:\\n$$O(NM)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool dfs(vector<vector<int>> &g, int x =0 , int y =0 ) {\\n        if(x >= g.size() || y >=g[0].size() || g[x][y] == 0) return false;\\n        if(x == g.size()-1 && y == g[0].size()-1) return true;\\n        \\n        if(x !=0 || y!=0)\\n            g[x][y] = 0;\\n\\n        if(dfs(g, x+1, y)) return true;\\n        return dfs(g, x, y+1);\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        return !dfs(grid) || !dfs(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool dfs(vector<vector<int>> &g, int x =0 , int y =0 ) {\\n        if(x >= g.size() || y >=g[0].size() || g[x][y] == 0) return false;\\n        if(x == g.size()-1 && y == g[0].size()-1) return true;\\n        \\n        if(x !=0 || y!=0)\\n            g[x][y] = 0;\\n\\n        if(dfs(g, x+1, y)) return true;\\n        return dfs(g, x, y+1);\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        return !dfs(grid) || !dfs(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257656,
                "title": "python3-two-bfss-work-for-new-added-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple one pass BFS might not work (https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3141835/simple-bfs-o-n-m-detailed-explanation/) since the positions in the queue might not be reachable from the dest.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first do BFS from the bottom right to top left and mark all visited positions with 2. Then we do another BFS from top left to bottom right. If at any given moment before reaching the end position, there are less than two nodes in the queue, then we return `True`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n\\n        if rows == 1 and cols == 1:\\n            return grid[0][0] == 0\\n\\n        # BFS from bottom right to top left\\n        # and set the visited positions to 2\\n        visited = set()\\n        q = collections.deque([(rows - 1, cols - 1)])\\n        grid[-1][-1]= 2\\n        reach_source = False\\n        while q:\\n            next_q = collections.deque()\\n            reach_source = False\\n            while q:\\n                node = q.popleft()\\n                for dr, dc in (-1, 0), (0, -1):\\n                    new_row, new_col = node[0] + dr, node[1] + dc\\n                    if (new_row, new_col) in visited or new_row < 0 or new_col < 0 or grid[new_row][new_col] == 0:\\n                        continue\\n                    visited.add((new_row, new_col))\\n                    next_q.append((new_row, new_col))\\n                    grid[new_row][new_col] = 2\\n                    if new_row == 0 and new_col == 0:\\n                        reach_source = True\\n            if not reach_source and len(next_q) < 2:\\n                return True\\n            if reach_source:\\n                break\\n            q = next_q\\n\\n        if not reach_source:\\n            return True\\n\\n        visited = set()\\n        q = collections.deque([(0, 0)])\\n        while q:\\n            next_q = collections.deque()\\n            reach_dest = False\\n            while q:\\n                node = q.popleft()\\n                for dr, dc in (0, 1), (1, 0):\\n                    new_row, new_col = node[0] + dr, node[1] + dc\\n                    if (new_row, new_col) in visited or new_row >= rows or new_col >= cols or grid[new_row][new_col] != 2:\\n                        continue\\n                    visited.add((new_row, new_col))\\n                    next_q.append((new_row, new_col))\\n                    if new_row == rows - 1 and new_col == cols - 1:\\n                        reach_dest = True\\n            if not reach_dest and len(next_q) < 2:\\n                return True\\n            if reach_dest:\\n                return False\\n            q = next_q\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n\\n        if rows == 1 and cols == 1:\\n            return grid[0][0] == 0\\n\\n        # BFS from bottom right to top left\\n        # and set the visited positions to 2\\n        visited = set()\\n        q = collections.deque([(rows - 1, cols - 1)])\\n        grid[-1][-1]= 2\\n        reach_source = False\\n        while q:\\n            next_q = collections.deque()\\n            reach_source = False\\n            while q:\\n                node = q.popleft()\\n                for dr, dc in (-1, 0), (0, -1):\\n                    new_row, new_col = node[0] + dr, node[1] + dc\\n                    if (new_row, new_col) in visited or new_row < 0 or new_col < 0 or grid[new_row][new_col] == 0:\\n                        continue\\n                    visited.add((new_row, new_col))\\n                    next_q.append((new_row, new_col))\\n                    grid[new_row][new_col] = 2\\n                    if new_row == 0 and new_col == 0:\\n                        reach_source = True\\n            if not reach_source and len(next_q) < 2:\\n                return True\\n            if reach_source:\\n                break\\n            q = next_q\\n\\n        if not reach_source:\\n            return True\\n\\n        visited = set()\\n        q = collections.deque([(0, 0)])\\n        while q:\\n            next_q = collections.deque()\\n            reach_dest = False\\n            while q:\\n                node = q.popleft()\\n                for dr, dc in (0, 1), (1, 0):\\n                    new_row, new_col = node[0] + dr, node[1] + dc\\n                    if (new_row, new_col) in visited or new_row >= rows or new_col >= cols or grid[new_row][new_col] != 2:\\n                        continue\\n                    visited.add((new_row, new_col))\\n                    next_q.append((new_row, new_col))\\n                    if new_row == rows - 1 and new_col == cols - 1:\\n                        reach_dest = True\\n            if not reach_dest and len(next_q) < 2:\\n                return True\\n            if reach_dest:\\n                return False\\n            q = next_q\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218160,
                "title": "python-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n    \\n        def dfs(i,j):\\n            if i == m-1 and j == n-1:\\n                return True\\n\\n            if (i == m or j == n or grid[i][j] == 0):\\n                return False\\n\\n            if (i+j): grid[i][j] = 0\\n\\n            return dfs(i+1,j) or dfs(i,j+1)\\n\\n\\n        if dfs(0,0) == False:\\n            return True\\n\\n        if dfs(0,0) == False:\\n            return True\\n\\n        return False\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n    \\n        def dfs(i,j):\\n            if i == m-1 and j == n-1:\\n                return True\\n\\n            if (i == m or j == n or grid[i][j] == 0):\\n                return False\\n\\n            if (i+j): grid[i][j] = 0\\n\\n            return dfs(i+1,j) or dfs(i,j+1)\\n\\n\\n        if dfs(0,0) == False:\\n            return True\\n\\n        if dfs(0,0) == False:\\n            return True\\n\\n        return False\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194247,
                "title": "python-double-bfs-independent-of-allowed-move-types-the-best",
                "content": "# Intuition\\nIf we look at fronts of BFS traversal from source to destination, the traversal can be disconnected by one flip if there is a front of length $$1$$, i.e. a bottleneck. However, paths that do not lead to destination must be ignored. This can be achieved by performing a backward traversal first, stopping the traversal when the source cell is reached, and afterwards in the second forward traversal ignoring cells that were unreachable in the first traversal.\\n\\nThe Best!\\n\\n# Approach\\nA generic BFS function is implemented that receives the following parameters:\\n- source and destination cells;\\n- allowed moves, expressed as delta values on cell row and column;\\n- cell value to consider as valid;\\n- new value for valid cells.\\n\\nThus, cell values are changed from $$1$$ to $$2$$ in first backward traversal, and afterwards from $$2$$ to $$3$$ in second forward traversal. During each traversal, BFS front bottleneck is detected when present, but it is considered only during the second traversal.\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n- Space complexity: $$O(m+n)$$, the maximal BFS front length\\n\\n# Code\\n```py\\ndef isPossibleToCutPath(self, grid: list[list[int]]) -> bool:\\n    def bfs(src, dst, deltas, before, after, detect):\\n        front, bottleneck, grid[src[0]][src[1]] = [src], False, after\\n        while front:\\n            newfront = []\\n            for r, c in front:\\n                for rn, cn in ((r+dr, c+dc) for dr, dc in deltas if 0 <= r+dr < m and\\n                                0 <= c+dc < n and grid[r+dr][c+dc] == before):\\n                    grid[rn][cn] = after\\n                    if (rn, cn) == dst:\\n                        return not detect or bottleneck\\n                    newfront.append((rn, cn))\\n            front, bottleneck = newfront, bottleneck | (len(newfront) == 1)\\n        return False\\n    \\n    if (m := len(grid)) == (n := len(grid[0])) == 1:\\n        return False\\n    return (not bfs((m-1, n-1), (0, 0), ((-1, 0), (0, -1)), 1, 2, False) or\\n            bfs((0, 0), (m-1, n-1), ((1, 0), (0, 1)), 2, 3, True))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef isPossibleToCutPath(self, grid: list[list[int]]) -> bool:\\n    def bfs(src, dst, deltas, before, after, detect):\\n        front, bottleneck, grid[src[0]][src[1]] = [src], False, after\\n        while front:\\n            newfront = []\\n            for r, c in front:\\n                for rn, cn in ((r+dr, c+dc) for dr, dc in deltas if 0 <= r+dr < m and\\n                                0 <= c+dc < n and grid[r+dr][c+dc] == before):\\n                    grid[rn][cn] = after\\n                    if (rn, cn) == dst:\\n                        return not detect or bottleneck\\n                    newfront.append((rn, cn))\\n            front, bottleneck = newfront, bottleneck | (len(newfront) == 1)\\n        return False\\n    \\n    if (m := len(grid)) == (n := len(grid[0])) == 1:\\n        return False\\n    return (not bfs((m-1, n-1), (0, 0), ((-1, 0), (0, -1)), 1, 2, False) or\\n            bfs((0, 0), (m-1, n-1), ((1, 0), (0, 1)), 2, 3, True))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3185019,
                "title": "c",
                "content": "```\\nbool DFS1(int** grid, int m, int n, int** data, int d_idx , int x, int y){\\n    if(x == m-1 && y == n-1)\\n        return true ;\\n    data[d_idx][0] = x ;\\n    data[d_idx][1] = y ;\\n    if((y+1) < n && grid[x][y+1] == 1 && DFS1(grid, m, n, data, d_idx+1, x, y+1))\\n        return true ;\\n    if((x+1) < m && grid[x+1][y] == 1 && DFS1(grid, m, n, data, d_idx+1, x+1, y))\\n        return true ;\\n    return false ;\\n}\\n\\nbool DFS2(int** grid, int m, int n, int** data, int d_idx , int x, int y){\\n    if(x == m-1 && y == n-1)\\n        return true ;\\n    data[d_idx][0] = x ;\\n    data[d_idx][1] = y ;\\n    if((x+1) < m && grid[x+1][y] == 1 && DFS2(grid, m, n, data, d_idx+1, x+1, y))\\n        return true ;\\n    \\n    if((y+1) < n && grid[x][y+1] == 1 && DFS2(grid, m, n, data, d_idx+1, x, y+1))\\n        return true ;\\n\\n    return false ;\\n}\\n\\n\\nbool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){\\n    int m = gridSize ;\\n    int n = *gridColSize ;\\n    if(m == 1 && n <= 2)\\n        return false ;\\n    if(n == 1 && m <= 2)\\n        return false ;\\n    \\n    if(n == 1 || m == 1)\\n        return true ;\\n    \\n    if(grid[0][1] == 0 || grid[1][0] == 0)\\n        return true ;\\n    \\n    if(grid[m-1][n-2] == 0 || grid[m-2][n-1] == 0) \\n        return true ;\\n    \\n    int N = m + n - 3 ;\\n    int** data1 = malloc(N * sizeof(int*)) ;\\n    int** data2 = malloc(N * sizeof(int*)) ;\\n    for(int i = 0; i < N; i++){\\n        data1[i] = malloc(2 * sizeof(int)) ;\\n        data2[i] = malloc(2 * sizeof(int)) ;\\n    }\\n    bool ans = false; \\n    bool up = DFS1(grid, m, n, data1, 0, 0, 1) ;\\n    if(up == false){\\n        ans = true ;\\n        goto exit ;\\n    }\\n    \\n    bool down = DFS2(grid, m, n, data2, 0, 1, 0) ;\\n    if(down == false){\\n        ans = true ;\\n        goto exit ;\\n    }\\n    \\n    for(int i = 0; i < m+n-3; i++){\\n        if(data1[i][0] == data2[i][0] && data1[i][1] == data2[i][1]){\\n            ans = true ;\\n            break ;\\n        }\\n    }\\n    exit :\\n    for(int i = 0; i < N; i++){\\n        free(data1[i]) ;\\n        free(data2[i]) ;\\n    }\\n    free(data1) ;\\n    free(data2) ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nbool DFS1(int** grid, int m, int n, int** data, int d_idx , int x, int y){\\n    if(x == m-1 && y == n-1)\\n        return true ;\\n    data[d_idx][0] = x ;\\n    data[d_idx][1] = y ;\\n    if((y+1) < n && grid[x][y+1] == 1 && DFS1(grid, m, n, data, d_idx+1, x, y+1))\\n        return true ;\\n    if((x+1) < m && grid[x+1][y] == 1 && DFS1(grid, m, n, data, d_idx+1, x+1, y))\\n        return true ;\\n    return false ;\\n}\\n\\nbool DFS2(int** grid, int m, int n, int** data, int d_idx , int x, int y){\\n    if(x == m-1 && y == n-1)\\n        return true ;\\n    data[d_idx][0] = x ;\\n    data[d_idx][1] = y ;\\n    if((x+1) < m && grid[x+1][y] == 1 && DFS2(grid, m, n, data, d_idx+1, x+1, y))\\n        return true ;\\n    \\n    if((y+1) < n && grid[x][y+1] == 1 && DFS2(grid, m, n, data, d_idx+1, x, y+1))\\n        return true ;\\n\\n    return false ;\\n}\\n\\n\\nbool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){\\n    int m = gridSize ;\\n    int n = *gridColSize ;\\n    if(m == 1 && n <= 2)\\n        return false ;\\n    if(n == 1 && m <= 2)\\n        return false ;\\n    \\n    if(n == 1 || m == 1)\\n        return true ;\\n    \\n    if(grid[0][1] == 0 || grid[1][0] == 0)\\n        return true ;\\n    \\n    if(grid[m-1][n-2] == 0 || grid[m-2][n-1] == 0) \\n        return true ;\\n    \\n    int N = m + n - 3 ;\\n    int** data1 = malloc(N * sizeof(int*)) ;\\n    int** data2 = malloc(N * sizeof(int*)) ;\\n    for(int i = 0; i < N; i++){\\n        data1[i] = malloc(2 * sizeof(int)) ;\\n        data2[i] = malloc(2 * sizeof(int)) ;\\n    }\\n    bool ans = false; \\n    bool up = DFS1(grid, m, n, data1, 0, 0, 1) ;\\n    if(up == false){\\n        ans = true ;\\n        goto exit ;\\n    }\\n    \\n    bool down = DFS2(grid, m, n, data2, 0, 1, 0) ;\\n    if(down == false){\\n        ans = true ;\\n        goto exit ;\\n    }\\n    \\n    for(int i = 0; i < m+n-3; i++){\\n        if(data1[i][0] == data2[i][0] && data1[i][1] == data2[i][1]){\\n            ans = true ;\\n            break ;\\n        }\\n    }\\n    exit :\\n    for(int i = 0; i < N; i++){\\n        free(data1[i]) ;\\n        free(data2[i]) ;\\n    }\\n    free(data1) ;\\n    free(data2) ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3180914,
                "title": "easy-understanding-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int n,int m,vector<vector<int>>& grid){\\n        if(i==n-1 && j==m-1){\\n            return 1;\\n        }\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==0){\\n            return 0;\\n        }\\n        int temp=grid[i][j];\\n        grid[i][j]=0;\\n        int t=dfs(i+1,j,n,m,grid);\\n        if(t==1){\\n            return t;\\n        }\\n        int t2=dfs(i,j+1,n,m,grid);\\n        if(t2){\\n            return t2;\\n        }\\n        grid[i][j]=temp;\\n        return t||t2;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(n==1 && m==1){\\n            return false;\\n        }\\n        if(n==1 && m==2){\\n            return false;\\n        }\\n        if(n==2 && m==1){\\n            return false;\\n        }\\n        if(n==1 || m==1){\\n            return true;\\n        }\\n        if(grid[1][0]==0 || grid[0][1]==0){\\n            return true;\\n        }\\n        if(grid[n-2][m-1]==0 || grid[n-1][m-2]==0){\\n            return true;\\n        }\\n        if(dfs(0,0,n,m,grid)==1){\\n            grid[0][0]=1;\\n            grid[n-1][m-1]=1;\\n            if(dfs(0,0,n,m,grid)==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int n,int m,vector<vector<int>>& grid){\\n        if(i==n-1 && j==m-1){\\n            return 1;\\n        }\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==0){\\n            return 0;\\n        }\\n        int temp=grid[i][j];\\n        grid[i][j]=0;\\n        int t=dfs(i+1,j,n,m,grid);\\n        if(t==1){\\n            return t;\\n        }\\n        int t2=dfs(i,j+1,n,m,grid);\\n        if(t2){\\n            return t2;\\n        }\\n        grid[i][j]=temp;\\n        return t||t2;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(n==1 && m==1){\\n            return false;\\n        }\\n        if(n==1 && m==2){\\n            return false;\\n        }\\n        if(n==2 && m==1){\\n            return false;\\n        }\\n        if(n==1 || m==1){\\n            return true;\\n        }\\n        if(grid[1][0]==0 || grid[0][1]==0){\\n            return true;\\n        }\\n        if(grid[n-2][m-1]==0 || grid[n-1][m-2]==0){\\n            return true;\\n        }\\n        if(dfs(0,0,n,m,grid)==1){\\n            grid[0][0]=1;\\n            grid[n-1][m-1]=1;\\n            if(dfs(0,0,n,m,grid)==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176063,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\n   bool valid(int i,int j)\\n   {\\n       if(i<0 || j<0 || i>=n || j>=m) return false;\\n       return true;\\n   }\\n    bool dfs(int i,int j,vector<vector<int>>& grid)\\n    {\\n        if (i==n-1 && j==m-1) return true;\\n        grid[i][j]=0;\\n        int dirx[]={0,1};\\n        int diry[]={1,0};\\n        for (int ind=0;ind<2;ind++)\\n        {\\n            int newi=i+dirx[ind];\\n            int newj=j+diry[ind];\\n            if (valid(newi,newj) && grid[newi][newj])\\n            {\\n                if (dfs(newi,newj,grid)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid)\\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n       if (!dfs(0,0,grid)) return true;\\n       if (!dfs(0,0,grid)) return true;\\n       return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\n   bool valid(int i,int j)\\n   {\\n       if(i<0 || j<0 || i>=n || j>=m) return false;\\n       return true;\\n   }\\n    bool dfs(int i,int j,vector<vector<int>>& grid)\\n    {\\n        if (i==n-1 && j==m-1) return true;\\n        grid[i][j]=0;\\n        int dirx[]={0,1};\\n        int diry[]={1,0};\\n        for (int ind=0;ind<2;ind++)\\n        {\\n            int newi=i+dirx[ind];\\n            int newj=j+diry[ind];\\n            if (valid(newi,newj) && grid[newi][newj])\\n            {\\n                if (dfs(newi,newj,grid)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid)\\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n       if (!dfs(0,0,grid)) return true;\\n       if (!dfs(0,0,grid)) return true;\\n       return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172923,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& grid, int i, int j){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        if(i < 0 || i >= row || j < 0 || j >= col || grid[i][j] == 0){\\n            return false;\\n        }\\n        // mark the cell visited\\n        grid[i][j] = 0;\\n        //check if the cell is reached\\n        if(i == row-1 && j == col-1){\\n            return true;\\n        }\\n        //explore all the path \\n        return dfs(grid,i+1,j) || dfs(grid,i,j+1);\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        if((row == 1 && col == 1) || (row == 1 && col == 2) || (row == 2 && col == 1)){\\n            return false;\\n        }\\n        //first call to mark all the cells that are reaching to the end. If no path is found that reaches to end then return true as they are already disconnected and if they are connected to end then simply change their cell value to 0 so that we don\\'t process those cells again and check if their exist another path by call dfs again.\\n        if(dfs(grid,0,0) == false){\\n            return true;\\n        }\\n        // reset the grid according to the constraint grid[0][0] && grid[row-1][col-1] == 1 and also using it to start a dfs call\\n        grid[0][0] = 1;\\n        grid[row-1][col-1] = 1;\\n        // calling dfs again to check if their exist another path that is reaching to end or not. If their exist a path then you can return false else return true. \\n        if(dfs(grid,0,0) == false){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& grid, int i, int j){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        if(i < 0 || i >= row || j < 0 || j >= col || grid[i][j] == 0){\\n            return false;\\n        }\\n        // mark the cell visited\\n        grid[i][j] = 0;\\n        //check if the cell is reached\\n        if(i == row-1 && j == col-1){\\n            return true;\\n        }\\n        //explore all the path \\n        return dfs(grid,i+1,j) || dfs(grid,i,j+1);\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        if((row == 1 && col == 1) || (row == 1 && col == 2) || (row == 2 && col == 1)){\\n            return false;\\n        }\\n        //first call to mark all the cells that are reaching to the end. If no path is found that reaches to end then return true as they are already disconnected and if they are connected to end then simply change their cell value to 0 so that we don\\'t process those cells again and check if their exist another path by call dfs again.\\n        if(dfs(grid,0,0) == false){\\n            return true;\\n        }\\n        // reset the grid according to the constraint grid[0][0] && grid[row-1][col-1] == 1 and also using it to start a dfs call\\n        grid[0][0] = 1;\\n        grid[row-1][col-1] = 1;\\n        // calling dfs again to check if their exist another path that is reaching to end or not. If their exist a path then you can return false else return true. \\n        if(dfs(grid,0,0) == false){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171884,
                "title": "c-dp-sln",
                "content": "If I assign MOD = 1\\'000\\'000\\'007 (big prime number which is often used in competetive programming) solution doesn\\'t work because of collision. But works with this one 1\\'000\\'012\\'337, that\\'s life..\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        const int n = size(grid);\\n        const int m = size(grid.front());\\n        using ll = long long;\\n        const ll MOD = 1\\'000\\'012\\'337;\\n\\n        const auto getPathsCountToStartPoint = [&]() {\\n            vector<vector<ll>> dp(n, vector<ll>(m, -1));\\n            dp[0][0] = 1;\\n            function<ll(int, int)> getOrCompute;\\n            getOrCompute = [&](int i, int j) {\\n                if (dp[i][j] != -1) {\\n                    return dp[i][j];\\n                }\\n                ll res = 0;\\n                if (i - 1 >= 0 && grid[i - 1][j]) {\\n                    res = (res + getOrCompute(i - 1, j)) % MOD;;\\n                }\\n                if (j - 1 >= 0 && grid[i][j - 1]) {\\n                    res = (res + getOrCompute(i, j - 1)) % MOD;;\\n                }\\n                return dp[i][j] = res;\\n            };\\n            getOrCompute(n - 1, m - 1);\\n            return dp;\\n        };\\n\\n        const auto getPathsCountToEndPoint = [&]() {\\n            vector<vector<ll>> dp(n, vector<ll>(m, -1));\\n            dp[n - 1][m - 1] = 1;\\n            function<ll(int, int)> getOrCompute;\\n            getOrCompute = [&](int i, int j) {\\n                if (dp[i][j] != -1) {\\n                    return dp[i][j];\\n                }\\n                ll res = 0;\\n                if (i + 1 < n && grid[i + 1][j]) {\\n                    res = (res + getOrCompute(i + 1, j)) % MOD;\\n                }\\n                if (j + 1 < m && grid[i][j + 1]) {\\n                    res = (res + getOrCompute(i, j + 1)) % MOD;\\n                }\\n                return dp[i][j] = res;\\n            };\\n            getOrCompute(0, 0);\\n            return dp;\\n        };\\n\\n        const auto dp1 = getPathsCountToEndPoint();\\n        const auto dp2 = getPathsCountToStartPoint();\\n        const auto pathsCount = dp1[0][0];\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (i == 0 && j == 0 || i == n - 1 && j == m - 1) {\\n                    continue;\\n                }\\n                if (dp1[i][j] * dp2[i][j] == pathsCount) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return pathsCount == 0;\\n    \\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        const int n = size(grid);\\n        const int m = size(grid.front());\\n        using ll = long long;\\n        const ll MOD = 1\\'000\\'012\\'337;\\n\\n        const auto getPathsCountToStartPoint = [&]() {\\n            vector<vector<ll>> dp(n, vector<ll>(m, -1));\\n            dp[0][0] = 1;\\n            function<ll(int, int)> getOrCompute;\\n            getOrCompute = [&](int i, int j) {\\n                if (dp[i][j] != -1) {\\n                    return dp[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3170026,
                "title": "my-solution",
                "content": "```\\n/**\\n * 1. try to find the bottom boundary,\\n *    and flip the cell of the bottom boundary if the cell has the value `1`.\\n * 2.1. if such a bottom boundary can not be found,\\n *      it means the matrix `grid` is disconnected,\\n *      return true\\n * 2.2. otherwise, try to find another path from the left-top point to the right-bottom point\\n * 2.2.1 if such a path exists,\\n *       it means the matrix `grid` is connected after any one point is flipped,\\n *       return false\\n * 2.2.2 otherwise, it means there exists a point on the bottom boundary, after it\\'s flipped,\\n *       the matrix `grid` is still disconnected\\n *       return true\\n *\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows + cols)\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  bool isPossibleToCutPath(vector<vector<int>> &grid) {\\n    return !dfs(grid, 0, 0) or !dfs(grid, 0, 0);\\n  }\\n  \\n private:\\n  bool dfs(vector<vector<int>> &grid, const int r, const int c) {\\n    constexpr int target = 1;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    if (r == rows - 1 && c == cols - 1) {\\n      return true;\\n    }\\n    \\n    if (!(r == 0 && c == 0) && !(r == rows - 1 && c == cols - 1)) {\\n      grid[r][c] ^= target;\\n    }\\n    \\n    return (r + 1 < rows && grid[r + 1][c] == target && dfs(grid, r + 1, c)) ||\\n      (c + 1 < cols && grid[r][c + 1] == target) && dfs(grid, r, c + 1);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * 1. try to find the bottom boundary,\\n *    and flip the cell of the bottom boundary if the cell has the value `1`.\\n * 2.1. if such a bottom boundary can not be found,\\n *      it means the matrix `grid` is disconnected,\\n *      return true\\n * 2.2. otherwise, try to find another path from the left-top point to the right-bottom point\\n * 2.2.1 if such a path exists,\\n *       it means the matrix `grid` is connected after any one point is flipped,\\n *       return false\\n * 2.2.2 otherwise, it means there exists a point on the bottom boundary, after it\\'s flipped,\\n *       the matrix `grid` is still disconnected\\n *       return true\\n *\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows + cols)\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  bool isPossibleToCutPath(vector<vector<int>> &grid) {\\n    return !dfs(grid, 0, 0) or !dfs(grid, 0, 0);\\n  }\\n  \\n private:\\n  bool dfs(vector<vector<int>> &grid, const int r, const int c) {\\n    constexpr int target = 1;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    if (r == rows - 1 && c == cols - 1) {\\n      return true;\\n    }\\n    \\n    if (!(r == 0 && c == 0) && !(r == rows - 1 && c == cols - 1)) {\\n      grid[r][c] ^= target;\\n    }\\n    \\n    return (r + 1 < rows && grid[r + 1][c] == target && dfs(grid, r + 1, c)) ||\\n      (c + 1 < cols && grid[r][c + 1] == target) && dfs(grid, r, c + 1);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167384,
                "title": "c-jucntion-or-not-simple-2-dfs",
                "content": "# Observation\\n- So my first observation is if there is not direct path from `0,0` to `n-1,m-1` so answer is simply true becoz the matrix is already disconnected\\n- What if there is path so in this case there are again two cases \\n- case1. if in matrix there is **junction** it means all the path which connects 0,0 and n-1,m-1 go through this point so we can make that point to \\'0\\' so the answer will be true beccoz we able to make matrix disconnected and for \\n- case2. so in this there is more than points which is reaching n-1,m-1   \\n\\n# Complexity\\n- Time complexity: $$O(N*M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool dfs(int i, int j, vector<vector<int>> &grid){\\n        if(i==grid.size()-1 && j==grid[0].size()-1){\\n            return true;\\n        }\\n        if(i>=grid.size() || j>=grid[0].size() || grid[i][j]==0){\\n            return false;\\n        }\\n        grid[i][j]=0;\\n        if(dfs(i+1,j,grid)){\\n            return true;\\n        }\\n        if(dfs(i,j+1,grid)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        if(!dfs(0,0,grid)){\\n            return true;\\n        }\\n\\n        grid[0][0]=1;\\n        return (!dfs(0,0,grid));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool dfs(int i, int j, vector<vector<int>> &grid){\\n        if(i==grid.size()-1 && j==grid[0].size()-1){\\n            return true;\\n        }\\n        if(i>=grid.size() || j>=grid[0].size() || grid[i][j]==0){\\n            return false;\\n        }\\n        grid[i][j]=0;\\n        if(dfs(i+1,j,grid)){\\n            return true;\\n        }\\n        if(dfs(i,j+1,grid)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        if(!dfs(0,0,grid)){\\n            return true;\\n        }\\n\\n        grid[0][0]=1;\\n        return (!dfs(0,0,grid));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163027,
                "title": "javascript-diagonal-count-84ms",
                "content": "```\\nconst isPossibleToCutPath = (g) => {\\n    let n = g.length, m = g[0].length, diagonals = Array(n + m - 1).fill(0);\\n    for (let i = 0; i < n; i++) {  // forward\\n        for (let j = 0; j < m; j++) {\\n            if (i == 0 && j == 0 || g[i][j] == 0) continue;\\n            if ((i == 0 || g[i - 1][j] == 0) && (j == 0 || g[i][j - 1] == 0)) g[i][j] = 0;\\n        }\\n    }\\n    for (let i = n - 1; i >= 0; i--) { // backward\\n        for (let j = m - 1; j >= 0; j--) {\\n            if (i == n - 1 && j == m - 1 || g[i][j] == 0) continue;\\n            if ((i == n - 1 || g[i + 1][j] == 0) && (j == m - 1 || g[i][j + 1] == 0)) g[i][j] = 0;\\n        }\\n    }\\n    // diagnonal count\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) diagonals[i + j] += g[i][j];\\n    }\\n    for (let i = 1; i < n + m - 2; i++) {\\n        if (diagonals[i] <= 1) return true;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\nconst isPossibleToCutPath = (g) => {\\n    let n = g.length, m = g[0].length, diagonals = Array(n + m - 1).fill(0);\\n    for (let i = 0; i < n; i++) {  // forward\\n        for (let j = 0; j < m; j++) {\\n            if (i == 0 && j == 0 || g[i][j] == 0) continue;\\n            if ((i == 0 || g[i - 1][j] == 0) && (j == 0 || g[i][j - 1] == 0)) g[i][j] = 0;\\n        }\\n    }\\n    for (let i = n - 1; i >= 0; i--) { // backward\\n        for (let j = m - 1; j >= 0; j--) {\\n            if (i == n - 1 && j == m - 1 || g[i][j] == 0) continue;\\n            if ((i == n - 1 || g[i + 1][j] == 0) && (j == m - 1 || g[i][j + 1] == 0)) g[i][j] = 0;\\n        }\\n    }\\n    // diagnonal count\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) diagonals[i + j] += g[i][j];\\n    }\\n    for (let i = 1; i < n + m - 2; i++) {\\n        if (diagonals[i] <= 1) return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3161631,
                "title": "simple-python-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou have explore the paths, this hould give an intuition that dfs and bfs could be the possible tools.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs per the question, we can flip only a cell at most.\\nSo answer will be True in the following cases:\\n1. If there is no path from (0, 0) to (m-1, n-1) => 0 flips required\\n2. If there is only one path from (0,0) to (m-1, n-1) => 1 flip required\\nSo if we somehow figure out that there are 2 paths, then the answer will be False.\\nSo just use dfs and make the first path go extinct, by turning 1 to 0(except the (0, 0) and (m-1, n-1)), so that any cell of this path can\\'t be used again.\\nThen again run dfs, and if you are able to reach (m-1, n-1), thisnmeans you have 2 distict paths available. Return False\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        def solve(i, j):\\n            if(i == m-1 and j == n-1):\\n                return True\\n            if(i == m or j == n or grid[i][j] == 0):\\n                return False\\n            if(i + j): grid[i][j] = 0\\n            return solve(i + 1, j) or solve(i, j + 1)\\n\\n        if(not solve(0, 0)): \\n            return True\\n        print(grid)\\n        if(not solve(0, 0)): \\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        def solve(i, j):\\n            if(i == m-1 and j == n-1):\\n                return True\\n            if(i == m or j == n or grid[i][j] == 0):\\n                return False\\n            if(i + j): grid[i][j] = 0\\n            return solve(i + 1, j) or solve(i, j + 1)\\n\\n        if(not solve(0, 0)): \\n            return True\\n        print(grid)\\n        if(not solve(0, 0)): \\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154708,
                "title": "one-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nMD ARHAM KALAM ANSARI\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,int m,vector<vector<int>> &v)\\n    {\\n        if(i==n-1 and j==m-1) return true;\\n        if(i>=n or j>=m) return false;\\n        if(v[i][j]==0) return false;\\n        v[i][j]=0;\\n        return check(i+1,j,n,m,v) or check(i,j+1,n,m,v);\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if(!check(0,0,n,m,grid)) return true;\\n        grid[0][0]=1;\\n        return check(0,0,n,m,grid)==false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nMD ARHAM KALAM ANSARI\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,int m,vector<vector<int>> &v)\\n    {\\n        if(i==n-1 and j==m-1) return true;\\n        if(i>=n or j>=m) return false;\\n        if(v[i][j]==0) return false;\\n        v[i][j]=0;\\n        return check(i+1,j,n,m,v) or check(i,j+1,n,m,v);\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if(!check(0,0,n,m,grid)) return true;\\n        grid[0][0]=1;\\n        return check(0,0,n,m,grid)==false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153736,
                "title": "2-pass-dfs-easy-solution",
                "content": "# Intuition\\nAs soon as we touch last row last cell, return true to caller immediately, without traversing any other path, setting the path as \"2\"\\nThen in second call we simply return cells with value \"2\" and if still from this call we touch the destination, that means we cannot disconnect.\\n\\n# Complexity\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar isPossibleToCutPath = function(grid) {\\n    \\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n\\n    if(rows === 1 && cols === 2 || rows === 2 && cols === 1)\\n        return false;\\n\\n    const directions = [[0,1], [1,0]];\\n    \\n    const inBounds = (r,c) => {\\n        if(r >= 0 && c >= 0 && r < rows && c < cols)\\n            return true;\\n        return false;\\n    }\\n\\n    const dfs = (currRow, currCol) => {\\n        if(currRow === rows - 1 && currCol === cols - 1) {\\n            return true;\\n        }\\n        \\n        grid[currRow][currCol] = 2;\\n        for(let j = 0; j < directions.length; j++) {\\n            let r = directions[j][0];\\n            let c = directions[j][1];\\n            \\n            let newRow = currRow + r;\\n            let newCol = currCol + c;\\n            \\n            if(!inBounds(newRow, newCol) || grid[newRow][newCol] === 2)\\n                continue;\\n            \\n            if(grid[newRow][newCol] === 1) {\\n                let temp = dfs(newRow, newCol);\\n                if(temp)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    let opt1 = dfs(0, 0);\\n    let opt2 = dfs(0, 0);\\n\\n    return opt1 && opt2 ? false : true;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar isPossibleToCutPath = function(grid) {\\n    \\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n\\n    if(rows === 1 && cols === 2 || rows === 2 && cols === 1)\\n        return false;\\n\\n    const directions = [[0,1], [1,0]];\\n    \\n    const inBounds = (r,c) => {\\n        if(r >= 0 && c >= 0 && r < rows && c < cols)\\n            return true;\\n        return false;\\n    }\\n\\n    const dfs = (currRow, currCol) => {\\n        if(currRow === rows - 1 && currCol === cols - 1) {\\n            return true;\\n        }\\n        \\n        grid[currRow][currCol] = 2;\\n        for(let j = 0; j < directions.length; j++) {\\n            let r = directions[j][0];\\n            let c = directions[j][1];\\n            \\n            let newRow = currRow + r;\\n            let newCol = currCol + c;\\n            \\n            if(!inBounds(newRow, newCol) || grid[newRow][newCol] === 2)\\n                continue;\\n            \\n            if(grid[newRow][newCol] === 1) {\\n                let temp = dfs(newRow, newCol);\\n                if(temp)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    let opt1 = dfs(0, 0);\\n    let opt2 = dfs(0, 0);\\n\\n    return opt1 && opt2 ? false : true;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3153414,
                "title": "javascript-dfs",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar isPossibleToCutPath = function (grid) {\\n  const n = grid.length;\\n  const m = grid[0].length;\\n  if (!dfs(grid, 0, 0, n, m)) return true;\\n\\n  grid[0][0] = 1;\\n  return !dfs(grid, 0, 0, n, m);\\n};\\n\\nfunction dfs(grid, i, j, n, m) {\\n  if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] === 0) return false;\\n  if (i === n - 1 && j === m - 1) return true;\\n\\n  grid[i][j] = 0;\\n  return dfs(grid, i + 1, j, n, m) || dfs(grid, i, j + 1, n, m);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar isPossibleToCutPath = function (grid) {\\n  const n = grid.length;\\n  const m = grid[0].length;\\n  if (!dfs(grid, 0, 0, n, m)) return true;\\n\\n  grid[0][0] = 1;\\n  return !dfs(grid, 0, 0, n, m);\\n};\\n\\nfunction dfs(grid, i, j, n, m) {\\n  if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] === 0) return false;\\n  if (i === n - 1 && j === m - 1) return true;\\n\\n  grid[i][j] = 0;\\n  return dfs(grid, i + 1, j, n, m) || dfs(grid, i, j + 1, n, m);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152926,
                "title": "easy-java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntially make one dfs call and make all zeros from the path. Then make one more call and if second path exists then answer is false else true. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Make DFS call starting from cell 0,0 to last cell and if not path exists then return true beacuse we no path exists.\\n- In the dfs call make flip all ones to zeros in the path.\\n- Then again make a dfs call supposing we flip the single cell in first call so there is no path for second call and if exists then answer is false else true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        \\n        // checking for first path if not exists then return true\\n        if(!hasPath(grid, 0, 0)){\\n            return true;\\n        }\\n\\n        // make the initial point again 1 for next turn\\n        grid[0][0] = 1;\\n\\n        // Again check if there is a path or not\\n        if(!hasPath(grid, 0, 0)){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n    \\n    public boolean hasPath(int[][] grid, int i, int j){\\n        \\n        // if i,j are out of the matrix then return false\\n        if(i == grid.length || j == grid[0].length){\\n            return false;\\n        }\\n        \\n        // if current cell is 0 then no path exixts so return false\\n        if(grid[i][j] == 0){\\n            return false;\\n        }\\n        \\n        // if reached the final cell then return true\\n        if(i == grid.length - 1 && j == grid[0].length - 1){\\n            return true;\\n        }\\n        \\n        // make the current cell 0 \\n        grid[i][j] = 0;\\n\\n        boolean r1 = hasPath(grid, i+1, j);\\n        if(r1){\\n            return true;\\n        }\\n        boolean r2 = hasPath(grid, i, j+1);\\n        \\n        return r1 || r2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        \\n        // checking for first path if not exists then return true\\n        if(!hasPath(grid, 0, 0)){\\n            return true;\\n        }\\n\\n        // make the initial point again 1 for next turn\\n        grid[0][0] = 1;\\n\\n        // Again check if there is a path or not\\n        if(!hasPath(grid, 0, 0)){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n    \\n    public boolean hasPath(int[][] grid, int i, int j){\\n        \\n        // if i,j are out of the matrix then return false\\n        if(i == grid.length || j == grid[0].length){\\n            return false;\\n        }\\n        \\n        // if current cell is 0 then no path exixts so return false\\n        if(grid[i][j] == 0){\\n            return false;\\n        }\\n        \\n        // if reached the final cell then return true\\n        if(i == grid.length - 1 && j == grid[0].length - 1){\\n            return true;\\n        }\\n        \\n        // make the current cell 0 \\n        grid[i][j] = 0;\\n\\n        boolean r1 = hasPath(grid, i+1, j);\\n        if(r1){\\n            return true;\\n        }\\n        boolean r2 = hasPath(grid, i, j+1);\\n        \\n        return r1 || r2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149853,
                "title": "python3-o-n-two-pass-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSet *used* is to mark all visited nodes that a path from src to dst. If we can find two different paths from src to dst, return False.\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n, used = len(grid), len(grid[0]), set()\\n        def dfs(x, y):\\n            nonlocal m, n\\n            if x == m - 1 and y == n - 1: return True\\n            if x + y: used.add((x, y))\\n            if x + 1 < m and grid[x + 1][y] and (x + 1, y) not in used and dfs(x + 1, y): return True\\n            if y + 1 < n and grid[x][y + 1] and (x, y + 1) not in used and dfs(x, y + 1): return True\\n            return False\\n        return not (dfs(0, 0) and dfs(0, 0))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n, used = len(grid), len(grid[0]), set()\\n        def dfs(x, y):\\n            nonlocal m, n\\n            if x == m - 1 and y == n - 1: return True\\n            if x + y: used.add((x, y))\\n            if x + 1 < m and grid[x + 1][y] and (x + 1, y) not in used and dfs(x + 1, y): return True\\n            if y + 1 < n and grid[x][y + 1] and (x, y + 1) not in used and dfs(x, y + 1): return True\\n            return False\\n        return not (dfs(0, 0) and dfs(0, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149664,
                "title": "go-dfs-twice",
                "content": "# Intuition\\nWe start from `(0,0)` and use DFS to reach the destination `(n-1, m-1)`.\\nIf it is not reachable, return `true` directly. \\nThen set the nodes on this path to `0`, it means that we don\\'t access `(n-1, m-1)` through this path, then DFS again. \\nIf it is still reachable, this means there are two unrelated paths in the matrix. We can\\'t make the matrix disconnect, return `false`.\\n\\n# Code\\n```\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n    m, n := len(grid), len(grid[0])\\n    cache := make(map[int]bool)  // key: 10000*i+j\\n    \\n    reachFirst := dfs(&grid, m, n, 0, 0, &cache)\\n    if !reachFirst { return true }\\n\\n    cache[10000] = true\\n    reachAgain := dfs(&grid, m, n, 0, 0, &cache)\\n\\n    if !reachAgain { return true }\\n    return false\\n}\\n\\nfunc dfs(grid *[][]int, m, n, i, j int, cache *map[int]bool) bool {\\n    // arrrive the destination\\n    if i == m-1 && j == n-1 { return true }\\n\\n    if _, ok := (*cache)[10000*i+j]; ok { return false }\\n\\n    reachable := false\\n    directions := [][]int{ []int{i+1, j}, []int{i, j+1} }\\n    for _, d := range(directions) {\\n        nxtI, nxtJ := d[0], d[1]\\n        if nxtI < m && nxtJ < n && (*grid)[nxtI][nxtJ] == 1 {\\n            if dfs(grid, m, n, nxtI, nxtJ, cache) { \\n                reachable = true\\n                break\\n            }\\n        }\\n    }\\n    if reachable { (*grid)[i][j] = 0 }\\n    // positon (i, j) can\\'t reach the destination\\n    if !reachable { (*cache)[10000*i+j] = false }\\n\\n    return reachable\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n    m, n := len(grid), len(grid[0])\\n    cache := make(map[int]bool)  // key: 10000*i+j\\n    \\n    reachFirst := dfs(&grid, m, n, 0, 0, &cache)\\n    if !reachFirst { return true }\\n\\n    cache[10000] = true\\n    reachAgain := dfs(&grid, m, n, 0, 0, &cache)\\n\\n    if !reachAgain { return true }\\n    return false\\n}\\n\\nfunc dfs(grid *[][]int, m, n, i, j int, cache *map[int]bool) bool {\\n    // arrrive the destination\\n    if i == m-1 && j == n-1 { return true }\\n\\n    if _, ok := (*cache)[10000*i+j]; ok { return false }\\n\\n    reachable := false\\n    directions := [][]int{ []int{i+1, j}, []int{i, j+1} }\\n    for _, d := range(directions) {\\n        nxtI, nxtJ := d[0], d[1]\\n        if nxtI < m && nxtJ < n && (*grid)[nxtI][nxtJ] == 1 {\\n            if dfs(grid, m, n, nxtI, nxtJ, cache) { \\n                reachable = true\\n                break\\n            }\\n        }\\n    }\\n    if reachable { (*grid)[i][j] = 0 }\\n    // positon (i, j) can\\'t reach the destination\\n    if !reachable { (*cache)[10000*i+j] = false }\\n\\n    return reachable\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149597,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>> &grid, int i, int j){ \\n        if(i+1 == grid.size() && j+1 == grid[0].size()) return true;\\n        if(i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return false;\\n        grid[i][j] = 0;\\n        return dfs(grid, i+1, j) || dfs(grid, i, j+1);\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) { \\n        if(dfs(grid, 0, 0) == false) return true;\\n        grid[0][0] = 1;\\n        return !dfs(grid, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>> &grid, int i, int j){ \\n        if(i+1 == grid.size() && j+1 == grid[0].size()) return true;\\n        if(i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return false;\\n        grid[i][j] = 0;\\n        return dfs(grid, i+1, j) || dfs(grid, i, j+1);\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) { \\n        if(dfs(grid, 0, 0) == false) return true;\\n        grid[0][0] = 1;\\n        return !dfs(grid, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149503,
                "title": "one-pass-simple-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind how many cells are in each BFS level, if excluding start cell and end cell,  there is at least one BFS level containing only one cell, then it\\'s flippable.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS to group cells in to levels\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) one pass\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        \\n        if(grid.length == 1 && Arrays.equals(grid[0], new int[]{1,1}))\\n            return false;\\n\\n        int count = 0;\\n        int m =grid.length;\\n        int n = grid[0].length;\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n\\n        int[][] dir = new int[][]{{0,1},{0,-1},{-1,0},{1,0}};\\n        int level = 0;\\n        boolean[][] checked = new boolean[m][n];\\n        checked[0][0]=true;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            System.out.println(size);\\n            if(level !=0 && size ==1){\\n                count++;\\n            }\\n            level++;\\n            for(int i = 0;i<size;i++){\\n                int[] curr = q.poll();\\n                for(int k = 0;k<dir.length;k++){\\n                    int newx = curr[0]+dir[k][0];\\n                    int newy = curr[1]+dir[k][1];\\n                    if(newx>=0 &&newy>=0 && newx<m&&newy<n &&!checked[newx][newy]&&grid[newx][newy]==1){\\n                        if(newx == m-1 && newy == n-1){\\n                            return count >= 1;\\n                        }\\n                        q.add(new int[]{newx,newy});\\n                        checked[newx][newy]=true;\\n                    }\\n                }\\n            }\\n\\n        } \\n        return true;\\n    }\\n}\\n\\n// [1,0,0,0,0,0,0,0,0,0,0,0,0],\\n// [1,1,1,0,0,0,0,0,0,0,0,0,0],\\n// [0,0,1,1,1,0,0,0,0,0,0,0,0],\\n// [0,0,0,0,1,1,0,0,0,0,0,0,0],\\n// [0,0,0,0,0,1,1,0,0,0,0,0,0],\\n// [0,0,0,0,0,0,1,0,0,0,0,0,0],\\n// [0,0,0,0,0,0,1,0,0,0,0,0,0],\\n// [0,0,0,0,0,0,1,1,0,0,0,0,0],\\n// [0,0,0,0,0,0,0,1,1,0,0,0,0],\\n// [0,0,0,0,0,0,0,0,1,0,0,0,0],\\n// [0,0,0,0,0,0,0,0,1,0,0,0,0],\\n// [0,0,0,0,0,0,0,0,1,1,1,1,1]\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        \\n        if(grid.length == 1 && Arrays.equals(grid[0], new int[]{1,1}))\\n            return false;\\n\\n        int count = 0;\\n        int m =grid.length;\\n        int n = grid[0].length;\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n\\n        int[][] dir = new int[][]{{0,1},{0,-1},{-1,0},{1,0}};\\n        int level = 0;\\n        boolean[][] checked = new boolean[m][n];\\n        checked[0][0]=true;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            System.out.println(size);\\n            if(level !=0 && size ==1){\\n                count++;\\n            }\\n            level++;\\n            for(int i = 0;i<size;i++){\\n                int[] curr = q.poll();\\n                for(int k = 0;k<dir.length;k++){\\n                    int newx = curr[0]+dir[k][0];\\n                    int newy = curr[1]+dir[k][1];\\n                    if(newx>=0 &&newy>=0 && newx<m&&newy<n &&!checked[newx][newy]&&grid[newx][newy]==1){\\n                        if(newx == m-1 && newy == n-1){\\n                            return count >= 1;\\n                        }\\n                        q.add(new int[]{newx,newy});\\n                        checked[newx][newy]=true;\\n                    }\\n                }\\n            }\\n\\n        } \\n        return true;\\n    }\\n}\\n\\n// [1,0,0,0,0,0,0,0,0,0,0,0,0],\\n// [1,1,1,0,0,0,0,0,0,0,0,0,0],\\n// [0,0,1,1,1,0,0,0,0,0,0,0,0],\\n// [0,0,0,0,1,1,0,0,0,0,0,0,0],\\n// [0,0,0,0,0,1,1,0,0,0,0,0,0],\\n// [0,0,0,0,0,0,1,0,0,0,0,0,0],\\n// [0,0,0,0,0,0,1,0,0,0,0,0,0],\\n// [0,0,0,0,0,0,1,1,0,0,0,0,0],\\n// [0,0,0,0,0,0,0,1,1,0,0,0,0],\\n// [0,0,0,0,0,0,0,0,1,0,0,0,0],\\n// [0,0,0,0,0,0,0,0,1,0,0,0,0],\\n// [0,0,0,0,0,0,0,0,1,1,1,1,1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149080,
                "title": "extension",
                "content": "So how would you go about solving this if you can move in all 4 directions? I don\\'t think the diagonal idea would work in this case, but correct me if I\\'m wrong. I think you\\'d have to find the articulation point directly.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3148736,
                "title": "c-bfs-one-pass",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<vector<int>> q;\\n        q.push({0, 0});\\n        vector<int> f = {0, 0};\\n        vector<int> l = {m-1, n-1};\\n        while(!q.empty()) {\\n            int z = q.size();\\n            if (z==1 && q.front()!=l && q.front()!=f)\\n                return true;\\n            while(z--) {\\n                int i = q.front()[0];\\n                int j = q.front()[1];\\n                q.pop();\\n                if (i+1<m && grid[i+1][j]) {\\n                    grid[i+1][j]=0;\\n                    q.push({i+1, j});\\n                }\\n                if (j+1<n && grid[i][j+1]) {\\n                    grid[i][j+1]=0;\\n                    q.push({i, j+1});\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1]!=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<vector<int>> q;\\n        q.push({0, 0});\\n        vector<int> f = {0, 0};\\n        vector<int> l = {m-1, n-1};\\n        while(!q.empty()) {\\n            int z = q.size();\\n            if (z==1 && q.front()!=l && q.front()!=f)\\n                return true;\\n            while(z--) {\\n                int i = q.front()[0];\\n                int j = q.front()[1];\\n                q.pop();\\n                if (i+1<m && grid[i+1][j]) {\\n                    grid[i+1][j]=0;\\n                    q.push({i+1, j});\\n                }\\n                if (j+1<n && grid[i][j+1]) {\\n                    grid[i][j+1]=0;\\n                    q.push({i, j+1});\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1]!=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148003,
                "title": "o-m-n-1-pass-proper-solution-works-in-all-cases",
                "content": "# Intuition\\nThe last cell has two neighbors and we need to make sure that they are reachable through paths that cannot be both interrupted at the same point.\\n\\n# Approach\\nWe can move in two directions from the starting point.  Let\\'s color the points in the first direction (right) as 1 and in the second direction (down) as 2.  Now lets scan the rest of the grid.  Every non-zero cell has two potential neighbours from which it can be reached.  If both neighbors are 0, the cell is not reachable, so we mark it as such.  If only one neighbor is 0, the cell inherits the color of the non-zero neighbor.  If both neighbors are non-zero and are the same, we propagate their color.  Finally, if the two neighbors are different, we create a new color and use it for our cell (it becomes a new potential flip point for all its descendants).  In the end we check the two neighbors of the final cell -- if at least one of them is 0 or if they are both the same color, then the matrix can be disconnected at one point.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1).  This is in place -- we could modify the algorithm easily to make the input matrix restorable.\\n\\n# Code\\n```\\nbool isPossibleToCutPath(vector<vector<int>>& g) {\\n    int n=g.size(), m=g[0].size(), cur=2;\\n    if (m==1 || n==1) return m+n>3; // edge case\\n\\n    for (int i=1; i<=n-1; i++) // propagate 2 down\\n        g[i][0]=g[i][0]>0 && g[i-1][0]>0 ? 2:0;\\n    for (int j=1; j<=m-1; j++) // propagate 1 right\\n        g[0][j]=g[0][j]>0 && g[0][j-1]>0 ? 1:0;\\n    for (int i=1; i<=n-1; i++) {\\n        for (int j=1; j<=m-1; j++) {\\n            if (g[i][j]>0) {\\n                if (g[i-1][j]==g[i][j-1]) \\n                    g[i][j]=g[i-1][j]; \\n                else {\\n                    if (g[i-1][j]!=0 && g[i][j-1]!=0)\\n                        g[i][j]=++cur;\\n                    else\\n                        g[i][j]=g[i-1][j] + g[i][j-1]; // one of them is 0\\n                }\\n            }\\n        }\\n    }  \\n    return g[n-2][m-1]==g[n-1][m-2] || g[n-2][m-1]==0 || g[n-1][m-2]==0;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isPossibleToCutPath(vector<vector<int>>& g) {\\n    int n=g.size(), m=g[0].size(), cur=2;\\n    if (m==1 || n==1) return m+n>3; // edge case\\n\\n    for (int i=1; i<=n-1; i++) // propagate 2 down\\n        g[i][0]=g[i][0]>0 && g[i-1][0]>0 ? 2:0;\\n    for (int j=1; j<=m-1; j++) // propagate 1 right\\n        g[0][j]=g[0][j]>0 && g[0][j-1]>0 ? 1:0;\\n    for (int i=1; i<=n-1; i++) {\\n        for (int j=1; j<=m-1; j++) {\\n            if (g[i][j]>0) {\\n                if (g[i-1][j]==g[i][j-1]) \\n                    g[i][j]=g[i-1][j]; \\n                else {\\n                    if (g[i-1][j]!=0 && g[i][j-1]!=0)\\n                        g[i][j]=++cur;\\n                    else\\n                        g[i][j]=g[i-1][j] + g[i][j-1]; // one of them is 0\\n                }\\n            }\\n        }\\n    }  \\n    return g[n-2][m-1]==g[n-1][m-2] || g[n-2][m-1]==0 || g[n-1][m-2]==0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3146545,
                "title": "2-dfs-easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(int x, int y, vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[0].size();\\n\\n        if(x == n - 1 && y == m - 1)  return true;\\n\\n        if(x + 1 < n && grid[x + 1][y] > 0){\\n            grid[x][y] = -1;\\n            if(dfs(x + 1, y, grid)) return true;\\n            grid[x][y] = -1;\\n        }\\n        if(y + 1 < m && grid[x][y + 1] > 0){\\n            grid[x][y] = -1;\\n            if(dfs(x,y + 1, grid)) return true;\\n            grid[x][y] = -1;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        dfs(0, 0, grid);\\n        return !dfs(0, 0, grid);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(int x, int y, vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[0].size();\\n\\n        if(x == n - 1 && y == m - 1)  return true;\\n\\n        if(x + 1 < n && grid[x + 1][y] > 0){\\n            grid[x][y] = -1;\\n            if(dfs(x + 1, y, grid)) return true;\\n            grid[x][y] = -1;\\n        }\\n        if(y + 1 < m && grid[x][y + 1] > 0){\\n            grid[x][y] = -1;\\n            if(dfs(x,y + 1, grid)) return true;\\n            grid[x][y] = -1;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        dfs(0, 0, grid);\\n        return !dfs(0, 0, grid);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146446,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(m+n)\\n# Code\\n```\\nbool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){\\n    \\n    int *tmp = malloc(sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    memset(tmp, 0, sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    \\n    int i,j;\\n    \\n    tmp[0] = 1;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            \\n            if (i == 0 && j == 0) {\\n                continue;\\n            }\\n            if ((grid[i][j] == 1) && tmp[i + j -1] != 0) {\\n                tmp[i + j] += 1;\\n            }\\n        }\\n    }\\n    \\n    for (i = 1; i < gridSize + gridColSize[0] - 2; i++) {\\n        if (tmp[i] <= 1) {\\n            printf(\"%d\\\\r\\\\n\", i);\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){\\n    \\n    int *tmp = malloc(sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    memset(tmp, 0, sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    \\n    int i,j;\\n    \\n    tmp[0] = 1;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            \\n            if (i == 0 && j == 0) {\\n                continue;\\n            }\\n            if ((grid[i][j] == 1) && tmp[i + j -1] != 0) {\\n                tmp[i + j] += 1;\\n            }\\n        }\\n    }\\n    \\n    for (i = 1; i < gridSize + gridColSize[0] - 2; i++) {\\n        if (tmp[i] <= 1) {\\n            printf(\"%d\\\\r\\\\n\", i);\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3146058,
                "title": "solution",
                "content": "```C++ []\\nstatic auto speedup = []() {\\n    ios_base::sync_with_stdio(false);\\n    cout.tie(NULL);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\n\\nclass Solution {\\n    int maxX, maxY;\\n    bool canReachEnd = false;\\n    vector<vector<int>> grid;\\n    void dfs(int x = 0, int y = 0) {\\n        if (canReachEnd) return;\\n        if (x == maxX && y == maxY) {\\n            canReachEnd = true;\\n            return;\\n        }\\n        grid[y][x] = 0;\\n        if (y < maxY && grid[y + 1][x]) dfs(x, y + 1);\\n        if (x < maxX && grid[y][x + 1]) dfs(x + 1, y);\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>> &tmp) {\\n        swap(grid, tmp);\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        dfs(0, 0);\\n        if (!canReachEnd) return true;\\n        canReachEnd = false;\\n        dfs(0, 0);\\n        return !canReachEnd;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n\\n        def has_path(i: int = 0, j: int = 0) -> bool:\\n\\n            if i == m or j == n:\\n                return False\\n            if grid[i][j] == 0:\\n                return False\\n            if i == m-1 and j == n-1:\\n                return True\\n\\n            grid[i][j] = 0\\n\\n            return has_path(i+1, j) or has_path(i, j+1)\\n\\n        if not has_path():\\n            return True\\n\\n        grid[0][0] = 1\\n        return not has_path()\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int first=dfs(grid,0,0);\\n        grid[0][0]=1;\\n        int second=dfs(grid,0,0);\\n        return second >= 1 ? false : true;\\n    }\\n    \\n    private int dfs(int[][] g, int r, int c) {\\n        if(r == g.length-1 && c == g[0].length-1)\\n            return 1;\\n        if(r == g.length || c == g[0].length || g[r][c] == 0)\\n            return 0;\\n        \\n        g[r][c]=0;\\n        if(dfs(g,r+1,c) == 1)\\n            return 1;\\n        return dfs(g,r,c+1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstatic auto speedup = []() {\\n    ios_base::sync_with_stdio(false);\\n    cout.tie(NULL);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\n\\nclass Solution {\\n    int maxX, maxY;\\n    bool canReachEnd = false;\\n    vector<vector<int>> grid;\\n    void dfs(int x = 0, int y = 0) {\\n        if (canReachEnd) return;\\n        if (x == maxX && y == maxY) {\\n            canReachEnd = true;\\n            return;\\n        }\\n        grid[y][x] = 0;\\n        if (y < maxY && grid[y + 1][x]) dfs(x, y + 1);\\n        if (x < maxX && grid[y][x + 1]) dfs(x + 1, y);\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>> &tmp) {\\n        swap(grid, tmp);\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        dfs(0, 0);\\n        if (!canReachEnd) return true;\\n        canReachEnd = false;\\n        dfs(0, 0);\\n        return !canReachEnd;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n\\n        def has_path(i: int = 0, j: int = 0) -> bool:\\n\\n            if i == m or j == n:\\n                return False\\n            if grid[i][j] == 0:\\n                return False\\n            if i == m-1 and j == n-1:\\n                return True\\n\\n            grid[i][j] = 0\\n\\n            return has_path(i+1, j) or has_path(i, j+1)\\n\\n        if not has_path():\\n            return True\\n\\n        grid[0][0] = 1\\n        return not has_path()\\n```\n```Java []\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int first=dfs(grid,0,0);\\n        grid[0][0]=1;\\n        int second=dfs(grid,0,0);\\n        return second >= 1 ? false : true;\\n    }\\n    \\n    private int dfs(int[][] g, int r, int c) {\\n        if(r == g.length-1 && c == g[0].length-1)\\n            return 1;\\n        if(r == g.length || c == g[0].length || g[r][c] == 0)\\n            return 0;\\n        \\n        g[r][c]=0;\\n        if(dfs(g,r+1,c) == 1)\\n            return 1;\\n        return dfs(g,r,c+1);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3145938,
                "title": "dfs-beats-100-time-and-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int visitCount = 0;\\n    int[][] grid;\\n    boolean[][] visited ;\\n    private boolean dfs(int i, int j){\\n        if(i == grid.length || j == grid[0].length) return false;\\n        if(grid[i][j] == 0 || visited[i][j]) return false;\\n        if(i == grid.length -1 && j ==  grid[0].length - 1){\\n            visitCount ++ ;\\n            return true; \\n        }\\n        visited[i][j] = true;\\n        if(!dfs(i+1,j) || (i == 0 && j == 0)){\\n            return dfs(i,j+1);    \\n        }\\n        return true;\\n    }\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if(grid.length * grid[0].length == 2) return false;\\n        visited = new boolean[grid.length][grid[0].length];\\n        this.grid = grid;\\n        dfs(0,0);\\n        return visitCount <= 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int visitCount = 0;\\n    int[][] grid;\\n    boolean[][] visited ;\\n    private boolean dfs(int i, int j){\\n        if(i == grid.length || j == grid[0].length) return false;\\n        if(grid[i][j] == 0 || visited[i][j]) return false;\\n        if(i == grid.length -1 && j ==  grid[0].length - 1){\\n            visitCount ++ ;\\n            return true; \\n        }\\n        visited[i][j] = true;\\n        if(!dfs(i+1,j) || (i == 0 && j == 0)){\\n            return dfs(i,j+1);    \\n        }\\n        return true;\\n    }\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        if(grid.length * grid[0].length == 2) return false;\\n        visited = new boolean[grid.length][grid[0].length];\\n        this.grid = grid;\\n        dfs(0,0);\\n        return visitCount <= 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145842,
                "title": "count-paths-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int [][] dp;\\n    int [][] dp2;\\n    int m,n;\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        m = grid.length; \\n        n = grid[0].length;\\n        dp = new int[m][n];\\n        dp2 = new int[m][n];\\n        makeMatrix(grid);\\n        makeMatrix2(grid);\\n        int totalPaths = dp[0][0];\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(!(i==0 && j==0) && !(i==m-1 && j==n-1) && dp[i][j] * dp2[i][j]==totalPaths)return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public void makeMatrix(int [][] grid){\\n        dp[m-1][n-1] = 1;\\n        for(int i = n-2;i>=0;i--){\\n            if(dp[m-1][i + 1]==1 && grid[m-1][i]==1)dp[m-1][i] = 1;\\n        }\\n        for(int i = m-2;i>=0;i--){\\n            if(dp[i + 1][n-1]==1 && grid[i][n-1]==1)dp[i][n-1] = 1;\\n        }\\n        for(int i = m-2;i>=0;i--){\\n            for(int j = n-2;j>=0;j--){\\n                if(grid[i][j]==1){\\n                    if(dp[i+1][j]!=0)dp[i][j]+=dp[i+1][j];\\n                    if(dp[i][j+1]!=0)dp[i][j]+=dp[i][j+1];\\n                }\\n            }\\n        }\\n    }\\n\\n    public void makeMatrix2(int [][] grid){\\n        dp2[0][0] = 1;\\n        for(int i = 1;i<n;i++){\\n            if(dp2[0][i - 1]==1 && grid[0][i]==1)dp2[0][i] = 1;\\n        }\\n        for(int i = 1;i<m;i++){\\n            if(dp2[i - 1][0]==1 && grid[i][0]==1)dp2[i][0] = 1;\\n        }\\n        for(int i = 1;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                if(grid[i][j]==1){\\n                    if(dp2[i-1][j]!=0)dp2[i][j]+=dp2[i-1][j];\\n                    if(dp2[i][j-1]!=0)dp2[i][j]+=dp2[i][j-1];\\n                }\\n            }\\n        }\\n    }\\n\\n    public void printMatrix(int [][] matrix){\\n        for(int []a:matrix){\\n            for(int b:a)System.out.print(b + \" \");\\n            System.out.println();\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int [][] dp;\\n    int [][] dp2;\\n    int m,n;\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        m = grid.length; \\n        n = grid[0].length;\\n        dp = new int[m][n];\\n        dp2 = new int[m][n];\\n        makeMatrix(grid);\\n        makeMatrix2(grid);\\n        int totalPaths = dp[0][0];\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(!(i==0 && j==0) && !(i==m-1 && j==n-1) && dp[i][j] * dp2[i][j]==totalPaths)return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public void makeMatrix(int [][] grid){\\n        dp[m-1][n-1] = 1;\\n        for(int i = n-2;i>=0;i--){\\n            if(dp[m-1][i + 1]==1 && grid[m-1][i]==1)dp[m-1][i] = 1;\\n        }\\n        for(int i = m-2;i>=0;i--){\\n            if(dp[i + 1][n-1]==1 && grid[i][n-1]==1)dp[i][n-1] = 1;\\n        }\\n        for(int i = m-2;i>=0;i--){\\n            for(int j = n-2;j>=0;j--){\\n                if(grid[i][j]==1){\\n                    if(dp[i+1][j]!=0)dp[i][j]+=dp[i+1][j];\\n                    if(dp[i][j+1]!=0)dp[i][j]+=dp[i][j+1];\\n                }\\n            }\\n        }\\n    }\\n\\n    public void makeMatrix2(int [][] grid){\\n        dp2[0][0] = 1;\\n        for(int i = 1;i<n;i++){\\n            if(dp2[0][i - 1]==1 && grid[0][i]==1)dp2[0][i] = 1;\\n        }\\n        for(int i = 1;i<m;i++){\\n            if(dp2[i - 1][0]==1 && grid[i][0]==1)dp2[i][0] = 1;\\n        }\\n        for(int i = 1;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                if(grid[i][j]==1){\\n                    if(dp2[i-1][j]!=0)dp2[i][j]+=dp2[i-1][j];\\n                    if(dp2[i][j-1]!=0)dp2[i][j]+=dp2[i][j-1];\\n                }\\n            }\\n        }\\n    }\\n\\n    public void printMatrix(int [][] matrix){\\n        for(int []a:matrix){\\n            for(int b:a)System.out.print(b + \" \");\\n            System.out.println();\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145808,
                "title": "java-o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find at least two disjoint path in order to prove the path cannot be cut.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first path start from the cell ```(1, 0)``` and the second starts\\nfrom the cell ```(0, 1)```.\\nAs we move through th first path we mark all the visited cells with ```0``` because the second path should not go through it.\\nIf we can find two disjoint path we return ```false```, otherwise ```true```.\\nAnd for the special cases of ```m x n``` which are ```1 x 1```, ```1 x 2``` and ```2 x 1```\\nwe simply return ```false```.\\n\\n# Complexity\\n- Time complexity: $$O(m+n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToReachEnd(int[][] grid) {\\n        boolean down = grid.length > 1 && grid[1][0] == 1 && \\n                isPossibleToReachEnd(grid, 1, 0);\\n        boolean right = grid[0].length > 1 && grid[0][1] == 1 && \\n                isPossibleToReachEnd(grid, 0, 1);\\n        return !(grid.length + grid[0].length <= 3 || down && right);\\n    }\\n\\n    private boolean isPossibleToReachEnd(int[][] grid, int i, int j) {\\n        if (i == grid.length - 1 && j == grid[0].length - 1) return true;\\n        grid[i][j] = 0;\\n        if (i < grid.length - 1 && grid[i + 1][j] == 1 && \\n                isPossibleToReachEnd(grid, i + 1, j)) return true;\\n        return j < grid[0].length - 1 && grid[i][j + 1] == 1 && \\n                isPossibleToReachEnd(grid, i, j + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```(1, 0)```\n```(0, 1)```\n```0```\n```false```\n```true```\n```m x n```\n```1 x 1```\n```1 x 2```\n```2 x 1```\n```false```\n```\\nclass Solution {\\n    public boolean isPossibleToReachEnd(int[][] grid) {\\n        boolean down = grid.length > 1 && grid[1][0] == 1 && \\n                isPossibleToReachEnd(grid, 1, 0);\\n        boolean right = grid[0].length > 1 && grid[0][1] == 1 && \\n                isPossibleToReachEnd(grid, 0, 1);\\n        return !(grid.length + grid[0].length <= 3 || down && right);\\n    }\\n\\n    private boolean isPossibleToReachEnd(int[][] grid, int i, int j) {\\n        if (i == grid.length - 1 && j == grid[0].length - 1) return true;\\n        grid[i][j] = 0;\\n        if (i < grid.length - 1 && grid[i + 1][j] == 1 && \\n                isPossibleToReachEnd(grid, i + 1, j)) return true;\\n        return j < grid[0].length - 1 && grid[i][j + 1] == 1 && \\n                isPossibleToReachEnd(grid, i, j + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145707,
                "title": "2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif diagonal sum is 2 in 2x2 grid and we flip one 1, there will always be path from second 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif any digonal sum in grid is <=1 then it can be flipped with 0 using atmost one flip to make grid disconnected\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m+n)\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[] temp=new int[m+n-1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp[i+j]+=grid[i][j];\\n            }\\n        }\\n        for(int i=1;i<temp.length-1;i++){\\n            if(temp[i]<=1)return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[] temp=new int[m+n-1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp[i+j]+=grid[i][j];\\n            }\\n        }\\n        for(int i=1;i<temp.length-1;i++){\\n            if(temp[i]<=1)return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145550,
                "title": "easy-c-solution",
                "content": "```\\n\\n// just checking the number of nodes we can go through for each level of distance if it is <=1 then it\\'s possible to make the grid disconnected.\\n\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        map<int,int>mp;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        mp[0]++;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0)),dist(n,vector<int>(m,0));\\n        vis[0][0]=1;\\n        int dx[]={1,0};\\n        int dy[]={0,1};\\n        while(!q.empty()){\\n            int curx=q.front().first;\\n            int cury=q.front().second;\\n            q.pop();\\n            for(int i=0;i<2;i++){\\n                int newx=curx+dx[i];\\n                int newy=cury+dy[i];\\n                if(newx<n&&newy<m&&grid[newx][newy]==1&&!vis[newx][newy]){\\n                    vis[newx][newy]=1;\\n                    dist[newx][newy]=dist[curx][cury]+1;\\n                    mp[dist[newx][newy]]++;\\n                    q.push({newx,newy});\\n                }\\n            }\\n        }\\n        \\n      \\n        for(int i=1;i<(n+m-2);i++){\\n            if(mp.find(i)==mp.end())return true;\\n            if(mp[i]<=1)return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\n// just checking the number of nodes we can go through for each level of distance if it is <=1 then it\\'s possible to make the grid disconnected.\\n\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        map<int,int>mp;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        mp[0]++;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0)),dist(n,vector<int>(m,0));\\n        vis[0][0]=1;\\n        int dx[]={1,0};\\n        int dy[]={0,1};\\n        while(!q.empty()){\\n            int curx=q.front().first;\\n            int cury=q.front().second;\\n            q.pop();\\n            for(int i=0;i<2;i++){\\n                int newx=curx+dx[i];\\n                int newy=cury+dy[i];\\n                if(newx<n&&newy<m&&grid[newx][newy]==1&&!vis[newx][newy]){\\n                    vis[newx][newy]=1;\\n                    dist[newx][newy]=dist[curx][cury]+1;\\n                    mp[dist[newx][newy]]++;\\n                    q.push({newx,newy});\\n                }\\n            }\\n        }\\n        \\n      \\n        for(int i=1;i<(n+m-2);i++){\\n            if(mp.find(i)==mp.end())return true;\\n            if(mp[i]<=1)return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145258,
                "title": "easy-dp",
                "content": "# Intuition\\n1. dp1[i][j]=count of all paths from ( 0 , 0 ) to ( i , j ).\\n1. dp2[i][j]=count of all paths from ( m-1, n-1 )   to ( i , j )\\n\\n# Approach\\n1. If there exist any cell ( i , j ) such that all paths from ( 0 , 0 ) to (m-1 , n-1 ) goes through it then flipping that cell to 0 will lead to disconnecyted matrix\\n2. Now can we find out which cell has this property. Yes we can..\\n3. dp1[i][j]*dp2[i][j]==dp1[m-1][n-1] this will check if there is any cell which satisfies above property.\\n4. **Corner case**- if there is not path from ( 0 , 0 ) to (m-1 , n-1 )\\n5. for that dp1[m-1][n-1]=0 and dp1[m-1][n-1]=0 LHS=RHS\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(M*N) for traversing grid\\n\\n- Space complexity:\\nO(M*N) for stroing dp states.\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        dp1 = [[0 for _ in range(n)] for _ in range(m)]\\n\\n        \\n        # this calculates all paths from 0,0 to i,j\\n        dp1[0][0] = 1\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    if i-1 >= 0:\\n                        dp1[i][j] += dp1[i-1][j]\\n                    if j-1 >= 0:\\n                        dp1[i][j] += dp1[i][j-1]\\n\\n\\n        # this calculates all paths from m-1,n-1 to i,j\\n        dp2 = [[0 for j in range(n)] for i in range(m)]\\n        dp2[m - 1][n - 1] = 1\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if grid[i][j] == 1:\\n                    if i + 1 < m:\\n                        dp2[i][j] += dp2[i + 1][j]\\n                    if j + 1 < n:\\n                        dp2[i][j] += dp2[i][j + 1]\\n                        \\n                        \\n        #this check whether there is any cell that satisfies equation\\n        flag=False\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    continue\\n                if i==m-1 and j==n-1:\\n                    continue\\n                    \\n                if dp1[i][j]*dp2[i][j]==dp1[m-1][n-1] :\\n                    flag |= True\\n        return flag\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        dp1 = [[0 for _ in range(n)] for _ in range(m)]\\n\\n        \\n        # this calculates all paths from 0,0 to i,j\\n        dp1[0][0] = 1\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    if i-1 >= 0:\\n                        dp1[i][j] += dp1[i-1][j]\\n                    if j-1 >= 0:\\n                        dp1[i][j] += dp1[i][j-1]\\n\\n\\n        # this calculates all paths from m-1,n-1 to i,j\\n        dp2 = [[0 for j in range(n)] for i in range(m)]\\n        dp2[m - 1][n - 1] = 1\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if grid[i][j] == 1:\\n                    if i + 1 < m:\\n                        dp2[i][j] += dp2[i + 1][j]\\n                    if j + 1 < n:\\n                        dp2[i][j] += dp2[i][j + 1]\\n                        \\n                        \\n        #this check whether there is any cell that satisfies equation\\n        flag=False\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    continue\\n                if i==m-1 and j==n-1:\\n                    continue\\n                    \\n                if dp1[i][j]*dp2[i][j]==dp1[m-1][n-1] :\\n                    flag |= True\\n        return flag\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144926,
                "title": "c-golang-counting-1-in-diagonals",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> count(m + n - 1, 0);\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                count[i + j] += grid[i][j];\\n            }\\n        }\\n        for(int i = 1; i < count.size() - 1; i++) {\\n            if(count[i] <= 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Golang\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n    var m, n int = len(grid), len(grid[0])\\n    count := make([]int, m + n - 1)\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            count[i + j] += grid[i][j]\\n        }\\n    }\\n    for i := 1; i < len(count) - 1; i++ {\\n        if count[i] <= 1 {return true}\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Counting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> count(m + n - 1, 0);\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                count[i + j] += grid[i][j];\\n            }\\n        }\\n        for(int i = 1; i < count.size() - 1; i++) {\\n            if(count[i] <= 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Golang\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n    var m, n int = len(grid), len(grid[0])\\n    count := make([]int, m + n - 1)\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            count[i + j] += grid[i][j]\\n        }\\n    }\\n    for i := 1; i < len(count) - 1; i++ {\\n        if count[i] <= 1 {return true}\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144568,
                "title": "c-solution-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i, int j, int m, int n, vector<vector<int>>& grid) {\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0) return false;\\n    \\n        if(i == m-1 && j == n-1) {\\n            return true;\\n        }\\n        \\n        grid[i][j] = 0;\\n        return dfs(i+1, j, m, n, grid) || dfs(i, j+1, m, n, grid);\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size() ,n = grid[0].size(), cnt = 0;\\n        if(dfs(0, 0 , m, n , grid)) cnt++;\\n        grid[0][0] = 1;\\n        if(dfs(0, 0 , m, n , grid)) cnt++;\\n        return (cnt <= 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i, int j, int m, int n, vector<vector<int>>& grid) {\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0) return false;\\n    \\n        if(i == m-1 && j == n-1) {\\n            return true;\\n        }\\n        \\n        grid[i][j] = 0;\\n        return dfs(i+1, j, m, n, grid) || dfs(i, j+1, m, n, grid);\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size() ,n = grid[0].size(), cnt = 0;\\n        if(dfs(0, 0 , m, n , grid)) cnt++;\\n        grid[0][0] = 1;\\n        if(dfs(0, 0 , m, n , grid)) cnt++;\\n        return (cnt <= 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144440,
                "title": "easy-bfs-intuition-on-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n### We go BFS and check if we have **no childs** or have **one child**)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have m+n-3 steps betbeen (0,0) and (m-1,n-1) cells.\\nIn each step we make roads from (i, j) if grid [i] [j] == 1 cell to (i+1, j) and (i+1, j) cells if grid [i+1] [j] == 1 or grid [i] [j] == grid [i] [j+1]. \\nif in any step we have only one or no road then we can flip or no flip\\nand return True, esle False.\\n# Complexity\\n- Time complexity:\\n- O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n- O(min(m,n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt\\'s my first post so let me comments to know if something wrong or can be better.\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        q = [(0,0)]\\n        s = set()\\n        s.add((0,0))\\n        k = 0\\n        while k < n+m-3:\\n            q2 = []\\n            while q:\\n                i,j = q.pop()\\n                s.remove((i,j))\\n                if i+1 < m and grid[i+1][j] == 1 and (i+1,j) not in s:\\n                    q2.append((i+1,j))\\n                    s.add((i+1,j))\\n                if j+1 < n and grid[i][j+1] == 1 and (i,j+1) not in s:\\n                    q2.append((i,j+1))\\n                    s.add((i,j+1))\\n            if not q2 or len(q2) == 1: return True\\n            q = q2\\n            k += 1\\n        return False        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        q = [(0,0)]\\n        s = set()\\n        s.add((0,0))\\n        k = 0\\n        while k < n+m-3:\\n            q2 = []\\n            while q:\\n                i,j = q.pop()\\n                s.remove((i,j))\\n                if i+1 < m and grid[i+1][j] == 1 and (i+1,j) not in s:\\n                    q2.append((i+1,j))\\n                    s.add((i+1,j))\\n                if j+1 < n and grid[i][j+1] == 1 and (i,j+1) not in s:\\n                    q2.append((i,j+1))\\n                    s.add((i,j+1))\\n            if not q2 or len(q2) == 1: return True\\n            q = q2\\n            k += 1\\n        return False        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144400,
                "title": "c-golang-dfs",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    void dfs(vector<vector<int>>& grid, int i, int j, bool &ans) {\\n        int m = grid.size(), n = grid[0].size();\\n        if(ans || i < 0 || j < 0 || i >= m || j >= n || !grid[i][j]) return;\\n        if(i == m - 1 && j == n - 1) {\\n            ans = true;\\n            return;\\n        }\\n        grid[i][j] = 0;\\n        dfs(grid, i + 1, j, ans);\\n        dfs(grid, i, j + 1, ans);\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        bool ans = false;\\n        dfs(grid, 0, 0, ans);\\n        grid[0][0] = grid[m - 1][n - 1] = 1;\\n        ans = false;\\n        dfs(grid, 0, 0, ans);\\n        return !ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc dfs(grid [][]int, i, j int, ans *bool) {\\n    var m, n int = len(grid), len(grid[0])\\n    if *ans || i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 {return}\\n    if i == m - 1 && j == n - 1 {\\n        *ans = true\\n        return\\n    }\\n    grid[i][j] = 0\\n    dfs(grid, i + 1, j, ans)\\n    dfs(grid, i, j + 1, ans)\\n}\\n\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n    var m, n int = len(grid), len(grid[0])\\n    var ans bool = false\\n    dfs(grid, 0, 0, &ans)\\n    grid[0][0], grid[m - 1][n - 1] = 1, 1\\n    ans = false\\n    dfs(grid, 0, 0, &ans)\\n    return !ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    void dfs(vector<vector<int>>& grid, int i, int j, bool &ans) {\\n        int m = grid.size(), n = grid[0].size();\\n        if(ans || i < 0 || j < 0 || i >= m || j >= n || !grid[i][j]) return;\\n        if(i == m - 1 && j == n - 1) {\\n            ans = true;\\n            return;\\n        }\\n        grid[i][j] = 0;\\n        dfs(grid, i + 1, j, ans);\\n        dfs(grid, i, j + 1, ans);\\n    }\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        bool ans = false;\\n        dfs(grid, 0, 0, ans);\\n        grid[0][0] = grid[m - 1][n - 1] = 1;\\n        ans = false;\\n        dfs(grid, 0, 0, ans);\\n        return !ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc dfs(grid [][]int, i, j int, ans *bool) {\\n    var m, n int = len(grid), len(grid[0])\\n    if *ans || i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 {return}\\n    if i == m - 1 && j == n - 1 {\\n        *ans = true\\n        return\\n    }\\n    grid[i][j] = 0\\n    dfs(grid, i + 1, j, ans)\\n    dfs(grid, i, j + 1, ans)\\n}\\n\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n    var m, n int = len(grid), len(grid[0])\\n    var ans bool = false\\n    dfs(grid, 0, 0, &ans)\\n    grid[0][0], grid[m - 1][n - 1] = 1, 1\\n    ans = false\\n    dfs(grid, 0, 0, &ans)\\n    return !ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144259,
                "title": "javascript-java-easy-solution-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We can move only right and Down. \\n- So, think that sum of those next cell\\'s index will be same for right and Down move.  \\n- sum(down_move) === sum(right_move)\\n\\n\\n---\\n\\n\\n# Approach\\n - Take array for traacking Sum of Indexes(Size of the array will be n+m-1)\\n - If Next move(right or down) has 1 then increse count of **{i+j}** index in our array.\\n - Now, Check if any value in array from start to end(exclude start and end because they always 1) has value **less than 2**.\\n\\n\\n---\\n\\n\\n# JavaScript\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int a[] = new int[n+m-1];\\n        for(int i=0; i<n ;i++){\\n                for(int j=0; j<m; j++){\\n                        if(grid[i][j] == 1)\\n                        a[i+j]++;\\n                }\\n        }\\n        \\n        for(int i=1 ; i< m+n-2 ;i++){\\n                if(a[i] < 2)return true;\\n        }\\n        \\n        return false;\\n    } \\n}\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int a[] = new int[n+m-1];\\n\\n        for(int i=0; i<n ;i++){\\n                for(int j=0; j<m; j++){\\n                        if(grid[i][j] == 1)\\n                        a[i+j]++;\\n                }\\n        }\\n        \\n        for(int i=1 ; i< m+n-2 ;i++){\\n                if(a[i] < 2)return true;\\n        }\\n        \\n        return false;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int a[] = new int[n+m-1];\\n        for(int i=0; i<n ;i++){\\n                for(int j=0; j<m; j++){\\n                        if(grid[i][j] == 1)\\n                        a[i+j]++;\\n                }\\n        }\\n        \\n        for(int i=1 ; i< m+n-2 ;i++){\\n                if(a[i] < 2)return true;\\n        }\\n        \\n        return false;\\n    } \\n}\\n```\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int a[] = new int[n+m-1];\\n\\n        for(int i=0; i<n ;i++){\\n                for(int j=0; j<m; j++){\\n                        if(grid[i][j] == 1)\\n                        a[i+j]++;\\n                }\\n        }\\n        \\n        for(int i=1 ; i< m+n-2 ;i++){\\n                if(a[i] < 2)return true;\\n        }\\n        \\n        return false;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144085,
                "title": "fully-explained-100-bfs",
                "content": "# Intuition\\n code is written in C++ and is implementing a breadth-first search (BFS) algorithm on a 2D grid represented by the grid parameter. The purpose of the algorithm is to determine whether it is possible to reach the bottom-right corner of the grid by only moving down and to the right, starting from the top-left corner. If it is possible to reach the bottom-right corner, the function returns false, otherwise it returns true.\\n\\n# Approach\\nThe algorithm first initializes a 2D boolean array, marked, which is used to keep track of the cells that have already been visited in the grid. Then, it initializes a queue, q, and adds the starting position, (0, 0), to the queue. The algorithm then enters a while loop, which continues until the queue is empty.\\n\\nIn the loop, the code checks if the first element in the queue is the bottom-right corner of the grid. If it is, the function returns false. If the queue has only one element, and it is not the starting position or the bottom-right corner, the function returns true.\\n\\nNext, the code enters a for loop, where the number of iterations is equal to the size of the queue at the start of the loop. In each iteration, the code retrieves the first element in the queue, del, and removes it from the queue. The code then uses the retrieved position to check if it is possible to move down or to the right in the grid. If it is, the code marks the new position as visited, adds it to the queue, and continues with the next iteration of the loop.\\n\\nFinally, if the while loop completes, the function returns true.\\n# Complexity\\n- Time complexity:\\no(mn)\\n- Space complexity:\\nO(mn)\\n# Code\\n```\\nclass Solution {\\n\\n  public:   \\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\nint m = grid.size();\\nint n = grid[0].size();\\nvector<vector<bool>> marked(m, vector<bool>(n, false));\\n\\nqueue<pair<int, int>> q;\\nmarked[0][0] = true;\\nq.push(make_pair(0, 0));\\nwhile (!q.empty()) {\\nif (q.front().first == m-1 && q.front().second == n-1)\\nreturn false;\\nelse if (q.size() == 1 && !(q.front().first == 0 && q.front().second == 0)\\n&& !(q.front().first == m - 1 && q.front().second == n - 1))\\nreturn true;\\nint q_size = q.size();\\nfor (int i = 0; i < q_size; i++) {\\npair<int, int> del = q.front();\\nq.pop();\\nint x = del.first, y = del.second;\\nif (x + 1 < m && grid[x + 1][y] == 1 && !marked[x + 1][y]) {\\nmarked[x + 1][y] = true;\\nq.push(make_pair(x + 1, y));\\n}\\nif (y + 1 < n && grid[x][y + 1] == 1 && !marked[x][y + 1]) {\\nmarked[x][y + 1] = true;\\nq.push(make_pair(x, y + 1));\\n}\\n}\\n}\\nreturn true;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n  public:   \\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\nint m = grid.size();\\nint n = grid[0].size();\\nvector<vector<bool>> marked(m, vector<bool>(n, false));\\n\\nqueue<pair<int, int>> q;\\nmarked[0][0] = true;\\nq.push(make_pair(0, 0));\\nwhile (!q.empty()) {\\nif (q.front().first == m-1 && q.front().second == n-1)\\nreturn false;\\nelse if (q.size() == 1 && !(q.front().first == 0 && q.front().second == 0)\\n&& !(q.front().first == m - 1 && q.front().second == n - 1))\\nreturn true;\\nint q_size = q.size();\\nfor (int i = 0; i < q_size; i++) {\\npair<int, int> del = q.front();\\nq.pop();\\nint x = del.first, y = del.second;\\nif (x + 1 < m && grid[x + 1][y] == 1 && !marked[x + 1][y]) {\\nmarked[x + 1][y] = true;\\nq.push(make_pair(x + 1, y));\\n}\\nif (y + 1 < n && grid[x][y + 1] == 1 && !marked[x][y + 1]) {\\nmarked[x][y + 1] = true;\\nq.push(make_pair(x, y + 1));\\n}\\n}\\n}\\nreturn true;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143861,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChecking whether there exits a row/column/diagonal having at most single 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] g) {\\n        if(g.length==1 && g[0].length>2){\\n            return true;\\n        }\\n        if(g.length==1 && g[0].length==2){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<g.length;i++){\\n            int c=0;\\n            for(int j=0;j<g[0].length;j++){\\n                c=c+g[i][j];\\n            }\\n            if(c<=1){\\n                return true;\\n            }\\n        }\\n        for(int j=0;j<g[0].length;j++){\\n            int c=0;\\n            for(int i=0;i<g.length;i++){\\n                c=c+g[i][j];\\n            }\\n            if(c<=1){\\n                return true;\\n            }\\n        }\\n        \\n        for(int i=1;i<g[0].length;i++){\\n            int c=0;\\n            int y=i,x=0;\\n            while(y>=0 && x<g.length){\\n                c=c+g[x][y];\\n                x++;\\n                y--;\\n            }\\n            if(c<=1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] g) {\\n        if(g.length==1 && g[0].length>2){\\n            return true;\\n        }\\n        if(g.length==1 && g[0].length==2){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<g.length;i++){\\n            int c=0;\\n            for(int j=0;j<g[0].length;j++){\\n                c=c+g[i][j];\\n            }\\n            if(c<=1){\\n                return true;\\n            }\\n        }\\n        for(int j=0;j<g[0].length;j++){\\n            int c=0;\\n            for(int i=0;i<g.length;i++){\\n                c=c+g[i][j];\\n            }\\n            if(c<=1){\\n                return true;\\n            }\\n        }\\n        \\n        for(int i=1;i<g[0].length;i++){\\n            int c=0;\\n            int y=i,x=0;\\n            while(y>=0 && x<g.length){\\n                c=c+g[x][y];\\n                x++;\\n                y--;\\n            }\\n            if(c<=1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143245,
                "title": "python-easy-solution-o-mn",
                "content": "1. count the number of total paths from (0,0) to (m-1,n-1), i.e., total \\n2. count the number of total paths from (0,0) to (i,j), i.e., left[i][j]\\n3. count the number of total paths from (i,j) to (m-1,n-1), i.e., right[i][j]\\n4. if total == left[i][j]*right[i][j], then (i,j) is the cut point\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        left = [[0]*n for _ in range(m)]\\n        right = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    if i == 0 and j == 0:\\n                        left[i][j] = 1\\n                    else:\\n                        left[i][j] = (left[i-1][j] if i else 0) + (left[i][j-1] if j else 0)\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j]:\\n                    if i == m - 1 and j == n - 1:\\n                        right[i][j] = 1\\n                    else:\\n                        right[i][j] = (right[i+1][j] if i < m - 1 else 0) + (right[i][j+1] if j < n - 1 else 0)\\n        total = left[-1][-1]\\n        if not total: return True\\n        for i in range(m):\\n            for j in range(n):\\n                if left[i][j]*right[i][j] == total:\\n                    if (i,j) not in [(0,0),(m-1,n-1)]:\\n                        return True\\n        return False\\n                \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        left = [[0]*n for _ in range(m)]\\n        right = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    if i == 0 and j == 0:\\n                        left[i][j] = 1\\n                    else:\\n                        left[i][j] = (left[i-1][j] if i else 0) + (left[i][j-1] if j else 0)\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j]:\\n                    if i == m - 1 and j == n - 1:\\n                        right[i][j] = 1\\n                    else:\\n                        right[i][j] = (right[i+1][j] if i < m - 1 else 0) + (right[i][j+1] if j < n - 1 else 0)\\n        total = left[-1][-1]\\n        if not total: return True\\n        for i in range(m):\\n            for j in range(n):\\n                if left[i][j]*right[i][j] == total:\\n                    if (i,j) not in [(0,0),(m-1,n-1)]:\\n                        return True\\n        return False\\n                \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142901,
                "title": "java-simple-explained-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the approach is simple.\\nAt first I thought to just calculate the number of paths possible and if more than 1 path is there answer would be false. But it would not work if a critical vertex is included in both the paths thus this was my absurd idea. \\nthen we can think that if only one path exist and we remove that path and by doing soo we can still traverse the graph then it cannot be seperated.\\n\\n**Just think if we flip one index then its whole path will collapse se just do it remove the path you traverse and after doing so still you can traverse the graph then return false, meaning it wont be possible to divide it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo a dfs traversal for just one path - \\n    this could be done by having boolean as return type so if path is found we donot go to next dfs.\\nDuring dfs remove the path by making grid for those indexs as 0.\\nAfter one DFS still if you can traverse the graph return false.\\nElse return true.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int path ;\\n    public boolean isPossibleToCutPath(int[][] grid) \\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if(grid[0][0] == 0 || grid[n-1][m-1]==0)\\n            return true;\\n        boolean f = dfs(grid,0,0,n,m);\\n        grid[0][0] = 1;\\n        f = dfs(grid,0,0,n,m);\\n        if(f==true)\\n            return false;\\n        else\\n            return true;\\n        \\n    }\\n    public boolean dfs(int grid[][],int i,int j,int n,int m)\\n    {\\n        if(i<0 || i>=n || j<0 || j>= m)\\n            return false;\\n        if(grid[i][j] == 0)\\n            return false;\\n        if(i==n-1 && j==m-1)\\n            return true;\\n        \\n        grid[i][j] = 0;\\n    \\n        if(dfs(grid,i+1,j,n,m) || dfs(grid,i,j+1,n,m))\\n        return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int path ;\\n    public boolean isPossibleToCutPath(int[][] grid) \\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if(grid[0][0] == 0 || grid[n-1][m-1]==0)\\n            return true;\\n        boolean f = dfs(grid,0,0,n,m);\\n        grid[0][0] = 1;\\n        f = dfs(grid,0,0,n,m);\\n        if(f==true)\\n            return false;\\n        else\\n            return true;\\n        \\n    }\\n    public boolean dfs(int grid[][],int i,int j,int n,int m)\\n    {\\n        if(i<0 || i>=n || j<0 || j>= m)\\n            return false;\\n        if(grid[i][j] == 0)\\n            return false;\\n        if(i==n-1 && j==m-1)\\n            return true;\\n        \\n        grid[i][j] = 0;\\n    \\n        if(dfs(grid,i+1,j,n,m) || dfs(grid,i,j+1,n,m))\\n        return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142898,
                "title": "dp-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind a way to cut through so that there is only one 1 or less.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP calculating the minimum number of 1s encountered in the cut.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (m == 1) {\\n            return (n > 2); \\n        }\\n        if (n == 1) {\\n            return (m > 2);\\n        }\\n        int[][] dp = new int[m][n];\\n        // init\\n        for (int i = 0; i < n; i++) {\\n            dp[0][i] = grid[0][i];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = grid[i][n-1];\\n        }\\n        // dp case\\n        for (int i = 1; i < m; i++) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i-1][j+1], dp[i][j+1]);\\n            }\\n        }\\n        // test\\n        for (int i = 1; i < m; i++) {\\n            if (dp[i][0] <= 1) {\\n                return true;\\n            }\\n        }\\n        for (int j = 0; j < n-1; j++) {\\n            if (dp[m-1][j] <= 1) {\\n                return true;\\n            }\\n        }\\n        // couln\\'t find a solution\\n        return false;\\n    }\\n\\n    public int min(int a, int b, int c) {\\n        if (a < b) {\\n            if (a < c) {\\n                return a;\\n            }\\n            return c;\\n        }\\n        if (b < c) {\\n            return b;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (m == 1) {\\n            return (n > 2); \\n        }\\n        if (n == 1) {\\n            return (m > 2);\\n        }\\n        int[][] dp = new int[m][n];\\n        // init\\n        for (int i = 0; i < n; i++) {\\n            dp[0][i] = grid[0][i];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = grid[i][n-1];\\n        }\\n        // dp case\\n        for (int i = 1; i < m; i++) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i-1][j+1], dp[i][j+1]);\\n            }\\n        }\\n        // test\\n        for (int i = 1; i < m; i++) {\\n            if (dp[i][0] <= 1) {\\n                return true;\\n            }\\n        }\\n        for (int j = 0; j < n-1; j++) {\\n            if (dp[m-1][j] <= 1) {\\n                return true;\\n            }\\n        }\\n        // couln\\'t find a solution\\n        return false;\\n    }\\n\\n    public int min(int a, int b, int c) {\\n        if (a < b) {\\n            if (a < c) {\\n                return a;\\n            }\\n            return c;\\n        }\\n        if (b < c) {\\n            return b;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142888,
                "title": "rust-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Perform a dfs and assign each node rthe sequence # in the order a node is discovered.\\nPerform another dfs in reverse order. If we see a node with sequence < that of [m - 1][n - 1] before reaching [m - 1][n - 1], that node is a node that will disconnect the matrix if it\\'s removed.   \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M * N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn is_possible_to_cut_path(grid: Vec<Vec<i32>>) -> bool {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut order = vec![vec![0; n]; m];\\n        \\n        let mut seq = 1;\\n        Self::dfs(&grid, &mut order, 0, 0, &mut seq);\\n\\n        let mut ret = false;\\n        let val = order[m - 1][n - 1];\\n        Self::dfs_reverse(&grid, &mut order, 0, 0, val, &mut ret);\\n        ret == false\\n    }\\n\\n    fn dfs(grid: &Vec<Vec<i32>>, order: &mut Vec<Vec<i32>>, i: i32, j: i32, seq: &mut i32) {\\n        if i == grid.len() as i32 || j == grid[0].len() as i32 { return }\\n        if grid[i as usize][j as usize] == 0 || order[i as usize][j as usize] != 0 { return }\\n\\n        *seq += 1;\\n        order[i as usize][j as usize] = *seq;\\n        Self::dfs(grid, order, i + 1, j, seq);\\n        Self::dfs(grid, order, i, j + 1, seq);\\n    }\\n\\n    fn dfs_reverse(grid: &Vec<Vec<i32>>, order: &mut Vec<Vec<i32>>, i: i32, j: i32, val: i32, ret: &mut bool) {\\n        if i == grid.len() as i32 || j == grid[0].len() as i32 { return }\\n        if grid[i as usize][j as usize] == 0 || order[i as usize][j as usize] == 0 { return }\\n\\n        if i + j > 0 && order[i as usize][j as usize] < val { return; }\\n\\n        order[i as usize][j as usize] = 0;\\n        if i == grid.len() as i32 - 1 && j == grid[0].len() as i32 - 1 { \\n            *ret = true;\\n            return \\n        }\\n        \\n        Self::dfs_reverse(grid, order, i, j + 1, val, ret);\\n        if *ret == false { Self::dfs_reverse(grid, order, i + 1, j, val, ret); }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_possible_to_cut_path(grid: Vec<Vec<i32>>) -> bool {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut order = vec![vec![0; n]; m];\\n        \\n        let mut seq = 1;\\n        Self::dfs(&grid, &mut order, 0, 0, &mut seq);\\n\\n        let mut ret = false;\\n        let val = order[m - 1][n - 1];\\n        Self::dfs_reverse(&grid, &mut order, 0, 0, val, &mut ret);\\n        ret == false\\n    }\\n\\n    fn dfs(grid: &Vec<Vec<i32>>, order: &mut Vec<Vec<i32>>, i: i32, j: i32, seq: &mut i32) {\\n        if i == grid.len() as i32 || j == grid[0].len() as i32 { return }\\n        if grid[i as usize][j as usize] == 0 || order[i as usize][j as usize] != 0 { return }\\n\\n        *seq += 1;\\n        order[i as usize][j as usize] = *seq;\\n        Self::dfs(grid, order, i + 1, j, seq);\\n        Self::dfs(grid, order, i, j + 1, seq);\\n    }\\n\\n    fn dfs_reverse(grid: &Vec<Vec<i32>>, order: &mut Vec<Vec<i32>>, i: i32, j: i32, val: i32, ret: &mut bool) {\\n        if i == grid.len() as i32 || j == grid[0].len() as i32 { return }\\n        if grid[i as usize][j as usize] == 0 || order[i as usize][j as usize] == 0 { return }\\n\\n        if i + j > 0 && order[i as usize][j as usize] < val { return; }\\n\\n        order[i as usize][j as usize] = 0;\\n        if i == grid.len() as i32 - 1 && j == grid[0].len() as i32 - 1 { \\n            *ret = true;\\n            return \\n        }\\n        \\n        Self::dfs_reverse(grid, order, i, j + 1, val, ret);\\n        if *ret == false { Self::dfs_reverse(grid, order, i + 1, j, val, ret); }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3142887,
                "title": "c-diagonal-traversal-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int> v(m+n-1,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                v[i+j]+=grid[i][j];\\n            }\\n        }\\n        for(int i=1;i<m+n-2;i++)\\n        {\\n            if(v[i]<=1)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int> v(m+n-1,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                v[i+j]+=grid[i][j];\\n            }\\n        }\\n        for(int i=1;i<m+n-2;i++)\\n        {\\n            if(v[i]<=1)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142730,
                "title": "c-dfs-tc-o-m-n-sc-o-m-n-simple-dfs-solution-find-two-disjoint-paths",
                "content": "# Intuition\\nIf we can find two disjoint paths from start to end such that there is no common cell, then we can not disconnect the matrix.\\nAnd we can not find any two such paths then it is possible to disconnect them (think about it).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSTEP 1 : using dfs search find a path which starts from (1, 0) and it is as left as possible and can connect start to end.\\n\\nSTEP 2: if we can not find such path then it is already disconnected.\\n\\nSTEP 3: using dfs search find second path which starts from (0, 1) and which connect start to end\\n\\nSTEP 4: if it is possible to find such path then we can not disconnect the matrix. since two such path exists.\\n\\nSTEP 5: else we can disconnect the matrix\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M * N);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M * N)\\n<!-- Add your space complexity here, e.g. $$O(M * N)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dir[3] = {1, 0, 1};\\n\\n    // function to check if it is possible to make a path from start to end\\n    bool dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &seen){\\n        if(i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 || seen[i][j] == 1) return false;\\n        \\n        if(i == m - 1 && j == n - 1) return true;\\n\\n        bool isPath = false;\\n        seen[i][j] = 1; \\n\\n        for(auto it = 0; it < 2; it++){\\n            int x = i + dir[it], y = j + dir[it + 1];\\n\\n            if(dfs(x, y, grid, seen)) {\\n                isPath = true;\\n                break;\\n            }\\n        }\\n\\n        return isPath;\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        \\n        // base cases\\n        if(m == 1){\\n            if(n == 2) return false;\\n            return true;\\n        }\\n        if(n == 1){\\n            if(m == 2) return false;\\n            return true;\\n        }\\n\\n        \\n        vector<vector<int>> seen(m, vector<int>(n, 0));\\n        \\n        // if we can\\'t make a path from start to end\\n        if(!dfs(1, 0, grid, seen)) return true;\\n\\n        // if we can make two paths from start to end\\n        if(dfs(0, 1, grid, seen)) return false;\\n        \\n        // else\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dir[3] = {1, 0, 1};\\n\\n    // function to check if it is possible to make a path from start to end\\n    bool dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &seen){\\n        if(i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 || seen[i][j] == 1) return false;\\n        \\n        if(i == m - 1 && j == n - 1) return true;\\n\\n        bool isPath = false;\\n        seen[i][j] = 1; \\n\\n        for(auto it = 0; it < 2; it++){\\n            int x = i + dir[it], y = j + dir[it + 1];\\n\\n            if(dfs(x, y, grid, seen)) {\\n                isPath = true;\\n                break;\\n            }\\n        }\\n\\n        return isPath;\\n    }\\n\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        \\n        // base cases\\n        if(m == 1){\\n            if(n == 2) return false;\\n            return true;\\n        }\\n        if(n == 1){\\n            if(m == 2) return false;\\n            return true;\\n        }\\n\\n        \\n        vector<vector<int>> seen(m, vector<int>(n, 0));\\n        \\n        // if we can\\'t make a path from start to end\\n        if(!dfs(1, 0, grid, seen)) return true;\\n\\n        // if we can make two paths from start to end\\n        if(dfs(0, 1, grid, seen)) return false;\\n        \\n        // else\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142673,
                "title": "simple-bfs-solution-with-comments",
                "content": "# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public bool IsPossibleToCutPath(int[][] grid) \\n    {\\n        int rows = grid.Length;\\n        int cols = grid[0].Length;\\n        var visited = new HashSet<(int,int)>();\\n        var q = new Queue<(int,int)>();\\n        //if we have matrix like a [[1,1]] return false;\\n        if(rows*cols == 2) return false;\\n        q.Enqueue((0,0));\\n        while (q.Count != 0)\\n        {\\n            (int row, int col) point = q.Dequeue();\\n             //Move Down\\n            if(point.row + 1 < rows && !visited.Contains((point.row+1,point.col) ) && grid[point.row+1][point.col] == 1)\\n            {\\n                //if we reach (m - 1, n - 1)\\n                if(point.row + 1 == rows - 1 && point.col == cols - 1)\\n                {\\n                    //if there is another way(Count > 0) - return false;\\n                    if(q.Count != 0) \\n                    {\\n                        return false;\\n                    //if we have the only one way\\n                    }else{\\n                        return true;\\n                    }\\n                //go ahead    \\n                } else \\n                {\\n                    visited.Add((point.row+1,point.col));\\n                    q.Enqueue((point.row+1,point.col));\\n                }\\n                \\n            }\\n            //Move Right\\n            if(point.col + 1 < cols && !visited.Contains((point.row,point.col+1)) && grid[point.row][point.col+1] == 1)\\n            {\\n                //if we reach (m - 1, n - 1)\\n                if(point.row == rows - 1 && point.col + 1 == cols - 1)\\n                {\\n                    //if there is another way(Count > 0) - return false;\\n                    if(q.Count != 0) \\n                    {\\n                        return false;\\n                    //if we have the only one way\\n                    } else\\n                    {\\n                        return true;\\n                    }\\n                //go ahead    \\n                } else \\n                {\\n                    visited.Add((point.row,point.col + 1));\\n                    q.Enqueue((point.row,point.col + 1));\\n                }\\n            }\\n            //if we have one way or not - return true\\n            //if we have the only one way, we swap 1 to 0 to disconnect this way\\n            if(q.Count <= 1) return true;\\n        }\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsPossibleToCutPath(int[][] grid) \\n    {\\n        int rows = grid.Length;\\n        int cols = grid[0].Length;\\n        var visited = new HashSet<(int,int)>();\\n        var q = new Queue<(int,int)>();\\n        //if we have matrix like a [[1,1]] return false;\\n        if(rows*cols == 2) return false;\\n        q.Enqueue((0,0));\\n        while (q.Count != 0)\\n        {\\n            (int row, int col) point = q.Dequeue();\\n             //Move Down\\n            if(point.row + 1 < rows && !visited.Contains((point.row+1,point.col) ) && grid[point.row+1][point.col] == 1)\\n            {\\n                //if we reach (m - 1, n - 1)\\n                if(point.row + 1 == rows - 1 && point.col == cols - 1)\\n                {\\n                    //if there is another way(Count > 0) - return false;\\n                    if(q.Count != 0) \\n                    {\\n                        return false;\\n                    //if we have the only one way\\n                    }else{\\n                        return true;\\n                    }\\n                //go ahead    \\n                } else \\n                {\\n                    visited.Add((point.row+1,point.col));\\n                    q.Enqueue((point.row+1,point.col));\\n                }\\n                \\n            }\\n            //Move Right\\n            if(point.col + 1 < cols && !visited.Contains((point.row,point.col+1)) && grid[point.row][point.col+1] == 1)\\n            {\\n                //if we reach (m - 1, n - 1)\\n                if(point.row == rows - 1 && point.col + 1 == cols - 1)\\n                {\\n                    //if there is another way(Count > 0) - return false;\\n                    if(q.Count != 0) \\n                    {\\n                        return false;\\n                    //if we have the only one way\\n                    } else\\n                    {\\n                        return true;\\n                    }\\n                //go ahead    \\n                } else \\n                {\\n                    visited.Add((point.row,point.col + 1));\\n                    q.Enqueue((point.row,point.col + 1));\\n                }\\n            }\\n            //if we have one way or not - return true\\n            //if we have the only one way, we swap 1 to 0 to disconnect this way\\n            if(q.Count <= 1) return true;\\n        }\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142491,
                "title": "python-dfs-dp-solution-explanation",
                "content": "# Intuition\\nThe idea is to \"solve\" the maze using some graph traversal algorithm. For each step which does lead to the finish we add the n (number of steps taken) to a counter dictionary. After it\\'s done we check if there is any number which occurs only once - if that\\'s the case than the path can be blocked by single \"flip\".\\n\\nInitially I thought about BFS, but since we can only go right or down (so we cannot go \"back\") DFS will do the job and I think it\\'s more straightforward to code.\\n\\nFor example:\\n![obraz.png](https://assets.leetcode.com/users/images/dcdc89b2-2610-4187-9cf8-062d72efac2a_1675535673.0193377.png)\\nHere \"X\" are the blocked paths (zeroes in the original grid). Numbers are the values that we want to put in our dictionary during traversal. Empty spaces represent \"dead ends\" - we don\\'t want them in the dictionary.\\n\\n\\n# Approach\\nThe graph traversal is done using a recursive approach (DFS). We use @cache for DP to avoid calculating the same path more than once. The recursive function goes as follows:\\n1. See if we are at the end, if yes: return 1\\n```\\n        @cache\\n        def go(row,col,n):\\n            if row == len(grid)-1 and col == len(grid[0])-1: return 1\\n```\\n2. See if (row,col) is outside the grid or if the path is blocked. If yes: return 0:\\n```\\n            if row >= len(grid) or col >= len(grid[0]): return 0\\n            if grid[row][col] == 0: return 0\\n```\\n3. Initiate recursion for steps \"down\" and \"right\". The idea is that if function go returns 0 the path is a dead-end, so we don\\'t put it into the dictionary.\\n```\\n            x = go(row+1,col,n+1)\\n            y = go(row,col+1,n+1)\\n```\\n4. So if either x or y equals 1 we can add current position to the dictionary. If not, return 0 (it\\'s a dead-end):\\n```\\n            if x or y:\\n                if n in count.keys(): count[n] +=1\\n                else: count.update({n:1})\\n                return 1\\n            return 0\\n```\\n5. Now we initialise the dictionary (here called \"count\") and run the function. If the count is empty - then there is no solution. If it\\'s not we check if there is any number n which occurrs only once (apart from the starting point, hence del count[0]).\\n```\\n        count = dict()\\n        go(0,0,0)\\n        if not count: return 1\\n        del count[0]\\n        if 1 in count.values(): return 1\\n        else: return 0\\n```\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        @cache\\n        def go(row,col,n):\\n            if row == len(grid)-1 and col == len(grid[0])-1: return 1\\n            if row >= len(grid) or col >= len(grid[0]): return 0\\n            if grid[row][col] == 0: return 0\\n            x = go(row+1,col,n+1)\\n            y = go(row,col+1,n+1)\\n\\n            if x or y:\\n                if n in count.keys(): count[n] +=1\\n                else: count.update({n:1})\\n                return 1\\n            return 0\\n            \\n        count = dict()\\n        go(0,0,0)\\n        if not count: return 1\\n        del count[0]\\n        if 1 in count.values(): return 1\\n        else: return 0\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        @cache\\n        def go(row,col,n):\\n            if row == len(grid)-1 and col == len(grid[0])-1: return 1\\n```\n```\\n            if row >= len(grid) or col >= len(grid[0]): return 0\\n            if grid[row][col] == 0: return 0\\n```\n```\\n            x = go(row+1,col,n+1)\\n            y = go(row,col+1,n+1)\\n```\n```\\n            if x or y:\\n                if n in count.keys(): count[n] +=1\\n                else: count.update({n:1})\\n                return 1\\n            return 0\\n```\n```\\n        count = dict()\\n        go(0,0,0)\\n        if not count: return 1\\n        del count[0]\\n        if 1 in count.values(): return 1\\n        else: return 0\\n```\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        @cache\\n        def go(row,col,n):\\n            if row == len(grid)-1 and col == len(grid[0])-1: return 1\\n            if row >= len(grid) or col >= len(grid[0]): return 0\\n            if grid[row][col] == 0: return 0\\n            x = go(row+1,col,n+1)\\n            y = go(row,col+1,n+1)\\n\\n            if x or y:\\n                if n in count.keys(): count[n] +=1\\n                else: count.update({n:1})\\n                return 1\\n            return 0\\n            \\n        count = dict()\\n        go(0,0,0)\\n        if not count: return 1\\n        del count[0]\\n        if 1 in count.values(): return 1\\n        else: return 0\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142385,
                "title": "dinamic-programming",
                "content": "# Intuition\\nThis is some strange solution without DFS my main idea is using count number of grids on path in one diganal. If there any diganal which is only one grid should be in path answer will be true, otherwise answer should be false \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP soultion\\n# Complexity\\n- Time complexity:\\n- O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool isPossibleToCutPath(vector<vector<int>>& g) {\\n    int n = g.size();\\n    int m = g[0].size();\\n    bool d[n][m];\\n    for(int i=0; i < n; i ++){\\n        for(int j=0; j < m; j ++){\\n            d[i][j] = 0; \\n        }\\n    }  \\n    if(g[0][0] == 0 || g[n-1][m-1] == 0)\\n        return true;\\n    d[0][0] = 1;\\n    int dp[n+m];\\n    for(int i=0; i < n + m; i ++)\\n        dp[i] = 0;\\n       \\n    for(int i=0; i < n; i ++){\\n        for(int j = 0; j < m; j ++){\\n            if(i == 0 && j == 0)\\n                continue;\\n            if(g[i][j] == 1){\\n                if(i > 0 && g[i-1][j]){\\n                    d[i][j] |= d[i-1][j];\\n                }\\n                if(j > 0 && g[i][j-1]){\\n                    d[i][j] |= d[i][j-1];\\n                }\\n                dp[i + j] += d[i][j];\\n            }\\n        }\\n    }\\n    for(int i=1; i < n + m -2 ; i ++){\\n        if(dp[i] <= 1)\\n            return true;\\n    }\\n    return false;    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isPossibleToCutPath(vector<vector<int>>& g) {\\n    int n = g.size();\\n    int m = g[0].size();\\n    bool d[n][m];\\n    for(int i=0; i < n; i ++){\\n        for(int j=0; j < m; j ++){\\n            d[i][j] = 0; \\n        }\\n    }  \\n    if(g[0][0] == 0 || g[n-1][m-1] == 0)\\n        return true;\\n    d[0][0] = 1;\\n    int dp[n+m];\\n    for(int i=0; i < n + m; i ++)\\n        dp[i] = 0;\\n       \\n    for(int i=0; i < n; i ++){\\n        for(int j = 0; j < m; j ++){\\n            if(i == 0 && j == 0)\\n                continue;\\n            if(g[i][j] == 1){\\n                if(i > 0 && g[i-1][j]){\\n                    d[i][j] |= d[i-1][j];\\n                }\\n                if(j > 0 && g[i][j-1]){\\n                    d[i][j] |= d[i][j-1];\\n                }\\n                dp[i + j] += d[i][j];\\n            }\\n        }\\n    }\\n    for(int i=1; i < n + m -2 ; i ++){\\n        if(dp[i] <= 1)\\n            return true;\\n    }\\n    return false;    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142371,
                "title": "run-dfs-2-times-very-easy-to-understand",
                "content": "**1. There should have a cycle including \"TOP_LEFT\" and \"BOTTOM_RIGHT\" cell of grid, then only we can\\'t disconnect the grid by flipping a point.**\\n**2. One case to consider as edge case is when size of grid is \"1\" or \"2\" then return false as no such cell willl be there.**\\n```\\nclass Solution {\\npublic:\\n    bool come(int i,int j,vector<vector<int>>& grid){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=n or j>=m){\\n            return false;\\n        }\\n        if(i==n-1 and j==m-1){\\n            return true;\\n        }\\n        if(grid[i][j]==0){\\n            return false;\\n        }\\n        grid[i][j]=0;\\n        if(come(i+1,j,grid)){\\n            return true;\\n        }\\n        if(come(i,j+1,grid)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if((m==1 and n==1)or m*n==2 ){\\n            return false;\\n        }\\n        if(come(1,0,grid) and come(0,1,grid)){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool come(int i,int j,vector<vector<int>>& grid){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=n or j>=m){\\n            return false;\\n        }\\n        if(i==n-1 and j==m-1){\\n            return true;\\n        }\\n        if(grid[i][j]==0){\\n            return false;\\n        }\\n        grid[i][j]=0;\\n        if(come(i+1,j,grid)){\\n            return true;\\n        }\\n        if(come(i,j+1,grid)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if((m==1 and n==1)or m*n==2 ){\\n            return false;\\n        }\\n        if(come(1,0,grid) and come(0,1,grid)){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142318,
                "title": "python-2-dfs-example-test-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf it is not possible to reach destination from any one of the cells (1,0) or (0,1) then we can always disconnect.\\n    \\nIf both cells have only one path to destination and it shares a common point, we can disconnect.\\n eg:\\n    1110\\n    1100\\n    0111\\n\\n\\n    \\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nORDER OF DFS MATTERS\\nIf processing cell (0,1) first, visit till the extreme possible right node before going down. This will prevent intersection while processing cell (1,0).\\neg:\\n     1110\\n     1111\\n     0111\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        if ROWS == 1:\\n            if COLS <= 2: return False\\n            return True\\n\\n        if COLS == 1:\\n            if ROWS <= 2: return False\\n            return True\\n        \\n        \\n        visited = set()\\n\\n        def dfs(r, c):\\n            if r<0 or c<0 or r==ROWS or c==COLS or grid[r][c]==0 or(r,c) in visited:\\n                return False\\n            if (r,c) == (ROWS-1, COLS-1):\\n                return True\\n            \\n            visited.add((r,c))\\n            if dfs(r, c+1) or dfs(r+1, c):\\n                return True\\n            \\n            return False\\n             \\n        \\n        if dfs(0,1) and dfs(1,0):\\n            return False\\n          \\n        return True\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        if ROWS == 1:\\n            if COLS <= 2: return False\\n            return True\\n\\n        if COLS == 1:\\n            if ROWS <= 2: return False\\n            return True\\n        \\n        \\n        visited = set()\\n\\n        def dfs(r, c):\\n            if r<0 or c<0 or r==ROWS or c==COLS or grid[r][c]==0 or(r,c) in visited:\\n                return False\\n            if (r,c) == (ROWS-1, COLS-1):\\n                return True\\n            \\n            visited.add((r,c))\\n            if dfs(r, c+1) or dfs(r+1, c):\\n                return True\\n            \\n            return False\\n             \\n        \\n        if dfs(0,1) and dfs(1,0):\\n            return False\\n          \\n        return True\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142296,
                "title": "go-python-o-n-m-time-o-n-m-time",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n    n := len(grid)+2\\n    m := len(grid[0])+2\\n\\n    dp1 := [][]int{}\\n    for i:=0;i<n;i++{\\n        dp1 = append(dp1,make([]int,m))\\n    }\\n    dp1[1][1] = 1\\n\\n    for i:=1;i<n-1;i++{\\n        for j:=1;j<m-1;j++{\\n            if i == 1 && j == 1{\\n                continue\\n            }\\n            if grid[i-1][j-1] == 0{\\n                continue\\n            }\\n            dp1[i][j] = dp1[i-1][j]+dp1[i][j-1]\\n        }\\n    }\\n        \\n    if dp1[n-2][m-2] == 0{\\n        return true\\n    }\\n                \\n    dp2 := [][]int{}\\n    for i:=0;i<n;i++{\\n        dp2 = append(dp2,make([]int,m))\\n    }\\n    dp2[n-2][m-2] = 1\\n    for i:=n-2;i>0;i--{\\n        for j:=m-2;j>0;j--{\\n            if i == n-2 && j == m-2{\\n                continue\\n            } \\n            if grid[i-1][j-1] == 0{\\n                continue\\n            }\\n            dp2[i][j] = dp2[i+1][j]+dp2[i][j+1]\\n        }\\n    }            \\n    \\n    target := dp1[n-2][m-2]\\n\\n    for i:=1;i<n-1;i++{\\n        for j:=1;j<m-1;j++{\\n            if i == 1 && j == 1{\\n                continue\\n            }\\n            if i == n-2 && j == m-2{\\n                continue\\n            }\\n            if grid[i-1][j-1] == 0{\\n                continue\\n            }\\n            if dp1[i][j] * dp2[i][j] == target{\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\\n```python []\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)+2\\n        m = len(grid[0])+2\\n\\n        dp1 = [[0 for _ in range(m)] for _ in range(n)]\\n        dp1[1][1] = 1\\n\\n        for i in range(1,n-1):\\n            for j in range(1,m-1):\\n                if i == 1 and j == 1:\\n                    continue\\n                if grid[i-1][j-1] == 0:\\n                    continue\\n                dp1[i][j] = dp1[i-1][j]+dp1[i][j-1]\\n\\n        if dp1[-2][-2] == 0:\\n            return True\\n                    \\n        dp2 = [[0 for _ in range(m)] for _ in range(n)]\\n        dp2[-2][-2] = 1\\n        for i in range(n-2,0,-1):\\n            for j in range(m-2,0,-1):\\n                if i == n-2 and j == m-2:\\n                    continue\\n                if grid[i-1][j-1] == 0:\\n                    continue\\n                dp2[i][j] = dp2[i+1][j]+dp2[i][j+1]\\n        \\n        \\n        target = dp1[-2][-2]\\n        for i in range(1,n-1):\\n            for j in range(1,m-1):\\n                if i == 1 and j == 1:\\n                    continue\\n                if i == n-2 and j == m-2:\\n                    continue\\n                if grid[i-1][j-1] == 0:\\n                    continue\\n                if dp1[i][j] * dp2[i][j] == target: \\n                    return True\\n        \\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```golang []\\nfunc isPossibleToCutPath(grid [][]int) bool {\\n    n := len(grid)+2\\n    m := len(grid[0])+2\\n\\n    dp1 := [][]int{}\\n    for i:=0;i<n;i++{\\n        dp1 = append(dp1,make([]int,m))\\n    }\\n    dp1[1][1] = 1\\n\\n    for i:=1;i<n-1;i++{\\n        for j:=1;j<m-1;j++{\\n            if i == 1 && j == 1{\\n                continue\\n            }\\n            if grid[i-1][j-1] == 0{\\n                continue\\n            }\\n            dp1[i][j] = dp1[i-1][j]+dp1[i][j-1]\\n        }\\n    }\\n        \\n    if dp1[n-2][m-2] == 0{\\n        return true\\n    }\\n                \\n    dp2 := [][]int{}\\n    for i:=0;i<n;i++{\\n        dp2 = append(dp2,make([]int,m))\\n    }\\n    dp2[n-2][m-2] = 1\\n    for i:=n-2;i>0;i--{\\n        for j:=m-2;j>0;j--{\\n            if i == n-2 && j == m-2{\\n                continue\\n            } \\n            if grid[i-1][j-1] == 0{\\n                continue\\n            }\\n            dp2[i][j] = dp2[i+1][j]+dp2[i][j+1]\\n        }\\n    }            \\n    \\n    target := dp1[n-2][m-2]\\n\\n    for i:=1;i<n-1;i++{\\n        for j:=1;j<m-1;j++{\\n            if i == 1 && j == 1{\\n                continue\\n            }\\n            if i == n-2 && j == m-2{\\n                continue\\n            }\\n            if grid[i-1][j-1] == 0{\\n                continue\\n            }\\n            if dp1[i][j] * dp2[i][j] == target{\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\n```python []\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)+2\\n        m = len(grid[0])+2\\n\\n        dp1 = [[0 for _ in range(m)] for _ in range(n)]\\n        dp1[1][1] = 1\\n\\n        for i in range(1,n-1):\\n            for j in range(1,m-1):\\n                if i == 1 and j == 1:\\n                    continue\\n                if grid[i-1][j-1] == 0:\\n                    continue\\n                dp1[i][j] = dp1[i-1][j]+dp1[i][j-1]\\n\\n        if dp1[-2][-2] == 0:\\n            return True\\n                    \\n        dp2 = [[0 for _ in range(m)] for _ in range(n)]\\n        dp2[-2][-2] = 1\\n        for i in range(n-2,0,-1):\\n            for j in range(m-2,0,-1):\\n                if i == n-2 and j == m-2:\\n                    continue\\n                if grid[i-1][j-1] == 0:\\n                    continue\\n                dp2[i][j] = dp2[i+1][j]+dp2[i][j+1]\\n        \\n        \\n        target = dp1[-2][-2]\\n        for i in range(1,n-1):\\n            for j in range(1,m-1):\\n                if i == 1 and j == 1:\\n                    continue\\n                if i == n-2 and j == m-2:\\n                    continue\\n                if grid[i-1][j-1] == 0:\\n                    continue\\n                if dp1[i][j] * dp2[i][j] == target: \\n                    return True\\n        \\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142207,
                "title": "2-dfs-c-o-n-m",
                "content": "in first dfs, go far most right means go down only if there is no path in right\\nthen in second dfs, go downward and go right only if there is no path in down\\nthe common points will be articulation point for path\\nclass Solution {\\npublic:\\n\\tint n , m ;\\n\\tint mask = 1 ;\\n\\n\\tvector<int>dx = { 0 , 1 } ;\\n\\tvector<int>dy = { 1 , 0 } ;\\n\\n\\tvector<vector<int>>vis;\\n\\n\\tbool outside ( int x , int y )\\n\\t{\\n\\t\\tif ( x < 0 || y < 0 || x >= n || y >= m )\\n\\t\\t\\treturn true ;\\n\\n\\t\\treturn false ;\\n\\t}\\n\\n    int f = 0;\\n    \\n\\tvoid dfs ( int x , int y, vector<vector<int>>& v )\\n\\t{\\n\\t\\tvis[x][y] |= mask ;\\n        if( x == n-1 && y == m-1){\\n            f = 1;\\n            return;\\n        }\\n\\t\\tfor ( int k = 0 ; k < 2 ; k ++ )\\n\\t\\t{\\n\\t\\t\\tint xx = x + dx[k] ;\\n\\t\\t\\tint yy = y + dy[k] ;\\n           \\n\\t\\t\\tif ( outside ( xx , yy ) )\\n\\t\\t\\t\\tcontinue ;\\n             \\n\\t\\t\\tif ( vis[xx][yy] & mask )\\n\\t\\t\\t\\tcontinue ;\\n\\n\\t\\t\\tif ( v[xx][yy] == 0 )\\n\\t\\t\\t\\tcontinue ;\\n\\n\\t\\t\\tdfs ( xx , yy , v) ;\\n\\t\\t\\tif(f) return ;\\n\\t\\t}\\n\\t}\\n\\tint cnt = 0;\\n\\tvoid solve(vector<vector<int>>& grid)\\n\\t{\\n\\t\\tn = grid.size();\\n\\t\\tm = grid[0].size();\\n\\t\\tvis.resize(n, vector<int>(m, 0));\\n\\t\\tdfs ( 0 , 0, grid ) ;\\n        //debug(vis);\\n\\t\\tmask = 2 ;\\n        f = 0;\\n\\t\\tswap ( dx[0] , dx[1] ) ;\\n\\t\\tswap ( dy[0] , dy[1] ) ;\\n\\t\\tdfs ( 0 , 0, grid ) ;\\n        //debug(vis);\\n\\t\\tfor ( int i = 0 ; i < n ; i ++ )\\n\\t\\t{\\n\\t\\t\\tfor ( int j = 0 ; j < m ; j ++ )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( vis[i][j] == 3 )\\n\\t\\t\\t\\t{\\n                    if(i == 0 && j == 0)continue;\\n                    if(i == n - 1 && j == m - 1)continue;\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tbool isPossibleToCutPath(vector<vector<int>>& grid) {\\n\\t\\tsolve(grid);\\n        if(vis[n-1][m-1] == 0)return true;\\n\\t\\treturn cnt >= 1;\\n\\t}\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\tint n , m ;\\n\\tint mask = 1 ;\\n\\n\\tvector<int>dx = { 0 , 1 }",
                "codeTag": "Java"
            },
            {
                "id": 3142195,
                "title": "java-diagonal-checking-o-nxm-time-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe \"target\" cell we are looking for is a cell that is used in all ways from the starting point to the destination.\\nA way from the starting point to the destination is a sequence of cells, where we take one cell from each diagonal.\\nIf a cell is not the \"target\" one, it means that there\\'s at least one other cell, that is lying on the same diagonal and is also accessible from the starting point and destination.\\nIt means that we need to find a diagonal where only one or zero cells are reachable from the start and destination. If there\\'s no such diagonal, means we can find two completele different paths.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. For all cells that are not reachable from the starting point reset value to `0`;\\n2. For all cells from which the destination point is not reachable also reset value to `0`;\\n3. Check if there\\'s at least one diagonal with less than two 1s.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(NxM)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] g) {\\n        for (int i = 0; i < g.length; i++)\\n            for (int j = 0; j < g[0].length; j++)\\n                if (i != 0 || j != 0)\\n                    g[i][j] &= ((i > 0 ? g[i-1][j] : 0) | (j > 0 ? g[i][j-1] : 0));\\n        for (int i = g.length-1; i >= 0; i--)\\n            for (int j = g[0].length-1; j >= 0; j--)\\n                if (i != g.length-1 || j != g[0].length-1)\\n                    g[i][j] &= ((i < g.length-1 ? g[i+1][j] : 0) | (j < g[0].length-1 ? g[i][j+1] : 0));\\n        \\n        int d = g.length + g[0].length - 3;\\n        for (int i = 1; i <= d; i++) {\\n            int c = 0;\\n            for (int j = Math.max(0, i - g.length + 1); j <= Math.min(i, g[0].length-1); j++)\\n                if (g[i-j][j] > 0) c++;\\n            if (c <= 1) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] g) {\\n        for (int i = 0; i < g.length; i++)\\n            for (int j = 0; j < g[0].length; j++)\\n                if (i != 0 || j != 0)\\n                    g[i][j] &= ((i > 0 ? g[i-1][j] : 0) | (j > 0 ? g[i][j-1] : 0));\\n        for (int i = g.length-1; i >= 0; i--)\\n            for (int j = g[0].length-1; j >= 0; j--)\\n                if (i != g.length-1 || j != g[0].length-1)\\n                    g[i][j] &= ((i < g.length-1 ? g[i+1][j] : 0) | (j < g[0].length-1 ? g[i][j+1] : 0));\\n        \\n        int d = g.length + g[0].length - 3;\\n        for (int i = 1; i <= d; i++) {\\n            int c = 0;\\n            for (int j = Math.max(0, i - g.length + 1); j <= Math.min(i, g[0].length-1); j++)\\n                if (g[i-j][j] > 0) c++;\\n            if (c <= 1) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142185,
                "title": "very-simple-and-easy-intuitive-solution-using-idea-of-calculation-of-grid-path-c",
                "content": "# Intuition\\nIf we block a particular cell (i,j) and if we are not able to reach (n-1,m-1) then,\\nLet the total number of ways to reach (i,j) from (n-1,m-1) is x, and total number of ways to reach (i,j) from (0,0) is y, then we can say particular cell (i,j) acts as blockage if x*y = total number of ways to reach (n-1,m-1) from (0,0).\\n# Approach\\nWe will calculate total ways to reach each cell from (0,0) and then from (n-1,m-1) and store it in two vectors.\\nSince number of ways can exceed long long limit , we can make use of mod\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nvector<vector<long long>> dp1(1001,vector<long long>(1001,-1));\\nvector<vector<long long>> dp2(1001,vector<long long>(1001,-1));\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    long long n,m;\\n    \\n    long long helper1(vector<vector<int>>& grid,long long i,long long j){\\n        if(i>=n || j>=m ){\\n            return 0;\\n        }\\n        if(i==n-1 && j==m-1){\\n            return dp1[i][j] = 1;\\n        }\\n        if(dp1[i][j]!=-1){\\n            return dp1[i][j];\\n        }\\n        if(grid[i][j]==0){\\n            return dp1[i][j] = 0;\\n        }\\n        return dp1[i][j] = (helper1(grid,i+1,j)+helper1(grid,i,j+1))%mod;\\n    }\\n    long long helper2(vector<vector<int>>& grid,long long i,long long j){\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(i==0 && j==0){\\n            return dp2[i][j] = 1;\\n        }\\n        if(dp2[i][j]!=-1){\\n            return dp2[i][j];\\n        }\\n        if(grid[i][j]==0){\\n            return dp2[i][j] = 0;\\n        }\\n        return dp2[i][j] = (helper2(grid,i-1,j)+helper2(grid,i,j-1))%mod;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        for(int i=0;i<1000;i++){\\n            for(int j=0;j<1000;j++){\\n                dp1[i][j]=dp2[i][j]=-1;\\n            }\\n        }\\n        n=grid.size();\\n        m=grid[0].size();\\n        helper1(grid,0,0);\\n        helper2(grid,n-1,m-1);\\n        bool flag=false;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!((i==0 && j==0) || (i==n-1 && j==m-1))){\\n                    long long val = (dp1[i][j]*dp2[i][j])%mod;\\n                    if(val==dp1[0][0]){\\n                        flag=true;\\n                    }\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<vector<long long>> dp1(1001,vector<long long>(1001,-1));\\nvector<vector<long long>> dp2(1001,vector<long long>(1001,-1));\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    long long n,m;\\n    \\n    long long helper1(vector<vector<int>>& grid,long long i,long long j){\\n        if(i>=n || j>=m ){\\n            return 0;\\n        }\\n        if(i==n-1 && j==m-1){\\n            return dp1[i][j] = 1;\\n        }\\n        if(dp1[i][j]!=-1){\\n            return dp1[i][j];\\n        }\\n        if(grid[i][j]==0){\\n            return dp1[i][j] = 0;\\n        }\\n        return dp1[i][j] = (helper1(grid,i+1,j)+helper1(grid,i,j+1))%mod;\\n    }\\n    long long helper2(vector<vector<int>>& grid,long long i,long long j){\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(i==0 && j==0){\\n            return dp2[i][j] = 1;\\n        }\\n        if(dp2[i][j]!=-1){\\n            return dp2[i][j];\\n        }\\n        if(grid[i][j]==0){\\n            return dp2[i][j] = 0;\\n        }\\n        return dp2[i][j] = (helper2(grid,i-1,j)+helper2(grid,i,j-1))%mod;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        for(int i=0;i<1000;i++){\\n            for(int j=0;j<1000;j++){\\n                dp1[i][j]=dp2[i][j]=-1;\\n            }\\n        }\\n        n=grid.size();\\n        m=grid[0].size();\\n        helper1(grid,0,0);\\n        helper2(grid,n-1,m-1);\\n        bool flag=false;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!((i==0 && j==0) || (i==n-1 && j==m-1))){\\n                    long long val = (dp1[i][j]*dp2[i][j])%mod;\\n                    if(val==dp1[0][0]){\\n                        flag=true;\\n                    }\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142135,
                "title": "disconnect-path-in-a-binary-matrix-java-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\n     public boolean isPossibleToCutPath(int[][] grid) { \\n  int m = grid.length; \\n  int n = grid[0].length; \\n  boolean[][] marked = new boolean[m][n]; \\n        marked[0][0]=true; \\n  for (int i = 0; i < m; i++) { \\n   for (int j = 0; j < n; j++) { \\n                if(i==0&&j==0)continue; \\n    marked[i][j] = grid[i][j] == 1 \\n      ? ((i > 0 ? marked[i - 1][j] : false) || (j > 0 ? marked[i][j - 1] : false)) \\n      : false; \\n   } \\n  } \\n  if (!marked[m - 1][n - 1]) \\n   return true;  \\n  Queue<int[]> q = new LinkedList<>(); \\n  marked = new boolean[m][n]; \\n  marked[0][0] = true; \\n  q.add(new int[] { 0, 0 }); \\n  while (!q.isEmpty()) { \\n   if (q.size() == 1 && !(q.peek()[0] == 0 && q.peek()[1] == 0) \\n     && !(q.peek()[0] == m - 1 && q.peek()[1] == n - 1)) \\n    return true; \\n   for (int i = 0; i < q.size(); i++) { \\n    int[] del = q.remove(); \\n    int x = del[0], y = del[1]; \\n    if (x + 1 < m && grid[x + 1][y] == 1 && !marked[x + 1][y]) { \\n     marked[x + 1][y] = true; \\n     q.add(new int[] { x + 1, y }); \\n    } \\n    if (y + 1 < n && grid[x][y + 1] == 1 && !marked[x][y + 1]) { \\n     marked[x][y + 1] = true; \\n     q.add(new int[] { x, y + 1 }); \\n    } \\n   } \\n  } \\n  return false; \\n } \\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n     public boolean isPossibleToCutPath(int[][] grid) { \\n  int m = grid.length; \\n  int n = grid[0].length; \\n  boolean[][] marked = new boolean[m][n]; \\n        marked[0][0]=true; \\n  for (int i = 0; i < m; i++) { \\n   for (int j = 0; j < n; j++) { \\n                if(i==0&&j==0)continue; \\n    marked[i][j] = grid[i][j] == 1 \\n      ? ((i > 0 ? marked[i - 1][j] : false) || (j > 0 ? marked[i][j - 1] : false)) \\n      : false; \\n   } \\n  } \\n  if (!marked[m - 1][n - 1]) \\n   return true;  \\n  Queue<int[]> q = new LinkedList<>(); \\n  marked = new boolean[m][n]; \\n  marked[0][0] = true; \\n  q.add(new int[] { 0, 0 }); \\n  while (!q.isEmpty()) { \\n   if (q.size() == 1 && !(q.peek()[0] == 0 && q.peek()[1] == 0) \\n     && !(q.peek()[0] == m - 1 && q.peek()[1] == n - 1)) \\n    return true; \\n   for (int i = 0; i < q.size(); i++) { \\n    int[] del = q.remove(); \\n    int x = del[0], y = del[1]; \\n    if (x + 1 < m && grid[x + 1][y] == 1 && !marked[x + 1][y]) { \\n     marked[x + 1][y] = true; \\n     q.add(new int[] { x + 1, y }); \\n    } \\n    if (y + 1 < n && grid[x][y + 1] == 1 && !marked[x][y + 1]) { \\n     marked[x][y + 1] = true; \\n     q.add(new int[] { x, y + 1 }); \\n    } \\n   } \\n  } \\n  return false; \\n } \\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142124,
                "title": "java-easy-approach-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int f,s;\\n    Pair(int f,int s){\\n        this.f = f;\\n        this.s = s;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if(grid[0][0]==0 || grid[n-1][m-1]==0){\\n            return true;\\n        }\\n        \\n        int visited[][] = new int[n][m];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0,0));\\n        int delrow[] = {0,1};\\n        int delcol[] = {1,0};\\n        \\n        while(!q.isEmpty()){\\n            int r = q.peek().f;\\n            int c = q.peek().s;\\n            q.poll();\\n            if(r==n-1 && c==m-1){\\n                return false;\\n            }\\n            if( (r!=0 || c!=0) && q.size()==0){\\n                return true;\\n            }\\n            for(int i=0;i<=1;i++){\\n                int nrow = r+delrow[i];\\n                int ncol = c+delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==1 && visited[nrow][ncol]==0){\\n                    visited[nrow][ncol] = 1;\\n                    q.add(new Pair(nrow,ncol));\\n                }\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Pair{\\n    int f,s;\\n    Pair(int f,int s){\\n        this.f = f;\\n        this.s = s;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if(grid[0][0]==0 || grid[n-1][m-1]==0){\\n            return true;\\n        }\\n        \\n        int visited[][] = new int[n][m];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0,0));\\n        int delrow[] = {0,1};\\n        int delcol[] = {1,0};\\n        \\n        while(!q.isEmpty()){\\n            int r = q.peek().f;\\n            int c = q.peek().s;\\n            q.poll();\\n            if(r==n-1 && c==m-1){\\n                return false;\\n            }\\n            if( (r!=0 || c!=0) && q.size()==0){\\n                return true;\\n            }\\n            for(int i=0;i<=1;i++){\\n                int nrow = r+delrow[i];\\n                int ncol = c+delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==1 && visited[nrow][ncol]==0){\\n                    visited[nrow][ncol] = 1;\\n                    q.add(new Pair(nrow,ncol));\\n                }\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142087,
                "title": "java-easy-dp-but-does-this-solution-have-an-integer-overflow-problem",
                "content": "```Java\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (m * n <= 2) return false;\\n        \\n        long[][] dp = new long[m][n]; // dp[i][j], is the number of path from (0, 0) reach (i, j);\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) continue;\\n                if (grid[i][j] == 1) {\\n                    dp[i][j] = (i - 1 >= 0 ? dp[i - 1][j] : 0 ) \\n                        + (j - 1 >= 0 ? dp[i][j - 1] : 0);\\n                }\\n            }\\n        }\\n        \\n        long[][] dp2 = new long[m][n]; // dp2[i][j], is the number of path from (m - 1, n - 1) reach (i, j);\\n        dp2[m - 1][n - 1] = 1;\\n        for (int i = m - 1; i >=0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1) continue;\\n                if (grid[i][j] == 1) {\\n                    dp2[i][j] = (i + 1 < m ? dp2[i + 1][j] : 0 ) \\n                        + (j + 1 < n ? dp2[i][j + 1] : 0);\\n                }\\n            }\\n        }\\n        \\n        // if there is a key point.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // System.out.print(dp[i][j] + \" \");\\n                if (i == 0 && j == 0) continue;\\n                if (i == m - 1 && j == n - 1) continue;\\n                if (dp[i][j] * dp2[i][j] == dp[m - 1][n - 1]) return true;\\n            }\\n            // System.out.println();\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (m * n <= 2) return false;\\n        \\n        long[][] dp = new long[m][n]; // dp[i][j], is the number of path from (0, 0) reach (i, j);\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) continue;\\n                if (grid[i][j] == 1) {\\n                    dp[i][j] = (i - 1 >= 0 ? dp[i - 1][j] : 0 ) \\n                        + (j - 1 >= 0 ? dp[i][j - 1] : 0);\\n                }\\n            }\\n        }\\n        \\n        long[][] dp2 = new long[m][n]; // dp2[i][j], is the number of path from (m - 1, n - 1) reach (i, j);\\n        dp2[m - 1][n - 1] = 1;\\n        for (int i = m - 1; i >=0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1) continue;\\n                if (grid[i][j] == 1) {\\n                    dp2[i][j] = (i + 1 < m ? dp2[i + 1][j] : 0 ) \\n                        + (j + 1 < n ? dp2[i][j + 1] : 0);\\n                }\\n            }\\n        }\\n        \\n        // if there is a key point.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // System.out.print(dp[i][j] + \" \");\\n                if (i == 0 && j == 0) continue;\\n                if (i == m - 1 && j == n - 1) continue;\\n                if (dp[i][j] * dp2[i][j] == dp[m - 1][n - 1]) return true;\\n            }\\n            // System.out.println();\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141964,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        vis[0][0] = true;\\n        q.push({0, 0});\\n        while(!q.empty()){\\n            if (q.front().first == m - 1 && q.front().second == n - 1)\\n                return false;\\n            else if (q.size() == 1 && !(q.front().first == 0 && q.front().second == 0) && !(q.front().first == m - 1 && q.front().second == n - 1))\\n                return true;\\n            int s = q.size();\\n            while(s--){\\n                pair<int, int> tmp = q.front();\\n                q.pop();\\n                int x = tmp.first, y = tmp.second;\\n                if (x + 1 < m && grid[x + 1][y] == 1 && !vis[x + 1][y]) {\\n                    vis[x + 1][y] = true;\\n                    q.push({x + 1, y});\\n                }\\n                if (y + 1 < n && grid[x][y + 1] == 1 && !vis[x][y + 1]) {\\n                    vis[x][y + 1] = true;\\n                    q.push({x, y + 1});\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        vis[0][0] = true;\\n        q.push({0, 0});\\n        while(!q.empty()){\\n            if (q.front().first == m - 1 && q.front().second == n - 1)\\n                return false;\\n            else if (q.size() == 1 && !(q.front().first == 0 && q.front().second == 0) && !(q.front().first == m - 1 && q.front().second == n - 1))\\n                return true;\\n            int s = q.size();\\n            while(s--){\\n                pair<int, int> tmp = q.front();\\n                q.pop();\\n                int x = tmp.first, y = tmp.second;\\n                if (x + 1 < m && grid[x + 1][y] == 1 && !vis[x + 1][y]) {\\n                    vis[x + 1][y] = true;\\n                    q.push({x + 1, y});\\n                }\\n                if (y + 1 < n && grid[x][y + 1] == 1 && !vis[x][y + 1]) {\\n                    vis[x][y + 1] = true;\\n                    q.push({x, y + 1});\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141894,
                "title": "c-tarjan-s-algorithm-or-dominator-tree",
                "content": "# Intuition\\nEnumerate all the cut points\\nOR USING DOMINATOR TREE \\n\\n\\n# Code\\n```\\npublic class Solution {\\n    const int N = 1001000, M = 3001000;\\n    int[] dfn = new int[M], low = new int[M], stk = new int[M], id = new int[M];\\n    int idx = 0, ans = 0, timestamp = 0, root = 0, num = 0;\\n    int[] h = new int[N], ne = new int[M], e = new int[M];\\n    int[] dir_x = {0, 0, 1, -1}, dir_y = {1, -1, 0, 0};\\n    \\n    public bool IsPossibleToCutPath(int[][] grid) {\\n        int[] vis = new int[N];\\n        int n = grid.Length, m = grid[0].Length;\\n        int[,] f = new int[n, m];\\n        Array.Fill(h, -1);\\n        \\n        int idx = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                f[i, j] = num++;\\n                if(grid[i][j] == 1) \\n                    vis[f[i, j]] = 1;\\n            }\\n         }\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){\\n                    for(int k = 0; k < 4; k++){\\n                        int x = i + dir_x[k], y = j + dir_y[k];\\n                        if(x < 0 || y < 0 || x >= n || y >= m) continue;\\n                        if(grid[x][y] == 0) continue;\\n                        int u = f[i, j], v = f[x, y];\\n                        e[idx] = v; ne[idx] = h[u]; h[u] = idx++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for(root = 0; root < num; root++){\\n            if(dfn[root] == 0 && vis[root] == 1){\\n                cnt++;\\n                Tarjan(root);\\n            }\\n        }\\n     \\n        return cnt > 1 || ans + cnt - 1 > 1;\\n    }\\n    \\n    public void Tarjan(int u){\\n        dfn[u] = low[u] = ++timestamp;\\n        int cnt = 0;\\n        for (int i = h[u]; i != -1; i = ne[i]){\\n            int j = e[i];\\n            if (dfn[j] == 0){\\n                Tarjan(j);\\n                low[u] = Math.Min(low[u], low[j]);\\n                if (low[j] >= dfn[u]) cnt++;\\n            }\\n            else low[u] = Math.Min(low[u], dfn[j]);\\n        }\\n\\n        if (u != root) cnt++;\\n        ans = Math.Max(ans, cnt);\\n    }\\n}\\n```\\n\\n# Or Dominator Tree\\n```\\npublic class Solution {\\n    const int N = 1000005, M = 2 * N, mod = (int)1e9 + 7;\\n    int[] fa = new int[N], sz = new int[N], dep = new int[M];\\n    int[] h = new int[N], ne = new int[M], e = new int[M];\\n    int[] hd = new int[N], deg = new int[N];\\n    int n = 0, idx = 0, num = 1, flag = 0;\\n    int[,] f = new int[N, 50];\\n    int[] dir_x = {0, 1}, dir_y = {1, 0};\\n    \\n    public bool IsPossibleToCutPath(int[][] grid) {\\n        Array.Fill(h, -1);\\n        Array.Fill(hd, -1);\\n        Array.Fill(fa, -1);\\n\\n        int[] vis = new int[N];\\n        int n = grid.Length, m = grid[0].Length;\\n        int[,] f = new int[n, m];\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                f[i, j] = num++;\\n                if(grid[i][j] == 1)\\n                    vis[f[i, j]] = 1;\\n            }\\n         }\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){\\n                    for(int k = 0; k < 2; k++){\\n                        int x = i + dir_x[k], y = j + dir_y[k];\\n                        if(x < 0 || y < 0 || x >= n || y >= m) continue;\\n                        if(grid[x][y] == 0) continue;\\n                        int u = f[i, j], v = f[x, y];\\n                        ++deg[v];\\n                        Build(h, u, v);\\n                    }\\n                }\\n            }\\n        }\\n        if(deg.Sum() == 0 || deg[num - 1] == 0) return true;\\n        Topo(num);\\n        Dfs(1);\\n        return !(fa[num - 1] <= 1);\\n    }\\n    \\n    public void Build(int[] head, int u, int v){\\n        e[idx] = v; ne[idx] = head[u]; head[u] = idx++;\\n    }\\n\\n    public int Lca(int u, int v){\\n        if(dep[u] < dep[v]){\\n            int tmp = u;\\n            u = v;\\n            v = tmp;\\n        }\\n        for(int i = 18; i >= 0; i--){\\n            if(dep[f[u, i]] >= dep[v]) \\n            u = f[u, i];\\n        }\\n        if(u == v) return v;\\n        for(int i = 18; i >= 0; i--){\\n            if(f[u, i] != f[v, i]){\\n                u = f[u, i];\\n                v = f[v, i];\\n            }\\n        }\\n        return f[u, 0];\\n    }\\n\\n    public void Topo(int num){ \\n        Queue<int> q = new Queue<int>();\\n        int cnt = 0;\\n        for(int i = 1; i < num; i++){\\n            if(deg[i] == 0){\\n                q.Enqueue(i);\\n                fa[i] = 0;\\n            }\\n        }\\n\\n        while(q.Count > 0){\\n            cnt++;\\n            int u = q.Dequeue(), ffa = fa[u];\\n            Build(hd, ffa, u);\\n            f[u, 0] = ffa;\\n            dep[u] = dep[ffa] + 1;\\n            for(int i = 1; i <= 22; i++)\\n                f[u, i] = f[f[u, i - 1], i - 1];\\n            for(int i = h[u]; i != -1; i = ne[i]){\\n                int j = e[i];\\n                if(--deg[j] == 0)\\n                    q.Enqueue(j);\\n                if(fa[j] == -1) fa[j] = u;\\n                else fa[j] = Lca(fa[j], u);\\n            }\\n        }\\n    }\\n\\n    public void Dfs(int u){\\n        sz[u] = sz[num] = 1;\\n        for(int i = hd[u]; i != -1; i = ne[i]){ \\n            int j = e[i];\\n            Dfs(j);\\n            sz[u] += sz[j];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int N = 1001000, M = 3001000;\\n    int[] dfn = new int[M], low = new int[M], stk = new int[M], id = new int[M];\\n    int idx = 0, ans = 0, timestamp = 0, root = 0, num = 0;\\n    int[] h = new int[N], ne = new int[M], e = new int[M];\\n    int[] dir_x = {0, 0, 1, -1}, dir_y = {1, -1, 0, 0};\\n    \\n    public bool IsPossibleToCutPath(int[][] grid) {\\n        int[] vis = new int[N];\\n        int n = grid.Length, m = grid[0].Length;\\n        int[,] f = new int[n, m];\\n        Array.Fill(h, -1);\\n        \\n        int idx = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                f[i, j] = num++;\\n                if(grid[i][j] == 1) \\n                    vis[f[i, j]] = 1;\\n            }\\n         }\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){\\n                    for(int k = 0; k < 4; k++){\\n                        int x = i + dir_x[k], y = j + dir_y[k];\\n                        if(x < 0 || y < 0 || x >= n || y >= m) continue;\\n                        if(grid[x][y] == 0) continue;\\n                        int u = f[i, j], v = f[x, y];\\n                        e[idx] = v; ne[idx] = h[u]; h[u] = idx++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for(root = 0; root < num; root++){\\n            if(dfn[root] == 0 && vis[root] == 1){\\n                cnt++;\\n                Tarjan(root);\\n            }\\n        }\\n     \\n        return cnt > 1 || ans + cnt - 1 > 1;\\n    }\\n    \\n    public void Tarjan(int u){\\n        dfn[u] = low[u] = ++timestamp;\\n        int cnt = 0;\\n        for (int i = h[u]; i != -1; i = ne[i]){\\n            int j = e[i];\\n            if (dfn[j] == 0){\\n                Tarjan(j);\\n                low[u] = Math.Min(low[u], low[j]);\\n                if (low[j] >= dfn[u]) cnt++;\\n            }\\n            else low[u] = Math.Min(low[u], dfn[j]);\\n        }\\n\\n        if (u != root) cnt++;\\n        ans = Math.Max(ans, cnt);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    const int N = 1000005, M = 2 * N, mod = (int)1e9 + 7;\\n    int[] fa = new int[N], sz = new int[N], dep = new int[M];\\n    int[] h = new int[N], ne = new int[M], e = new int[M];\\n    int[] hd = new int[N], deg = new int[N];\\n    int n = 0, idx = 0, num = 1, flag = 0;\\n    int[,] f = new int[N, 50];\\n    int[] dir_x = {0, 1}, dir_y = {1, 0};\\n    \\n    public bool IsPossibleToCutPath(int[][] grid) {\\n        Array.Fill(h, -1);\\n        Array.Fill(hd, -1);\\n        Array.Fill(fa, -1);\\n\\n        int[] vis = new int[N];\\n        int n = grid.Length, m = grid[0].Length;\\n        int[,] f = new int[n, m];\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                f[i, j] = num++;\\n                if(grid[i][j] == 1)\\n                    vis[f[i, j]] = 1;\\n            }\\n         }\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){\\n                    for(int k = 0; k < 2; k++){\\n                        int x = i + dir_x[k], y = j + dir_y[k];\\n                        if(x < 0 || y < 0 || x >= n || y >= m) continue;\\n                        if(grid[x][y] == 0) continue;\\n                        int u = f[i, j], v = f[x, y];\\n                        ++deg[v];\\n                        Build(h, u, v);\\n                    }\\n                }\\n            }\\n        }\\n        if(deg.Sum() == 0 || deg[num - 1] == 0) return true;\\n        Topo(num);\\n        Dfs(1);\\n        return !(fa[num - 1] <= 1);\\n    }\\n    \\n    public void Build(int[] head, int u, int v){\\n        e[idx] = v; ne[idx] = head[u]; head[u] = idx++;\\n    }\\n\\n    public int Lca(int u, int v){\\n        if(dep[u] < dep[v]){\\n            int tmp = u;\\n            u = v;\\n            v = tmp;\\n        }\\n        for(int i = 18; i >= 0; i--){\\n            if(dep[f[u, i]] >= dep[v]) \\n            u = f[u, i];\\n        }\\n        if(u == v) return v;\\n        for(int i = 18; i >= 0; i--){\\n            if(f[u, i] != f[v, i]){\\n                u = f[u, i];\\n                v = f[v, i];\\n            }\\n        }\\n        return f[u, 0];\\n    }\\n\\n    public void Topo(int num){ \\n        Queue<int> q = new Queue<int>();\\n        int cnt = 0;\\n        for(int i = 1; i < num; i++){\\n            if(deg[i] == 0){\\n                q.Enqueue(i);\\n                fa[i] = 0;\\n            }\\n        }\\n\\n        while(q.Count > 0){\\n            cnt++;\\n            int u = q.Dequeue(), ffa = fa[u];\\n            Build(hd, ffa, u);\\n            f[u, 0] = ffa;\\n            dep[u] = dep[ffa] + 1;\\n            for(int i = 1; i <= 22; i++)\\n                f[u, i] = f[f[u, i - 1], i - 1];\\n            for(int i = h[u]; i != -1; i = ne[i]){\\n                int j = e[i];\\n                if(--deg[j] == 0)\\n                    q.Enqueue(j);\\n                if(fa[j] == -1) fa[j] = u;\\n                else fa[j] = Lca(fa[j], u);\\n            }\\n        }\\n    }\\n\\n    public void Dfs(int u){\\n        sz[u] = sz[num] = 1;\\n        for(int i = hd[u]; i != -1; i = ne[i]){ \\n            int j = e[i];\\n            Dfs(j);\\n            sz[u] += sz[j];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141890,
                "title": "c-bfs-detect-single-point-of-failure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart from (0, 0), we explore all possible neighboring cells to move to if it is allowed. Until the moment when we were left with only cell. \\nIf the cell is the end cell, it means we can reach here with more than 1 ways.\\nIf the cell is not the end cell, it means we can flip the cell and virtually cut the connection.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS is the good way to implement the idea with a little variation. Instead of using a queue to keep all possible neighboring cells, use a unordered set to keep unique cells. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n    \\n        int m = grid.size(), n = grid[0].size();\\n        unordered_set<int> from;\\n        \\n        from.insert(0);\\n        while(!from.empty()) {\\n            unordered_set<int> next;\\n            for(int pos : from) {\\n                int i = pos/1001, j = pos%1001;\\n                \\n                if(i==m-1 && j==n-1) return false;\\n                \\n                if(i+1 < m && grid[i+1][j]==1) {\\n                    next.insert((i+1)*1001+j);\\n                }\\n                if(j+1 < n && grid[i][j+1]==1) {\\n                    next.insert(i*1001+j+1);\\n                }\\n            }\\n            swap(from, next);\\n            \\n            if(from.size()==1 && *from.begin() != (m-1)*1001+n-1)\\n                return true;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n    \\n        int m = grid.size(), n = grid[0].size();\\n        unordered_set<int> from;\\n        \\n        from.insert(0);\\n        while(!from.empty()) {\\n            unordered_set<int> next;\\n            for(int pos : from) {\\n                int i = pos/1001, j = pos%1001;\\n                \\n                if(i==m-1 && j==n-1) return false;\\n                \\n                if(i+1 < m && grid[i+1][j]==1) {\\n                    next.insert((i+1)*1001+j);\\n                }\\n                if(j+1 < n && grid[i][j+1]==1) {\\n                    next.insert(i*1001+j+1);\\n                }\\n            }\\n            swap(from, next);\\n            \\n            if(from.size()==1 && *from.begin() != (m-1)*1001+n-1)\\n                return true;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141888,
                "title": "simple-dfs-solution-explained-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to find 2 unique path that uses unique cells so this can only happen if we have (0,1) and (1,0) as 1 then only we can have 2 unique path using these 2 cells you can see this right . We can have more than 1 ways to reach at bottom using both cells but in those ways we will have these cells common .\\nSo we will do dfs to find if we can reach to bottom through these 2 cells , so if we can then we return false or we return true .\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    void dfs(int r,int c, vector<vector<int>>& g, vector<vector<bool>> &vis){\\n        if(r >= g.size() || c >= g[0].size() || g[r][c] == 0 || vis[r][c]) return;\\n        if(r == g.size()-1 && c == g[0].size()-1){ ans++; return;}\\n        vis[r][c] = 1;\\n        // go right\\n        dfs(r,c+1,g,vis);\\n        if(ans > 0) return; // if we have found answer with this path then return\\n        // go down\\n        dfs(r+1,c,g,vis);\\n    }\\n    \\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        // if we have more than 2 unique ways then we cannot do that\\n        // so we will do dfs from right and down of top point and if we can find 2 unique ways then we return false else return 1;\\n        // we can only move right and down\\n        // so first we check\\n        ans = 0; \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // some basic conditions in which answer will be constant\\n        if((m == 1 && n == 1) || (m == 1 && n == 2) || (m == 2 && n == 1)) return 0;\\n        if((m == 1 && n > 2) || (m > 2 && n == 1)) return 1;\\n        if(m > 2 && n > 2 && (!(grid[0][1] && grid[1][0]))) return 1;\\n        vector<vector<bool>> vis(m,vector<bool>(n,0));\\n        dfs(0,1,grid,vis); // dfs from right\\n        int ans2 = ans > 0 ? 1 : 0; // if ans\\n        ans = 0;\\n        dfs(1,0,grid,vis);\\n        ans = ans > 0 ? 1 : 0;\\n        return !(ans&ans2)  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void dfs(int r,int c, vector<vector<int>>& g, vector<vector<bool>> &vis){\\n        if(r >= g.size() || c >= g[0].size() || g[r][c] == 0 || vis[r][c]) return;\\n        if(r == g.size()-1 && c == g[0].size()-1){ ans++; return;}\\n        vis[r][c] = 1;\\n        // go right\\n        dfs(r,c+1,g,vis);\\n        if(ans > 0) return; // if we have found answer with this path then return\\n        // go down\\n        dfs(r+1,c,g,vis);\\n    }\\n    \\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        // if we have more than 2 unique ways then we cannot do that\\n        // so we will do dfs from right and down of top point and if we can find 2 unique ways then we return false else return 1;\\n        // we can only move right and down\\n        // so first we check\\n        ans = 0; \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // some basic conditions in which answer will be constant\\n        if((m == 1 && n == 1) || (m == 1 && n == 2) || (m == 2 && n == 1)) return 0;\\n        if((m == 1 && n > 2) || (m > 2 && n == 1)) return 1;\\n        if(m > 2 && n > 2 && (!(grid[0][1] && grid[1][0]))) return 1;\\n        vector<vector<bool>> vis(m,vector<bool>(n,0));\\n        dfs(0,1,grid,vis); // dfs from right\\n        int ans2 = ans > 0 ? 1 : 0; // if ans\\n        ans = 0;\\n        dfs(1,0,grid,vis);\\n        ans = ans > 0 ? 1 : 0;\\n        return !(ans&ans2)  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141887,
                "title": "simple-2-bfs-check-number-of-path-at-each-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs distance fron `(0,0)` to `(n-1, m-1)` is always same if we follow any path.\\nSo, just check congestion in number of path i.e how many number of path is there for moving forward.\\nIf `min` path of all level is `<= 1` then `true` else `false`.\\n\\nHere we have to check congestion in path from `(0, 0)`  to `(n-1, m-1)` and from `(n-1, m-1)` to `(0, 0)` both.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        return bfs(0, 0, new int[]{0, 1}, new int[]{1, 0}, grid) \\n                || bfs(n-1, m-1, new int[]{0, -1}, new int[]{-1, 0}, grid);\\n    }\\n    public boolean bfs(int x, int y, int []dr, int []dc, int [][]grid){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<pair> queue = new LinkedList<>();\\n        queue.add(new pair(x, y));\\n        \\n        int min = (int)1e8;\\n        int val = 1;\\n        while(!queue.isEmpty()){\\n\\n            val++;\\n            int size = queue.size();\\n\\n            int count = 0;\\n            List<pair> set = new ArrayList<>();\\n            while(size > 0){\\n                int X = queue.peek().x;\\n                int Y = queue.peek().y;\\n                queue.poll();\\n\\n                if(X == n-1 - x && Y == m-1 - y){\\n                    break;\\n                }\\n\\n                for(int i = 0; i < 2; i++){\\n                    int newX = X + dr[i];\\n                    int newY = Y + dc[i];\\n                    if(newX < n && newY < m && newX >= 0 && newY >= 0 && grid[newX][newY] == 1){\\n                        pair p = new pair(newX, newY);\\n                        if(!check(p, set)) {\\n                            count++;\\n                            queue.add(new pair(newX, newY));\\n                            set.add(new pair(newX, newY));\\n                        }\\n                    }\\n                }\\n\\n                size--;\\n            }\\n\\n            if(val < n + m - 1) {\\n                min = Math.min(min, count);\\n            }\\n        }\\n        if(min <= 1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public boolean check(pair p, List<pair> list){\\n        for(pair pp : list){\\n            if(pp.x == p.x && pp.y == p.y){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\nclass pair{\\n    int x;\\n    int y;\\n    pair(int x, int y){\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        return bfs(0, 0, new int[]{0, 1}, new int[]{1, 0}, grid) \\n                || bfs(n-1, m-1, new int[]{0, -1}, new int[]{-1, 0}, grid);\\n    }\\n    public boolean bfs(int x, int y, int []dr, int []dc, int [][]grid){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<pair> queue = new LinkedList<>();\\n        queue.add(new pair(x, y));\\n        \\n        int min = (int)1e8;\\n        int val = 1;\\n        while(!queue.isEmpty()){\\n\\n            val++;\\n            int size = queue.size();\\n\\n            int count = 0;\\n            List<pair> set = new ArrayList<>();\\n            while(size > 0){\\n                int X = queue.peek().x;\\n                int Y = queue.peek().y;\\n                queue.poll();\\n\\n                if(X == n-1 - x && Y == m-1 - y){\\n                    break;\\n                }\\n\\n                for(int i = 0; i < 2; i++){\\n                    int newX = X + dr[i];\\n                    int newY = Y + dc[i];\\n                    if(newX < n && newY < m && newX >= 0 && newY >= 0 && grid[newX][newY] == 1){\\n                        pair p = new pair(newX, newY);\\n                        if(!check(p, set)) {\\n                            count++;\\n                            queue.add(new pair(newX, newY));\\n                            set.add(new pair(newX, newY));\\n                        }\\n                    }\\n                }\\n\\n                size--;\\n            }\\n\\n            if(val < n + m - 1) {\\n                min = Math.min(min, count);\\n            }\\n        }\\n        if(min <= 1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public boolean check(pair p, List<pair> list){\\n        for(pair pp : list){\\n            if(pp.x == p.x && pp.y == p.y){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\nclass pair{\\n    int x;\\n    int y;\\n    pair(int x, int y){\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141776,
                "title": "racket-solution",
                "content": "# Intuition\\n\\nWe use a DP matrix to record if a node is reachable.\\nThe distance from $(0,0)$ to $(m-1,n-1)$ is $d=m-1+n-1$.\\nFor $1 \\\\le k < d$, there should always be a reachable node $(i,j)$ that meet $i+j = k$.\\nFor a given k, if there only one node meet that condition, we can remove it to get a disconnected graph.\\n\\n# Complexity\\n\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$\\n\\n# Code\\n\\n```racket\\n(define (is-possible-to-cut-path grid-lst)\\n  (define grid (for/vector ([row grid-lst])\\n                 (for/vector ([v row])\\n                   v)))\\n  (define m (vector-length grid))\\n  (define n (vector-length (aref grid 0)))\\n  (define counts (make-vector (+ m n) 0))\\n  (define reachable (make-array m n #f))\\n  (aset! reachable 0 0 #t)\\n  (for* ([i m]\\n         [j n])\\n    (when (and (= 1 (aref grid i j))\\n               (or (if (= i 0) #f (aref reachable (sub1 i) j))\\n                   (if (= j 0) #f (aref reachable i (sub1 j)))))\\n      (aset! reachable i j #t)\\n      (aupd! counts (+ i j) add1)))\\n  (for/or ([i (range 1 (+ m n -2))])\\n    (<= (aref counts i) 1)))\\n\\n(define-syntax-rule (aupd! arr dims ... fn)\\n  (aset! arr dims ... (fn (aref arr dims ...))))\\n\\n(define-syntax aset!\\n  (syntax-rules ()\\n    [(_ arr i v)\\n     (vector-set! arr i v)]\\n    [(_ arr i args ... v)\\n     (aset! (vector-ref arr i) args ... v)]))\\n\\n(define-syntax aref\\n  (syntax-rules ()\\n    [(_ arr) arr]\\n    [(_ arr i args ...)\\n     (aref (vector-ref arr i) args ...)]))\\n\\n(define-syntax make-array\\n  (syntax-rules ()\\n    [(_ n init)\\n     (make-vector n init)]\\n    [(_ n args ...)\\n     (build-vector n (lambda _ (make-array args ...)))]))\\n\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```racket\\n(define (is-possible-to-cut-path grid-lst)\\n  (define grid (for/vector ([row grid-lst])\\n                 (for/vector ([v row])\\n                   v)))\\n  (define m (vector-length grid))\\n  (define n (vector-length (aref grid 0)))\\n  (define counts (make-vector (+ m n) 0))\\n  (define reachable (make-array m n #f))\\n  (aset! reachable 0 0 #t)\\n  (for* ([i m]\\n         [j n])\\n    (when (and (= 1 (aref grid i j))\\n               (or (if (= i 0) #f (aref reachable (sub1 i) j))\\n                   (if (= j 0) #f (aref reachable i (sub1 j)))))\\n      (aset! reachable i j #t)\\n      (aupd! counts (+ i j) add1)))\\n  (for/or ([i (range 1 (+ m n -2))])\\n    (<= (aref counts i) 1)))\\n\\n(define-syntax-rule (aupd! arr dims ... fn)\\n  (aset! arr dims ... (fn (aref arr dims ...))))\\n\\n(define-syntax aset!\\n  (syntax-rules ()\\n    [(_ arr i v)\\n     (vector-set! arr i v)]\\n    [(_ arr i args ... v)\\n     (aset! (vector-ref arr i) args ... v)]))\\n\\n(define-syntax aref\\n  (syntax-rules ()\\n    [(_ arr) arr]\\n    [(_ arr i args ...)\\n     (aref (vector-ref arr i) args ...)]))\\n\\n(define-syntax make-array\\n  (syntax-rules ()\\n    [(_ n init)\\n     (make-vector n init)]\\n    [(_ n args ...)\\n     (build-vector n (lambda _ (make-array args ...)))]))\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141673,
                "title": "c-simple-diagonal-examine-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        map<int,int> a;\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j])\\n                    a[i+j]++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=1;i<=m+n-3;i++){\\n            if(a[i]<=1) return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        map<int,int> a;\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j])\\n                    a[i+j]++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=1;i<=m+n-3;i++){\\n            if(a[i]<=1) return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1789101,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1790419,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1790396,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1791766,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1787899,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1787716,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1787594,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1908541,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1805911,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1790481,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1789101,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1790419,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1790396,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1791766,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1787899,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1787716,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1787594,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1908541,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1805911,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            },
            {
                "id": 1790481,
                "content": [
                    {
                        "username": "Varan03",
                        "content": "grid = [[1,1,1,0,1],[0,1,1,0,1],[0,1,1,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]]\n\nAbove test case should give correct output as TRUE but sadly these cases are *not included in the test cases used for judging* so **wrong submissions are also being accepted**. I request problem @setters and @testers to look into this. \n\n\nThank you "
                    },
                    {
                        "username": "Varan03",
                        "content": "I have seen **accepted submissions checking the diagonals except first and last**.\\nPlease consider this test case.\\n\\nGrid = [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]]\\nCorrect output: True \\n\\nBut your code\\'s output will be False. \\n\\nThe logic of storing level[i+j] and checking this is less than 2 is **not the correct logic**. \\n*Weak test cases* :( \\n\\nThank you "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Should be moved to **Hard** to my mind"
                    },
                    {
                        "username": "luckymaster",
                        "content": "Can some one Explain how the answer for this test case is TRUE.\\n `[[1,1,0,1,1,1],[1,1,1,1,0,1],[1,1,1,1,1,1]]`"
                    },
                    {
                        "username": "sksonalkothari9",
                        "content": "if you flip value at grid[2][3] to 0, you can actually make this disconnected in 1 flip "
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "there are only 2 directions possible, just read it in the question for the first time after seeing this comment :)"
                    },
                    {
                        "username": "Michael_V",
                        "content": "Guys, I think I found a much simpler approach by noticing a nice trick. Check out my [solution](https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solutions/3142446/python-diagonal-trick-simple-and-intuitive-solution/) if you are interested."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "why is this approach wrong 28/71 TC passes\ndp[i][j] =number of possible paths\n if we are allowed to flip at most one cell then if number of valid paths>=2 then false\nelse true\ndid i miss something??????\n\n```\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if i-1 >= 0:\n                        dp[i][j] += dp[i-1][j]\n                    if j-1 >= 0:\n                        dp[i][j] += dp[i][j-1]\n\n\n        if dp[n-1][m-1]<2:\n            return True\n        return False\n```"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "there might be possible  a single bridge connecting several path and as a result we have many paths between source and destination but still we can disconnect the path by switching either of the nodes of bridge."
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "[@sarthak_045](/sarthak_045) I started by thinking that the squares adjacent to the corner must be \\'1\\', because otherwise if you change one of those squares, the path becomes unreachable. Next, each of these cells must have at least one \\'1\\' cell that does not intersect with a cell from the other path, and so on until the opposite corner is reached."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "btw we need to only check if there exist any cell such that all possible paths must go thorough it then we can flip that and make matrix disconnected. right?\\n[@sanmayaj](/sanmayaj) "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sanmayaj](/sanmayaj) ohh thanks for the test case explaination\\uD83D\\uDE4C"
                    },
                    {
                        "username": "sanmayaj",
                        "content": "Say you have something like:\n```\n1 1 1 1\n1 1 1 1\n0 1 1 1\n0 0 1 1\n0 0 0 1\n0 0 0 1\n```\n\nYou can flip the last 1 in the second last row to make it disconnect. Exactly what [@sprightlyowl13](/sprightlyowl13) said"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@sprightlyowl13](/sprightlyowl13) how you came up with this observation?"
                    },
                    {
                        "username": "sprightlyowl13",
                        "content": "There must be two *completely disjoint* paths between the corners (like a round trip) , so that both paths cannot be changed by changing one cell. If path A and path B have some cells in common, it is only one path. \\nHope it helps you."
                    },
                    {
                        "username": "space_invader",
                        "content": "Check diagonals except the first and the last."
                    },
                    {
                        "username": "Varan03",
                        "content": "Grid : [[1,1,1,1,1,0],[1,1,1,1,0,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,1,1,1,1,1],[0,0,0,0,1,1]] \\nRun your code for this test case. "
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "Why this works \n```\nclass Solution {\npublic:\nbool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        return func(x + 1, y, grid) || func(x, y + 1, grid);\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```\nBut this does not works \n# Even though both code are exactly same \n```\nclass Solution {\npublic:\n    bool func(int x, int y, vector<vector<int>> &grid)\n    {\n        int n = grid.size(), m = grid[0].size();\n        if (x == n - 1 && y == m - 1)\n            return true;\n        if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0)\n            return false;\n        grid[x][y] = 0;\n        bool down = func(x + 1, y, grid);\n        bool right = func(x, y + 1, grid);\n        return down || right;\n    }\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\n        bool first_call = func(0, 0, grid);\n        if (!first_call)\n            return true;\n        grid[0][0] = 1;\n        bool second_call = func(0, 0, grid);\n        return !second_call;\n    }\n};\n```"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why this code is giving me TLE \\n```\\nclass Solution {\\npublic:\\n    int row[2] = {0, 1};\\n    int col[2] = {1, 0};\\n    bool isSafe(int i, int j, int n, int m){\\n        return i >= 0 and i < n and j >= 0 and j < m;\\n    }\\n    bool dfs(int x, int y, int n, int m, vector<vector<int>>& grid){\\n        if(x == n-1 and y == m-1) { return true; }\\n        for(int i = 0; i < 2; i++){\\n            int newX = x+row[i];\\n            int newY = y+col[i];\\n            if(isSafe(newX, newY, n, m) and grid[newX][newY] == 1){\\n                if(dfs(newX, newY, n, m, grid)){\\n                    if(x != 0 || y != 0)\\n                        grid[x][y] = 0;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int path = 0;\\n        for(int i = 0; i < 2; i++){\\n            if (dfs(0, 0, n, m, grid)){\\n                path++;\\n            }\\n        }\\n        return path == 2?false:true;\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "saieswar87",
                        "content": "class Solution {\\npublic:\\n    int left,down;\\n    int PossiblePaths(vector<vector<int>>& v,int i,int j,int m,int n,          vector<vector<int>>&dp)\\n    {\\n        if(i==m-1 && j==n-1) return 1;\\n        if(i>=m || j>=n) return 0;\\n        if(v[i][j]==0) return dp[i][j]=0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        left=PossiblePaths(v,i,j+1,m,n,dp);\\n        down=PossiblePaths(v,i+1,j,m,n,dp);\\n        dp[i][j]=left+down;\\n        return dp[i][j];\\n    }\\n    bool isPossibleToCutPath(vector<vector<int>>& g) {\\n        int paths,m=g.size(),n=g[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        paths=PossiblePaths(g,0,0,m,n,dp);\\n        if(paths<=1) return true;\\n        return false;\\n    }\\n};\\n\\nGetting wrong answer for the sample testcases .........any one please help me to figure out where the problem was i am unable to find.Please help me out of this."
                    }
                ]
            }
        ]
    }
]