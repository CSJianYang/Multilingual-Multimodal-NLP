[
    {
        "title": "Find Common Characters",
        "question_content": "Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\n&nbsp;\nExample 1:\nInput: words = [\"bella\",\"label\",\"roller\"]\nOutput: [\"e\",\"l\",\"l\"]\nExample 2:\nInput: words = [\"cool\",\"lock\",\"cook\"]\nOutput: [\"c\",\"o\"]\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 100\n\t1 <= words[i].length <= 100\n\twords[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 3540699,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        \\n        sort(words.begin(), words.end());\\n        \\n        for (char c : words[0]) {\\n            bool common = true;\\n            \\n            for (int i = 1; i < words.size(); i++) {\\n                if (words[i].find(c) == string::npos) {\\n                    common = false;\\n                    break;\\n                } else {\\n                    words[i].erase(words[i].find(c), 1);\\n                }\\n            }\\n            if (common) {\\n                res.push_back(string(1, c));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        if len(words) < 2:\\n            return words\\n        res = []\\n        word1 = set(words[0])\\n        for char in word1:\\n            frequency = min([word.count(char) for word in words])\\n            res += [char] * frequency\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n   public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }\\n        List<String> arr = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (last[i] != 0) {\\n                char a = \\'a\\';\\n                a += i;\\n                String s = String.valueOf(a);\\n                while (last[i] > 0) {\\n                    arr.add(s);\\n                    last[i]--;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n    int[] intersection(int[] a, int[] b) {\\n        int[] t = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            t[i] = Math.min(a[i], b[i]);\\n        }\\n        return t;\\n    }\\n    int[] count(String str) {\\n        int[] t = new int[26];\\n        for (char c : str.toCharArray()) t[c - \\'a\\']++;\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        \\n        sort(words.begin(), words.end());\\n        \\n        for (char c : words[0]) {\\n            bool common = true;\\n            \\n            for (int i = 1; i < words.size(); i++) {\\n                if (words[i].find(c) == string::npos) {\\n                    common = false;\\n                    break;\\n                } else {\\n                    words[i].erase(words[i].find(c), 1);\\n                }\\n            }\\n            if (common) {\\n                res.push_back(string(1, c));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        if len(words) < 2:\\n            return words\\n        res = []\\n        word1 = set(words[0])\\n        for char in word1:\\n            frequency = min([word.count(char) for word in words])\\n            res += [char] * frequency\\n        return res\\n```\n```Java []\\nclass Solution {\\n   public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }\\n        List<String> arr = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (last[i] != 0) {\\n                char a = \\'a\\';\\n                a += i;\\n                String s = String.valueOf(a);\\n                while (last[i] > 0) {\\n                    arr.add(s);\\n                    last[i]--;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n    int[] intersection(int[] a, int[] b) {\\n        int[] t = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            t[i] = Math.min(a[i], b[i]);\\n        }\\n        return t;\\n    }\\n    int[] count(String str) {\\n        int[] t = new int[26];\\n        for (char c : str.toCharArray()) t[c - \\'a\\']++;\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247560,
                "title": "python-1-line",
                "content": "```\\n    def commonChars(self, A):\\n        res = collections.Counter(A[0])\\n        for a in A:\\n            res &= collections.Counter(a)\\n        return list(res.elements())\\n```\\n\\n1-line version\\n```\\n    def commonChars(self, A):\\n        return list(reduce(collections.Counter.__and__, map(collections.Counter, A)).elements())\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def commonChars(self, A):\\n        res = collections.Counter(A[0])\\n        for a in A:\\n            res &= collections.Counter(a)\\n        return list(res.elements())\\n```\n```\\n    def commonChars(self, A):\\n        return list(reduce(collections.Counter.__and__, map(collections.Counter, A)).elements())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 247573,
                "title": "c-o-n-o-1-two-vectors",
                "content": "For each string, we count characters in ```cnt1```. Then, we track the minimum count for each character in ```cnt```.\\n```\\nvector<string> commonChars(vector<string>& A) {\\n  vector<int> cnt(26, INT_MAX);\\n  vector<string> res;\\n  for (auto s : A) {\\n    vector<int> cnt1(26, 0);\\n    for (auto c : s) ++cnt1[c - \\'a\\'];\\n    for (auto i = 0; i < 26; ++i) cnt[i] = min(cnt[i], cnt1[i]);\\n  }\\n  for (auto i = 0; i < 26; ++i)\\n    for (auto j = 0; j < cnt[i]; ++j) res.push_back(string(1, i + \\'a\\'));\\n  return res;\\n}\\n```\\n## Complexity Analysis\\nRuntime: *O(n)*, where *n* is the total number of characters.\\nMemory: *O(1)* (we use two fixed-size vectors).",
                "solutionTags": [],
                "code": "```cnt1```\n```cnt```\n```\\nvector<string> commonChars(vector<string>& A) {\\n  vector<int> cnt(26, INT_MAX);\\n  vector<string> res;\\n  for (auto s : A) {\\n    vector<int> cnt1(26, 0);\\n    for (auto c : s) ++cnt1[c - \\'a\\'];\\n    for (auto i = 0; i < 26; ++i) cnt[i] = min(cnt[i], cnt1[i]);\\n  }\\n  for (auto i = 0; i < 26; ++i)\\n    for (auto j = 0; j < cnt[i]; ++j) res.push_back(string(1, i + \\'a\\'));\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247558,
                "title": "java-python-3-12-liner-and-7-liner-count-and-look-for-minimum",
                "content": "Initialize `count` array with `Integer.MAX_VALUE`, loop through the input to count the chars in each string; then find out the minimum for each char.\\n\\n**Method 1:**\\n\\n```\\n    public List<String> commonChars(String[] A) {\\n        List<String> ans = new ArrayList<>();\\n        int[] count = new int[26]; \\n        Arrays.fill(count, Integer.MAX_VALUE);\\n        for (String str : A) {\\n            int[] cnt = new int[26];\\n            str.chars().forEach(c -> ++cnt[c - \\'a\\']); // count each char\\'s frequency in string str.\\n            for (int i = 0; i < 26; ++i) { count[i] = Math.min(cnt[i], count[i]); } // update minimum frequency.\\n        }\\n        for (char c = \\'a\\'; c <= \\'z\\'; ++c) {\\n            while (count[c - \\'a\\']-- > 0) { ans.add(\"\" + c); }\\n        }\\n        return ans;\\n    }\\n```\\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        cnt = [float(\\'inf\\')] * 26\\n        for s in A:\\n            cnt2 = [0] * 26\\n            for c in s:\\n                cnt2[ord(c) - ord(\\'a\\')] += 1\\n            cnt = [min(cnt[i], cnt2[i]) for i in range(26)]    \\n        return [c for k, c in zip(cnt, string.ascii_lowercase) for _ in range(k)]\\n```\\nor use `Counter`:\\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        cnt = collections.Counter(A[0])\\n        for s in A:\\n            cnt2 = collections.Counter(s)\\n            for k in cnt.keys():\\n                cnt[k] = min(cnt[k], cnt2[k])\\n        return cnt.elements()\\n```\\n\\n----\\n**Method 2: Java 8 Stream**\\n\\n```\\n    public List<String> commonChars(String[] A) {\\n        int[] count = new int[26]; \\n        Arrays.fill(count, Integer.MAX_VALUE);\\n        for (String str : A) {\\n            int[] cnt = new int[26];\\n            str.chars().forEach(c -> ++cnt[c - \\'a\\']); // count each char\\'s frequency in string str.\\n            IntStream.range(0, 26).forEach(i ->  count[i] = Math.min(cnt[i], count[i])); // update minimum frequency.\\n        }\\n        List<String> ans = new ArrayList<>();\\n        IntStream.range(\\'a\\', \\'z\\' + 1).forEach(c ->  ans.addAll(Collections.nCopies(count[c - \\'a\\'], \"\" + (char)c)));\\n        return ans;\\n    }\\n```\\n\\n----\\n\\n**Analysis:**\\n**Time: O(n)**, where `n` is the total number of characters in A; \\n**extra space: O(1)**, excludes output/return space.\\n\\n----\\n\\n**Q & A**:\\n\\nQ: What does ` ++cnt[c - \\'a\\']; ` mean?\\n\\nA: \\ncount the frequency of chars in String str.\\n\\nc : cnt[c - \\'a\\'] \\n-----------------------------\\n\\'a\\': cnt[\\'a\\' - \\'a\\'] = cnt[0]\\n\\'b\\': cnt[\\'b\\' - \\'a\\'] = cnt[1]\\n\\'c\\': cnt[\\'c\\' - \\'a\\'] = cnt[2]\\n...\\n\\'z\\': cnt[\\'z\\' - \\'a\\'] = cnt[25]\\n--------------------------------\\nif char `c` represents `\\'x\\'`, then  `cnt[c - \\'a\\'] = cnt[23]`. That is, when encountering char \\'x\\', we increase cnt[23] by 1. \\n\\nTherefore, after traversal of all chars in String `str`, we have the frequency (number of occurrence) of each char in `cnt`.",
                "solutionTags": [],
                "code": "```\\n    public List<String> commonChars(String[] A) {\\n        List<String> ans = new ArrayList<>();\\n        int[] count = new int[26]; \\n        Arrays.fill(count, Integer.MAX_VALUE);\\n        for (String str : A) {\\n            int[] cnt = new int[26];\\n            str.chars().forEach(c -> ++cnt[c - \\'a\\']); // count each char\\'s frequency in string str.\\n            for (int i = 0; i < 26; ++i) { count[i] = Math.min(cnt[i], count[i]); } // update minimum frequency.\\n        }\\n        for (char c = \\'a\\'; c <= \\'z\\'; ++c) {\\n            while (count[c - \\'a\\']-- > 0) { ans.add(\"\" + c); }\\n        }\\n        return ans;\\n    }\\n```\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        cnt = [float(\\'inf\\')] * 26\\n        for s in A:\\n            cnt2 = [0] * 26\\n            for c in s:\\n                cnt2[ord(c) - ord(\\'a\\')] += 1\\n            cnt = [min(cnt[i], cnt2[i]) for i in range(26)]    \\n        return [c for k, c in zip(cnt, string.ascii_lowercase) for _ in range(k)]\\n```\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        cnt = collections.Counter(A[0])\\n        for s in A:\\n            cnt2 = collections.Counter(s)\\n            for k in cnt.keys():\\n                cnt[k] = min(cnt[k], cnt2[k])\\n        return cnt.elements()\\n```\n```\\n    public List<String> commonChars(String[] A) {\\n        int[] count = new int[26]; \\n        Arrays.fill(count, Integer.MAX_VALUE);\\n        for (String str : A) {\\n            int[] cnt = new int[26];\\n            str.chars().forEach(c -> ++cnt[c - \\'a\\']); // count each char\\'s frequency in string str.\\n            IntStream.range(0, 26).forEach(i ->  count[i] = Math.min(cnt[i], count[i])); // update minimum frequency.\\n        }\\n        List<String> ans = new ArrayList<>();\\n        IntStream.range(\\'a\\', \\'z\\' + 1).forEach(c ->  ans.addAll(Collections.nCopies(count[c - \\'a\\'], \"\" + (char)c)));\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 332733,
                "title": "python-solution-easy-to-understand",
                "content": "```\\ndef commonChars(self,A):\\n        check = list(A[0])\\n        for word in A:\\n            newCheck = []\\n            for c in word:\\n                if c in check:\\n                    newCheck.append(c)\\n                    check.remove(c)\\n            check = newCheck\\n        \\n        return check\\n```",
                "solutionTags": [],
                "code": "```\\ndef commonChars(self,A):\\n        check = list(A[0])\\n        for word in A:\\n            newCheck = []\\n            for c in word:\\n                if c in check:\\n                    newCheck.append(c)\\n                    check.remove(c)\\n            check = newCheck\\n        \\n        return check\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 712527,
                "title": "c-simple-and-sweet",
                "content": "Runtime: 8 ms, faster than 99.08% of C++ online submissions for Find Common Characters.\\nMemory Usage: 8.9 MB, less than 96.95% of C++ online submissions for Find Common Characters.\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> commonChars(vector<string>& arr) {\\n\\t\\t   vector<int> hash1(26, 0);\\n\\t\\t\\tvector<int> hash2(26, 0);\\n\\n\\t\\t\\tfor(auto ch : arr[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\thash1[ch - \\'a\\']++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 1; i < arr.size() ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(auto ch : arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thash2[ch-\\'a\\']++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thash1[i] = min(hash1[i], hash2[i]);\\n\\t\\t\\t\\t\\thash2[i] = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\n\\t\\t\\t\\tif(hash1[i] > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint count = hash1[i];\\n\\t\\t\\t\\t\\twhile(count--)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar x = i+ \\'a\\';\\n\\t\\t\\t\\t\\t\\tstring s ;\\n\\t\\t\\t\\t\\t\\ts = x;\\n\\t\\t\\t\\t\\t\\tans.push_back(s);\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> commonChars(vector<string>& arr) {\\n\\t\\t   vector<int> hash1(26, 0);\\n\\t\\t\\tvector<int> hash2(26, 0);\\n\\n\\t\\t\\tfor(auto ch : arr[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\thash1[ch - \\'a\\']++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 249739,
                "title": "java-10ms-38mb-clear-solution-with-comments",
                "content": "```\\npublic List<String> commonChars(String[] A) {\\n        List<String> ans = new ArrayList<>();\\n        // Common characters dictionary\\n        int[] dict = new int[26];\\n        for (int j = 0; j < A[0].length(); j++) {\\n            dict[A[0].charAt(j) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            // Dictionary of the current word\\n            int[] curr = new int[26];\\n            for (int j = 0; j < A[i].length(); j++) {\\n                curr[A[i].charAt(j) - \\'a\\']++;\\n            }\\n            // Update the common dictionary\\n            for (int j = 0; j < 26; j++) {\\n                if (curr[j] < dict[j]) dict[j] = curr[j];\\n            }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < dict[i]; j++) {\\n                ans.add(Character.toString((char) (\\'a\\' + i)));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> commonChars(String[] A) {\\n        List<String> ans = new ArrayList<>();\\n        // Common characters dictionary\\n        int[] dict = new int[26];\\n        for (int j = 0; j < A[0].length(); j++) {\\n            dict[A[0].charAt(j) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            // Dictionary of the current word\\n            int[] curr = new int[26];\\n            for (int j = 0; j < A[i].length(); j++) {\\n                curr[A[i].charAt(j) - \\'a\\']++;\\n            }\\n            // Update the common dictionary\\n            for (int j = 0; j < 26; j++) {\\n                if (curr[j] < dict[j]) dict[j] = curr[j];\\n            }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < dict[i]; j++) {\\n                ans.add(Character.toString((char) (\\'a\\' + i)));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 447986,
                "title": "java-best-solution-100-faster-100-lessor",
                "content": "Just count the characters and reduce intersection of words. Then, convert it back to List.\\n```\\n    public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }\\n        List<String> arr = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (last[i] != 0) {\\n                char a = \\'a\\';\\n                a += i;\\n                String s = String.valueOf(a);\\n                while (last[i] > 0) {\\n                    arr.add(s);\\n                    last[i]--;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[] intersection(int[] a, int[] b) {\\n        int[] t = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            t[i] = Math.min(a[i], b[i]);\\n        }\\n        return t;\\n    }\\n\\n    int[] count(String str) {\\n        int[] t = new int[26];\\n        for (char c : str.toCharArray()) t[c - \\'a\\']++;\\n        return t;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }\\n        List<String> arr = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (last[i] != 0) {\\n                char a = \\'a\\';\\n                a += i;\\n                String s = String.valueOf(a);\\n                while (last[i] > 0) {\\n                    arr.add(s);\\n                    last[i]--;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[] intersection(int[] a, int[] b) {\\n        int[] t = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            t[i] = Math.min(a[i], b[i]);\\n        }\\n        return t;\\n    }\\n\\n    int[] count(String str) {\\n        int[] t = new int[26];\\n        for (char c : str.toCharArray()) t[c - \\'a\\']++;\\n        return t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 259707,
                "title": "java-clean-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (char c = \\'a\\'; c <= \\'z\\'; c++){\\n            int minCount = Integer.MAX_VALUE;\\n            for (String s : A){\\n                int wordCount = 0;\\n                for (char cur_c : s.toCharArray()) if (cur_c == c) wordCount++;\\n                minCount = Math.min(minCount, wordCount);\\n            }\\n            \\n            for (int i = 0; i < minCount; i++) result.add(\"\" + c);\\n        }\\n        \\n        return result;\\n}\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (char c = \\'a\\'; c <= \\'z\\'; c++){\\n            int minCount = Integer.MAX_VALUE;\\n            for (String s : A){\\n                int wordCount = 0;\\n                for (char cur_c : s.toCharArray()) if (cur_c == c) wordCount++;\\n                minCount = Math.min(minCount, wordCount);\\n            }\\n            \\n            for (int i = 0; i < minCount; i++) result.add(\"\" + c);\\n        }\\n        \\n        return result;\\n}\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422308,
                "title": "python-7-lines-beats-100-and-100-in-o-n",
                "content": "```python\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     # make a set from first string\\n        res = []\\n        for one in alist:\\n            n = min([a_word.count(one) for a_word in A])     # count min frequency of every letter in every word\\n            if n:    # if n>0 , we append this letter n times\\n                res += [one]*n\\n        return res\\n```\\n\\n\\n**Runtime: 28 ms**, faster than **100.00%** of Python3 online submissions for Find Common Characters.\\n**Memory Usage: 12.8 MB**, less than **100.00%** of Python3 online submissions for Find Common Characters.\\n\\n**If it helps you , Please give me a star \\nThanks.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     # make a set from first string\\n        res = []\\n        for one in alist:\\n            n = min([a_word.count(one) for a_word in A])     # count min frequency of every letter in every word\\n            if n:    # if n>0 , we append this letter n times\\n                res += [one]*n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515453,
                "title": "javascript-concise-solution",
                "content": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  let res = [...A[0]];\\n  for (let i = 1; i < A.length; i++) {\\n    res = res.filter(c => {\\n      const l = A[i].length;\\n      A[i] = A[i].replace(c, \"\");\\n      return l > A[i].length;\\n    });\\n  }\\n  return res;\\n};\\n```\\n\\n* 83/83 cases passed (56 ms)\\n* Your runtime beats 97.73 % of javascript submissions\\n* Your memory usage beats 85.71 % of javascript submissions (37 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  let res = [...A[0]];\\n  for (let i = 1; i < A.length; i++) {\\n    res = res.filter(c => {\\n      const l = A[i].length;\\n      A[i] = A[i].replace(c, \"\");\\n      return l > A[i].length;\\n    });\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413601,
                "title": "python-showing-progress-from-64-ms-to-12-ms-from-beating-38-to-100",
                "content": "I\\'ll start with my slowest solution.  During a Contest, fast and reliable code is best, so definitely use ```collections.Counter``` then.  But if you want a fast solution, ```Counter``` tends to do extra work, and so runs slower.  Here\\'s my first solution, clocked at 64 ms:\\n\\n```python\\nfrom collections import Counter\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\t\\t\\t\\n        count = Counter(A[0])\\n        for w in A[1:]:\\n            count &= Counter(w)\\n\\t\\t\\t\\n        return list(count.elements())\\n```\\nThe ```Counter``` class implements ```&=``` by pairing up all the same elements, and reducing their counts to the minimum common count.  Very appropriate for this problem!  Since an empty ```Counter``` has a count of 0, I have to start with one of the words, and I picked ```A[0]```.\\n\\nMy second slowest solution was a bit more creatve than re-using an existing class.  I can\\'t directly compare two words because they\\'re in random order.  But if I ```sort()``` both words, I can see which letters are in common.  Even better, after each comparison I get a list of overlaps.  I can use that list to compare against other words, and keep shrinking it until it only holds the letters common to all of the words.  Here\\'s how that looks in code:\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\n        key = list(sorted(A[0]))\\n        key_n = len(key)\\n        for w in A:\\n            w_n, w_i, k_i, new_key = len(w), 0, 0, []\\n            sort_w = list(sorted(w))\\n            while k_i < key_n and w_i < w_n:\\n                if sort_w[w_i] > key[k_i]:\\n                    k_i += 1\\n                elif key[k_i] == sort_w[w_i]:\\n                    new_key.append(key[k_i])\\n                    k_i += 1\\n                    w_i += 1\\n                else:\\n                    w_i += 1\\n            key = new_key\\n            key_n = len(new_key)\\n\\n        return key\\n```\\n\\nThat\\'s slightly faster, at 56 ms.  There\\'s another trick to this problem, but it doesn\\'t speed it up much: sort(A) and go through in that order.  Going through the smaller lists first means fewer overlaps, and then later comparisons are made against a smaller list.  But that\\'s still in the 52 ms to 56 ms range.\\n\\nSo that\\'s two solutions, and the ```sort()``` approach doesn\\'t seem to get much faster.  But what about replacing ```Counter``` with custom code?  That would avoid the overhead of a ```Counter``` object, and tracking that isn\\'t needed for this problem.  I could count the number of letters / characters in each word, and then only keep counts that they had in common.  I\\'ll have some extra work to do at the end: I\\'ll need to output the characters times the count.  Since I\\'ll be performing frequency counts in two different places, I split that code into it\\'s own method, giving me:\\n\\n```python\\ndef Freq(w):\\n    fq = {}\\n    for ch in w:\\n        fq[ch] = 1 + fq.get(ch, 0)\\n    return fq\\n\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\n        common = Freq(A[0])\\n        for w in A[1:]:\\n            fq = Freq(w)\\n            for ch,count in list(common.items()):\\n                try:\\n                    common[ch] = min(count, fq[ch])\\n                except KeyError:\\n                    del common[ch]\\n\\n        res = []\\n        for ch,count in common.items():\\n            res.extend([ch]*count)\\n        return res\\n```\\n\\nWhich runs notably faster at 44 ms.  Note that 44 ms is the faster of two times.  When I rewrote the code to use lists of zeros, the fastest run was still 44 ms.  But it did lead me in a new direction, so I\\'ll show this code - the turning point - here:\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        A_n = len(A)\\n        if A_n < 2:\\n            return A\\n\\n        all_freq = {chr(i):[0]*A_n for i in range(ord(\\'a\\'), ord(\\'z\\')+1)}\\n        for i,w in enumerate(A):\\n            if not w:\\n                return []\\n            for ch in w:\\n                all_freq[ch][i] += 1\\n\\n        res = []\\n        for ch,count_list in all_freq.items():\\n            least = min(count_list)\\n            if least:\\n                res.extend([ch]*least)\\n\\n        return res\\n```\\n\\nThe above all all solutions before I saw anyone else\\'s code.  Sometimes Python prefers approaches that might not intuitively seem faster.  Some Python built-ins are written in \"C\", so the more of your processing that happens in those built-ins, the faster your code runs.  But it\\'s not a guarantee, just something worth trying.\\n\\nMy code above calls ```min()``` in every frequency count.  But I\\'m taking a frequency count of everything, and wasting time calling ```min()``` with a value of 0.  I can avoid that by only going over letters that might be in every word.  I can start with all the letters in one word (the first word), and then only count the frequencies of those letters.  Most of that time will be spent calling ```min()``` and building list comprehensions, which may help improve the speeed.  After seeing another solution, I wrote something similar, which got me going in a new direction.\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if not A:\\n            return []\\n\\n        res = []\\n        key_set = set(A[0])\\n        for ch in key_set:\\n            n = min([w.count(ch) for w in A])\\n            if n:\\n                res.extend([ch]*n)\\n\\n        return res\\n```\\n\\nNote that ```res.extend()``` and ```res +=``` have the same functionality, so if you prefer ```+=```, just picture that instead.\\n\\nThis code runs even faster, at 32 ms.  Now it\\'s beating 90% of entries - but really I\\'m taking someone else\\'s idea.  But what if I could improve on their idea.  Python loves list comprehensions... could I write this entire problem in one line?  One big list comprehension?\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        return A and sum([[ch]*min([w.count(ch) for w in A]) for ch in set(A[0])], [])\\n```\\n\\nYou need a wide monitor to call that \"one line\", but it might fit.  But why do I start with ```A and ...```?  What if the input is empty.  If I call ```A[0]``` when A is empty, I\\'ll trigger an exception.  I know that ```3 and 5``` returns 5, while ```[] and 5``` returns ```[]```.  So that\\'s what I\\'m doing here: ```[] and ``` causes my code to return ```[]``` when the input is ```[]```.\\n\\nAnother trick is with sum().  If \"b\" appears once and \"c\" appears 3 times, I\\'ve generated a list that looks like: ```[ [\"b\"], [\"c\",\"c\",\"c\"] ]```.  The problem doesn\\'t call for nested lists.  I need a way to call ```res.extend()``` or ```res +=```.  It turns out ```sum()``` can be used to ```+=``` numbers starting with 0, or it can be used to ```+=``` lists, starting with the empty list.  So I call ```sum(..., [])``` to flatten all my lists, and give the answer ```[\"b\", \"c\", \"c\", \"c\"]``` instead of ```[ [\"b\"], [\"c\",\"c\",\"c\"] ]```.\\n\\nThe rest is a list comprehesion: I go through all the unique letters in the first word, and build a list showing how many times that letter appears in each word.  Then I call ```min()``` to find the least number of occurances.\\n\\nOne line solutions are fun, but in this case it\\'s also fast: 24 ms.  (The slower run was 32 ms, which seems like a wide range to me).  Could I do faster than either of these last two?\\n\\nI figured if I could avoid checking for an empty input, that might speed up the code.  But I have to deal with empty input somehow.  So I put that code in a try/except block to see if that\\'s any faster.  Using an exception to catch the empty input turns out to be my fastest solution to the problem:\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        res = []\\n        try:\\n            key_set = set(A[0])\\n        except IndexError:\\n            return res\\n        \\n        for ch in key_set:\\n            n = min([w.count(ch) for w in A])\\n            if n:\\n                res.extend([ch]*n)\\n\\n        return res\\n```\\n\\nThis code beats 100% of other solutions on time, and on memory.  It runs in 12 ms.  It\\'s other run was 20 ms, which beats 99.7% of other submissions.  In this case, pushing the empty list check into a try/except sped up the code.\\n\\nSo here\\'s a summary of the approaches I used, and the performance of each one.\\n\\nUsing a Counter\\n```text\\nRuntime: 64 ms, faster than 39.04% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 82.35% of Python online submissions for Find Common Characters.\\n```\\n\\nsort() each word\\n```text\\nRuntime: 56 ms, faster than 47.84% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 88.24% of Python online submissions for Find Common Characters.\\n```\\n\\nsort() the entire list so the smallest are at the front, then sort() each word:\\n```text\\nRuntime: 52 ms, faster than 51.98% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 94.12% of Python online submissions for Find Common Characters.\\n```\\n\\nuse a dict() to count frequencies:\\n```text\\nRuntime: 44 ms, faster than 62.00% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.8 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\\n\\nloop through the first word\\'s unique letters, count each word, and take the minimum:\\n```text\\nRuntime: 32 ms, faster than 90.21% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 88.24% of Python online submissions for Find Common Characters.\\n```\\n\\nOne line solution using ```return A and sum(... , [])```\\n```text\\nRuntime: 24 ms, faster than 98.83% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.8 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\\n\\nAnd my fastest solution, using try/except to handle an empty list:\\n```text\\nRuntime: 12 ms, faster than 100.00% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.7 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\\n\\nI hope you liked my various solutions and explanations.  Feel free to ask me questions about anything that wasn\\'t clear.\\n\\nThere\\'s no official solution to this problem, so what do others think of leetcode using mine?  I\\'m not sure how that works, but up votes will probably help.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```collections.Counter```\n```Counter```\n```python\\nfrom collections import Counter\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\t\\t\\t\\n        count = Counter(A[0])\\n        for w in A[1:]:\\n            count &= Counter(w)\\n\\t\\t\\t\\n        return list(count.elements())\\n```\n```Counter```\n```&=```\n```Counter```\n```A[0]```\n```sort()```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\n        key = list(sorted(A[0]))\\n        key_n = len(key)\\n        for w in A:\\n            w_n, w_i, k_i, new_key = len(w), 0, 0, []\\n            sort_w = list(sorted(w))\\n            while k_i < key_n and w_i < w_n:\\n                if sort_w[w_i] > key[k_i]:\\n                    k_i += 1\\n                elif key[k_i] == sort_w[w_i]:\\n                    new_key.append(key[k_i])\\n                    k_i += 1\\n                    w_i += 1\\n                else:\\n                    w_i += 1\\n            key = new_key\\n            key_n = len(new_key)\\n\\n        return key\\n```\n```sort()```\n```Counter```\n```Counter```\n```python\\ndef Freq(w):\\n    fq = {}\\n    for ch in w:\\n        fq[ch] = 1 + fq.get(ch, 0)\\n    return fq\\n\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\n        common = Freq(A[0])\\n        for w in A[1:]:\\n            fq = Freq(w)\\n            for ch,count in list(common.items()):\\n                try:\\n                    common[ch] = min(count, fq[ch])\\n                except KeyError:\\n                    del common[ch]\\n\\n        res = []\\n        for ch,count in common.items():\\n            res.extend([ch]*count)\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        A_n = len(A)\\n        if A_n < 2:\\n            return A\\n\\n        all_freq = {chr(i):[0]*A_n for i in range(ord(\\'a\\'), ord(\\'z\\')+1)}\\n        for i,w in enumerate(A):\\n            if not w:\\n                return []\\n            for ch in w:\\n                all_freq[ch][i] += 1\\n\\n        res = []\\n        for ch,count_list in all_freq.items():\\n            least = min(count_list)\\n            if least:\\n                res.extend([ch]*least)\\n\\n        return res\\n```\n```min()```\n```min()```\n```min()```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if not A:\\n            return []\\n\\n        res = []\\n        key_set = set(A[0])\\n        for ch in key_set:\\n            n = min([w.count(ch) for w in A])\\n            if n:\\n                res.extend([ch]*n)\\n\\n        return res\\n```\n```res.extend()```\n```res +=```\n```+=```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        return A and sum([[ch]*min([w.count(ch) for w in A]) for ch in set(A[0])], [])\\n```\n```A and ...```\n```A[0]```\n```3 and 5```\n```[] and 5```\n```[]```\n```[] and ```\n```[]```\n```[]```\n```[ [\"b\"], [\"c\",\"c\",\"c\"] ]```\n```res.extend()```\n```res +=```\n```sum()```\n```+=```\n```+=```\n```sum(..., [])```\n```[\"b\", \"c\", \"c\", \"c\"]```\n```[ [\"b\"], [\"c\",\"c\",\"c\"] ]```\n```min()```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        res = []\\n        try:\\n            key_set = set(A[0])\\n        except IndexError:\\n            return res\\n        \\n        for ch in key_set:\\n            n = min([w.count(ch) for w in A])\\n            if n:\\n                res.extend([ch]*n)\\n\\n        return res\\n```\n```text\\nRuntime: 64 ms, faster than 39.04% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 82.35% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 56 ms, faster than 47.84% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 88.24% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 52 ms, faster than 51.98% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 94.12% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 44 ms, faster than 62.00% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.8 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 32 ms, faster than 90.21% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 88.24% of Python online submissions for Find Common Characters.\\n```\n```return A and sum(... , [])```\n```text\\nRuntime: 24 ms, faster than 98.83% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.8 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 12 ms, faster than 100.00% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.7 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248428,
                "title": "clear-python-solution",
                "content": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:                        \\n        common_counter = Counter(A[0])                \\n        for str in A[1:]:\\n            common_counter &= Counter(str)                                    \\n        return list(common_counter.elements())\\n\\t\\t\\n```\\n\\nFor Testcase [\"bella\",\"label\",\"roller\"],  **common_counter**  would be \\n\\nCounter({\\'l\\': 2, \\'b\\': 1, \\'e\\': 1, \\'a\\': 1}) \\n->\\nCounter({\\'l\\': 2, \\'b\\': 1, \\'e\\': 1, \\'a\\': 1}) \\n->\\nCounter({\\'l\\': 2, \\'e\\': 1})\\n\\n:D",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:                        \\n        common_counter = Counter(A[0])                \\n        for str in A[1:]:\\n            common_counter &= Counter(str)                                    \\n        return list(common_counter.elements())\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247637,
                "title": "java-two-hashmap-solution-easy-to-understand",
                "content": "The idea here is to use two HashMaps. The first, which we call `union`, will contain all of the common chars found in the strings compared before our current string. Then, before we go through the chars in the current string, we declare a new HashMap, called `temp`. `temp` will contain the chars that are found in our current string which are also found in `union`. \\n\\nWe have to make sure that we don\\'t add a common char too many times. For example, if we have 2 instances of the letter `c` in common strings before the current, but we have three instances of `c` in the current string, we have to make sure that we only count 2 instances of `c` in common. \\n\\nWe do this via the following line: `Math.min(union.get(curr), temp.getOrDefault(curr, 0)+1)`. Then, when we finish looping through the current string, we just set `union` to ` temp`. \\n\\n\\t\\tList<String> ans = new ArrayList<String>(); \\n        if(A == null || A.length == 0) return ans; \\n        \\n        HashMap<Character, Integer> union = new HashMap<>(); \\n        for(int i = 0; i < A[0].length(); i++) union.put(A[0].charAt(i), union.getOrDefault(A[0].charAt(i), 0)+1); \\n        \\n        for(int i = 1; i < A.length; i++){\\n            HashMap<Character, Integer> temp = new HashMap<>(); \\n            for(int j = 0; j < A[i].length(); j++){\\n                char curr = A[i].charAt(j); \\n                if(union.containsKey(curr)) temp.put(curr, Math.min(union.get(curr), temp.getOrDefault(curr, 0)+1)); \\n            }\\n            union = temp; \\n        }\\n        \\n        for(char c : union.keySet()){\\n            for(int i = 0; i < union.get(c); i++) ans.add(c + \"\"); \\n        }\\n        \\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea here is to use two HashMaps. The first, which we call `union`, will contain all of the common chars found in the strings compared before our current string. Then, before we go through the chars in the current string, we declare a new HashMap, called `temp`. `temp` will contain the chars that are found in our current string which are also found in `union`. \\n\\nWe have to make sure that we don\\'t add a common char too many times. For example, if we have 2 instances of the letter `c` in common strings before the current, but we have three instances of `c` in the current string, we have to make sure that we only count 2 instances of `c` in common. \\n\\nWe do this via the following line: `Math.min(union.get(curr), temp.getOrDefault(curr, 0)+1)`. Then, when we finish looping through the current string, we just set `union` to ` temp`. \\n\\n\\t\\tList<String> ans = new ArrayList<String>(); \\n        if(A == null || A.length == 0) return ans; \\n        \\n        HashMap<Character, Integer> union = new HashMap<>(); \\n        for(int i = 0; i < A[0].length(); i++) union.put(A[0].charAt(i), union.getOrDefault(A[0].charAt(i), 0)+1); \\n        \\n        for(int i = 1; i < A.length; i++){\\n            HashMap<Character, Integer> temp = new HashMap<>(); \\n            for(int j = 0; j < A[i].length(); j++){\\n                char curr = A[i].charAt(j); \\n                if(union.containsKey(curr)) temp.put(curr, Math.min(union.get(curr), temp.getOrDefault(curr, 0)+1)); \\n            }\\n            union = temp; \\n        }\\n        \\n        for(char c : union.keySet()){\\n            for(int i = 0; i < union.get(c); i++) ans.add(c + \"\"); \\n        }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 923859,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n^2) space O(n)\\nvar commonChars = function(A) {\\n    const result = []\\n    const firstWordArr = [...A[0]]\\n    \\n    for(const letter of firstWordArr) {\\n        if(A.every(word => word.includes(letter))) {\\n            result.push(letter)\\n            A = A.map(word => word.replace(letter, \\'\\'))\\n        }\\n    }    \\n    \\n    return result\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n^2) space O(n)\\nvar commonChars = function(A) {\\n    const result = []\\n    const firstWordArr = [...A[0]]\\n    \\n    for(const letter of firstWordArr) {\\n        if(A.every(word => word.includes(letter))) {\\n            result.push(letter)\\n            A = A.map(word => word.replace(letter, \\'\\'))\\n        }\\n    }    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 722794,
                "title": "c-very-easy-to-understand-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        vector<int> mainCnt(26, 0);\\n        vector<int> tempCnt(26,0);\\n        for(int i=0;i<A[0].length();i++)\\n            mainCnt[A[0][i]-\\'a\\']++;\\n        for(int i=1;i<A.size();i++){\\n            for(int j=0;j<A[i].length();j++){\\n                tempCnt[A[i][j]-\\'a\\']++;\\n            }\\n            for(int j=0;j<26;j++){\\n                mainCnt[j] = min(tempCnt[j],mainCnt[j]);\\n                tempCnt[j] = 0;\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<26;i++){\\n            if(mainCnt[i]>0){\\n                while(mainCnt[i]--){\\n\\t\\t\\t\\t// the below 2 lines convert \\'char\\' type into \\'string\\' type\\n                    string temp = \"\";\\n                    temp += i+\\'a\\';\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nFeel free to ask any questions in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        vector<int> mainCnt(26, 0);\\n        vector<int> tempCnt(26,0);\\n        for(int i=0;i<A[0].length();i++)\\n            mainCnt[A[0][i]-\\'a\\']++;\\n        for(int i=1;i<A.size();i++){\\n            for(int j=0;j<A[i].length();j++){\\n                tempCnt[A[i][j]-\\'a\\']++;\\n            }\\n            for(int j=0;j<26;j++){\\n                mainCnt[j] = min(tempCnt[j],mainCnt[j]);\\n                tempCnt[j] = 0;\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<26;i++){\\n            if(mainCnt[i]>0){\\n                while(mainCnt[i]--){\\n\\t\\t\\t\\t// the below 2 lines convert \\'char\\' type into \\'string\\' type\\n                    string temp = \"\";\\n                    temp += i+\\'a\\';\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473485,
                "title": "python-99-60-short-and-understandable-solution",
                "content": "Idea is simple:\\n\\n1) We loop over the unique characters in the first word because for a letter to be considered it must be in all words including first word.\\n\\n2) Comparing each character in first word with all other words.\\n3) Check if the character in comparison in the first world exists in the word in comparison\\n4) If it does then count its count and compare with existing count and take the min. Also increment the occurences to see if this character exists in all words.\\n5) If it doesn\\'t then break from the loop as now one of characters isn\\'t in first words and we are no longer interested in it.\\n6) After inside loop exits, check if occurences amount equals that of the amount of words we have to make sure the character in question exists in all the words.\\n7) Lastly add this character which exists in all words with its minimum occurence.\\n\\n```\\n\\t\\tresult = []\\n        for c in set(A[0]):\\n            count = A[0].count(c)\\n            occurences = 1\\n            for i in range(1,len(A)):\\n                if c in A[i]:\\n                    count = min(count,A[i].count(c))\\n                    occurences += 1\\n                else:\\n                    break\\n            if occurences == len(A):\\n                for i in range(count):\\n                    result.append(c)\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tresult = []\\n        for c in set(A[0]):\\n            count = A[0].count(c)\\n            occurences = 1\\n            for i in range(1,len(A)):\\n                if c in A[i]:\\n                    count = min(count,A[i].count(c))\\n                    occurences += 1\\n                else:\\n                    break\\n            if occurences == len(A):\\n                for i in range(count):\\n                    result.append(c)\\n                    \\n        return result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274501,
                "title": "java-solution-faster-than-100-simple-logic",
                "content": "*Runtime: 1 ms, faster than 100.00% of Java online submissions for Find Common Characters.\\nMemory Usage: 37.7 MB, less than 100.00% of Java online submissions for Find Common Characters.*\\n\\nVery native solution. We use the first String char_count as a reference.\\nfor example, \"bella\" will count into arr[26] with all letter\\'s count. [b]=1, [e]=1,[l]=2,[a]=1 will be the reference.\\nThen we loop the rest String: for each string ,we did the same new arr[26] count, then scan reference with the new arr count. If count not match, then we need to update the reference count with smaller count. like \"label\" has same char_count, then \"roller\" will update reference as [e]=1, [l]=2;\\nAfter loop the whole string array, we only need to scan the reference count [e]=1, [l]=2 and add the letter into a list respectively with the count number.\\n\\n```\\nclass Solution {\\n    int[] arr = new int[26];\\n    public List<String> commonChars(String[] A) {\\n        List<String> list = new ArrayList<String>();\\n        if (A == null || A.length == 0) return list;\\n        int[] arr_ori = new int[26];\\n        for (char c : A[0].toCharArray()) {\\n            arr_ori[c - \\'a\\']++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            countValid(A[i], arr_ori);\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr_ori[i] != 0) {\\n                for (int j = 0; j < arr_ori[i]; j++) {\\n                    list.add((char)(i+\\'a\\') + \"\");\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    private void countValid(String str, int[] arr_ori) {\\n        for (char c : str.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr_ori[i] != 0 && arr[i] != arr_ori[i]) {\\n                arr_ori[i] = Math.min(arr_ori[i], arr[i]);\\n            }\\n        }\\n        arr = new int[26];\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] arr = new int[26];\\n    public List<String> commonChars(String[] A) {\\n        List<String> list = new ArrayList<String>();\\n        if (A == null || A.length == 0) return list;\\n        int[] arr_ori = new int[26];\\n        for (char c : A[0].toCharArray()) {\\n            arr_ori[c - \\'a\\']++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            countValid(A[i], arr_ori);\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr_ori[i] != 0) {\\n                for (int j = 0; j < arr_ori[i]; j++) {\\n                    list.add((char)(i+\\'a\\') + \"\");\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    private void countValid(String str, int[] arr_ori) {\\n        for (char c : str.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr_ori[i] != 0 && arr[i] != arr_ori[i]) {\\n                arr_ori[i] = Math.min(arr_ori[i], arr[i]);\\n            }\\n        }\\n        arr = new int[26];\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250620,
                "title": "short-javascript-solution",
                "content": "```\\nvar commonChars = function(A) {\\n    let originalChars = A[0].split(\\'\\');\\n    for (let i = 1; i < A.length; i++) {\\n        let tempChars = A[i].split(\\'\\');\\n        originalChars = originalChars.filter(char => {\\n            let ind = tempChars.indexOf(char);\\n            return ind > -1 ? tempChars[ind] = true : false;\\n        });\\n    }\\n    return originalChars;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar commonChars = function(A) {\\n    let originalChars = A[0].split(\\'\\');\\n    for (let i = 1; i < A.length; i++) {\\n        let tempChars = A[i].split(\\'\\');\\n        originalChars = originalChars.filter(char => {\\n            let ind = tempChars.indexOf(char);\\n            return ind > -1 ? tempChars[ind] = true : false;\\n        });\\n    }\\n    return originalChars;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175578,
                "title": "c-easy-simple",
                "content": "***Do upvote if you found the solution helpful to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n***Explanation in the comments section***\\n```\\nclass Solution {\\npublic:\\n     vector<string> commonChars(vector<string>& A)\\n     {\\n         vector<int> count(26,INT_MAX);\\n         vector<string> res;\\n         \\n         for(auto i: A)\\n         {\\n             vector<int> temp(26,0);\\n             for(auto j: i)\\n             {\\n                 temp[j-\\'a\\']++;\\n             }\\n             \\n             for(int k=0 ; k<26 ;k++)\\n             {\\n                 count[k] = min(count[k],temp[k]);\\n             }\\n         }\\n         \\n         for(int l=0 ; l<26 ;l++)\\n         {\\n             while(count[l]--)\\n             {\\n                 res.push_back(string(1 , l+\\'a\\'));\\n             }\\n         }\\n         return res;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<string> commonChars(vector<string>& A)\\n     {\\n         vector<int> count(26,INT_MAX);\\n         vector<string> res;\\n         \\n         for(auto i: A)\\n         {\\n             vector<int> temp(26,0);\\n             for(auto j: i)\\n             {\\n                 temp[j-\\'a\\']++;\\n             }\\n             \\n             for(int k=0 ; k<26 ;k++)\\n             {\\n                 count[k] = min(count[k],temp[k]);\\n             }\\n         }\\n         \\n         for(int l=0 ; l<26 ;l++)\\n         {\\n             while(count[l]--)\\n             {\\n                 res.push_back(string(1 , l+\\'a\\'));\\n             }\\n         }\\n         return res;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211860,
                "title": "java-intuitive-approach-using-list-of-hashmap-explained-with-comments",
                "content": "# Commented Code(for clean code scroll down)\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        //create list of hashmap so that we can store the frequency of characters for each string\\n        for(String s: words){\\n            HashMap<Character,Integer> map = new HashMap<>();\\n            for(char ch: s.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n            }\\n            list.add(map);\\n        }\\n        // Ex: TC1 would look something like this [{a=1, b=1, e=1, l=2}, {a=1, b=1, e=1, l=2}, {r=2, e=1, l=2, o=1}]\\n\\n        List<String> ans = new ArrayList<>();\\n        for(char ch : list.get(0).keySet()) {\\n//take the key of the first map in string(doesnt really matter 1st or 2nd just to avoid out of bound error take 0th index map\\'s keySet)\\n            int min = Integer.MAX_VALUE;//find out the minimum occurrence of a character which is common in every string\\n            for (HashMap<Character, Integer> map : list) {//just iterate over all the maps and get the min occurrence\\n                if (!map.containsKey(ch)) {\\n//if map doesnt contain a key then we are sure that this particiular character is not common\\n                    min = 0;\\n                    break;\\n                }\\n                min = Math.min(min, map.get(ch));\\n            }\\n            for (int i = 0; i < min; i++) {\\n//put the common chararcter in the ans list (loop will take care of duplicates as in TC1 chaar \\'l\\' is present twice in every string so min value for \\'l\\' would be 2 and hence we added it twice)\\n                ans.add(String.valueOf(ch));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Clean code without comments\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        for(String s: words){\\n            HashMap<Character,Integer> map = new HashMap<>();\\n            for(char ch: s.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n            }\\n            list.add(map);\\n        }\\n        List<String> ans = new ArrayList<>();\\n        for(char ch : list.get(0).keySet()) {\\n            int min = Integer.MAX_VALUE;\\n            for (HashMap<Character, Integer> map : list) {\\n                if (!map.containsKey(ch)) {\\n                    min = 0;\\n                    break;\\n                }\\n                min = Math.min(min, map.get(ch));\\n            }\\n            for (int i = 0; i < min; i++) {\\n                ans.add(String.valueOf(ch));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        //create list of hashmap so that we can store the frequency of characters for each string\\n        for(String s: words){\\n            HashMap<Character,Integer> map = new HashMap<>();\\n            for(char ch: s.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n            }\\n            list.add(map);\\n        }\\n        // Ex: TC1 would look something like this [{a=1, b=1, e=1, l=2}, {a=1, b=1, e=1, l=2}, {r=2, e=1, l=2, o=1}]\\n\\n        List<String> ans = new ArrayList<>();\\n        for(char ch : list.get(0).keySet()) {\\n//take the key of the first map in string(doesnt really matter 1st or 2nd just to avoid out of bound error take 0th index map\\'s keySet)\\n            int min = Integer.MAX_VALUE;//find out the minimum occurrence of a character which is common in every string\\n            for (HashMap<Character, Integer> map : list) {//just iterate over all the maps and get the min occurrence\\n                if (!map.containsKey(ch)) {\\n//if map doesnt contain a key then we are sure that this particiular character is not common\\n                    min = 0;\\n                    break;\\n                }\\n                min = Math.min(min, map.get(ch));\\n            }\\n            for (int i = 0; i < min; i++) {\\n//put the common chararcter in the ans list (loop will take care of duplicates as in TC1 chaar \\'l\\' is present twice in every string so min value for \\'l\\' would be 2 and hence we added it twice)\\n                ans.add(String.valueOf(ch));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        for(String s: words){\\n            HashMap<Character,Integer> map = new HashMap<>();\\n            for(char ch: s.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n            }\\n            list.add(map);\\n        }\\n        List<String> ans = new ArrayList<>();\\n        for(char ch : list.get(0).keySet()) {\\n            int min = Integer.MAX_VALUE;\\n            for (HashMap<Character, Integer> map : list) {\\n                if (!map.containsKey(ch)) {\\n                    min = 0;\\n                    break;\\n                }\\n                min = Math.min(min, map.get(ch));\\n            }\\n            for (int i = 0; i < min; i++) {\\n                ans.add(String.valueOf(ch));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247798,
                "title": "detailed-explanation-c-o-n",
                "content": "**Approach**\\n* \\tCreate a vector `freq` that maps each character of the alphabet to its frequency in any given string.\\n* \\tCreate a vector `minMatching` that stores the count of characters which occur in all the strings so far\\n* \\tTraverse the list of strings and for each string, update (overwrite) the `freq` vector and accordingly update the `minMatching` vector.\\n* \\tAt the end, traverse the `minMatching` vector and append each character as a single string in the answer vector.\\n\\n**MIscellaneous**\\n* The `minMatching` vector has been initialised with `INT_MAX` instead of `0` to handle the updation of first string. After that, all the non-appearing charcters would be set to zero.\\n```\\nclass Solution\\n{\\n    int alphabetSize = 26;\\n    vector<int> freq;\\n    vector<int> minMatching;\\n    vector<string> answer;\\npublic:   \\n    Solution()\\n    {\\n        freq.resize(alphabetSize);\\n        minMatching.resize(alphabetSize, INT_MAX);\\n    }\\n    void mapCharacters(string str);\\n    vector<string> commonChars(vector<string>& a);\\n};\\n\\n/* Maps the characters to its frequency */\\nvoid Solution :: mapCharacters(string str)\\n{\\n    // Initialise the frequency vector with zero\\n    for(auto &ele:freq)\\n        ele = 0;\\n    \\n    // Increase the frequency of each element as it is encountered\\n    for(auto ele : str)\\n        freq[ele-\\'a\\']++;\\n}\\n\\n/* Returns the common characters in all the strings */\\nvector<string> Solution :: commonChars(vector<string>& a)\\n{\\n    // Iterate throught each string\\n    for(auto str : a)\\n    {\\n        // Map the charcters in the frequency vector\\n        mapCharacters(str);\\n        \\n        // Traverse the frequency map , and update the minimum matching\\n        for(int i=0; i<alphabetSize; i++)\\n            minMatching[i] = min(minMatching[i], freq[i]);\\n    }\\n\\n    // Traverse the minMatching vector and fill the answer\\n    for(int i=0; i<alphabetSize; i++)\\n    {\\n        // Get the minimum number of repetitions of ecah charcter and append it to answer\\n        int count = minMatching[i];\\n        for(int j=0; j<count; j++)\\n            answer.push_back(string(1, \\'a\\'+i));\\n    }\\n    \\n    return answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    int alphabetSize = 26;\\n    vector<int> freq;\\n    vector<int> minMatching;\\n    vector<string> answer;\\npublic:   \\n    Solution()\\n    {\\n        freq.resize(alphabetSize);\\n        minMatching.resize(alphabetSize, INT_MAX);\\n    }\\n    void mapCharacters(string str);\\n    vector<string> commonChars(vector<string>& a);\\n};\\n\\n/* Maps the characters to its frequency */\\nvoid Solution :: mapCharacters(string str)\\n{\\n    // Initialise the frequency vector with zero\\n    for(auto &ele:freq)\\n        ele = 0;\\n    \\n    // Increase the frequency of each element as it is encountered\\n    for(auto ele : str)\\n        freq[ele-\\'a\\']++;\\n}\\n\\n/* Returns the common characters in all the strings */\\nvector<string> Solution :: commonChars(vector<string>& a)\\n{\\n    // Iterate throught each string\\n    for(auto str : a)\\n    {\\n        // Map the charcters in the frequency vector\\n        mapCharacters(str);\\n        \\n        // Traverse the frequency map , and update the minimum matching\\n        for(int i=0; i<alphabetSize; i++)\\n            minMatching[i] = min(minMatching[i], freq[i]);\\n    }\\n\\n    // Traverse the minMatching vector and fill the answer\\n    for(int i=0; i<alphabetSize; i++)\\n    {\\n        // Get the minimum number of repetitions of ecah charcter and append it to answer\\n        int count = minMatching[i];\\n        for(int j=0; j<count; j++)\\n            answer.push_back(string(1, \\'a\\'+i));\\n    }\\n    \\n    return answer;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346579,
                "title": "python-solution-beat-95",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res = []\\n        for ch in set(A[0]):\\n            count = []\\n            for word in A:\\n                count.append(word.count(ch))\\n            res += ch * min(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res = []\\n        for ch in set(A[0]):\\n            count = []\\n            for word in A:\\n                count.append(word.count(ch))\\n            res += ch * min(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250336,
                "title": "python-100-no-built-ins-straight-forward-with-comments",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        answer = None\\n        \\n        for a in A:\\n            # create the counts for the current word\\n            work = {}\\n            for c in a:\\n                if c in work:\\n                    work[c] += 1\\n                else:\\n                    work[c] = 1\\n            \\n            # compare the current word counts\\n            # keep the least of the common ones\\n            # delete the ones in the answer not found in the current word\\n            if answer != None:\\n                keys = list(answer.keys())\\n                for k in keys:\\n                    if k in work:\\n                        answer[k] = min(answer[k], work[k])\\n                    else:\\n                        del answer[k]\\n            else:\\n                answer = work\\n\\n        # turn the counts into an array\\n        answerArr = []\\n        for key in answer:\\n            count = answer[key]\\n            for _ in xrange(count):\\n                answerArr.append(key)\\n        \\n        return answerArr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        answer = None\\n        \\n        for a in A:\\n            # create the counts for the current word\\n            work = {}\\n            for c in a:\\n                if c in work:\\n                    work[c] += 1\\n                else:\\n                    work[c] = 1\\n            \\n            # compare the current word counts\\n            # keep the least of the common ones\\n            # delete the ones in the answer not found in the current word\\n            if answer != None:\\n                keys = list(answer.keys())\\n                for k in keys:\\n                    if k in work:\\n                        answer[k] = min(answer[k], work[k])\\n                    else:\\n                        del answer[k]\\n            else:\\n                answer = work\\n\\n        # turn the counts into an array\\n        answerArr = []\\n        for key in answer:\\n            count = answer[key]\\n            for _ in xrange(count):\\n                answerArr.append(key)\\n        \\n        return answerArr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248223,
                "title": "hashmap-java-100",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        Map<Character,Integer> map=new HashMap<>();\\n        for(char c:A[0].toCharArray()){\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        \\n        for(int i=1;i<A.length;i++){\\n            Map<Character,Integer> tmp=new HashMap<>();\\n            for(int j=0;j<A[i].length();j++){\\n                char c=A[i].charAt(j);\\n                if(map.containsKey(c) && map.get(c)>0){\\n                    tmp.put(c,tmp.getOrDefault(c,0)+1);\\n                    map.put(c,map.get(c)-1);\\n                }\\n            }\\n            map=tmp;\\n            if(map.size()==0)break;\\n        }\\n        List<String> res=new ArrayList<>();\\n        for(Character c:map.keySet()){\\n            for(int k=0;k<map.get(c);k++){\\n                res.add(\"\"+c);\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        Map<Character,Integer> map=new HashMap<>();\\n        for(char c:A[0].toCharArray()){\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        \\n        for(int i=1;i<A.length;i++){\\n            Map<Character,Integer> tmp=new HashMap<>();\\n            for(int j=0;j<A[i].length();j++){\\n                char c=A[i].charAt(j);\\n                if(map.containsKey(c) && map.get(c)>0){\\n                    tmp.put(c,tmp.getOrDefault(c,0)+1);\\n                    map.put(c,map.get(c)-1);\\n                }\\n            }\\n            map=tmp;\\n            if(map.size()==0)break;\\n        }\\n        List<String> res=new ArrayList<>();\\n        for(Character c:map.keySet()){\\n            for(int k=0;k<map.get(c);k++){\\n                res.add(\"\"+c);\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271676,
                "title": "easy-js-sol-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n- This below **approach** works because if a **character** appears in every word in the input array, then its frequency in **charFreqs** will be equal to the **minimum frequency** of that character across all words. \\n\\n- By taking the intersection of the frequency maps for each word, we effectively *find the common characters across all words.*\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe below code uses a *frequency counting approach to find the common characters across all words in the input array.*\\n\\n1. It first initializes a Map object called **charFreqs** with the frequency of each character in the first word of the input array. \\n\\n2. It then iterates through the rest of the words in the array and for each word, it creates a new Map object called **wordFreqs** to *store the frequency of each character in the current word.*\\n\\n3. For each character in **charFreqs**, the code checks if it also appears in **wordFreqs**. \\n\\n4. If it does, the code updates the frequency of that character in **charFreqs** to the minimum of its current frequency and its frequency in **wordFreqs**. \\n\\n5. If it does not, the code deletes the character from **charFreqs**.\\n\\n6. Finally, the code converts the resulting **charFreqs** Map object to an **array of common characters**, where each character appears as many times as its frequency in **charFreqs**.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here **n** is the number of words in the input array and **m** is the length of the longest word. \\n\\n2. This is because the algorithm iterates through each word in the array once and performs a constant amount of work for each character in each word.\\n\\n\\n\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n1. Here k is the number of distinct characters across all the words.\\n\\n2. This is because the algorithm creates a Map object to store the frequency of each character, which has a space complexity proportional to the number of distinct keys (characters) it contains.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n\\nvar commonChars = function(words) {\\n    \\n    let charFreqs = new Map();\\n    // initialize charFreqs with the first word\\n    \\n    for (let char of words[0]) {\\n        \\n        charFreqs.set(char, (charFreqs.get(char) || 0) + 1);\\n    }\\n    \\n    // iterate through the rest of the words\\n    for (let i = 1; i < words.length; i++) {\\n        \\n        let wordFreqs = new Map();\\n        \\n        for (let char of words[i]) {\\n            \\n            wordFreqs.set(char, (wordFreqs.get(char) || 0) + 1);\\n        }\\n        \\n        // update charFreqs with the intersection of wordFreqs\\n        for (let [char, freq] of charFreqs) {\\n            \\n            if (wordFreqs.has(char)) {\\n                charFreqs.set(char, Math.min(freq, wordFreqs.get(char)));\\n            }\\n            \\n            else {\\n                \\n                charFreqs.delete(char);\\n            }\\n        }\\n    }\\n    \\n    // convert charFreqs to an array of characters\\n    let result = [];\\n    \\n    for (let [char, freq] of charFreqs) {\\n        \\n        for (let i = 0; i < freq; i++) {\\n            \\n            result.push(char);\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/9a4a1a61-4716-41af-a842-8a8b7f2e1d31_1678263114.7496967.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n\\nvar commonChars = function(words) {\\n    \\n    let charFreqs = new Map();\\n    // initialize charFreqs with the first word\\n    \\n    for (let char of words[0]) {\\n        \\n        charFreqs.set(char, (charFreqs.get(char) || 0) + 1);\\n    }\\n    \\n    // iterate through the rest of the words\\n    for (let i = 1; i < words.length; i++) {\\n        \\n        let wordFreqs = new Map();\\n        \\n        for (let char of words[i]) {\\n            \\n            wordFreqs.set(char, (wordFreqs.get(char) || 0) + 1);\\n        }\\n        \\n        // update charFreqs with the intersection of wordFreqs\\n        for (let [char, freq] of charFreqs) {\\n            \\n            if (wordFreqs.has(char)) {\\n                charFreqs.set(char, Math.min(freq, wordFreqs.get(char)));\\n            }\\n            \\n            else {\\n                \\n                charFreqs.delete(char);\\n            }\\n        }\\n    }\\n    \\n    // convert charFreqs to an array of characters\\n    let result = [];\\n    \\n    for (let [char, freq] of charFreqs) {\\n        \\n        for (let i = 0; i < freq; i++) {\\n            \\n            result.push(char);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595220,
                "title": "python-unique-way-using-dictionary-faster-than-100-00-less-than-77-78",
                "content": "\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        \\n        res = [] \\n        d = defaultdict(lambda: 0) \\n        # create default dictionary with key as character, and value as the occurence\\n        # since the constraint is that there is always more than 1 item in the list, we can do this\\n        for x in words[0]:\\n            d[x] += 1\\n        \\n        \\n        for key in d: # check each key in the dictinary to see if the character exist in the item in the list\\n            for word in words[1:]: # since we already looked up the first element, start from the second\\n                if not key in word: # if key does not exsit in the item, set the occurence as 0\\n                    d[key] = 0\\n                else:\\n                    # check the value of the key in the dictinonary is more than 1\\n                    # in that case, we need to check how many of the same key(character) exists in the item\\n                    # and keep the minimun value of the occurence\\n                    if d[key] > 1:\\n                        d[key] = min(d[key], word.count(key)) \\n                        \\n        \\n\\t\\t# now the dictionary holds the common characters as key and its occurences as value\\n        for key, value in d.items():\\n            if value > 0:\\n                for i in range(value):\\n                    res.append(key)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        \\n        res = [] \\n        d = defaultdict(lambda: 0) \\n        # create default dictionary with key as character, and value as the occurence\\n        # since the constraint is that there is always more than 1 item in the list, we can do this\\n        for x in words[0]:\\n            d[x] += 1\\n        \\n        \\n        for key in d: # check each key in the dictinary to see if the character exist in the item in the list\\n            for word in words[1:]: # since we already looked up the first element, start from the second\\n                if not key in word: # if key does not exsit in the item, set the occurence as 0\\n                    d[key] = 0\\n                else:\\n                    # check the value of the key in the dictinonary is more than 1\\n                    # in that case, we need to check how many of the same key(character) exists in the item\\n                    # and keep the minimun value of the occurence\\n                    if d[key] > 1:\\n                        d[key] = min(d[key], word.count(key)) \\n                        \\n        \\n\\t\\t# now the dictionary holds the common characters as key and its occurences as value\\n        for key, value in d.items():\\n            if value > 0:\\n                for i in range(value):\\n                    res.append(key)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283550,
                "title": "c-faster-than-99-26-unique-map-approach-with-detailed-explanation",
                "content": "**Please leave an upvote if you feel the efforts were good enough, Thank You**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        int sz = words.size();\\n        vector<string> ans;\\n        unordered_map<char, array<int,100>> mp;        //This map stores the count of each letter in every word(assuming there are max 100 words)\\n         \\n        for(int i=0;i<sz;i++)       //get each word\\n        {\\n            for(int j=0;j<words[i].size();j++)      //get each letter in word\\n                mp[words[i][j]][i]++;               //increment the count at appropriate index in map\\n        }\\n        int cnt=0;      //count variable to keep minimum occurence count of a letter in each word\\n        for(auto x:mp)\\n        {\\n            cnt = INT_MAX;\\n            for(int i=0;i<sz;i++)\\n            {\\n                if(x.second[i]< cnt)\\n                    cnt = x.second[i];      //get the minimum common occurence\\n            }\\n            string s(1, x.first);\\n            for(int i=0;i<cnt;i++)\\n                ans.push_back(s);           //push to the answer vector \\'count\\' times\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        int sz = words.size();\\n        vector<string> ans;\\n        unordered_map<char, array<int,100>> mp;        //This map stores the count of each letter in every word(assuming there are max 100 words)\\n         \\n        for(int i=0;i<sz;i++)       //get each word\\n        {\\n            for(int j=0;j<words[i].size();j++)      //get each letter in word\\n                mp[words[i][j]][i]++;               //increment the count at appropriate index in map\\n        }\\n        int cnt=0;      //count variable to keep minimum occurence count of a letter in each word\\n        for(auto x:mp)\\n        {\\n            cnt = INT_MAX;\\n            for(int i=0;i<sz;i++)\\n            {\\n                if(x.second[i]< cnt)\\n                    cnt = x.second[i];      //get the minimum common occurence\\n            }\\n            string s(1, x.first);\\n            for(int i=0;i<cnt;i++)\\n                ans.push_back(s);           //push to the answer vector \\'count\\' times\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075750,
                "title": "faster-than-99-71-python-with-hash-table-easy-to-understand",
                "content": "Step 1: count all letter in first word, save result in hash table \"count\"\\nStep 2: for each letter in first word, check if it exists in all the rest words, if exist: \\nStep 3: find the min counts for that letter, and overwrite the count value in hash table. if doesn\\'t exist:\\nStep 4: overwrite the count of that letter to 0, and break the inner loop\\nStep 5: define an empty list `l`, for all the letter in hash table, use the `l+= [letter] *count`  to generate final answer\\n\\n\\n\\n```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        count = {}\\n        for x in A[0]:\\n            count[x] = count.get(x, 0) + 1\\n            \\n        \\n        for x in count:\\n            for i in range(1,len(A)):\\n                if x in A[i]:\\n                    count[x] = min(count[x], A[i].count(x))\\n                    \\n                else:\\n                    count[x] = 0\\n                    break\\n        \\n        ans = []\\n        for k,v in count.items():\\n            ans += v * [k]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        count = {}\\n        for x in A[0]:\\n            count[x] = count.get(x, 0) + 1\\n            \\n        \\n        for x in count:\\n            for i in range(1,len(A)):\\n                if x in A[i]:\\n                    count[x] = min(count[x], A[i].count(x))\\n                    \\n                else:\\n                    count[x] = 0\\n                    break\\n        \\n        ans = []\\n        for k,v in count.items():\\n            ans += v * [k]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506674,
                "title": "javascript-solution-straightforward",
                "content": "```\\nvar commonChars = function(A) {\\n    return A.reduce(findCommon, A[0].split(\\'\\'))\\n};\\n\\nconst findCommon = (prev, curr) => {\\n    curr = curr.split(\\'\\');\\n    return prev.filter(p => {\\n        const i = curr.indexOf(p);\\n        if(i !== -1) {\\n            curr.splice(i, 1);\\n            return true;\\n        }\\n        return false;\\n    });\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar commonChars = function(A) {\\n    return A.reduce(findCommon, A[0].split(\\'\\'))\\n};\\n\\nconst findCommon = (prev, curr) => {\\n    curr = curr.split(\\'\\');\\n    return prev.filter(p => {\\n        const i = curr.indexOf(p);\\n        if(i !== -1) {\\n            curr.splice(i, 1);\\n            return true;\\n        }\\n        return false;\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233490,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        //Go through each char in the first string\\n        for (int i=0; i<words[0].length(); i++) {\\n            int flag = 0; \\n            char c = words[0].charAt(i);\\n            //Go through each string in words starting from the second string\\n            for (int j=1; j<words.length; j++){\\n                int index = words[j].indexOf(c);\\n                //if char is not in the string then break and set flag to 1\\n                if (index==-1) {\\n                    flag = 1;\\n                    break;\\n                }\\n                else {\\n                    words[j]= words[j].substring(0, index) + words[j].substring(index+1); //delete the char the is already compared\\n                }\\n            }\\n            //if flag is 0 that means char is in all the string thus add to result\\n            if (flag==0) {\\n                result.add(Character.toString(c));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n//Time: O(N*M) where N is char in the first string and M is number of string\\n//Space: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        //Go through each char in the first string\\n        for (int i=0; i<words[0].length(); i++) {\\n            int flag = 0; \\n            char c = words[0].charAt(i);\\n            //Go through each string in words starting from the second string\\n            for (int j=1; j<words.length; j++){\\n                int index = words[j].indexOf(c);\\n                //if char is not in the string then break and set flag to 1\\n                if (index==-1) {\\n                    flag = 1;\\n                    break;\\n                }\\n                else {\\n                    words[j]= words[j].substring(0, index) + words[j].substring(index+1); //delete the char the is already compared\\n                }\\n            }\\n            //if flag is 0 that means char is in all the string thus add to result\\n            if (flag==0) {\\n                result.add(Character.toString(c));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n//Time: O(N*M) where N is char in the first string and M is number of string\\n//Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161807,
                "title": "python-simple-and-easy-to-understand",
                "content": "```\\n\\nlength = len(A)\\noutput = []\\nfor i in A[0]:\\n\\tcheck = True\\n\\tfor j in range(1, length):\\n\\t\\tif i in A[j] and check:\\n\\t\\t\\tA[j] = A[j].replace(i, \"\", 1)\\n\\t\\t\\tcheck = i\\n\\t\\telse:\\n\\t\\t\\tcheck = None\\n\\tif check == i:\\n\\t\\toutput.append(i)\\n\\nreturn output\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nlength = len(A)\\noutput = []\\nfor i in A[0]:\\n\\tcheck = True\\n\\tfor j in range(1, length):\\n\\t\\tif i in A[j] and check:\\n\\t\\t\\tA[j] = A[j].replace(i, \"\", 1)\\n\\t\\t\\tcheck = i\\n\\t\\telse:\\n\\t\\t\\tcheck = None\\n\\tif check == i:\\n\\t\\toutput.append(i)\\n\\nreturn output\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 721548,
                "title": "python-faster-than-77-67-and-better-space-than-86-74",
                "content": "It takes 302 steps just to complete with the sample input [\"bella\",\"label\",\"roller\"] so I  thought my solution would end up being miserably slow compared to other submissions but it actually seems to hold up fairly decent.\\n```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        alphabet = string.ascii_lowercase\\n        d = {c: 0 for c in alphabet}\\n        \\n        for k, v in d.items():\\n            d[k] = min([word.count(k) for word in A])\\n\\n        res = []\\n        for c, n in d.items():\\n            if n > 0:\\n                res += [c] * n\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/17f1a637-682d-4135-8db4-fc009842b8a3_1593978255.9363427.png)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        alphabet = string.ascii_lowercase\\n        d = {c: 0 for c in alphabet}\\n        \\n        for k, v in d.items():\\n            d[k] = min([word.count(k) for word in A])\\n\\n        res = []\\n        for c, n in d.items():\\n            if n > 0:\\n                res += [c] * n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545858,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        map<char,int> ans;\\n        for(auto ch: A[0]){\\n            ans[ch]++;\\n        }\\n        map<char,int>cur;\\n        for(auto& word:A){\\n            cur.clear();\\n            for(auto ch:word){\\n                cur[ch]++;\\n            }\\n            for(auto& it:ans){\\n                it.second = min(it.second,cur[it.first]);\\n            }\\n        }\\n        vector<string> sol;\\n        string s;\\n        for(auto& it:ans){\\n            while(it.second!=0){\\n                s=it.first;\\n                sol.push_back(s);\\n                it.second--;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        map<char,int> ans;\\n        for(auto ch: A[0]){\\n            ans[ch]++;\\n        }\\n        map<char,int>cur;\\n        for(auto& word:A){\\n            cur.clear();\\n            for(auto ch:word){\\n                cur[ch]++;\\n            }\\n            for(auto& it:ans){\\n                it.second = min(it.second,cur[it.first]);\\n            }\\n        }\\n        vector<string> sol;\\n        string s;\\n        for(auto& it:ans){\\n            while(it.second!=0){\\n                s=it.first;\\n                sol.push_back(s);\\n                it.second--;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353247,
                "title": "java-beats-100-in-speed-and-takes-100-less-memory",
                "content": "```\\nclass Solution {\\n    public int[] getCharCountBucket(String word, int[] charCount) {\\n        int[] charCountBucket = new int[26];\\n        for (char ch : word.toCharArray()) {\\n            if (charCount[ch - 97] > 0) {\\n                charCount[ch - 97]--;\\n                charCountBucket[ch - 97]++;\\n            }\\n        }\\n        return charCountBucket;\\n    }\\n    public List<String> commonChars(String[] A) {\\n        List<String> result = new ArrayList();\\n        if (A.length == 0) {\\n            return new ArrayList<String>();\\n        }\\n        int[] charCount = new int[26];\\n        for (char ch : A[0].toCharArray()) {\\n            charCount[ch - 97]++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            charCount = getCharCountBucket(A[i], charCount);\\n        }\\n        for (int i = 0; i < charCount.length; i++) {\\n            while (charCount[i] > 0) {\\n                result.add(\"\" + (char)(i + 97));\\n                charCount[i]--;\\n            }\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getCharCountBucket(String word, int[] charCount) {\\n        int[] charCountBucket = new int[26];\\n        for (char ch : word.toCharArray()) {\\n            if (charCount[ch - 97] > 0) {\\n                charCount[ch - 97]--;\\n                charCountBucket[ch - 97]++;\\n            }\\n        }\\n        return charCountBucket;\\n    }\\n    public List<String> commonChars(String[] A) {\\n        List<String> result = new ArrayList();\\n        if (A.length == 0) {\\n            return new ArrayList<String>();\\n        }\\n        int[] charCount = new int[26];\\n        for (char ch : A[0].toCharArray()) {\\n            charCount[ch - 97]++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            charCount = getCharCountBucket(A[i], charCount);\\n        }\\n        for (int i = 0; i < charCount.length; i++) {\\n            while (charCount[i] > 0) {\\n                result.add(\"\" + (char)(i + 97));\\n                charCount[i]--;\\n            }\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321240,
                "title": "java-high-performance",
                "content": "```\\npublic List<String> commonChars(String[] A) {\\n\\tList<String> res=new ArrayList<String>();\\n\\tint[] min=new int[26];\\n\\tfor(int i=0;i<26;i++){\\n\\t\\tmin[i]=Integer.MAX_VALUE;\\n\\t}\\n\\tfor(String s:A){\\n\\t\\tint[] cur=new int[26];\\n\\t\\tchar[] ca=s.toCharArray();\\n\\t\\tfor(char c:ca){\\n\\t\\t\\tcur[c -\\'a\\']++;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\tmin[i]=Math.min(min[i],cur[i]);\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<26;i++){\\n\\t\\tfor(int j=0;j<min[i];j++){\\n\\t\\t\\tres.add(String.valueOf((char)(i+\\'a\\')));\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> commonChars(String[] A) {\\n\\tList<String> res=new ArrayList<String>();\\n\\tint[] min=new int[26];\\n\\tfor(int i=0;i<26;i++){\\n\\t\\tmin[i]=Integer.MAX_VALUE;\\n\\t}\\n\\tfor(String s:A){\\n\\t\\tint[] cur=new int[26];\\n\\t\\tchar[] ca=s.toCharArray();\\n\\t\\tfor(char c:ca){\\n\\t\\t\\tcur[c -\\'a\\']++;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\tmin[i]=Math.min(min[i],cur[i]);\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<26;i++){\\n\\t\\tfor(int j=0;j<min[i];j++){\\n\\t\\t\\tres.add(String.valueOf((char)(i+\\'a\\')));\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260815,
                "title": "javascript-99-time-100-memory-easy-to-understand-iterative-method",
                "content": "```\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n    let ans = A[0].split(\"\");\\n    for(let i=1; i< A.length; i++){\\n        ans = findCommon(ans, A[i].split(\"\"));\\n    }\\n    return ans;\\n};\\n\\nvar findCommon = function(a,b){\\n  return a.filter(v=>{\\n      let i = b.indexOf(v);\\n      if(i !== -1){\\n          b.splice(i, 1);\\n          return true\\n      }\\n      return false;\\n  })\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n    let ans = A[0].split(\"\");\\n    for(let i=1; i< A.length; i++){\\n        ans = findCommon(ans, A[i].split(\"\"));\\n    }\\n    return ans;\\n};\\n\\nvar findCommon = function(a,b){\\n  return a.filter(v=>{\\n      let i = b.indexOf(v);\\n      if(i !== -1){\\n          b.splice(i, 1);\\n          return true\\n      }\\n      return false;\\n  })\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2625261,
                "title": "simple-counter-49ms",
                "content": "![image](https://assets.leetcode.com/users/images/6bf5ce0d-9bf7-4ae8-b832-5405476a9384_1664167116.9646862.png)\\n\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        data = collections.Counter(words[0])\\n        for word in words:\\n            data2 = collections.Counter(word)\\n            for k in data.keys():\\n                data[k] = min(data[k], data2[k])\\n        return data.elements()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        data = collections.Counter(words[0])\\n        for word in words:\\n            data2 = collections.Counter(word)\\n            for k in data.keys():\\n                data[k] = min(data[k], data2[k])\\n        return data.elements()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099192,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        \\n        int count[][] = new int[words.length][26];\\n        List<Integer> l = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        \\n        for(int i=0; i<words.length; i++)\\n        {\\n            for(int j=0; j<words[i].length(); j++)\\n                count[i][(int)(words[i].charAt(j) - 97)]++;\\n        }\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<words.length; j++)\\n            {\\n                l.add(count[j][i]);\\n            }\\n            int min = Collections.min(l);\\n            l.clear();\\n            if(min > 0)\\n            {\\n                for(int j=0; j<min; j++)\\n                {\\n                    res.add(String.valueOf((char)(i + 97)));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        \\n        int count[][] = new int[words.length][26];\\n        List<Integer> l = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        \\n        for(int i=0; i<words.length; i++)\\n        {\\n            for(int j=0; j<words[i].length(); j++)\\n                count[i][(int)(words[i].charAt(j) - 97)]++;\\n        }\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<words.length; j++)\\n            {\\n                l.add(count[j][i]);\\n            }\\n            int min = Collections.min(l);\\n            l.clear();\\n            if(min > 0)\\n            {\\n                for(int j=0; j<min; j++)\\n                {\\n                    res.add(String.valueOf((char)(i + 97)));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412020,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        ArrayList<String> result = new ArrayList<>();\\n\\t\\t//an int array with size of 26 to count character frequency\\n        int[] count = new int[26];\\n\\t\\t//count character frequencies in first word, and put count in an int array\\n        for (int i = 0; i < words[0].length(); i++) {\\n            count[words[0].charAt(i) - \\'a\\']++;\\n        }\\n\\t\\t//for each word, start from second word\\n        for (int i = 1; i < words.length; i++) {\\n            int[] temp = new int[26];\\n\\t\\t\\t//count character frequencies and put result into a temp array\\n            for (int j = 0; j < words[i].length(); j++) {\\n                temp[words[i].charAt(j) - \\'a\\']++;\\n            }\\n\\t\\t\\t//compare frequencies in temp and count\\n            for (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\t//if temp[j]==0, that means this character cannot be the common character\\n\\t\\t\\t\\t//if temp[j] and count[j] are both greater than 0, that means there will be common characters of temp[j] at the current moment. set count[j] to temp[j]\\n\\t\\t\\t\\t//count[j] is frequency of common characters for previous words, and temp[j] is frequency of characters for current word\\n                if (temp[j] <= count[j] && temp[j] != 0) count[j] = temp[j];\\n                if (temp[j] == 0) count[j] = 0;\\n            }\\n        }\\n\\t\\t// convert count to a set\\n        for (int i = 0; i < 26; i++) {\\n            while (count[i]-- > 0) {\\n                result.add(\"\" + (char) (\\'a\\' + i));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        ArrayList<String> result = new ArrayList<>();\\n\\t\\t//an int array with size of 26 to count character frequency\\n        int[] count = new int[26];\\n\\t\\t//count character frequencies in first word, and put count in an int array\\n        for (int i = 0; i < words[0].length(); i++) {\\n            count[words[0].charAt(i) - \\'a\\']++;\\n        }\\n\\t\\t//for each word, start from second word\\n        for (int i = 1; i < words.length; i++) {\\n            int[] temp = new int[26];\\n\\t\\t\\t//count character frequencies and put result into a temp array\\n            for (int j = 0; j < words[i].length(); j++) {\\n                temp[words[i].charAt(j) - \\'a\\']++;\\n            }\\n\\t\\t\\t//compare frequencies in temp and count\\n            for (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\t//if temp[j]==0, that means this character cannot be the common character\\n\\t\\t\\t\\t//if temp[j] and count[j] are both greater than 0, that means there will be common characters of temp[j] at the current moment. set count[j] to temp[j]\\n\\t\\t\\t\\t//count[j] is frequency of common characters for previous words, and temp[j] is frequency of characters for current word\\n                if (temp[j] <= count[j] && temp[j] != 0) count[j] = temp[j];\\n                if (temp[j] == 0) count[j] = 0;\\n            }\\n        }\\n\\t\\t// convert count to a set\\n        for (int i = 0; i < 26; i++) {\\n            while (count[i]-- > 0) {\\n                result.add(\"\" + (char) (\\'a\\' + i));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688794,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        ans = list(A[0])\\n        for word in A:\\n            check = []\\n            for c in word:\\n                if c in ans:\\n                    check.append(c)\\n                    ans.remove(c)\\n            ans = check\\n        return ans\\n        \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        ans = list(A[0])\\n        for word in A:\\n            check = []\\n            for c in word:\\n                if c in ans:\\n                    check.append(c)\\n                    ans.remove(c)\\n            ans = check\\n        return ans\\n        \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 514982,
                "title": "c-linq-solution-with-no-limitation-on-char-being-a-to-z-with-description",
                "content": "```\\npublic class Solution {\\n    public IList<string> CommonChars(string[] A) {\\n        return A\\n\\t\\t\\t// group chars in each word and then select all the groups across all words\\n            .SelectMany(a => a.GroupBy(c => c))\\n\\t\\t\\t// group all the groups again by char again\\n            .GroupBy(e => e.Key)\\n\\t\\t\\t// filtering out groups that don\\'t have a count not matching the number of words\\n\\t\\t\\t// if count doesn\\'t match word count that means not all the words have that specific char\\n            .Where(g => g.Count() == A.Length)\\n\\t\\t\\t// for each group we generate a char repeated to minumum of its repeat across words\\n\\t\\t\\t// if a word has 1 <o> and another has 2 then the min is 1 so we output only 1 <o>\"\\n            .SelectMany(g => Enumerable.Repeat(g.Key.ToString(), g.Min(h => h.Count())))\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> CommonChars(string[] A) {\\n        return A\\n\\t\\t\\t// group chars in each word and then select all the groups across all words\\n            .SelectMany(a => a.GroupBy(c => c))\\n\\t\\t\\t// group all the groups again by char again\\n            .GroupBy(e => e.Key)\\n\\t\\t\\t// filtering out groups that don\\'t have a count not matching the number of words\\n\\t\\t\\t// if count doesn\\'t match word count that means not all the words have that specific char\\n            .Where(g => g.Count() == A.Length)\\n\\t\\t\\t// for each group we generate a char repeated to minumum of its repeat across words\\n\\t\\t\\t// if a word has 1 <o> and another has 2 then the min is 1 so we output only 1 <o>\"\\n            .SelectMany(g => Enumerable.Repeat(g.Key.ToString(), g.Min(h => h.Count())))\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349352,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  if(A.length===1){\\n    return A[0].split(\\'\\');\\n  }\\n  let lens = A.length;\\n  let res = [];\\n  for(let j of A[0]){\\n    let i;\\n    for(i = 1; i < lens; i++){\\n      if(!A[i].includes(j)){\\n        break;\\n      }else{\\n        A[i] = A[i].replace(j,\\'\\');\\n      }\\n    }\\n    if(i === lens){\\n      res.push(j);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  if(A.length===1){\\n    return A[0].split(\\'\\');\\n  }\\n  let lens = A.length;\\n  let res = [];\\n  for(let j of A[0]){\\n    let i;\\n    for(i = 1; i < lens; i++){\\n      if(!A[i].includes(j)){\\n        break;\\n      }else{\\n        A[i] = A[i].replace(j,\\'\\');\\n      }\\n    }\\n    if(i === lens){\\n      res.push(j);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325381,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  if (A.length <= 1) return [];\\n  let res = helper(A[0], A[1]);\\n  \\n  for (let i = 2; i < A.length; i++) {\\n    res = helper(res, A[i]);\\n  }\\n  return res.split(\\'\\');\\n};\\n\\n// Helper function returns character intersecations as a string\\nconst helper = (str1, str2) => {\\n  let result = \\'\\';\\n  let map = {};\\n  \\n  for (let char of str1) {\\n    if (!map[char]) {\\n      map[char] = 1;\\n    } else {\\n      map[char]++;\\n    }\\n  }\\n  \\n  for (let char of str2) {\\n    if (map[char]) {\\n      result += char;\\n      map[char]--;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  if (A.length <= 1) return [];\\n  let res = helper(A[0], A[1]);\\n  \\n  for (let i = 2; i < A.length; i++) {\\n    res = helper(res, A[i]);\\n  }\\n  return res.split(\\'\\');\\n};\\n\\n// Helper function returns character intersecations as a string\\nconst helper = (str1, str2) => {\\n  let result = \\'\\';\\n  let map = {};\\n  \\n  for (let char of str1) {\\n    if (!map[char]) {\\n      map[char] = 1;\\n    } else {\\n      map[char]++;\\n    }\\n  }\\n  \\n  for (let char of str2) {\\n    if (map[char]) {\\n      result += char;\\n      map[char]--;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250132,
                "title": "c-one-line",
                "content": "```\\n    public IList<string> CommonChars(string[] A) {\\n        return A[0].Distinct().SelectMany(l => Enumerable.Repeat(l.ToString(), A.Min(x => x.Count(y => y == l)))).ToList();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<string> CommonChars(string[] A) {\\n        return A[0].Distinct().SelectMany(l => Enumerable.Repeat(l.ToString(), A.Min(x => x.Count(y => y == l)))).ToList();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248410,
                "title": "python-explained-no-counter-intuitive-solution",
                "content": "**Approach**\\n1) Initialize a dictionary dict1 with letter counts from word#1\\n2) Compare letters in dict1 with word#2: add letters in common to dict2 while reducing the count in dict1 to account for duplicates\\n3) Clear dict1\\n4) Compare letters in dict2 with word#3 in the same fashion\\n5) Clear dict2\\n6) Repeat for next words, alternating between filling/clearing dict1/2\\n7) Return result from the appropriate dictionary\\n\\nWill appreciate if you guys can suggest more condensed code with this logic.\\n\\nCheers\\n\\n**Solution**\\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dict1 = collections.defaultdict(int)\\n        dict2 = collections.defaultdict(int)\\n        k = 0\\n        \\n        for letter in A[0]:\\n            dict1[letter] += 1\\n        \\n        for word in A[1:]:\\n            if k%2 == 0:\\n                for letter in word:\\n                    if dict1[letter]:\\n                        dict2[letter] += 1\\n                        dict1[letter] -= 1\\n                dict1.clear()\\n            else:\\n                for letter in word:\\n                    if dict2[letter]:\\n                        dict1[letter] += 1\\n                        dict2[letter] -= 1\\n                dict2.clear()\\n            k += 1\\n        \\n        if k%2 == 0:\\n            result = [letter for l,cnt in dict1.items() for letter in l*cnt]\\n        else:\\n            result = [letter for l,cnt in dict2.items() for letter in l*cnt]\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dict1 = collections.defaultdict(int)\\n        dict2 = collections.defaultdict(int)\\n        k = 0\\n        \\n        for letter in A[0]:\\n            dict1[letter] += 1\\n        \\n        for word in A[1:]:\\n            if k%2 == 0:\\n                for letter in word:\\n                    if dict1[letter]:\\n                        dict2[letter] += 1\\n                        dict1[letter] -= 1\\n                dict1.clear()\\n            else:\\n                for letter in word:\\n                    if dict2[letter]:\\n                        dict1[letter] += 1\\n                        dict2[letter] -= 1\\n                dict2.clear()\\n            k += 1\\n        \\n        if k%2 == 0:\\n            result = [letter for l,cnt in dict1.items() for letter in l*cnt]\\n        else:\\n            result = [letter for l,cnt in dict2.items() for letter in l*cnt]\\n\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2062244,
                "title": "simple-javascript-solution-easy-to-understand",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar commonChars = function(words, result = []) {\\n    // we just need to take the first element from the array for comparison\\n    for (const letter of words[0]) {\\n        // check letter in word\\n        if (words.every(w => w.includes(letter))) {\\n            result.push(letter)\\n            // remove letter from word\\n            words = words.map(w => w.replace(letter, \\'\\'))\\n        }\\n    }\\n    // the duplicate letter\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar commonChars = function(words, result = []) {\\n    // we just need to take the first element from the array for comparison\\n    for (const letter of words[0]) {\\n        // check letter in word\\n        if (words.every(w => w.includes(letter))) {\\n            result.push(letter)\\n            // remove letter from word\\n            words = words.map(w => w.replace(letter, \\'\\'))\\n        }\\n    }\\n    // the duplicate letter\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1818072,
                "title": "simple-solution-brute-force",
                "content": "\\n \\n    ArrayList<String> list = new ArrayList<>();\\n        for(int k = 0;k<words[0].length();k++){\\n            int c = 1;\\n           for(int i = 1;i<words.length;i++){\\n             for(int j = 0;j<words[i].length();j++){  \\n                 if(words[0].charAt(k) == words[i].charAt(j)){\\n                     c++;\\n                     words[i] = words[i].substring(0,j)+\"\"+words[i].substring(j+1);\\n                     break;\\n                 }\\n             }\\n          }\\n            if(c == words.length) list.add(words[0].charAt(k)+\"\"); \\n        } \\n        return list;",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n \\n    ArrayList<String> list = new ArrayList<>();\\n        for(int k = 0;k<words[0].length();k++){\\n            int c = 1;\\n           for(int i = 1;i<words.length;i++){\\n             for(int j = 0;j<words[i].length();j++){  \\n                 if(words[0].charAt(k) == words[i].charAt(j)){\\n                     c++;\\n                     words[i] = words[i].substring(0,j)+\"\"+words[i].substring(j+1);\\n                     break;\\n                 }\\n             }\\n          }\\n            if(c == words.length) list.add(words[0].charAt(k)+\"\"); \\n        } \\n        return list;",
                "codeTag": "Unknown"
            },
            {
                "id": 1177496,
                "title": "easy-to-understand-c",
                "content": "Description in Comment Section .\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {        \\n        string s = A[0];\\n        vector<string> res;\\n        int j=0, k;\\n        char search;\\n        while(j != s.length()) {\\n            search = s[j];\\n            k = 0;\\n             for(int i=1; i<A.size(); i++) {\\n                 if(A[i].find(search) != -1) {\\n                     A[i].erase(A[i].find(search),1);\\n                     k++;\\n                 }         \\n             }\\n            if(k == A.size()-1)\\n                res.push_back(string(1, search));\\n            j++;\\n        }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {        \\n        string s = A[0];\\n        vector<string> res;\\n        int j=0, k;\\n        char search;\\n        while(j != s.length()) {\\n            search = s[j];\\n            k = 0;\\n             for(int i=1; i<A.size(); i++) {\\n                 if(A[i].find(search) != -1) {\\n                     A[i].erase(A[i].find(search),1);\\n                     k++;\\n                 }         \\n             }\\n            if(k == A.size()-1)\\n                res.push_back(string(1, search));\\n            j++;\\n        }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049772,
                "title": "simple-method-c-java-o-n-2-0-ms-faster-than-99-00-easy-to-understand",
                "content": "**Implementation**\\n\\n**1st Approach in C++**\\nTime Complexity = O(N^2), Space Complexity = O(N)\\n```\\nvector<string> commonChars(vector<string>& A) {\\n    vector<int> check1(26, 0);\\n    vector<int> check2(26, 0);\\n    vector<string> result;\\n    \\n    for(char ch : A[0]){\\n        check1[ch-\\'a\\']++;\\n    }\\n    \\n    for(int itr = 1; itr < A.size(); itr++){\\n        for(char ch : A[itr]){\\n            check2[ch-\\'a\\']++;\\n        }\\n        \\n        for(int jtr = 0; jtr < 26; jtr++){\\n            check1[jtr] = min(check1[jtr], check2[jtr]); \\n            check2[jtr] = 0;\\n        }\\n    }\\n           \\n    for(int itr = 0; itr < 26; itr++){\\n        if(check1[itr]){\\n            int value = check1[itr];\\n            while(value--){\\n                char ch = itr + \\'a\\';\\n                string str;\\n                str = ch;\\n                result.emplace_back(str);                                \\n            }                \\n        }\\n    }\\n    return result;\\n}\\n```\\n**2nd Approach in Java**\\nTime Complexity = O(N^2), Space Complexity = O(N)\\n\\n```\\npublic List<String> commonChars(String[] A) {\\n    int[] check1 = new int[26];\\n    int[] check2 = new int[26];\\n    List<String> result = new ArrayList<String>();\\n    \\n    String str = A[0];\\n    for(int itr = 0; itr < str.length(); itr++){\\n        check1[str.charAt(itr)-\\'a\\']++;\\n    }\\n    \\n    for(int itr = 1; itr < A.length; itr++){\\n        str = A[itr];\\n        for(int jtr = 0; jtr < str.length(); jtr++){\\n            check2[str.charAt(jtr)-\\'a\\']++;\\n        }            \\n        \\n        for(int jtr = 0; jtr < 26; jtr++){\\n            check1[jtr] = Math.min(check1[jtr], check2[jtr]); \\n            check2[jtr] = 0;\\n        }\\n    }\\n           \\n    for(int itr = 0; itr < 26; itr++){\\n        if(check1[itr] > 0){\\n            int value = check1[itr];\\n            while(value-- > 0){\\n                char ch = (char)(itr + \\'a\\');                                        \\n                result.add(Character.toString((char)ch));                                \\n            }                \\n        }\\n    }\\n    return result;\\n}\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array"
                ],
                "code": "```\\nvector<string> commonChars(vector<string>& A) {\\n    vector<int> check1(26, 0);\\n    vector<int> check2(26, 0);\\n    vector<string> result;\\n    \\n    for(char ch : A[0]){\\n        check1[ch-\\'a\\']++;\\n    }\\n    \\n    for(int itr = 1; itr < A.size(); itr++){\\n        for(char ch : A[itr]){\\n            check2[ch-\\'a\\']++;\\n        }\\n        \\n        for(int jtr = 0; jtr < 26; jtr++){\\n            check1[jtr] = min(check1[jtr], check2[jtr]); \\n            check2[jtr] = 0;\\n        }\\n    }\\n           \\n    for(int itr = 0; itr < 26; itr++){\\n        if(check1[itr]){\\n            int value = check1[itr];\\n            while(value--){\\n                char ch = itr + \\'a\\';\\n                string str;\\n                str = ch;\\n                result.emplace_back(str);                                \\n            }                \\n        }\\n    }\\n    return result;\\n}\\n```\n```\\npublic List<String> commonChars(String[] A) {\\n    int[] check1 = new int[26];\\n    int[] check2 = new int[26];\\n    List<String> result = new ArrayList<String>();\\n    \\n    String str = A[0];\\n    for(int itr = 0; itr < str.length(); itr++){\\n        check1[str.charAt(itr)-\\'a\\']++;\\n    }\\n    \\n    for(int itr = 1; itr < A.length; itr++){\\n        str = A[itr];\\n        for(int jtr = 0; jtr < str.length(); jtr++){\\n            check2[str.charAt(jtr)-\\'a\\']++;\\n        }            \\n        \\n        for(int jtr = 0; jtr < 26; jtr++){\\n            check1[jtr] = Math.min(check1[jtr], check2[jtr]); \\n            check2[jtr] = 0;\\n        }\\n    }\\n           \\n    for(int itr = 0; itr < 26; itr++){\\n        if(check1[itr] > 0){\\n            int value = check1[itr];\\n            while(value-- > 0){\\n                char ch = (char)(itr + \\'a\\');                                        \\n                result.add(Character.toString((char)ch));                                \\n            }                \\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905080,
                "title": "python3-beats-98-100-with-5-short-lines",
                "content": "**idea**\\nfor each letter of the alphabet, count its number *n* of occurences across all words, then append it *n* times to the result.\\n```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n    res = []\\n    for c in ascii_lowercase:\\n        for n in range(min([w.count(c) for w in A])):\\n            res.append(c)\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n    res = []\\n    for c in ascii_lowercase:\\n        for n in range(min([w.count(c) for w in A])):\\n            res.append(c)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 849212,
                "title": "c-clean-code-with-map-easy-to-understand",
                "content": "If you don\\'t know how this code work , Please comment below I will try my best to answer your question : )\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        unordered_map<char, int> ansMap;\\n        unordered_map<char, int> midMap;\\n        vector<string> ans;\\n        for(auto c : A[0]) {\\n            ansMap[c]++;\\n        }\\n        for (auto i = 1; i < A.size() ; ++i) {\\n            midMap.clear();\\n            for (auto c : A[i]) {\\n                midMap[c]++;\\n            }\\n            if (ansMap.size() == 0) {\\n                return ans;\\n            }\\n            for (auto iter = ansMap.begin(); iter != ansMap.end();iter++) {\\n                if (midMap.count(iter->first)) { \\n                    ansMap[iter->first] = min(ansMap[iter->first], midMap[iter->first]);\\n                }\\n                else {\\n                    ansMap[iter->first] = 0;\\n                }\\n            }\\n        }\\n        for (auto iter = ansMap.begin(); iter != ansMap.end(); iter++) {\\n            for (auto i = 0; i < ansMap[iter->first]; ++i) {\\n                ans.push_back(string(1, iter->first));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        unordered_map<char, int> ansMap;\\n        unordered_map<char, int> midMap;\\n        vector<string> ans;\\n        for(auto c : A[0]) {\\n            ansMap[c]++;\\n        }\\n        for (auto i = 1; i < A.size() ; ++i) {\\n            midMap.clear();\\n            for (auto c : A[i]) {\\n                midMap[c]++;\\n            }\\n            if (ansMap.size() == 0) {\\n                return ans;\\n            }\\n            for (auto iter = ansMap.begin(); iter != ansMap.end();iter++) {\\n                if (midMap.count(iter->first)) { \\n                    ansMap[iter->first] = min(ansMap[iter->first], midMap[iter->first]);\\n                }\\n                else {\\n                    ansMap[iter->first] = 0;\\n                }\\n            }\\n        }\\n        for (auto iter = ansMap.begin(); iter != ansMap.end(); iter++) {\\n            for (auto i = 0; i < ansMap[iter->first]; ++i) {\\n                ans.push_back(string(1, iter->first));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778615,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dic = {}\\n        for i in range(len(A)):\\n            for j in range(len(A[i])):\\n                if A[i][j] not in dic:\\n                    dic[A[i][j]] = (len(A))*[0]\\n                    dic[A[i][j]][i] = 1\\n                else:\\n                    dic[A[i][j]][i] += 1\\n        out = []\\n        for i,v in dic.items():\\n            if min(v)>0:\\n                out.extend([i]*min(v))\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dic = {}\\n        for i in range(len(A)):\\n            for j in range(len(A[i])):\\n                if A[i][j] not in dic:\\n                    dic[A[i][j]] = (len(A))*[0]\\n                    dic[A[i][j]][i] = 1\\n                else:\\n                    dic[A[i][j]][i] += 1\\n        out = []\\n        for i,v in dic.items():\\n            if min(v)>0:\\n                out.extend([i]*min(v))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368428,
                "title": "swift-solution-beats-90-32",
                "content": "```\\nclass Solution {\\n    func commonChars(_ A: [String]) -> [String] {\\n        \\n        //use the first string to get candidates for matching\\n        var candidates = [Character : Int]()        \\n        for ch in A[0] {\\n            if let val = candidates[ch] {\\n                candidates[ch] = val + 1\\n            } else {\\n                candidates[ch] = 1\\n            }\\n        }\\n        \\n        //create a dict for each additional string and compare\\n        for i in 1..<A.count {\\n            var matcher = [Character : Int]()\\n            for ch in A[i] {\\n                if let _ = candidates[ch] { \\n                    if let val = matcher[ch] {\\n                        matcher[ch] = val + 1\\n                    } else {\\n                        matcher[ch] = 1\\n                    }\\n                } \\n            }\\n            \\n            //reduce initial candidates list down to what we had in common\\n            candidates = reduceCandidates(candidates: candidates, matcher: matcher)\\n        }\\n\\n        //convert from dict\\'s quantities to array and return the result\\n        var result = [String]()\\n        for (c, n) in candidates {\\n            for i in 0..<n {\\n                result.append(String(c))\\n            }\\n        }\\n        return result\\n    }\\n    \\n    \\n    func reduceCandidates(candidates: [Character : Int], matcher: [Character : Int]) -> [Character : Int] {\\n        var newCandidates = candidates\\n        for (c, n) in candidates {\\n            if let val = matcher[c] {\\n                newCandidates[c] = min(candidates[c]!, val)  \\n            } else {\\n                newCandidates[c] = nil\\n            }\\n        }\\n    \\n        return newCandidates\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func commonChars(_ A: [String]) -> [String] {\\n        \\n        //use the first string to get candidates for matching\\n        var candidates = [Character : Int]()        \\n        for ch in A[0] {\\n            if let val = candidates[ch] {\\n                candidates[ch] = val + 1\\n            } else {\\n                candidates[ch] = 1\\n            }\\n        }\\n        \\n        //create a dict for each additional string and compare\\n        for i in 1..<A.count {\\n            var matcher = [Character : Int]()\\n            for ch in A[i] {\\n                if let _ = candidates[ch] { \\n                    if let val = matcher[ch] {\\n                        matcher[ch] = val + 1\\n                    } else {\\n                        matcher[ch] = 1\\n                    }\\n                } \\n            }\\n            \\n            //reduce initial candidates list down to what we had in common\\n            candidates = reduceCandidates(candidates: candidates, matcher: matcher)\\n        }\\n\\n        //convert from dict\\'s quantities to array and return the result\\n        var result = [String]()\\n        for (c, n) in candidates {\\n            for i in 0..<n {\\n                result.append(String(c))\\n            }\\n        }\\n        return result\\n    }\\n    \\n    \\n    func reduceCandidates(candidates: [Character : Int], matcher: [Character : Int]) -> [Character : Int] {\\n        var newCandidates = candidates\\n        for (c, n) in candidates {\\n            if let val = matcher[c] {\\n                newCandidates[c] = min(candidates[c]!, val)  \\n            } else {\\n                newCandidates[c] = nil\\n            }\\n        }\\n    \\n        return newCandidates\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316230,
                "title": "find-common-characters-0-ms-golang-solution-o-n-o-1",
                "content": "```\\nfunc commonChars(A []string) []string {\\n\\tcnt := [26]int{}\\n\\tfor i := range cnt {\\n\\t\\tcnt[i] = math.MaxUint16\\n\\t}\\n\\n\\tcntInWord := [26]int{}\\n\\tfor _, word := range A {\\n\\t\\tfor _, char := range []byte(word) { // compiler trick - here we will not allocate new memory\\n\\t\\t\\tcntInWord[char - \\'a\\']++\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < 26; i++ {\\n\\t\\t\\tif cntInWord[i] < cnt[i] {\\n\\t\\t\\t\\tcnt[i] = cntInWord[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor i := range cntInWord {\\n\\t\\t\\tcntInWord[i] = 0\\n\\t\\t}\\n\\t}\\n\\n\\tresult := make([]string, 0)\\n\\tfor i := 0; i < 26; i++ {\\n\\t\\tfor j := 0; j < cnt[i]; j++ {\\n\\t\\t\\tresult = append(result, string(i + \\'a\\'))\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\\nComplexity Analysis\\n\\nRuntime: O(n), n - total number of characters\\nSpace: O(1) - use 2 arrays",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc commonChars(A []string) []string {\\n\\tcnt := [26]int{}\\n\\tfor i := range cnt {\\n\\t\\tcnt[i] = math.MaxUint16\\n\\t}\\n\\n\\tcntInWord := [26]int{}\\n\\tfor _, word := range A {\\n\\t\\tfor _, char := range []byte(word) { // compiler trick - here we will not allocate new memory\\n\\t\\t\\tcntInWord[char - \\'a\\']++\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < 26; i++ {\\n\\t\\t\\tif cntInWord[i] < cnt[i] {\\n\\t\\t\\t\\tcnt[i] = cntInWord[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor i := range cntInWord {\\n\\t\\t\\tcntInWord[i] = 0\\n\\t\\t}\\n\\t}\\n\\n\\tresult := make([]string, 0)\\n\\tfor i := 0; i < 26; i++ {\\n\\t\\tfor j := 0; j < cnt[i]; j++ {\\n\\t\\t\\tresult = append(result, string(i + \\'a\\'))\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309840,
                "title": "c-readable-solution",
                "content": "```\\npublic IList<string> CommonChars(string[] A) {\\n          var intersection = A[0].ToCharArray().ToList();\\n            for (int i = 1; i < A.Length; i++)\\n            for (int k = 0; k < intersection.Count; k++)\\n            {\\n                int index = A[i].IndexOf(intersection[k]);\\n                if (index >= 0)\\n                    A[i] = A[i].Remove(index, 1);\\n                else\\n                {\\n                    intersection.RemoveAt(k);\\n                    k--;\\n                }\\n            }\\n\\n            return intersection.Select(ch => ch.ToString()).ToList();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<string> CommonChars(string[] A) {\\n          var intersection = A[0].ToCharArray().ToList();\\n            for (int i = 1; i < A.Length; i++)\\n            for (int k = 0; k < intersection.Count; k++)\\n            {\\n                int index = A[i].IndexOf(intersection[k]);\\n                if (index >= 0)\\n                    A[i] = A[i].Remove(index, 1);\\n                else\\n                {\\n                    intersection.RemoveAt(k);\\n                    k--;\\n                }\\n            }\\n\\n            return intersection.Select(ch => ch.ToString()).ToList();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261592,
                "title": "python-solution-three-lines",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        check = set(A[0])\\n        result = [[l] * min([a.count(l) for a in A]) for l in check]\\n        return sorted([i for e in result for i in e])\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        check = set(A[0])\\n        result = [[l] * min([a.count(l) for a in A]) for l in check]\\n        return sorted([i for e in result for i in e])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647780,
                "title": "for-beginners-more-simplified",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res = Counter(words[0])\\n        for i in words:\\n            res &= Counter(i)\\n        return list(res.elements())\\n        \\n```\\n\\n# Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\'&=\\'\\nThe &= operator in Python is a compound assignment operator that performs a bitwise AND operation between two operands and assigns the result back to the left operand.\\n\\nThe & operator is a bitwise AND operator that performs a bitwise AND operation between corresponding bits of two integers. It returns a new integer with bits set to 1 only where both corresponding bits of the operands are 1.\\n\\nThe &= operator combines the bitwise AND operation and assignment operation. It updates the left operand with the result of the bitwise AND operation between the left operand and the right operand.\\n\\nHere\\'s an example to illustrate the usage of &=:\\n\\npython\\n\\na = 5\\nb = 3\\na &= b  # Equivalent to: a = a & b\\nprint(a)  # Output: 1\\n\\nIn this example, a initially holds the value 5 (binary: 0101) and b holds the value 3 (binary: 0011). After performing a &= b, the value of a is updated to 1 (binary: 0001) because it performs a bitwise AND operation between the two values.\\n\\nThe &= operator can be used with different types, such as integers, booleans, sets, or custom objects, depending on how it is defined for each type. The specific behavior of &= may vary depending on the data type being used.\\n\\nIt\\'s important to note that the &= operator is not universally defined for all data types. Its availability and behavior depend on the specific implementation and behavior defined for each type.\\n\\n\\n# credits :   https://leetcode.com/rioran/",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res = Counter(words[0])\\n        for i in words:\\n            res &= Counter(i)\\n        return list(res.elements())\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420780,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        for (auto c: words[0])\\n        {\\n            bool isPresent = true;\\n            string s;\\n            for (int i = 1; i < words.size(); i++)\\n            {\\n                int index = words[i].find(c);\\n                cout<<index<<\" \";\\n                if(index != string::npos) {\\n                    words[i].erase(index, 1);\\n                }else {\\n                    isPresent = false;\\n                    break;\\n                }\\n            }\\n            if(isPresent) res.push_back(s+=c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        for (auto c: words[0])\\n        {\\n            bool isPresent = true;\\n            string s;\\n            for (int i = 1; i < words.size(); i++)\\n            {\\n                int index = words[i].find(c);\\n                cout<<index<<\" \";\\n                if(index != string::npos) {\\n                    words[i].erase(index, 1);\\n                }else {\\n                    isPresent = false;\\n                    break;\\n                }\\n            }\\n            if(isPresent) res.push_back(s+=c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2366740,
                "title": "c-easiest-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        for (auto c: words[0])\\n        {\\n            bool isPresent = true;\\n            string s;\\n            for (int i = 1; i < words.size(); i++)\\n            {\\n                int index = words[i].find(c);\\n                cout<<index<<\" \";\\n                if(index != string::npos) {\\n                    words[i].erase(index, 1);\\n                }else {\\n                    isPresent = false;\\n                    break;\\n                }\\n            }\\n            if(isPresent) res.push_back(s+=c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        for (auto c: words[0])\\n        {\\n            bool isPresent = true;\\n            string s;\\n            for (int i = 1; i < words.size(); i++)\\n            {\\n                int index = words[i].find(c);\\n                cout<<index<<\" \";\\n                if(index != string::npos) {\\n                    words[i].erase(index, 1);\\n                }else {\\n                    isPresent = false;\\n                    break;\\n                }\\n            }\\n            if(isPresent) res.push_back(s+=c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2103125,
                "title": "python-solution-slow-but-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        \\n        g = []\\n        \\n        for i in words[0]:\\n            t = True\\n            for j in range(len(words)):\\n                if i not in words[j]:\\n                    t = False\\n                else:\\n                    cur = list(words[j])\\n                    cur.pop(cur.index(i))\\n                    words[j] = \\'\\'.join(cur)\\n                  \\n                \\n            if t:\\n                g.append(i)\\n                \\n        return g\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        \\n        g = []\\n        \\n        for i in words[0]:\\n            t = True\\n            for j in range(len(words)):\\n                if i not in words[j]:\\n                    t = False\\n                else:\\n                    cur = list(words[j])\\n                    cur.pop(cur.index(i))\\n                    words[j] = \\'\\'.join(cur)\\n                  \\n                \\n            if t:\\n                g.append(i)\\n                \\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819654,
                "title": "c-unordered-map-comments-for-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        //mapping first word characters with their count\\n        for(auto x: words[0]) mp[x]++;\\n        \\n        for(int i=1; i<words.size(); i++){\\n           unordered_map<char, int> temp;\\n           //storing count of next words characters by making temp map everytime\\n            for(auto y : words[i])\\n                temp[y]++;\\n           \\n            //Updating original map values \\n            for(int i=0; i<26; i++){\\n                char ch = \\'a\\' + i;\\n                //If both mp and temp contains the character ch, update the\\n\\t\\t\\t\\t// main map i.e. mp with the value minimum of both mp and temp\\n\\t\\t\\t\\tif(temp.find(ch) != temp.end() && mp.find(ch) != mp.end()) mp[ch] = min(mp[ch], temp[ch]);\\n                //If temp doesn\\'t contain the character, that means we have to\\n\\t\\t\\t\\t//remove the ch from main map now\\n\\t\\t\\t\\telse if(mp.find(ch) != mp.end()) mp.erase(ch);\\n            }\\n        }\\n        \\n        //Handling the output of common characters\\n        vector<string> v;\\n        for(auto x: mp){\\n            string s =\"\"; \\n            s += x.first;\\n            for(int i=1; i<=x.second; i++) v.push_back(s);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        //mapping first word characters with their count\\n        for(auto x: words[0]) mp[x]++;\\n        \\n        for(int i=1; i<words.size(); i++){\\n           unordered_map<char, int> temp;\\n           //storing count of next words characters by making temp map everytime\\n            for(auto y : words[i])\\n                temp[y]++;\\n           \\n            //Updating original map values \\n            for(int i=0; i<26; i++){\\n                char ch = \\'a\\' + i;\\n                //If both mp and temp contains the character ch, update the\\n\\t\\t\\t\\t// main map i.e. mp with the value minimum of both mp and temp\\n\\t\\t\\t\\tif(temp.find(ch) != temp.end() && mp.find(ch) != mp.end()) mp[ch] = min(mp[ch], temp[ch]);\\n                //If temp doesn\\'t contain the character, that means we have to\\n\\t\\t\\t\\t//remove the ch from main map now\\n\\t\\t\\t\\telse if(mp.find(ch) != mp.end()) mp.erase(ch);\\n            }\\n        }\\n        \\n        //Handling the output of common characters\\n        vector<string> v;\\n        for(auto x: mp){\\n            string s =\"\"; \\n            s += x.first;\\n            for(int i=1; i<=x.second; i++) v.push_back(s);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261884,
                "title": "c-o-n-where-n-is-total-number-charachters-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        map<char,int>mp1;\\n        map<char,int>mp2;\\n        \\n        for(char ch: words[0])\\n            mp1[ch]++;\\n        \\n        for(int i=1;i<words.size();i++){\\n            string word = words[i];\\n            for(char ch:word){\\n                if(mp1.find(ch)!=mp1.end() && mp1[ch]>0){\\n                    mp1[ch]--;\\n                    mp2[ch]++;\\n                }\\n            }\\n            mp1.clear();\\n            mp1=mp2;\\n            mp2.clear();\\n        }\\n        vector<string>res;\\n        for(auto iter:mp1){\\n            int j = iter.second;\\n            string s = \"\";\\n            s=s+iter.first;\\n            while(j>0){\\n                res.push_back(s);j--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        map<char,int>mp1;\\n        map<char,int>mp2;\\n        \\n        for(char ch: words[0])\\n            mp1[ch]++;\\n        \\n        for(int i=1;i<words.size();i++){\\n            string word = words[i];\\n            for(char ch:word){\\n                if(mp1.find(ch)!=mp1.end() && mp1[ch]>0){\\n                    mp1[ch]--;\\n                    mp2[ch]++;\\n                }\\n            }\\n            mp1.clear();\\n            mp1=mp2;\\n            mp2.clear();\\n        }\\n        vector<string>res;\\n        for(auto iter:mp1){\\n            int j = iter.second;\\n            string s = \"\";\\n            s=s+iter.first;\\n            while(j>0){\\n                res.push_back(s);j--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184747,
                "title": "python-simple-list-comprehension-very-basic",
                "content": "\\n\\t# We can first find all the distinct letters that exist in A\\n\\t# For each distinct letter, we find how many times it occurs in each word in A. Take the minimum occurance.\\n\\t# occurance gives you something like this [[\"e\",1],[\"a\",0],[\"l\",2],[\"r\",0],[\"o\",0],[\"b\",0]]\\n\\t# This indicates we need to append \\'e\\' 1 time, and \\'l\\' 2 times. Other letters did not occur in some words since their minimum occurance is 0.\\n\\tclass Solution:\\n\\t\\tdef commonChars(self, A: List[str]) -> List[str]:\\n\\t\\t\\tletters = set([x for a in A for x in a])\\n\\t\\t\\toccurance = [[l, min([a.count(l) for a in A])] for l in letters]\\n\\t\\t\\tans = []\\n\\t\\t\\tfor o in occurance:\\n\\t\\t\\t\\tans += o[0]*o[1]\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\n\\t# We can first find all the distinct letters that exist in A\\n\\t# For each distinct letter, we find how many times it occurs in each word in A. Take the minimum occurance.\\n\\t# occurance gives you something like this [[\"e\",1],[\"a\",0],[\"l\",2],[\"r\",0],[\"o\",0],[\"b\",0]]\\n\\t# This indicates we need to append \\'e\\' 1 time, and \\'l\\' 2 times. Other letters did not occur in some words since their minimum occurance is 0.\\n\\tclass Solution:\\n\\t\\tdef commonChars(self, A: List[str]) -> List[str]:\\n\\t\\t\\tletters = set([x for a in A for x in a])\\n\\t\\t\\toccurance = [[l, min([a.count(l) for a in A])] for l in letters]\\n\\t\\t\\tans = []\\n\\t\\t\\tfor o in occurance:\\n\\t\\t\\t\\tans += o[0]*o[1]\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 1088489,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int[] common = count(A[0]);\\n        \\n        for (int i = 1; i < A.length; i++) {\\n            common = cross(common, count(A[i]));\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < common[i]; j++) {\\n                Character c = (char) (\\'a\\' + i);\\n                result.add(c.toString());\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static int[] count(String s) {\\n        int[] count = new int[26];\\n        for (char c: s.toCharArray()) {\\n            count[c - \\'a\\']++;\\n        }\\n        return count;\\n    }\\n    \\n    private static int[] cross(int[] x, int[] y) {\\n        int[] result = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            result[i] = Math.min(x[i], y[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int[] common = count(A[0]);\\n        \\n        for (int i = 1; i < A.length; i++) {\\n            common = cross(common, count(A[i]));\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < common[i]; j++) {\\n                Character c = (char) (\\'a\\' + i);\\n                result.add(c.toString());\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static int[] count(String s) {\\n        int[] count = new int[26];\\n        for (char c: s.toCharArray()) {\\n            count[c - \\'a\\']++;\\n        }\\n        return count;\\n    }\\n    \\n    private static int[] cross(int[] x, int[] y) {\\n        int[] result = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            result[i] = Math.min(x[i], y[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037047,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        ans = []\\n        for i in set(A[0]):\\n            x = []\\n            for j in A:\\n                x.append(j.count(i))\\n            a = 0\\n            while a < min(x):\\n                ans.append(i)\\n                a += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        ans = []\\n        for i in set(A[0]):\\n            x = []\\n            for j in A:\\n                x.append(j.count(i))\\n            a = 0\\n            while a < min(x):\\n                ans.append(i)\\n                a += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964176,
                "title": "c-solution-hashmap-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) \\n    {\\n        int mp[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            mp[i]=INT_MAX;\\n        }\\n        for(auto x: A)\\n        {\\n            int h[26]={0};\\n            for(auto c:x)\\n            {\\n                h[c-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                mp[i]=min(mp[i],h[i]);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<26;i++)\\n        {\\n            while(mp[i])\\n            {\\n                ans.push_back(string(1,i+\\'a\\'));\\n                mp[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) \\n    {\\n        int mp[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            mp[i]=INT_MAX;\\n        }\\n        for(auto x: A)\\n        {\\n            int h[26]={0};\\n            for(auto c:x)\\n            {\\n                h[c-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                mp[i]=min(mp[i],h[i]);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<26;i++)\\n        {\\n            while(mp[i])\\n            {\\n                ans.push_back(string(1,i+\\'a\\'));\\n                mp[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861581,
                "title": "java-3ms-runtime-92",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int n = A.length;\\n        int[]result = new int[26];\\n        Arrays.fill(result,100);\\n        for(int i=0;i<n;i++){\\n            int[]curr=new int[26];\\n            for(int j=0;j<A[i].length();j++){\\n                curr[(int)(A[i].charAt(j) - \\'a\\')]++;\\n            }\\n            for(int j=0;j<26;j++){\\n                result[j]=Math.min(result[j],curr[j]);\\n            }\\n        }\\n        List<String>ret = new LinkedList<String>();\\n        for(int i=0;i<26;i++){\\n            while(result[i]--!=0){\\n                ret.add(String.valueOf((char)(i+\\'a\\')));\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int n = A.length;\\n        int[]result = new int[26];\\n        Arrays.fill(result,100);\\n        for(int i=0;i<n;i++){\\n            int[]curr=new int[26];\\n            for(int j=0;j<A[i].length();j++){\\n                curr[(int)(A[i].charAt(j) - \\'a\\')]++;\\n            }\\n            for(int j=0;j<26;j++){\\n                result[j]=Math.min(result[j],curr[j]);\\n            }\\n        }\\n        List<String>ret = new LinkedList<String>();\\n        for(int i=0;i<26;i++){\\n            while(result[i]--!=0){\\n                ret.add(String.valueOf((char)(i+\\'a\\')));\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716130,
                "title": "c-o-n-time-o-1-space-beats-99",
                "content": "In our solution we are basically calculating the result map as mp1, and mp2 is a temporary map for each iterating word. Next we find the intersection (minimum) of both sets to get our desired results in map mp1.\\n```\\nvector<string> commonChars(vector<string>& A) {\\n        int mp1[26] = {0};\\n        int mp2[26] = {0};\\n        for(auto &c:A[0])\\n            mp1[c-\\'a\\']++;\\n        for(int i=1;i<A.size();i++)\\n        {\\n            for(auto &c:A[i])\\n                mp2[c-\\'a\\']++;\\n            for(int j=0;j<26;j++)\\n            {\\n                mp1[j] = min(mp1[j],mp2[j]);\\n                mp2[j] = 0;\\n            }\\n        }\\n        vector<string> res;\\n        for(int i=0;i<26;i++)\\n            while(mp1[i]--)\\n                res.push_back(string(1,\\'a\\'+ i));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> commonChars(vector<string>& A) {\\n        int mp1[26] = {0};\\n        int mp2[26] = {0};\\n        for(auto &c:A[0])\\n            mp1[c-\\'a\\']++;\\n        for(int i=1;i<A.size();i++)\\n        {\\n            for(auto &c:A[i])\\n                mp2[c-\\'a\\']++;\\n            for(int j=0;j<26;j++)\\n            {\\n                mp1[j] = min(mp1[j],mp2[j]);\\n                mp2[j] = 0;\\n            }\\n        }\\n        vector<string> res;\\n        for(int i=0;i<26;i++)\\n            while(mp1[i]--)\\n                res.push_back(string(1,\\'a\\'+ i));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498420,
                "title": "python-simple-solution-faster-than-96-93-memory-less-than-100",
                "content": "* Runtime: 36 ms, faster than 96.93% of Python3 online submissions for Find Common Characters.\\n* Memory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Find Common Characters.\\n\\n```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n\\toutput = []\\n\\t\\tfor char in A[0]: # iterate through each character in the first string\\n\\t\\t\\tif all(char in string for string in A): # if every string contains this character\\n\\t\\t\\t\\toutput.append(char) # add it to the output list\\n\\t\\t\\t\\tA = [s.replace(char,\\'\\',1) for s in A] # replace 1 instance of this character from each string\\n\\treturn output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n\\toutput = []\\n\\t\\tfor char in A[0]: # iterate through each character in the first string\\n\\t\\t\\tif all(char in string for string in A): # if every string contains this character\\n\\t\\t\\t\\toutput.append(char) # add it to the output list\\n\\t\\t\\t\\tA = [s.replace(char,\\'\\',1) for s in A] # replace 1 instance of this character from each string\\n\\treturn output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 487777,
                "title": "python-1-line-and-counters-or-min-count",
                "content": "```\\ndef commonChars(self, A):\\n    return reduce(operator.and_, map(collections.Counter, A)).elements()\\n```\\n```\\ndef commonChars(self, A):\\n    return [c for c in set(A[0]) for c in c * min(a.count(c) for a in A)]\\n```",
                "solutionTags": [],
                "code": "```\\ndef commonChars(self, A):\\n    return reduce(operator.and_, map(collections.Counter, A)).elements()\\n```\n```\\ndef commonChars(self, A):\\n    return [c for c in set(A[0]) for c in c * min(a.count(c) for a in A)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 442487,
                "title": "c-linq-solution-5-lines",
                "content": "``` csharp\\npublic class Solution {\\n    public IList<string> CommonChars(string[] A) {\\n        return Enumerable.Range((int)\\'a\\', 26)\\n            .Select(x => new { ch = (char)x, cnt = A.Min(y => y.Count(z => z == (char)x)) })\\n            .Where(x => x.cnt > 0)\\n            .SelectMany(x => Enumerable.Range(0, x.cnt).Select(y => x.ch.ToString()))\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic class Solution {\\n    public IList<string> CommonChars(string[] A) {\\n        return Enumerable.Range((int)\\'a\\', 26)\\n            .Select(x => new { ch = (char)x, cnt = A.Min(y => y.Count(z => z == (char)x)) })\\n            .Where(x => x.cnt > 0)\\n            .SelectMany(x => Enumerable.Range(0, x.cnt).Select(y => x.ch.ToString()))\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404915,
                "title": "python-99",
                "content": "\\'\\'\\'\\n        \\n\\t\\tres = []\\n\\n        for ch in A[0]:\\n            count = 0\\n            for i in range(1, len(A)):\\n                if ch not in A[i]:\\n                    break\\n                else:\\n                    count += 1\\n                    A[i] = A[i].replace(ch,\\'\\', 1)\\n            if count == len(A) - 1:\\n                res.append(ch)\\n        \\n        return res\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n        \\n\\t\\tres = []\\n\\n        for ch in A[0]:\\n            count = 0\\n            for i in range(1, len(A)):\\n                if ch not in A[i]:\\n                    break\\n                else:\\n                    count += 1\\n                    A[i] = A[i].replace(ch,\\'\\', 1)\\n            if count == len(A) - 1:\\n                res.append(ch)\\n        \\n        return res\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 301527,
                "title": "java-98-time-99-space",
                "content": "```java\\npublic List<String> commonChars(String[] A) {\\n        // use two frequency arrays\\n        // \\'freqs\\' holds our answer as we build it\\n        // \\'compare\\' holds each String as we iterate\\n        // as we inspect it\\n        int[] freqs = new int[26];\\n        int[] compare = new int[26];\\n        \\n        // initialize the \\'freqs\\' array with the frequencies\\n\\t\\t// found in the first String\\n        String first = A[0];\\n        for (char c : first.toCharArray()) {\\n            freqs[c - \\'a\\']++;\\n        }\\n\\n        for (int i = 1; i < A.length; i++) {\\n\\t\\t\\t// build the \\'compare\\' array with frequency of\\n\\t\\t\\t// each character occurring in the current String\\n            for (char c : A[i].toCharArray()) {\\n                compare[c - \\'a\\']++;\\n            }\\n\\t\\t\\t// whittle the \\'freqs\\' values down by using Math.min()\\n\\t\\t\\t// with the frequencies found in the current String\\n\\t\\t\\t// also reset the \\'compare\\' array for next iteration\\n            for (int j = 0; j < 26; j++) {\\n                freqs[j] = Math.min(freqs[j], compare[j]);\\n                compare[j] = 0;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// at this point, \\'freqs\\' contains the minimum occurrence\\n\\t\\t// frequency for each character a-z across all the Strings\\n        \\n        // construct the required List<String> answer\\n        List<String> result = new ArrayList<String>();\\n        for (int i = 0; i < 26; i++) {\\n            while (freqs[i]-- > 0) {\\n                result.add(Character.toString((char)(\\'a\\' + i)));\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\npublic List<String> commonChars(String[] A) {\\n        // use two frequency arrays\\n        // \\'freqs\\' holds our answer as we build it\\n        // \\'compare\\' holds each String as we iterate\\n        // as we inspect it\\n        int[] freqs = new int[26];\\n        int[] compare = new int[26];\\n        \\n        // initialize the \\'freqs\\' array with the frequencies\\n\\t\\t// found in the first String\\n        String first = A[0];\\n        for (char c : first.toCharArray()) {\\n            freqs[c - \\'a\\']++;\\n        }\\n\\n        for (int i = 1; i < A.length; i++) {\\n\\t\\t\\t// build the \\'compare\\' array with frequency of\\n\\t\\t\\t// each character occurring in the current String\\n            for (char c : A[i].toCharArray()) {\\n                compare[c - \\'a\\']++;\\n            }\\n\\t\\t\\t// whittle the \\'freqs\\' values down by using Math.min()\\n\\t\\t\\t// with the frequencies found in the current String\\n\\t\\t\\t// also reset the \\'compare\\' array for next iteration\\n            for (int j = 0; j < 26; j++) {\\n                freqs[j] = Math.min(freqs[j], compare[j]);\\n                compare[j] = 0;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// at this point, \\'freqs\\' contains the minimum occurrence\\n\\t\\t// frequency for each character a-z across all the Strings\\n        \\n        // construct the required List<String> answer\\n        List<String> result = new ArrayList<String>();\\n        for (int i = 0; i < 26; i++) {\\n            while (freqs[i]-- > 0) {\\n                result.add(Character.toString((char)(\\'a\\' + i)));\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251620,
                "title": "java-solution-without-hashmap-faster-than-97",
                "content": "class Solution {\\n    public List<String> commonChars(String[] A) {\\n        \\n        int[] all_dict = new int[26];\\n        List<String> result = new ArrayList<String>();\\n        for (int i = 0; i < 26; i ++) {\\n            all_dict[i] = Integer.MAX_VALUE;\\n        }\\n        for (String word: A) {\\n            int[] dict = new int[26];\\n            for (int i = 0; i < 26; i ++) {\\n                dict[i] = 0;\\n            }\\n            \\n            for (Character c: word.toCharArray()) {\\n                dict[c - \\'a\\'] ++;\\n            }\\n            for (int k = 0; k < 26; k ++) {\\n                if (dict[k] < all_dict[k]) {\\n                    all_dict[k] = dict[k];\\n                }\\n            }\\n        }\\n        for (int k = 0; k < 26; k ++) {\\n            if ((all_dict[k] != 0) && (all_dict[k] != Integer.MAX_VALUE)) {\\n                for (int i = 0; i < all_dict[k]; i ++) {\\n                    result.add(Character.toString((char)(k+\\'a\\')));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public List<String> commonChars(String[] A) {\\n        \\n        int[] all_dict = new int[26];\\n        List<String> result = new ArrayList<String>();\\n        for (int i = 0; i < 26; i ++) {\\n            all_dict[i] = Integer.MAX_VALUE;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 249508,
                "title": "js-one-pass-o-n-time-and-o-1-space",
                "content": "Please vote up\\n```\\nconst commonChars = A => {\\n    let res = [], count = Array(26).fill(1e9), size = 26, aCode = 97;\\n\\n    for (let s of A) {\\n        let cnt = Array(size).fill(0);\\n        \\n        for (let c of s) { cnt[c.charCodeAt(0) - aCode]++; }\\n        for (let i = 0; i < size; i++) { count[i] = Math.min(count[i], cnt[i]); }\\n    }\\n    \\n    for (let i = 0; i < size; i++) {\\n        while (count[i]-- > 0) {\\n            res.push(String.fromCharCode(i + aCode));\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst commonChars = A => {\\n    let res = [], count = Array(26).fill(1e9), size = 26, aCode = 97;\\n\\n    for (let s of A) {\\n        let cnt = Array(size).fill(0);\\n        \\n        for (let c of s) { cnt[c.charCodeAt(0) - aCode]++; }\\n        for (let i = 0; i < size; i++) { count[i] = Math.min(count[i], cnt[i]); }\\n    }\\n    \\n    for (let i = 0; i < size; i++) {\\n        while (count[i]-- > 0) {\\n            res.push(String.fromCharCode(i + aCode));\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3375707,
                "title": "my-solution-using-hash-table-o-n-time-and-o-1-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        return self.sol1(words)\\n\\n    def sol1(self, words):\\n        # INIT\\n\\n        # ALGO\\n\\n        #   --Build a freq graph of letters\\n        #   --Each letter has an array mapped to it containing the frequency of char in a specific word\\n        #   -- Populate the result array by checking for chars that appear in all strings \\n        #   -- The number if times to add a char is the min \\n\\n        freq_graph = {}\\n        result = []\\n\\n        for idx, word in enumerate(words):\\n            for char in word:\\n                if char not in freq_graph:\\n                    freq_graph[char] = [0] * len(words)\\n                    freq_graph[char][idx] = 1\\n                else:\\n                    freq_graph[char][idx] += 1\\n\\n\\n        for char in freq_graph:\\n            for i in range(0, min(freq_graph[char])):\\n                result.append(char)\\n\\n        return result\\n\\n        \\n\\n        \\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        return self.sol1(words)\\n\\n    def sol1(self, words):\\n        # INIT\\n\\n        # ALGO\\n\\n        #   --Build a freq graph of letters\\n        #   --Each letter has an array mapped to it containing the frequency of char in a specific word\\n        #   -- Populate the result array by checking for chars that appear in all strings \\n        #   -- The number if times to add a char is the min \\n\\n        freq_graph = {}\\n        result = []\\n\\n        for idx, word in enumerate(words):\\n            for char in word:\\n                if char not in freq_graph:\\n                    freq_graph[char] = [0] * len(words)\\n                    freq_graph[char][idx] = 1\\n                else:\\n                    freq_graph[char][idx] += 1\\n\\n\\n        for char in freq_graph:\\n            for i in range(0, min(freq_graph[char])):\\n                result.append(char)\\n\\n        return result\\n\\n        \\n\\n        \\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115294,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        common = []\\n        for c in range(len(words[0])):\\n            isCommon = True\\n            for wordIdx in range(1, len(words)):\\n                if words[0][c] not in words[wordIdx]:\\n                    isCommon = False\\n                    break\\n            if isCommon:\\n                common.append(words[0][c])\\n                for word in range(1, len(words)):\\n                    i = words[word].index(words[0][c])\\n                    words[word] = words[word][:i] + words[word][i + 1:]\\n        return common\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/604f2746-0039-49ef-9457-9ae348a1dc4a_1675026543.4825096.png)\\n![image.png](https://assets.leetcode.com/users/images/ded51de0-4748-45a8-9128-c7977b501b7a_1675026556.308422.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        common = []\\n        for c in range(len(words[0])):\\n            isCommon = True\\n            for wordIdx in range(1, len(words)):\\n                if words[0][c] not in words[wordIdx]:\\n                    isCommon = False\\n                    break\\n            if isCommon:\\n                common.append(words[0][c])\\n                for word in range(1, len(words)):\\n                    i = words[word].index(words[0][c])\\n                    words[word] = words[word][:i] + words[word][i + 1:]\\n        return common\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457090,
                "title": "simple-o-n-go-solution",
                "content": "```\\nfunc commonChars(words []string) []string {\\n    var res []string\\n    \\n    arr := make([][26]byte, len(words))\\n    \\n    for i := 0; i < len(words); i++ {\\n        for j := 0; j < len(words[i]); j++ {\\n            arr[i][words[i][j] - \\'a\\']++\\n        }\\n    }\\n    \\n    for i := 0; i < 26; i++ {\\n        isValid, count := true, 1<<63-1\\n        \\n        for j := 0; j < len(words); j++ {\\n            if arr[j][i] <= 0 {\\n                isValid = false\\n                break\\n            } else if int(arr[j][i]) < count {\\n                count = int(arr[j][i])\\n            }\\n        }\\n        \\n        if isValid {\\n            for count > 0 {\\n                res = append(res, fmt.Sprintf(\"%c\", i + \\'a\\'))\\n                count--\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc commonChars(words []string) []string {\\n    var res []string\\n    \\n    arr := make([][26]byte, len(words))\\n    \\n    for i := 0; i < len(words); i++ {\\n        for j := 0; j < len(words[i]); j++ {\\n            arr[i][words[i][j] - \\'a\\']++\\n        }\\n    }\\n    \\n    for i := 0; i < 26; i++ {\\n        isValid, count := true, 1<<63-1\\n        \\n        for j := 0; j < len(words); j++ {\\n            if arr[j][i] <= 0 {\\n                isValid = false\\n                break\\n            } else if int(arr[j][i]) < count {\\n                count = int(arr[j][i])\\n            }\\n        }\\n        \\n        if isValid {\\n            for count > 0 {\\n                res = append(res, fmt.Sprintf(\"%c\", i + \\'a\\'))\\n                count--\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366737,
                "title": "java-simple-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> strResult = new ArrayList<String>();\\n        for(int i = 0; i < words[0].length(); i++){\\n            String ch = String.valueOf(words[0].charAt(i));\\n            boolean isTrue = false;\\n            for(int j = 1; j < words.length; j++){\\n                if(words[j].contains(ch)){\\n                    words[j] = words[j].replaceFirst(ch,\"\");\\n                    isTrue = true;\\n                }else{\\n                    isTrue = false;\\n                    break;\\n                }\\n            }\\n            if(isTrue){\\n                strResult.add(ch);\\n            }\\n        }\\n        \\n        return strResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> strResult = new ArrayList<String>();\\n        for(int i = 0; i < words[0].length(); i++){\\n            String ch = String.valueOf(words[0].charAt(i));\\n            boolean isTrue = false;\\n            for(int j = 1; j < words.length; j++){\\n                if(words[j].contains(ch)){\\n                    words[j] = words[j].replaceFirst(ch,\"\");\\n                    isTrue = true;\\n                }else{\\n                    isTrue = false;\\n                    break;\\n                }\\n            }\\n            if(isTrue){\\n                strResult.add(ch);\\n            }\\n        }\\n        \\n        return strResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294440,
                "title": "simple-c-solution-using-two-arrays",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        int cnt1[26]={0};\\n        \\n        for(int i = 0; i < words.size(); i++)\\n        {\\n            int cnt2[26]={0};\\n            if(i == 0) for(char c: words[i]) cnt1[c-\\'a\\']++;\\n            else \\n            {\\n                for(char c: words[i])\\n                    cnt2[c-\\'a\\']++;\\n                for(int j = 0; j<26; j++)\\n                cnt1[j] = min(cnt1[j], cnt2[j]);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i<26; i++)\\n        {\\n            while(cnt1[i]>0)\\n            {\\n                cnt1[i]--;   \\n                ans.push_back(string(1,i+\\'a\\'));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        int cnt1[26]={0};\\n        \\n        for(int i = 0; i < words.size(); i++)\\n        {\\n            int cnt2[26]={0};\\n            if(i == 0) for(char c: words[i]) cnt1[c-\\'a\\']++;\\n            else \\n            {\\n                for(char c: words[i])\\n                    cnt2[c-\\'a\\']++;\\n                for(int j = 0; j<26; j++)\\n                cnt1[j] = min(cnt1[j], cnt2[j]);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i<26; i++)\\n        {\\n            while(cnt1[i]>0)\\n            {\\n                cnt1[i]--;   \\n                ans.push_back(string(1,i+\\'a\\'));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046065,
                "title": "vanilla-python-with-explanation",
                "content": "Probably not the fanciest solution, but gets the job done. Input constaraints are reasonable, we are not dealing with millions of words. \\n```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        example input: words = [\"bella\",\"label\",\"roller\"]\\n                output: [\"e\",\"l\",\"l\"]\\n        approach: we are only interested in letters that are in \\n                  all 3 words, therefore map only the letters in \\n                  first word like for \\'bella\\': \\n          fill the array of len(words) size with zeros, and \\n          account for first occurence with proper count: for \\n          \\'bella\\' and 3 words this would look like \\n                  b: [1, 0, 0]\\n                  e: [1, 0, 0]\\n                  l: [2, 0, 0] there are 2 \\'l\\'s\\n                  a: [1, 0 ,0]\\n      \"\"\"\\n      \\n        firstWordMap = {}\\n        for letter in words[0]:\\n            if letter not in firstWordMap:\\n                firstWordMap[letter] = [0] * len(words)\\n                firstWordMap[letter][0] = 1\\n            else:\\n                firstWordMap[letter][0] += 1\\n        \\'\\'\\'\\n        from index 1-len(words), sum up only the letters that show up in that first OG word \\n\\t\\tand  place the count in the correct index in hash map value for that letter\\n        \\'\\'\\'\\n        for i in range(1, len(words)):\\n            curr = words[i]\\n            for letter in curr:\\n                if letter in firstWordMap:\\n                    firstWordMap[letter][i] += 1\\n        \\n        result = []\\n        \\'\\'\\'\\n          iterate over key, value pairs \\n          append each letter min times it shows up in all words\\n          this will append letters with 0 occurrences 0 times, \\n          which handles the scenario where a letter in that first\\n          word does not show up in other words\\n          so for a map like this:\\n        {\\'a\\': [1, 1, 0], means \\'a\\' shows up in first and second word but NOT in third\\n         \\'b\\': [1, 1, 0], same as above\\n         \\'e\\': [1, 1, 1], means \\'e\\' shows up once in all 3 words\\n         \\'l\\': [2, 2, 2]  means \\'l\\' shows up twice in all 3 words\\n        }\\n        result will correctly contain one \\'e\\' and two \\'l\\'s\\n        \\'\\'\\'\\n        for letter, occurences in firstWordMap.items():\\n            for i in range(min(occurences)):\\n                result.append(letter)\\n        return result\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        example input: words = [\"bella\",\"label\",\"roller\"]\\n                output: [\"e\",\"l\",\"l\"]\\n        approach: we are only interested in letters that are in \\n                  all 3 words, therefore map only the letters in \\n                  first word like for \\'bella\\': \\n          fill the array of len(words) size with zeros, and \\n          account for first occurence with proper count: for \\n          \\'bella\\' and 3 words this would look like \\n                  b: [1, 0, 0]\\n                  e: [1, 0, 0]\\n                  l: [2, 0, 0] there are 2 \\'l\\'s\\n                  a: [1, 0 ,0]\\n      \"\"\"\\n      \\n        firstWordMap = {}",
                "codeTag": "Java"
            },
            {
                "id": 1793520,
                "title": "easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    string common(string a, string b){ //gives us common characters between two strings\\n        string ans=\"\";\\n        map<char,int> m;\\n        for(int i=0;i<a.length();i++) m[a[i]]++;\\n        for(int i=0;i<b.length();i++){\\n            if(m.find(b[i])!=m.end() && m[b[i]]>0) {\\n                ans+=b[i];\\n                m[b[i]]--;}\\n            \\n        }\\n        return ans;\\n    }\\n\\n    vector<string> commonChars(vector<string>& words) {\\n        string fans=words[0]; //fans=final answer\\n        for(int i=0;i<words.size();i++){\\n            string ans=common(fans,words[i]);\\n            fans=ans;\\n        }\\n        vector<string> res;\\n        for(int i=0;i<fans.length();i++){\\n            string s(1, fans[i]); //converting each character of fans to string\\n            res.push_back(s);\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    string common(string a, string b){ //gives us common characters between two strings\\n        string ans=\"\";\\n        map<char,int> m;\\n        for(int i=0;i<a.length();i++) m[a[i]]++;\\n        for(int i=0;i<b.length();i++){\\n            if(m.find(b[i])!=m.end() && m[b[i]]>0) {\\n                ans+=b[i];\\n                m[b[i]]--;}\\n            \\n        }\\n        return ans;\\n    }\\n\\n    vector<string> commonChars(vector<string>& words) {\\n        string fans=words[0]; //fans=final answer\\n        for(int i=0;i<words.size();i++){\\n            string ans=common(fans,words[i]);\\n            fans=ans;\\n        }\\n        vector<string> res;\\n        for(int i=0;i<fans.length();i++){\\n            string s(1, fans[i]); //converting each character of fans to string\\n            res.push_back(s);\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738597,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n       String str = words[0];\\n        List<String> list = new ArrayList<>();\\n        for(int i = 0; i < str.length(); i++)\\n        {\\n            char ch = str.charAt(i);\\n            int count = 1;\\n            for(int j = 1; j < words.length; j++)\\n            {\\n                String s = words[j];\\n                for(int k = 0; k < s.length(); k++)\\n                {\\n                    char c = s.charAt(k);\\n                    if(c == ch)\\n                    {\\n                        StringBuilder sb = new StringBuilder(s);\\n                        sb.setCharAt(k, \\'1\\');\\n                        words[j] = sb.toString();\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(count == words.length)\\n            {\\n                list.add(ch+\"\");\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n       String str = words[0];\\n        List<String> list = new ArrayList<>();\\n        for(int i = 0; i < str.length(); i++)\\n        {\\n            char ch = str.charAt(i);\\n            int count = 1;\\n            for(int j = 1; j < words.length; j++)\\n            {\\n                String s = words[j];\\n                for(int k = 0; k < s.length(); k++)\\n                {\\n                    char c = s.charAt(k);\\n                    if(c == ch)\\n                    {\\n                        StringBuilder sb = new StringBuilder(s);\\n                        sb.setCharAt(k, \\'1\\');\\n                        words[j] = sb.toString();\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(count == words.length)\\n            {\\n                list.add(ch+\"\");\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410231,
                "title": "python-faster-than-98",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if len(words) == 0:\\n            return\\n        \\n        ref = words[0] # reference word to compare to rest of list\\n        ret = []\\n            \\n        for char in ref:\\n            valid = True\\n            for i in range(1, len(words)):\\n                # break if word does not contain this char\\n                if not char in words[i]:\\n                    valid = False\\n                    break\\n                else:\\n                    # replace first occurrence of char with blank (allow duplicates)\\n                    words[i] = words[i].replace(char, \"\", 1)\\n            if valid:\\n                ret.append(char)\\n                    \\n        return ret\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if len(words) == 0:\\n            return\\n        \\n        ref = words[0] # reference word to compare to rest of list\\n        ret = []\\n            \\n        for char in ref:\\n            valid = True\\n            for i in range(1, len(words)):\\n                # break if word does not contain this char\\n                if not char in words[i]:\\n                    valid = False\\n                    break\\n                else:\\n                    # replace first occurrence of char with blank (allow duplicates)\\n                    words[i] = words[i].replace(char, \"\", 1)\\n            if valid:\\n                ret.append(char)\\n                    \\n        return ret\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1310060,
                "title": "o-n-2-solution-python3",
                "content": "**I know it\\'s pretty immature approach but helpful for beginners.**\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return list(*words)\\n        output=[]\\n        for i in words[0]:\\n            temp=0\\n            for j,k in enumerate(words[1:]):\\n                if i in k:\\n                    words[j+1]=k.replace(i,\"_\",1)\\n                    temp+=1\\n            if temp==len(words)-1:\\n                output.append(i)\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return list(*words)\\n        output=[]\\n        for i in words[0]:\\n            temp=0\\n            for j,k in enumerate(words[1:]):\\n                if i in k:\\n                    words[j+1]=k.replace(i,\"_\",1)\\n                    temp+=1\\n            if temp==len(words)-1:\\n                output.append(i)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283213,
                "title": "c-easy-to-understand-using-vectors-clean-code",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string> A){\\n       vector<int> main(26,0);\\n       vector<int> temp(26,0);\\n       for(int i=0;i<A[0].length();i++)\\n       {\\n           main[A[0][i]-\\'a\\']++;\\n       }\\n       for(int i=1;i<A.size();i++)\\n       {\\n           for(int j=0;j<A[i].length();j++)\\n           {\\n               temp[A[i][j]-\\'a\\']++;\\n           }\\n           for(int j=0;j<26;j++)\\n           {\\n               main[j]=min(main[j],temp[j]);\\n               temp[j]=0;\\n           }\\n       }\\n        vector<string> ans;\\n       for(int i=0;i<26;i++)\\n       {\\n           if(main[i]>0)\\n           {\\n               while(main[i]--)\\n               {\\n                   string str=\"\";\\n                   str.append(1,(char)(i+97));\\n                   ans.push_back(str);\\n               }\\n           }\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> commonChars(vector<string> A){\\n       vector<int> main(26,0);\\n       vector<int> temp(26,0);\\n       for(int i=0;i<A[0].length();i++)\\n       {\\n           main[A[0][i]-\\'a\\']++;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1150217,
                "title": "python3-simple-and-readable-solution",
                "content": "**Runtime Beats 98% of Python3 Sumbissions**\\n```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        arr = []\\n        for i in set(A[0]):\\n            ans = [A[0].count(i)]\\n            for j in A[1:]:\\n                if(i in j):\\n                    ans.append(j.count(i))\\n            if(len(ans) == len(A)):\\n                arr += ([i] * min(ans))\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        arr = []\\n        for i in set(A[0]):\\n            ans = [A[0].count(i)]\\n            for j in A[1:]:\\n                if(i in j):\\n                    ans.append(j.count(i))\\n            if(len(ans) == len(A)):\\n                arr += ([i] * min(ans))\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108075,
                "title": "c-solution-constant-size-frequency-table",
                "content": "Because all of the frequency tables will be compared at the end to produce one set of counters with the minimum for each character, we could easily do with only two frequency tables. When building a frequency table for a string, we can merge it into the final frequency table as soon as we\\'re done counting. Afterward, we just allocate the prescribed amount of strings and return the resulting array.\\n\\n```\\nvoid calculateHistorgram(unsigned char finalFreq[26], char ** A, int ASize){\\n    unsigned char tempFreq[26];\\n    char * strPtr;\\n    int i, j;\\n    \\n    for(strPtr = A[0]; *strPtr != \\'\\\\0\\'; ++strPtr)\\n        ++finalFreq[*strPtr - \\'a\\'];\\n    \\n    for(i = 1; i < ASize; ++i){\\n        memset(tempFreq, 0, sizeof(tempFreq));\\n        \\n        for(strPtr = A[i]; *strPtr != \\'\\\\0\\'; ++strPtr)\\n            ++tempFreq[*strPtr - \\'a\\'];\\n        \\n        for(j = 0; j < 26; ++j){\\n            if(tempFreq[j] < finalFreq[j])\\n                finalFreq[j] = tempFreq[j];\\n        }\\n    }\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** commonChars(char ** A, int ASize, int* returnSize){\\n    unsigned char freq[26] = {0};\\n    char ** output;\\n    int i, j, ctr;\\n    int outputSize = 0;\\n    \\n    calculateHistorgram(freq, A, ASize);\\n    \\n    for(i = 0; i < 26; ++i)\\n        outputSize += freq[i];\\n    \\n    output = malloc(outputSize * sizeof(char *));\\n    \\n    for(i = 0, j = 0; i < 26; ++i){\\n        for(ctr = freq[i]; ctr-- > 0; ++j){\\n            output[j] = malloc(2 * sizeof(char));\\n            output[j][0] = \\'a\\' + i;\\n            output[j][1] = \\'\\\\0\\';\\n        }\\n    }\\n    \\n    *returnSize = outputSize;\\n    \\n    return output;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "Because all of the frequency tables will be compared at the end to produce one set of counters with the minimum for each character, we could easily do with only two frequency tables. When building a frequency table for a string, we can merge it into the final frequency table as soon as we\\'re done counting. Afterward, we just allocate the prescribed amount of strings and return the resulting array.\\n\\n```\\nvoid calculateHistorgram(unsigned char finalFreq[26], char ** A, int ASize){\\n    unsigned char tempFreq[26];\\n    char * strPtr;\\n    int i, j;\\n    \\n    for(strPtr = A[0]; *strPtr != \\'\\\\0\\'; ++strPtr)\\n        ++finalFreq[*strPtr - \\'a\\'];\\n    \\n    for(i = 1; i < ASize; ++i){\\n        memset(tempFreq, 0, sizeof(tempFreq));\\n        \\n        for(strPtr = A[i]; *strPtr != \\'\\\\0\\'; ++strPtr)\\n            ++tempFreq[*strPtr - \\'a\\'];\\n        \\n        for(j = 0; j < 26; ++j){\\n            if(tempFreq[j] < finalFreq[j])\\n                finalFreq[j] = tempFreq[j];\\n        }\\n    }\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** commonChars(char ** A, int ASize, int* returnSize){\\n    unsigned char freq[26] = {0};\\n    char ** output;\\n    int i, j, ctr;\\n    int outputSize = 0;\\n    \\n    calculateHistorgram(freq, A, ASize);\\n    \\n    for(i = 0; i < 26; ++i)\\n        outputSize += freq[i];\\n    \\n    output = malloc(outputSize * sizeof(char *));\\n    \\n    for(i = 0, j = 0; i < 26; ++i){\\n        for(ctr = freq[i]; ctr-- > 0; ++j){\\n            output[j] = malloc(2 * sizeof(char));\\n            output[j][0] = \\'a\\' + i;\\n            output[j][1] = \\'\\\\0\\';\\n        }\\n    }\\n    \\n    *returnSize = outputSize;\\n    \\n    return output;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1019213,
                "title": "java-constant-space-straightforward-explanation",
                "content": "Key Idea:\\n- Take first string into account as that\\'s the bare minimum required to return *something*. Have a hashmap that stores each character\\'s total occurrences. (`charFreq`)\\n- Loop through other strings:\\n\\t- For each string, have a hashmap to store each character\\'s occurrences. (`currCharFreq`)\\n\\t- Find the minimum of occurrences between `currCharFreq` and `charFreq` for each character => and store in `charFreq`. (again bare minimum is needed)\\n- At the end, you will be left with **non-zero** occurrences implying the common characters in total.\\n\\n**Time Complexity:** `O(N * M)`, where `N` - A.length (total number of strings) and `M` - the number of characters in the longest string.\\n**Space Complexity** `O(1)`, excluding the return list space.\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        List<String> list = new ArrayList<>();\\n        int n = A.length;\\n        int[] charFreq = new int[26];\\n        \\n\\t\\tfor(char c : A[0].toCharArray())\\n            charFreq[c - \\'a\\']++;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int[] currCharFreq = new int[26];\\n\\t\\t\\t\\n            for(Character c : A[i].toCharArray())\\n\\t\\t\\t\\tcurrCharFreq[c - \\'a\\']++;\\n            \\n\\t\\t\\tfor(int k = 0; k < 26; k++)\\n\\t\\t\\t\\tcharFreq[k] = Math.min(currCharFreq[k], charFreq[k]); \\n        }\\n        \\n\\t\\tfor(int i = 0; i < 26; i++)\\n            while(charFreq[i]-- > 0)\\n                list.add(Character.toString(i + \\'a\\')); //add only those that have frequency count > 0. If none, then return empty list.\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        List<String> list = new ArrayList<>();\\n        int n = A.length;\\n        int[] charFreq = new int[26];\\n        \\n\\t\\tfor(char c : A[0].toCharArray())\\n            charFreq[c - \\'a\\']++;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int[] currCharFreq = new int[26];\\n\\t\\t\\t\\n            for(Character c : A[i].toCharArray())\\n\\t\\t\\t\\tcurrCharFreq[c - \\'a\\']++;\\n            \\n\\t\\t\\tfor(int k = 0; k < 26; k++)\\n\\t\\t\\t\\tcharFreq[k] = Math.min(currCharFreq[k], charFreq[k]); \\n        }\\n        \\n\\t\\tfor(int i = 0; i < 26; i++)\\n            while(charFreq[i]-- > 0)\\n                list.add(Character.toString(i + \\'a\\')); //add only those that have frequency count > 0. If none, then return empty list.\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015608,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return None\\n        \\n        count = Counter(A[0])            \\n        for word in A[1:]:\\n            count &= Counter(word)\\n                    \\n        result = []\\n        for x in count:\\n            result += [x] * count[x]\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return None\\n        \\n        count = Counter(A[0])            \\n        for word in A[1:]:\\n            count &= Counter(word)\\n                    \\n        result = []\\n        for x in count:\\n            result += [x] * count[x]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010839,
                "title": "python-solution",
                "content": "```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return None\\n        else:\\n            freq = Counter(A[0])\\n            for i in range(1, len(A)):\\n                for key in freq:\\n                    freq[key] = min(freq[key],A[i].count(key))\\n            return freq.elements()  \\n```\\n\\nWould really appreciate your feedback on how to fasten my code.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return None\\n        else:\\n            freq = Counter(A[0])\\n            for i in range(1, len(A)):\\n                for key in freq:\\n                    freq[key] = min(freq[key],A[i].count(key))\\n            return freq.elements()  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 898947,
                "title": "python-3-detailed-explanation-including-assumptions-missed-in-the-question-itself",
                "content": "**Idea**:\\nFirst, you need to make sure that all elements of the same length. Currently nothing states that this is a case. Thus, we will assume otherwise and will do sorting. Your result cannot have letters that are **not** present in the shortest word.\\nSecond, we will count characters\\' frequencies in the shortest word and save them in ```d_shortest```.\\nThen we will iterate over all other words. \\nThe trick is the following. You need to make sure that\\n1. you are looking at a character that is present in ```d_shortest```\\n2. and after that you need to update the respective character\\'s value by choosing between the current value and the number of times this character occurs in a current word\\n\\n\\nThird, after updating you dictionary, you need to build an answer. \\nIterate over the dictionaries\\' keys and values and, if the value ```>=1``` (means that this character is present in all words), append the character whatever many times its key tells you.\\n\\n```\\nfrom collections import Counter\\ndef commonChars(A):\\n    res = []\\n    A.sort(key = lambda x: len(x))\\n    d_shortest = Counter(A[0])\\n    for word in A[1:]:\\n        for k in d_shortest:\\n            d_shortest[k] = min(d_shortest[k], word.count(k))\\n    for k, v in d_shortest.items():\\n        if v >= 1:\\n            for _ in range(v):\\n                res.append(k)\\n    return res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```d_shortest```\n```d_shortest```\n```>=1```\n```\\nfrom collections import Counter\\ndef commonChars(A):\\n    res = []\\n    A.sort(key = lambda x: len(x))\\n    d_shortest = Counter(A[0])\\n    for word in A[1:]:\\n        for k in d_shortest:\\n            d_shortest[k] = min(d_shortest[k], word.count(k))\\n    for k, v in d_shortest.items():\\n        if v >= 1:\\n            for _ in range(v):\\n                res.append(k)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 834680,
                "title": "ultimate-use-of-dictionaries-in-python",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        m = collections.defaultdict(lambda:[0]*len(A))\\n        for i in range(len(A)):\\n            for char in A[i]:\\n                if char not in m:\\n                    m[char][i] = 1\\n                else:\\n                    m[char][i] += 1\\n        res = []\\n        for key,values in m.items():\\n            value = min(values)\\n            if value != 0:\\n                res.extend(key*value)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        m = collections.defaultdict(lambda:[0]*len(A))\\n        for i in range(len(A)):\\n            for char in A[i]:\\n                if char not in m:\\n                    m[char][i] = 1\\n                else:\\n                    m[char][i] += 1\\n        res = []\\n        for key,values in m.items():\\n            value = min(values)\\n            if value != 0:\\n                res.extend(key*value)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790529,
                "title": "python-simple",
                "content": "Slightly modified version of https://leetcode.com/problems/find-common-characters/discuss/247560/Python-1-Line\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        res = Counter(A[0])\\n        \\n        for a in A:\\n            res &= Counter(a)\\n        \\n        return res.elements()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        res = Counter(A[0])\\n        \\n        for a in A:\\n            res &= Counter(a)\\n        \\n        return res.elements()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786157,
                "title": "python-3-using-set-count",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A):\\n        \"\"\"\\n        Given a list of strings consisting of lowercase letters,\\n        this program determines the list of common letters,\\n        including frequencies, among all the strings.\\n\\n        :param A: list of strings made up of only lowercase letters\\n        :type A: list[str]\\n        :return: list of common letters among all strings in A\\n        :rtype: list[str]\\n        \"\"\"\\n        \\n        \"\"\"\\n        Get the set of letters that are common to all strings in A.\\n        \"\"\"\\n        set_A = set(A[0])\\n        for a in A[1:]:\\n            set_A = set_A.intersection(a)\\n        \\n        \"\"\"\\n        For each common letter, determine its frequency that is\\n        common to all strings in A. Capture the common letters\\n        and their frequencies in common_letters and return\\n        common_letters to the caller.\\n        \"\"\"\\n        common_letters = []\\n        for letter in set_A:\\n            count = 101\\n            for a in A:\\n                count = min(count, a.count(letter))\\n            common_letters += [letter] * count\\n        return common_letters\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A):\\n        \"\"\"\\n        Given a list of strings consisting of lowercase letters,\\n        this program determines the list of common letters,\\n        including frequencies, among all the strings.\\n\\n        :param A: list of strings made up of only lowercase letters\\n        :type A: list[str]\\n        :return: list of common letters among all strings in A\\n        :rtype: list[str]\\n        \"\"\"\\n        \\n        \"\"\"\\n        Get the set of letters that are common to all strings in A.\\n        \"\"\"\\n        set_A = set(A[0])\\n        for a in A[1:]:\\n            set_A = set_A.intersection(a)\\n        \\n        \"\"\"\\n        For each common letter, determine its frequency that is\\n        common to all strings in A. Capture the common letters\\n        and their frequencies in common_letters and return\\n        common_letters to the caller.\\n        \"\"\"\\n        common_letters = []\\n        for letter in set_A:\\n            count = 101\\n            for a in A:\\n                count = min(count, a.count(letter))\\n            common_letters += [letter] * count\\n        return common_letters\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776863,
                "title": "javascript-99-faster-easy-to-read-and-understand",
                "content": "Loop through the first word, since the matching letters have to be in every word.\\n\\n```\\nvar commonChars = function(A) {\\n    let res = [];\\n    \\n    // Set number of loops outside of function\\n    // Since we modify A[0]\\n    let loops = A[0].length;\\n    \\n    for (let i = 0; i < loops; i++) {\\n        let letter = A[0][i];\\n        \\n        if (letter === undefined) return res;\\n\\n        if (A.every(word => word.indexOf(letter) !== -1 )) {\\n            // Every word in array has letter\\n            res.push(letter);\\n            \\n            // Remove the matched letter from the words\\n            A = A.map(word => word.replace(letter, \\'\\'));\\n            \\n            // Reset i since we replaced the current letter\\n            i--;\\n        }\\n    }\\n    \\n    return res;\\n};\\n```\\n\\nStats:\\nRuntime: 68 ms, faster than 99.77% of JavaScript online submissions for Find Common Characters.\\nMemory Usage: 38.6 MB, less than 84.51% of JavaScript online submissions for Find Common Characters.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar commonChars = function(A) {\\n    let res = [];\\n    \\n    // Set number of loops outside of function\\n    // Since we modify A[0]\\n    let loops = A[0].length;\\n    \\n    for (let i = 0; i < loops; i++) {\\n        let letter = A[0][i];\\n        \\n        if (letter === undefined) return res;\\n\\n        if (A.every(word => word.indexOf(letter) !== -1 )) {\\n            // Every word in array has letter\\n            res.push(letter);\\n            \\n            // Remove the matched letter from the words\\n            A = A.map(word => word.replace(letter, \\'\\'));\\n            \\n            // Reset i since we replaced the current letter\\n            i--;\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636527,
                "title": "java-simple-and-easy-to-understand",
                "content": "```\\npublic List<String> commonChars(String[] A) {\\n             \\n        List<String> result = new ArrayList<>();\\n               \\n        for(Character c: A[0].toCharArray()) {\\n            \\n            boolean exists = true;\\n            for(int i =1; i <A.length; i++) {\\n                if(A[i].indexOf(c+\"\") == -1) {\\n                    exists = false;\\n                    break;\\n                } else {\\n                    A[i] = A[i].replaceFirst(c+\"\",\"\");\\n                }\\n            }\\n            \\n            if(exists) \\n                result.add(c + \"\");\\n            \\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> commonChars(String[] A) {\\n             \\n        List<String> result = new ArrayList<>();\\n               \\n        for(Character c: A[0].toCharArray()) {\\n            \\n            boolean exists = true;\\n            for(int i =1; i <A.length; i++) {\\n                if(A[i].indexOf(c+\"\") == -1) {\\n                    exists = false;\\n                    break;\\n                } else {\\n                    A[i] = A[i].replaceFirst(c+\"\",\"\");\\n                }\\n            }\\n            \\n            if(exists) \\n                result.add(c + \"\");\\n            \\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607334,
                "title": "python-simple-and-clean-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        from collections import Counter\\n        \\n        overlap = Counter(A[0])\\n        for i in range(1, len(A)):\\n            overlap = overlap & Counter(A[i])\\n            \\n        res = []    \\n        for key, value in overlap.items():\\n            res.extend(list(key)*value)\\n            \\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        from collections import Counter\\n        \\n        overlap = Counter(A[0])\\n        for i in range(1, len(A)):\\n            overlap = overlap & Counter(A[i])\\n            \\n        res = []    \\n        for key, value in overlap.items():\\n            res.extend(list(key)*value)\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 537979,
                "title": "java-use-hashmap",
                "content": "```\\npublic List<String> commonChars(String[] A) {\\n        int[] res = new int[26];\\n        Arrays.fill(res, Integer.MAX_VALUE);\\n        for (String s : A) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (char c : s.toCharArray()) {\\n                map.put(c - \\'a\\', map.getOrDefault(c - \\'a\\', 0) + 1);\\n            }\\n            for (int i = 0; i < 26; i++) {\\n                res[i] = Math.min(res[i], map.getOrDefault(i, 0));\\n            }\\n        }\\n        List<String> ret = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            while (res[i] > 0) {\\n                ret.add(String.valueOf((char) (i + \\'a\\')));\\n                res[i]--;\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> commonChars(String[] A) {\\n        int[] res = new int[26];\\n        Arrays.fill(res, Integer.MAX_VALUE);\\n        for (String s : A) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (char c : s.toCharArray()) {\\n                map.put(c - \\'a\\', map.getOrDefault(c - \\'a\\', 0) + 1);\\n            }\\n            for (int i = 0; i < 26; i++) {\\n                res[i] = Math.min(res[i], map.getOrDefault(i, 0));\\n            }\\n        }\\n        List<String> ret = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            while (res[i] > 0) {\\n                ret.add(String.valueOf((char) (i + \\'a\\')));\\n                res[i]--;\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528098,
                "title": "javascript",
                "content": "```\\nvar commonChars = function(A) {\\n    let common = A[0].split(\\'\\').filter(char => {\\n        for (var i = 1; i < A.length; i++) {\\n            if (!A[i].includes(char)) return false;\\n            else {\\n                A[i] = A[i].replace(char, \\'\\')\\n            }\\n        }\\n        return true;\\n    })\\n\\treturn common\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar commonChars = function(A) {\\n    let common = A[0].split(\\'\\').filter(char => {\\n        for (var i = 1; i < A.length; i++) {\\n            if (!A[i].includes(char)) return false;\\n            else {\\n                A[i] = A[i].replace(char, \\'\\')\\n            }\\n        }\\n        return true;\\n    })\\n\\treturn common\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454371,
                "title": "python-dictionary-beat-96-time-and-100-space",
                "content": "![image](https://assets.leetcode.com/users/jefferyzzy/image_1576619610.png)\\n```\\nimport collections\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dict = collections.Counter(A[0])\\n        for i in range(1, len(A)):\\n            del_keys = []\\n            for k, v in dict.items():\\n                if k in A[i]:\\n                    dict[k] = min(A[i].count(k), v)\\n                else:\\n                    del_keys.append(k)\\n            for key in del_keys:\\n                del dict[key]\\n        return list(dict.elements())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dict = collections.Counter(A[0])\\n        for i in range(1, len(A)):\\n            del_keys = []\\n            for k, v in dict.items():\\n                if k in A[i]:\\n                    dict[k] = min(A[i].count(k), v)\\n                else:\\n                    del_keys.append(k)\\n            for key in del_keys:\\n                del dict[key]\\n        return list(dict.elements())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435957,
                "title": "java-short-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        Map<Character, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int k = 0; k < A.length; k++) {\\n            String s = A[k];\\n            for (int i = 0; i < s.length(); i++) {\\n                Map<Integer, Integer> set = map.getOrDefault(s.charAt(i), new HashMap<>());\\n                set.put(k, set.getOrDefault(k, 0) + 1);\\n                map.put(s.charAt(i), set);\\n            }\\n        }\\n        List<String> result = new ArrayList<>();\\n        for (Character c : map.keySet()) {\\n            if (map.get(c).size() < A.length) {\\n                continue;\\n            }\\n            int cnt = Integer.MAX_VALUE;\\n            for (Map.Entry<Integer, Integer> e : map.get(c).entrySet()) {\\n                cnt = Math.min(e.getValue(), cnt);\\n            }\\n            for (int i = 0; i < cnt; i++) {\\n                result.add(\"\"+c);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        Map<Character, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int k = 0; k < A.length; k++) {\\n            String s = A[k];\\n            for (int i = 0; i < s.length(); i++) {\\n                Map<Integer, Integer> set = map.getOrDefault(s.charAt(i), new HashMap<>());\\n                set.put(k, set.getOrDefault(k, 0) + 1);\\n                map.put(s.charAt(i), set);\\n            }\\n        }\\n        List<String> result = new ArrayList<>();\\n        for (Character c : map.keySet()) {\\n            if (map.get(c).size() < A.length) {\\n                continue;\\n            }\\n            int cnt = Integer.MAX_VALUE;\\n            for (Map.Entry<Integer, Integer> e : map.get(c).entrySet()) {\\n                cnt = Math.min(e.getValue(), cnt);\\n            }\\n            for (int i = 0; i < cnt; i++) {\\n                result.add(\"\"+c);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395860,
                "title": "python-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        \"\"\"\\n        A Counter is a dict subclass for counting hashable objects. \\n        It is an unordered collection where elements are stored as dictionary keys \\n        and their counts are stored as dictionary values.\\n        \"\"\"\\n        c=Counter(A[0])\\n        for i in range(1,len(A)):\\n            c&=Counter(A[i]) # concept borrowed from [rachit\\'s solution](https://leetcode.com/problems/find-common-characters/discuss/394501/Python-Simple-Solution)\\n            \"\"\"\\n            elements() Return an iterator over elements repeating each as many times \\n            as its count. Elements are returned in arbitrary order. If an element\\u2019s \\n            count is less than one, elements() will ignore it.\\n            \"\"\"\\n        return c.elements()\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        \"\"\"\\n        A Counter is a dict subclass for counting hashable objects. \\n        It is an unordered collection where elements are stored as dictionary keys \\n        and their counts are stored as dictionary values.\\n        \"\"\"\\n        c=Counter(A[0])\\n        for i in range(1,len(A)):\\n            c&=Counter(A[i]) # concept borrowed from [rachit\\'s solution](https://leetcode.com/problems/find-common-characters/discuss/394501/Python-Simple-Solution)\\n            \"\"\"\\n            elements() Return an iterator over elements repeating each as many times \\n            as its count. Elements are returned in arbitrary order. If an element\\u2019s \\n            count is less than one, elements() will ignore it.\\n            \"\"\"\\n        return c.elements()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356723,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        \\n        # Add first word in list \\n        prev_word = [char for char in A[0]]\\n        \\n        \\n        # Loop through the list starting from second item since we already marked the first above \\n        for word in A[1:]:\\n            current_word = []\\n            for char in word:\\n                if char in prev_word:\\n                    # If the current word we are iterating over is in the prev_word then append to the current_word list\\n                    current_word.append(char)\\n                    # Need to remove the just visited char otherwise we will keep adding it to our current_word list \\n                    prev_word.remove(char)\\n            \\n            prev_word = current_word\\n            \\n        return prev_word\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        \\n        # Add first word in list \\n        prev_word = [char for char in A[0]]\\n        \\n        \\n        # Loop through the list starting from second item since we already marked the first above \\n        for word in A[1:]:\\n            current_word = []\\n            for char in word:\\n                if char in prev_word:\\n                    # If the current word we are iterating over is in the prev_word then append to the current_word list\\n                    current_word.append(char)\\n                    # Need to remove the just visited char otherwise we will keep adding it to our current_word list \\n                    prev_word.remove(char)\\n            \\n            prev_word = current_word\\n            \\n        return prev_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332716,
                "title": "very-easy-to-understand-python-solution",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if A:\\n            t = list(A.pop())\\n            n = []\\n            while A:\\n                s = A.pop()\\n                for val in s:\\n                    if val in t:\\n                        t.remove(val)\\n                        n.append(val)\\n                t = n\\n                n = []\\n        return t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if A:\\n            t = list(A.pop())\\n            n = []\\n            while A:\\n                s = A.pop()\\n                for val in s:\\n                    if val in t:\\n                        t.remove(val)\\n                        n.append(val)\\n                t = n\\n                n = []\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288671,
                "title": "swift-3-line-solution",
                "content": "```\\nclass Solution {\\n    func commonChars(_ A: [String]) -> [String] {\\n        let chars = A.map { Set($0) }.reduce(Set(A.first!)) { $0.intersection($1) }\\n        let counts = Dictionary(A.flatMap { Dictionary($0.compactMap { chars.contains($0) ? ($0,1) : nil }, uniquingKeysWith:+) }, uniquingKeysWith:min)\\n        return counts.flatMap { Array(repeating:String($0.0), count:$0.1) }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func commonChars(_ A: [String]) -> [String] {\\n        let chars = A.map { Set($0) }.reduce(Set(A.first!)) { $0.intersection($1) }\\n        let counts = Dictionary(A.flatMap { Dictionary($0.compactMap { chars.contains($0) ? ($0,1) : nil }, uniquingKeysWith:+) }, uniquingKeysWith:min)\\n        return counts.flatMap { Array(repeating:String($0.0), count:$0.1) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285824,
                "title": "go-o-n-solution-beat-100",
                "content": "```go\\nfunc commonChars(A []string) []string {\\n\\tres := []string{}\\n\\tfor i := range A[0] {\\n\\t\\tcurrentString := A[0][i : i+1]\\n\\t\\tfind := true\\n\\t\\tfor j := 1; j < len(A); j++ {\\n\\t\\t\\tif strings.Index(A[j], currentString) == -1 {\\n\\t\\t\\t\\tfind = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif find  {\\n\\t\\t\\t// \\u6D88\\u8017\\u4E00\\u4E2A\\n\\t\\t\\tres = append(res, currentString)\\n\\n\\t\\t\\tfor j := 1; j < len(A); j++ {\\n\\t\\t\\t\\tcurrentStringIndex := strings.Index(A[j], currentString)\\n\\t\\t\\t\\tA[j] = A[j][:currentStringIndex] + A[j][currentStringIndex+1:]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc commonChars(A []string) []string {\\n\\tres := []string{}\\n\\tfor i := range A[0] {\\n\\t\\tcurrentString := A[0][i : i+1]\\n\\t\\tfind := true\\n\\t\\tfor j := 1; j < len(A); j++ {\\n\\t\\t\\tif strings.Index(A[j], currentString) == -1 {\\n\\t\\t\\t\\tfind = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif find  {\\n\\t\\t\\t// \\u6D88\\u8017\\u4E00\\u4E2A\\n\\t\\t\\tres = append(res, currentString)\\n\\n\\t\\t\\tfor j := 1; j < len(A); j++ {\\n\\t\\t\\t\\tcurrentStringIndex := strings.Index(A[j], currentString)\\n\\t\\t\\t\\tA[j] = A[j][:currentStringIndex] + A[j][currentStringIndex+1:]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267593,
                "title": "clean-python",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        my_list, res = [], []\\n        for v in A:\\n            my_list.append(Counter(v))\\n        for key in my_list[0]:\\n            times = my_list[0][key]\\n            for e in my_list[1:]:\\n                times = min(times, e[key])\\n            for _ in range(times):\\n                res.append(key)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        my_list, res = [], []\\n        for v in A:\\n            my_list.append(Counter(v))\\n        for key in my_list[0]:\\n            times = my_list[0][key]\\n            for e in my_list[1:]:\\n                times = min(times, e[key])\\n            for _ in range(times):\\n                res.append(key)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259572,
                "title": "python-solution-runtime-beats-98-39-memory-beats-100",
                "content": "\\tdef commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return []\\n\\n        concat = set(\\'\\'.join(A))\\n        repeats = []\\n        for char in concat:\\n            occurance = min([x.count(char) for x in A])\\n            repeats += [char]*occurance\\n        return repeats\\n\\t",
                "solutionTags": [],
                "code": "\\tdef commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return []\\n\\n        concat = set(\\'\\'.join(A))\\n        repeats = []\\n        for char in concat:\\n            occurance = min([x.count(char) for x in A])\\n            repeats += [char]*occurance\\n        return repeats\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 255465,
                "title": "simple-python3-code",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        l=[]\\n        for i in \"abcdefghijklmnopqrstuvwxyz\":\\n            l=l+[i]*min(list(map(lambda x:x.count(i),A)))\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        l=[]\\n        for i in \"abcdefghijklmnopqrstuvwxyz\":\\n            l=l+[i]*min(list(map(lambda x:x.count(i),A)))\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247552,
                "title": "simple-python-version",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        ans = []\\n        d1 = Counter(A[0])\\n        for i in range(1,len(A)):\\n            d2 = Counter(A[i])\\n            d1 = d1 & d2\\n        ans = list(d1.elements())\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        ans = []\\n        d1 = Counter(A[0])\\n        for i in range(1,len(A)):\\n            d2 = Counter(A[i])\\n            d1 = d1 & d2\\n        ans = list(d1.elements())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020449,
                "title": "c-code-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        //to store the count of common element\\n        vector<int>common(26,INT_MAX);\\n        //to stroe the result\\n        vector<string>res;\\n        for(auto s :words){\\n            //to stroe the count of each element\\n            vector<int>count(26,0);\\n            //to count the frequency\\n            for(auto c:s) count[c-\\'a\\']++;\\n            // to store the min count of elements \\n            //as we find the common elements in each string\\n            //so we need to stroe the min freq of them\\n            //eg [\"cool\",\"lock\",\"cook\"] \\n            //in cool count of l -1, lock count of l-1 , cook of l -0\\n            //min count is-->0 so we store common[i]=0 for count of l\\n\\n            for(int i=0;i<26;++i){\\n                common[i]=min(common[i],count[i]);\\n            \\n            }\\n        }\\n        //store the ouput in result\\n        for(int i=0;i<26;++i){\\n        //if common[i] is not 0 we have store it common[i] times as it includes duplicates    \\n            if(common[i]>0){\\n                while(common[i]--)res.push_back(string(1,i+\\'a\\'));//it means we are storing string size 1\\n            }\\n        }\\nreturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        //to store the count of common element\\n        vector<int>common(26,INT_MAX);\\n        //to stroe the result\\n        vector<string>res;\\n        for(auto s :words){\\n            //to stroe the count of each element\\n            vector<int>count(26,0);\\n            //to count the frequency\\n            for(auto c:s) count[c-\\'a\\']++;\\n            // to store the min count of elements \\n            //as we find the common elements in each string\\n            //so we need to stroe the min freq of them\\n            //eg [\"cool\",\"lock\",\"cook\"] \\n            //in cool count of l -1, lock count of l-1 , cook of l -0\\n            //min count is-->0 so we store common[i]=0 for count of l\\n\\n            for(int i=0;i<26;++i){\\n                common[i]=min(common[i],count[i]);\\n            \\n            }\\n        }\\n        //store the ouput in result\\n        for(int i=0;i<26;++i){\\n        //if common[i] is not 0 we have store it common[i] times as it includes duplicates    \\n            if(common[i]>0){\\n                while(common[i]--)res.push_back(string(1,i+\\'a\\'));//it means we are storing string size 1\\n            }\\n        }\\nreturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850080,
                "title": "python-nested-for-in-loops-beats-100-00",
                "content": "# Intuition\\nI decided to take the shortest word (\"min_word\") and compare it to the others\\n\\n# Approach\\nI loop through the shortest word, then loop through the remaining words inside. \\nIf a character is not in the word, I delete it from \"min_word\".\\nElse, I delete it from the comparable word.\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        min_word = min(words)\\n        words.remove(min_word)\\n        for char in min_word[:]: # shallow copy by slice\\n            for idx_w, word in enumerate(words):\\n                if char not in word and (idx_w == len(words) or char in min_word):\\n                    min_word = min_word.replace(char, \"\", 1)\\n                    break\\n                else:\\n                    words[idx_w] = words[idx_w].replace(char, \"\", 1)\\n        return min_word\\n```\\n\\n![Screenshot 2023-08-01 at 11.41.20 PM.png](https://assets.leetcode.com/users/images/1373198d-61ab-4aac-8e3e-153be42047e5_1690922501.803046.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        min_word = min(words)\\n        words.remove(min_word)\\n        for char in min_word[:]: # shallow copy by slice\\n            for idx_w, word in enumerate(words):\\n                if char not in word and (idx_w == len(words) or char in min_word):\\n                    min_word = min_word.replace(char, \"\", 1)\\n                    break\\n                else:\\n                    words[idx_w] = words[idx_w].replace(char, \"\", 1)\\n        return min_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717808,
                "title": "runtime-100-beats-memory-96-beats-fully-explained",
                "content": "# Approach\\n\\n1. Initialize an empty result list, `res`, to store the common characters.\\n2. Declare an empty array, `cnt`, which will be used to count the frequencies of characters.\\n3. Iterate through the words array using a for loop:\\n   - If it is the first word (i.e., `i == 0`), call the `count` method to count the frequencies of characters in the word and assign the result to the `cnt` array.\\n   - If it is not the first word, call the `count` method to count the frequencies of characters in the word and update the `cnt` array by finding the intersection (minimum frequencies) between `cnt` and the current word\\'s frequencies using the `intersect` method.\\n4. After the loop, iterate through the `cnt` array:\\n   - For each index `i` in the `cnt` array, if the frequency at `cnt[i]` is greater than 0, it means the character represented by `i + \\'a\\'` is common. Therefore, decrement `cnt[i]` and add the character to the result list `res` using `String.valueOf((char)(i + \\'a\\'))`.\\n5. Return the result list `res`, which contains all the common characters.\\n\\nThe approach essentially counts the frequencies of characters in each word using the `count` method and finds the intersection of frequencies between the words using the `intersect` method. Finally, it constructs the result list by iterating through the resulting `cnt` array and adding the common characters based on their frequencies.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        int[] cnt = new int[0];\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (i == 0) \\n                cnt = count(words[i]);\\n            else \\n                intersect(cnt, count(words[i]));\\n        }\\n\\n        for (int i = 0; i < cnt.length; i++)\\n            while (cnt[i]-- > 0)\\n                res.add(String.valueOf((char)(i + \\'a\\')));\\n\\n        return res;\\n    }\\n\\n    private int[] count(String str) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < str.length(); i++)\\n            ++cnt[str.charAt(i) - \\'a\\'];\\n        return cnt;\\n    }\\n\\n    private void intersect(int[] cnt1, int[] cnt2) {\\n        for (int i = 0; i < cnt1.length; i++)\\n            cnt1[i] = Math.min(cnt1[i], cnt2[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        int[] cnt = new int[0];\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (i == 0) \\n                cnt = count(words[i]);\\n            else \\n                intersect(cnt, count(words[i]));\\n        }\\n\\n        for (int i = 0; i < cnt.length; i++)\\n            while (cnt[i]-- > 0)\\n                res.add(String.valueOf((char)(i + \\'a\\')));\\n\\n        return res;\\n    }\\n\\n    private int[] count(String str) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < str.length(); i++)\\n            ++cnt[str.charAt(i) - \\'a\\'];\\n        return cnt;\\n    }\\n\\n    private void intersect(int[] cnt1, int[] cnt2) {\\n        for (int i = 0; i < cnt1.length; i++)\\n            cnt1[i] = Math.min(cnt1[i], cnt2[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461671,
                "title": "nice-short-collections-counter-65-ms-16-4-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI recalled a nice tool fit for the job - the Counter class from the collections built-in module. Aside from other solutions - mine is more readable, though slightly less optimized: redundunt 1-st element conversion and Counter-ization of every word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounter class creates a dictionary-like object with chars as keys and amounts as values. What is more - we can get intersections of Counters with the \"&\" operation (and mechanic).\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI read every char of the input and perform word by word comparison. If to be more presize - it is O(x*n), where x is an average word length.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI store only a small portion of the data, representing at most 2 words at a time.\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        counter = Counter(words[0])\\n        for word in words:\\n            counter &= Counter(word)\\n        return list(counter.elements())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        counter = Counter(words[0])\\n        for word in words:\\n            counter &= Counter(word)\\n        return list(counter.elements())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290285,
                "title": "easy-solution-c-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<int> freq1(26,0) , freq2(26,0) ;\\n        for(auto ch: words[0]){\\n            freq1[ch -\\'a\\']++;\\n        }\\n        int i , j  , n = words.size() ;\\n        for(i=1;i<n;i++)\\n        {\\n            for(auto ch: words[i]){\\n                freq2[ch-\\'a\\']++;\\n            }\\n            for(j=0;j<26;j++){\\n                freq1[j] = min(freq1[j],freq2[j]) ;\\n                freq2[j] = 0 ;\\n            }\\n        }\\n        vector<string> ans ;\\n        for(i=0;i<26;i++){\\n            if(freq1[i]>0){\\n                char ch = i + \\'a\\' ;\\n                string s = \"\" ;\\n                s += ch;\\n                int count = freq1[i] ;\\n                while(count-->0){\\n                    ans.push_back(s) ;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<int> freq1(26,0) , freq2(26,0) ;\\n        for(auto ch: words[0]){\\n            freq1[ch -\\'a\\']++;\\n        }\\n        int i , j  , n = words.size() ;\\n        for(i=1;i<n;i++)\\n        {\\n            for(auto ch: words[i]){\\n                freq2[ch-\\'a\\']++;\\n            }\\n            for(j=0;j<26;j++){\\n                freq1[j] = min(freq1[j],freq2[j]) ;\\n                freq2[j] = 0 ;\\n            }\\n        }\\n        vector<string> ans ;\\n        for(i=0;i<26;i++){\\n            if(freq1[i]>0){\\n                char ch = i + \\'a\\' ;\\n                string s = \"\" ;\\n                s += ch;\\n                int count = freq1[i] ;\\n                while(count-->0){\\n                    ans.push_back(s) ;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280559,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        \\n  vector<int> ans_freq(26, INT_MAX);\\n  int n=words.size();\\n  for (int i = 0; i < n; i++)\\n  {\\n    vector<int> freq(26,0);\\n    string word = words[i];\\n    for (int j = 0; j < word.size(); j++)\\n      freq[word[j] - \\'a\\']++;\\n\\n    for (int j = 0; j < 26; j++)\\n      ans_freq[j] = min(ans_freq[j], freq[j]);\\n  }\\n\\n   vector<string> ans;\\n  for (int i = 0; i < 26; i++)\\n  {\\n    while (ans_freq[i] != 0)\\n    {\\n      string s=\"\";\\n      char c = \\'a\\' + i;\\n      s=s+c;\\n      ans.push_back(s);\\n      ans_freq[i]--;\\n    }\\n  }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        \\n  vector<int> ans_freq(26, INT_MAX);\\n  int n=words.size();\\n  for (int i = 0; i < n; i++)\\n  {\\n    vector<int> freq(26,0);\\n    string word = words[i];\\n    for (int j = 0; j < word.size(); j++)\\n      freq[word[j] - \\'a\\']++;\\n\\n    for (int j = 0; j < 26; j++)\\n      ans_freq[j] = min(ans_freq[j], freq[j]);\\n  }\\n\\n   vector<string> ans;\\n  for (int i = 0; i < 26; i++)\\n  {\\n    while (ans_freq[i] != 0)\\n    {\\n      string s=\"\";\\n      char c = \\'a\\' + i;\\n      s=s+c;\\n      ans.push_back(s);\\n      ans_freq[i]--;\\n    }\\n  }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278901,
                "title": "python-solution-with-collections",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        from collections import Counter\\n        from typing import List\\n\\n        # Initialize a Counter object with the characters of the first word\\n        common = Counter(words[0])\\n\\n        # Iterate over the remaining words and update the common Counter object\\n        for word in words[1:]:\\n            # Initialize a Counter object for the current word\\n            word_count = Counter(word)\\n            # Update the common Counter object to only include characters present in both\\n            common &= word_count\\n\\n        # Convert the common Counter object to a list of characters\\n        result = []\\n        for char, count in common.items():\\n            result += [char] * count\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        from collections import Counter\\n        from typing import List\\n\\n        # Initialize a Counter object with the characters of the first word\\n        common = Counter(words[0])\\n\\n        # Iterate over the remaining words and update the common Counter object\\n        for word in words[1:]:\\n            # Initialize a Counter object for the current word\\n            word_count = Counter(word)\\n            # Update the common Counter object to only include characters present in both\\n            common &= word_count\\n\\n        # Convert the common Counter object to a list of characters\\n        result = []\\n        for char, count in common.items():\\n            result += [char] * count\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074402,
                "title": "python-readable-no-shortcuts-with-explanation",
                "content": "# Approach\\nThe idea of this approach is to first start with the counts of every character in the first word and store these `character : character count` pairs in `res_counts`. Then we iterate through every other word in the words list. For each word, we use its own `char_counts` hash map to store `character : character count` pairs. Then we iterate through `res_counts`, and reassign each character\\'s count to the min of what it is currently and what we found in this current word. It is important to understand that we have to iterate through `res_counts` characters, not the `char_counts` characters. This is because we want to only update the characters that have been seen previously. If we iterate through every character in the current word, we might not have a character that was in the previous words, so we would skip characters that should actually be updated to have a count of 0 due to them not being present in the current word.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res_counts = defaultdict(int)\\n        for char in words[0]:\\n            res_counts[char] += 1\\n\\n        for i in range(1, len(words)):\\n            word = words[i]\\n            char_counts = defaultdict(int)\\n            for char in word:\\n                char_counts[char] += 1\\n            for char in res_counts:\\n                res_counts[char] = min(res_counts[char], char_counts[char])\\n        \\n        res = []\\n        for char, char_count in res_counts.items():\\n            if char_count != 0:\\n                for i in range(char_count):\\n                    res.append(char)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res_counts = defaultdict(int)\\n        for char in words[0]:\\n            res_counts[char] += 1\\n\\n        for i in range(1, len(words)):\\n            word = words[i]\\n            char_counts = defaultdict(int)\\n            for char in word:\\n                char_counts[char] += 1\\n            for char in res_counts:\\n                res_counts[char] = min(res_counts[char], char_counts[char])\\n        \\n        res = []\\n        for char, char_count in res_counts.items():\\n            if char_count != 0:\\n                for i in range(char_count):\\n                    res.append(char)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805284,
                "title": "java-find-common-characters",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        \\n        List<String> list=new ArrayList<>();\\n        char c[]=words[0].toCharArray();\\n        for(int i=0;i<c.length;i++){\\n            if(isContains(c[i],words))\\n                list.add(String.valueOf(c[i]));\\n        }\\n        return list;\\n        \\n    }\\n    \\n    public static boolean isContains(char c1,String[] words){\\n        for(int i=1;i<words.length;i++){\\n            if(!words[i].contains(String.valueOf(c1)))return false;\\n            else words[i]=words[i].replaceFirst(String.valueOf(c1), \"@\");\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        \\n        List<String> list=new ArrayList<>();\\n        char c[]=words[0].toCharArray();\\n        for(int i=0;i<c.length;i++){\\n            if(isContains(c[i],words))\\n                list.add(String.valueOf(c[i]));\\n        }\\n        return list;\\n        \\n    }\\n    \\n    public static boolean isContains(char c1,String[] words){\\n        for(int i=1;i<words.length;i++){\\n            if(!words[i].contains(String.valueOf(c1)))return false;\\n            else words[i]=words[i].replaceFirst(String.valueOf(c1), \"@\");\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788868,
                "title": "c-solution-hashmaps-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<int>shared(26,INT_MAX);\\n        vector<string>ans;\\n        for(auto it:words)\\n        {\\n            vector<int>count(26,0);\\n            for(auto ut:it)\\n            {\\n                count[ut-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                shared[i]=min(shared[i],count[i]);\\n            }\\n        }\\n       for(int i=0;i<26;i++)\\n       {\\n           for(int j=0;j<shared[i];j++)\\n               ans.push_back(string(1,i+\\'a\\'));\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<int>shared(26,INT_MAX);\\n        vector<string>ans;\\n        for(auto it:words)\\n        {\\n            vector<int>count(26,0);\\n            for(auto ut:it)\\n            {\\n                count[ut-\\'a\\']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2653444,
                "title": "c-95-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<string> commonChars(vector<string>& words) {\\n\\t\\tvector<int>util(26,INT_MAX);\\n\\t\\tfor(auto it:words){\\n\\t\\t\\tvector<int>v(26,0);\\n\\t\\t\\tfor(auto t:it) v[t-\\'a\\']++;\\n\\t\\t\\tfor(int i=0;i<26;i++) util[i] = min(util[i],v[i]);\\n\\t\\t}\\n\\t\\tvector<string>ans;\\n\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\twhile(util[i]--) ans.push_back(string(1,i+\\'a\\'));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<string> commonChars(vector<string>& words) {\\n\\t\\tvector<int>util(26,INT_MAX);\\n\\t\\tfor(auto it:words){\\n\\t\\t\\tvector<int>v(26,0);\\n\\t\\t\\tfor(auto t:it) v[t-\\'a\\']++;\\n\\t\\t\\tfor(int i=0;i<26;i++) util[i] = min(util[i],v[i]);\\n\\t\\t}\\n\\t\\tvector<string>ans;\\n\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\twhile(util[i]--) ans.push_back(string(1,i+\\'a\\'));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573534,
                "title": "python",
                "content": "class Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        a=[x for x in words[0]]\\n        b=[]\\n        for i in a:\\n            s=0\\n            for j in range(1,len(words)):\\n                if i in words[j]:\\n                    c=[x for x in words[j]]\\n                    c.remove(i)\\n                    s=s+1\\n                    words[j]=\"\".join(c)\\n            if(s==len(words)-1):\\n                b.append(i)\\n        return b",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        a=[x for x in words[0]]\\n        b=[]\\n        for i in a:\\n            s=0\\n            for j in range(1,len(words)):\\n                if i in words[j]:\\n                    c=[x for x in words[j]]\\n                    c.remove(i)\\n                    s=s+1\\n                    words[j]=\"\".join(c)\\n            if(s==len(words)-1):\\n                b.append(i)\\n        return b",
                "codeTag": "Java"
            },
            {
                "id": 2560903,
                "title": "java-solution-stream-faster-than-100",
                "content": "```\\n    public List<String> commonChars(String[] words) {\\n        return Stream.of(words)\\n                .map(x -> {\\n                    int[] arr = new int[26];\\n                    for (char c : x.toCharArray()) arr[c - 97]++;\\n                    return arr;\\n                })\\n                .reduce((x1, x2) -> {\\n                    for (int i = 0; i < 26; i++) x1[i] = Math.min(x1[i], x2[i]);\\n                    return x1;\\n                })\\n                .map(x -> {\\n                    List<String> ans = new ArrayList<>();\\n                    for (int i = 0; i < x.length; i++)\\n                        for (int j = 0; j < x[i]; j++) ans.add(String.valueOf((char) (i + 97)));\\n                    return ans;\\n                }).get();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<String> commonChars(String[] words) {\\n        return Stream.of(words)\\n                .map(x -> {\\n                    int[] arr = new int[26];\\n                    for (char c : x.toCharArray()) arr[c - 97]++;\\n                    return arr;\\n                })\\n                .reduce((x1, x2) -> {\\n                    for (int i = 0; i < 26; i++) x1[i] = Math.min(x1[i], x2[i]);\\n                    return x1;\\n                })\\n                .map(x -> {\\n                    List<String> ans = new ArrayList<>();\\n                    for (int i = 0; i < x.length; i++)\\n                        for (int j = 0; j < x[i]; j++) ans.add(String.valueOf((char) (i + 97)));\\n                    return ans;\\n                }).get();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2543225,
                "title": "java-arraylist-string-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        String str = words[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        if(words.length==1){\\n            for(int i=0;i<str.length();i++)\\n                list.add(Character.toString(str.charAt(i)));\\n            return list;\\n        }\\n        for(int i=0;i<str.length();i++){\\n            String letter = Character.toString(str.charAt(i));\\n            int flag=1;\\n            for(int j=0;j<words.length;j++){\\n                if(words[j].contains(letter))\\n                    words[j]=words[j].replaceFirst(letter,\"\");\\n                else{\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n                flag=1;\\n            else\\n                list.add(letter);\\n        }\\n        return list;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        String str = words[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        if(words.length==1){\\n            for(int i=0;i<str.length();i++)\\n                list.add(Character.toString(str.charAt(i)));\\n            return list;\\n        }\\n        for(int i=0;i<str.length();i++){\\n            String letter = Character.toString(str.charAt(i));\\n            int flag=1;\\n            for(int j=0;j<words.length;j++){\\n                if(words[j].contains(letter))\\n                    words[j]=words[j].replaceFirst(letter,\"\");\\n                else{\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n                flag=1;\\n            else\\n                list.add(letter);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453727,
                "title": "easy-python-solution-91-5",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        rt_dict = {}\\n        for c in set(words[0]):\\n            rt_dict[c] = min([word.count(c) for word in words])\\n        rt_list = []\\n        for key, value in rt_dict.items():\\n            if value > 0:\\n                for _ in range(value):\\n                    rt_list.append(key)\\n        return rt_list\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        rt_dict = {}\\n        for c in set(words[0]):\\n            rt_dict[c] = min([word.count(c) for word in words])\\n        rt_list = []\\n        for key, value in rt_dict.items():\\n            if value > 0:\\n                for _ in range(value):\\n                    rt_list.append(key)\\n        return rt_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308263,
                "title": "a-c-naive-approach",
                "content": "```\\nclass Solution {\\n    string commom_of_two(string& v1, string& v2){\\n        string st = \"\";\\n        vector<string> v;\\n        int l1 = v1.length(), l2 = v2.length();\\n        unordered_map<char,int> m1,m2;\\n        for(auto& i : v1){\\n            m1[i]++;\\n        }\\n        for(auto& i : v2){\\n            m2[i]++;\\n        }\\n        if(m1.size() < m2.size()){\\n            for(auto& itr : m1){\\n                auto p = itr.first;\\n                if(m1[p] > 0 && m2[p] >0){\\n                    int num = min(m1[p],m2[p]);\\n                    for(int i=0; i<num; ++i){\\n                        string s = \"\";\\n                        st += p+s;\\n                    }\\n                }\\n            }\\n        }\\n        else{\\n            for(auto& itr : m2){\\n                auto p = itr.first;\\n                if(m1[p] > 0 && m2[p] >0){\\n                    int num = min(m1[p],m2[p]);\\n                    for(int i=0; i<num; ++i){\\n                        string s = \"\";\\n                        st += p+s;\\n                    }\\n                }\\n            }\\n        }\\n        return st;\\n    }\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> v;\\n        int l = words.size();\\n        string s = words[0];\\n        if(l>1){\\n            for(int i=1; i<l; ++i){\\n                s = commom_of_two(s,words[i]);\\n            }\\n        }\\n        for(auto& i : s){\\n            string t = \"\";\\n            v.push_back(t+i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    string commom_of_two(string& v1, string& v2){\\n        string st = \"\";\\n        vector<string> v;\\n        int l1 = v1.length(), l2 = v2.length();\\n        unordered_map<char,int> m1,m2;\\n        for(auto& i : v1){\\n            m1[i]++;\\n        }\\n        for(auto& i : v2){\\n            m2[i]++;\\n        }\\n        if(m1.size() < m2.size()){\\n            for(auto& itr : m1){\\n                auto p = itr.first;\\n                if(m1[p] > 0 && m2[p] >0){\\n                    int num = min(m1[p],m2[p]);\\n                    for(int i=0; i<num; ++i){\\n                        string s = \"\";\\n                        st += p+s;\\n                    }\\n                }\\n            }\\n        }\\n        else{\\n            for(auto& itr : m2){\\n                auto p = itr.first;\\n                if(m1[p] > 0 && m2[p] >0){\\n                    int num = min(m1[p],m2[p]);\\n                    for(int i=0; i<num; ++i){\\n                        string s = \"\";\\n                        st += p+s;\\n                    }\\n                }\\n            }\\n        }\\n        return st;\\n    }\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> v;\\n        int l = words.size();\\n        string s = words[0];\\n        if(l>1){\\n            for(int i=1; i<l; ++i){\\n                s = commom_of_two(s,words[i]);\\n            }\\n        }\\n        for(auto& i : s){\\n            string t = \"\";\\n            v.push_back(t+i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206972,
                "title": "javascript-solution-with-hash",
                "content": "```\\nvar commonChars = function(words) {\\n    let res = [];    \\n    let hash = hashWord(words[0]);    \\n    \\n    for(let i=1; i<words.length; i++) {\\n        let word = words[i];\\n        let tempHash = hashWord(word);                 \\n        merge(hash, tempHash);\\n    }\\n    \\n    for(let [letter, count] of Object.entries(hash)) {\\n        while(0 < count--) {\\n            res.push(letter);\\n        }                \\n    }\\n    \\n    return res;\\n};\\n\\nfunction hashWord(word) {\\n    let hash = {};\\n    for(let i=0; i<word.length; i++) {\\n        let letter = word[i];\\n        if( hash[letter] ){\\n            hash[letter]++;\\n        } else {\\n            hash[letter] = 1;\\n        }\\n    }    \\n    return hash;\\n}\\n\\nfunction merge(hash1, hash2) {  \\n    for(let letter of Object.keys(hash1)) {        \\n        if(!hash2[letter]) {\\n            delete hash1[letter];\\n        } else {\\n            hash1[letter] = Math.min(hash1[letter], hash2[letter]);            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar commonChars = function(words) {\\n    let res = [];    \\n    let hash = hashWord(words[0]);    \\n    \\n    for(let i=1; i<words.length; i++) {\\n        let word = words[i];\\n        let tempHash = hashWord(word);                 \\n        merge(hash, tempHash);\\n    }\\n    \\n    for(let [letter, count] of Object.entries(hash)) {\\n        while(0 < count--) {\\n            res.push(letter);\\n        }                \\n    }\\n    \\n    return res;\\n};\\n\\nfunction hashWord(word) {\\n    let hash = {};\\n    for(let i=0; i<word.length; i++) {\\n        let letter = word[i];\\n        if( hash[letter] ){\\n            hash[letter]++;\\n        } else {\\n            hash[letter] = 1;\\n        }\\n    }    \\n    return hash;\\n}\\n\\nfunction merge(hash1, hash2) {  \\n    for(let letter of Object.keys(hash1)) {        \\n        if(!hash2[letter]) {\\n            delete hash1[letter];\\n        } else {\\n            hash1[letter] = Math.min(hash1[letter], hash2[letter]);            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171936,
                "title": "very-interesting-solution-java",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n     \\n        int [] array=new int[26];\\n        Arrays.fill(array,Integer.MAX_VALUE);\\n        for(String str:words)\\n        {\\n            int [] res=new int[26];\\n            for(char ch:str.toCharArray())\\n            {\\n                res[ch-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                array[i]=Math.min(array[i],res[i]);\\n            }   \\n        }\\n        \\n        ArrayList<String> ans=new ArrayList<>();\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            while(array[i]>0)\\n            {\\n                ans.add(\"\"+(char)(i+\\'a\\'));\\n                array[i]--;\\n            }\\n        }\\n        return ans;     \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n     \\n        int [] array=new int[26];\\n        Arrays.fill(array,Integer.MAX_VALUE);\\n        for(String str:words)\\n        {\\n            int [] res=new int[26];\\n            for(char ch:str.toCharArray())\\n            {\\n                res[ch-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                array[i]=Math.min(array[i],res[i]);\\n            }   \\n        }\\n        \\n        ArrayList<String> ans=new ArrayList<>();\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            while(array[i]>0)\\n            {\\n                ans.add(\"\"+(char)(i+\\'a\\'));\\n                array[i]--;\\n            }\\n        }\\n        return ans;     \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071783,
                "title": "c-code-with-explanation",
                "content": "```\\n/*\\n\\tintuition : suppose in input we have -> words = [ \"aaa\" , \"aa\"  ,\"a\" ]\\n\\t\\t\\t    here just calculate the frequency of char \\'a\\' for every string and\\n\\t\\t\\t\\tstroe it in a vector and at the end we just calculate the minimun \\n\\t\\t\\t\\tfrequency of a .\\n*/\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n\\t    //to store the final output\\n        vector<string> ans;\\n        vector<int> freq1(26,INT_MAX); // to store final frequency of every char \\n\\n        for(auto word : words){\\n            vector<int> freq2(26,0); // for every iteration you need to store the every char\\'s freq of word.\\n            for(auto ch : word) freq2[ch-\\'a\\']++;\\n            for(int i=0;i<26;i++) freq1[i] = min(freq1[i],freq2[i]); // after that store the minimun freq\\n        }\\n        \\n\\t\\t\\n        for(int i=0;i<26;i++)\\n            if(freq1[i])\\n                while(freq1[i]--) ans.push_back(string(1, i + \\'a\\')); // converting the char to string\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tor you can convert a char to string in this way --\\n\\t\\t\\t\\t\\tchar c = i+97;\\n                    string str;\\n                    str.append(1,c);\\n                    ans.push_back(str);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tremember every char can be a string but every string can\\'t be char .\\n\\t\\t\\t\\t*/\\n       \\n        return ans;\\n    }\\n};\\n```\\n\\n**if you like please upvoat :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n\\tintuition : suppose in input we have -> words = [ \"aaa\" , \"aa\"  ,\"a\" ]\\n\\t\\t\\t    here just calculate the frequency of char \\'a\\' for every string and\\n\\t\\t\\t\\tstroe it in a vector and at the end we just calculate the minimun \\n\\t\\t\\t\\tfrequency of a .\\n*/\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n\\t    //to store the final output\\n        vector<string> ans;\\n        vector<int> freq1(26,INT_MAX); // to store final frequency of every char \\n\\n        for(auto word : words){\\n            vector<int> freq2(26,0); // for every iteration you need to store the every char\\'s freq of word.\\n            for(auto ch : word) freq2[ch-\\'a\\']++;\\n            for(int i=0;i<26;i++) freq1[i] = min(freq1[i],freq2[i]); // after that store the minimun freq\\n        }\\n        \\n\\t\\t\\n        for(int i=0;i<26;i++)\\n            if(freq1[i])\\n                while(freq1[i]--) ans.push_back(string(1, i + \\'a\\')); // converting the char to string\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tor you can convert a char to string in this way --\\n\\t\\t\\t\\t\\tchar c = i+97;\\n                    string str;\\n                    str.append(1,c);\\n                    ans.push_back(str);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tremember every char can be a string but every string can\\'t be char .\\n\\t\\t\\t\\t*/\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057778,
                "title": "simple-python-4-lines-solution-with-counter",
                "content": "Here is what I did.\\nA lot of shortcuts, but if they are in stdlib and you can implement each of them if needed then I guess it\\'s ok to use them: \\n\\n```python\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        ans = Counter(words[0])\\n        for i in range(1, len(words)):\\n            ans &= Counter(words[i])\\n        return ans.elements()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        ans = Counter(words[0])\\n        for i in range(1, len(words)):\\n            ans &= Counter(words[i])\\n        return ans.elements()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2042612,
                "title": "java-solution-using-2-hashmaps",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) \\n    {\\n        List<String> list=new ArrayList<>();\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        for(char c:words[0].toCharArray())\\n            hmap.put(c,hmap.getOrDefault(c,0)+1);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            HashMap<Character,Integer> hmap2=new HashMap<>();\\n            for(char c:words[i].toCharArray())\\n                hmap2.put(c,hmap2.getOrDefault(c,0)+1);\\n            hmap.keySet().retainAll(hmap2.keySet());\\n            for(Character c:hmap.keySet())\\n            {\\n                if(hmap.get(c)!=hmap2.get(c))\\n                    hmap.put(c,Math.min(hmap.get(c),hmap2.get(c)));\\n            }\\n        }\\n        for(Character c:hmap.keySet())\\n        {\\n            if(hmap.get(c)!=1)\\n                for(int i=0;i<hmap.get(c)-1;i++)\\n                    list.add(String.valueOf(c));\\n            list.add(String.valueOf(c));\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> commonChars(String[] words) \\n    {\\n        List<String> list=new ArrayList<>();\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        for(char c:words[0].toCharArray())\\n            hmap.put(c,hmap.getOrDefault(c,0)+1);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            HashMap<Character,Integer> hmap2=new HashMap<>();\\n            for(char c:words[i].toCharArray())\\n                hmap2.put(c,hmap2.getOrDefault(c,0)+1);\\n            hmap.keySet().retainAll(hmap2.keySet());\\n            for(Character c:hmap.keySet())\\n            {\\n                if(hmap.get(c)!=hmap2.get(c))\\n                    hmap.put(c,Math.min(hmap.get(c),hmap2.get(c)));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2006225,
                "title": "python-short-code-with-counter",
                "content": "\\tclass Solution:\\n\\t\\tdef commonChars(self, words: List[str]) -> List[str]:\\t\\n\\t\\t\\tmin_counter = collections.Counter(words[0])\\n        \\n\\t\\t\\tfor word in words[1:]:\\n\\t\\t\\t\\tword_counter = collections.Counter(word)\\n\\t\\t\\t\\tmin_counter = word_counter & min_counter\\n        \\n\\t\\t\\treturn list(min_counter.elements())\\n\\t\\t\\t\\n\\t\\t\\t\\nUsing first word to build initial Counter dictionary. Then going through all other words. Each time compare the min_counter with current word_counter, and using & to do intersection. For example, c = Counter(\\'a\\':3, \\'b\\':1), d = Counter(\\'a\\':1, \\'b\\':2), c & d is Counter({\\'a\\': 1, \\'b\\': 1}). Finally, using Counter.elements to return an iterator over elements repeating each as many times as its count.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef commonChars(self, words: List[str]) -> List[str]:\\t\\n\\t\\t\\tmin_counter = collections.Counter(words[0])\\n        \\n\\t\\t\\tfor word in words[1:]:\\n\\t\\t\\t\\tword_counter = collections.Counter(word)\\n\\t\\t\\t\\tmin_counter = word_counter & min_counter\\n        \\n\\t\\t\\treturn list(min_counter.elements())\\n\\t\\t\\t\\n\\t\\t\\t\\nUsing first word to build initial Counter dictionary. Then going through all other words. Each time compare the min_counter with current word_counter, and using & to do intersection. For example, c = Counter(\\'a\\':3, \\'b\\':1), d = Counter(\\'a\\':1, \\'b\\':2), c & d is Counter({\\'a\\': 1, \\'b\\': 1}",
                "codeTag": "Java"
            },
            {
                "id": 2000645,
                "title": "java-easy-to-undersatand",
                "content": "class Solution {\\n\\n    public List<String> commonChars(String[] words) {\\n        HashMap<Character,Integer> cmap =new HashMap<>();\\n        \\n        for(int i=0;i<words[0].length();i++){\\n            char ch = words[0].charAt(i);\\n            cmap.put(ch,cmap.getOrDefault(ch,0)+1);\\n        }\\n        for(int i =1;i<words.length;i++){\\n            String word = words[i];\\n            \\n            HashMap<Character,Integer> map =new HashMap<>();\\n            \\n            for(int j=0;j<word.length();j++){\\n                char ch = word.charAt(j);\\n                map.put(ch,map.getOrDefault(ch,0)+1);\\n            }\\n            HashMap<Character,Integer> map2 =new HashMap<>();\\n            for(char key : map.keySet()){\\n                if(cmap.containsKey(key)== true){\\n                    map2.put(key,Math.min(map.get(key),cmap.get(key)));\\n                }\\n            }\\n         \\n            cmap = map2;\\n        }\\n        List<String> res = new ArrayList<>();\\n        \\n        for(char key: cmap.keySet()){\\n            int frq = cmap.get(key);\\n            for(int i=0;i<frq;i++){\\n                res.add(\"\"+key);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public List<String> commonChars(String[] words) {\\n        HashMap<Character,Integer> cmap =new HashMap<>();\\n        \\n        for(int i=0;i<words[0].length();i++){\\n            char ch = words[0].charAt(i);\\n            cmap.put(ch,cmap.getOrDefault(ch,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1871865,
                "title": "java-beat-95",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(final String[] words) {\\n        final int[] current = new int[\\'z\\' - \\'a\\' + 1];\\n        final int[] result = new int[\\'z\\' - \\'a\\' + 1];\\n        for (final char ch: words[0].toCharArray()) {\\n            result[ch - \\'a\\']++;\\n        }\\n        for (int i=1; i<words.length; i++) {\\n            for (final char ch: words[i].toCharArray()) {\\n                final int index = ch - \\'a\\';\\n                current[index]++;\\n                \\n            }\\n            \\n            for (int j=0; j<result.length; j++) {\\n                result[j] = Math.min(result[j], current[j]);\\n                current[j] = 0;\\n            }\\n        }\\n        final List<String> resultList = new LinkedList<>();\\n        for (int i=0; i<result.length; i++) {\\n            while (result[i]-- > 0) {\\n                resultList.add(Character.toString(\\'a\\' + i));\\n            }\\n        }\\n        return resultList;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(final String[] words) {\\n        final int[] current = new int[\\'z\\' - \\'a\\' + 1];\\n        final int[] result = new int[\\'z\\' - \\'a\\' + 1];\\n        for (final char ch: words[0].toCharArray()) {\\n            result[ch - \\'a\\']++;\\n        }\\n        for (int i=1; i<words.length; i++) {\\n            for (final char ch: words[i].toCharArray()) {\\n                final int index = ch - \\'a\\';\\n                current[index]++;\\n                \\n            }\\n            \\n            for (int j=0; j<result.length; j++) {\\n                result[j] = Math.min(result[j], current[j]);\\n                current[j] = 0;\\n            }\\n        }\\n        final List<String> resultList = new LinkedList<>();\\n        for (int i=0; i<result.length; i++) {\\n            while (result[i]-- > 0) {\\n                resultList.add(Character.toString(\\'a\\' + i));\\n            }\\n        }\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861512,
                "title": "python-counter",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res_dict = {elem:words[0].count(elem) for elem in words[0]}\\n        for elem in words[1:]:\\n            comp_dict = dict(Counter(elem))\\n            res_dict = {k: min(v, res_dict[k]) for k, v in comp_dict.items() if k in comp_dict and k in res_dict}\\n            \\n        \\n        res = []\\n        for k in res_dict:\\n            res.extend([k]*res_dict[k])\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res_dict = {elem:words[0].count(elem) for elem in words[0]}\\n        for elem in words[1:]:\\n            comp_dict = dict(Counter(elem))\\n            res_dict = {k: min(v, res_dict[k]) for k, v in comp_dict.items() if k in comp_dict and k in res_dict}\\n            \\n        \\n        res = []\\n        for k in res_dict:\\n            res.extend([k]*res_dict[k])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818068,
                "title": "java-find-common-characters",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> li = new ArrayList<>();\\n        int n = words.length;\\n        String s = words[0];\\n        int count = 1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            count=1;\\n            for(int j=1;j<words.length;j++)\\n            {\\n                String str = words[j];\\n                for(int k=0;k<str.length();k++){\\n                if(ch==str.charAt(k)){\\n                  count++;\\n                  words[j] = str.substring(0,k)+\"\"+str.substring(k+1);\\n                  break;\\n                }\\n            }\\n            if(count==words.length)\\n                li.add(ch+\"\");\\n            }\\n        }\\n        return li;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> li = new ArrayList<>();\\n        int n = words.length;\\n        String s = words[0];\\n        int count = 1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            count=1;\\n            for(int j=1;j<words.length;j++)\\n            {\\n                String str = words[j];\\n                for(int k=0;k<str.length();k++){\\n                if(ch==str.charAt(k)){\\n                  count++;\\n                  words[j] = str.substring(0,k)+\"\"+str.substring(k+1);\\n                  break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1807799,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n\\t\\t// count the frequency of each character for first word\\n        for (char ch : words[0].toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n\\t\\t// loop through the rest of words and compare with the first word\\n        for (int i = 1; i < words.length; i++) {\\n\\t\\t\\t// count the frequency of character to do comparison\\n            Map<Character, Integer> tempMap = new HashMap<>();\\n            for (char ch : words[i].toCharArray()) {\\n                tempMap.put(ch, tempMap.getOrDefault(ch, 0) + 1);\\n            }\\n            \\n\\t\\t\\t// if the character in first word is not in other words, then make it 0\\n\\t\\t\\t// else we put the min frequency\\n            for (Character ch : map.keySet()){\\n                if (!tempMap.containsKey(ch)) {\\n                    map.put(ch, 0);\\n                } else {\\n                    map.put(ch, Math.min(map.get(ch), tempMap.get(ch)));\\n                }\\n            }\\n        }\\n        \\n\\t\\t// last step is simply printing out the result\\n        List<String> result = new ArrayList<>();\\n        for (Character ch : map.keySet()) {\\n            int count = map.get(ch);\\n            while (count > 0) {\\n                result.add(String.valueOf(ch));\\n                count--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nN is num of words, M is the len of word\\nTime Complexity: O(N * M), worst case is words[0] has longest M and compare it with N - 1 words\\nSpace Complexity: O(M), two hashmaps",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n\\t\\t// count the frequency of each character for first word\\n        for (char ch : words[0].toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n\\t\\t// loop through the rest of words and compare with the first word\\n        for (int i = 1; i < words.length; i++) {\\n\\t\\t\\t// count the frequency of character to do comparison\\n            Map<Character, Integer> tempMap = new HashMap<>();\\n            for (char ch : words[i].toCharArray()) {\\n                tempMap.put(ch, tempMap.getOrDefault(ch, 0) + 1);\\n            }\\n            \\n\\t\\t\\t// if the character in first word is not in other words, then make it 0\\n\\t\\t\\t// else we put the min frequency\\n            for (Character ch : map.keySet()){\\n                if (!tempMap.containsKey(ch)) {\\n                    map.put(ch, 0);\\n                } else {\\n                    map.put(ch, Math.min(map.get(ch), tempMap.get(ch)));\\n                }\\n            }\\n        }\\n        \\n\\t\\t// last step is simply printing out the result\\n        List<String> result = new ArrayList<>();\\n        for (Character ch : map.keySet()) {\\n            int count = map.get(ch);\\n            while (count > 0) {\\n                result.add(String.valueOf(ch));\\n                count--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786865,
                "title": "easiest-solution-to-understand-time-0-ms-space-less-than-98-subs",
                "content": "**Please upvote if you liked my solution. It is always a great motivation to write more :)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) \\n    {\\n        int hash1[26] = {0};\\n        vector<string> result;\\n        \\n        for(int i=0; i<words[0].length(); i++)\\n            hash1[words[0][i]-\\'a\\']++;\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            int hash2[26] = {0};\\n            \\n            for(int j=0; j<words[i].length(); j++)\\n                hash2[words[i][j]-\\'a\\']++;\\n\\n            for(int j=0; j<26; j++)\\n                hash1[j] = min(hash1[j], hash2[j]);\\n        }\\n        \\n        for(int i=0; i<26; i++)\\n            if(hash1[i] != 0)\\n            {\\n                while(hash1[i]-- > 0)\\n                {\\n                    string temp1(1, i + \\'a\\');\\n                    result.push_back(temp1);   \\n                }\\n            }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) \\n    {\\n        int hash1[26] = {0};\\n        vector<string> result;\\n        \\n        for(int i=0; i<words[0].length(); i++)\\n            hash1[words[0][i]-\\'a\\']++;\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            int hash2[26] = {0};\\n            \\n            for(int j=0; j<words[i].length(); j++)\\n                hash2[words[i][j]-\\'a\\']++;\\n\\n            for(int j=0; j<26; j++)\\n                hash1[j] = min(hash1[j], hash2[j]);\\n        }\\n        \\n        for(int i=0; i<26; i++)\\n            if(hash1[i] != 0)\\n            {\\n                while(hash1[i]-- > 0)\\n                {\\n                    string temp1(1, i + \\'a\\');\\n                    result.push_back(temp1);   \\n                }\\n            }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768841,
                "title": "python-3-lines-solution-with-counter-with-explanation",
                "content": "First we will import the class \\nthen we will take the first word into a temp variable\\nthen iterate the rest of the words and find the letters common in the two words and store as a dict\\nThen finally using another function of collections we will return the final dict as a list.\\n\\n```from collections import Counter\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        dict1 = words[0]\\n        for i in range(1,len(words)):\\n            dict1 = Counter(dict1) & Counter(words[i])\\n        return list(dict1.elements())\\n                \\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "First we will import the class \\nthen we will take the first word into a temp variable\\nthen iterate the rest of the words and find the letters common in the two words and store as a dict\\nThen finally using another function of collections we will return the final dict as a list.\\n\\n```from collections import Counter\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        dict1 = words[0]\\n        for i in range(1,len(words)):\\n            dict1 = Counter(dict1) & Counter(words[i])\\n        return list(dict1.elements())\\n                \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1683586,
                "title": "1ms-faster-than-100-with-explanation",
                "content": "Test Case - [\"bella\",\"label\",\"roller\"]\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int[] ar=countOccurances(A[0]);     //First get occurance array of 1st String\\n        //ar will be 1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        \\n        //Now we will be comparing 1st String\\'s countOccurance with 2nd, 3rd.. and so on, and will be getting the intersection also\\n        \\n        //Count Occurance of bella is   1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        //Count Occurance of label is   1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        //After Intersection it will be 1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        \\n        //Now Intersection will be compared with 3rd String\\'s Count Occurance and so on  \\n        for(int x=1; x<A.length; x++){\\n            ar=intersection(ar, countOccurances(A[x]));\\n        }\\n        //For the result we will have to print each repeating element by the nuber of time it repeats\\n        return result(ar);         \\n    }\\n    public static List<String> result(int[] ar){\\n        List<String> l=new ArrayList<>();\\n        for(int x=0; x<26; x++){\\n            while(ar[x]!=0){        //this is the case of \\'l\\' which repeats twice in every string so it needs to be printed twice \\n                l.add(String.valueOf( (char)(x+97) )); \\n                ar[x]=ar[x]-1;\\n            }\\n        }\\n        return l;\\n    }\\n    public static int[] intersection(int[]a, int[]b){\\n        int[] t=new int[26];\\n        for(int x=0; x<26; x++){\\n            t[x]=Math.min(a[x], b[x]);\\n        }\\n        return t;\\n    }\\n    public static int[] countOccurances(String a){\\n        int[] t=new int[26];\\n        for(char ch : a.toCharArray())\\n            t[ch - \\'a\\']++; \\n        // for(int x: t)\\n        //     System.out.print(x + \" \");\\n        // System.out.println();\\n        return t;\\n    }\\n}\\n```\\nPlease upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int[] ar=countOccurances(A[0]);     //First get occurance array of 1st String\\n        //ar will be 1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        \\n        //Now we will be comparing 1st String\\'s countOccurance with 2nd, 3rd.. and so on, and will be getting the intersection also\\n        \\n        //Count Occurance of bella is   1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        //Count Occurance of label is   1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        //After Intersection it will be 1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        \\n        //Now Intersection will be compared with 3rd String\\'s Count Occurance and so on  \\n        for(int x=1; x<A.length; x++){\\n            ar=intersection(ar, countOccurances(A[x]));\\n        }\\n        //For the result we will have to print each repeating element by the nuber of time it repeats\\n        return result(ar);         \\n    }\\n    public static List<String> result(int[] ar){\\n        List<String> l=new ArrayList<>();\\n        for(int x=0; x<26; x++){\\n            while(ar[x]!=0){        //this is the case of \\'l\\' which repeats twice in every string so it needs to be printed twice \\n                l.add(String.valueOf( (char)(x+97) )); \\n                ar[x]=ar[x]-1;\\n            }\\n        }\\n        return l;\\n    }\\n    public static int[] intersection(int[]a, int[]b){\\n        int[] t=new int[26];\\n        for(int x=0; x<26; x++){\\n            t[x]=Math.min(a[x], b[x]);\\n        }\\n        return t;\\n    }\\n    public static int[] countOccurances(String a){\\n        int[] t=new int[26];\\n        for(char ch : a.toCharArray())\\n            t[ch - \\'a\\']++; \\n        // for(int x: t)\\n        //     System.out.print(x + \" \");\\n        // System.out.println();\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619166,
                "title": "simplest-approach-for-1002-find-common-characters",
                "content": "\\twhat you can do just iterate for all string and store all characters frequency in your string then find minimum frequency for that char then store in your ans vector\\n\\t\\n\\t\\n```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> commonChars(vector<string>& a) {\\n\\t\\t\\t\\t\\tvector<vector<int>> v(a.size(),vector<int> (30,0));\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<a.size();i++){\\n\\t\\t\\t\\t\\t\\tfor(auto &it:a[i]){\\n\\t\\t\\t\\t\\t\\t\\tint val = (int)(it -\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\tv[i][val]++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvector<string> ans;\\n\\t\\t\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\t\\t\\tint cnt=INT_MAX;\\n\\t\\t\\t\\t\\t\\tfor(int j=0;j<a.size();j++){\\n\\t\\t\\t\\t\\t\\t\\tcnt=min(v[j][i],cnt);\\n\\t\\t\\t\\t\\t\\t\\t//cout<<v[j][i];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstring s = \"\";\\n\\t\\t\\t\\t\\t\\ts+=(i+\\'a\\');\\n\\t\\t\\t\\t\\t\\tfor(int l=0;l<cnt;l++){\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> commonChars(vector<string>& a) {\\n\\t\\t\\t\\t\\tvector<vector<int>> v(a.size(),vector<int> (30,0));\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<a.size();i++){\\n\\t\\t\\t\\t\\t\\tfor(auto &it:a[i]){\\n\\t\\t\\t\\t\\t\\t\\tint val = (int)(it -\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\tv[i][val]++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvector<string> ans;\\n\\t\\t\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\t\\t\\tint cnt=INT_MAX;\\n\\t\\t\\t\\t\\t\\tfor(int j=0;j<a.size();j++){\\n\\t\\t\\t\\t\\t\\t\\tcnt=min(v[j][i],cnt);\\n\\t\\t\\t\\t\\t\\t\\t//cout<<v[j][i];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstring s = \"\";\\n\\t\\t\\t\\t\\t\\ts+=(i+\\'a\\');\\n\\t\\t\\t\\t\\t\\tfor(int l=0;l<cnt;l++){\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1606764,
                "title": "simple-java-code-using-array-and-ascii-key",
                "content": "```\\n public List<String> commonChars(String[] A) {\\n        \\n        \\n        ArrayList<String> result=new ArrayList<>();\\n        \\n        int[] min_frequency=new int[26];\\n        \\n        Arrays.fill(min_frequency, Integer.MAX_VALUE);\\n       \\n            \\n            \\n            for( String current: A)\\n            {\\n                int[] char_frequency=new int[26];\\n                \\n                \\n                for(char c: current.toCharArray())\\n                {\\n                    char_frequency[c-\\'a\\']++;\\n                    \\n                }\\n                \\n                for(int i=0; i<26; i++)\\n                {\\n                    min_frequency[i]=Math.min( min_frequency[i], char_frequency[i]);\\n                }\\n            }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            while(min_frequency[i]>0)\\n            {\\n                result.add(\"\"+(char)(i+\\'a\\'));\\n                 min_frequency[i]--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n public List<String> commonChars(String[] A) {\\n        \\n        \\n        ArrayList<String> result=new ArrayList<>();\\n        \\n        int[] min_frequency=new int[26];\\n        \\n        Arrays.fill(min_frequency, Integer.MAX_VALUE);\\n       \\n            \\n            \\n            for( String current: A)\\n            {\\n                int[] char_frequency=new int[26];\\n                \\n                \\n                for(char c: current.toCharArray())\\n                {\\n                    char_frequency[c-\\'a\\']++;\\n                    \\n                }\\n                \\n                for(int i=0; i<26; i++)\\n                {\\n                    min_frequency[i]=Math.min( min_frequency[i], char_frequency[i]);\\n                }\\n            }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            while(min_frequency[i]>0)\\n            {\\n                result.add(\"\"+(char)(i+\\'a\\'));\\n                 min_frequency[i]--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546010,
                "title": "simple-java-solution",
                "content": "```\\npublic List<String> commonChars(String[] words) {\\n\\tMap<String, Integer> map = new HashMap<>();\\n\\tfor(int j = 0; j < words[0].length(); j++){\\n\\t\\tString key = words[0].substring(j, j+1);\\n\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t}\\n\\tfor(int i = 1; i < words.length; i++){\\n\\t\\tMap<String, Integer> temp = new HashMap<>();\\n\\t\\tfor(int j = 0; j < words[i].length(); j++){\\n\\t\\t\\tString key = words[i].substring(j, j+1);\\n\\t\\t\\ttemp.put(key, temp.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\tmap = getCommon(map, temp);\\n\\t}\\n\\tList<String> list = new ArrayList<>();\\n\\tfor(Map.Entry<String, Integer> e : map.entrySet()){\\n\\t\\tint value = e.getValue();\\n\\t\\twhile(value > 0){\\n\\t\\t\\tlist.add(e.getKey());\\n\\t\\t\\tvalue--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn list;\\n}\\n\\n// This method will compare the 2 maps and will return a map having the common characters\\npublic Map<String, Integer> getCommon(Map<String, Integer> map1, Map<String, Integer> map2){\\n\\tMap<String, Integer> common = new HashMap<>();\\n\\tfor(Map.Entry<String, Integer> e : map1.entrySet()){\\n\\t\\tif(map2.containsKey(e.getKey())){\\n\\t\\t\\tcommon.put(e.getKey(), Math.min(e.getValue(), map2.get(e.getKey())));\\n\\t\\t}\\n\\t}\\n\\n\\treturn common;\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> commonChars(String[] words) {\\n\\tMap<String, Integer> map = new HashMap<>();\\n\\tfor(int j = 0; j < words[0].length(); j++){\\n\\t\\tString key = words[0].substring(j, j+1);\\n\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t}\\n\\tfor(int i = 1; i < words.length; i++){\\n\\t\\tMap<String, Integer> temp = new HashMap<>();\\n\\t\\tfor(int j = 0; j < words[i].length(); j++){\\n\\t\\t\\tString key = words[i].substring(j, j+1);\\n\\t\\t\\ttemp.put(key, temp.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\tmap = getCommon(map, temp);\\n\\t}\\n\\tList<String> list = new ArrayList<>();\\n\\tfor(Map.Entry<String, Integer> e : map.entrySet()){\\n\\t\\tint value = e.getValue();\\n\\t\\twhile(value > 0){\\n\\t\\t\\tlist.add(e.getKey());\\n\\t\\t\\tvalue--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn list;\\n}\\n\\n// This method will compare the 2 maps and will return a map having the common characters\\npublic Map<String, Integer> getCommon(Map<String, Integer> map1, Map<String, Integer> map2){\\n\\tMap<String, Integer> common = new HashMap<>();\\n\\tfor(Map.Entry<String, Integer> e : map1.entrySet()){\\n\\t\\tif(map2.containsKey(e.getKey())){\\n\\t\\t\\tcommon.put(e.getKey(), Math.min(e.getValue(), map2.get(e.getKey())));\\n\\t\\t}\\n\\t}\\n\\n\\treturn common;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1476020,
                "title": "java-no-hashmap-inputs-appreciated",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        String firstWord = words[0]; //setting word to first word\\n        List<String> list = new ArrayList<>();\\n        for(char c:firstWord.toCharArray()) {\\n            for(int i = 0; i < words.length; i++) {\\n                if(!words[i].contains(Character.toString(c))) \\n                    break;\\n                else if(i == words.length - 1) \\n                    // if it got till here, it means that character was present in all\\n                    list.add(Character.toString(c));\\n                //Replacing character with star (for duplicates)\\n                StringBuilder string = new StringBuilder(words[i]);\\n                string.setCharAt(words[i].indexOf(c), \\'*\\');\\n                words[i] = string.toString();\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        String firstWord = words[0]; //setting word to first word\\n        List<String> list = new ArrayList<>();\\n        for(char c:firstWord.toCharArray()) {\\n            for(int i = 0; i < words.length; i++) {\\n                if(!words[i].contains(Character.toString(c))) \\n                    break;\\n                else if(i == words.length - 1) \\n                    // if it got till here, it means that character was present in all\\n                    list.add(Character.toString(c));\\n                //Replacing character with star (for duplicates)\\n                StringBuilder string = new StringBuilder(words[i]);\\n                string.setCharAt(words[i].indexOf(c), \\'*\\');\\n                words[i] = string.toString();\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405684,
                "title": "easy-java-solution",
                "content": "\\t\\t\\t\\t\\n```\\n    public List<String> commonChars(String[] words) {\\n        int[][] characters = new int[words.length][26];\\n        for(int i = 0; i<words[0].length(); i++){\\n            characters[0][words[0].charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 1; i<words.length; i++){\\n            int[] array = characters[i - 1];\\n            for(char ch: words[i].toCharArray()){\\n                if(array[ch - \\'a\\'] > 0){\\n                    characters[i][ch - \\'a\\']++;\\n                    array[ch - \\'a\\']--;\\n                }\\n            }\\n        }\\n        List<String> answer = new ArrayList<>();\\n        for(int i = 0; i<26; i++){\\n            while(characters[words.length - 1][i]-- > 0){\\n                answer.add(String.valueOf((char)(i + \\'a\\')));\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> commonChars(String[] words) {\\n        int[][] characters = new int[words.length][26];\\n        for(int i = 0; i<words[0].length(); i++){\\n            characters[0][words[0].charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 1; i<words.length; i++){\\n            int[] array = characters[i - 1];\\n            for(char ch: words[i].toCharArray()){\\n                if(array[ch - \\'a\\'] > 0){\\n                    characters[i][ch - \\'a\\']++;\\n                    array[ch - \\'a\\']--;\\n                }\\n            }\\n        }\\n        List<String> answer = new ArrayList<>();\\n        for(int i = 0; i<26; i++){\\n            while(characters[words.length - 1][i]-- > 0){\\n                answer.add(String.valueOf((char)(i + \\'a\\')));\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1381570,
                "title": "dynamic-programming-approach",
                "content": "\\t # dynamic programming\\n\\t\\tdp = [[]] * len(words)\\n\\t\\tdp[0] = words[0]\\n\\t\\t\\n        for i in range(1, len(words)):\\n            dp[i-1] = Counter(dp[i-1])\\n            chars = []\\n            for char in words[i]:\\n                if char in dp[i-1] and dp[i-1][char] > 0:\\n                    chars.append(char)\\n                    dp[i-1][char] -= 1\\n                dp[i] = chars\\n                \\n        return dp[-1]\\n        \\nThe logic is to use the common characters in the previous element, and extract the common character for the current element, at the end return the last item of the dp",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\t # dynamic programming\\n\\t\\tdp = [[]] * len(words)\\n\\t\\tdp[0] = words[0]\\n\\t\\t\\n        for i in range(1, len(words)):\\n            dp[i-1] = Counter(dp[i-1])\\n            chars = []\\n            for char in words[i]:\\n                if char in dp[i-1] and dp[i-1][char] > 0:\\n                    chars.append(char)\\n                    dp[i-1][char] -= 1\\n                dp[i] = chars\\n                \\n        return dp[-1]\\n        \\nThe logic is to use the common characters in the previous element, and extract the common character for the current element, at the end return the last item of the dp",
                "codeTag": "Unknown"
            },
            {
                "id": 1316906,
                "title": "simple-and-easy-c-approach-using-maps",
                "content": "```\\n vector<string> commonChars(vector<string>& words) {\\n        vector<string> ans;\\n        \\n        map<char,int> mp;\\n        \\n       for(int i=0;i<words[0].size();i++){\\n           mp[words[0][i]]++;\\n       }\\n\\n        \\n        for(int i=1;i<words.size();i++){\\n            map<char,int>  mp1;\\n            \\n            for(int j=0;j<words[i].size();j++){\\n                mp1[words[i][j]]++;\\n            }\\n            \\n            for(auto x: mp){\\n                if(mp1.find(x.first)!=mp.end()){\\n                    \\n                    if(mp1[x.first]!=x.second){\\n                     \\n                        mp[x.first]=min(x.second, mp1[x.first]);\\n                    }\\n                }\\n                else{\\n                     mp.erase(mp.find(x.first));\\n                }\\n            }\\n         \\n         \\n        }\\n\\n            for(auto x: mp){\\n                while(x.second--){\\n                    string s(1, x.first);\\n                    ans.push_back(s);\\n                }\\n                \\n            }\\n            \\n           return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<string> commonChars(vector<string>& words) {\\n        vector<string> ans;\\n        \\n        map<char,int> mp;\\n        \\n       for(int i=0;i<words[0].size();i++){\\n           mp[words[0][i]]++;\\n       }\\n\\n        \\n        for(int i=1;i<words.size();i++){\\n            map<char,int>  mp1;\\n            \\n            for(int j=0;j<words[i].size();j++){\\n                mp1[words[i][j]]++;\\n            }\\n            \\n            for(auto x: mp){\\n                if(mp1.find(x.first)!=mp.end()){\\n                    \\n                    if(mp1[x.first]!=x.second){\\n                     \\n                        mp[x.first]=min(x.second, mp1[x.first]);\\n                    }\\n                }\\n                else{\\n                     mp.erase(mp.find(x.first));\\n                }\\n            }\\n         \\n         \\n        }\\n\\n            for(auto x: mp){\\n                while(x.second--){\\n                    string s(1, x.first);\\n                    ans.push_back(s);\\n                }\\n                \\n            }\\n            \\n           return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1278939,
                "title": "java-most-easy-solution-5ms",
                "content": "```\\n    public List<String> commonChars(String[] words) {\\n        List<String> result = new ArrayList<>();\\n\\n        for (char c : words[0].toCharArray()) {\\n            boolean isCommon = true;\\n            for (int i = 1; i < words.length; i++) {\\n                if (words[i].indexOf(c) == -1) {\\n                    isCommon = false;\\n                    break;\\n                }\\n            }\\n            if (isCommon) {\\n                result.add(String.valueOf(c));\\n                for (int i = 1; i < words.length; i++) {\\n                    StringBuilder sb = new StringBuilder(words[i]);\\n                    sb.deleteCharAt(words[i].indexOf(c));\\n                    words[i] = sb.toString();\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> commonChars(String[] words) {\\n        List<String> result = new ArrayList<>();\\n\\n        for (char c : words[0].toCharArray()) {\\n            boolean isCommon = true;\\n            for (int i = 1; i < words.length; i++) {\\n                if (words[i].indexOf(c) == -1) {\\n                    isCommon = false;\\n                    break;\\n                }\\n            }\\n            if (isCommon) {\\n                result.add(String.valueOf(c));\\n                for (int i = 1; i < words.length; i++) {\\n                    StringBuilder sb = new StringBuilder(words[i]);\\n                    sb.deleteCharAt(words[i].indexOf(c));\\n                    words[i] = sb.toString();\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1930540,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1834515,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1948693,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1997766,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1999640,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 2035727,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1999711,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1988614,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 2053054,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1873594,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1930540,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1834515,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1948693,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1997766,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1999640,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 2035727,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1999711,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1988614,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 2053054,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1873594,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            }
        ]
    },
    {
        "title": "Probability of a Two Boxes Having The Same Number of Distinct Balls",
        "question_content": "<p>Given <code>2n</code> balls of <code>k</code> distinct colors. You will be given an integer array <code>balls</code> of size <code>k</code> where <code>balls[i]</code> is the number of balls of color <code>i</code>.</p>\n\n<p>All the balls will be <strong>shuffled uniformly at random</strong>, then we will distribute the first <code>n</code> balls to the first box and the remaining <code>n</code> balls to the other box (Please read the explanation of the second example carefully).</p>\n\n<p>Please note that the two boxes are considered different. For example, if we have two balls of colors <code>a</code> and <code>b</code>, and two boxes <code>[]</code> and <code>()</code>, then the distribution <code>[a] (b)</code> is considered different than the distribution <code>[b] (a) </code>(Please read the explanation of the first example carefully).</p>\n\n<p>Return<em> the probability</em> that the two boxes have the same number of distinct balls. Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted as correct.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> balls = [1,1]\n<strong>Output:</strong> 1.00000\n<strong>Explanation:</strong> Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> balls = [2,1,1]\n<strong>Output:</strong> 0.66667\n<strong>Explanation:</strong> We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> balls = [1,2,1,2]\n<strong>Output:</strong> 0.60000\n<strong>Explanation:</strong> The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= balls.length &lt;= 8</code></li>\n\t<li><code>1 &lt;= balls[i] &lt;= 6</code></li>\n\t<li><code>sum(balls)</code> is even.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 661723,
                "title": "struggling-with-probability-problems-read-this",
                "content": "When it comes to generic software engineering interview questions, probability problems are not as hard as they seem. Their solutions are often the same as your average backtracking (and DP if it\\'s a harder problem) problem.\\n\\nLet\\'s define the following terms:\\nA *permutation* is some unique combination of the 2N-length array. If our input is [2,1,1] like in the second test case, an example permutation is [2 / 1,1,3].\\n\\nA *valid permutation* is a permutation that can be considered in our answer, but may or may not meet the specific requirements of what we\\'re counting. The above example for a permutation is not a *valid* permutation, because the number of balls in the first half is not equal to the number of balls in the second half. We want to divide the array in half, after all - the above permutation doesn\\'t do that. An example of a valid permutation is [1, 1 / 2, 3].\\n\\nA *successful* permutation is a valid permutation that meets the requirements of what we\\'re counting. The above example of a valid permutation isn\\'t *successful* because the number of unique balls in the first half (1) isn\\'t the same as the number of unique balls in the second half (2). An example of a *successful* permutation is [1, 2 / 1, 3].\\n\\nA simple strategy, which actually works here, is to just count the number of \"successful\" permutations and divide it by the number of \"valid\" permutations. I do this in my solution below.\\n\\nPlease reach out for any questions; I typed this up quickly, so there may be gaps I didn\\'t explain. It makes me sad to see candidates mess up on probability questions like this, because if you know how to backtrack, you can solve problems like this. Good luck in your future interviews!\\n\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from math import factorial\\n        \\n        firstHalf = {}\\n        secondHalf = {}\\n        \\n        # successful permutations\\n        self.good = 0\\n        # total number of valid permutations\\n        self.all = 0\\n        def dfs(i):\\n            if i == len(balls):\\n                s1 = sum(firstHalf.values())\\n                s2 = sum(secondHalf.values())\\n                # invalid permutation if the total number of balls in each\\n                # half is not equal, because we only consider permutations\\n                # with equal balls in each half\\n                if s1 != s2:\\n                    return 0\\n                \\n                # Get the number of permutations in the FIRST HALF of the result array.\\n\\t\\t\\t\\t# If you don\\'t understand, search \"geeks for geeks number of distinct permutations\" on Google.\\n                prod1 = 1\\n                for k in firstHalf:\\n                    prod1 *= factorial(firstHalf[k])\\n                p1 = factorial(s1) / prod1\\n                \\n                # Same as above but for the SECOND HALF of the array.\\n                prod2 = 1\\n                for k in secondHalf:\\n                    prod2 *= factorial(secondHalf[k])\\n                p2 = factorial(s2) / prod2\\n                \\n                # We can use each permutation as many times as possible since the problem\\n                # tells us they\\'re all unique regardless of order. So [1, 2 / 1, 3] is separate\\n                # from [2, 1 / 3, 1].\\n                self.all += p1 * p2\\n                # only add to the \"successful\" permutations if we meet our success criteria: equal number \\n                # of unique balls in each half of the array.\\n                self.good += p1 * p2 if len(firstHalf) == len(secondHalf) else 0\\n            else:\\n                # This will calculate every permutation of splitting the number of balls of color i\\n                # into each half. We So if there are 3 balls of color i, the iterations will split like this,\\n                # in order:\\n                # 0 -> first: 3, second: 0\\n                # 1 -> first: 2, second: 1\\n                # 2 -> first: 1, second: 2\\n                # 3 -> first: 0, second: 3\\n                firstHalf[i] = balls[i]\\n                for _ in range(((balls[i])) + 1):\\n                    dfs(i + 1)\\n                    \\n                    if i in firstHalf:\\n                        firstHalf[i] -= 1\\n                        if firstHalf[i] == 0:\\n                            del firstHalf[i]\\n                    secondHalf[i] = secondHalf.get(i, 0) + 1\\n                    \\n                del secondHalf[i]\\n                \\n        dfs(0)\\n        print(self.good, self.all)\\n        # if we have X good permutations and Y total permutations, the odds that a randomly\\n        # selected permutation will be \"good\" is X / Y AS LONG AS each permutation is equally likely.\\n        return self.good / self.all\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from math import factorial\\n        \\n        firstHalf = {}\\n        secondHalf = {}\\n        \\n        # successful permutations\\n        self.good = 0\\n        # total number of valid permutations\\n        self.all = 0\\n        def dfs(i):\\n            if i == len(balls):\\n                s1 = sum(firstHalf.values())\\n                s2 = sum(secondHalf.values())\\n                # invalid permutation if the total number of balls in each\\n                # half is not equal, because we only consider permutations\\n                # with equal balls in each half\\n                if s1 != s2:\\n                    return 0\\n                \\n                # Get the number of permutations in the FIRST HALF of the result array.\\n\\t\\t\\t\\t# If you don\\'t understand, search \"geeks for geeks number of distinct permutations\" on Google.\\n                prod1 = 1\\n                for k in firstHalf:\\n                    prod1 *= factorial(firstHalf[k])\\n                p1 = factorial(s1) / prod1\\n                \\n                # Same as above but for the SECOND HALF of the array.\\n                prod2 = 1\\n                for k in secondHalf:\\n                    prod2 *= factorial(secondHalf[k])\\n                p2 = factorial(s2) / prod2\\n                \\n                # We can use each permutation as many times as possible since the problem\\n                # tells us they\\'re all unique regardless of order. So [1, 2 / 1, 3] is separate\\n                # from [2, 1 / 3, 1].\\n                self.all += p1 * p2\\n                # only add to the \"successful\" permutations if we meet our success criteria: equal number \\n                # of unique balls in each half of the array.\\n                self.good += p1 * p2 if len(firstHalf) == len(secondHalf) else 0\\n            else:\\n                # This will calculate every permutation of splitting the number of balls of color i\\n                # into each half. We So if there are 3 balls of color i, the iterations will split like this,\\n                # in order:\\n                # 0 -> first: 3, second: 0\\n                # 1 -> first: 2, second: 1\\n                # 2 -> first: 1, second: 2\\n                # 3 -> first: 0, second: 3\\n                firstHalf[i] = balls[i]\\n                for _ in range(((balls[i])) + 1):\\n                    dfs(i + 1)\\n                    \\n                    if i in firstHalf:\\n                        firstHalf[i] -= 1\\n                        if firstHalf[i] == 0:\\n                            del firstHalf[i]\\n                    secondHalf[i] = secondHalf.get(i, 0) + 1\\n                    \\n                del secondHalf[i]\\n                \\n        dfs(0)\\n        print(self.good, self.all)\\n        # if we have X good permutations and Y total permutations, the odds that a randomly\\n        # selected permutation will be \"good\" is X / Y AS LONG AS each permutation is equally likely.\\n        return self.good / self.all\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661757,
                "title": "python-10-lines-90-multionomial-coefficients-explained",
                "content": "This is an interesting mathematical problem. Denote by `k` different number of balls and by `B1, ..., Bk` number of balls of each type. Then we need to put into first box `X1, ..., Xk` balls and into the second `B1 - X1, ..., Bk - Xk`. We need to check 2 properties:\\n1. Number of balls in two boxes are equal.\\n2. Number of ball types in each boxes are equal.\\n\\nThen we need to evaluate total number of possibilites for boxes, using **Multinomial coefficients**, (see https://en.wikipedia.org/wiki/Multinomial_theorem for more details) and divide it by total number of possibilities. Let us work through example: `B1, B2, B3 = 1, 2, 3`, then all possible ways to put into boxes are:\\n1. (0, 0, 0) and (1, 2, 3)\\n2. (0, 0, 1) and (1, 2, 2)\\n3. (0, 0, 2) and (1, 2, 1)\\n\\n...\\n\\n22. (1, 2, 1) and (0, 0, 2)\\n23. (1, 2, 2) and (0, 0, 1)\\n24. (1, 2, 3) and (0, 0, 0)\\n\\nBut only for 2 of them holds the above two properties:\\n1. (0, 2, 1) and (1, 0, 2)\\n2. (1, 0, 2) and (0, 2, 1)\\n\\nSo, the answer in this case will be `[M(0, 2, 1) * M(1, 0, 2) + M(1, 0, 2) * M(0, 2, 1)]/ M(1, 2, 3)`\\n\\n**Complexity** We check all possible `(B1+1) * ... * (Bk+1)` splits into two boxes, and then evaluate number of zeros and multinomial coefficientes, so it is `O(B1 ... Bk * k)`\\n\\n**Update** There is more elegant way to use multinomial coefficients, which I updated.\\n\\n```\\nclass Solution:\\n    def multinomial(self, n):\\n        return factorial(sum(n))/prod([factorial(i) for i in n])\\n  \\n    def getProbability(self, balls):\\n        k, n, Q = len(balls), sum(balls)// 2, 0\\n        arrays = [range(0,i+1) for i in balls]\\n        t = list(product(*arrays))\\n        for i in range(len(t)):\\n            if sum(t[i]) == n and t[i].count(0) == t[-i-1].count(0):\\n                Q += self.multinomial(t[i]) * self.multinomial(t[-i-1]) \\n\\n        return Q / self.multinomial(list(balls))     \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote**!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def multinomial(self, n):\\n        return factorial(sum(n))/prod([factorial(i) for i in n])\\n  \\n    def getProbability(self, balls):\\n        k, n, Q = len(balls), sum(balls)// 2, 0\\n        arrays = [range(0,i+1) for i in balls]\\n        t = list(product(*arrays))\\n        for i in range(len(t)):\\n            if sum(t[i]) == n and t[i].count(0) == t[-i-1].count(0):\\n                Q += self.multinomial(t[i]) * self.multinomial(t[-i-1]) \\n\\n        return Q / self.multinomial(list(balls))     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 661730,
                "title": "c-backtrack-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nFirst, compute the total number of distinct shuffles. \\n\\n```\\ntotal = factorial(sum( A[i] | 0 <= i < k )) / (factorial(A[0]) * factorial(A[1]) * ... * factorial(A[k-1]))\\n```\\n\\nwhere `factorial(x)` is the number of permutations of `x` different items. For example, `factorial(3) = 1 * 2 * 3 = 6`.\\n\\nI denote the right-hand side of the above equation as `perm(A)` where `A` is an array of numbers. We\\'ll need it later.\\n\\nThen we need to compute the count of valid splits. Assume array `a` and `b` is a split of `A`, then:\\n\\n* `size(a) == size(b) == size(A) == k`\\n* For each `0 <= i < k`, `a[i] + b[i] = A[i]`\\n\\nFor example, if `A = [1, 2, 3]`, then `a = [1, 0, 1]`, `b = [0, 2, 2]` is a split of `A`.\\n\\nA split is valid if:\\n* Each of them contains half of the balls: `sum( a[i] | 0 <= i < k ) == sum( b[i] | 0 <= i < k ) == sum( A[i] | 0 <= i < k ) / 2`\\n* They contain equal number of distinct colors: `count(a) == count(b)` where `count(x)` is the number of positive numbers in array `x`.\\n\\nFor example, if `A = [1, 1, 2]`, then `a = [1, 0, 1]`, `b = [0, 1, 1]` is a *valid* split of `A`.\\n\\nSo we can use DFS to get different valid splits of `A`. For each valid split `a, b`, the count of distinct permutation of the split is `perm(a) * perm(b)` .\\n\\nThe answer is the sum of `perm(a) * perm(b)` of all valid splits `a, b` divided by `total`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-191/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/\\n// Author: github.com/lzl124631x\\n// Time: O((M+1)^K * MK) where M is the maximum number of A[i]. It\\'s O(7^8 * 6 * 8) given the constraints of this problem.\\n// Space: O(K)\\nclass Solution {\\n    double perm(vector<int> &A) {\\n        double ans = 1;\\n        for (int i = 0, j = 1; i < A.size(); ++i) {\\n            for (int k = 1; k <= A[i]; ++k, ++j) ans = ans * j / k; \\n        }\\n        return ans;\\n    }\\n    int sum = 0;\\n    double dfs(vector<int> &A, vector<int>& a, vector<int> &b, int i, int sa, int sb) {\\n        if (sa > sum / 2 || sb > sum / 2) return 0; // invalid split because either `a` or `b` takes up more than half of the balls.\\n        if (i == A.size()) {\\n            int ca = 0, cb = 0;\\n            for (int j = 0; j < A.size(); ++j) ca += a[j] > 0;\\n            for (int j = 0; j < A.size(); ++j) cb += b[j] > 0;\\n            if (ca != cb) return 0; // invalid split because `a` and `b` don\\'t have the same number of distinct colors.\\n            return perm(a) * perm(b);\\n        }\\n        double ans = 0;\\n        for (int j = 0; j <= A[i]; ++j) { // try different splits at the `i`-th element, i.e. a[i] + b[i] = A[i]\\n            a[i] = j;\\n            b[i] = A[i] - j;\\n            ans += dfs(A, a, b, i + 1, sa + a[i], sb + b[i]);\\n        }\\n        return ans;\\n    }\\npublic:\\n    double getProbability(vector<int>& A) {\\n        sum = accumulate(begin(A), end(A), 0);\\n        vector<int> a(A.size()), b(A.size());\\n        return dfs(A, a, b, 0, 0, 0) / perm(A);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntotal = factorial(sum( A[i] | 0 <= i < k )) / (factorial(A[0]) * factorial(A[1]) * ... * factorial(A[k-1]))\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-191/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/\\n// Author: github.com/lzl124631x\\n// Time: O((M+1)^K * MK) where M is the maximum number of A[i]. It\\'s O(7^8 * 6 * 8) given the constraints of this problem.\\n// Space: O(K)\\nclass Solution {\\n    double perm(vector<int> &A) {\\n        double ans = 1;\\n        for (int i = 0, j = 1; i < A.size(); ++i) {\\n            for (int k = 1; k <= A[i]; ++k, ++j) ans = ans * j / k; \\n        }\\n        return ans;\\n    }\\n    int sum = 0;\\n    double dfs(vector<int> &A, vector<int>& a, vector<int> &b, int i, int sa, int sb) {\\n        if (sa > sum / 2 || sb > sum / 2) return 0; // invalid split because either `a` or `b` takes up more than half of the balls.\\n        if (i == A.size()) {\\n            int ca = 0, cb = 0;\\n            for (int j = 0; j < A.size(); ++j) ca += a[j] > 0;\\n            for (int j = 0; j < A.size(); ++j) cb += b[j] > 0;\\n            if (ca != cb) return 0; // invalid split because `a` and `b` don\\'t have the same number of distinct colors.\\n            return perm(a) * perm(b);\\n        }\\n        double ans = 0;\\n        for (int j = 0; j <= A[i]; ++j) { // try different splits at the `i`-th element, i.e. a[i] + b[i] = A[i]\\n            a[i] = j;\\n            b[i] = A[i] - j;\\n            ans += dfs(A, a, b, i + 1, sa + a[i], sb + b[i]);\\n        }\\n        return ans;\\n    }\\npublic:\\n    double getProbability(vector<int>& A) {\\n        sum = accumulate(begin(A), end(A), 0);\\n        vector<int> a(A.size()), b(A.size());\\n        return dfs(A, a, b, 0, 0, 0) / perm(A);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661648,
                "title": "java-heavily-commented-simple-solution",
                "content": "Idea : `Probability = valid cases/all cases`\\n\\ncredits to @svll for identifying issues with code.\\n\\nExample: [2, 1, 1]\\nfor first ball, we can put both ball in first bin and 0 ball in second bin OR we can put 1 ball in first bin, second ball in 2nd bin OR we can put both in second bin\\n\\nfor second ball, we can put ball in first bin and 0 ball in second bin, similarly, we can put 1 ball in second bin.\\n\\nsame thing with the third ball\\n\\nTry all possible permutations recursively. And, in the end check, if there are equal number of distinct balls in both bins or not.\\n\\n```\\nclass Solution {\\n    public double getProbability(int[] balls) {\\n        int sum = 0;\\n        for (int i = 0; i < balls.length; ++i) sum += balls[i];\\n        //Get all possible cases where we select same number of balls in both bins\\n        double all = allCases(balls, 0, 0, 0, 0, 0, sum);\\n        //Get all possible cases where we select same number of balls in both bins + we select same number of distinct balls\\n        double valid = casesWithEqualDistinctBalls(balls, 0, 0, 0, 0, 0, sum);\\n\\n        return ((1.0) * valid / all);\\n    }\\n\\n    // disF = distinct balls in first bin\\n    // disS = distinct balls in second bin\\n    // f = number of balls in first bin\\n    // s = number of balls in second bin\\n    public double allCases(int[] b, int pos, int f, int s, int disF, int disS, int sum) {\\n        if (pos == b.length) {\\n            // for all cases, we just need to check if both bins have same number of balls or not\\n            if (f == s) return fact(sum / 2) * fact(sum / 2); //numerator of our permutations\\n            return 0;\\n        }\\n        // we put all balls in second bin\\n        double answer = 1.0 * allCases(b, pos + 1, f, s + b[pos], disF, disS + 1, sum) / fact(b[pos]);\\n\\n        // we put all balls in first bin\\n        answer += 1.0 * allCases(b, pos + 1, f + b[pos], s, disF + 1, disS, sum) / fact(b[pos]);\\n        for (int i = 1; i < b[pos]; ++i) {\\n            answer += 1.0 * (allCases(b, pos + 1, f + i, s + b[pos] - i, disF + 1, disS + 1, sum) / (fact(i) * fact(b[pos] - i))); // We put i ball in bin and b[pos] - i in another, now since all of them are of same color, we need to divide permutation by  (fact(i) * fact(b[pos]-i)), this acts as a denominator of our permutations\\n        }\\n        return answer;\\n\\n    }\\n\\n    // disF = distinct balls in first bin\\n    // disS = distinct balls in second bin\\n    // f = number of balls in first bin\\n    // s = number of balls in second bin\\n    public double casesWithEqualDistinctBalls(int[] b, int pos, int f, int s, int disF, int disS, int sum) {\\n        if (pos == b.length) {\\n            // we  need to check if both bins have same number of balls or not + number of distinct balls in each bin should be equal\\n            if (f == s && disF == disS) return fact(sum / 2) * fact(sum / 2); //numerator of our permutations\\n            return 0;\\n        }\\n\\n        // we put all balls in second bin\\n        double answer = 1.0 * casesWithEqualDistinctBalls(b, pos + 1, f, s + b[pos], disF, disS + 1, sum) / fact(b[pos]);\\n\\n        // we put all balls in first bin\\n        answer += 1.0 * casesWithEqualDistinctBalls(b, pos + 1, f + b[pos], s, disF + 1, disS, sum) / fact(b[pos]);\\n        for (int i = 1; i < b[pos]; ++i) {\\n            answer += 1.0 * (casesWithEqualDistinctBalls(b, pos + 1, f + i, s + b[pos] - i, disF + 1, disS + 1, sum) / (fact(i) * fact(b[pos] - i))); // We put i ball in bin and b[pos] - i in another, now since all of them are of same color, we need to divide permutation by  (fact(i) * fact(b[pos]-i)), this acts as a denominator of our permutations\\n        }\\n        return answer;\\n\\n    }\\n\\n    double fact(double n) {\\n        double res = 1;\\n        for (int i = 2; i <= n; i++)\\n            res = res * i;\\n        return res;\\n    }\\n}\\n```\\n\\nComplexity: There can be total of (8 * 6) balls with 8 distinct. Complexity of recursion is f * s * disF * disS = O(48 * 48 * 8 * 8)\\n\\nI understand that we can optimize this to a single function. But, it would make code difficult to understand for you.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double getProbability(int[] balls) {\\n        int sum = 0;\\n        for (int i = 0; i < balls.length; ++i) sum += balls[i];\\n        //Get all possible cases where we select same number of balls in both bins\\n        double all = allCases(balls, 0, 0, 0, 0, 0, sum);\\n        //Get all possible cases where we select same number of balls in both bins + we select same number of distinct balls\\n        double valid = casesWithEqualDistinctBalls(balls, 0, 0, 0, 0, 0, sum);\\n\\n        return ((1.0) * valid / all);\\n    }\\n\\n    // disF = distinct balls in first bin\\n    // disS = distinct balls in second bin\\n    // f = number of balls in first bin\\n    // s = number of balls in second bin\\n    public double allCases(int[] b, int pos, int f, int s, int disF, int disS, int sum) {\\n        if (pos == b.length) {\\n            // for all cases, we just need to check if both bins have same number of balls or not\\n            if (f == s) return fact(sum / 2) * fact(sum / 2); //numerator of our permutations\\n            return 0;\\n        }\\n        // we put all balls in second bin\\n        double answer = 1.0 * allCases(b, pos + 1, f, s + b[pos], disF, disS + 1, sum) / fact(b[pos]);\\n\\n        // we put all balls in first bin\\n        answer += 1.0 * allCases(b, pos + 1, f + b[pos], s, disF + 1, disS, sum) / fact(b[pos]);\\n        for (int i = 1; i < b[pos]; ++i) {\\n            answer += 1.0 * (allCases(b, pos + 1, f + i, s + b[pos] - i, disF + 1, disS + 1, sum) / (fact(i) * fact(b[pos] - i))); // We put i ball in bin and b[pos] - i in another, now since all of them are of same color, we need to divide permutation by  (fact(i) * fact(b[pos]-i)), this acts as a denominator of our permutations\\n        }\\n        return answer;\\n\\n    }\\n\\n    // disF = distinct balls in first bin\\n    // disS = distinct balls in second bin\\n    // f = number of balls in first bin\\n    // s = number of balls in second bin\\n    public double casesWithEqualDistinctBalls(int[] b, int pos, int f, int s, int disF, int disS, int sum) {\\n        if (pos == b.length) {\\n            // we  need to check if both bins have same number of balls or not + number of distinct balls in each bin should be equal\\n            if (f == s && disF == disS) return fact(sum / 2) * fact(sum / 2); //numerator of our permutations\\n            return 0;\\n        }\\n\\n        // we put all balls in second bin\\n        double answer = 1.0 * casesWithEqualDistinctBalls(b, pos + 1, f, s + b[pos], disF, disS + 1, sum) / fact(b[pos]);\\n\\n        // we put all balls in first bin\\n        answer += 1.0 * casesWithEqualDistinctBalls(b, pos + 1, f + b[pos], s, disF + 1, disS, sum) / fact(b[pos]);\\n        for (int i = 1; i < b[pos]; ++i) {\\n            answer += 1.0 * (casesWithEqualDistinctBalls(b, pos + 1, f + i, s + b[pos] - i, disF + 1, disS + 1, sum) / (fact(i) * fact(b[pos] - i))); // We put i ball in bin and b[pos] - i in another, now since all of them are of same color, we need to divide permutation by  (fact(i) * fact(b[pos]-i)), this acts as a denominator of our permutations\\n        }\\n        return answer;\\n\\n    }\\n\\n    double fact(double n) {\\n        double res = 1;\\n        for (int i = 2; i <= n; i++)\\n            res = res * i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662154,
                "title": "c-24ms-permutations-of-combination",
                "content": "I did not solve this problem during the context - did not read the description carefully, again!! I missed that the order of balls matters, e.g. [1,1 / 2,3] and [1,1 / 3,2] are two different shuffles. Then, I got stuck by trying to make integer (or long) computation work... totally forgot we can just use double :( I think that I could have done better if I did a quantitative analysis first (see the Complexity Analysis section below).\\n\\nThe idea is that processing each permutation (order matters) is too time-consuming. Instead, we can process each combination (order does not matter) of how balls can be distributed, check if two boxes have the same number of colors, and calculate how many permutations each combination can produce.\\n\\nThe is similar to the other solutions, with a few optimizations:\\n- Track how many balls are left to fill each box as `cnt1` and `cnt2`.\\n- Count different colors in each box as `col1` and `col2`; compare in the end.\\n- The initial/maximum number of permutatons in each box is (n / 2)!\\n- When selecting *m* balls of particular color, we reduce the number of permutations by m!\\n- When both `cnt1` and `cnt2` are zero, `prm1` and `prm2` are permutations in each box.\\n\\t\\t- Number of permutations = (n / 2)! / (m1! * m2! * ... * mk!).\\n\\t\\t- The total number of permutations with two boxes is `prm1 * prm2`.\\n\\n```cpp\\nstatic constexpr int fact[7] = {1, 1, 2, 6, 24, 120, 720};\\ndouble total = 0, match = 0;\\nvoid dfs(vector<int>& balls, int p, int col1, int col2, int cnt1, int cnt2, double prm1, double prm2) { \\n    if (cnt1 == 0 && cnt2 == 0) {\\n        total += prm1 * prm2;\\n        match += (col1 == col2) * prm1 * prm2;\\n    }\\n    else if (cnt1 >= 0 && cnt2 >= 0)\\n        for (int b1 = 0, b2 = balls[p]; b2 >= 0; ++b1, --b2)\\n            dfs(balls, p + 1, col1 + (b1 > 0), col2 + (b2 > 0),\\n                cnt1 - b1, cnt2 - b2, prm1 / fact[b1], prm2 / fact[b2]);\\n}\\ndouble factorial(int n) { return n < 3 ? n : n * factorial(n - 1); }\\ndouble getProbability(vector<int>& balls) {\\n    auto n = accumulate(begin(balls), end(balls), 0);\\n    dfs(balls, 0, 0, 0, n / 2, n / 2, factorial(n / 2), factorial(n / 2));\\n    return match / total;\\n}\\n```\\n**Complexity Analysis**\\nIf we analyze all permutations, the time complexity would be O(k * n! / ((n / k)! ^ k), where *k* is the number of colors and   *n* - the number of the balls. Note that *n / k* represents the number of balls of the same color. With maximum *n* equals 48, and *k* up to 8, we have ~10 ^ 62 / 10 ^ 22 = 10 ^ 40 operations.\\n\\nWith combinations, the number of operations is reduced to O((n / k) ^ k), which is a mere 720 operations with this problem constraints. \\n\\n- Time: O((n / k) ^ k). For each color, we put [0...*n / k*] balls in one box, and the rest in the other box, and repeat this for *k* colors.\\n- Memory: O(k) for the recursion.",
                "solutionTags": [],
                "code": "```cpp\\nstatic constexpr int fact[7] = {1, 1, 2, 6, 24, 120, 720};\\ndouble total = 0, match = 0;\\nvoid dfs(vector<int>& balls, int p, int col1, int col2, int cnt1, int cnt2, double prm1, double prm2) { \\n    if (cnt1 == 0 && cnt2 == 0) {\\n        total += prm1 * prm2;\\n        match += (col1 == col2) * prm1 * prm2;\\n    }\\n    else if (cnt1 >= 0 && cnt2 >= 0)\\n        for (int b1 = 0, b2 = balls[p]; b2 >= 0; ++b1, --b2)\\n            dfs(balls, p + 1, col1 + (b1 > 0), col2 + (b2 > 0),\\n                cnt1 - b1, cnt2 - b2, prm1 / fact[b1], prm2 / fact[b2]);\\n}\\ndouble factorial(int n) { return n < 3 ? n : n * factorial(n - 1); }\\ndouble getProbability(vector<int>& balls) {\\n    auto n = accumulate(begin(balls), end(balls), 0);\\n    dfs(balls, 0, 0, 0, n / 2, n / 2, factorial(n / 2), factorial(n / 2));\\n    return match / total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 665680,
                "title": "java-from-tle-to-1000ms-to-25ms-to-1ms-combination-dp",
                "content": "This is an interesting problem. Not only did I have to brush up my knowledge on permutations/combinations, but also I needed to convert the idea into code. So I wasn\\'t able to finish it during the contest, but after spending some time grinding away at this problem, I want to share what I\\'ve learned to make it 1ms.\\n\\nCredit goes to @uwi. The final solution is from his contest submission. I learned from him and am just trying to explain it here.\\n\\n##### TLDR The key take-aways are:\\n1. This is a combination problem, don\\'t use permutation since it\\'s wasteful; (1000ms)\\n2. Combination table (binomial coefficients) must be pre-calculated to save us from repetitive calculation; (25ms)\\n3. Clever DP design on ball selections is the final trick to bring it down to 1ms.\\n\\n##### Brute Force (TLE)\\nI started with brute force: choose each ball into either the first box or the second, when either box reaches half of the total number of balls, stop and test whether colors are equal. Complexity is O( 2^2n * m ), where n is the target number of balls in each box and m is the number of colors, because for each ball there are 2 options, and finally the color check needs a loop of size m. Code will be skipped \\'cause nobody cares :)\\n\\n##### Combination (1000ms)\\nActually we don\\'t need to know which ball of the same color goes to which box, what we really care is how many combinations are there to pick k balls from n balls of the same color. Complexity becomes O(b^m * n * m). b^m is for recursions, where b is the ball number for each color, n is for computing combinations, the final m is for checking color.\\n```\\nclass Solution {\\n    double equals = 0, ne = 0;\\n    public double getProbability(int[] balls) {\\n        equals = 0;\\n        ne = 0;\\n        int size = 0;\\n        for (int i = 0; i < balls.length; i++) {\\n            size += balls[i];\\n        }\\n        choose(balls, 0, 0, size / 2,  0, new int[balls.length], new int[balls.length], 1);\\n        return equals / (equals + ne);\\n    }\\n\\n    void choose(int[] balls, int size1, int size2, int k, int i, int[] b1, int[] b2, double factor) {\\n        if (size1 > k || size2 > k) return;\\n        if (size1 == k) {\\n            count(b1, balls, factor);\\n            return;\\n        }\\n        if (size2 == k) {\\n            count(b2, balls, factor);\\n            return;\\n        }\\n        for (int j = 0; j <= balls[i]; j++) {\\n            //pick [0-j) of ball i\\n            b1[i] += j;\\n            b2[i] += balls[i] - j;\\n            choose(balls, size1 + j, size2 + balls[i] - j, k, i + 1, b1, b2, factor * combination(j, balls[i]));\\n            b1[i] -= j;\\n            b2[i] -= balls[i] - j;\\n        }\\n    }\\n\\n    double combination(int i, int total) {\\n        return IntStream.rangeClosed(i + 1, total).reduce(1, (a,b) -> a * b) / factorial(total - i);\\n    }\\n\\n    double factorial(int i) {\\n        return IntStream.rangeClosed(1,i).reduce(1, (a,b) -> a * b);\\n    }\\n\\n    void count(int[] b1, int[] balls, double factor) {\\n        int c1 = 0, c2 = 0;\\n        for (int j = 0; j < balls.length; j++) {\\n            c1 += (b1[j] > 0) ? 1 : 0;\\n            c2 += (balls[j] - b1[j] > 0) ? 1 : 0;\\n        }\\n\\n        if (c1 == c2) {\\n            equals += factor;\\n        } else {\\n            ne += factor;\\n        }\\n        return;\\n    }\\n}\\n```\\n\\n##### Cache Combination Table (25ms)\\nIf we keep a combination table, we could improve complexity to O(b^m * m + n^2), where n^2 is for computing combinations.\\n```\\nclass Solution {\\n    double equals = 0;\\n    long[][] binom;\\n    public double getProbability(int[] balls) {\\n        equals = 0;\\n        int size = 0;\\n        for (int i = 0; i < balls.length; i++) {\\n            size += balls[i];\\n        }\\n        binom = getBinom(size, size / 2);\\n        choose(balls, 0, 0, size / 2,  0, new int[balls.length], new int[balls.length], 1);\\n        return equals / binom[size][size/2];\\n    }\\n\\n    void choose(int[] balls, int size1, int size2, int k, int i, int[] b1, int[] b2, double factor) {\\n        if (size1 > k || size2 > k) return;\\n        if (size1 == k) {\\n            count(b1, balls, factor);\\n            return;\\n        }\\n        if (size2 == k) {\\n            count(b2, balls, factor);\\n            return;\\n        }\\n        for (int j = 0; j <= Math.min(balls[i], k - size1); j++) {\\n            //pick [0-j) of ball i\\n            b1[i] += j;\\n            b2[i] += balls[i] - j;\\n            choose(balls, size1 + j, size2 + balls[i] - j, k, i + 1, b1, b2, factor * binom[balls[i]][j]);\\n            b1[i] -= j;\\n            b2[i] -= balls[i] - j;\\n        }\\n    }\\n\\n    long[][] getBinom(int n, int k) {\\n        long[][] binom = new long[n + 1][k + 1];\\n        binom[0][0] = 1;\\n        for (int i = 1; i < n + 1; i++) {\\n            binom[i][0] = 1;\\n            for (int j = 1; j < k + 1; j++) {\\n                binom[i][j] = binom[i - 1][j] + binom[i - 1][j - 1];\\n            }\\n        }\\n        return binom;\\n    }\\n\\n    void count(int[] b1, int[] balls, double factor) {\\n        int c1 = 0, c2 = 0;\\n        for (int j = 0; j < balls.length; j++) {\\n            c1 += (b1[j] > 0) ? 1 : 0;\\n            c2 += (balls[j] - b1[j] > 0) ? 1 : 0;\\n        }\\n\\n        if (c1 == c2) {\\n            equals += factor;\\n        }\\n        return;\\n    }\\n}\\n```\\n\\n##### Bottom-Up DP (1ms)\\nNow let\\'s look at this O(2n * 2m * n + n^2) solution from @uwi. The tricky part is the DP table `double[][] dp = new double[2 * m + 1][S/2 + 1];`, where dp[m][k] saves number of cases with equal number of colors in both boxes and k balls in the first box, and dp[m-x][k] saves number of cases where first box has x less colors, and dp[m+x][k] saves number of cases where first box has x more colors. Because there are m colors altogether, so the first dimension is 2 * m + 1. Initial condition is `dp[m][0] = 1` because with 0 balls, the colors in both boxes are clearly equal.\\n\\n```\\nclass Solution {\\n    public double getProbability(int[] balls) {\\n        int m = balls.length;\\n        int S = 0;\\n        for (int b : balls) S += b;\\n        double[][] C = new double[S + 1][S/2 + 1];\\n        C[0][0] = 1;\\n        for (int i = 1; i < S + 1; i++) {\\n            C[i][0] = 1;\\n            for (int j = 1; j < S / 2 + 1; j++) {\\n                C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\\n            }\\n        }\\n        double[][] dp = new double[2 * m + 1][S/2 + 1];\\n        dp[m][0] = 1;\\n        int sum = 0;\\n        for (int b : balls) {\\n            sum += b;\\n            double[][] ndp = new double[2 * m + 1][S/2 + 1];\\n            for (int i = 0; i <= b; i++) {\\n                for (int j = 0; j < 2 * m + 1; j++) {\\n                    for (int k = 0; k < S/2 + 1; k++) {\\n                        if (dp[j][k] == 0) continue;\\n                        int nk = k + i;\\n                        int nr = sum - nk;\\n                        if (nk <= S/2 && nr <= S/2) {\\n                            int nj = (i == 0) ? j - 1 : (i == b) ? j + 1 : j;\\n                            ndp[nj][nk] += dp[j][k] * C[b][i];\\n                        }\\n                    }\\n                }\\n            }\\n            dp = ndp;\\n        }\\n        return dp[m][S/2] / C[S][S/2];\\n    }\\n}\\n```\\n\\nThis is my first time coming up with such a long post at leetcode. Upvotes and suggestion are greatly appreciated!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    double equals = 0, ne = 0;\\n    public double getProbability(int[] balls) {\\n        equals = 0;\\n        ne = 0;\\n        int size = 0;\\n        for (int i = 0; i < balls.length; i++) {\\n            size += balls[i];\\n        }\\n        choose(balls, 0, 0, size / 2,  0, new int[balls.length], new int[balls.length], 1);\\n        return equals / (equals + ne);\\n    }\\n\\n    void choose(int[] balls, int size1, int size2, int k, int i, int[] b1, int[] b2, double factor) {\\n        if (size1 > k || size2 > k) return;\\n        if (size1 == k) {\\n            count(b1, balls, factor);\\n            return;\\n        }\\n        if (size2 == k) {\\n            count(b2, balls, factor);\\n            return;\\n        }\\n        for (int j = 0; j <= balls[i]; j++) {\\n            //pick [0-j) of ball i\\n            b1[i] += j;\\n            b2[i] += balls[i] - j;\\n            choose(balls, size1 + j, size2 + balls[i] - j, k, i + 1, b1, b2, factor * combination(j, balls[i]));\\n            b1[i] -= j;\\n            b2[i] -= balls[i] - j;\\n        }\\n    }\\n\\n    double combination(int i, int total) {\\n        return IntStream.rangeClosed(i + 1, total).reduce(1, (a,b) -> a * b) / factorial(total - i);\\n    }\\n\\n    double factorial(int i) {\\n        return IntStream.rangeClosed(1,i).reduce(1, (a,b) -> a * b);\\n    }\\n\\n    void count(int[] b1, int[] balls, double factor) {\\n        int c1 = 0, c2 = 0;\\n        for (int j = 0; j < balls.length; j++) {\\n            c1 += (b1[j] > 0) ? 1 : 0;\\n            c2 += (balls[j] - b1[j] > 0) ? 1 : 0;\\n        }\\n\\n        if (c1 == c2) {\\n            equals += factor;\\n        } else {\\n            ne += factor;\\n        }\\n        return;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    double equals = 0;\\n    long[][] binom;\\n    public double getProbability(int[] balls) {\\n        equals = 0;\\n        int size = 0;\\n        for (int i = 0; i < balls.length; i++) {\\n            size += balls[i];\\n        }\\n        binom = getBinom(size, size / 2);\\n        choose(balls, 0, 0, size / 2,  0, new int[balls.length], new int[balls.length], 1);\\n        return equals / binom[size][size/2];\\n    }\\n\\n    void choose(int[] balls, int size1, int size2, int k, int i, int[] b1, int[] b2, double factor) {\\n        if (size1 > k || size2 > k) return;\\n        if (size1 == k) {\\n            count(b1, balls, factor);\\n            return;\\n        }\\n        if (size2 == k) {\\n            count(b2, balls, factor);\\n            return;\\n        }\\n        for (int j = 0; j <= Math.min(balls[i], k - size1); j++) {\\n            //pick [0-j) of ball i\\n            b1[i] += j;\\n            b2[i] += balls[i] - j;\\n            choose(balls, size1 + j, size2 + balls[i] - j, k, i + 1, b1, b2, factor * binom[balls[i]][j]);\\n            b1[i] -= j;\\n            b2[i] -= balls[i] - j;\\n        }\\n    }\\n\\n    long[][] getBinom(int n, int k) {\\n        long[][] binom = new long[n + 1][k + 1];\\n        binom[0][0] = 1;\\n        for (int i = 1; i < n + 1; i++) {\\n            binom[i][0] = 1;\\n            for (int j = 1; j < k + 1; j++) {\\n                binom[i][j] = binom[i - 1][j] + binom[i - 1][j - 1];\\n            }\\n        }\\n        return binom;\\n    }\\n\\n    void count(int[] b1, int[] balls, double factor) {\\n        int c1 = 0, c2 = 0;\\n        for (int j = 0; j < balls.length; j++) {\\n            c1 += (b1[j] > 0) ? 1 : 0;\\n            c2 += (balls[j] - b1[j] > 0) ? 1 : 0;\\n        }\\n\\n        if (c1 == c2) {\\n            equals += factor;\\n        }\\n        return;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double getProbability(int[] balls) {\\n        int m = balls.length;\\n        int S = 0;\\n        for (int b : balls) S += b;\\n        double[][] C = new double[S + 1][S/2 + 1];\\n        C[0][0] = 1;\\n        for (int i = 1; i < S + 1; i++) {\\n            C[i][0] = 1;\\n            for (int j = 1; j < S / 2 + 1; j++) {\\n                C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\\n            }\\n        }\\n        double[][] dp = new double[2 * m + 1][S/2 + 1];\\n        dp[m][0] = 1;\\n        int sum = 0;\\n        for (int b : balls) {\\n            sum += b;\\n            double[][] ndp = new double[2 * m + 1][S/2 + 1];\\n            for (int i = 0; i <= b; i++) {\\n                for (int j = 0; j < 2 * m + 1; j++) {\\n                    for (int k = 0; k < S/2 + 1; k++) {\\n                        if (dp[j][k] == 0) continue;\\n                        int nk = k + i;\\n                        int nr = sum - nk;\\n                        if (nk <= S/2 && nr <= S/2) {\\n                            int nj = (i == 0) ? j - 1 : (i == b) ? j + 1 : j;\\n                            ndp[nj][nk] += dp[j][k] * C[b][i];\\n                        }\\n                    }\\n                }\\n            }\\n            dp = ndp;\\n        }\\n        return dp[m][S/2] / C[S][S/2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661706,
                "title": "python-dp",
                "content": "probability = number of combinations satisfy the problem / number of all combinations\\n\\nnumber of all combinations = comb(sum(balls), sum(balls)/2)\\n\\nThen we use DP to calculate number of combinations satisfy the problem\\n\\nWe maintain a status dictionary, after put all balls of the same color into boxA and boxB in one time(there are many ways to put), we update the dictionary.\\n\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from scipy.special import comb # help to calculate combination numbers\\n        \\n        sm = sum(balls)\\n        number_of_combinations = comb(sm, sm//2) # \\n        \\n        def number_of_ways_to_pick(n): # there are n balls of color-a, we want to pick some number of them and put them into boxA, and others into boxB\\n            d = Counter() # key: number of balls put into boxA, value: number of such combinations\\n            for i in range(n+1):\\n                d[i] = comb(n,i)\\n            return d\\n            \\n        status = Counter()\\n        status[(0,0,0,0)] = 1 \\n        #key: num of balls in boxA, num of balls in boxB, different colors in boxA, different colors in boxB; value: number of such combinations\\n        for n in balls:\\n            combs = number_of_ways_to_pick(n)\\n            new_s = Counter()\\n            for k in status:\\n                a,b,ca,cb = k\\n                for n_a in combs:\\n                    if n_a == 0:\\n                        new_s[(a,b+n,ca,cb+1)] += status[k] * combs[n_a]\\n                    elif n_a == n:\\n                        new_s[(a+n,b,ca+1,cb)] += status[k] * combs[n_a]\\n                    else:\\n                        new_s[(a+n_a, b+n-n_a, ca, cb)] += status[k] * combs[n_a]\\n            status = new_s\\n        \\n        res = 0\\n        for k in status:\\n            a,b,ca,cb = k\\n            if a==b and ca==cb:\\n                res += status[k]\\n            \\n        return res/number_of_combinations\\n        \\n```\\n\\n\\na better way: 3-dimension DP\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from scipy.special import comb\\n        \\n        sm = sum(balls)\\n        all_per = comb(sm, sm//2)\\n        lru_cache(None)\\n        \\n        def find(n):\\n            d = Counter()\\n            for i in range(n+1):\\n                d[i] = comb(n,i)\\n            return d\\n            \\n        status = Counter()\\n        status[(0,0,0)] = 1 #num of A box, num of B box, colorA-colorB, such combinations number\\n        for n in balls:\\n            new_ball = find(n)\\n            new_s = Counter()\\n            for k in status:\\n                a,b,c = k\\n                for n_a in new_ball:\\n                    if n_a == 0:\\n                        new_s[(a,b+n,c-1)] += status[k] * new_ball[n_a]\\n                    elif n_a == n:\\n                        new_s[(a+n,b,c+1)] += status[k] * new_ball[n_a]\\n                    else:\\n                        new_s[(a+n_a,b+n-n_a,c)] += status[k] * new_ball[n_a]\\n            status = new_s\\n        \\n        res = 0\\n        for k in status:\\n            a,b,c = k\\n            if a==b and c==0:\\n                res += status[k]\\n            \\n        return res/all_per\\n        \\n```\\na better way: 2-dimension DP:\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from scipy.special import comb # help to calculate combination numbers\\n        \\n        sm = sum(balls)\\n        number_of_combinations = comb(sm, sm//2) # \\n        \\n        def number_of_ways_to_pick(n): # there are n balls of color-a, we want to pick some number of them and put them into boxA, and others into boxB\\n            d = Counter() # key: number of balls put into boxA, value: number of such combinations\\n            for i in range(n+1):\\n                d[i] = comb(n,i)\\n            return d\\n            \\n        status = Counter()\\n        status[(0,0)] = 1 \\n        #key: number difference, color difference; value: number of such combinations\\n        for n in balls:\\n            combs = number_of_ways_to_pick(n)\\n            new_s = Counter()\\n            for k in status:\\n                d_n, d_c = k\\n                for n_a in combs:\\n                    if n_a == 0:\\n                        new_s[(d_n-n, d_c-1)] += status[k] * combs[n_a]\\n                    elif n_a == n:\\n                        new_s[(d_n+n,d_c+1)] += status[k] * combs[n_a]\\n                    else:\\n                        new_s[(d_n+2*n_a-n, d_c)] += status[k] * combs[n_a]\\n            status = new_s\\n        \\n        \\n            \\n        return status[(0,0)]/number_of_combinations\\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from scipy.special import comb # help to calculate combination numbers\\n        \\n        sm = sum(balls)\\n        number_of_combinations = comb(sm, sm//2) # \\n        \\n        def number_of_ways_to_pick(n): # there are n balls of color-a, we want to pick some number of them and put them into boxA, and others into boxB\\n            d = Counter() # key: number of balls put into boxA, value: number of such combinations\\n            for i in range(n+1):\\n                d[i] = comb(n,i)\\n            return d\\n            \\n        status = Counter()\\n        status[(0,0,0,0)] = 1 \\n        #key: num of balls in boxA, num of balls in boxB, different colors in boxA, different colors in boxB; value: number of such combinations\\n        for n in balls:\\n            combs = number_of_ways_to_pick(n)\\n            new_s = Counter()\\n            for k in status:\\n                a,b,ca,cb = k\\n                for n_a in combs:\\n                    if n_a == 0:\\n                        new_s[(a,b+n,ca,cb+1)] += status[k] * combs[n_a]\\n                    elif n_a == n:\\n                        new_s[(a+n,b,ca+1,cb)] += status[k] * combs[n_a]\\n                    else:\\n                        new_s[(a+n_a, b+n-n_a, ca, cb)] += status[k] * combs[n_a]\\n            status = new_s\\n        \\n        res = 0\\n        for k in status:\\n            a,b,ca,cb = k\\n            if a==b and ca==cb:\\n                res += status[k]\\n            \\n        return res/number_of_combinations\\n        \\n```\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from scipy.special import comb\\n        \\n        sm = sum(balls)\\n        all_per = comb(sm, sm//2)\\n        lru_cache(None)\\n        \\n        def find(n):\\n            d = Counter()\\n            for i in range(n+1):\\n                d[i] = comb(n,i)\\n            return d\\n            \\n        status = Counter()\\n        status[(0,0,0)] = 1 #num of A box, num of B box, colorA-colorB, such combinations number\\n        for n in balls:\\n            new_ball = find(n)\\n            new_s = Counter()\\n            for k in status:\\n                a,b,c = k\\n                for n_a in new_ball:\\n                    if n_a == 0:\\n                        new_s[(a,b+n,c-1)] += status[k] * new_ball[n_a]\\n                    elif n_a == n:\\n                        new_s[(a+n,b,c+1)] += status[k] * new_ball[n_a]\\n                    else:\\n                        new_s[(a+n_a,b+n-n_a,c)] += status[k] * new_ball[n_a]\\n            status = new_s\\n        \\n        res = 0\\n        for k in status:\\n            a,b,c = k\\n            if a==b and c==0:\\n                res += status[k]\\n            \\n        return res/all_per\\n        \\n```\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from scipy.special import comb # help to calculate combination numbers\\n        \\n        sm = sum(balls)\\n        number_of_combinations = comb(sm, sm//2) # \\n        \\n        def number_of_ways_to_pick(n): # there are n balls of color-a, we want to pick some number of them and put them into boxA, and others into boxB\\n            d = Counter() # key: number of balls put into boxA, value: number of such combinations\\n            for i in range(n+1):\\n                d[i] = comb(n,i)\\n            return d\\n            \\n        status = Counter()\\n        status[(0,0)] = 1 \\n        #key: number difference, color difference; value: number of such combinations\\n        for n in balls:\\n            combs = number_of_ways_to_pick(n)\\n            new_s = Counter()\\n            for k in status:\\n                d_n, d_c = k\\n                for n_a in combs:\\n                    if n_a == 0:\\n                        new_s[(d_n-n, d_c-1)] += status[k] * combs[n_a]\\n                    elif n_a == n:\\n                        new_s[(d_n+n,d_c+1)] += status[k] * combs[n_a]\\n                    else:\\n                        new_s[(d_n+2*n_a-n, d_c)] += status[k] * combs[n_a]\\n            status = new_s\\n        \\n        \\n            \\n        return status[(0,0)]/number_of_combinations\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 661937,
                "title": "java-clean-dfs",
                "content": "As shown in the comment, we need to use same type balls as a unit together and apply combination theory to optimal the time complexity. The idea is same as the question combination, the difference is now we can not expand every element since it will get TLE, we need to calculate the same type of balls together by math knowledge which called \"Combination\", basic idea is calculate how many ways you can pick n / 2 balls from n balls. The same as in this question of total combination way concept.\\n```\\nclass Solution {\\n    double[] dp = new double[49];\\n    public double getProbability(int[] balls) {\\n        dp[0] = 1;\\n        int sum = Arrays.stream(balls).sum();\\n        for (int i = 1; i < 49; i++) dp[i] = dp[i - 1] * i; //this is for calculate C(a, b) as explained in helper method\\n        double validNumber = dfs(0, 0, 0, 0, balls, 0);\\n        double totalNumber = combination(sum, sum / 2);   //how many different ways we can pick sum / 2 balls from sum\\n        return validNumber / totalNumber;\\n    }\\n    \\n    //count means the numebr of distinguish balls in one box, sum means total balls in one box\\n    private double dfs(int count1, int count2, int sum1, int sum2, int[] balls, int i) {\\n        if (i == balls.length) return (sum1 == sum2 && count1 == count2) ? 1 : 0;\\n        double res = dfs(count1 + 1, count2, sum1 + balls[i], sum2, balls, i + 1);\\n        res += dfs(count1, count2 + 1, sum1, sum2 + balls[i], balls, i + 1);\\n        for (int j = 1; j < balls[i]; j++)\\n            res += combination(balls[i], j) * dfs(count1 + 1, count2 + 1, sum1 + j, sum2 + balls[i] - j, balls, i + 1);\\n        return res;\\n    }\\n    \\n    //combination way to calculate pick b from a: C(a, b), eg C(4, 2) = dp[4] / dp[2] / dp[4 - 2] = 6\\n    private double combination(int a, int b) {\\n        return dp[a] / dp[b] / dp[a - b];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double[] dp = new double[49];\\n    public double getProbability(int[] balls) {\\n        dp[0] = 1;\\n        int sum = Arrays.stream(balls).sum();\\n        for (int i = 1; i < 49; i++) dp[i] = dp[i - 1] * i; //this is for calculate C(a, b) as explained in helper method\\n        double validNumber = dfs(0, 0, 0, 0, balls, 0);\\n        double totalNumber = combination(sum, sum / 2);   //how many different ways we can pick sum / 2 balls from sum\\n        return validNumber / totalNumber;\\n    }\\n    \\n    //count means the numebr of distinguish balls in one box, sum means total balls in one box\\n    private double dfs(int count1, int count2, int sum1, int sum2, int[] balls, int i) {\\n        if (i == balls.length) return (sum1 == sum2 && count1 == count2) ? 1 : 0;\\n        double res = dfs(count1 + 1, count2, sum1 + balls[i], sum2, balls, i + 1);\\n        res += dfs(count1, count2 + 1, sum1, sum2 + balls[i], balls, i + 1);\\n        for (int j = 1; j < balls[i]; j++)\\n            res += combination(balls[i], j) * dfs(count1 + 1, count2 + 1, sum1 + j, sum2 + balls[i] - j, balls, i + 1);\\n        return res;\\n    }\\n    \\n    //combination way to calculate pick b from a: C(a, b), eg C(4, 2) = dp[4] / dp[2] / dp[4 - 2] = 6\\n    private double combination(int a, int b) {\\n        return dp[a] / dp[b] / dp[a - b];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663791,
                "title": "python-dp-detailed-explanation",
                "content": "Don\\'t directly calculate probability. Calculate the number of \"success count\" instead. After getting total \"success count\", probability can be obtained using \"success count / total count\". Where \"total count\" equals the combinations of \"taking half balls out of all balls\", which is a mathmatical problem: \"comb(n, n//2)\". (python provides \"comb\" function out of the box).\\n\\nWe allocate balls into two buckets, with first bucket having balls count \"num1\", distinct colors count \"c1\", and second bucket having balls count \"num2\" and distinct colors count \"c2\". When we see \"num1==num2==totalBalls//2 and c1==c2\" at the same time, we find one success count.\\ndp(i, num1, c1, num2, c2): \"i\" means the index in balls[i]. dp returns the \"success count\" at and after index \"i\". \"num1, num2, c1, c2\" are the bucket states of index \"i-1\".\\n\\nIn dp, we loop through all different ways allocating \"balls[i]\" to bucket1 and bucket2. Be careful that if we decide to allocate some balls to bucket1, for example \"two\" balls, then the \"two\" balls can be choosen from all different balls in \"balls[i]\". That\\'s why there is a \"comb\" statement inside the \"for\" loop in dp.\\n\\nTime complexity: O(totalColors * totalBalls^2 * totalColors^2 * maxBallEachColor )\\nWithout \"@functools.lru_cache(None)\": 3000ms\\nWith \"@functools.lru_cache(None)\": 30ms\\n\\n```\\n    def getProbability(self, balls: List[int]) -> float:\\n        @functools.lru_cache(None)\\n        def dp(i,num1,c1,num2,c2):\\n\\t\\t\\tif num1>totalBalls//2 or num2>totalBalls//2:\\n                return 0\\n            if i>=len(balls):\\n                return num1==num2==totalBalls//2 and c1==c2\\n            res=0\\n            for toBucket1 in range(balls[i]+1):\\n                toBucket2=balls[i]-toBucket1\\n                ways=comb(balls[i],toBucket1)\\n                successCnt=dp(i+1,num1+toBucket1,c1+(toBucket1!=0),num2+toBucket2,c2+(toBucket2!=0))\\n                res+=successCnt*ways\\n            return res\\n        totalBalls=sum(balls)\\n        return dp(0,0,0,0,0)/comb(totalBalls,totalBalls//2)\\n```",
                "solutionTags": [],
                "code": "```\\n    def getProbability(self, balls: List[int]) -> float:\\n        @functools.lru_cache(None)\\n        def dp(i,num1,c1,num2,c2):\\n\\t\\t\\tif num1>totalBalls//2 or num2>totalBalls//2:\\n                return 0\\n            if i>=len(balls):\\n                return num1==num2==totalBalls//2 and c1==c2\\n            res=0\\n            for toBucket1 in range(balls[i]+1):\\n                toBucket2=balls[i]-toBucket1\\n                ways=comb(balls[i],toBucket1)\\n                successCnt=dp(i+1,num1+toBucket1,c1+(toBucket1!=0),num2+toBucket2,c2+(toBucket2!=0))\\n                res+=successCnt*ways\\n            return res\\n        totalBalls=sum(balls)\\n        return dp(0,0,0,0,0)/comb(totalBalls,totalBalls//2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 662408,
                "title": "my-screencast",
                "content": "https://www.youtube.com/watch?v=NePiM0T_Pac",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=NePiM0T_Pac",
                "codeTag": "Unknown"
            },
            {
                "id": 662218,
                "title": "most-intuitive-recursive-approach-video-explanation-w-code",
                "content": "Hi Guys, \\nI have given an attempt to explain my approach to this problem in this video, \\nI hope it helps. \\n\\nhttps://www.youtube.com/watch?v=6iab51dJiM4&t=1s\\n\\nPlease checkout my playlist to watch other similar problems from leetcode.\\nPlease do subscribe to my channel if you like my work.\\n\\nAny feedback/suggestions are highly appreciated,\\nThanks\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "Hi Guys, \\nI have given an attempt to explain my approach to this problem in this video, \\nI hope it helps. \\n\\nhttps://www.youtube.com/watch?v=6iab51dJiM4&t=1s\\n\\nPlease checkout my playlist to watch other similar problems from leetcode.\\nPlease do subscribe to my channel if you like my work.\\n\\nAny feedback/suggestions are highly appreciated,\\nThanks\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 661992,
                "title": "python-o-n-k-max-balls-dfs-with-memory-76ms",
                "content": "\\n\\n\\nLet\\'s image we have two boxes, each can fit in `n` balls. Currently we have `left` balls in the first box and `right` balls in the second box, the number of unique balls in the first box is `ul` and the number of unique balls in the second box is `ur`,  and we are going to put `balls[i]` balls into two boxes. \\n\\nThe state is `(left, right, i, ul, ur)`, and the transition equation is \\n![image](https://assets.leetcode.com/users/seeean/image_1590935347.png)\\n\\nBecause there are `2n-left-right` slots available, the total number of ways to put `balls[i]` balls is `C(2n-left-right, balls[i])`. The probability that we put exactly `l` balls into the first box and `r` balls into the second box (`l+r=balls[i]`) is `C(n-left, l) * C(n-right, r) / C(2n-left-right, balls[i])`. If `l>0` then the number of unique balls in the first box increase by 1, the same applies for the second box. From there, we can transit to the next state `(left+l, right+r, i, ul+(l>0), ur+(r>0))`.\\n\\nHere\\'s the code\\n\\n\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        self.n = sum(balls) // 2\\n        self.balls = balls\\n        return self.dfs(0, 0, 0, 0, 0)\\n        \\n    def com(self, n, m):\\n        ans = 1\\n        for i in range(n-m+1, n+1):\\n            ans *= i\\n        for i in range(1, m+1):\\n            ans //= i\\n        return ans\\n        \\n    @lru_cache(None)\\n    def dfs(self, left, right, i, ul, ur):\\n        if i == len(self.balls):\\n            return float(ul == ur)\\n        p = 0\\n        for l in range(self.balls[i]+1):\\n            r = self.balls[i] - l\\n            if left+l > self.n or r+right > self.n:\\n                continue\\n            p += self.com(self.n-left, l) * self.com(self.n-right, r) / self.com(2*self.n-left-right, self.balls[i]) * self.dfs(left+l, right+r, i+1, ul+(l>0), ur+(r>0))\\n        return p\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        self.n = sum(balls) // 2\\n        self.balls = balls\\n        return self.dfs(0, 0, 0, 0, 0)\\n        \\n    def com(self, n, m):\\n        ans = 1\\n        for i in range(n-m+1, n+1):\\n            ans *= i\\n        for i in range(1, m+1):\\n            ans //= i\\n        return ans\\n        \\n    @lru_cache(None)\\n    def dfs(self, left, right, i, ul, ur):\\n        if i == len(self.balls):\\n            return float(ul == ur)\\n        p = 0\\n        for l in range(self.balls[i]+1):\\n            r = self.balls[i] - l\\n            if left+l > self.n or r+right > self.n:\\n                continue\\n            p += self.com(self.n-left, l) * self.com(self.n-right, r) / self.com(2*self.n-left-right, self.balls[i]) * self.dfs(left+l, right+r, i+1, ul+(l>0), ur+(r>0))\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728731,
                "title": "c-python-short-backtracking-solution-o-m-n",
                "content": "**Explanation:**\\nEnumerate all possible ways of dividing the colours between buckets `A` and `B`:\\n\\n* Keep track of the _balance_ of the number of balls in each bucket `n = |A| - |B|`.\\n\\t* If `n = 0` then the buckets have the same number of balls.\\n\\n* Keep track of the _balance_ of the distinct colours in each bucket `c = |colours in A| - |colours in B|`.\\n\\t* If `c = 0` then the buckets have the same number of distinct colours.\\n\\n* Compute the _weight_ `w` we give to each combination by dividing out the number of permuations for the balls of each colour.\\n\\n**C++:**\\n```c++\\nclass Solution {\\npublic:\\n    double fact[7] = { 1, 1, 2, 6, 24, 120, 720 };\\n    double total = 0, match = 0;\\n    \\n    void dfs(vector<int>& balls, int i=0, int n=0, int c=0, double w=1) {\\n        if (i == balls.size()) {\\n            total += w * !n;\\n            match += w * !n * !c;\\n            return;\\n        }\\n        for (int b1 = 0, b2 = balls[i]; b2 >= 0; b1++, b2--) {\\n            dfs(balls, i + 1, n + b1 - b2, c + !b2 - !b1, w / fact[b1] / fact[b2]);\\n        }\\n    }\\n    \\n    double getProbability(vector<int>& balls) {\\n        dfs(balls);\\n        return match / total;\\n    }\\n};\\n```\\n\\n**Python:**\\n```python\\nclass Solution(object):\\n    def __init__(self):\\n        self.fact = [1, 1, 2, 6, 24, 120, 720]\\n        self.total = 0.0\\n        self.match = 0.0\\n\\n    def dfs(self, balls, i=0, n=0, c=0, w=1.0):\\n        if i == len(balls):\\n            self.total += w * (n == 0)\\n            self.match += w * (n == 0) * (c == 0)\\n            return\\n        for b1, b2 in zip(range(balls[i] + 1), reversed(range(balls[i] + 1))):\\n            self.dfs(\\n                balls,\\n                i + 1,\\n                n + b1 - b2,\\n                c + (b2 == 0) - (b1 == 0),\\n                w / self.fact[b1] / self.fact[b2])\\n\\n    def getProbability(self, balls):\\n        self.dfs(balls)\\n        return self.match / self.total\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    double fact[7] = { 1, 1, 2, 6, 24, 120, 720 };\\n    double total = 0, match = 0;\\n    \\n    void dfs(vector<int>& balls, int i=0, int n=0, int c=0, double w=1) {\\n        if (i == balls.size()) {\\n            total += w * !n;\\n            match += w * !n * !c;\\n            return;\\n        }\\n        for (int b1 = 0, b2 = balls[i]; b2 >= 0; b1++, b2--) {\\n            dfs(balls, i + 1, n + b1 - b2, c + !b2 - !b1, w / fact[b1] / fact[b2]);\\n        }\\n    }\\n    \\n    double getProbability(vector<int>& balls) {\\n        dfs(balls);\\n        return match / total;\\n    }\\n};\\n```\n```python\\nclass Solution(object):\\n    def __init__(self):\\n        self.fact = [1, 1, 2, 6, 24, 120, 720]\\n        self.total = 0.0\\n        self.match = 0.0\\n\\n    def dfs(self, balls, i=0, n=0, c=0, w=1.0):\\n        if i == len(balls):\\n            self.total += w * (n == 0)\\n            self.match += w * (n == 0) * (c == 0)\\n            return\\n        for b1, b2 in zip(range(balls[i] + 1), reversed(range(balls[i] + 1))):\\n            self.dfs(\\n                balls,\\n                i + 1,\\n                n + b1 - b2,\\n                c + (b2 == 0) - (b1 == 0),\\n                w / self.fact[b1] / self.fact[b2])\\n\\n    def getProbability(self, balls):\\n        self.dfs(balls)\\n        return self.match / self.total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661915,
                "title": "java-easy-counting-with-backtracking",
                "content": "Anyway, using back tracking to count all different types would easily solve this problem, see the code and comments:\\n\\n```\\nclass Solution {\\n    double same = 0, diff = 0;\\n    int sum = 0, n;\\n    int[] bs;\\n    public double getProbability(int[] bs) {\\n        this.n = bs.length;\\n        for (int i : bs) sum += i;\\n        this.bs = bs;\\n        dfs(0, 0, new ArrayList<>());  //Back tracing to cnt diff colors or same colors;\\n        return same / (same + diff);\\n    }\\n    \\n    private void dfs(int idx, int cnt, List<Integer> pool) {\\n        if (cnt == sum / 2) {   // finished distribution, counting\\n            List<Integer> secondPool = new ArrayList<>();  // distrbution of the second half;\\n            for (int i = 0; i < n; i++){\\n                int count = i < pool.size() ? pool.get(i) : 0;\\n                secondPool.add(bs[i] - count);\\n            }\\n            double acc = getCnt(pool) * getCnt(secondPool);   // tot = count of first half arrages * count of second half arranges;\\n            if (isSameCount(pool)) same += acc;\\n            else diff += acc;\\n            return;\\n        }\\n        if (idx >= n) return;\\n        for (int i = 0; i <= bs[idx]; i++) {\\n            if (cnt + i > sum / 2) break;\\n            pool.add(i);\\n            dfs(idx + 1, cnt + i, pool);\\n            pool.remove(pool.size() - 1);\\n        } \\n    }\\n    \\n    // count of different arranges for each half\\n    private double getCnt(List<Integer> pool) {\\n        double res = 1, rem = sum / 2;\\n        for (int i = 0; i < pool.size() - 1; i++) {\\n            int cnt = pool.get(i);\\n            if (cnt == 0) continue;\\n            res *= getCombCnt(rem, cnt);\\n            rem -= cnt;\\n        }\\n        return res;\\n    }\\n    \\n    //number of combinations to select i positions from list of rem positions\\n    private double getCombCnt(double rem, int i) {\\n        double res = 1, div = 1;\\n        for (int j = 1; j <= i; j++) {\\n            res *= (rem + 1 - j);\\n            div *= j;\\n        }\\n        return res / div;\\n    }\\n    \\n    //check if same num of colors\\n    private boolean isSameCount(List<Integer> pool) {\\n        int l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            int cnt = i < pool.size() ? pool.get(i) : 0;\\n            if (bs[i] - cnt > 0) r++;\\n            if (cnt > 0) l++;\\n        }\\n        return l == r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double same = 0, diff = 0;\\n    int sum = 0, n;\\n    int[] bs;\\n    public double getProbability(int[] bs) {\\n        this.n = bs.length;\\n        for (int i : bs) sum += i;\\n        this.bs = bs;\\n        dfs(0, 0, new ArrayList<>());  //Back tracing to cnt diff colors or same colors;\\n        return same / (same + diff);\\n    }\\n    \\n    private void dfs(int idx, int cnt, List<Integer> pool) {\\n        if (cnt == sum / 2) {   // finished distribution, counting\\n            List<Integer> secondPool = new ArrayList<>();  // distrbution of the second half;\\n            for (int i = 0; i < n; i++){\\n                int count = i < pool.size() ? pool.get(i) : 0;\\n                secondPool.add(bs[i] - count);\\n            }\\n            double acc = getCnt(pool) * getCnt(secondPool);   // tot = count of first half arrages * count of second half arranges;\\n            if (isSameCount(pool)) same += acc;\\n            else diff += acc;\\n            return;\\n        }\\n        if (idx >= n) return;\\n        for (int i = 0; i <= bs[idx]; i++) {\\n            if (cnt + i > sum / 2) break;\\n            pool.add(i);\\n            dfs(idx + 1, cnt + i, pool);\\n            pool.remove(pool.size() - 1);\\n        } \\n    }\\n    \\n    // count of different arranges for each half\\n    private double getCnt(List<Integer> pool) {\\n        double res = 1, rem = sum / 2;\\n        for (int i = 0; i < pool.size() - 1; i++) {\\n            int cnt = pool.get(i);\\n            if (cnt == 0) continue;\\n            res *= getCombCnt(rem, cnt);\\n            rem -= cnt;\\n        }\\n        return res;\\n    }\\n    \\n    //number of combinations to select i positions from list of rem positions\\n    private double getCombCnt(double rem, int i) {\\n        double res = 1, div = 1;\\n        for (int j = 1; j <= i; j++) {\\n            res *= (rem + 1 - j);\\n            div *= j;\\n        }\\n        return res / div;\\n    }\\n    \\n    //check if same num of colors\\n    private boolean isSameCount(List<Integer> pool) {\\n        int l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            int cnt = i < pool.size() ? pool.get(i) : 0;\\n            if (bs[i] - cnt > 0) r++;\\n            if (cnt > 0) l++;\\n        }\\n        return l == r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663268,
                "title": "python3-52ms-solution-explained-beats-100",
                "content": "**Big Idea: Dynamic Programming**\\n\\nFirst of all, let\\'s propose this combination of values as a DP state:\\n\\n**(i, disl, disr, numl, numr)**\\n\\nwhere:\\n**i** indicates we use up to the ith type of ball\\n**disl** and **disr** are the **number of distinct types** of balls in the left and right bin\\n**numl** and **numr** are the total **number of balls** in the left and right bin\\n\\nWhy is this dp state useful? Well, to calculate the **number of permutations** in any given dp state, say we put **j** balls in the left bin, leaving us **balls[i]-j** balls to put in the right, we only need the number of permutations at:\\n\\n**(i - 1, disl - ?, disr - ?, numl - j, numr - (balls[i]-j))**\\n\\nThe value of **?** is either 0 and 1 depending on if we are putting all the balls of ith type into one bin or not. If this is the case, then the other bin would have the same amount of distinct types, and **?** would be 0. Otherwise, the previous dp state should have one less distinct types to be relevant, so **?** would be 1.\\n\\nNow let\\'s take a look at my solution:\\n\\n```\\nfrom functools import lru_cache\\nimport math\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        \\n        @lru_cache(None)\\n        def fac(n):\\n            return math.factorial(n)\\n        \\n        @lru_cache(None)\\n        def dp(i, disl, disr, numl, numr):\\n            if i == 0: # Base case: there is only 1 valid permuatation if everything is empty\\n                if disl == 0 and disr == 0 and numl == 0 and numr == 0:\\n                    return 1\\n                return 0\\n            b = balls[i-1]\\n            res = 0\\n            for j in range(b+1): # j is the number of balls we put in the left bin\\n                if numl - j < 0 or (numr - (b-j)) < 0: # invalid case\\n                    continue\\n                ways = dp(i - 1, disl - (j != b), disr - (j != 0), numl - j, numr - (b-j))\\n                ways *= fac(numl) * fac(numr) / fac(j) / fac(b-j) / fac(numl-j) / fac(numr-(b-j))\\n                res += ways\\n            return res\\n        \\n        res = 0\\n        for k in range((len(balls) + 1) // 2, len(balls) + 1):\\n            res += dp(len(balls), k, k, sum(balls) // 2, sum(balls) // 2)\\n        \\n        div = fac(sum(balls))\\n        for b in balls:\\n            div //= fac(b)\\n        \\n        return res / div\\n```\\n\\nTo understant this better, let\\'s break down this solution into 4 parts:\\n**Part 1** def fac(n). This is simply a short hand for computing factorials. We are memoizing it to make it faster.\\n\\n**Part 2** def dp(.. . This is our dynamic programming relation described above. First of all, if i = 0, then we are using no balls, so there is really only 1 way to permute it, given that the other quantities are 0 as well.\\nThen, we would have to rely on the dp relation to solve this subproblem. Say we put **j** balls in the left and **b-j** balls in the right, given the number of permutations at the previous dp state, how do we solve for the number of permutations at the new state? We can approach this by first counting the total number of permutations, and then dividing by the number of ways we \"overcounted\". If we multiply the number of ways to permute the previous two bins without adding new balls with the total number of ways to permute the two bins after adding the new balls, then we have overcounted, for each bin: the number of ways to permute the old balls, and the number of ways to permute the new balls. The equation is given by:\\n**[permutations in previous dp] * fac(numl) * fac(numr) / fac(j) / fac(b-j) / fac(numl-j) / fac(numr-(b-j))**\\nNow we can proceed by summing up the number of permutations for each value of **j** we choose.\\n\\n**Part 3**: This where we derive the answer to the question from our dp relation. The question asks that the number of distinct types should be the same, and the number of balls in each bins are also the same. In other words, the number of balls in each bins are constantly half of the total number of balls, and we only need to enumerate the number of distinct types of balls, denoted by **k**.\\n\\n**Part 4**: Finally, since the question is asking about probability, not number of permutations, we divide our answer with the total number of valid permutations. In Python3, you do not need to worry about numerical overflow, so the computation process would always be valid.\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache\\nimport math\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        \\n        @lru_cache(None)\\n        def fac(n):\\n            return math.factorial(n)\\n        \\n        @lru_cache(None)\\n        def dp(i, disl, disr, numl, numr):\\n            if i == 0: # Base case: there is only 1 valid permuatation if everything is empty\\n                if disl == 0 and disr == 0 and numl == 0 and numr == 0:\\n                    return 1\\n                return 0\\n            b = balls[i-1]\\n            res = 0\\n            for j in range(b+1): # j is the number of balls we put in the left bin\\n                if numl - j < 0 or (numr - (b-j)) < 0: # invalid case\\n                    continue\\n                ways = dp(i - 1, disl - (j != b), disr - (j != 0), numl - j, numr - (b-j))\\n                ways *= fac(numl) * fac(numr) / fac(j) / fac(b-j) / fac(numl-j) / fac(numr-(b-j))\\n                res += ways\\n            return res\\n        \\n        res = 0\\n        for k in range((len(balls) + 1) // 2, len(balls) + 1):\\n            res += dp(len(balls), k, k, sum(balls) // 2, sum(balls) // 2)\\n        \\n        div = fac(sum(balls))\\n        for b in balls:\\n            div //= fac(b)\\n        \\n        return res / div\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663152,
                "title": "java-dfs",
                "content": "The description was so confusing and I spent some time reviewing the discussions and finally have a more clear understanding. **ALL the balls are different even they are in the same color!** Hope this helps.\\n\\nThe idea here is to get the total number of valid cases and then divide the total number of combinations for selecting n balls out of 2n balls.\\n\\n**To count the valid cases we can do as following**\\n1) For any color i, we can select j (0, or 1, or, 2 ... or balls[i]) balls and put to box A, and put the rest of balls in box B. \\n    Take [2,1,1] for example: \\n\\t- [**2**,1,1]: For color 0, we can put 0 or 1 or 2 balls in box A while put 2 or 1 or 0 in Box B\\n\\t- [2,**1**,1]: For color 1, we can put 0 or 1 ball in A, and 1 or 0 in B\\n\\t- [2,1,**1**]: For color 2, we can put 0 or 1 ball in A, and 1 or 0 in B\\n\\n\\tFor each case here, we need to multiply the number of combinations for selecting j balls out of balls[i]. Because when we do the splitting, we only considered the count of balls, however there are C(balls[i], j) conbinations in total.\\n2) We validate if the current division is valid by checking if the number of balls in A and B are equal AND the distinct color count are the same when all the colors are processed.\\n```\\n\\t// c1, c2 are the counters of the number of balls in each box\\n\\t// d1, d2 are the distinct colors in each box\\n\\t// idx is the current color we are splitting\\n    private double dfs(int[] balls, int idx, int c1, int c2, int d1, int d2){\\n        if(idx == balls.length){\\n            if(c1==c2 && d1==d2)  return 1;\\n            else return 0;\\n        } \\n        double ans = 0;\\n\\t\\t// For each color, we could select 0,1,2,...,balls[idx] and put in box A, and the rest in box B.\\n\\t\\t// If we put 0 balls in A, then the distinct color count d1 will not increase. If we put all balls[idx] in A and 0 in B, then the distinct color count d2 will not increase. For other cases, we increase d1 and d2 by 1 and go ahead process next color by calling dfs method .\\n        for(int i=0; i<=balls[idx];i++){\\n\\t\\t    // combination method is used to calculate the total number of combinations to select i balls from balls[idx]. \\n            ans += combination(balls[idx], i) * dfs(balls, idx+1, c1+i, c2+balls[idx]-i, d1+ (i==0 ? 0: 1), d2+(i==balls[idx] ? 0: 1));    \\n        }\\n        return ans;\\n    }\\n\\tprivate double combination(int n, int k) {\\n        return factorial[n] / (factorial[k] *factorial[n - k]);\\n    }\\n```\\n\\n\\n**To get the total number of conbinations** using n balls from 2n balls. We use the C(m,k)= m!/(k!(m-k)!) formula. In our case, m= 2n and k = n.\\nThus C(2n,n) = (2n!)/n!*(2n-n)! = (2n!)/(n!)*n! = (1 * 2 * 3 *... * 2n)/(1 * 2 * 3 *...* n) ^ 2 = (n+1 * n+2 * ... * 2n) / (1 * 2 * 3 *...* n)\\n\\n```\\n        int sum = 0;\\n        for (int ball : balls) sum += ball;\\n        double total = 1;\\n        for (int i = sum; i > sum / 2; i--) total *= i; \\n        for (int i = sum / 2; i > 0; i--) total /= i; \\n```\\n\\nThen the finaly probability is (# of valid cases)/(total # of combinations)\\n\\nHere is to code:\\n```\\nclass Solution {\\n    int n;\\n    double[] factorial = new double[7];\\n    public double getProbability(int[] balls) {\\n        factorial[0] = 1;\\n        for (int i = 1; i < 7; i++) factorial[i] = factorial[i - 1] * i; // this part is to calculate the conbinations for selecting j balls out of balls[i] for color i.\\n        \\n\\t\\t//Following part to to count the total combinations = (n+1 * n+2 * ... * 2n) / (1 * 2 * 3 *...* n)\\n        int sum = 0;\\n        for (int ball : balls) sum += ball;\\n        double total = 1;\\n        for (int i = sum; i > sum / 2; i--) total *= i; \\n        for (int i = sum / 2; i > 0; i--) total /= i; \\n     \\n\\t\\tdouble validNumber = dfs(balls, 0, 0,0,0,0);\\n\\t\\t\\n        return (double) validNumber/total;\\n    }\\n    \\n\\t// c1, c2 are the counters of the number of balls in each box\\n\\t// d1, d2 are the distinct colors in each box\\n\\t// idx is the current color we are splitting\\n    private double dfs(int[] balls, int idx, int c1, int c2, int d1, int d2){\\n        if(idx == balls.length){\\n            if(c1==c2 && d1==d2)  return 1;\\n            else return 0;\\n        } \\n        double ans = 0;\\n\\t\\t// For each color, we could select 0,1,2,...,balls[idx] and put in box A, and the rest in box B.\\n\\t\\t// If we put 0 balls in A, then the distinct color count d1 will not increase. If we put all balls[idx] in A and 0 in B, then the distinct color count d2 will not increase. For other cases, we increase d1 and d2 by 1 and go ahead process next color by calling dfs method .\\n        for(int i=0; i<=balls[idx];i++){\\n\\t\\t    // combination method is used to calculate the total number of combinations to select i balls from balls[idx]. \\n            ans += combination(balls[idx], i) * dfs(balls, idx+1, c1+i, c2+balls[idx]-i, d1+ (i==0 ? 0: 1), d2+(i==balls[idx] ? 0: 1));    \\n        }\\n        return ans;\\n    }\\n\\n    private double combination(int n, int k) {\\n        return factorial[n] / (factorial[k] *factorial[n - k]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t// c1, c2 are the counters of the number of balls in each box\\n\\t// d1, d2 are the distinct colors in each box\\n\\t// idx is the current color we are splitting\\n    private double dfs(int[] balls, int idx, int c1, int c2, int d1, int d2){\\n        if(idx == balls.length){\\n            if(c1==c2 && d1==d2)  return 1;\\n            else return 0;\\n        } \\n        double ans = 0;\\n\\t\\t// For each color, we could select 0,1,2,...,balls[idx] and put in box A, and the rest in box B.\\n\\t\\t// If we put 0 balls in A, then the distinct color count d1 will not increase. If we put all balls[idx] in A and 0 in B, then the distinct color count d2 will not increase. For other cases, we increase d1 and d2 by 1 and go ahead process next color by calling dfs method .\\n        for(int i=0; i<=balls[idx];i++){\\n\\t\\t    // combination method is used to calculate the total number of combinations to select i balls from balls[idx]. \\n            ans += combination(balls[idx], i) * dfs(balls, idx+1, c1+i, c2+balls[idx]-i, d1+ (i==0 ? 0: 1), d2+(i==balls[idx] ? 0: 1));    \\n        }\\n        return ans;\\n    }\\n\\tprivate double combination(int n, int k) {\\n        return factorial[n] / (factorial[k] *factorial[n - k]);\\n    }\\n```\n```\\n        int sum = 0;\\n        for (int ball : balls) sum += ball;\\n        double total = 1;\\n        for (int i = sum; i > sum / 2; i--) total *= i; \\n        for (int i = sum / 2; i > 0; i--) total /= i; \\n```\n```\\nclass Solution {\\n    int n;\\n    double[] factorial = new double[7];\\n    public double getProbability(int[] balls) {\\n        factorial[0] = 1;\\n        for (int i = 1; i < 7; i++) factorial[i] = factorial[i - 1] * i; // this part is to calculate the conbinations for selecting j balls out of balls[i] for color i.\\n        \\n\\t\\t//Following part to to count the total combinations = (n+1 * n+2 * ... * 2n) / (1 * 2 * 3 *...* n)\\n        int sum = 0;\\n        for (int ball : balls) sum += ball;\\n        double total = 1;\\n        for (int i = sum; i > sum / 2; i--) total *= i; \\n        for (int i = sum / 2; i > 0; i--) total /= i; \\n     \\n\\t\\tdouble validNumber = dfs(balls, 0, 0,0,0,0);\\n\\t\\t\\n        return (double) validNumber/total;\\n    }\\n    \\n\\t// c1, c2 are the counters of the number of balls in each box\\n\\t// d1, d2 are the distinct colors in each box\\n\\t// idx is the current color we are splitting\\n    private double dfs(int[] balls, int idx, int c1, int c2, int d1, int d2){\\n        if(idx == balls.length){\\n            if(c1==c2 && d1==d2)  return 1;\\n            else return 0;\\n        } \\n        double ans = 0;\\n\\t\\t// For each color, we could select 0,1,2,...,balls[idx] and put in box A, and the rest in box B.\\n\\t\\t// If we put 0 balls in A, then the distinct color count d1 will not increase. If we put all balls[idx] in A and 0 in B, then the distinct color count d2 will not increase. For other cases, we increase d1 and d2 by 1 and go ahead process next color by calling dfs method .\\n        for(int i=0; i<=balls[idx];i++){\\n\\t\\t    // combination method is used to calculate the total number of combinations to select i balls from balls[idx]. \\n            ans += combination(balls[idx], i) * dfs(balls, idx+1, c1+i, c2+balls[idx]-i, d1+ (i==0 ? 0: 1), d2+(i==balls[idx] ? 0: 1));    \\n        }\\n        return ans;\\n    }\\n\\n    private double combination(int n, int k) {\\n        return factorial[n] / (factorial[k] *factorial[n - k]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858117,
                "title": "python-intuitive-short-solution",
                "content": "Basically just brute-force with some minor optimizations.\\n```python\\ndef getProbability(self, balls: List[int]) -> float:\\n    M = len(balls)\\n    N = sum(balls)\\n    F = [math.factorial(n) for n in range(N // 2 + 1)]\\n\\n    s1 = [0] * M\\n    s2 = [0] * M\\n\\n    def find(i):\\n        if i == M:\\n            if sum(s1) == sum(s2) and len([n for n in s1 if n]) == len([n for n in s2 if n]):\\n                base1 = F[N // 2] // math.prod(F[n] for n in s1)\\n                base2 = F[N // 2] // math.prod(F[n] for n in s2)\\n                return base1 * base2\\n            return 0\\n\\n        s = 0\\n        for n in range(balls[i]+1):\\n            s1[i] = n\\n            s2[i] = balls[i] - n\\n            s += find(i+1)\\n        return s\\n\\n    base = math.factorial(N) // math.prod(math.factorial(n) for n in balls)\\n    return find(0) / base\\n```\\nVote up if find this helpful, thanks!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef getProbability(self, balls: List[int]) -> float:\\n    M = len(balls)\\n    N = sum(balls)\\n    F = [math.factorial(n) for n in range(N // 2 + 1)]\\n\\n    s1 = [0] * M\\n    s2 = [0] * M\\n\\n    def find(i):\\n        if i == M:\\n            if sum(s1) == sum(s2) and len([n for n in s1 if n]) == len([n for n in s2 if n]):\\n                base1 = F[N // 2] // math.prod(F[n] for n in s1)\\n                base2 = F[N // 2] // math.prod(F[n] for n in s2)\\n                return base1 * base2\\n            return 0\\n\\n        s = 0\\n        for n in range(balls[i]+1):\\n            s1[i] = n\\n            s2[i] = balls[i] - n\\n            s += find(i+1)\\n        return s\\n\\n    base = math.factorial(N) // math.prod(math.factorial(n) for n in balls)\\n    return find(0) / base\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 661739,
                "title": "c-dfs-search-with-modularized-code-beats-100",
                "content": "The main idea is to use DFS search all possible picks. (After analyzing the data size, 6^8 ~= 1M should be good for us to search). \\nthen check if current pick satisfy the **equal distinct color** criterial.\\nFinally divided by all the possible combinitions to get the result.\\n\\nSome detailed notice here:\\n1. The combinition function is listed below, always multiply before divide, and alternate. You can prove the result will always be integer and no error.\\nFor example, pick 4 balls from 8 balls, C(8, 4), can be calculated in the order of: `8 / 1 * 7 / 2 * 6 / 3 * 5 / 4`, and you will not see any float number during the intermediate result.\\n\\n2. Whenever find a possible pick, for example, we picked `{2, 0, 1}` from `{4, 1, 1}`, even both side has 2 distict numbers, but the nominator should **NOT just simply add 1**, it should add some combinitions: `C(4, 2) * C(1, 0) * C(1, 1) = 6 * 1 * 1 = 6`\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        int sum = 0;\\n        for (int ball : balls) {\\n            sum += ball;\\n        }\\n        \\n        // This array store the picked balls in one box.\\n        // `balls - picks` will then in another box.\\n        vector<int> picks(balls.size(), 0); \\n        return double(DFS(balls, picks, sum / 2, 0)) / combinition(sum, sum / 2);\\n    }\\n    \\n    long DFS(const vector<int>& balls, vector<int>& picks, int remain, int idx) {\\n        if (remain == 0) {\\n            if (sameDistinctBall(balls, picks)) {\\n                long res = 1;\\n                for (int i = 0; i < balls.size(); i++) {\\n                    res *= combinition(balls.at(i), balls.at(i) - picks.at(i));\\n                }\\n                return res;\\n            }\\n            return 0;\\n        }\\n        if (idx >= balls.size()) {\\n            return 0;\\n        }\\n        long res = 0;\\n        // Search all possible picks for next index position.\\n        for (int i = 0; i <= balls.at(idx) and i <= remain; ++i) {\\n            picks[idx] = i;\\n            res += DFS(balls, picks, remain - i, idx + 1);\\n        }\\n        picks[idx] = 0;\\n        return res;\\n    }\\n    \\n    long combinition(int from, int pick) {\\n        pick = min(pick, from - pick);\\n        long res = 1;\\n        for (int i = 1, j = from; i <= pick; i++, j--) {\\n            res *= j;\\n            res /= i;\\n        }\\n        return res;\\n    }\\n    \\n    bool sameDistinctBall(const vector<int>& balls, const vector<int>& pick) {\\n        int box_a = 0, box_b = 0;\\n        for (int i = 0; i < balls.size(); ++i) {\\n            if (pick.at(i) > 0) {\\n                ++box_a;\\n            }\\n            if (balls.at(i) - pick.at(i) > 0) {\\n                ++box_b;\\n            }\\n        }\\n        return box_a == box_b;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        int sum = 0;\\n        for (int ball : balls) {\\n            sum += ball;\\n        }\\n        \\n        // This array store the picked balls in one box.\\n        // `balls - picks` will then in another box.\\n        vector<int> picks(balls.size(), 0); \\n        return double(DFS(balls, picks, sum / 2, 0)) / combinition(sum, sum / 2);\\n    }\\n    \\n    long DFS(const vector<int>& balls, vector<int>& picks, int remain, int idx) {\\n        if (remain == 0) {\\n            if (sameDistinctBall(balls, picks)) {\\n                long res = 1;\\n                for (int i = 0; i < balls.size(); i++) {\\n                    res *= combinition(balls.at(i), balls.at(i) - picks.at(i));\\n                }\\n                return res;\\n            }\\n            return 0;\\n        }\\n        if (idx >= balls.size()) {\\n            return 0;\\n        }\\n        long res = 0;\\n        // Search all possible picks for next index position.\\n        for (int i = 0; i <= balls.at(idx) and i <= remain; ++i) {\\n            picks[idx] = i;\\n            res += DFS(balls, picks, remain - i, idx + 1);\\n        }\\n        picks[idx] = 0;\\n        return res;\\n    }\\n    \\n    long combinition(int from, int pick) {\\n        pick = min(pick, from - pick);\\n        long res = 1;\\n        for (int i = 1, j = from; i <= pick; i++, j--) {\\n            res *= j;\\n            res /= i;\\n        }\\n        return res;\\n    }\\n    \\n    bool sameDistinctBall(const vector<int>& balls, const vector<int>& pick) {\\n        int box_a = 0, box_b = 0;\\n        for (int i = 0; i < balls.size(); ++i) {\\n            if (pick.at(i) > 0) {\\n                ++box_a;\\n            }\\n            if (balls.at(i) - pick.at(i) > 0) {\\n                ++box_b;\\n            }\\n        }\\n        return box_a == box_b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661667,
                "title": "python-commented-solution-simple-recursion-backtracking",
                "content": "Use simple recursion to assign the balls color by color to box 1 and check desired conditions after one full assignment. Refer to comments in the code.\\n\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        fact = [1]       # Array to store factorials\\n        \\n        # Populating factorials\\n        for i in range(1, 49):\\n            last = fact[-1]\\n            fact.append(i*last)\\n        \\n        # Note there are total k colors of balls\\n        k = len(balls)\\n        n = sum(balls)//2\\n        \\n        self.total = 0    # Total desired permutations for the 2 boxes (numerator for our answer)\\n        \\n\\t\\t# Simple helper method to find difference of two arrays (i.e. find box 2 given original list and box 1)\\n        def diff(arr1, arr2):\\n            return [arr1[i]-arr2[i] for i in range(k)]\\n\\t\\t\\n        # Simple helper method to return all nonzero elements of an array\\n        def nonZero(arr1):\\n            return [i for i in arr1 if i != 0]\\n        \\n        # Simple helper method to return total permutations when there are n total balls out of which lst[0] balls are of type 1, lst[1] balls are of type 2, ... lst[x-1] balls are of type x\\n        def perm(n, lst):\\n            num = fact[n]\\n            den = 1\\n            for i in lst:\\n                den *= fact[i]\\n            return num//den\\n        \\n        # Recursive method to iteratively assign given list of balls to first box (denoted by list b1) starting from ball color = idx (index)\\n\\t\\t# and update instance variable `self.total` if all conditions are satisfied\\n        def dfs(givenBalls, idx, b1):\\n            if idx == k or sum(b1) == n:\\n                if sum(b1) == n and len(nonZero(b1)) == len(nonZero(diff(givenBalls, b1))):     # desired condition: total balls in box1 = n and total colors in box1 = total colors in box2\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# We can use each permutation as many times as possible \"inside EACH box\" since the problem tells us they\\'re all unique \\n\\t\\t\\t\\t\\t# regardless of order. So [1, 2 | 1, 3] is separate from [2, 1 | 3, 1] which is separate from [1, 2 | 3, 1] and so on.\\n\\t\\t\\t\\t\\t\\n                    self.total += perm(n, nonZero(b1)) * perm(n, nonZero(diff(givenBalls, b1)))\\n\\t\\t\\t\\t\\t\\n            elif sum(b1) < n:\\n                for i in range(givenBalls[idx]+1):\\n                    b1[idx] = i       # assign i balls of color = idx to box 1\\n                    dfs(givenBalls, idx+1, b1)   # recursively call for next color of balls\\n                    b1[idx] = 0       # re-assign balls of color idx in box 1 to zero\\n        \\n        dfs(balls, 0, [0]*k)\\n        \\n        return self.total/perm(2*n, balls)\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        fact = [1]       # Array to store factorials\\n        \\n        # Populating factorials\\n        for i in range(1, 49):\\n            last = fact[-1]\\n            fact.append(i*last)\\n        \\n        # Note there are total k colors of balls\\n        k = len(balls)\\n        n = sum(balls)//2\\n        \\n        self.total = 0    # Total desired permutations for the 2 boxes (numerator for our answer)\\n        \\n\\t\\t# Simple helper method to find difference of two arrays (i.e. find box 2 given original list and box 1)\\n        def diff(arr1, arr2):\\n            return [arr1[i]-arr2[i] for i in range(k)]\\n\\t\\t\\n        # Simple helper method to return all nonzero elements of an array\\n        def nonZero(arr1):\\n            return [i for i in arr1 if i != 0]\\n        \\n        # Simple helper method to return total permutations when there are n total balls out of which lst[0] balls are of type 1, lst[1] balls are of type 2, ... lst[x-1] balls are of type x\\n        def perm(n, lst):\\n            num = fact[n]\\n            den = 1\\n            for i in lst:\\n                den *= fact[i]\\n            return num//den\\n        \\n        # Recursive method to iteratively assign given list of balls to first box (denoted by list b1) starting from ball color = idx (index)\\n\\t\\t# and update instance variable `self.total` if all conditions are satisfied\\n        def dfs(givenBalls, idx, b1):\\n            if idx == k or sum(b1) == n:\\n                if sum(b1) == n and len(nonZero(b1)) == len(nonZero(diff(givenBalls, b1))):     # desired condition: total balls in box1 = n and total colors in box1 = total colors in box2\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# We can use each permutation as many times as possible \"inside EACH box\" since the problem tells us they\\'re all unique \\n\\t\\t\\t\\t\\t# regardless of order. So [1, 2 | 1, 3] is separate from [2, 1 | 3, 1] which is separate from [1, 2 | 3, 1] and so on.\\n\\t\\t\\t\\t\\t\\n                    self.total += perm(n, nonZero(b1)) * perm(n, nonZero(diff(givenBalls, b1)))\\n\\t\\t\\t\\t\\t\\n            elif sum(b1) < n:\\n                for i in range(givenBalls[idx]+1):\\n                    b1[idx] = i       # assign i balls of color = idx to box 1\\n                    dfs(givenBalls, idx+1, b1)   # recursively call for next color of balls\\n                    b1[idx] = 0       # re-assign balls of color idx in box 1 to zero\\n        \\n        dfs(balls, 0, [0]*k)\\n        \\n        return self.total/perm(2*n, balls)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230931,
                "title": "python3-dp-memoization",
                "content": "Not the shortest but pretty easy to understand. For each ball, we have 2 choices, either put it into the first box (`first`), or put it into the second box. The consequence will be adding a distinct color potentially. The colors are kept as bit masks (`color1` for box 1 and `color2` for box 2, respectively). Once all balls have been placed, we cound how many 1\\'s are in `color1` and `color2`.\\n\\n```python\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        k = len(balls)\\n        n = sum(balls)//2\\n        array = []\\n        for i in range(k):\\n            array += [i] * balls[i]\\n        total = factorial(2*n) // (factorial(n) * factorial(n))\\n\\n        @lru_cache(None)\\n        def dp(i, first, color1, color2):\\n            if first > n or i - first > n:\\n                return 0\\n            if i == 2*n:\\n                return bin(color1).count(\\'1\\') == bin(color2).count(\\'1\\')\\n            mask = 1 << array[i]\\n            return dp(i + 1, first + 1, color1 | mask, color2) + \\\\\\n                    dp(i + 1, first, color1, color2 | mask)\\n        \\n        return dp(0, 0, 0, 0) / total\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        k = len(balls)\\n        n = sum(balls)//2\\n        array = []\\n        for i in range(k):\\n            array += [i] * balls[i]\\n        total = factorial(2*n) // (factorial(n) * factorial(n))\\n\\n        @lru_cache(None)\\n        def dp(i, first, color1, color2):\\n            if first > n or i - first > n:\\n                return 0\\n            if i == 2*n:\\n                return bin(color1).count(\\'1\\') == bin(color2).count(\\'1\\')\\n            mask = 1 << array[i]\\n            return dp(i + 1, first + 1, color1 | mask, color2) + \\\\\\n                    dp(i + 1, first, color1, color2 | mask)\\n        \\n        return dp(0, 0, 0, 0) / total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663491,
                "title": "java-beats-100",
                "content": "Calculate all valid cases.\\n\\nTotal cases - sum(arr)!/arr[0]!*......arr[n-1]!\\n```\\n\\nclass Solution {\\n    \\n    private static double[] PERMS;\\n    private int sum;\\n    \\n    public double getProbability(int[] balls) {\\n        sum = 0;\\n        \\n        for(int i = 0; i < balls.length; ++i) {\\n            sum += balls[i];    \\n        }\\n        \\n        PERMS = new double[sum + 1];\\n        PERMS[0] = 1;\\n        \\n        // Precalculate premutations\\n        for(int i = 1; i < PERMS.length; ++i) {\\n            PERMS[i] = i * PERMS[i - 1];\\n        }\\n        \\n        return splitHelper(balls, 0, new int[balls.length], new int[balls.length], 0, 0)/permutation(balls);\\n    }\\n    \\n    \\n    private double splitHelper(int[] balls, int idx, int[] A, int[] B, int sumA, int sumB) {\\n        if(sumA > sum/2 || sumB > sum/2) return 0; //invalid split\\n        \\n        // Equal split\\n        if(idx == balls.length) {\\n            int ca = 0, cb = 0;\\n            \\n            for(int i = 0; i < A.length; ++i) if(A[i] > 0) ca++;\\n            for(int i = 0; i < B.length; ++i) if(B[i] > 0) cb++;\\n            \\n            if(ca == cb) return permutation(A) * permutation(B); //valid split\\n            \\n            return 0; //invalid split\\n        }\\n        \\n        double count = 0.0;\\n        for(int i = 0; i <= balls[idx]; ++i) {\\n            A[idx] = i;\\n            B[idx] = balls[idx] - i;\\n            count += splitHelper(balls, idx + 1, A, B, sumA + A[idx], sumB + B[idx]);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private double permutation(int[] arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length; ++i) {\\n            count += arr[i];\\n        }\\n        \\n        double res = PERMS[count];\\n        for(int i = 0; i < arr.length; ++i) {\\n            res /= PERMS[arr[i]];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    private static double[] PERMS;\\n    private int sum;\\n    \\n    public double getProbability(int[] balls) {\\n        sum = 0;\\n        \\n        for(int i = 0; i < balls.length; ++i) {\\n            sum += balls[i];    \\n        }\\n        \\n        PERMS = new double[sum + 1];\\n        PERMS[0] = 1;\\n        \\n        // Precalculate premutations\\n        for(int i = 1; i < PERMS.length; ++i) {\\n            PERMS[i] = i * PERMS[i - 1];\\n        }\\n        \\n        return splitHelper(balls, 0, new int[balls.length], new int[balls.length], 0, 0)/permutation(balls);\\n    }\\n    \\n    \\n    private double splitHelper(int[] balls, int idx, int[] A, int[] B, int sumA, int sumB) {\\n        if(sumA > sum/2 || sumB > sum/2) return 0; //invalid split\\n        \\n        // Equal split\\n        if(idx == balls.length) {\\n            int ca = 0, cb = 0;\\n            \\n            for(int i = 0; i < A.length; ++i) if(A[i] > 0) ca++;\\n            for(int i = 0; i < B.length; ++i) if(B[i] > 0) cb++;\\n            \\n            if(ca == cb) return permutation(A) * permutation(B); //valid split\\n            \\n            return 0; //invalid split\\n        }\\n        \\n        double count = 0.0;\\n        for(int i = 0; i <= balls[idx]; ++i) {\\n            A[idx] = i;\\n            B[idx] = balls[idx] - i;\\n            count += splitHelper(balls, idx + 1, A, B, sumA + A[idx], sumB + B[idx]);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private double permutation(int[] arr) {\\n        int count = 0;\\n        for(int i = 0; i < arr.length; ++i) {\\n            count += arr[i];\\n        }\\n        \\n        double res = PERMS[count];\\n        for(int i = 0; i < arr.length; ++i) {\\n            res /= PERMS[arr[i]];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663378,
                "title": "python-dp-beat-100",
                "content": "The helper function returns the number of ways to achieve:\\n1. There are \"offset\" more unique balls in boxA and boxB\\n2. There are \"num1\" balls in boxA and \"num2\" balls in boxB\\n3. Use balls before \"idx\" of the ball array\\n\\nThere are three possibilities to meet the requirement:\\n1. For each k in (1,balls[idx]-1), add number of ways to put k in boxB \"comb(balls[idx],k)\" and multiply helper(offset,num1-balls[idx]+k,num2-k,idx-1)\\n2. Put all balls[idx] in boxA and add  helper(offset-1,num1-balls[idx],num2,idx-1)\\n3. Put all balls[idx] in boxB and add helper(offset+1,num1,num2-balls[idx],idx-1)\\n\\nThe base case is when the idx==-1, check if num1==num2==offset==0. If not, return 0 as there is no such way to achieve that.\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        allComb = comb(sum(balls),sum(balls)//2)\\n        @lru_cache(None)\\n        #num of unique balls in boxA-boxB, num of total balls in boxA, num of total balls in boxB, current bucket\\n        def helper(offset,num1,num2,idx):\\n            if idx==-1:\\n                return num1==num2==offset==0\\n            res = 0\\n            for k in range(1,balls[idx]):\\n                res+=helper(offset,num1-balls[idx]+k,num2-k,idx-1)*comb(balls[idx],k)\\n            res+=helper(offset-1,num1-balls[idx],num2,idx-1)\\n            res+=helper(offset+1,num1,num2-balls[idx],idx-1)\\n            return res\\n        return helper(0,sum(balls)//2,sum(balls)//2,len(balls)-1)/allComb\\n```\\n\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        allComb = comb(sum(balls),sum(balls)//2)\\n        @lru_cache(None)\\n        #num of unique balls in boxA-boxB, num of total balls in boxA, num of total balls in boxB, current bucket\\n        def helper(offset,num1,num2,idx):\\n            if idx==-1:\\n                return num1==num2==offset==0\\n            res = 0\\n            for k in range(1,balls[idx]):\\n                res+=helper(offset,num1-balls[idx]+k,num2-k,idx-1)*comb(balls[idx],k)\\n            res+=helper(offset-1,num1-balls[idx],num2,idx-1)\\n            res+=helper(offset+1,num1,num2-balls[idx],idx-1)\\n            return res\\n        return helper(0,sum(balls)//2,sum(balls)//2,len(balls)-1)/allComb\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662076,
                "title": "java-clean-recursive-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    double num=0;\\n    double fact[];\\n    public double getProbability(int[] balls) {\\n        int n2 = Arrays.stream(balls).sum();\\n        fact = new double[n2+1];\\n        fact[0]=1;\\n        for(int i=1;i<=n2;++i) fact[i]=i*fact[i-1];\\n        helper(balls,0,0,0,0,0,1,1,n2/2);\\n        return num/getDen(balls,n2);\\n    }\\n    \\n    /**\\n        i Current index of the balls array\\n        b1/b2 Total balls in box1/box2\\n        c1/c2 Total distinct ball types in box1/box2\\n        dup1/dup2 double value maintaining the product of factorial of count of each distinct balls in box1/box2\\n    **/\\n    void helper(int[] balls, int i, int b1, int b2, int c1, int c2, double dup1, double dup2, int n){\\n        if(i==balls.length){\\n            /**\\n\\t\\t\\t    Because of the check we do before recursing, b1 & b2 should be n now. \\n                If number of distinct color balls are the same in box1 and box2, this is a valid combination.\\n                Permutations of balls in box1P = n!/dup1\\n                                         box2P = n!/dup2\\n                    Total permutation is box1P*box2P\\n                                \\n            **/\\n            if(c1==c2) num+=((fact[n]/dup1)*(fact[n]/dup2)); \\n            return;\\n        }\\n\\t\\t/**\\n\\t\\t\\tTry all the possible valid combinations of placing balls[i] \"i\" color balls into box1 and box2 such that total balls in each is less than equal to n\\n\\t\\t**/\\n        for(int j=0;j<=balls[i];++j)\\n            if((b1+j)<=n && (b2+(balls[i]-j))<=n)\\n                helper(balls, i+1, b1+j, b2+(balls[i]-j), c1+(j==0?0:1), c2+((balls[i]-j)==0?0:1), dup1*fact[j], dup2*fact[balls[i]-j], n);\\n    }\\n    \\n    /**\\n        The denominator will always be (totalNumOfBalls)! / ( (balls[0])! * (balls[1])! * ... * (balls[k-1])!)\\n    **/\\n    double getDen(int[] balls,int sum){\\n        double t = fact[sum];\\n        for(int i=0;i<balls.length;++i) t/=fact[balls[i]];\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double num=0;\\n    double fact[];\\n    public double getProbability(int[] balls) {\\n        int n2 = Arrays.stream(balls).sum();\\n        fact = new double[n2+1];\\n        fact[0]=1;\\n        for(int i=1;i<=n2;++i) fact[i]=i*fact[i-1];\\n        helper(balls,0,0,0,0,0,1,1,n2/2);\\n        return num/getDen(balls,n2);\\n    }\\n    \\n    /**\\n        i Current index of the balls array\\n        b1/b2 Total balls in box1/box2\\n        c1/c2 Total distinct ball types in box1/box2\\n        dup1/dup2 double value maintaining the product of factorial of count of each distinct balls in box1/box2\\n    **/\\n    void helper(int[] balls, int i, int b1, int b2, int c1, int c2, double dup1, double dup2, int n){\\n        if(i==balls.length){\\n            /**\\n\\t\\t\\t    Because of the check we do before recursing, b1 & b2 should be n now. \\n                If number of distinct color balls are the same in box1 and box2, this is a valid combination.\\n                Permutations of balls in box1P = n!/dup1\\n                                         box2P = n!/dup2\\n                    Total permutation is box1P*box2P\\n                                \\n            **/\\n            if(c1==c2) num+=((fact[n]/dup1)*(fact[n]/dup2)); \\n            return;\\n        }\\n\\t\\t/**\\n\\t\\t\\tTry all the possible valid combinations of placing balls[i] \"i\" color balls into box1 and box2 such that total balls in each is less than equal to n\\n\\t\\t**/\\n        for(int j=0;j<=balls[i];++j)\\n            if((b1+j)<=n && (b2+(balls[i]-j))<=n)\\n                helper(balls, i+1, b1+j, b2+(balls[i]-j), c1+(j==0?0:1), c2+((balls[i]-j)==0?0:1), dup1*fact[j], dup2*fact[balls[i]-j], n);\\n    }\\n    \\n    /**\\n        The denominator will always be (totalNumOfBalls)! / ( (balls[0])! * (balls[1])! * ... * (balls[k-1])!)\\n    **/\\n    double getDen(int[] balls,int sum){\\n        double t = fact[sum];\\n        for(int i=0;i<balls.length;++i) t/=fact[balls[i]];\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098639,
                "title": "backtracking-math",
                "content": "```\\nclass Solution {\\npublic:\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    vector<int> first,second;\\n    \\n    double getProbability(vector<int>& balls) \\n    {\\n        first.resize(10,0);\\n        second.resize(10,0);\\n        dfs(balls, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    void dfs(vector<int>& balls, int num1, int num2, int idx) \\n    {\\n        if (idx == balls.size()) \\n        {\\n            if (num1 == num2) \\n            {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second))\\n                    valid += distrib;\\n            }\\n            return;\\n        }\\n        \\n        \\n        for (int b = 0; b <= balls[idx]; b++) \\n        {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    int unique(vector<int> &balls) \\n    {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    double permFake(vector<int> &balls) \\n    {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    int factorial(int n)\\n    {\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    vector<int> first,second;\\n    \\n    double getProbability(vector<int>& balls) \\n    {\\n        first.resize(10,0);\\n        second.resize(10,0);\\n        dfs(balls, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    void dfs(vector<int>& balls, int num1, int num2, int idx) \\n    {\\n        if (idx == balls.size()) \\n        {\\n            if (num1 == num2) \\n            {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second))\\n                    valid += distrib;\\n            }\\n            return;\\n        }\\n        \\n        \\n        for (int b = 0; b <= balls[idx]; b++) \\n        {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    int unique(vector<int> &balls) \\n    {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    double permFake(vector<int> &balls) \\n    {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    int factorial(int n)\\n    {\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686464,
                "title": "python-two-solutions-dfs-beets-100",
                "content": "Solution1:\\n* Let p0 = Probability of a Two Boxes Having The Same Number of **Distinct Balls**, p1 = Probability of a Two Boxes Having The Same Number of Balls*\\n* Then ans = p0 / p1\\n* We just need to find Probability of a Two Boxes Having The Same Number of **Distinct Balls**, and Probability of a Two Boxes Having The Same Number of Balls*. DFS is a choice.\\n* Say we have assign balls[:i], difference of the number of distinct balls between two boxes is ***d***, difference of the number of balls between two boxes is ***cnt***, and the probability to go into this case is ***pro***. We are now divide balls[i] into 2 parts and assign them into two boxes.\\n* select t balls from balls[i], 0 <= t < balls[i], and assign them to first box, and balls[i] - t balls to second box, then the probability will be ***pro * C(t, balls[i]) / 2^balls[i]***\\n* after we have assigned all balls, meaning i == k, then if d == 0 and cnt == 0, ***p0 += pro***, if cnt == 0, then ***p1 += pro***\\n* after searching all cases, ***ans = p0 / p1***\\n* To reduce search depth, in cases that sum(balls[:i]) > abs(cnt), it is impossible to keep the number of balls or distinct balls of two boxes ballance, we stop.\\n* Time complexity: O(balls[0] * balls[1] * ... * balls[k - 1])\\n```\\nclass Solution(object):\\n    def getProbability(self, balls):\\n        \"\"\"\\n        :type balls: List[int]\\n        :rtype: float\\n        \"\"\"\\n        def dfs(i, d, cnt, pro):\\n            if i == k:\\n                if cnt == 0:\\n                    self.base += pro\\n                    if d == 0:\\n                        self.ans += pro\\n            elif abs(cnt) <= total[-1] - total[i]:\\n                cur = 1.0 / (1 << balls[i])\\n                dfs(i + 1, d + 1, cnt + balls[i], pro * cur)\\n                dfs(i + 1, d - 1, cnt - balls[i], pro * cur)\\n                for j in range(1, balls[i]):\\n                    cur = cur * (balls[i] - j + 1) / j\\n                    dfs(i + 1, d, cnt + j - (balls[i] - j), pro * cur)\\n\\n        k = len(balls)\\n        total = [0]\\n        for b in balls:\\n            total.append(total[-1] + b)\\n        self.ans = 0\\n        self.base = 0\\n        dfs(0, 0, 0, 1.0)\\n        return self.ans / self.base\\n```\\n\\nSolution2:\\n* let ***cnt0*** = the number of ways to assign same number of distinct balls and same number of balls into two boxes, ***cnt1*** = the number of ways to assign same number of balls into two boxes, then the answer will be ***cnt0 / cnt1***\\n* Our goal is to count the number of cnt0 and cnt1.\\n* dp[i, d, cnt] denotes the number of cnt0 and cnt1 to assign balls[i:] with current difference of distinct balls and difference of balls of two boxes.\\n* Hence, \\n*dp[i, d, cnt] = sum(C(t, balls[i]) * dp[i + 1, d + (-1 if t == 0 else 1 if t == balls[i] else 0, cnt + t - (balls[i] - t))])*\\n* Same with Solution1, if abs(cnt) > sum(balls[i:]), just return [0, 0]\\n* Time complexity: O(NMK^2), where N is the total number of balls, M is the maximum balls[i]\\n\\n```\\ndef dfs(i, d, cnt):\\n            if i == k:\\n                return [1 if cnt == 0 else 0, 1 if d == 0 and cnt == 0 else 0]\\n            if abs(cnt) <= total[-1] - total[i]:\\n                if (i, d, cnt) not in memo:\\n                    valid0 = valid1 = 0\\n                    for delta in (-1, 1):\\n                        v0, v1 = dfs(i + 1, d + delta, cnt + delta * balls[i])\\n                        valid0 += v0\\n                        valid1 += v1\\n                    cur = 1\\n                    for j in range(1, balls[i]):\\n                        cur = cur * (balls[i] - j + 1) // j\\n                        v0, v1 = dfs(i + 1, d, cnt + j - (balls[i] - j))\\n                        valid0 += cur * v0\\n                        valid1 += cur * v1\\n                    memo[i, d, cnt] = [valid0, valid1]\\n                return memo[i, d, cnt]\\n            return [0, 0]\\n\\n        k = len(balls)\\n        total = [0]\\n        for b in balls:\\n            total.append(total[-1] + b)\\n        memo = collections.defaultdict(list)\\n        base, ans = dfs(0, 0, 0)\\n        return ans * 1.0 / base\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getProbability(self, balls):\\n        \"\"\"\\n        :type balls: List[int]\\n        :rtype: float\\n        \"\"\"\\n        def dfs(i, d, cnt, pro):\\n            if i == k:\\n                if cnt == 0:\\n                    self.base += pro\\n                    if d == 0:\\n                        self.ans += pro\\n            elif abs(cnt) <= total[-1] - total[i]:\\n                cur = 1.0 / (1 << balls[i])\\n                dfs(i + 1, d + 1, cnt + balls[i], pro * cur)\\n                dfs(i + 1, d - 1, cnt - balls[i], pro * cur)\\n                for j in range(1, balls[i]):\\n                    cur = cur * (balls[i] - j + 1) / j\\n                    dfs(i + 1, d, cnt + j - (balls[i] - j), pro * cur)\\n\\n        k = len(balls)\\n        total = [0]\\n        for b in balls:\\n            total.append(total[-1] + b)\\n        self.ans = 0\\n        self.base = 0\\n        dfs(0, 0, 0, 1.0)\\n        return self.ans / self.base\\n```\n```\\ndef dfs(i, d, cnt):\\n            if i == k:\\n                return [1 if cnt == 0 else 0, 1 if d == 0 and cnt == 0 else 0]\\n            if abs(cnt) <= total[-1] - total[i]:\\n                if (i, d, cnt) not in memo:\\n                    valid0 = valid1 = 0\\n                    for delta in (-1, 1):\\n                        v0, v1 = dfs(i + 1, d + delta, cnt + delta * balls[i])\\n                        valid0 += v0\\n                        valid1 += v1\\n                    cur = 1\\n                    for j in range(1, balls[i]):\\n                        cur = cur * (balls[i] - j + 1) // j\\n                        v0, v1 = dfs(i + 1, d, cnt + j - (balls[i] - j))\\n                        valid0 += cur * v0\\n                        valid1 += cur * v1\\n                    memo[i, d, cnt] = [valid0, valid1]\\n                return memo[i, d, cnt]\\n            return [0, 0]\\n\\n        k = len(balls)\\n        total = [0]\\n        for b in balls:\\n            total.append(total[-1] + b)\\n        memo = collections.defaultdict(list)\\n        base, ans = dfs(0, 0, 0)\\n        return ans * 1.0 / base\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018837,
                "title": "c-solution-16-ms-o-numballs-numcolors-counting-all-possible-ways-no-memoization",
                "content": "The essence of this approach is to go color by color, from left to right, and consider all possible ways you could assign balls of that color to the left and right groups. \\n\\nIn order to limit the recursive step to valid ways of assigning colors, you will calculate an upperbound that will equal the total number of balls divided by two. This is the most number of balls that can be assigned to the left group (or right group). When considering a specific color, you cannot assign more balls than there are of that color, so in each round, the upper bound is also capped at the number of balls of the given color.\\nA lower bound will be calculated as the minimum number of balls that the left group needs from the specific color in order to be able to reach half of the total number of balls. To calculate this, we will create a table of the number of balls remaining at each color, when going from left to right. So a problem with [6, 3, 4, 3] will have such a table equal to [10, 7, 3, 0].\\n\\nThen, looping from the lower bound to the upper bound, the function will recursively call itself at the next color, having assigned an amount of balls to the left group equal to the current value in the loop. Any balls that were not assigned to the left group were assumed to be assigned to the right group. If 0 balls were assigned, only the number of unique colors in the right group will increase. If all balls were assigned, only the number in the left increase. Otherwise, they both increase.\\n\\nIf you assign 3 out of 5 balls to the left group, there are 5 choose 3 possible ways that that assigning could have happened. In the recursive function, you will keep track of the number of ways that you could have gotten to the current state of left and right groups, starting with 1. This number is multiplied by n choose k (number of balls of given color choose number of balls assigned to left) at each round. \\n\\nThe base case of the function is when the index indicating the color of ball passes the final color. If the numbe of unique colors in the left and right groups are equal, then the number of ways to get to the current state of left and right groups is added to a variable tracking the number of ways to split the balls into an equal number of colors for each group. Otherwise, it is added to a variable tracking the number of ways that the balls are split so the number of colors are not equal. \\n\\nAfter the recursive function is finished, the answer is returned as waysEqual / (waysEqual + waysUnequal)\\n \\n\\n\\n\\n\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid calcWays(int splitIndex, long long currentWays, int *powers, long long *waysEven, long long *waysUneven, int numBalls, int *ballsLeft, int *balls, int ballsSize, int leftGroups, int rightGroups);\\nint minCustom(int op1, int op2);\\nint maxCustom(int op1, int op2);\\nint findNumBalls(int* balls, int ballsSize);\\nint nChooseK(int *powers, int n, int k);\\nint * fillPowers(int powersSize);\\nint * fillBallsLeft(int ballsSize, int *balls);\\ndouble divide(long long numerator, long long denominator);\\n\\ndouble getProbability(int* balls, int ballsSize) {\\n  int *powers = fillPowers(7);\\n\\n  int splitIndex = 0;\\n  long long currentWays = 1;\\n  long long waysEven = 0;\\n  long long waysUneven = 0;\\n  int numBalls = findNumBalls(balls, ballsSize);\\n  int leftGroups = 0;\\n  int rightGroups = 0;\\n\\n  int *ballsLeft = fillBallsLeft(ballsSize, balls);\\n\\n  calcWays(splitIndex, currentWays, powers, &waysEven, &waysUneven, numBalls/2, ballsLeft, balls, ballsSize, leftGroups, rightGroups);\\n  return divide(waysEven, waysEven + waysUneven);\\n}\\n\\nvoid calcWays(int splitIndex, long long currentWays, int *powers, long long *waysEven, long long *waysUneven, int numBalls, int *ballsLeft, int *balls, int ballsSize, int leftGroups, int rightGroups) {\\n  if(splitIndex == ballsSize) {\\n    if(leftGroups != rightGroups) {\\n      *waysUneven += currentWays;\\n    } else {\\n      *waysEven += currentWays;\\n    }\\n  } else {\\n    int lowerBound = maxCustom(numBalls - ballsLeft[splitIndex], 0);\\n    int upperBound = minCustom(balls[splitIndex], numBalls);\\n    for(int i = lowerBound; i <= upperBound; i++) {\\n      int leftGroupIncrease = (i == 0)? 0: 1;\\n      int rightGroupIncrease = (i == balls[splitIndex])? 0: 1;\\n      calcWays(splitIndex+1, currentWays * nChooseK(powers, balls[splitIndex], i), powers, waysEven, waysUneven, numBalls-i, ballsLeft, balls, ballsSize, leftGroups+leftGroupIncrease, rightGroups+rightGroupIncrease);\\n    }\\n  }\\n}\\n\\nint minCustom(int op1, int op2) {\\n  if(op1 > op2) {\\n    return op2;\\n  }\\n  return op1;\\n}\\n\\nint maxCustom(int op1, int op2) {\\n  if(op1 > op2) {\\n    return op1;\\n  }\\n  return op2;\\n}\\n\\nint findNumBalls(int* balls, int ballsSize) {\\n  int numBalls = 0;\\n  for(int i = 0; i < ballsSize; i++) {\\n    numBalls += balls[i];\\n  }\\n  return numBalls;\\n}\\n\\nint nChooseK(int *powers, int n, int k) {\\n  int numerator = powers[n];\\n  int denominator = powers[k] * powers[n-k];\\n  return numerator / denominator;\\n}\\n\\nint * fillPowers(int powersSize) {\\n  int *powers = (int*) malloc(powersSize * sizeof(int));\\n  powers[0] = 1;\\n  for(int i = 1; i < powersSize; i++) {\\n    powers[i] = i * powers[i-1];\\n  }\\n  return powers;\\n}\\n\\nint * fillBallsLeft(int ballsSize, int *balls) {\\n  int *ballsLeft = (int*) malloc(ballsSize * sizeof(int));\\n\\n  int trackBallsLeft = 0;\\n  for(int i = ballsSize-1; i >= 0; i--) {\\n    ballsLeft[i] = trackBallsLeft;\\n    trackBallsLeft += balls[i];\\n  }\\n\\n  return ballsLeft;\\n}\\n\\ndouble divide(long long numerator, long long denominator) {\\n  return (double) numerator / denominator;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nvoid calcWays(int splitIndex, long long currentWays, int *powers, long long *waysEven, long long *waysUneven, int numBalls, int *ballsLeft, int *balls, int ballsSize, int leftGroups, int rightGroups);\\nint minCustom(int op1, int op2);\\nint maxCustom(int op1, int op2);\\nint findNumBalls(int* balls, int ballsSize);\\nint nChooseK(int *powers, int n, int k);\\nint * fillPowers(int powersSize);\\nint * fillBallsLeft(int ballsSize, int *balls);\\ndouble divide(long long numerator, long long denominator);\\n\\ndouble getProbability(int* balls, int ballsSize) {\\n  int *powers = fillPowers(7);\\n\\n  int splitIndex = 0;\\n  long long currentWays = 1;\\n  long long waysEven = 0;\\n  long long waysUneven = 0;\\n  int numBalls = findNumBalls(balls, ballsSize);\\n  int leftGroups = 0;\\n  int rightGroups = 0;\\n\\n  int *ballsLeft = fillBallsLeft(ballsSize, balls);\\n\\n  calcWays(splitIndex, currentWays, powers, &waysEven, &waysUneven, numBalls/2, ballsLeft, balls, ballsSize, leftGroups, rightGroups);\\n  return divide(waysEven, waysEven + waysUneven);\\n}\\n\\nvoid calcWays(int splitIndex, long long currentWays, int *powers, long long *waysEven, long long *waysUneven, int numBalls, int *ballsLeft, int *balls, int ballsSize, int leftGroups, int rightGroups) {\\n  if(splitIndex == ballsSize) {\\n    if(leftGroups != rightGroups) {\\n      *waysUneven += currentWays;\\n    } else {\\n      *waysEven += currentWays;\\n    }\\n  } else {\\n    int lowerBound = maxCustom(numBalls - ballsLeft[splitIndex], 0);\\n    int upperBound = minCustom(balls[splitIndex], numBalls);\\n    for(int i = lowerBound; i <= upperBound; i++) {\\n      int leftGroupIncrease = (i == 0)? 0: 1;\\n      int rightGroupIncrease = (i == balls[splitIndex])? 0: 1;\\n      calcWays(splitIndex+1, currentWays * nChooseK(powers, balls[splitIndex], i), powers, waysEven, waysUneven, numBalls-i, ballsLeft, balls, ballsSize, leftGroups+leftGroupIncrease, rightGroups+rightGroupIncrease);\\n    }\\n  }\\n}\\n\\nint minCustom(int op1, int op2) {\\n  if(op1 > op2) {\\n    return op2;\\n  }\\n  return op1;\\n}\\n\\nint maxCustom(int op1, int op2) {\\n  if(op1 > op2) {\\n    return op1;\\n  }\\n  return op2;\\n}\\n\\nint findNumBalls(int* balls, int ballsSize) {\\n  int numBalls = 0;\\n  for(int i = 0; i < ballsSize; i++) {\\n    numBalls += balls[i];\\n  }\\n  return numBalls;\\n}\\n\\nint nChooseK(int *powers, int n, int k) {\\n  int numerator = powers[n];\\n  int denominator = powers[k] * powers[n-k];\\n  return numerator / denominator;\\n}\\n\\nint * fillPowers(int powersSize) {\\n  int *powers = (int*) malloc(powersSize * sizeof(int));\\n  powers[0] = 1;\\n  for(int i = 1; i < powersSize; i++) {\\n    powers[i] = i * powers[i-1];\\n  }\\n  return powers;\\n}\\n\\nint * fillBallsLeft(int ballsSize, int *balls) {\\n  int *ballsLeft = (int*) malloc(ballsSize * sizeof(int));\\n\\n  int trackBallsLeft = 0;\\n  for(int i = ballsSize-1; i >= 0; i--) {\\n    ballsLeft[i] = trackBallsLeft;\\n    trackBallsLeft += balls[i];\\n  }\\n\\n  return ballsLeft;\\n}\\n\\ndouble divide(long long numerator, long long denominator) {\\n  return (double) numerator / denominator;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 673790,
                "title": "java-solution-using-memoization",
                "content": "```\\nclass Solution {\\n    int N = 0, k = 0;\\n    int[] c;\\n    int[] rem_balls;\\n    \\n    public double getProbability(int[] balls) {\\n        k = balls.length;\\n        c = balls;\\n        for (int count : balls) N += count;\\n        \\n        rem_balls = new int[k];\\n        rem_balls[k - 1] = 0;\\n        for (int i = k - 2; i >= 0; i--) rem_balls[i] = rem_balls[i + 1] + balls[i + 1];\\n        \\n        double total = factorial(N);\\n        for (int count : balls) total /= factorial(count);\\n        \\n        double eq = find(0, new HashMap<>(), 0, new HashMap<>(), \"\");\\n        return eq / total;\\n    }\\n    \\n    private double find(int p, Map<Integer, Integer> A, int a_count, Map<String, Double> memo, String key) {\\n        if (memo.containsKey(key)) return memo.get(key);\\n        \\n        int n = N / 2;\\n        double ways = 0;\\n        int rem_a = n - a_count;\\n        \\n        if (rem_a == 0) {\\n            Map<Integer, Integer> B = new HashMap<>();\\n            for (int i = 0; i < k; i++) {\\n                int b_i = c[i] - A.getOrDefault(i, 0);\\n                if (b_i > 0) B.put(i, b_i);\\n            }\\n            if (A.size() == B.size()) {\\n                double perms = factorial(n);\\n                double perms_a = perms, perms_b = perms;\\n                \\n                for (Map.Entry<Integer, Integer> entry : A.entrySet()) perms_a /= factorial(entry.getValue());\\n                for (Map.Entry<Integer, Integer> entry : B.entrySet()) perms_b /= factorial(entry.getValue());\\n            \\n                ways = perms_a * perms_b;\\n            }\\n            memo.put(key, ways);\\n            return ways;\\n        }\\n        \\n        int max = Math.min(rem_a, c[p]);\\n        int min = rem_balls[p] >= rem_a ? 0 : rem_a - rem_balls[p];\\n\\n        for (int i = min; i <= max; i++) {\\n            if (i > 0) A.put(p, i);\\n            ways += find(p + 1, A, a_count + i, memo, key + \":\" + i);\\n            A.remove(p);\\n        }\\n        \\n        memo.put(key, ways);\\n        return ways;\\n    }\\n    \\n    private double factorial(int num) {\\n        double fac = 1;\\n        for (int i = 2; i <= num; i++) fac *= i;\\n        return fac;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int N = 0, k = 0;\\n    int[] c;\\n    int[] rem_balls;\\n    \\n    public double getProbability(int[] balls) {\\n        k = balls.length;\\n        c = balls;\\n        for (int count : balls) N += count;\\n        \\n        rem_balls = new int[k];\\n        rem_balls[k - 1] = 0;\\n        for (int i = k - 2; i >= 0; i--) rem_balls[i] = rem_balls[i + 1] + balls[i + 1];\\n        \\n        double total = factorial(N);\\n        for (int count : balls) total /= factorial(count);\\n        \\n        double eq = find(0, new HashMap<>(), 0, new HashMap<>(), \"\");\\n        return eq / total;\\n    }\\n    \\n    private double find(int p, Map<Integer, Integer> A, int a_count, Map<String, Double> memo, String key) {\\n        if (memo.containsKey(key)) return memo.get(key);\\n        \\n        int n = N / 2;\\n        double ways = 0;\\n        int rem_a = n - a_count;\\n        \\n        if (rem_a == 0) {\\n            Map<Integer, Integer> B = new HashMap<>();\\n            for (int i = 0; i < k; i++) {\\n                int b_i = c[i] - A.getOrDefault(i, 0);\\n                if (b_i > 0) B.put(i, b_i);\\n            }\\n            if (A.size() == B.size()) {\\n                double perms = factorial(n);\\n                double perms_a = perms, perms_b = perms;\\n                \\n                for (Map.Entry<Integer, Integer> entry : A.entrySet()) perms_a /= factorial(entry.getValue());\\n                for (Map.Entry<Integer, Integer> entry : B.entrySet()) perms_b /= factorial(entry.getValue());\\n            \\n                ways = perms_a * perms_b;\\n            }\\n            memo.put(key, ways);\\n            return ways;\\n        }\\n        \\n        int max = Math.min(rem_a, c[p]);\\n        int min = rem_balls[p] >= rem_a ? 0 : rem_a - rem_balls[p];\\n\\n        for (int i = min; i <= max; i++) {\\n            if (i > 0) A.put(p, i);\\n            ways += find(p + 1, A, a_count + i, memo, key + \":\" + i);\\n            A.remove(p);\\n        }\\n        \\n        memo.put(key, ways);\\n        return ways;\\n    }\\n    \\n    private double factorial(int num) {\\n        double fac = 1;\\n        for (int i = 2; i <= num; i++) fac *= i;\\n        return fac;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666103,
                "title": "c-8ms-93-simple-dp-solution-with-detailed-explanation-english-chinese",
                "content": "\\nIn this problem, we use dynamic programming.\\n\\n**State design**: The state is designed to be dp[i][j], where, i denotes (left ball count - right ball count)\\uFF0Cwhile j is (left color count - right color count). And the value(dp[i][j]) means how many kinds of arrangements that can reach this state.\\ne.g.left: [1,2,3] right: [1,1,2,4]. Then i=-1 and j=0 (three different colors).\\n\\n**Result**: According to the problem, the final answer of dp[0][0] is the required  arrangements (left and right have n balls, and same count of colors). And we can sum dp[0][j] to find how many ways that meet \"left and right have n balls\". So the final answer is dp[0][0]/sum_j{dp[0][j]}.\\n\\n**State transition**: We iterate the array balls[], where use idx as index. for ball[idx] (write as num)\\uFF0Cwe have num+1 ways of arrangements: (0,num),(1,num-1),(...)(num,0). In each arrangement we can figure the following state. e.g. We are in state (i\\uFF0Cj), if we give p balls to the left, then num-p balls are given to the right. the new difference of i becomes i+p-(num-p)=i+2p-num. When p=0, j changes to j-1(all balls of this color are given to the right, so left-right get decrease). When p=num j changes to j+1. Else j holds(because left and right both own this color).\\n\\n**Progress** we iterate on idx, and all last state dp(i,j). for each state and each kind of arrangement, we calculate the new state.\\n\\n**Combinations** We do not calculate probability, while we use combinations.  When we give p balls to the left and num-p balls to the right, there are Combinations(num,p) ways. And the new state dp[i\\'][j\\']+=dp\\\\[i\\\\]\\\\[j\\\\]\\\\*C(num,p). In fact the last step we should multiple n! on dp\\\\[0\\\\]\\\\[0\\\\], luckily the problem requires left length=right length so we can ignore that.\\n\\n**Complexity** If balls has length of M\\uFF0Cwhere elements can be 1,...N, then the whole state space is sum\\\\*M=MMN. Since we iterator on idx, so overall complexity is O(M^3N).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int factorial(long number){\\n        if(number<=1)\\n            return 1;\\n        else \\n            return number*factorial(number-1);\\n    }\\n    int combinator(int n,int m){\\n        int temp;\\n        return factorial(n)/(factorial(m)*factorial(n-m));\\n    }\\n    double getProbability(vector<int>& balls) {\\n        int n=balls.size();\\n        long long sum=0;\\n        for(int i=0;i<n;i++) sum+=balls[i];//1\\n        vector<long long> row(2*n+1,-1),row2(2*n+1,0);\\n        vector<vector<long long>> dp(2*sum+1,row),dp2(2*sum+1,row2);//2\\n        dp[sum][n]=1;//3\\n        for(int idx=0;idx<n;idx++){//4\\n            int num=balls[idx];//5\\n            for(int p=0;p<=num;p++){//6\\n                for(int i=-sum;i<=sum;i++){\\n                    for(int j=-n;j<=n;j++){//7\\n                        if(dp[i+sum][j+n]==-1) continue;\\n                        if((i+sum+2*p-num<0)||(i+sum+2*p-num>=2*sum+1)) continue;//8\\n                        int coef=combinator(num,p);//9\\n                        if(p==0&&j+n-1>=0) dp2[i+sum+2*p-num][j+n-1]+=(dp[i+sum][j+n]);//10\\n                        else if(p==num&&j+n+1<2*n+1) dp2[i+sum+2*p-num][j+n+1]+=(dp[i+sum][j+n]);//11\\n                        else dp2[i+sum+2*p-num][j+n]+=(dp[i+sum][j+n])*coef;//12\\n                    }\\n                }\\n            }\\n            dp=dp2;//13\\n            for(int i=0;i<2*sum+1;i++){\\n                for(int j=0;j<2*n+1;j++){\\n                    dp2[i][j]=0;//14\\n                }\\n            }\\n        }\\n        long long mnt=0;\\n        for(int i=0;i<2*n+1;i++){\\n            mnt+=dp[sum][i];//15\\n        }\\n        return double(dp[sum][n])/mnt;//16\\n    }\\n};\\n```\\n1. We get the sum of balls, so i will between -sum to sum\\n2. i between -sum to sum, j between -n and n, we use a 2x+1 length here, so if we try to index dp[i][j] actually we need use dp[i+sum][j+n]\\n3.  before the beginning, dp[0][0]=1\\n4.  iterate over idx\\n5.  num=balls[idx]\\n6.  iterate over each kind of arragement\\n7.  iterate over old states\\n8.  early stop when the new state is unreachable (out of boundries).\\n9.  calculate the combination\\n10.  if the arrangement is (0,num), then right get more color, so j-1\\n11.  if the arrangement is (num,0), then left get more color,so j+1\\n12.  in other situations, j holds\\n13.  update the state\\n14.  clear dp2\\n15.  get all ways that left length=right length\\n16.  get the result\\n\\nRuntime: 8 ms, faster than 93.20% of C++ online submissions for Probability of a Two Boxes Having The Same Number of Distinct Balls.\\nMemory Usage: 7.3 MB, less than 100.00% of C++ online submissions for Probability of a Two Boxes Having The Same Number of Distinct Balls.\\n## ---------------------------------\\n## \\u4EE5\\u4E0B\\u662F\\u4E2D\\u6587\\u89E3\\u91CA\\n\\u6211\\u4EEC\\u8BBE\\u8BA1\\u72B6\\u6001\\u4E3Adp[i][j],\\u5176\\u4E2D\\uFF0Ci\\u4EE3\\u8868\\u5DE6\\u8FB9\\u4E0E\\u53F3\\u8FB9\\u7684\\u6570\\u91CF\\u5DEE\\uFF0Cj\\u4EE3\\u8868\\u5DE6\\u8FB9\\u4E0E\\u53F3\\u8FB9\\u7684\\u79CD\\u7C7B(\\u989C\\u8272)\\u5DEE\\u3002\\n\\u4F8B\\u5982\\u5DE6\\u8FB9\\uFF1A[1,2,3] \\u53F3\\u8FB9\\uFF1A[1,1,2,4]\\uFF0C\\u6B64\\u65F6i=-1\\uFF0Cj=0\\uFF08\\u90FD\\u662F\\u6709\\u4E09\\u79CD\\uFF09\\u3002\\n\\u90A3\\u4E48\\u6839\\u636E\\u9898\\u610F\\uFF0C\\u6211\\u4EEC\\u6240\\u8981\\u627E\\u7684\\u7ED3\\u679C\\u3002\\u5206\\u5B50\\u5C31\\u662F\\u6700\\u7EC8dp[0][0]\\u8FD9\\u4E2A\\u70B9\\u7684\\u503C\\uFF0C\\u800C\\u5206\\u6BCD\\u662F\\u6240\\u6709dp[0][j]\\u7684\\u548C\\uFF08\\u56E0\\u4E3A\\u9898\\u76EE\\u63D0\\u8981\\u6C42\\u5DE6\\u53F3\\u957F\\u5EA6\\u5FC5\\u987B\\u76F8\\u7B49\\uFF09\\u3002\\n\\n\\u63A5\\u4E0B\\u6765\\u6309\\u7167\\u6BCF\\u79CD\\u7403\\u6328\\u4E2A\\u5206\\u914D\\u7684\\u65B9\\u5F0F\\u6267\\u884C\\uFF0C\\u7D22\\u5F15\\u8BB0\\u4E3Aidx\\uFF0C\\u5BF9\\u4E8Eball[idx] (\\u8BB0\\u4E3Anum)\\uFF0C\\u6211\\u4EEC\\u5C31\\u6709num+1\\u79CD\\u5206\\u914D\\u65B9\\u5F0F\\uFF0C(0,num),(1,num-1),(...)(num,0)\\u7B49\\u3002\\u6BCF\\u4E00\\u79CD\\u5206\\u914D\\u6211\\u90FD\\u77E5\\u9053\\u5BF9\\u5E94\\u7684\\u72B6\\u6001\\u53D8\\u5316\\u662F\\u4EC0\\u4E48\\u3002\\u6BD4\\u5982\\u524D\\u4E00\\u4E2A\\u72B6\\u6001\\u662F\\uFF08i\\uFF0Cj\\uFF09\\uFF0C\\u90A3\\u4E48\\u5F53\\u6211\\u5206\\u914D\\u4E3A\\uFF08p\\uFF0Cnum-p\\uFF09\\u7684\\u65F6\\u5019\\uFF0Ci\\u5C31\\u53D8\\u4E3Ai+p-(num-p)=i+2p-num\\uFF0C\\u8FD9\\u91CC\\u5F53p=0\\u7684\\u65F6\\u5019j\\u4F1A-1\\uFF0Cp=num\\u7684\\u65F6\\u5019j\\u4F1A+1\\uFF0C\\u5176\\u4ED6\\u65F6\\u5019j\\u90FD\\u4E0D\\u53D8\\u3002\\n\\n\\u56E0\\u6B64\\u6BCF\\u4E00\\u4E2Aidx\\uFF0C\\u90FD\\u53EF\\u4EE5\\u904D\\u5386\\u6240\\u6709\\u7684\\u72B6\\u6001\\uFF08i\\uFF0Cj\\uFF09\\uFF0C\\u904D\\u5386\\u5206\\u914D\\u65B9\\u5F0Fp\\uFF0C\\u8FDB\\u884C\\u72B6\\u6001\\u8F6C\\u79FB\\u3002\\u5C31\\u53EF\\u4EE5\\u5B8C\\u6210\\u6574\\u4E2A\\u8FC7\\u7A0B\\u3002\\n\\n\\u4E0D\\u8FC7\\u4E3A\\u4E86\\u7B97\\u6982\\u7387\\uFF0C\\u8FD9\\u91CC\\u9700\\u8981\\u5904\\u7406\\u4E00\\u4E0B\\u3002\\u6211\\u4EEC\\u53EA\\u7B97\\u7EC4\\u5408\\u6570\\uFF0C\\u5F53\\u5206\\u914D\\u4E3A\\uFF08p\\uFF0Cnum-p\\uFF09\\u7684\\u65F6\\u5019\\uFF0C\\u6709C\\uFF08num\\uFF0Cp\\uFF09\\u4E2D\\u9009\\u62E9\\uFF0C\\u6240\\u4EE5\\u8F6C\\u4EE5\\u540E\\u7684\\u72B6\\u6001\\u662Fdp\\\\[i\\\\]\\\\[j\\\\]\\\\*C(num,p)\\u3002 \\u5176\\u5B9E\\u5728\\u6700\\u540Edp\\\\[0\\\\]\\\\[0\\\\]\\u8FD9\\u4E2A\\u70B9\\u8FD8\\u5F97\\u4E58\\u4E0A\\u5404\\u81EA\\u5185\\u90E8\\u7684\\u5168\\u6392\\u5217\\u5373n\\uFF01\\u4E0D\\u8FC7\\u8FD9\\u4E2A\\u95EE\\u9898\\u4E2D\\u4E24\\u8FB9\\u6D88\\u6389\\u4E86\\uFF0C\\u5982\\u679C\\u4E24\\u8FB9\\u957F\\u5EA6\\u4E0D\\u76F8\\u7B49\\u7684\\u8BDD\\u90A3\\u8FD8\\u5F97\\u7B97\\n\\n\\u5982\\u679Cball\\u7684\\u957F\\u5EA6\\u662FM\\uFF0C\\u5176\\u4E2D\\u6BCF\\u4E00\\u4E2A\\u7684\\u6700\\u5927\\u4E2A\\u6570\\u662FN\\uFF0C\\u90A3\\u4E48\\u72B6\\u6001\\u7A7A\\u95F4\\u662Fsum\\\\*M=MMN\\uFF0C\\u5916\\u5C42\\u8FD8\\u9700\\u8981\\u5BF9M\\u7684\\u904D\\u5386\\uFF0C\\u6240\\u4EE5\\u603B\\u7684\\u590D\\u6742\\u5EA6\\u662FO(M^3N)\\u3002\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int factorial(long number){\\n        if(number<=1)\\n            return 1;\\n        else \\n            return number*factorial(number-1);\\n    }\\n    int combinator(int n,int m){\\n        int temp;\\n        return factorial(n)/(factorial(m)*factorial(n-m));\\n    }\\n    double getProbability(vector<int>& balls) {\\n        int n=balls.size();\\n        long long sum=0;\\n        for(int i=0;i<n;i++) sum+=balls[i];//1\\n        vector<long long> row(2*n+1,-1),row2(2*n+1,0);\\n        vector<vector<long long>> dp(2*sum+1,row),dp2(2*sum+1,row2);//2\\n        dp[sum][n]=1;//3\\n        for(int idx=0;idx<n;idx++){//4\\n            int num=balls[idx];//5\\n            for(int p=0;p<=num;p++){//6\\n                for(int i=-sum;i<=sum;i++){\\n                    for(int j=-n;j<=n;j++){//7\\n                        if(dp[i+sum][j+n]==-1) continue;\\n                        if((i+sum+2*p-num<0)||(i+sum+2*p-num>=2*sum+1)) continue;//8\\n                        int coef=combinator(num,p);//9\\n                        if(p==0&&j+n-1>=0) dp2[i+sum+2*p-num][j+n-1]+=(dp[i+sum][j+n]);//10\\n                        else if(p==num&&j+n+1<2*n+1) dp2[i+sum+2*p-num][j+n+1]+=(dp[i+sum][j+n]);//11\\n                        else dp2[i+sum+2*p-num][j+n]+=(dp[i+sum][j+n])*coef;//12\\n                    }\\n                }\\n            }\\n            dp=dp2;//13\\n            for(int i=0;i<2*sum+1;i++){\\n                for(int j=0;j<2*n+1;j++){\\n                    dp2[i][j]=0;//14\\n                }\\n            }\\n        }\\n        long long mnt=0;\\n        for(int i=0;i<2*n+1;i++){\\n            mnt+=dp[sum][i];//15\\n        }\\n        return double(dp[sum][n])/mnt;//16\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663891,
                "title": "java-combinations-binomial-coefficients",
                "content": "First of all I found this problem really challenging. I didn\\u2019t have experience solving probability related tasks, so to everyone who struggle to solve it correctly - gosh, I feel your pain.\\n\\nLet\\u2019s denote colors with letter  r,g,b, etc. (red, grey. blue). E.g. 1r 2r 1g 2g 1b 2b 3b - 2 red balls, 2 green and 3 blue\\n\\n\\n#### Observations:\\n1. Usage of permutations is redundant. We don\\u2019t really care about ordering, e.g. two red balls, it does not matter which one goes to basket first. If both balls will appear in the same basket - this is what matter.  \\n    1. Formula to calculate permutations is n! Maximum basket capacity is 24 so basically to calculate 24! you will have to use special classes intended for dealing with big numbers (BigInteger in java.) But if the ordering is not required, we can use formula for \\u201Ccombinations\\u201D that will result in much smaller number that fits under standard language primitive types. c(n, r) = n! /(r! * (n - r)!) \\n2. It is enough to calculate combinations just for single basket. \\n\\n\\nFrom description we have total 2n balls, so to single basket will go n balls. We need to select n balls out of set of 2n. Again order does not matter\\n***C(2n, n) = 2n! / (n! (2n - n)!) = 2n  (2n - 1)  (2n - 2)  \\u2026 (n + 1) / (1  2  3  4  \\u2026  n)*** \\n\\nAbove we calculated total number of combinations of balls in a single basket. Next step is to find number of combinations that meet the problem requirement - number of different colors should be same in both baskets.\\n\\n#### Good combinations\\nSay we have `3r  5g 6b`. What we will be doing is try to derive different combination that will go to single basket (total n balls). The rest of the balls that was not chosen in following step will go to second basket. \\n\\nTry \\n1. Not using any 0 red balls\\n2. Use 1r\\n    1. Use 0g\\n    2. Use 1g\\n        1. Use 0b\\n        2. Use 1b\\n        3. Use 2b\\n        4. \\u2026\\n    3. \\u2026\\n    4. Use 5g\\n3. Use 2r\\n    1. \\u2026\\n4. Use 3r\\n    1. \\u2026\\n \\nThis might result in combinations like `2g 1r 4b` or `1g 3r 3b` or `1g 6b`. As you might note some of such combinations does not meet requirements so we will ignore them and count only \\u201Cgood\\u201D ones.\\n\\nAdditional important note. For each step above when we choose some number of balls of the same color, say **2g** - **it is also combination!!** - we choosing 2 green balls out of 5 existing and in total it will be C(5, 2) different combinations\\n\\n```java\\nclass Solution {\\n\\n    // counter of different colors in each basket\\n    int basket1 = 0;;\\n    int basket2 = 0;\\n\\n    public double getProbability(int[] balls) {\\n        // initially assume all balls in second basket.\\n        // We will be working on moving half of them into basket 1\\n        basket2 = balls.length;\\n        int n = IntStream.of(balls).sum();\\n\\n        long all = comb(n, n / 2);\\n\\n        long goodCombs = goodCombs(n/ 2, balls, 0, 0);\\n\\n        return (double) goodCombs / all;\\n    }\\n\\n    long goodCombs(int n, int[] balls, int usedBalls, int i) {\\n        if (usedBalls == n) {\\n            return basket1 == basket2 ? 1 : 0;\\n        }\\n        else if (i >= balls.length) return 0;\\n\\n        // assume we ignore all balls of color i, that means they will go to other basket\\n        long res  = goodCombs(n, balls, usedBalls, i + 1);\\n\\n        // now we take some balls of color i and put into current basket\\n        basket1++;\\n        for (int j = 1; j <= balls[i]; j++) {\\n            if (j == balls[i]) basket2--;\\n\\n            long combinations = comb(balls[i], j);\\n            res += combinations * goodCombs(n, balls, usedBalls + j, i + 1);\\n        }\\n\\n        basket1--;\\n        basket2++;\\n\\n        return res;\\n    }\\n\\n    // Please refer to information in google \"How to calculate binomial coefficients Mark Dominus\"\\n    long comb(int n, int r) {\\n\\n        long res = 1;\\n\\n        for (int i = 1; i <= r; i++) {\\n            res *= n--;\\n            res /= i;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n\\n    // counter of different colors in each basket\\n    int basket1 = 0;;\\n    int basket2 = 0;\\n\\n    public double getProbability(int[] balls) {\\n        // initially assume all balls in second basket.\\n        // We will be working on moving half of them into basket 1\\n        basket2 = balls.length;\\n        int n = IntStream.of(balls).sum();\\n\\n        long all = comb(n, n / 2);\\n\\n        long goodCombs = goodCombs(n/ 2, balls, 0, 0);\\n\\n        return (double) goodCombs / all;\\n    }\\n\\n    long goodCombs(int n, int[] balls, int usedBalls, int i) {\\n        if (usedBalls == n) {\\n            return basket1 == basket2 ? 1 : 0;\\n        }\\n        else if (i >= balls.length) return 0;\\n\\n        // assume we ignore all balls of color i, that means they will go to other basket\\n        long res  = goodCombs(n, balls, usedBalls, i + 1);\\n\\n        // now we take some balls of color i and put into current basket\\n        basket1++;\\n        for (int j = 1; j <= balls[i]; j++) {\\n            if (j == balls[i]) basket2--;\\n\\n            long combinations = comb(balls[i], j);\\n            res += combinations * goodCombs(n, balls, usedBalls + j, i + 1);\\n        }\\n\\n        basket1--;\\n        basket2++;\\n\\n        return res;\\n    }\\n\\n    // Please refer to information in google \"How to calculate binomial coefficients Mark Dominus\"\\n    long comb(int n, int r) {\\n\\n        long res = 1;\\n\\n        for (int i = 1; i <= r; i++) {\\n            res *= n--;\\n            res /= i;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662635,
                "title": "extremely-detailed-explanation-with-c-code",
                "content": "ANSWER INSPIRED FROM--\\nhttps://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/discuss/661730/C%2B%2B-Backtrack-with-explanation\\n\\nread the code once before reading the explanation\\n\\nthought process---\\n\\nQuestion is a dfs/backtrackng problem clearly, as we have to explore tons and tons of possibilities.\\n\\nQUESTION HAS 2 MAJOR STEPS---\\n1)Get all possible distibutions of balls[i] into 2 groups\\n2)Select the favourable distributions\\n\\nwe need to split vector \\'balls\\' into 2 vectors \\'a\\' and \\'b\\' such that for all i (a[i]+b[i])==balls[i]) since we are distributing all the balls\\n\\nbasically many possibilities to explore as each element of a and b could be any split of balls[i]\\n.Choose the value of a[i] and b[i] and then for each of those choices we further see what all choices possible for a[i+1] and b[i+1].We do this till we fill it completely.\\n\\nExample:\\nballs={5,3,7,4}\\nThen options for a.First element could contain 0 to 5 balls of the first type so 6 choices,2nd element has 4 and so on.\\nSo we do dfs(6*4*8*5) times.\\n\\nNow we have gotten ALL POSSIBLE Splits(excluding permutation) OF BALLS[i]!\\nLast step is simple just check for the 2 things ques asks for\\n\\nnow 2 conditions--\\n1)equal number of balls in each set.\\n2)number of types of balls in the 2 vectors must be same.\\n\\nor in other words\\n\\n1)sum(a)==sum(b)(you could do this in the end also,it would be submitted but time could be optimized by returning 0 whenever sum(a) or sum(b) becomes greater than sum/2.In the end if this(sum(a) or sum(b) greater than sum/2) doesn\\'t satisfy means sums are equal).\\n2)no. of non zero elements in a==no. of non zero elements b(non zero element means that type is present).\\n\\nNow return all possible permutations of the favourable distribution.\\n\\nvariable ans will track all the dfs calls that reached the favourable end.\\n\\n```\\nclass Solution {\\npublic:\\n    double fact(int n)\\n    {\\n        double ret=1;\\n        for(int i=2;i<=n;i++)\\n            ret=ret*i;\\n        return ret;\\n    }\\n    \\n    double perm(vector<int> &A) {\\n        double ans = 1;\\n        int sum=accumulate(A.begin(),A.end(),0);\\n        double ret=fact(sum);\\n        for(int i=0;i<A.size();i++)\\n            ret/=fact(A[i]);\\n        return ret;\\n    }\\n    int sum=0;\\n    \\n    double dfs(vector<int>& A,vector<int>& a,vector<int>& b,int suma,int sumb,int i)\\n    {\\n        if(suma>sum/2||sumb>sum/2)\\n            return 0;\\n        if(i==A.size())\\n        {\\n            int cnta=0;\\n            int cntb=0;\\n            for(int j=0;j<i;j++)if(a[j])cnta++;\\n            for(int j=0;j<i;j++)if(b[j])cntb++;\\n            if(cnta==cntb)\\n                return perm(a)*perm(b);\\n            else\\n                return 0;\\n        }\\n        double ans=0;\\n        for(int j=0;j<=A[i];j++)\\n        {\\n            a[i]=j;\\n            b[i]=A[i]-j;\\n            ans+=dfs(A,a,b,suma+a[i],sumb+b[i],i+1);\\n        }\\n        return ans;\\n    }\\n\\n    double getProbability(vector<int>& A) {\\n        int suma=0;\\n        int sumb=0;\\n        sum=accumulate(A.begin(),A.end(),0);\\n        vector<int> a(A.size());\\n        vector<int> b(A.size());\\n        return dfs(A,a,b,0,0,0)/perm(A);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double fact(int n)\\n    {\\n        double ret=1;\\n        for(int i=2;i<=n;i++)\\n            ret=ret*i;\\n        return ret;\\n    }\\n    \\n    double perm(vector<int> &A) {\\n        double ans = 1;\\n        int sum=accumulate(A.begin(),A.end(),0);\\n        double ret=fact(sum);\\n        for(int i=0;i<A.size();i++)\\n            ret/=fact(A[i]);\\n        return ret;\\n    }\\n    int sum=0;\\n    \\n    double dfs(vector<int>& A,vector<int>& a,vector<int>& b,int suma,int sumb,int i)\\n    {\\n        if(suma>sum/2||sumb>sum/2)\\n            return 0;\\n        if(i==A.size())\\n        {\\n            int cnta=0;\\n            int cntb=0;\\n            for(int j=0;j<i;j++)if(a[j])cnta++;\\n            for(int j=0;j<i;j++)if(b[j])cntb++;\\n            if(cnta==cntb)\\n                return perm(a)*perm(b);\\n            else\\n                return 0;\\n        }\\n        double ans=0;\\n        for(int j=0;j<=A[i];j++)\\n        {\\n            a[i]=j;\\n            b[i]=A[i]-j;\\n            ans+=dfs(A,a,b,suma+a[i],sumb+b[i],i+1);\\n        }\\n        return ans;\\n    }\\n\\n    double getProbability(vector<int>& A) {\\n        int suma=0;\\n        int sumb=0;\\n        sum=accumulate(A.begin(),A.end(),0);\\n        vector<int> a(A.size());\\n        vector<int> b(A.size());\\n        return dfs(A,a,b,0,0,0)/perm(A);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662074,
                "title": "java-slow-backtrack-math-sol",
                "content": "```\\nclass Solution {\\n    int T=0;\\n    Map<Integer,Integer>map=new HashMap<>();\\n    Set<String>set=new HashSet<>();\\n    int balls[];\\n    double all=1;\\n    double res=0;\\n    double down=1.0;\\n    public double getProbability(int[] balls) {\\n        Arrays.sort(balls);\\n        List<Integer>l=new ArrayList<>();\\n        for(int n:balls)l.add(n);\\n        Collections.reverse(l);\\n        for(int i=0;i<balls.length;i++)balls[i]=l.get(i);\\n        this.balls=balls;\\n        int total=0;\\n        for(int i=0;i<balls.length;i++){\\n            int n=balls[i];\\n            total+=n; //n/2\\n            map.put(i,n);\\n            down*=per(n);\\n        }\\n        T=total/2;\\n        all=per(total);\\n        for(int n:balls)all/=get(n);\\n        dfs(balls,0,0,new HashMap<>(),new StringBuilder(),1.0,down);\\n        return (res+0.0)/all;\\n    }\\n    \\n    public void dfs(int balls[],int start,int cnt,Map<Integer,Integer>cur,StringBuilder str,double div1,double div2){\\n        if(cnt>T){\\n            return;\\n        }\\n        if(map.size()<cur.size())return;\\n        if(cnt==T){\\n            if(map.size()!=cur.size())return;\\n            String s=str.toString();\\n            if(set.contains(s))return;\\n            double p1=per(T);\\n            double p2=per(T);\\n            p1/=div1;\\n            p2/=div2;\\n            set.add(s);\\n            res+=(p1*p2);\\n            return;\\n        }\\n        for(int i=start;i<balls.length;i++){\\n            int n=balls[i];\\n            for(int take=1;take<=n;take++){\\n                if(cnt+take>T)break;\\n                \\n                if(!cur.containsKey(i))cur.put(i,0);\\n                if(cur.get(i)+take>n)break;\\n                cur.put(i,cur.get(i)+take);\\n                map.put(i,map.get(i)-take);\\n                if(map.get(i)==0)map.remove(i);\\n                str.append(i+\"\"+cur.get(i)+\",\");\\n                \\n                double m1=1.0;\\n                double m2=1.0;\\n                m1=per(cur.get(i));\\n\\n               \\n                dfs(balls,i+1,cnt+take,cur,str,div1*m1,div2/get(n)*get(n-cur.get(i)));\\n               \\n                str.deleteCharAt(str.length()-1);\\n                str.deleteCharAt(str.length()-1);\\n                str.deleteCharAt(str.length()-1);\\n                \\n                cur.put(i,cur.get(i)-take);\\n                if(cur.get(i)==0)cur.remove(i);\\n                if(!map.containsKey(i))map.put(i,0);\\n                map.put(i,map.get(i)+take);\\n            }\\n        }\\n        \\n    }\\n    public double get(int i){\\n        if(i==0||i==1)return 1;\\n        if(i==2)return 2;\\n        if(i==3)return 6;\\n        if(i==4)return 24;\\n        if(i==5)return 120;\\n        if(i==6)return 720;\\n        return 0;\\n    }\\n    \\n    public double per(int n){\\n        double ans=1;\\n        for(int i=1;i<=n;i++)ans*=i;\\n        return ans;\\n    }\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int T=0;\\n    Map<Integer,Integer>map=new HashMap<>();\\n    Set<String>set=new HashSet<>();\\n    int balls[];\\n    double all=1;\\n    double res=0;\\n    double down=1.0;\\n    public double getProbability(int[] balls) {\\n        Arrays.sort(balls);\\n        List<Integer>l=new ArrayList<>();\\n        for(int n:balls)l.add(n);\\n        Collections.reverse(l);\\n        for(int i=0;i<balls.length;i++)balls[i]=l.get(i);\\n        this.balls=balls;\\n        int total=0;\\n        for(int i=0;i<balls.length;i++){\\n            int n=balls[i];\\n            total+=n; //n/2\\n            map.put(i,n);\\n            down*=per(n);\\n        }\\n        T=total/2;\\n        all=per(total);\\n        for(int n:balls)all/=get(n);\\n        dfs(balls,0,0,new HashMap<>(),new StringBuilder(),1.0,down);\\n        return (res+0.0)/all;\\n    }\\n    \\n    public void dfs(int balls[],int start,int cnt,Map<Integer,Integer>cur,StringBuilder str,double div1,double div2){\\n        if(cnt>T){\\n            return;\\n        }\\n        if(map.size()<cur.size())return;\\n        if(cnt==T){\\n            if(map.size()!=cur.size())return;\\n            String s=str.toString();\\n            if(set.contains(s))return;\\n            double p1=per(T);\\n            double p2=per(T);\\n            p1/=div1;\\n            p2/=div2;\\n            set.add(s);\\n            res+=(p1*p2);\\n            return;\\n        }\\n        for(int i=start;i<balls.length;i++){\\n            int n=balls[i];\\n            for(int take=1;take<=n;take++){\\n                if(cnt+take>T)break;\\n                \\n                if(!cur.containsKey(i))cur.put(i,0);\\n                if(cur.get(i)+take>n)break;\\n                cur.put(i,cur.get(i)+take);\\n                map.put(i,map.get(i)-take);\\n                if(map.get(i)==0)map.remove(i);\\n                str.append(i+\"\"+cur.get(i)+\",\");\\n                \\n                double m1=1.0;\\n                double m2=1.0;\\n                m1=per(cur.get(i));\\n\\n               \\n                dfs(balls,i+1,cnt+take,cur,str,div1*m1,div2/get(n)*get(n-cur.get(i)));\\n               \\n                str.deleteCharAt(str.length()-1);\\n                str.deleteCharAt(str.length()-1);\\n                str.deleteCharAt(str.length()-1);\\n                \\n                cur.put(i,cur.get(i)-take);\\n                if(cur.get(i)==0)cur.remove(i);\\n                if(!map.containsKey(i))map.put(i,0);\\n                map.put(i,map.get(i)+take);\\n            }\\n        }\\n        \\n    }\\n    public double get(int i){\\n        if(i==0||i==1)return 1;\\n        if(i==2)return 2;\\n        if(i==3)return 6;\\n        if(i==4)return 24;\\n        if(i==5)return 120;\\n        if(i==6)return 720;\\n        return 0;\\n    }\\n    \\n    public double per(int n){\\n        double ans=1;\\n        for(int i=1;i<=n;i++)ans*=i;\\n        return ans;\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661945,
                "title": "3-lines-python",
                "content": "```\\n    def getProbability(self, balls):\\n        f = lambda v, n: reduce(lambda pre, x: pre//math.factorial(x), v, math.factorial(n))\\n        n, t = sum(balls)// 2, list(product(*[range(0,i+1) for i in balls]))\\n        return sum(f(t[i], n) * f(t[~i], n) for i in range(len(t)) if sum(t[i]) == n and t[i].count(0) == t[~i].count(0)) / f(balls, 2*n)\\n```",
                "solutionTags": [],
                "code": "```\\n    def getProbability(self, balls):\\n        f = lambda v, n: reduce(lambda pre, x: pre//math.factorial(x), v, math.factorial(n))\\n        n, t = sum(balls)// 2, list(product(*[range(0,i+1) for i in balls]))\\n        return sum(f(t[i], n) * f(t[~i], n) for i in range(len(t)) if sum(t[i]) == n and t[i].count(0) == t[~i].count(0)) / f(balls, 2*n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 661919,
                "title": "simple-dfs-and-maths-beat-100-space-and-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    double fac(vector<int> & v){\\n        long long sum=0;\\n        for(int i:v) sum+=i;\\n        \\n        double d=1;\\n        long long count=1;\\n        for(int i:v){\\n            for(int j=1;j<=i;j++){\\n                    d*=count;\\n                    count++;\\n                    d=d/j;\\n            }\\n        }\\n      \\n        return d;\\n    }\\n    \\n    double helper(vector<int>& a , int i , int sum, int req,vector<int>& v,vector<int>& l){\\n        \\n        if(i==a.size()){\\n        if(sum==req){\\n            if(l.size()==v.size()){\\n                \\n                \\n\\n                 return fac(v)*fac(l) ;\\n            }\\n            \\n            \\n        }\\n          return 0.0;\\n        }\\n        \\n        \\n         \\n        if(sum>req)\\n             return 0.0;\\n        \\n        double ans = 0.0;\\n        for(int id=0;id<=a[i];id++){\\n            if(id==0){\\n                l.push_back(a[i]);\\n                ans = ans + helper(a,i+1,sum+id,req,v,l);\\n                l.pop_back();\\n            }\\n            \\n            else if(id==a[i]){\\n                v.push_back(id);\\n                ans = ans + helper(a,i+1,sum+id,req,v,l);\\n                v.pop_back();\\n            }\\n            \\n            else{\\n                 v.push_back(id);\\n                 l.push_back(a[i]-id);\\n                 ans = ans + helper(a,i+1,sum+id,req,v,l);\\n                  v.pop_back();\\n                 l.pop_back();\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    double getProbability(vector<int>& balls) {\\n        int sum = 0;\\n        for(auto i:balls)\\n             sum+=i;\\n        \\n        int req = sum/2;\\n        int n = balls.size();\\n        vector<int> v;\\n        vector<int> l;\\n        double  ans = helper(balls, 0,0,req,v,l);\\n        double deno = fac(balls);\\n        double fans = ans/deno;\\n        return  fans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double fac(vector<int> & v){\\n        long long sum=0;\\n        for(int i:v) sum+=i;\\n        \\n        double d=1;\\n        long long count=1;\\n        for(int i:v){\\n            for(int j=1;j<=i;j++){\\n                    d*=count;\\n                    count++;\\n                    d=d/j;\\n            }\\n        }\\n      \\n        return d;\\n    }\\n    \\n    double helper(vector<int>& a , int i , int sum, int req,vector<int>& v,vector<int>& l){\\n        \\n        if(i==a.size()){\\n        if(sum==req){\\n            if(l.size()==v.size()){\\n                \\n                \\n\\n                 return fac(v)*fac(l) ;\\n            }\\n            \\n            \\n        }\\n          return 0.0;\\n        }\\n        \\n        \\n         \\n        if(sum>req)\\n             return 0.0;\\n        \\n        double ans = 0.0;\\n        for(int id=0;id<=a[i];id++){\\n            if(id==0){\\n                l.push_back(a[i]);\\n                ans = ans + helper(a,i+1,sum+id,req,v,l);\\n                l.pop_back();\\n            }\\n            \\n            else if(id==a[i]){\\n                v.push_back(id);\\n                ans = ans + helper(a,i+1,sum+id,req,v,l);\\n                v.pop_back();\\n            }\\n            \\n            else{\\n                 v.push_back(id);\\n                 l.push_back(a[i]-id);\\n                 ans = ans + helper(a,i+1,sum+id,req,v,l);\\n                  v.pop_back();\\n                 l.pop_back();\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    double getProbability(vector<int>& balls) {\\n        int sum = 0;\\n        for(auto i:balls)\\n             sum+=i;\\n        \\n        int req = sum/2;\\n        int n = balls.size();\\n        vector<int> v;\\n        vector<int> l;\\n        double  ans = helper(balls, 0,0,req,v,l);\\n        double deno = fac(balls);\\n        double fans = ans/deno;\\n        return  fans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661718,
                "title": "java-backtrack",
                "content": "```\\nclass Solution {\\n    double[] A = new double[49];\\n    int n = 0;\\n    double res = 0;\\n    public double getProbability(int[] balls) {\\n        A[0] = 1.0;\\n        for(int i=1; i<A.length; i++){\\n            A[i] = A[i-1]*i;\\n        }\\n        for(int count : balls){\\n            n += count;\\n        }\\n        calc(balls, 0, new int[balls.length], n/2);\\n        double denom = A[n];\\n        for(int num : balls){\\n            denom /= A[num];\\n        }\\n        return res / denom;\\n    }\\n    \\n    public void calc(int[] balls, int index, int[] a, int m){\\n        if(m<0){\\n            return;\\n        }\\n        \\n        if(m==0){\\n            int colors = 0;\\n            int otherColors = 0;\\n            for(int i=0; i<a.length; i++){\\n                if(a[i]>0){\\n                    colors++;\\n                }\\n                if(balls[i]-a[i]>0){\\n                    otherColors++;\\n                }\\n            }\\n            if(otherColors==colors){\\n                double curRes = 0.0;\\n                double aCount = A[n/2];\\n                for(int i=0; i<a.length; i++){\\n                    aCount /= A[a[i]];\\n                }\\n                double bCount = A[n/2];\\n                for(int i=0; i<a.length; i++){\\n                    bCount /= A[balls[i]-a[i]];\\n                }\\n                curRes = aCount*bCount;\\n                res+=curRes;\\n            }\\n            return;\\n        }\\n        \\n        if(index==balls.length){\\n            return;\\n        }\\n        \\n        for(int take=0; take<=balls[index]; take++){\\n            a[index] += take;\\n            calc(balls, index+1, a, m-take);\\n            a[index] -= take;\\n        }  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double[] A = new double[49];\\n    int n = 0;\\n    double res = 0;\\n    public double getProbability(int[] balls) {\\n        A[0] = 1.0;\\n        for(int i=1; i<A.length; i++){\\n            A[i] = A[i-1]*i;\\n        }\\n        for(int count : balls){\\n            n += count;\\n        }\\n        calc(balls, 0, new int[balls.length], n/2);\\n        double denom = A[n];\\n        for(int num : balls){\\n            denom /= A[num];\\n        }\\n        return res / denom;\\n    }\\n    \\n    public void calc(int[] balls, int index, int[] a, int m){\\n        if(m<0){\\n            return;\\n        }\\n        \\n        if(m==0){\\n            int colors = 0;\\n            int otherColors = 0;\\n            for(int i=0; i<a.length; i++){\\n                if(a[i]>0){\\n                    colors++;\\n                }\\n                if(balls[i]-a[i]>0){\\n                    otherColors++;\\n                }\\n            }\\n            if(otherColors==colors){\\n                double curRes = 0.0;\\n                double aCount = A[n/2];\\n                for(int i=0; i<a.length; i++){\\n                    aCount /= A[a[i]];\\n                }\\n                double bCount = A[n/2];\\n                for(int i=0; i<a.length; i++){\\n                    bCount /= A[balls[i]-a[i]];\\n                }\\n                curRes = aCount*bCount;\\n                res+=curRes;\\n            }\\n            return;\\n        }\\n        \\n        if(index==balls.length){\\n            return;\\n        }\\n        \\n        for(int take=0; take<=balls[index]; take++){\\n            a[index] += take;\\n            calc(balls, index+1, a, m-take);\\n            a[index] -= take;\\n        }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028631,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach:\\n\\n- The function getProbability takes an array of integers representing the number of balls of each color.\\n- It initializes variables to keep track of counts for same and different distributions, as well as the total number of balls and colors.\\n\\nThe backtracking function backtrack is defined within getProbability to explore different distributions of balls.\\nThe backtracking function recursively considers distributing balls of each color and checks if it results in a valid distribution.\\n\\nThe getCount function calculates the number of different arrangements for each half.\\nThe getCombinationCount function calculates combinations using factorials.\\n\\nThe hasSameCount function checks if the left and right distributions have the same number of colors.\\nThe main logic initializes variables and starts the backtracking process.\\n\\nFinally, it returns the probability of having the same number of distinct balls in each box.\\n\\n\\n\\n\\n\\n# Complexity\\nTime Complexity:\\n\\nThe time complexity of this solution is exponential due to the nature of the backtracking algorithm. In the worst case, the algorithm explores all possible distributions, resulting in a time complexity of O(2^n), where n is the number of colors.\\n\\nSpace Complexity:\\n\\nThe space complexity of this solution is O(n), where n is the number of colors. This is primarily due to the space used for recursion depth and the auxiliary space for storing color counts.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} balls\\n * @return {number}\\n */\\nvar getProbability = function(balls) {\\n    let sameCount = 0, diffCount = 0;  // Variables to track counts of same and different distributions\\n    let totalBalls = 0, numColors;  // Variables for total sum and number of colors\\n    let ballCounts;  // Array to store the input balls\\n\\n    // Backtracking function\\n    function backtrack(index, count, colorCounts) {\\n        if (count === totalBalls / 2) {\\n            let secondPool = [];\\n            for (let i = 0; i < numColors; i++) {\\n                let count = i < colorCounts.length ? colorCounts[i] : 0;\\n                secondPool.push(ballCounts[i] - count);\\n            }\\n            let acc = getCount(colorCounts) * getCount(secondPool);\\n\\n            if (hasSameCount(colorCounts)) sameCount += acc;\\n            else diffCount += acc;\\n            return;\\n        }\\n\\n        if (index >= numColors) return;\\n\\n        for (let i = 0; i <= ballCounts[index]; i++) {\\n            if (count + i > totalBalls / 2) break;\\n            let newCounts = colorCounts.concat(i);\\n            backtrack(index + 1, count + i, newCounts);\\n        }\\n    }\\n\\n    // Function to count different arrangements for each half\\n    function getCount(colorCounts) {\\n        let result = 1, remaining = totalBalls / 2;\\n        for (let i = 0; i < colorCounts.length - 1; i++) {\\n            let count = colorCounts[i];\\n            if (count === 0) continue;\\n            result *= getCombinationCount(remaining, count);\\n            remaining -= count;\\n        }\\n        return result;\\n    }\\n\\n    // Function to calculate combinations\\n    function getCombinationCount(remaining, count) {\\n        let result = 1, divisor = 1;\\n        for (let j = 1; j <= count; j++) {\\n            result *= (remaining + 1 - j);\\n            divisor *= j;\\n        }\\n        return result / divisor;\\n    }\\n\\n    // Function to check if same number of colors\\n    function hasSameCount(colorCounts) {\\n        let leftCount = 0, rightCount = 0;\\n        for (let i = 0; i < numColors; i++) {\\n            let count = i < colorCounts.length ? colorCounts[i] : 0;\\n            if (ballCounts[i] - count > 0) rightCount++;\\n            if (count > 0) leftCount++;\\n        }\\n        return leftCount === rightCount;\\n    }\\n\\n    // Main logic\\n    numColors = balls.length;\\n    for (let count of balls) totalBalls += count;\\n    ballCounts = balls;\\n    backtrack(0, 0, []);\\n\\n    return sameCount / (sameCount + diffCount);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} balls\\n * @return {number}\\n */\\nvar getProbability = function(balls) {\\n    let sameCount = 0, diffCount = 0;  // Variables to track counts of same and different distributions\\n    let totalBalls = 0, numColors;  // Variables for total sum and number of colors\\n    let ballCounts;  // Array to store the input balls\\n\\n    // Backtracking function\\n    function backtrack(index, count, colorCounts) {\\n        if (count === totalBalls / 2) {\\n            let secondPool = [];\\n            for (let i = 0; i < numColors; i++) {\\n                let count = i < colorCounts.length ? colorCounts[i] : 0;\\n                secondPool.push(ballCounts[i] - count);\\n            }\\n            let acc = getCount(colorCounts) * getCount(secondPool);\\n\\n            if (hasSameCount(colorCounts)) sameCount += acc;\\n            else diffCount += acc;\\n            return;\\n        }\\n\\n        if (index >= numColors) return;\\n\\n        for (let i = 0; i <= ballCounts[index]; i++) {\\n            if (count + i > totalBalls / 2) break;\\n            let newCounts = colorCounts.concat(i);\\n            backtrack(index + 1, count + i, newCounts);\\n        }\\n    }\\n\\n    // Function to count different arrangements for each half\\n    function getCount(colorCounts) {\\n        let result = 1, remaining = totalBalls / 2;\\n        for (let i = 0; i < colorCounts.length - 1; i++) {\\n            let count = colorCounts[i];\\n            if (count === 0) continue;\\n            result *= getCombinationCount(remaining, count);\\n            remaining -= count;\\n        }\\n        return result;\\n    }\\n\\n    // Function to calculate combinations\\n    function getCombinationCount(remaining, count) {\\n        let result = 1, divisor = 1;\\n        for (let j = 1; j <= count; j++) {\\n            result *= (remaining + 1 - j);\\n            divisor *= j;\\n        }\\n        return result / divisor;\\n    }\\n\\n    // Function to check if same number of colors\\n    function hasSameCount(colorCounts) {\\n        let leftCount = 0, rightCount = 0;\\n        for (let i = 0; i < numColors; i++) {\\n            let count = i < colorCounts.length ? colorCounts[i] : 0;\\n            if (ballCounts[i] - count > 0) rightCount++;\\n            if (count > 0) leftCount++;\\n        }\\n        return leftCount === rightCount;\\n    }\\n\\n    // Main logic\\n    numColors = balls.length;\\n    for (let count of balls) totalBalls += count;\\n    ballCounts = balls;\\n    backtrack(0, 0, []);\\n\\n    return sameCount / (sameCount + diffCount);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912583,
                "title": "c-exponential-time-complexity-dfs",
                "content": "Idea is to check every possible permuatation, and then compute the result.\\n\\n> I hope you are familiar with the following formula :\\nNumber of ways to distribte `r1` objects of type 1, `r2` objects of type 2, ```\\nr3\\n``` objects of type 3, ...  in `(r1 + r2 + r3 + ... )`  positions is \\n$$(r1 + r2 + r3 + ... )!/(r1! * r2! * r3! * ... )\\n$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double sum, ans, cnt;\\n    vector<double> fact;\\n\\n    // \\'diff\\' is the difference in the number of balls between group a and group b.\\n    // \\'distinct\\' is the difference in the number of distinct balls between group a and group b.\\n    void f(int ind, vector<int> &balls, int diff, int distinct, double pro)\\n    {\\n        if(ind == balls.size())\\n        {\\n            if(diff==0 && distinct==0)\\n                ans += pro;\\n            return;\\n        }\\n        for(int i=0; i<=balls[ind]; i++)\\n        {\\n            int a = i, b = balls[ind]-i;\\n            double temp = pro/(fact[a]*fact[b]);\\n            f(ind+1, balls, diff+a-b, distinct+(a>0)-(b>0), temp);\\n        }\\n    }\\n    \\n    double getProbability(vector<int>& balls) {\\n        sum = 0; ans = 0; cnt = 0;\\n\\n        for(auto x: balls)\\n            sum += x;\\n\\n        fact.assign(sum+1, 1);\\n        for(int i=1;i<=sum; i++)\\n            fact[i] = fact[i-1]*i;\\n\\n        // cnt is total number of ways to arrange sum(balls) in 2n posititons\\n        cnt = fact[sum];\\n        for(auto x: balls)\\n            cnt /= fact[x];\\n\\n        f(0, balls, 0, 0, fact[sum/2]*fact[sum/2]);\\n\\n        return ans/cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nr3\\n```\n```\\nclass Solution {\\npublic:\\n    double sum, ans, cnt;\\n    vector<double> fact;\\n\\n    // \\'diff\\' is the difference in the number of balls between group a and group b.\\n    // \\'distinct\\' is the difference in the number of distinct balls between group a and group b.\\n    void f(int ind, vector<int> &balls, int diff, int distinct, double pro)\\n    {\\n        if(ind == balls.size())\\n        {\\n            if(diff==0 && distinct==0)\\n                ans += pro;\\n            return;\\n        }\\n        for(int i=0; i<=balls[ind]; i++)\\n        {\\n            int a = i, b = balls[ind]-i;\\n            double temp = pro/(fact[a]*fact[b]);\\n            f(ind+1, balls, diff+a-b, distinct+(a>0)-(b>0), temp);\\n        }\\n    }\\n    \\n    double getProbability(vector<int>& balls) {\\n        sum = 0; ans = 0; cnt = 0;\\n\\n        for(auto x: balls)\\n            sum += x;\\n\\n        fact.assign(sum+1, 1);\\n        for(int i=1;i<=sum; i++)\\n            fact[i] = fact[i-1]*i;\\n\\n        // cnt is total number of ways to arrange sum(balls) in 2n posititons\\n        cnt = fact[sum];\\n        for(auto x: balls)\\n            cnt /= fact[x];\\n\\n        f(0, balls, 0, 0, fact[sum/2]*fact[sum/2]);\\n\\n        return ans/cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768288,
                "title": "probability-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768287,
                "title": "probability-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753676,
                "title": "python-complicated-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        def fact(n):\\n            if n <= 0:return 1\\n            return n*fact(n-1)\\n        t = 2**len(balls)\\n        tm = len(balls)\\n        res = 0\\n        ed = sum(balls)//2\\n        gt = fact(ed)\\n        def go(arr):\\n            ans = gt*gt\\n            for x in range(tm):\\n                ans /= fact(arr[x])\\n                ans /= fact(abs(balls[x]-arr[x]))\\n            return ans\\n        def solve(i,l,r,cntl,arr):\\n            nonlocal res, gets\\n            if cntl>ed:\\n                return \\n            if i == tm:\\n                if cntl == ed:\\n                    res+=go(arr)\\n                return\\n            if (1<<i)&l != 0 and (1<<i)&r != 0:\\n                for j in range(1,balls[i]):\\n                    arr[i] = j\\n                    solve(i+1, l,r, cntl+j, arr)\\n                    arr[i] = 0\\n            elif (1<<i)&l != 0:\\n                arr[i] = balls[i]\\n                solve(i+1, l, r, cntl+balls[i], arr)\\n                arr[i] = 0\\n            else:\\n                solve(i+1, l, r, cntl, arr)\\n        cnt = 0            \\n        temp = [0 for i in range(tm)]\\n        for i in range(t):\\n            for j in range(t):\\n                if bin(i|j).count(\"1\") == tm and bin(i).count(\"1\") == bin(j).count(\"1\"):\\n                    solve(0,i,j,0,temp)\\n        gets = fact(ed*2)\\n        for i in balls:\\n            gets /= fact(i) \\n        return res/gets\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        def fact(n):\\n            if n <= 0:return 1\\n            return n*fact(n-1)\\n        t = 2**len(balls)\\n        tm = len(balls)\\n        res = 0\\n        ed = sum(balls)//2\\n        gt = fact(ed)\\n        def go(arr):\\n            ans = gt*gt\\n            for x in range(tm):\\n                ans /= fact(arr[x])\\n                ans /= fact(abs(balls[x]-arr[x]))\\n            return ans\\n        def solve(i,l,r,cntl,arr):\\n            nonlocal res, gets\\n            if cntl>ed:\\n                return \\n            if i == tm:\\n                if cntl == ed:\\n                    res+=go(arr)\\n                return\\n            if (1<<i)&l != 0 and (1<<i)&r != 0:\\n                for j in range(1,balls[i]):\\n                    arr[i] = j\\n                    solve(i+1, l,r, cntl+j, arr)\\n                    arr[i] = 0\\n            elif (1<<i)&l != 0:\\n                arr[i] = balls[i]\\n                solve(i+1, l, r, cntl+balls[i], arr)\\n                arr[i] = 0\\n            else:\\n                solve(i+1, l, r, cntl, arr)\\n        cnt = 0            \\n        temp = [0 for i in range(tm)]\\n        for i in range(t):\\n            for j in range(t):\\n                if bin(i|j).count(\"1\") == tm and bin(i).count(\"1\") == bin(j).count(\"1\"):\\n                    solve(0,i,j,0,temp)\\n        gets = fact(ed*2)\\n        for i in balls:\\n            gets /= fact(i) \\n        return res/gets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724585,
                "title": "in-depth-explanation-backtracking",
                "content": "# Intuition\\nIts a bit mathematical approach with backtracking involved.\\nFirst we find all possible combinations. Then from those combinations we count possible permutations and add those permutation to the count of fav or unfav outcomes. Finally we return fav/(fav+unfav).\\nlet dig deeper to understand what\\'s done.\\n\\nhere is the code where we genrate all combinations:\\n```\\n        for(let i=0;i<=balls[index]||selected+i<select;i++){\\n            if(balls[index]>=i){\\n                balls[index]-=i;\\n                solve(index+1,selected+i);\\n                balls[index]+=i;\\n            }\\n        }\\n```\\nselect is total selection we have to make \\nselected is selections we have made yet\\nat every level we take one box and generate all possible values\\nwe can select 0 balls or 1 or 2 till selected+i<select i.e. we have not selected enough.\\n```if(balls[index]>=i)``` keeps in check that we do not pick more than what is present in the slot.\\nThen the same itrates for every slot/box.\\n\\n``if(index===balls.length) return;`` we should return as the array is completed now\\n\\nAnd at any point of time we have selected enough balls (half of total), We need to return and count at the same time.\\nlet\\'s see the code.\\n\\n\\n```\\n        if(selected===select){\\n            let filter=initial.map((e,i)=>initial[i]-balls[i])\\n            let colorSet1=filter.reduce((a,b)=>b>0?a+1:a,0);\\n            let colorSet2=balls.reduce((a,b)=>b>0?a+1:a,0);\\n\\n            let permutationSet1=factorial(select);\\n            let permutationSet2=factorial(select);\\n\\n            filter.forEach((e)=>permutationSet1/=factorial(e))\\n            balls.forEach((e)=>permutationSet2/=factorial(e))\\n\\n            if(colorSet1===colorSet2) fav+=permutationSet1*permutationSet2;\\n            else unfav+=permutationSet1*permutationSet2;\\n            return;\\n        }\\n```\\n`if(selected===select)` represents if half of balls are selected\\n`initial` contains the initial array. \\n`balls` contains one half of array and `filter` will be the other half\\n\\nlet take an example to simplify input was [ 1, 2, 1, 2 ]\\nso initial = [ 1, 2, 1, 2 ]\\nnow one possible combination is [ 1, 1, 0, 1 ]\\n    so balls = [ 1, 1, 0, 1 ]\\n    filter will be [ 0, 1, 1, 1 ]\\n\\nnow in colorSet1 and colorSet2 we just count non 0 elements in filter and balls (i.e. unique selection of colored balls)\\nif colorSet1===colorSet2 it is a fav outcome so we add count to fav, else we add the count to unfav.\\n\\nNow [ 1, 1, 0, 1 ] is a combination of balls that can be selected it will genrate permutations so we need to calculate all the permutations possible. We can arrange n items in n! ways dividing by factorials of repeating indentical items.\\n\\nin out Particular case \\n[1,1,0,1] no permutations will be 3! = 6\\nfor another [1,2,0,0] it would be 3!/2! = 3\\n\\nNow note sum(...[1,1,0,1]) will always be equal to `select` as that is the condition we are inside.\\n\\nso permutation of set 1 can be equal to ` factorial(select) ` divide by factorial of repeating. \\nTo devide by repeating we use ` filter.forEach((e)=>permutationSet1/=factorial(e)) `\\n\\nand now permutationSet1 we have all possible permutations of set 1 or filter\\n\\nsimilarly we calculate it for set 2 or balls.\\n\\nTotal possible arrangements are permutationSet1*permutationSet2\\nwe add it to fav or unfav accordingly.\\n\\nfinally we just return.\\n \\nHere is an step by step application of this done manually\\n```\\ninput= [ 1, 2, 1, 2 ]\\nballs [ 1, 2, 0, 0 ] permutationSet2= 3 filter= [ 0, 0, 1, 2 ] permutationSet1= 3 total= 9\\n=>> total= 9 fav= 9 unfav= 0\\nballs [ 1, 1, 1, 0 ] permutationSet2= 6 filter= [ 0, 1, 0, 2 ] permutationSet1= 3 total= 18\\n=>> total= 27 fav= 9 unfav= 18\\nballs [ 1, 1, 0, 1 ] permutationSet2= 6 filter= [ 0, 1, 1, 1 ] permutationSet1= 6 total= 36\\n=>> total= 63 fav= 45 unfav= 18\\nballs [ 1, 0, 1, 1 ] permutationSet2= 6 filter= [ 0, 2, 0, 1 ] permutationSet1= 3 total= 18\\n=>> total= 81 fav= 45 unfav= 36\\nballs [ 1, 0, 0, 2 ] permutationSet2= 3 filter= [ 0, 2, 1, 0 ] permutationSet1= 3 total= 9\\n=>> total= 90 fav= 54 unfav= 36\\nballs [ 0, 2, 1, 0 ] permutationSet2= 3 filter= [ 1, 0, 0, 2 ] permutationSet1= 3 total= 9\\n=>> total= 99 fav= 63 unfav= 36\\nballs [ 0, 2, 0, 1 ] permutationSet2= 3 filter= [ 1, 0, 1, 1 ] permutationSet1= 6 total= 18\\n=>> total= 117 fav= 63 unfav= 54\\nballs [ 0, 1, 1, 1 ] permutationSet2= 6 filter= [ 1, 1, 0, 1 ] permutationSet1= 6 total= 36\\n=>> total= 153 fav= 99 unfav= 54\\nballs [ 0, 1, 0, 2 ] permutationSet2= 3 filter= [ 1, 1, 1, 0 ] permutationSet1= 6 total= 18\\n=>> total= 171 fav= 99 unfav= 72\\nballs [ 0, 0, 1, 2 ] permutationSet2= 3 filter= [ 1, 2, 0, 0 ] permutationSet1= 3 total= 9\\n=>> total= 180 fav= 108 unfav= 72\\nFINAL RESULT total= 180 fav= 108 unfav= 72 probab= 0.6\\n```\\n\\n\\n# Code\\n```\\nlet cache={}\\nfunction getProbability(balls: number[]): number {\\n    let initial= [...balls]\\n    let select= balls.reduce((a,b)=>a+b,0)/2\\n    let fav=0,unfav=0;\\n    solve(0,0);\\n    return fav/(fav+unfav);\\n\\n    function solve(index,selected){\\n        if(selected===select){\\n            let filter=initial.map((e,i)=>initial[i]-balls[i])\\n            let colorSet1=filter.reduce((a,b)=>b>0?a+1:a,0);\\n            let colorSet2=balls.reduce((a,b)=>b>0?a+1:a,0);\\n\\n            let permutationSet1=factorial(select);\\n            let permutationSet2=factorial(select);\\n\\n            filter.forEach((e)=>permutationSet1/=factorial(e))\\n            balls.forEach((e)=>permutationSet2/=factorial(e))\\n\\n            \\n            if(colorSet1===colorSet2) fav+=permutationSet1*permutationSet2;\\n            else unfav+=permutationSet1*permutationSet2;\\n            return;\\n        }\\n        if(index===balls.length) return;\\n        \\n        for(let i=0;i<=balls[index]||selected+i<select;i++){\\n            if(balls[index]>=i){\\n                balls[index]-=i;\\n                solve(index+1,selected+i);\\n                balls[index]+=i;\\n            }\\n        }\\n    }\\n    function factorial(n){\\n        if(n===0) return 1;\\n        if(n===1) return 1;\\n        if(cache[n]===undefined) cache[n]=n*factorial(n-1);\\n        return cache[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Backtracking",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```\\n        for(let i=0;i<=balls[index]||selected+i<select;i++){\\n            if(balls[index]>=i){\\n                balls[index]-=i;\\n                solve(index+1,selected+i);\\n                balls[index]+=i;\\n            }\\n        }\\n```\n```if(balls[index]>=i)```\n```\\n        if(selected===select){\\n            let filter=initial.map((e,i)=>initial[i]-balls[i])\\n            let colorSet1=filter.reduce((a,b)=>b>0?a+1:a,0);\\n            let colorSet2=balls.reduce((a,b)=>b>0?a+1:a,0);\\n\\n            let permutationSet1=factorial(select);\\n            let permutationSet2=factorial(select);\\n\\n            filter.forEach((e)=>permutationSet1/=factorial(e))\\n            balls.forEach((e)=>permutationSet2/=factorial(e))\\n\\n            if(colorSet1===colorSet2) fav+=permutationSet1*permutationSet2;\\n            else unfav+=permutationSet1*permutationSet2;\\n            return;\\n        }\\n```\n```\\ninput= [ 1, 2, 1, 2 ]\\nballs [ 1, 2, 0, 0 ] permutationSet2= 3 filter= [ 0, 0, 1, 2 ] permutationSet1= 3 total= 9\\n=>> total= 9 fav= 9 unfav= 0\\nballs [ 1, 1, 1, 0 ] permutationSet2= 6 filter= [ 0, 1, 0, 2 ] permutationSet1= 3 total= 18\\n=>> total= 27 fav= 9 unfav= 18\\nballs [ 1, 1, 0, 1 ] permutationSet2= 6 filter= [ 0, 1, 1, 1 ] permutationSet1= 6 total= 36\\n=>> total= 63 fav= 45 unfav= 18\\nballs [ 1, 0, 1, 1 ] permutationSet2= 6 filter= [ 0, 2, 0, 1 ] permutationSet1= 3 total= 18\\n=>> total= 81 fav= 45 unfav= 36\\nballs [ 1, 0, 0, 2 ] permutationSet2= 3 filter= [ 0, 2, 1, 0 ] permutationSet1= 3 total= 9\\n=>> total= 90 fav= 54 unfav= 36\\nballs [ 0, 2, 1, 0 ] permutationSet2= 3 filter= [ 1, 0, 0, 2 ] permutationSet1= 3 total= 9\\n=>> total= 99 fav= 63 unfav= 36\\nballs [ 0, 2, 0, 1 ] permutationSet2= 3 filter= [ 1, 0, 1, 1 ] permutationSet1= 6 total= 18\\n=>> total= 117 fav= 63 unfav= 54\\nballs [ 0, 1, 1, 1 ] permutationSet2= 6 filter= [ 1, 1, 0, 1 ] permutationSet1= 6 total= 36\\n=>> total= 153 fav= 99 unfav= 54\\nballs [ 0, 1, 0, 2 ] permutationSet2= 3 filter= [ 1, 1, 1, 0 ] permutationSet1= 6 total= 18\\n=>> total= 171 fav= 99 unfav= 72\\nballs [ 0, 0, 1, 2 ] permutationSet2= 3 filter= [ 1, 2, 0, 0 ] permutationSet1= 3 total= 9\\n=>> total= 180 fav= 108 unfav= 72\\nFINAL RESULT total= 180 fav= 108 unfav= 72 probab= 0.6\\n```\n```\\nlet cache={}\\nfunction getProbability(balls: number[]): number {\\n    let initial= [...balls]\\n    let select= balls.reduce((a,b)=>a+b,0)/2\\n    let fav=0,unfav=0;\\n    solve(0,0);\\n    return fav/(fav+unfav);\\n\\n    function solve(index,selected){\\n        if(selected===select){\\n            let filter=initial.map((e,i)=>initial[i]-balls[i])\\n            let colorSet1=filter.reduce((a,b)=>b>0?a+1:a,0);\\n            let colorSet2=balls.reduce((a,b)=>b>0?a+1:a,0);\\n\\n            let permutationSet1=factorial(select);\\n            let permutationSet2=factorial(select);\\n\\n            filter.forEach((e)=>permutationSet1/=factorial(e))\\n            balls.forEach((e)=>permutationSet2/=factorial(e))\\n\\n            \\n            if(colorSet1===colorSet2) fav+=permutationSet1*permutationSet2;\\n            else unfav+=permutationSet1*permutationSet2;\\n            return;\\n        }\\n        if(index===balls.length) return;\\n        \\n        for(let i=0;i<=balls[index]||selected+i<select;i++){\\n            if(balls[index]>=i){\\n                balls[index]-=i;\\n                solve(index+1,selected+i);\\n                balls[index]+=i;\\n            }\\n        }\\n    }\\n    function factorial(n){\\n        if(n===0) return 1;\\n        if(n===1) return 1;\\n        if(cache[n]===undefined) cache[n]=n*factorial(n-1);\\n        return cache[n];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3693116,
                "title": "object-oriented-for-memory-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can consider a dynamic programming approach concerning a valid combination. \\nA valid combination is one in which all colors have been used, there are no left overs of a color, and both buckets have an equal number of distinct colors. As such, we set our base case as an int cast of the boolean number of balls leftover == 0 and number distinct colors in left == number distinct colors in right. We memoize our results and progress based on this through states of color indices, num balls leftover, num distinct left and num distinct right known as a state. \\n\\nThis will over count, so we need to reduce this by the number of combinations for all balls choosing half of the balls (since left and right buckets should not really have a preferencing to them). This will give us our final result correctly. \\n\\nTo calculate our total result before division, we need to start at color 0, with exactly half of the balls used up, and no colors in either bucket. We start with exactly half since we will need to be able to split that succesfully to zero to come to a correct answer. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTook an object oriented approach for this one. \\n\\nInitialize \\n- balls storage \\n- num colors variable \\n- num balls variable \\n- even split variable \\n- states memo \\n\\nset up passing parameter of balls list \\n- set balls to balls \\n- set num colors to len of balls \\n- sest num balls to sum of balls list \\n- set even split to num balls by 2 evenly \\n- set start state to [0, even split, 0, 0] representing color index 0, even split balls remaining, 0 distinct in left and 0 distinct in right\\n- set start state tuple as tuple cast of above start state \\n- set dividend to combination of 2 * even split and even split \\n\\ndp calculation passing state and state key \\n- if state key in states memo -> return states memo @ state key \\n- otherwise \\n    - if state[0] == self.num_colors \\n        - self.states[state_key] = int(state[1] == 0 and state[2] == state[3])\\n        - return self.states at state_key \\n    - otherwise \\n        - set result = 0 \\n        - set balls of this color to self.balls at state[0] \\n        - our min range will be balls of this color or num balls leftover (state[1]) + 1 \\n        - loop for b_i (balls of color c of count i) in range min range \\n            - next state is state[0] + 1, state[1] - b_i, state[2] + (b_i > 0), state[3] + (b_i < balls_here) \\n            - next state key is tuple of next state \\n            - next state value is dp of next state, next state key \\n            - combinations here is math.comb balls of this color, b_i\\n            - result is incremented by combinations * next_state value \\n        - self.states[state_key] = result \\n        - return self.states[state_key]\\n\\nprobability \\n- return self.dp(self.start_state, self.start_state_key) / self.dividend\\n\\ngetProbability passing balls \\n- set up passing balls \\n- return probability       \\n\\n# Complexity\\n- Time complexity : O(C*B)\\n    - C * B : colors times num balls of that color on average \\n    - O(C * B) for dp progression \\n        - lowered by memoization progression \\n        - memoization also saves stack space  \\n\\n\\n- Space complexity : O(S) \\n    - We end up storing O(S) states \\n    - We do not end up exploring the entirety of O(C * B) thanks to memoization\\n    - This saves us from matching space complexity at the cost of O(S) states  \\n\\n# Code\\n```\\nclass Solution:\\n    # set up with initial fields \\n    def __init__(self) : \\n        self.balls = []\\n        self.num_colors = 0 \\n        self.num_balls  = 0\\n        self.even_split = 0 \\n        self.states = dict() \\n\\n    # set up with fields initialized with values \\n    def set_up(self, balls) : \\n        self.balls = balls \\n        self.num_colors = len(balls)\\n        self.num_balls = sum(balls)\\n        self.even_split = self.num_balls // 2 \\n        self.start_state = [0, self.even_split, 0, 0]\\n        self.start_state_tuple = tuple(self.start_state)\\n        self.dividend = math.comb(2*self.even_split, self.even_split)\\n    \\n    # dp calculation \\n    # if you have it, return it \\n    # otherwise, if you are at end of color indices, return int form of all balls used and distinct on left and right match after memoizing \\n    # otherwise, calculate for result, using balls of this color with other components \\n    # return either state valuation \\n    def dp(self, state, state_key) : \\n        if state_key in self.states : \\n            return self.states[state_key]\\n        else : \\n            if state[0] == self.num_colors : \\n                self.states[state_key] = int(state[1] == 0 and state[2] == state[3])\\n                return self.states[state_key]\\n            else : \\n                result = 0 \\n                balls_of_this_color = self.balls[state[0]]\\n                for b_i in range(min(balls_of_this_color, state[1]) + 1) : \\n                    # set next state up and then use to get uple form of next state key \\n                    next_state = [state[0] + 1, state[1]-b_i, state[2]+(b_i > 0), state[3] + (b_i < balls_of_this_color)]\\n                    next_state_key = tuple(next_state)\\n                    # calculate next state value \\n                    next_state_value = self.dp(next_state, next_state_key)\\n                    # calculate combinations current \\n                    combinations = math.comb(balls_of_this_color, b_i)\\n                    # increment by product result \\n                    result += combinations * next_state_value\\n                # set appropriately and return \\n                self.states[state_key] = result \\n                return self.states[state_key]\\n\\n    # getter function \\n    def probability(self) : \\n        # recorded start state and start state tuple during set up, calculated divided then as well \\n        return self.dp(self.start_state, self.start_state_tuple) / self.dividend\\n\\n    def getProbability(self, balls: List[int]) -> float :\\n        # set up and solve \\n        self.set_up(balls)\\n        return self.probability()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # set up with initial fields \\n    def __init__(self) : \\n        self.balls = []\\n        self.num_colors = 0 \\n        self.num_balls  = 0\\n        self.even_split = 0 \\n        self.states = dict() \\n\\n    # set up with fields initialized with values \\n    def set_up(self, balls) : \\n        self.balls = balls \\n        self.num_colors = len(balls)\\n        self.num_balls = sum(balls)\\n        self.even_split = self.num_balls // 2 \\n        self.start_state = [0, self.even_split, 0, 0]\\n        self.start_state_tuple = tuple(self.start_state)\\n        self.dividend = math.comb(2*self.even_split, self.even_split)\\n    \\n    # dp calculation \\n    # if you have it, return it \\n    # otherwise, if you are at end of color indices, return int form of all balls used and distinct on left and right match after memoizing \\n    # otherwise, calculate for result, using balls of this color with other components \\n    # return either state valuation \\n    def dp(self, state, state_key) : \\n        if state_key in self.states : \\n            return self.states[state_key]\\n        else : \\n            if state[0] == self.num_colors : \\n                self.states[state_key] = int(state[1] == 0 and state[2] == state[3])\\n                return self.states[state_key]\\n            else : \\n                result = 0 \\n                balls_of_this_color = self.balls[state[0]]\\n                for b_i in range(min(balls_of_this_color, state[1]) + 1) : \\n                    # set next state up and then use to get uple form of next state key \\n                    next_state = [state[0] + 1, state[1]-b_i, state[2]+(b_i > 0), state[3] + (b_i < balls_of_this_color)]\\n                    next_state_key = tuple(next_state)\\n                    # calculate next state value \\n                    next_state_value = self.dp(next_state, next_state_key)\\n                    # calculate combinations current \\n                    combinations = math.comb(balls_of_this_color, b_i)\\n                    # increment by product result \\n                    result += combinations * next_state_value\\n                # set appropriately and return \\n                self.states[state_key] = result \\n                return self.states[state_key]\\n\\n    # getter function \\n    def probability(self) : \\n        # recorded start state and start state tuple during set up, calculated divided then as well \\n        return self.dp(self.start_state, self.start_state_tuple) / self.dividend\\n\\n    def getProbability(self, balls: List[int]) -> float :\\n        # set up and solve \\n        self.set_up(balls)\\n        return self.probability()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565303,
                "title": "clean-self-explanatory-c-solution",
                "content": "# Approach\\nSplit balls into two groups of the, multiply each group by it\\'s frequency, and count only valid paritions. i.e, two groups of the same balls count and same distinct colors count.\\n\\n# Complexity\\n- Time complexity: $$O(N * M ^ N)$$ where M is the max number of balls of any given color + 1, and N is the number of colors.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ for the stack memory and the two arrays A, B.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    inline int ballsCount(const vector<int> &balls) const{\\n        return accumulate(balls.begin(), balls.end(), 0);\\n    }\\n\\n    inline int colorCount(const vector<int> &balls) const{\\n        return accumulate(balls.begin(), balls.end(), 0,\\n            [&](int sum, int color) {\\n                return sum + (color > 0);\\n            });\\n    }\\n\\n    inline double shufflesCount(const vector<int> &balls) const{\\n        double ans = 1, last = 0; // double to avoid overflow in long long\\n        for(int color : balls) {\\n            for(int i = 1; i <= color; i++) {\\n                last++;\\n                ans *= last; // numerator factorial\\n                ans /= i; // denominator factorial   \\n            }\\n        }\\n        return ans;\\n    }\\n\\n    double probability(int colorIdx, vector<int> &A, vector<int> &B, const vector<int> &balls) {\\n        if(colorIdx == balls.size()) {\\n            if(ballsCount(A) == ballsCount(B) && colorCount(A) == colorCount(B)) {\\n                return shufflesCount(A) * shufflesCount(B) / shufflesCount(balls);\\n            }\\n            return 0;\\n        }\\n        double ans = 0;\\n        for(int i = 0; i <= balls[colorIdx]; i++) {\\n            A[colorIdx] = i;\\n            B[colorIdx] = balls[colorIdx] - i;\\n            ans += probability(colorIdx + 1, A, B, balls);\\n            A[colorIdx] = B[colorIdx] = 0;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        vector<int> A(balls.size(), 0), B(balls.size(), 0);\\n        return probability(0, A, B, balls);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n\\n    inline int ballsCount(const vector<int> &balls) const{\\n        return accumulate(balls.begin(), balls.end(), 0);\\n    }\\n\\n    inline int colorCount(const vector<int> &balls) const{\\n        return accumulate(balls.begin(), balls.end(), 0,\\n            [&](int sum, int color) {\\n                return sum + (color > 0);\\n            });\\n    }\\n\\n    inline double shufflesCount(const vector<int> &balls) const{\\n        double ans = 1, last = 0; // double to avoid overflow in long long\\n        for(int color : balls) {\\n            for(int i = 1; i <= color; i++) {\\n                last++;\\n                ans *= last; // numerator factorial\\n                ans /= i; // denominator factorial   \\n            }\\n        }\\n        return ans;\\n    }\\n\\n    double probability(int colorIdx, vector<int> &A, vector<int> &B, const vector<int> &balls) {\\n        if(colorIdx == balls.size()) {\\n            if(ballsCount(A) == ballsCount(B) && colorCount(A) == colorCount(B)) {\\n                return shufflesCount(A) * shufflesCount(B) / shufflesCount(balls);\\n            }\\n            return 0;\\n        }\\n        double ans = 0;\\n        for(int i = 0; i <= balls[colorIdx]; i++) {\\n            A[colorIdx] = i;\\n            B[colorIdx] = balls[colorIdx] - i;\\n            ans += probability(colorIdx + 1, A, B, balls);\\n            A[colorIdx] = B[colorIdx] = 0;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        vector<int> A(balls.size(), 0), B(balls.size(), 0);\\n        return probability(0, A, B, balls);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384191,
                "title": "python3-using-permutations-and-factorials-it-is-a-math-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        fact = [1]\\n        for i in range(1, 49):\\n            fact.append(fact[-1] * i)\\n        \\n        def find_total_ways(box):\\n            total_balls = sum(box)\\n            ans = fact[total_balls]\\n            for count in box:\\n                ans //= fact[count]\\n            return ans\\n        \\n        def backtrack(idx, box_1, box_2):\\n            if idx == len(balls): \\n                if len(box_1) == len(box_2) and sum(box_1) == sum(box_2):\\n                    return find_total_ways(box_1) * find_total_ways(box_2)\\n                else:\\n                    return 0\\n            ans = 0\\n\\n            for count1 in range(balls[idx] + 1):\\n                count2 = balls[idx] - count1\\n                if count1: box_1.append(count1)\\n                if count2: box_2.append(count2)\\n                ans += backtrack(idx + 1, box_1, box_2)\\n                if count1: box_1.pop()\\n                if count2: box_2.pop()\\n            \\n            return ans\\n        \\n        total = find_total_ways(balls)\\n        valid = backtrack(0, [], [])\\n        return valid / total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        fact = [1]\\n        for i in range(1, 49):\\n            fact.append(fact[-1] * i)\\n        \\n        def find_total_ways(box):\\n            total_balls = sum(box)\\n            ans = fact[total_balls]\\n            for count in box:\\n                ans //= fact[count]\\n            return ans\\n        \\n        def backtrack(idx, box_1, box_2):\\n            if idx == len(balls): \\n                if len(box_1) == len(box_2) and sum(box_1) == sum(box_2):\\n                    return find_total_ways(box_1) * find_total_ways(box_2)\\n                else:\\n                    return 0\\n            ans = 0\\n\\n            for count1 in range(balls[idx] + 1):\\n                count2 = balls[idx] - count1\\n                if count1: box_1.append(count1)\\n                if count2: box_2.append(count2)\\n                ans += backtrack(idx + 1, box_1, box_2)\\n                if count1: box_1.pop()\\n                if count2: box_2.pop()\\n            \\n            return ans\\n        \\n        total = find_total_ways(balls)\\n        valid = backtrack(0, [], [])\\n        return valid / total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342670,
                "title": "straightforward-5-dimensional-dp",
                "content": "# Intuition\\nThis problem has a clear state (the distribution of balls at a given point) and transition (adding balls to either box). Thus, we can use dynamic programming.\\n\\n# Approach\\nNote: Although the problem statement uses $$2n$$ to refer to the total number of balls and $$k$$ to refer to the total number of types of balls, we will denote $$s\\\\le 48$$ (standing for sum) to be the total number of balls and $$n\\\\le 8$$ to be the total number of types of balls in this solution. This allows us to use $$n$$ as the length of `balls` and $$k$$ as a loop index variable in the code, which looks a bit nicer.\\n\\nNaively, storing the position of each individual ball as a state could take as much as $$O(2^s)$$ space (each ball has $$2$$ choices of box, leading to $$2^s$$ total states). However, we can optimize this by noting that not all balls are distinct and iterating over the types of balls rather than each individual ball.\\n\\nFor our state, we store:\\n1. The index of the type of ball we are considering\\n2. The number of balls in the left box\\n3. The number of balls in the right box\\n4. The number of types of balls in the left box\\n5. The number of types of balls in the right box\\n\\nWe map this state to the probability of ending up in this state.\\n\\nFor our transition, we consider what happens when\\n1. All of the type of the ball we are considering goes to the left box\\n2. All of the type of the ball we are considering goes to the right box\\n3. Some positive amount `amt` of the type of the ball we are considering goes to the left box while the remaining goes to the right box\\n\\nIn the first case, the number of balls in the left box changes as well as the number of balls in the left box. A similar situation applies for the second case.\\n\\nIn the third case, both the number of balls in the left and right boxes and the number of types of balls in the left and right boxes change.\\n\\nNow that we have our state and transition, we must compute the answer. Using the definition of conditional probability, the numerator of the fraction we wish to compute is the sum of the probabilities of the ways to evenly split the balls so that each type has the same number of types of balls. The denominator is the total number of ways to evenly split the balls.\\n\\nDividing these two results yields the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n^2s^3)$$\\nWe have six nested for loops, but the outermost and innermost loop combine to multiply the runtime by $$O\\\\left(\\\\sum_{\\\\mathrm{ballIndex}=0}^n \\\\mathrm{balls}[\\\\mathrm{ballIndex}]\\\\right)=O(s)$$. The remaining four loops take $$O(n^2s^2)$$, so the total runtime is $$O(s)\\\\cdot O(n^2s^2)=O(n^2s^3)$$.\\n\\n- Space complexity: $$O(n^3s^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int choose(int n, int r) {\\n        int res = 1;\\n        for (int i = 0; i < r; ++i) {\\n            res *= n - i;\\n            res /= i + 1;\\n        }\\n        return res;\\n    }\\n\\n    public double getProbability(int[] balls) {\\n        final int n = balls.length;\\n\\n        int sum = 0;\\n        for (int ball : balls) {\\n            sum += ball;\\n        }\\n\\n        // dp[num left][num right][num colors left][num distinct colors right] = probability\\n        double[][][][][] dp = new double[n + 1][sum / 2 + 1][sum / 2 + 1][n + 1][n + 1];\\n        dp[0][0][0][0][0] = 1.0;\\n\\n        for (int ballIndex = 0; ballIndex < n; ++ballIndex) {\\n            int ball = balls[ballIndex];\\n            for (int i = 0; i < sum / 2 + 1; ++i) {\\n                for (int j = 0; j < sum / 2 + 1; ++j) {\\n                    for (int k = 0; k <= n; ++k) {\\n                        for (int l = 0; l <= n; ++l) {\\n                            // put all in left\\n                            if (i >= ball && k >= 1) {\\n                                dp[ballIndex + 1][i][j][k][l] += dp[ballIndex][i - ball][j][k - 1][l] * Math.pow(0.5, ball);\\n                            }\\n\\n                            // put all in right\\n                            if (j >= ball && l >= 1) {\\n                                dp[ballIndex + 1][i][j][k][l] += dp[ballIndex][i][j - ball][k][l - 1] * Math.pow(0.5, ball);\\n                            }\\n\\n                            // put some in both\\n                            for (int amt = 1; amt < ball; ++amt) {\\n                                if (i >= amt && j >= ball - amt && k >= 1 && l >= 1) {\\n                                    dp[ballIndex + 1][i][j][k][l] += dp[ballIndex][i - amt][j - (ball - amt)][k - 1][l - 1] * choose(ball, amt) * Math.pow(0.5, ball);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        double num = 0;\\n        for (int i = 0; i <= n; ++i) {\\n            num += dp[n][sum / 2][sum / 2][i][i];\\n        }\\n\\n        double den = 0;\\n        for (int i = 0; i <= n; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                den += dp[n][sum / 2][sum / 2][i][j];\\n            }\\n        }\\n\\n        return num / den;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    int choose(int n, int r) {\\n        int res = 1;\\n        for (int i = 0; i < r; ++i) {\\n            res *= n - i;\\n            res /= i + 1;\\n        }\\n        return res;\\n    }\\n\\n    public double getProbability(int[] balls) {\\n        final int n = balls.length;\\n\\n        int sum = 0;\\n        for (int ball : balls) {\\n            sum += ball;\\n        }\\n\\n        // dp[num left][num right][num colors left][num distinct colors right] = probability\\n        double[][][][][] dp = new double[n + 1][sum / 2 + 1][sum / 2 + 1][n + 1][n + 1];\\n        dp[0][0][0][0][0] = 1.0;\\n\\n        for (int ballIndex = 0; ballIndex < n; ++ballIndex) {\\n            int ball = balls[ballIndex];\\n            for (int i = 0; i < sum / 2 + 1; ++i) {\\n                for (int j = 0; j < sum / 2 + 1; ++j) {\\n                    for (int k = 0; k <= n; ++k) {\\n                        for (int l = 0; l <= n; ++l) {\\n                            // put all in left\\n                            if (i >= ball && k >= 1) {\\n                                dp[ballIndex + 1][i][j][k][l] += dp[ballIndex][i - ball][j][k - 1][l] * Math.pow(0.5, ball);\\n                            }\\n\\n                            // put all in right\\n                            if (j >= ball && l >= 1) {\\n                                dp[ballIndex + 1][i][j][k][l] += dp[ballIndex][i][j - ball][k][l - 1] * Math.pow(0.5, ball);\\n                            }\\n\\n                            // put some in both\\n                            for (int amt = 1; amt < ball; ++amt) {\\n                                if (i >= amt && j >= ball - amt && k >= 1 && l >= 1) {\\n                                    dp[ballIndex + 1][i][j][k][l] += dp[ballIndex][i - amt][j - (ball - amt)][k - 1][l - 1] * choose(ball, amt) * Math.pow(0.5, ball);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        double num = 0;\\n        for (int i = 0; i <= n; ++i) {\\n            num += dp[n][sum / 2][sum / 2][i][i];\\n        }\\n\\n        double den = 0;\\n        for (int i = 0; i <= n; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                den += dp[n][sum / 2][sum / 2][i][j];\\n            }\\n        }\\n\\n        return num / den;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159815,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_probability(balls: Vec<i32>) -> f64 {\\n        let balls = balls.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let sum = balls.iter().sum::<_>();\\n        let mut a = vec![0; balls.len()];\\n        let mut b = vec![0; balls.len()];\\n        Solution::dfs(&sum, &balls, &mut a, &mut b, 0, 0, 0) / Solution::perm(&balls)\\n    }\\n\\n    fn perm(a: &[i64]) -> f64 {\\n        let mut ans = 1.0;\\n        let mut j = 1;\\n        for i in 0..a.len() {\\n            for k in 1..=a[i] {\\n                ans = ans * j as f64 / k as f64;\\n                j += 1;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn dfs(sum: &i64, balls: &[i64], a: &mut [i64], b: &mut [i64], i: usize, sa: i64, sb: i64) -> f64 {\\n        if sa > sum / 2 || sb > sum / 2 {\\n            return 0.0;\\n        }\\n        if i == balls.len() {\\n            let ca = a.iter().filter(|&&x| x > 0).count();\\n            let cb = b.iter().filter(|&&x| x > 0).count();\\n            if ca != cb {\\n                return 0.0;\\n            }\\n            return Solution::perm(a) * Solution::perm(b);\\n        }\\n        let mut ans = 0.0;\\n        for j in 0..=balls[i] {\\n            a[i] = j;\\n            b[i] = balls[i] - j;\\n            ans += Solution::dfs(sum, balls, a, b, i + 1, sa + a[i], sb + b[i]);\\n        }\\n        ans\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_probability(balls: Vec<i32>) -> f64 {\\n        let balls = balls.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let sum = balls.iter().sum::<_>();\\n        let mut a = vec![0; balls.len()];\\n        let mut b = vec![0; balls.len()];\\n        Solution::dfs(&sum, &balls, &mut a, &mut b, 0, 0, 0) / Solution::perm(&balls)\\n    }\\n\\n    fn perm(a: &[i64]) -> f64 {\\n        let mut ans = 1.0;\\n        let mut j = 1;\\n        for i in 0..a.len() {\\n            for k in 1..=a[i] {\\n                ans = ans * j as f64 / k as f64;\\n                j += 1;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn dfs(sum: &i64, balls: &[i64], a: &mut [i64], b: &mut [i64], i: usize, sa: i64, sb: i64) -> f64 {\\n        if sa > sum / 2 || sb > sum / 2 {\\n            return 0.0;\\n        }\\n        if i == balls.len() {\\n            let ca = a.iter().filter(|&&x| x > 0).count();\\n            let cb = b.iter().filter(|&&x| x > 0).count();\\n            if ca != cb {\\n                return 0.0;\\n            }\\n            return Solution::perm(a) * Solution::perm(b);\\n        }\\n        let mut ans = 0.0;\\n        for j in 0..=balls[i] {\\n            a[i] = j;\\n            b[i] = balls[i] - j;\\n            ans += Solution::dfs(sum, balls, a, b, i + 1, sa + a[i], sb + b[i]);\\n        }\\n        ans\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3085808,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n* @param {number[]} balls\\n* @return {number}\\n*/\\nvar getProbability = function(balls) \\n{\\n       var k = balls.length;\\n       var halfUsed = balls.reduce((acc,val)=>acc+val,0)/2;\\n       var startArray = new Array(k);\\n       startArray.fill(0);\\n       \\n       const perm = function(b1,b2)\\n       {\\n               var p1, p2, s1, s2;\\n               \\n               s1 =  b1.reduce((acc,val)=>acc+val,0);\\n               s2 =  b2.reduce((acc,val)=>acc+val,0);\\n               \\n               const fact = function(n)\\n               {\\n                       var f=1;\\n                       for(let i=2; i<=n; i++)\\n                               f *= i;\\n                       return  f;\\n               };\\n               \\n               p1 = fact(s1);\\n               p2 = fact(s2);\\n               \\n               b1.forEach(val=>{if(val>1)p1/=fact(val);});\\n               b2.forEach(val=>{if(val>1)p2/=fact(val);});\\n\\n               return p1*p2;\\n       };\\n       \\n       const getValidCombos = function(ballsUsed,colorNum=0)\\n       {\\n               var box1Used = ballsUsed.reduce((acc,val)=>acc+val,0);\\n               var matches = {good:0,total:0}, thisColorMax = halfUsed - box1Used;\\n\\n               if(colorNum === k-1)\\n               {\\n                       /* \\n                               Last ball color - adjust # of balls of this color to equal half\\n                               (if possible).  Then count # of different balls in each box.\\n                       */\\n                       if(thisColorMax > balls[colorNum])\\n                               return {good:0,total:0};\\n\\n                       ballsUsed[colorNum] = thisColorMax;\\n                       let ballsLeft = [];\\n                       let colorsUsed = [0,0];\\n                       for(let i=0; i<k; i++)\\n                       {\\n                               ballsLeft[i] = balls[i] - ballsUsed[i];\\n                               if(ballsUsed[i] > 0)\\n                                       colorsUsed[0]++;\\n                               if(ballsLeft[i] > 0)\\n                                       colorsUsed[1]++;\\n                       }\\n                       \\n                       /* Count the # of permutations for the boxes represented by this 1 combination. */\\n                       let permutations = perm(ballsUsed,ballsLeft,k);\\n                       return {good:(colorsUsed[1] === colorsUsed[0]) ? permutations : 0, total:permutations};\\n               }\\n\\n               thisColorMax = Math.min(thisColorMax,balls[colorNum]);\\n               for(let i=0; i<=thisColorMax; i++)\\n               {\\n                       let match = getValidCombos([...ballsUsed], colorNum+1);\\n                       matches = {good:matches.good+match.good, total:matches.total+match.total};\\n                       ballsUsed[colorNum]++;\\n               }\\n               return matches;\\n       }\\n   \\n       /* Probability = (total # of permutations with equal # of balls) / (permutations with same # of unique balls) */\\n       let res = getValidCombos(startArray);\\n       return res.good/res.total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n* @param {number[]} balls\\n* @return {number}\\n*/\\nvar getProbability = function(balls) \\n{\\n       var k = balls.length;\\n       var halfUsed = balls.reduce((acc,val)=>acc+val,0)/2;\\n       var startArray = new Array(k);\\n       startArray.fill(0);\\n       \\n       const perm = function(b1,b2)\\n       {\\n               var p1, p2, s1, s2;\\n               \\n               s1 =  b1.reduce((acc,val)=>acc+val,0);\\n               s2 =  b2.reduce((acc,val)=>acc+val,0);\\n               \\n               const fact = function(n)\\n               {\\n                       var f=1;\\n                       for(let i=2; i<=n; i++)\\n                               f *= i;\\n                       return  f;\\n               };\\n               \\n               p1 = fact(s1);\\n               p2 = fact(s2);\\n               \\n               b1.forEach(val=>{if(val>1)p1/=fact(val);});\\n               b2.forEach(val=>{if(val>1)p2/=fact(val);});\\n\\n               return p1*p2;\\n       };\\n       \\n       const getValidCombos = function(ballsUsed,colorNum=0)\\n       {\\n               var box1Used = ballsUsed.reduce((acc,val)=>acc+val,0);\\n               var matches = {good:0,total:0}, thisColorMax = halfUsed - box1Used;\\n\\n               if(colorNum === k-1)\\n               {\\n                       /* \\n                               Last ball color - adjust # of balls of this color to equal half\\n                               (if possible).  Then count # of different balls in each box.\\n                       */\\n                       if(thisColorMax > balls[colorNum])\\n                               return {good:0,total:0};\\n\\n                       ballsUsed[colorNum] = thisColorMax;\\n                       let ballsLeft = [];\\n                       let colorsUsed = [0,0];\\n                       for(let i=0; i<k; i++)\\n                       {\\n                               ballsLeft[i] = balls[i] - ballsUsed[i];\\n                               if(ballsUsed[i] > 0)\\n                                       colorsUsed[0]++;\\n                               if(ballsLeft[i] > 0)\\n                                       colorsUsed[1]++;\\n                       }\\n                       \\n                       /* Count the # of permutations for the boxes represented by this 1 combination. */\\n                       let permutations = perm(ballsUsed,ballsLeft,k);\\n                       return {good:(colorsUsed[1] === colorsUsed[0]) ? permutations : 0, total:permutations};\\n               }\\n\\n               thisColorMax = Math.min(thisColorMax,balls[colorNum]);\\n               for(let i=0; i<=thisColorMax; i++)\\n               {\\n                       let match = getValidCombos([...ballsUsed], colorNum+1);\\n                       matches = {good:matches.good+match.good, total:matches.total+match.total};\\n                       ballsUsed[colorNum]++;\\n               }\\n               return matches;\\n       }\\n   \\n       /* Probability = (total # of permutations with equal # of balls) / (permutations with same # of unique balls) */\\n       let res = getValidCombos(startArray);\\n       return res.good/res.total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2943811,
                "title": "python-solution",
                "content": "Runtime 40ms. Beats 99.21%\\n# Code\\n```\\nclass Solution:\\n\\n    def C(self, n, r) -> int:\\n        return self.l[int(n)] / self.l[int(r)] / self.l[int(n - r)]\\n    \\'\\'\\'\\n    params:\\n        idx -> what color to consider now\\n        first -> how many balls are filled to box 1\\n        second -> how many balls are filled to box 2\\n        disinct -> the diff of disinct color between box 1 and box 2\\n    return:\\n        the number of possible combinations\\n    \\'\\'\\'\\n    @cache\\n    def helper(self, idx: int, first: int, second: int, distinct: int) -> int:\\n        if idx == self.size:\\n            return distinct == 0\\n        cnt = 0\\n        if first > self.target:\\n            return 0\\n        for i in range(0, min(self.balls[idx], self.target - first) + 1):\\n            base_first = self.C(self.target - first, i)\\n            base_second = self.C(self.target - second, self.balls[idx] - i)\\n            \\n            if i == 0:\\n                addition = 1\\n            elif i == self.balls[idx]:\\n                addition = -1\\n            else:\\n                addition = 0\\n            cnt = cnt + base_first * base_second * self.helper(idx + 1, first + i, second + self.balls[idx] - i , distinct + addition)\\n            \\n        return cnt\\n\\n    def getProbability(self, balls: List[int]) -> float:\\n        a = 1\\n        self.l = [1]\\n        self.cnt = sum(balls)\\n        self.target = int(self.cnt / 2)\\n        self.size = len(balls)\\n        self.balls = balls\\n        for j in range(1, 49):\\n            a = a * j\\n            self.l.append(a)\\n        \\n        all_com = self.l[self.cnt]\\n        for ball in balls:\\n            all_com = all_com / self.l[ball]\\n\\n        return self.helper(0, 0, 0, 0) / all_com\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def C(self, n, r) -> int:\\n        return self.l[int(n)] / self.l[int(r)] / self.l[int(n - r)]\\n    \\'\\'\\'\\n    params:\\n        idx -> what color to consider now\\n        first -> how many balls are filled to box 1\\n        second -> how many balls are filled to box 2\\n        disinct -> the diff of disinct color between box 1 and box 2\\n    return:\\n        the number of possible combinations\\n    \\'\\'\\'\\n    @cache\\n    def helper(self, idx: int, first: int, second: int, distinct: int) -> int:\\n        if idx == self.size:\\n            return distinct == 0\\n        cnt = 0\\n        if first > self.target:\\n            return 0\\n        for i in range(0, min(self.balls[idx], self.target - first) + 1):\\n            base_first = self.C(self.target - first, i)\\n            base_second = self.C(self.target - second, self.balls[idx] - i)\\n            \\n            if i == 0:\\n                addition = 1\\n            elif i == self.balls[idx]:\\n                addition = -1\\n            else:\\n                addition = 0\\n            cnt = cnt + base_first * base_second * self.helper(idx + 1, first + i, second + self.balls[idx] - i , distinct + addition)\\n            \\n        return cnt\\n\\n    def getProbability(self, balls: List[int]) -> float:\\n        a = 1\\n        self.l = [1]\\n        self.cnt = sum(balls)\\n        self.target = int(self.cnt / 2)\\n        self.size = len(balls)\\n        self.balls = balls\\n        for j in range(1, 49):\\n            a = a * j\\n            self.l.append(a)\\n        \\n        all_com = self.l[self.cnt]\\n        for ball in balls:\\n            all_com = all_com / self.l[ball]\\n\\n        return self.helper(0, 0, 0, 0) / all_com\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896470,
                "title": "python-solution-with-explanation",
                "content": "\\tclass Solution:\\n\\t\\tdef getProbability(self, balls: List[int]) -> float:\\n\\t\\t\\tdef solve(idx,num,k1,k2,p):\\n\\t\\t\\t\\t#num is representing total number of balls in box1\\n\\t\\t\\t\\t#k1 is representing the distinct balls in box1\\n\\t\\t\\t\\t#k2 is representing the distinct balls in box2\\n\\t\\t\\t\\t#p is representing the ways of choosing that distinct colors balls in box1 and box2\\n\\t\\t\\t\\tnonlocal valids,ways,tot\\n\\t\\t\\t\\tif idx==n:\\n\\t\\t\\t\\t\\tif num==tot:\\n\\t\\t\\t\\t\\t\\tvalids+=(k1==k2)*p\\n\\t\\t\\t\\t\\t\\tways+=p\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(balls[idx]+1):\\n\\t\\t\\t\\t\\tif i+num>tot: break\\n\\t\\t\\t\\t\\tk11 = k1+(i>0)\\n\\t\\t\\t\\t\\tk22 = k2+((balls[idx]-i) > 0)\\n\\t\\t\\t\\t\\tsolve(idx+1,i+num,k11,k22,p*C[balls[idx]][i])\\n\\n\\t\\t\\tC=[[0 for _ in range(7)] for i in range(7)]\\n\\t\\t\\tn= len(balls)\\n\\t\\t\\tfor i in range(7):\\n\\t\\t\\t\\tC[i][i] = C[i][0] = 1\\n\\t\\t\\t\\tfor j in range(1,i):\\n\\t\\t\\t\\t\\tC[i][j] = C[i-1][j-1] + C[i-1][j]\\n\\t\\t\\ttot = 0\\n\\t\\t\\tvalids = 0\\n\\t\\t\\tways = 0\\n\\t\\t\\tfor x in balls:\\n\\t\\t\\t\\ttot+=x\\n\\t\\t\\ttot//=2\\n\\t\\t\\tsolve(0,0,0,0,1)\\n\\t\\t\\treturn valids/ways\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef getProbability(self, balls: List[int]) -> float:\\n\\t\\t\\tdef solve(idx,num,k1,k2,p):\\n\\t\\t\\t\\t#num is representing total number of balls in box1\\n\\t\\t\\t\\t#k1 is representing the distinct balls in box1\\n\\t\\t\\t\\t#k2 is representing the distinct balls in box2\\n\\t\\t\\t\\t#p is representing the ways of choosing that distinct colors balls in box1 and box2\\n\\t\\t\\t\\tnonlocal valids,ways,tot\\n\\t\\t\\t\\tif idx==n:\\n\\t\\t\\t\\t\\tif num==tot:\\n\\t\\t\\t\\t\\t\\tvalids+=(k1==k2)*p\\n\\t\\t\\t\\t\\t\\tways+=p\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(balls[idx]+1):\\n\\t\\t\\t\\t\\tif i+num>tot: break\\n\\t\\t\\t\\t\\tk11 = k1+(i>0)\\n\\t\\t\\t\\t\\tk22 = k2+((balls[idx]-i) > 0)\\n\\t\\t\\t\\t\\tsolve(idx+1,i+num,k11,k22,p*C[balls[idx]][i])\\n\\n\\t\\t\\tC=[[0 for _ in range(7)] for i in range(7)]\\n\\t\\t\\tn= len(balls)\\n\\t\\t\\tfor i in range(7):\\n\\t\\t\\t\\tC[i][i] = C[i][0] = 1\\n\\t\\t\\t\\tfor j in range(1,i):\\n\\t\\t\\t\\t\\tC[i][j] = C[i-1][j-1] + C[i-1][j]\\n\\t\\t\\ttot = 0\\n\\t\\t\\tvalids = 0\\n\\t\\t\\tways = 0\\n\\t\\t\\tfor x in balls:\\n\\t\\t\\t\\ttot+=x\\n\\t\\t\\ttot//=2\\n\\t\\t\\tsolve(0,0,0,0,1)\\n\\t\\t\\treturn valids/ways\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2794784,
                "title": "c-dp",
                "content": "```\\ndouble fact[49];\\nint N;\\nclass Solution {\\npublic:\\n    double getProbability(vector<int>& a) {\\n        fact[0] = fact[1] = 1;\\n        for(int i = 2; i < 49; i++) {\\n            fact[i] = fact[i - 1] * i;\\n        }\\n        int tot = 0; double y = 1;\\n        for(int i : a) tot += i;\\n        N = tot / 2;\\n        for(int i = 0; i < a.size(); i++) {\\n            y *= C(tot, a[i]);\\n            tot -= a[i];\\n        }\\n        return cal(a) / y;\\n    }\\n    \\n    double C(int n, int r) {\\n        return fact[n] / (fact[r] * fact[n - r]);\\n    }\\n    \\n    double cal(vector<int>& a) {\\n        double res = 0;\\n        double dp[2][25][25][9][9];\\n        memset(dp, 0.0, sizeof dp);\\n        dp[0][0][0][0][0] = 1.0;\\n        for(int cnt : a) {\\n            for(int x = 0; x <= cnt; x++) {\\n                int add1 = 0, add2 = 0;\\n                if(x > 0) add1 = 1;\\n                if(cnt - x > 0) add2 = 1;\\n                for(int i = 0; i <= N; i++) {\\n                    for(int j = 0; j <= N; j++) {\\n                        for(int l = 0; l <= a.size(); l++) {\\n                            for(int r = 0; r <= a.size(); r++) {\\n                                if(i + x <= N && j + (cnt - x) <= N && l + add1 <= a.size() && r + add2 <= a.size()) {\\n                                    dp[1][i + x][j + (cnt - x)][l + add1][r + add2] += dp[0][i][j][l][r] * C(N - i, x) * C(N - j, cnt - x);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            swap(dp[0], dp[1]);\\n            memset(dp[1], 0, sizeof dp[1]);\\n        }\\n        for(int i = 0; i <= a.size(); i++) res += dp[0][N][N][i][i];\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndouble fact[49];\\nint N;\\nclass Solution {\\npublic:\\n    double getProbability(vector<int>& a) {\\n        fact[0] = fact[1] = 1;\\n        for(int i = 2; i < 49; i++) {\\n            fact[i] = fact[i - 1] * i;\\n        }\\n        int tot = 0; double y = 1;\\n        for(int i : a) tot += i;\\n        N = tot / 2;\\n        for(int i = 0; i < a.size(); i++) {\\n            y *= C(tot, a[i]);\\n            tot -= a[i];\\n        }\\n        return cal(a) / y;\\n    }\\n    \\n    double C(int n, int r) {\\n        return fact[n] / (fact[r] * fact[n - r]);\\n    }\\n    \\n    double cal(vector<int>& a) {\\n        double res = 0;\\n        double dp[2][25][25][9][9];\\n        memset(dp, 0.0, sizeof dp);\\n        dp[0][0][0][0][0] = 1.0;\\n        for(int cnt : a) {\\n            for(int x = 0; x <= cnt; x++) {\\n                int add1 = 0, add2 = 0;\\n                if(x > 0) add1 = 1;\\n                if(cnt - x > 0) add2 = 1;\\n                for(int i = 0; i <= N; i++) {\\n                    for(int j = 0; j <= N; j++) {\\n                        for(int l = 0; l <= a.size(); l++) {\\n                            for(int r = 0; r <= a.size(); r++) {\\n                                if(i + x <= N && j + (cnt - x) <= N && l + add1 <= a.size() && r + add2 <= a.size()) {\\n                                    dp[1][i + x][j + (cnt - x)][l + add1][r + add2] += dp[0][i][j][l][r] * C(N - i, x) * C(N - j, cnt - x);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            swap(dp[0], dp[1]);\\n            memset(dp[1], 0, sizeof dp[1]);\\n        }\\n        for(int i = 0; i <= a.size(); i++) res += dp[0][N][N][i][i];\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269197,
                "title": "o-m-2n-2-dynamic-programming-combinatorics",
                "content": "Suppose we are given `m` distinct ball types, and they total to `N`, an even number. We have two boxes to distribute the balls into evenly, i.e. pick `n = N / 2` balls to place in each. What\\'s the probability they have the same count of unique ball types?\\n\\n\\n**SIZE OF SAMPLE SPACE**\\nWith these probability questions that have a combinatorial nature, we often have to compute a numerator (the size of the event we are interested in) over a denominator (the size of the sample space itself). Let\\'s do the latter first.\\n\\nOur sample space is the set of all possible choices of `n` balls out of the total `N`; once we pick those `n` balls, they go into the first box, and the rest are forced into the second.\\n\\nThis tells us then that the total space consists of \\n```\\nC(N, n) = N!/(n!(N-n)!)\\n```\\nelements. Since `N!` can be quite large, we compute this bottom up using dynamic programming.  Define:\\n```\\nchoose(i, j) = ways to choose j balls if we\\'ve only considered the first i of them\\n```\\nThen we have two decisions:\\n- don\\'t include the `i`th ball in our choice set\\n- include the `i`th ball in our choice set\\n\\nSo we have:\\n```\\nchoose(i, j) = choose(i - 1, j) + choose(i - 1, j - 1)\\n```\\nNote that we will need these intermediate calculations in the next section.\\n\\n**SIZE OF EVENT**\\nSo we\\'ve got a handle on our restricted sample space (i.e. denominator for probability computation), let\\'s get to the interesting part, the actual event we need to compute probability for.\\n\\nFor the `i`th ball type, let\\'s consider the function:\\n```\\nways(i, c1, c2, d) = # of ways to pick c1 balls for box1, c2 balls for box2 from the first i unique ball types, such that the difference in unique count between box1 and box2 is precisely d\\n```\\nSince there are `m` distinct type balls, the final answer for our event of interest will be `ways(m, n, n, 0)`. Let\\'s see how to actually compute this thing.\\n\\nAt this `i`th ball type, there are `b(i)` new balls available. We can pick any of `j = 0, 1, ..., balls(i)` of these to place into box1, and the remaining `b(i) - j` into box2 (provided we don\\'t exceed count of `n` with that choice in box1 or box2).  However, for such a `j`, there are precisely `choose(b(i), j)` ways to pick this many balls (we re-use our previous calculations here!), and so by the [multiplication](https://en.wikipedia.org/wiki/Rule_of_product#:~:text=In%20combinatorics%2C%20the%20rule%20of,ways%20of%20performing%20both%20actions.) and [addition principles](https://en.wikipedia.org/wiki/Rule_of_sum#:~:text=In%20combinatorics%2C%20the%20rule%20of,choose%20one%20of%20the%20actions.):\\n```\\nways(i, c1, c2, d) = sum_{j = 0}^b(i) choose(b(i), j) * ways(i - 1, c1 - j, c2 - b(i) + j, d +/- {0, 1})\\n```\\nwhere the `+/-{0, 1}` will be:\\n- -1 if we added all `b(i)` balls to box1 (box1 widened/closed unique count gap with box2)\\n- +1 if we added all `b(i)` balls to box2 (box2 widened/closed unique count gap with box1)\\n- 0 if we added some balls to each of box1 and box2 (neither box widened/closed unique count gap from the other)\\n\\nThus, we have our recurrence relation, and our final probability will be:\\n```\\nP = ways(m, n, n, 0) / choose(N, n)\\n```\\n\\n**OPTIMIZATION: REMOVING A STATE PARAMETER VIA PREFIX SUM**\\nNotice that we have parameters `c1` and `c2` in our function `ways(i, c1, c2, d)`. However, we know that since all balls up to whatever point must be assigned to either box:\\n```\\nb(1) + ... + b(i) = c1 + c2\\n```\\nso we can easily leverage a prefix sum on ball counts to eliminate one of these parameters. Define:\\n```\\nways(i, c1, d) := ways to pick c1 balls for box1 for first i ball types, such that unique ball type difference between box1 and box2 is d\\n```\\nThe rest of the logic for the recurrence remains the same.\\n\\n**CODE**\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        m = len(balls)\\n        N = sum(balls)\\n        n = N // 2\\n        \\n        prefix = [0] * m\\n        for i in range(m):\\n            prefix[i] = prefix[i-1] + balls[i]\\n        \\n        # STEP 1: Compute the number of ways to pick j balls from i total, i.e. C(i, j)\\n        choose = [[0] * (N + 1) for i in range(N + 1)]\\n        choose[0][0] = 1\\n        for i in range(1, N + 1):\\n            for pick in range(N + 1):\\n                # DECISION 1: don\\'t pick the ith ball \\n                choose[i][pick] += choose[i - 1][pick]\\n                # DECISION 2: pick the ith ball\\n                choose[i][pick] += choose[i - 1][pick - 1]\\n        \\n        # STEP 2: From first i ball types, compute ways to:\\n        # - pick c1 balls in box1 \\n        # - such that the difference in unique ball count between box1 and box2 is d\\n        ways = [[defaultdict(int) for k in range(n + 1)] for i in range(m + 1)]\\n        ways[0][0][0] = 1\\n        \\n        for i in range(m):\\n            b = balls[i]\\n            if i == 0:\\n                prev_total = 0\\n            else:\\n                prev_total = prefix[i - 1]\\n            for c1 in range(n + 1):\\n                c2 = prev_total - c1\\n                if c2 < 0:\\n                    continue\\n                for d in ways[i][c1]:\\n                    for add1 in range(b + 1):\\n                        add2 = b - add1\\n                        if c1 + add1 > n:\\n                            continue\\n                        if c2 + add2 > n:\\n                            continue\\n                        if add1 == b:\\n                            delta = 1\\n                        elif add2 == b:\\n                            delta = -1\\n                        else:\\n                            delta = 0\\n                        ways_to_add = choose[b][add1] * ways[i][c1][d] \\n                        ways[i + 1][c1 + add1][d + delta] += ways_to_add\\n        \\n        \\n        # compute the actual probability\\n        return ways[m][n][0] / choose[N][n]\\n```",
                "solutionTags": [],
                "code": "```\\nC(N, n) = N!/(n!(N-n)!)\\n```\n```\\nchoose(i, j) = ways to choose j balls if we\\'ve only considered the first i of them\\n```\n```\\nchoose(i, j) = choose(i - 1, j) + choose(i - 1, j - 1)\\n```\n```\\nways(i, c1, c2, d) = # of ways to pick c1 balls for box1, c2 balls for box2 from the first i unique ball types, such that the difference in unique count between box1 and box2 is precisely d\\n```\n```\\nways(i, c1, c2, d) = sum_{j = 0}^b(i) choose(b(i), j) * ways(i - 1, c1 - j, c2 - b(i) + j, d +/- {0, 1})\\n```\n```\\nP = ways(m, n, n, 0) / choose(N, n)\\n```\n```\\nb(1) + ... + b(i) = c1 + c2\\n```\n```\\nways(i, c1, d) := ways to pick c1 balls for box1 for first i ball types, such that unique ball type difference between box1 and box2 is d\\n```\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        m = len(balls)\\n        N = sum(balls)\\n        n = N // 2\\n        \\n        prefix = [0] * m\\n        for i in range(m):\\n            prefix[i] = prefix[i-1] + balls[i]\\n        \\n        # STEP 1: Compute the number of ways to pick j balls from i total, i.e. C(i, j)\\n        choose = [[0] * (N + 1) for i in range(N + 1)]\\n        choose[0][0] = 1\\n        for i in range(1, N + 1):\\n            for pick in range(N + 1):\\n                # DECISION 1: don\\'t pick the ith ball \\n                choose[i][pick] += choose[i - 1][pick]\\n                # DECISION 2: pick the ith ball\\n                choose[i][pick] += choose[i - 1][pick - 1]\\n        \\n        # STEP 2: From first i ball types, compute ways to:\\n        # - pick c1 balls in box1 \\n        # - such that the difference in unique ball count between box1 and box2 is d\\n        ways = [[defaultdict(int) for k in range(n + 1)] for i in range(m + 1)]\\n        ways[0][0][0] = 1\\n        \\n        for i in range(m):\\n            b = balls[i]\\n            if i == 0:\\n                prev_total = 0\\n            else:\\n                prev_total = prefix[i - 1]\\n            for c1 in range(n + 1):\\n                c2 = prev_total - c1\\n                if c2 < 0:\\n                    continue\\n                for d in ways[i][c1]:\\n                    for add1 in range(b + 1):\\n                        add2 = b - add1\\n                        if c1 + add1 > n:\\n                            continue\\n                        if c2 + add2 > n:\\n                            continue\\n                        if add1 == b:\\n                            delta = 1\\n                        elif add2 == b:\\n                            delta = -1\\n                        else:\\n                            delta = 0\\n                        ways_to_add = choose[b][add1] * ways[i][c1][d] \\n                        ways[i + 1][c1 + add1][d + delta] += ways_to_add\\n        \\n        \\n        # compute the actual probability\\n        return ways[m][n][0] / choose[N][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243292,
                "title": "java-backtracking-58ms",
                "content": "First gen a factorial table for up to `24!` (since the max sum is 48, we only need half).\\nThen we can try all combinations with backtracking.\\n\\nFor each valid combination, we got `total!/dupA!/dupB!/...` on each side.\\n\\nIf the colors count are equal on both side, return the product of the above,\\notherwise return 0.\\n\\n```Java\\nclass Solution {\\n    double all = 0;\\n    public double getProbability(int[] balls) {\\n        double[] fact = new double[25];\\n        fact[0]=1;\\n        for (int i = 1; i <= 24; i++){\\n            fact[i]=i*fact[i-1];\\n        }\\n        int need = Arrays.stream(balls).sum()/2;\\n        return solve(0, 0, need, new int[balls.length], balls, fact)/all;\\n    }\\n\\n    private double solve(int idx, int got, int need, int[] cur, int[] balls, double[] fact){\\n        if (need == got){\\n            int colors=0;\\n            double a = fact[need];\\n            double b = fact[need];\\n            for (int i = 0;i<cur.length;i++){\\n                if(cur[i]==balls[i]){\\n                    ++colors;\\n                }else if (cur[i]==0){\\n                    --colors;\\n                }\\n                a/=fact[cur[i]];\\n                b/=fact[balls[i]-cur[i]];\\n            }\\n            all+=a*b;\\n            return colors==0?a*b:0;\\n        }\\n        if (idx == balls.length||got>need){\\n            return 0;\\n        }\\n        double ans = 0;\\n        for (int i = 0; i <=balls[idx];i++){ // for this level of ball, try to take 0 to balls[idx]\\n            cur[idx]+=i;\\n            ans += solve(idx+1,got+i,need,cur,balls,fact);\\n            cur[idx]-=i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    double all = 0;\\n    public double getProbability(int[] balls) {\\n        double[] fact = new double[25];\\n        fact[0]=1;\\n        for (int i = 1; i <= 24; i++){\\n            fact[i]=i*fact[i-1];\\n        }\\n        int need = Arrays.stream(balls).sum()/2;\\n        return solve(0, 0, need, new int[balls.length], balls, fact)/all;\\n    }\\n\\n    private double solve(int idx, int got, int need, int[] cur, int[] balls, double[] fact){\\n        if (need == got){\\n            int colors=0;\\n            double a = fact[need];\\n            double b = fact[need];\\n            for (int i = 0;i<cur.length;i++){\\n                if(cur[i]==balls[i]){\\n                    ++colors;\\n                }else if (cur[i]==0){\\n                    --colors;\\n                }\\n                a/=fact[cur[i]];\\n                b/=fact[balls[i]-cur[i]];\\n            }\\n            all+=a*b;\\n            return colors==0?a*b:0;\\n        }\\n        if (idx == balls.length||got>need){\\n            return 0;\\n        }\\n        double ans = 0;\\n        for (int i = 0; i <=balls[idx];i++){ // for this level of ball, try to take 0 to balls[idx]\\n            cur[idx]+=i;\\n            ans += solve(idx+1,got+i,need,cur,balls,fact);\\n            cur[idx]-=i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228397,
                "title": "c-solution-by-recursion",
                "content": "Btw, I think my combination function calculate_cmn(int m, int n) is poor, how to improve it?\\n```\\nclass Solution {\\npublic:\\n    long long same;\\n    long long total;\\n    double getProbability(vector<int>& balls) {\\n        \\n        this->same = 0;\\n        this->total = 0;\\n        int bn = balls.size();\\n        helper(balls, bn, 0, 0, 0, 0, 0, 1);\\n        return (double)this->same / (double)this->total;\\n    }\\n    \\n    void helper(vector<int>& balls, int bn, int p, int k1, int k2, long q1, long q2, long long weight){\\n        \\n        if (p == bn){\\n            if (q1 == q2){\\n                if (k1 == k2){\\n                    this->same += weight;\\n                }\\n                this->total += weight;\\n            }\\n            return; \\n        }\\n        /*\\n        regular case: at index p, we have two selections\\n        1.give the color p to box1;\\n        2.give the color to box2;\\n        3.give color to both box1 and box2\\n        */\\n        for (long i = 0; i <= (long)balls[p]; i++){\\n            if (i == 0){\\n                helper(balls, bn, p + 1, k1, k2 + 1, q1, q2 + balls[p], weight);\\n            }\\n            else if (i == balls[p]){\\n                helper(balls, bn, p + 1, k1 + 1, k2, q1 + balls[p], q2, weight);\\n            }\\n            else{\\n                long cmn = calculate_cmn(i, balls[p]);\\n                helper(balls, bn, p + 1, k1 + 1, k2 + 1, q1 + i, q2 + balls[p] - i, cmn * weight);\\n            }\\n        }\\n    }\\n    long long calculate_cmn(long m, long n){\\n        if (m == 1 || m == n - 1){return n;}\\n        \\n        long long bottoms = 1;\\n        for (long factor = 2; factor <= n - m; factor++){\\n            bottoms *= factor;\\n        }\\n        long long product = 1;\\n        for (long factor = m + 1; factor <= n; factor++){\\n            product *= factor;\\n        }\\n        return product / bottoms;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long same;\\n    long long total;\\n    double getProbability(vector<int>& balls) {\\n        \\n        this->same = 0;\\n        this->total = 0;\\n        int bn = balls.size();\\n        helper(balls, bn, 0, 0, 0, 0, 0, 1);\\n        return (double)this->same / (double)this->total;\\n    }\\n    \\n    void helper(vector<int>& balls, int bn, int p, int k1, int k2, long q1, long q2, long long weight){\\n        \\n        if (p == bn){\\n            if (q1 == q2){\\n                if (k1 == k2){\\n                    this->same += weight;\\n                }\\n                this->total += weight;\\n            }\\n            return; \\n        }\\n        /*\\n        regular case: at index p, we have two selections\\n        1.give the color p to box1;\\n        2.give the color to box2;\\n        3.give color to both box1 and box2\\n        */\\n        for (long i = 0; i <= (long)balls[p]; i++){\\n            if (i == 0){\\n                helper(balls, bn, p + 1, k1, k2 + 1, q1, q2 + balls[p], weight);\\n            }\\n            else if (i == balls[p]){\\n                helper(balls, bn, p + 1, k1 + 1, k2, q1 + balls[p], q2, weight);\\n            }\\n            else{\\n                long cmn = calculate_cmn(i, balls[p]);\\n                helper(balls, bn, p + 1, k1 + 1, k2 + 1, q1 + i, q2 + balls[p] - i, cmn * weight);\\n            }\\n        }\\n    }\\n    long long calculate_cmn(long m, long n){\\n        if (m == 1 || m == n - 1){return n;}\\n        \\n        long long bottoms = 1;\\n        for (long factor = 2; factor <= n - m; factor++){\\n            bottoms *= factor;\\n        }\\n        long long product = 1;\\n        for (long factor = m + 1; factor <= n; factor++){\\n            product *= factor;\\n        }\\n        return product / bottoms;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152945,
                "title": "c-recursion-trying-all-possible-combination",
                "content": "```\\nclass Solution {\\npublic:\\n    double c[7][7]={},v=0,tc=0;\\n    int t=0;\\n    void solve(int idx,int k1,int k2,int n1,double p,vector<int>& balls){\\n        if(idx==size(balls)){\\n            if(n1==t){\\n                v+=(k1==k2)*p;\\n                tc+=p;\\n            }\\n        }else{\\n            int k11,k12;\\n            for(int i=0;i<=balls[idx];++i){\\n                if(i+n1>t) break;\\n                k11=k1+(i>0);\\n                k12=k2+(balls[idx]-i>0);\\n                solve(idx+1,k11,k12,n1+i,p*c[balls[idx]][i],balls);\\n            }\\n        }\\n    }\\n    double getProbability(vector<int>& balls) {\\n        for(int i=0;i<=6;++i){\\n            c[i][0]=c[i][i]=1;\\n            for(int j=1;j<i;++j)c[i][j]=c[i-1][j]+c[i-1][j-1];\\n        }\\n        for(auto&i:balls)t+=i;\\n        t/=2;\\n        solve(0,0,0,0,1,balls);\\n        return v/tc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double c[7][7]={},v=0,tc=0;\\n    int t=0;\\n    void solve(int idx,int k1,int k2,int n1,double p,vector<int>& balls){\\n        if(idx==size(balls)){\\n            if(n1==t){\\n                v+=(k1==k2)*p;\\n                tc+=p;\\n            }\\n        }else{\\n            int k11,k12;\\n            for(int i=0;i<=balls[idx];++i){\\n                if(i+n1>t) break;\\n                k11=k1+(i>0);\\n                k12=k2+(balls[idx]-i>0);\\n                solve(idx+1,k11,k12,n1+i,p*c[balls[idx]][i],balls);\\n            }\\n        }\\n    }\\n    double getProbability(vector<int>& balls) {\\n        for(int i=0;i<=6;++i){\\n            c[i][0]=c[i][i]=1;\\n            for(int j=1;j<i;++j)c[i][j]=c[i-1][j]+c[i-1][j-1];\\n        }\\n        for(auto&i:balls)t+=i;\\n        t/=2;\\n        solve(0,0,0,0,1,balls);\\n        return v/tc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937581,
                "title": "python-math-dfs-beats-80-runtime-and-30-memory",
                "content": "First of all, we need to understand the math behind. \\nIf we have 4 balls, two in colour `R` and two in colour `B`, then we have `6` different permutations of them:\\n```\\n1    RRBB\\n2    BBRR\\n3    RBBR\\n4    RBRB\\n5    BRBR\\n6    BRRB\\n```\\nNotice, there is only one `RRBB`, that means the two balls in `R` colour has no difference between each other. \\nTherefore, we can get the number of permutation mathmatically: \\n`factorial(total_balls) // productOf(factorial(num_of_balls_in_each_colour))`\\nBased on this observation, we can get the total number of cases.\\nBased on this observation, we can fill box 1 with `half_balls = total_balls // 2` balls and get the number of cases is actually: \\n```python\\nbox_one = factorial(half_balls) // productOf(factorial(num_of_balls_in_each_colour_in_box1))\\nbox_two = factorial(half_balls) // productOf(factorial(num_of_balls_in_each_colour_in_box2))\\nreturn box_one * box_two\\n```\\n\\nThen we use a `dfs` function to try to fill box 1, and leave the . The function returns the number of cases that two boxes have the same number of balls with the same number of distinct colours. It takes 5 parameters:\\n\\n1. `remaining` - the number of balls that box1 still has place for\\n2. `index` - the ball colour we should start at\\n3. `box1` - the product of factorials of balls in each colour in box 1 (`productOf(factorial(num_of_balls_in_each_colour_in_box1))`)\\n4. `box2` - the product of factorials of balls in each colour in box 2 (`productOf(factorial(num_of_balls_in_each_colour_in_box2))`)\\n5. `colours` - the balance of colours. \\n    * When it equals to 0, it means both boxes have the same number of distinct colours. \\n    * When it is less than 0, it means box 1 has fewer distinct colours than box2 does\\n    * When it is greater than 0, it means box 1 has more distinct colours than box2 does\\n\\n```python\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from math import factorial\\n        n = sum(balls) // 2\\n        size = len(balls)\\n        total = factorial(n * 2)\\n        for ball in balls:\\n            total //= factorial(ball)\\n        half_cases = factorial(n)\\n        @lru_cache(None)\\n        def dfs(remaining, index, box1, box2, colours):\\n            if index >= size:\\n                if remaining != 0 or colours != 0: return 0\\n                return half_cases // box1 * half_cases // box2\\n            count = 0\\n            for picked in range(min(balls[index], remaining) + 1):\\n                next_colours = colours\\n                if picked == 0: # if we do not pick this colour, then box 1 is one colour short\\n                    next_colours -= 1\\n                if picked == balls[index]: # if we picked all balls, then box 1 has one more colour\\n                    next_colours += 1\\n                count += dfs(remaining - picked, \\n                             index + 1, \\n                             box1 * factorial(picked), \\n                             box2 * factorial(balls[index] - picked),\\n                             next_colours)\\n            return count\\n        accepted = dfs(n, 0, 1, 1, 0)\\n        return accepted / total\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n1    RRBB\\n2    BBRR\\n3    RBBR\\n4    RBRB\\n5    BRBR\\n6    BRRB\\n```\n```python\\nbox_one = factorial(half_balls) // productOf(factorial(num_of_balls_in_each_colour_in_box1))\\nbox_two = factorial(half_balls) // productOf(factorial(num_of_balls_in_each_colour_in_box2))\\nreturn box_one * box_two\\n```\n```python\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        from math import factorial\\n        n = sum(balls) // 2\\n        size = len(balls)\\n        total = factorial(n * 2)\\n        for ball in balls:\\n            total //= factorial(ball)\\n        half_cases = factorial(n)\\n        @lru_cache(None)\\n        def dfs(remaining, index, box1, box2, colours):\\n            if index >= size:\\n                if remaining != 0 or colours != 0: return 0\\n                return half_cases // box1 * half_cases // box2\\n            count = 0\\n            for picked in range(min(balls[index], remaining) + 1):\\n                next_colours = colours\\n                if picked == 0: # if we do not pick this colour, then box 1 is one colour short\\n                    next_colours -= 1\\n                if picked == balls[index]: # if we picked all balls, then box 1 has one more colour\\n                    next_colours += 1\\n                count += dfs(remaining - picked, \\n                             index + 1, \\n                             box1 * factorial(picked), \\n                             box2 * factorial(balls[index] - picked),\\n                             next_colours)\\n            return count\\n        accepted = dfs(n, 0, 1, 1, 0)\\n        return accepted / total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861375,
                "title": "what-s-wrong",
                "content": "The result when i submit the solution and the result in test case are different. When i run the code in my machine i also get the correct result. What can i do?\\n![image](https://assets.leetcode.com/users/images/31f905c2-6196-4dbc-9d55-8263fd7d6704_1647627304.6116114.png)\\n```\\nclass Solution:\\n    n: int = 0\\n    sets: List[list[List[int], List[int]]] = []\\n    def complect(self, arr: List[int], firstBox: List[int], secondBox: List[int], packed = 0):\\n        if packed == 2 * self.n and len(firstBox) == len(secondBox):\\n            self.sets.append([firstBox, secondBox])\\n        for i, j in enumerate(arr):\\n            if j == 0: continue\\n            while arr[i]:\\n                arr[i] -= 1\\n                self.complect(arr[::1], firstBox[::1] + [i], secondBox[::1], packed + 1)\\n                self.complect(arr[::1], firstBox[::1], secondBox[::1] + [i], packed + 1)\\n                \\n        \\n\\n    def getProbability(self, balls: List[int]) -> float:\\n        self.n = sum(balls) // 2\\n        self.complect(balls, [], [], 0)\\n        total = len(self.sets)\\n        un = 0\\n        for i in self.sets:\\n            if len(set(i[0])) == len(set(i[1])):\\n                un += 1\\n        return un / total\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    n: int = 0\\n    sets: List[list[List[int], List[int]]] = []\\n    def complect(self, arr: List[int], firstBox: List[int], secondBox: List[int], packed = 0):\\n        if packed == 2 * self.n and len(firstBox) == len(secondBox):\\n            self.sets.append([firstBox, secondBox])\\n        for i, j in enumerate(arr):\\n            if j == 0: continue\\n            while arr[i]:\\n                arr[i] -= 1\\n                self.complect(arr[::1], firstBox[::1] + [i], secondBox[::1], packed + 1)\\n                self.complect(arr[::1], firstBox[::1], secondBox[::1] + [i], packed + 1)\\n                \\n        \\n\\n    def getProbability(self, balls: List[int]) -> float:\\n        self.n = sum(balls) // 2\\n        self.complect(balls, [], [], 0)\\n        total = len(self.sets)\\n        un = 0\\n        for i in self.sets:\\n            if len(set(i[0])) == len(set(i[1])):\\n                un += 1\\n        return un / total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583335,
                "title": "ruby-4-liner-beats-100",
                "content": "```\\ndef get_probability(a, h={}, s=a.sum/2, prod = -> s,e{(s..e).reduce 1, :*})\\n  f = -> r,c,b1,b2{ c==s ? b1==b2+r.size ? 1 : 0 : c>s || !r[0] ? 0 : h[[c,b1,b2]+(n,*r=r)] ||= \\n      (0..n).sum{|i|  f[r, c+i, b1+(i<=>0), b2+(n-i<=>0)] * prod[n-i+1,n] / prod[1,i]} }\\n  f[a, 0, 0, 0].to_f / (prod[s+1, 2*s] / prod[1,s]) end\\n  ```",
                "solutionTags": [],
                "code": "```\\ndef get_probability(a, h={}, s=a.sum/2, prod = -> s,e{(s..e).reduce 1, :*})\\n  f = -> r,c,b1,b2{ c==s ? b1==b2+r.size ? 1 : 0 : c>s || !r[0] ? 0 : h[[c,b1,b2]+(n,*r=r)] ||= \\n      (0..n).sum{|i|  f[r, c+i, b1+(i<=>0), b2+(n-i<=>0)] * prod[n-i+1,n] / prod[1,i]} }\\n  f[a, 0, 0, 0].to_f / (prod[s+1, 2*s] / prod[1,s]) end\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1284190,
                "title": "java-clean-code-diagram-representation-on-how-to-calculate-the-probability",
                "content": "Break the question into smaller parts:-\\n1]Equally divide 2n balls into 2 boxes. This can be acheived with dfs.\\n   Your dfs function should keep track of 4 things\\n           *  count of different number of balls in box1.\\n           *   count of different number of balls in box2.\\n           *   Total number of balls in box1\\n           *   Total number of balls in box1.\\n  \\n  For example, we have 4 balls of different colors. Red, Black, Green, Purple. Diffrent permutations we get after applying dfs are:-\\n     ![image](https://assets.leetcode.com/users/images/3af2eb01-683f-48b8-af9d-840506ce4afb_1624157656.2775848.png)\\n\\t \\n2] Find out all the combinations of each box. Suppose one box has Green and Purple balls. So it will have two combinations (Green, Purple) and (Purple, Green). So if we generalize things, if a box has n balls ,number of combinations will be n!. \\n\\n3] If a box has n balls containing 2 balls of same color (lets say red) and 3 other balls of same color (lets say black). Then the number of combinations become n!/(2!*3!).\\n\\n4]Mulitply the combinations of box1 and box2, to get the total combinations.\\n5] Check whether the combination is good or not i.e having same number of different color balls in each box. \\n6]Calculate the probabilty as Good combinations/Total combinations.\\n\\n```\\nclass Solution {\\n    \\n    \\t\\n\\tdouble good=0.0;\\n\\tdouble total=0.0;\\n\\t double[] factorial;\\n    public double getProbability(int[] balls) {\\n        \\n        factorial=new double[49];\\n        \\n        factorial[0]=1.0;\\n\\t\\t\\n\\t\\tfor(int i=1;i<49;i++)\\n\\t\\t{\\n\\t\\t\\tfactorial[i]=factorial[i-1]*i;\\n\\t\\t}\\n\\t\\t\\n\\t\\t int[] box1 = new int[balls.length];\\n\\t        int[] box2 = new int[balls.length];\\n\\t        dfs(0, box1, box2, balls);\\n        \\n        return valid/total;\\n        \\n    }\\n    \\tpublic  void dfs(int i, int[] box1, int[] box2, int[] balls) {\\n            \\n    //base case when we have divided all the balls in the boxes        \\n   if (i == balls.length)\\n   {\\n  \\n      int ballsinBox1 = 0;\\n   int ballsinBox2 = 0;\\n \\n   for (int j=0;j<box1.length;j++) \\n   {\\n       ballsinBox1 += box1[j];\\n   }\\n   for (int j=0;j<box2.length;j++) \\n   {\\n       ballsinBox2 += box2[j];\\n   }\\n  //Negative base case     \\n   if (ballsinBox1 != ballsinBox2) \\n   {\\n       return;\\n   }\\n   \\n  double p1 = permutation(box1);\\n   double p2 = permutation(box2);\\n  \\n    int cnt1 = 0;\\n   int cnt2 = 0;\\n   for (int value : box1) {\\n       if (value > 0) {\\n           cnt1++;\\n       }\\n   }\\n   for (int value : box2) {\\n       if (value > 0) {\\n           cnt2++;\\n       }\\n   }\\n   //Calculating total and valid.    \\n   total=total+p1*p2;\\n   if(cnt1==cnt2)\\n   {\\n\\t   good=good+p1*p2;\\n   }\\n   \\n}\\nelse {\\n    //applying dfs\\n   for (int j = 0; j <= balls[i]; j++) {\\n       box1[i] = j;\\n       box2[i] = balls[i] - j;\\n       dfs(i + 1, box1, box2, balls);\\n       box1[i] = 0;\\n       box2[i] = 0;\\n   }\\n}\\n}\\n    \\n    //getting the combinations\\n\\tpublic  double permutation(int[] box)\\n\\t{\\n\\t\\tint sum=0;\\n\\t\\tdouble product=1.0;\\n\\t\\tfor(int i=0;i<box.length;i++)\\n\\t\\t{\\n\\t\\t\\tproduct=product*factorial[box[i]];\\n\\t\\t\\tsum=sum+box[i];\\n\\t\\t}\\n\\t\\treturn (factorial[sum])/product;\\n\\t}\\n\\t\\n}\\n```\\n",
                "solutionTags": [
                    "Math",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\t\\n\\tdouble good=0.0;\\n\\tdouble total=0.0;\\n\\t double[] factorial;\\n    public double getProbability(int[] balls) {\\n        \\n        factorial=new double[49];\\n        \\n        factorial[0]=1.0;\\n\\t\\t\\n\\t\\tfor(int i=1;i<49;i++)\\n\\t\\t{\\n\\t\\t\\tfactorial[i]=factorial[i-1]*i;\\n\\t\\t}\\n\\t\\t\\n\\t\\t int[] box1 = new int[balls.length];\\n\\t        int[] box2 = new int[balls.length];\\n\\t        dfs(0, box1, box2, balls);\\n        \\n        return valid/total;\\n        \\n    }\\n    \\tpublic  void dfs(int i, int[] box1, int[] box2, int[] balls) {\\n            \\n    //base case when we have divided all the balls in the boxes        \\n   if (i == balls.length)\\n   {\\n  \\n      int ballsinBox1 = 0;\\n   int ballsinBox2 = 0;\\n \\n   for (int j=0;j<box1.length;j++) \\n   {\\n       ballsinBox1 += box1[j];\\n   }\\n   for (int j=0;j<box2.length;j++) \\n   {\\n       ballsinBox2 += box2[j];\\n   }\\n  //Negative base case     \\n   if (ballsinBox1 != ballsinBox2) \\n   {\\n       return;\\n   }\\n   \\n  double p1 = permutation(box1);\\n   double p2 = permutation(box2);\\n  \\n    int cnt1 = 0;\\n   int cnt2 = 0;\\n   for (int value : box1) {\\n       if (value > 0) {\\n           cnt1++;\\n       }\\n   }\\n   for (int value : box2) {\\n       if (value > 0) {\\n           cnt2++;\\n       }\\n   }\\n   //Calculating total and valid.    \\n   total=total+p1*p2;\\n   if(cnt1==cnt2)\\n   {\\n\\t   good=good+p1*p2;\\n   }\\n   \\n}\\nelse {\\n    //applying dfs\\n   for (int j = 0; j <= balls[i]; j++) {\\n       box1[i] = j;\\n       box2[i] = balls[i] - j;\\n       dfs(i + 1, box1, box2, balls);\\n       box1[i] = 0;\\n       box2[i] = 0;\\n   }\\n}\\n}\\n    \\n    //getting the combinations\\n\\tpublic  double permutation(int[] box)\\n\\t{\\n\\t\\tint sum=0;\\n\\t\\tdouble product=1.0;\\n\\t\\tfor(int i=0;i<box.length;i++)\\n\\t\\t{\\n\\t\\t\\tproduct=product*factorial[box[i]];\\n\\t\\t\\tsum=sum+box[i];\\n\\t\\t}\\n\\t\\treturn (factorial[sum])/product;\\n\\t}\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237126,
                "title": "c-dp",
                "content": "DP state: record[unique type of balls visited][num balls in left box][num balls in right box][unique ball kinds in left - unique ball kinds in right]\\nThe transition is on enumerating the ways to split the ith-type ball to left and box.\\n```\\ndouble record[10][50][50][20];\\n\\nclass Solution {\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        int n = balls.size();\\n        int m = 0;\\n        for (int b: balls) m += b;\\n        m /= 2;\\n        memset(record, 0.0, sizeof(record));\\n        record[0][0][0][n] = 1.0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int lSlot = 0; lSlot <= m; lSlot++) {\\n                for (int rSlot = 0; rSlot <= m; rSlot++) {\\n                    for (int det = -n; det <= n; det++) { // left unique - right unique\\n                        for (int left = 0; left <= balls[i-1]; left++) {\\n                            int right = balls[i-1] - left;\\n                            if (left > lSlot || right > rSlot) continue;\\n                            int prevDet = det + n;\\n                            if (left == 0) prevDet--;\\n                            if (right == 0) prevDet++;\\n                            if (prevDet < 0 || prevDet > 2*n) continue;\\n                            record[i][lSlot][rSlot][det+n] += record[i-1][lSlot-left][rSlot-right][prevDet] * computeCnk(lSlot, left) * computeCnk(rSlot, right) / computeCnk(lSlot + rSlot, balls[i-1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return record[n][m][m][n];\\n    }\\n    double computeCnk(int n, int k) {\\n        double result = 1.0;\\n        for (int i = 0; i < k; i++) {\\n            result *= n - i;\\n            result /= k - i;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndouble record[10][50][50][20];\\n\\nclass Solution {\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        int n = balls.size();\\n        int m = 0;\\n        for (int b: balls) m += b;\\n        m /= 2;\\n        memset(record, 0.0, sizeof(record));\\n        record[0][0][0][n] = 1.0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int lSlot = 0; lSlot <= m; lSlot++) {\\n                for (int rSlot = 0; rSlot <= m; rSlot++) {\\n                    for (int det = -n; det <= n; det++) { // left unique - right unique\\n                        for (int left = 0; left <= balls[i-1]; left++) {\\n                            int right = balls[i-1] - left;\\n                            if (left > lSlot || right > rSlot) continue;\\n                            int prevDet = det + n;\\n                            if (left == 0) prevDet--;\\n                            if (right == 0) prevDet++;\\n                            if (prevDet < 0 || prevDet > 2*n) continue;\\n                            record[i][lSlot][rSlot][det+n] += record[i-1][lSlot-left][rSlot-right][prevDet] * computeCnk(lSlot, left) * computeCnk(rSlot, right) / computeCnk(lSlot + rSlot, balls[i-1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return record[n][m][m][n];\\n    }\\n    double computeCnk(int n, int k) {\\n        double result = 1.0;\\n        for (int i = 0; i < k; i++) {\\n            result *= n - i;\\n            result /= k - i;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214891,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        n = sum(balls)//2\\n        \\n        @cache \\n        def fn(i, s0, s1, c0, c1):\\n            \"\"\"Return number of ways to distribute boxes successfully (w/o considering relative order).\"\"\"\\n            if s0 > n or s1 > n: return 0 # impossible \\n            if i == len(balls): return int(c0 == c1)\\n            ans = 0 \\n            for x in range(balls[i]+1): \\n                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)\\n            return ans\\n        \\n        return fn(0, 0, 0, 0, 0) / comb(2*n, n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        n = sum(balls)//2\\n        \\n        @cache \\n        def fn(i, s0, s1, c0, c1):\\n            \"\"\"Return number of ways to distribute boxes successfully (w/o considering relative order).\"\"\"\\n            if s0 > n or s1 > n: return 0 # impossible \\n            if i == len(balls): return int(c0 == c1)\\n            ans = 0 \\n            for x in range(balls[i]+1): \\n                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)\\n            return ans\\n        \\n        return fn(0, 0, 0, 0, 0) / comb(2*n, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137244,
                "title": "cpp-dp-0ms",
                "content": "Let us call \\u0394 the difference between the number of different colors in box 1 and the number of different colors in box 2. We have -n \\u2A7D \\u0394 \\u2A7D +n.\\nwe maintain an array where\\n\\n*dp[i][\\u0394\\xD7(nb+1)+j]* = number of ways to distribute the balls from subarray balls[i...n-1], such that *j* balls are placed in box 1, with a delta of different colors \\u0394-n.\\n\\n*nb* = sum(balls)/2 is the max number of balls we can put in box 1.\\n\\n1. If we chose to put *l* balls of colors *i* in box 1, with *l* = 1 ... ball[i]-1, that means we put at least 1 ball of the same color in box 2. There is (balls[i]  l) choices of these balls, and dp[i+1][\\u0394\\xD7(nb+1)+j-l] ways to distribute the remaining *j-l* balls with the remaining colors.\\nWe add these choices:\\ndp[i][\\u0394\\xD7(nb+1)+j] = \\u2211  (balls[i]  l)\\xD7dp[i+1][\\u0394\\xD7(nb+1)+j-l], l = 1 ... balls[i]-1\\n\\n2. If we put all the balls of color i in box 1, there is dp[i+1][(**\\u0394-1**)\\xD7(nb+1)+j-balls[i]] ways to distribute the remaining balls.\\ndp[i][\\u0394\\xD7(nb+1)+j] += dp[i+1][(\\u0394-1)\\xD7(nb+1)+j-balls[i]]\\n\\n3. If we put none of the balls of color i in box 1, there is dp[i+1][(**\\u0394+1**)\\xD7(nb+1)+j] ways to distribute the remaining balls.\\ndp[i][\\u0394\\xD7(nb+1)+j] += dp[i+1][(\\u0394+1)\\xD7(nb+1)+j]\\n\\nthe total number of ways to distribute equally the 2\\xD7*nb* balls with \\u0394=0 is then\\ndp[0][(0+n)\\xD7(nb+1)+nb]\\n\\nthe total number of ways to distribute equally the 2\\xD7*nb* balls is \\ncoeff binomial (2nb  nb) = \\u2211 (nb  k)\\xB2\\n\\nIt is better to work with counting and integers than probabilities and floating number since we do at most one rounding error with the final division.\\nThere is no need to consider some kind of ordering as suggested in the problem statement. it would just result in multiplying all the counts by some big factor.\\nI think there is still room for optimization in the 3 most inner nested loops, make use of some symmetry, think of the bounds.\\nas always we can use less space by keeping in memory only the last 2 rows in the dp array.\\nThe time complexity is O(n\\xB2 \\xD7 number of balls \\xD7 max(balls) + number of balls\\xB2) = O(n\\xB2 \\xD7 number of balls \\xD7 max(balls)).\\n\\n\\n```\\n    double getProbability(vector<int>& balls) {\\n        \\n        int n = balls.size();\\n        int nb  = std::accumulate(balls.begin(),balls.end(),0)/2;\\n        \\n        int mx(0);\\n        for(int& i: balls){\\n            mx = std::max(mx,i);\\n        }\\n        \\n        std::vector<std::vector<long unsigned int>> binomial(std::max(mx,nb)+1, std::vector<long unsigned int>(std::max(nb,mx)+1,1));\\n        \\n        for(int i=1; i<=std::max(mx,nb); ++i){\\n            for(int j=1; j<i; ++j){\\n                binomial[i][j] = binomial[i-1][j-1] + binomial[i-1][j];\\n            }\\n        }\\n        \\n        std::vector<std::vector<long unsigned int>> dp(n+1, std::vector<long unsigned int>((2*n+1)*(nb+1),0));\\n        dp[n][n*(nb+1)+0] = 1;\\n        \\n        int csum(0);\\n        \\n        for(int i=n-1; i>=0; --i){                            \\n            csum += balls[i];\\n            for(int d=n-i; d<2*(n)+1-(n-i); ++d){\\n                for(int k=0; k<=std::min(csum,nb); ++k){\\n                    \\n                    for(int l=1; l<=std::min(k,balls[i]-1); ++l){\\n                        dp[i][d*(nb+1)+k] += binomial[balls[i]][l] * dp[i+1][d*(nb+1)+(k-l)]; \\n                    }\\n                    \\n                    dp[i][d*(nb+1)+k] += dp[i+1][(d+1)*(nb+1)+k]; \\n                    \\n                    if(balls[i]<=k){\\n                       dp[i][d*(nb+1)+k] += dp[i+1][(d-1)*(nb+1)+(k-balls[i])]; \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        long unsigned int total(0);\\n        for(int i=0; i<=nb; ++i){\\n            total += binomial[nb][i]*binomial[nb][i];\\n        }\\n        \\n        return dp[0][n*(nb+1)+nb]/static_cast<double>(total);\\n        \\n    }",
                "solutionTags": [],
                "code": "Let us call \\u0394 the difference between the number of different colors in box 1 and the number of different colors in box 2. We have -n \\u2A7D \\u0394 \\u2A7D +n.\\nwe maintain an array where\\n\\n*dp[i][\\u0394\\xD7(nb+1)+j]* = number of ways to distribute the balls from subarray balls[i...n-1], such that *j* balls are placed in box 1, with a delta of different colors \\u0394-n.\\n\\n*nb* = sum(balls)/2 is the max number of balls we can put in box 1.\\n\\n1. If we chose to put *l* balls of colors *i* in box 1, with *l* = 1 ... ball[i]-1, that means we put at least 1 ball of the same color in box 2. There is (balls[i]  l) choices of these balls, and dp[i+1][\\u0394\\xD7(nb+1)+j-l] ways to distribute the remaining *j-l* balls with the remaining colors.\\nWe add these choices:\\ndp[i][\\u0394\\xD7(nb+1)+j] = \\u2211  (balls[i]  l)\\xD7dp[i+1][\\u0394\\xD7(nb+1)+j-l], l = 1 ... balls[i]-1\\n\\n2. If we put all the balls of color i in box 1, there is dp[i+1][(**\\u0394-1**)\\xD7(nb+1)+j-balls[i]] ways to distribute the remaining balls.\\ndp[i][\\u0394\\xD7(nb+1)+j] += dp[i+1][(\\u0394-1)\\xD7(nb+1)+j-balls[i]]\\n\\n3. If we put none of the balls of color i in box 1, there is dp[i+1][(**\\u0394+1**)\\xD7(nb+1)+j] ways to distribute the remaining balls.\\ndp[i][\\u0394\\xD7(nb+1)+j] += dp[i+1][(\\u0394+1)\\xD7(nb+1)+j]\\n\\nthe total number of ways to distribute equally the 2\\xD7*nb* balls with \\u0394=0 is then\\ndp[0][(0+n)\\xD7(nb+1)+nb]\\n\\nthe total number of ways to distribute equally the 2\\xD7*nb* balls is \\ncoeff binomial (2nb  nb) = \\u2211 (nb  k)\\xB2\\n\\nIt is better to work with counting and integers than probabilities and floating number since we do at most one rounding error with the final division.\\nThere is no need to consider some kind of ordering as suggested in the problem statement. it would just result in multiplying all the counts by some big factor.\\nI think there is still room for optimization in the 3 most inner nested loops, make use of some symmetry, think of the bounds.\\nas always we can use less space by keeping in memory only the last 2 rows in the dp array.\\nThe time complexity is O(n\\xB2 \\xD7 number of balls \\xD7 max(balls) + number of balls\\xB2) = O(n\\xB2 \\xD7 number of balls \\xD7 max(balls)).\\n\\n\\n```\\n    double getProbability(vector<int>& balls) {\\n        \\n        int n = balls.size();\\n        int nb  = std::accumulate(balls.begin(),balls.end(),0)/2;\\n        \\n        int mx(0);\\n        for(int& i: balls){\\n            mx = std::max(mx,i);\\n        }\\n        \\n        std::vector<std::vector<long unsigned int>> binomial(std::max(mx,nb)+1, std::vector<long unsigned int>(std::max(nb,mx)+1,1));\\n        \\n        for(int i=1; i<=std::max(mx,nb); ++i){\\n            for(int j=1; j<i; ++j){\\n                binomial[i][j] = binomial[i-1][j-1] + binomial[i-1][j];\\n            }\\n        }\\n        \\n        std::vector<std::vector<long unsigned int>> dp(n+1, std::vector<long unsigned int>((2*n+1)*(nb+1),0));\\n        dp[n][n*(nb+1)+0] = 1;\\n        \\n        int csum(0);\\n        \\n        for(int i=n-1; i>=0; --i){                            \\n            csum += balls[i];\\n            for(int d=n-i; d<2*(n)+1-(n-i); ++d){\\n                for(int k=0; k<=std::min(csum,nb); ++k){\\n                    \\n                    for(int l=1; l<=std::min(k,balls[i]-1); ++l){\\n                        dp[i][d*(nb+1)+k] += binomial[balls[i]][l] * dp[i+1][d*(nb+1)+(k-l)]; \\n                    }\\n                    \\n                    dp[i][d*(nb+1)+k] += dp[i+1][(d+1)*(nb+1)+k]; \\n                    \\n                    if(balls[i]<=k){\\n                       dp[i][d*(nb+1)+k] += dp[i+1][(d-1)*(nb+1)+(k-balls[i])]; \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        long unsigned int total(0);\\n        for(int i=0; i<=nb; ++i){\\n            total += binomial[nb][i]*binomial[nb][i];\\n        }\\n        \\n        return dp[0][n*(nb+1)+nb]/static_cast<double>(total);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1084517,
                "title": "8ms-2mb-combination-dfs-no-permutation-factorial-is-needed",
                "content": "As long as we treat balls diffirent even they are in the same color, permutation is no longer needed.\\n\\n```\\nvar pascal = make([][]int, 1, 49)\\n\\nfunc init() {\\n    pascal[0] = []int{1}\\n    for i := 1; i < 49; i++{\\n        tmp := make([]int, i+1, i+1)\\n        tmp[0], tmp[i] = 1, 1\\n        \\n        prev := pascal[i-1]        \\n        for j := 1; j < i; j++ {tmp[j] = prev[j-1]+prev[j]}\\n        \\n        pascal = append(pascal, tmp)\\n    }\\n}\\n\\nfunc getProbability(balls []int) float64 {\\n\\tballCnt := 0\\n\\tfor _, cnt := range balls {\\n\\t\\tballCnt += cnt\\n\\t}\\n\\n    half := ballCnt>>1\\n    \\n    targetCnt := 0\\n    \\n\\tvar dfs func(i, s1cnt, s2cnt, s1Ccnt, s2Ccnt, com int) //com = combination\\n\\tdfs = func(i, s1cnt, s2cnt, s1Ccnt, s2Ccnt, com int) {      \\n\\t\\tif s1cnt == half { //balls cnt of set1 == half cnt of total balls\\n            if s1Ccnt == s2Ccnt+len(balls)-i {targetCnt += com} //color cnt of s1 == color cnt of s2\\n\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif s1cnt > half {return}\\n\\n\\t\\tnexti := i + 1\\n\\n        balliNum := balls[i]\\n\\t\\ts1cnt += balliNum\\n        s1Ccnt++\\n        dfs(nexti, s1cnt, s2cnt, s1Ccnt, s2Ccnt, com)\\n\\n        s2Ccnt++\\n\\t\\tfor j := 1; j <= balliNum; j++ {\\n            if s2cnt++; s2cnt > half {return}\\n            \\n            s1cnt--\\n            if j == balliNum {s1Ccnt--}\\n            \\n            dfs(nexti, s1cnt, s2cnt, s1Ccnt, s2Ccnt, com*pascal[balliNum][j])\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0, 0, 0, 0, 0, 1)\\n\\n    return float64(targetCnt)/float64(pascal[ballCnt][half])\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar pascal = make([][]int, 1, 49)\\n\\nfunc init() {\\n    pascal[0] = []int{1}\\n    for i := 1; i < 49; i++{\\n        tmp := make([]int, i+1, i+1)\\n        tmp[0], tmp[i] = 1, 1\\n        \\n        prev := pascal[i-1]        \\n        for j := 1; j < i; j++ {tmp[j] = prev[j-1]+prev[j]}\\n        \\n        pascal = append(pascal, tmp)\\n    }\\n}\\n\\nfunc getProbability(balls []int) float64 {\\n\\tballCnt := 0\\n\\tfor _, cnt := range balls {\\n\\t\\tballCnt += cnt\\n\\t}\\n\\n    half := ballCnt>>1\\n    \\n    targetCnt := 0\\n    \\n\\tvar dfs func(i, s1cnt, s2cnt, s1Ccnt, s2Ccnt, com int) //com = combination\\n\\tdfs = func(i, s1cnt, s2cnt, s1Ccnt, s2Ccnt, com int) {      \\n\\t\\tif s1cnt == half { //balls cnt of set1 == half cnt of total balls\\n            if s1Ccnt == s2Ccnt+len(balls)-i {targetCnt += com} //color cnt of s1 == color cnt of s2\\n\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif s1cnt > half {return}\\n\\n\\t\\tnexti := i + 1\\n\\n        balliNum := balls[i]\\n\\t\\ts1cnt += balliNum\\n        s1Ccnt++\\n        dfs(nexti, s1cnt, s2cnt, s1Ccnt, s2Ccnt, com)\\n\\n        s2Ccnt++\\n\\t\\tfor j := 1; j <= balliNum; j++ {\\n            if s2cnt++; s2cnt > half {return}\\n            \\n            s1cnt--\\n            if j == balliNum {s1Ccnt--}\\n            \\n            dfs(nexti, s1cnt, s2cnt, s1Ccnt, s2Ccnt, com*pascal[balliNum][j])\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0, 0, 0, 0, 0, 1)\\n\\n    return float64(targetCnt)/float64(pascal[ballCnt][half])\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020272,
                "title": "c-combination-number-and-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        init(balls);\\n        long sumProb = 0;\\n        dfs(0, 0, 1, 0, 0, sumProb);\\n        return double(sumProb) / combis[n][n/2];\\n    }\\n    \\n    void dfs(int i, int numBalls, long prob, int numColor1, int numColor2, long& sumProb){\\n        if(numBalls > n/2) return;\\n        if(i == v.size()){\\n            if(numBalls != n/2) return;\\n            if(numColor1 == numColor2) sumProb += prob;\\n            return;\\n        }\\n        const int size = v[i];\\n        for(int j=0;j<=size;j++){\\n            int newNumColor1 = numColor1 + (j!=0);\\n            int newNumColor2 = numColor2 + (j!= size);\\n            dfs(i+1, numBalls + j, prob*combis[size][j], newNumColor1, newNumColor2, sumProb);\\n        }\\n    }\\n    \\n    void init(vector<int>& balls){\\n        v = balls;\\n        n = accumulate(balls.begin(), balls.end(), 0);\\n        combis = vector(n+1, vector<long>());\\n        combis[0].push_back(1);\\n        for(int i=1;i<=n;i++){\\n            combis[i].push_back(1);\\n            for(int j=1;j<combis[i-1].size();j++) \\n                combis[i].push_back(combis[i-1][j-1] + combis[i-1][j]);\\n            combis[i].push_back(1);\\n        }\\n    }\\n    \\n    vector<int> v;\\n    vector<vector<long>> combis;\\n    int n;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        init(balls);\\n        long sumProb = 0;\\n        dfs(0, 0, 1, 0, 0, sumProb);\\n        return double(sumProb) / combis[n][n/2];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1007119,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        \\n        @lru_cache(None)\\n        def prod(n):\\n            if n <= 1:\\n                return 1\\n            else:\\n                return n * prod(n - 1)\\n        \\n        @lru_cache(None)\\n        def m_choose_multi(tup0, tup1):\\n            ans = 1\\n            \\n            for m0, m1 in zip(tup0, tup1):\\n                ans *= prod(m0 + m1) / prod(m0) / prod(m1)\\n            return ans\\n        \\n        lst0 = [0] * len(balls)\\n        lst1 = [0] * len(balls)\\n        \\n        def backtrack(idx, n0, n1):\\n            \\n            if idx == len(balls):\\n                if sum([1 if m > 0 else 0 for m in lst0]) == sum([1 if m > 0 else 0 for m in lst1]):\\n                    return m_choose_multi(tuple(lst0), tuple(lst1))\\n                else:\\n                    return 0\\n                \\n            ans = 0\\n            \\n            for k in range(balls[idx] + 1):\\n                if n0 >= k and n1 >= balls[idx] - k:\\n                    lst0[idx] = k\\n                    lst1[idx] = balls[idx] - k\\n                    ans += backtrack(idx + 1, n0 - k, n1 - (balls[idx] - k))\\n                                \\n            return ans\\n        \\n        n = sum(balls)\\n                \\n        return backtrack(0, n//2, n//2) / (prod(n) / prod(n // 2) / prod(n // 2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        \\n        @lru_cache(None)\\n        def prod(n):\\n            if n <= 1:\\n                return 1\\n            else:\\n                return n * prod(n - 1)\\n        \\n        @lru_cache(None)\\n        def m_choose_multi(tup0, tup1):\\n            ans = 1\\n            \\n            for m0, m1 in zip(tup0, tup1):\\n                ans *= prod(m0 + m1) / prod(m0) / prod(m1)\\n            return ans\\n        \\n        lst0 = [0] * len(balls)\\n        lst1 = [0] * len(balls)\\n        \\n        def backtrack(idx, n0, n1):\\n            \\n            if idx == len(balls):\\n                if sum([1 if m > 0 else 0 for m in lst0]) == sum([1 if m > 0 else 0 for m in lst1]):\\n                    return m_choose_multi(tuple(lst0), tuple(lst1))\\n                else:\\n                    return 0\\n                \\n            ans = 0\\n            \\n            for k in range(balls[idx] + 1):\\n                if n0 >= k and n1 >= balls[idx] - k:\\n                    lst0[idx] = k\\n                    lst1[idx] = balls[idx] - k\\n                    ans += backtrack(idx + 1, n0 - k, n1 - (balls[idx] - k))\\n                                \\n            return ans\\n        \\n        n = sum(balls)\\n                \\n        return backtrack(0, n//2, n//2) / (prod(n) / prod(n // 2) / prod(n // 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826995,
                "title": "c-bottom-up-dp-solution",
                "content": "dp[index, i, j, k]: means after allocating the indexth balls,, there are i unique in box1, j unique in box2, and k total balls in box1.  We can record the presum, so there will be presum-k balls in box2. For the next index+1, we can update dp[index+1, i, j, k] based on how many we allocate to box1 and box2. \\n\\n\\n\\t\\tpublic double DP(int[] balls)\\n        {\\n            var n = balls.Length;\\n            var total = balls.Sum();\\n\\n            var dp = new int[n, n + 1, n + 1, total + 1];\\n            var presum = balls[0];\\n            dp[0, 0, 1, 0] = 1;\\n            dp[0, 1, 0, presum] = 1;\\n            for (var i = 1; i < presum; i++)\\n            {\\n                dp[0, 1, 1, i] = 1;\\n            }\\n\\n            for (var index = 1; index < n; index++)\\n            {\\n                var m = balls[index];\\n                for (var c = 0; c <= m; c++)\\n                {\\n                    for (var i = 0; i <= index; i++)\\n                    {\\n                        for (var j = 0; j <= index; j++)\\n                        {\\n                            for (var k = 0; k <= presum; k++)\\n                            {\\n                                var tmp = dp[index-1, i, j, k];\\n                                if (tmp == 0) continue;\\n                                var p1 = c;\\n                                var p2 = m - c;\\n                                var t1 = 1;\\n                                while (p1 > 0)\\n                                {\\n                                    tmp = tmp * (k + p1);\\n                                    t1 *= p1;\\n                                    p1--;\\n                                }\\n\\n                                tmp /= t1;\\n\\n                                var t2 = 1;\\n                                while (p2 > 0)\\n                                {\\n                                    tmp = tmp * (presum - k + p2);\\n                                    t2 *= p2;\\n                                    p2--;\\n                                }\\n\\n                                tmp /= t2;\\n\\n                                if (c == 0)\\n                                {\\n                                    dp[index, i, j + 1, k + c] += tmp;\\n                                }\\n                                else if (c == m)\\n                                {\\n                                    dp[index, i + 1, j, k + c] += tmp;\\n                                }\\n                                else\\n                                {\\n                                    dp[index, i + 1, j + 1, k + c] += tmp;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                presum += m;\\n            }\\n\\n            double all = 0;\\n            double good = 0;\\n            var count = presum / 2;\\n            for (var i = 0; i <= n; i++)\\n            {\\n                for (var j = 0; j <= n; j++)\\n                {\\n                    all += dp[n-1, i, j, count];\\n                    if (i == j)\\n                    {\\n                        good += dp[n-1, i, j, count];\\n                    }\\n                }\\n            }\\n\\n            return good / all;\\n        }",
                "solutionTags": [],
                "code": "dp[index, i, j, k]: means after allocating the indexth balls,, there are i unique in box1, j unique in box2, and k total balls in box1.  We can record the presum, so there will be presum-k balls in box2. For the next index+1, we can update dp[index+1, i, j, k] based on how many we allocate to box1 and box2. \\n\\n\\n\\t\\tpublic double DP(int[] balls)\\n        {\\n            var n = balls.Length;\\n            var total = balls.Sum();\\n\\n            var dp = new int[n, n + 1, n + 1, total + 1];\\n            var presum = balls[0];\\n            dp[0, 0, 1, 0] = 1;\\n            dp[0, 1, 0, presum] = 1;\\n            for (var i = 1; i < presum; i++)\\n            {\\n                dp[0, 1, 1, i] = 1;\\n            }\\n\\n            for (var index = 1; index < n; index++)\\n            {\\n                var m = balls[index];\\n                for (var c = 0; c <= m; c++)\\n                {\\n                    for (var i = 0; i <= index; i++)\\n                    {\\n                        for (var j = 0; j <= index; j++)\\n                        {\\n                            for (var k = 0; k <= presum; k++)\\n                            {\\n                                var tmp = dp[index-1, i, j, k];\\n                                if (tmp == 0) continue;\\n                                var p1 = c;\\n                                var p2 = m - c;\\n                                var t1 = 1;\\n                                while (p1 > 0)\\n                                {\\n                                    tmp = tmp * (k + p1);\\n                                    t1 *= p1;\\n                                    p1--;\\n                                }\\n\\n                                tmp /= t1;\\n\\n                                var t2 = 1;\\n                                while (p2 > 0)\\n                                {\\n                                    tmp = tmp * (presum - k + p2);\\n                                    t2 *= p2;\\n                                    p2--;\\n                                }\\n\\n                                tmp /= t2;\\n\\n                                if (c == 0)\\n                                {\\n                                    dp[index, i, j + 1, k + c] += tmp;\\n                                }\\n                                else if (c == m)\\n                                {\\n                                    dp[index, i + 1, j, k + c] += tmp;\\n                                }\\n                                else\\n                                {\\n                                    dp[index, i + 1, j + 1, k + c] += tmp;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                presum += m;\\n            }\\n\\n            double all = 0;\\n            double good = 0;\\n            var count = presum / 2;\\n            for (var i = 0; i <= n; i++)\\n            {\\n                for (var j = 0; j <= n; j++)\\n                {\\n                    all += dp[n-1, i, j, count];\\n                    if (i == j)\\n                    {\\n                        good += dp[n-1, i, j, count];\\n                    }\\n                }\\n            }\\n\\n            return good / all;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 787000,
                "title": "scala-multinomials",
                "content": "```\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  def getProbability(balls: Array[Int]): Double = getProbability(balls.toSeq: _*)\\n\\n  private def getProbability(balls: Int*): Double = {\\n    val totalBalls = balls.sum\\n    cartesianProduct(balls.map(0 to _): _*)\\n      .filter(_.sum == totalBalls / 2)\\n      .map { firstBox =>\\n        balls\\n          .zip(firstBox)\\n          .map {\\n            case (numBalls, numBallsInFirstBox) => numBalls - numBallsInFirstBox\\n          }\\n          .pipe(firstBox -> _)\\n      }\\n      .collect {\\n        case (firstBox, secondBox) if firstBox.count(_ > 0) == secondBox.count(_ > 0) =>\\n          multinomial(firstBox: _*) * multinomial(secondBox: _*)\\n      }\\n      .sum\\n      .pipe(_ / multinomial(balls: _*))\\n  }\\n\\n  private def cartesianProduct[A](iterables: Iterable[A]*): LazyList[Seq[A]] = {\\n    iterables match {\\n      case Seq(head, tail@_*) => cartesianProduct(tail: _*).flatMap(seq => head.map(_ +: seq))\\n      case _ => LazyList(Seq[A]())\\n    }\\n  }\\n\\n  private def multinomial(counts: Int*) = {\\n    factorial(counts.sum) / counts.map(factorial).product\\n  }\\n\\n  private def factorial(n: Int) = (2 to n).map(_.toDouble).product\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  def getProbability(balls: Array[Int]): Double = getProbability(balls.toSeq: _*)\\n\\n  private def getProbability(balls: Int*): Double = {\\n    val totalBalls = balls.sum\\n    cartesianProduct(balls.map(0 to _): _*)\\n      .filter(_.sum == totalBalls / 2)\\n      .map { firstBox =>\\n        balls\\n          .zip(firstBox)\\n          .map {\\n            case (numBalls, numBallsInFirstBox) => numBalls - numBallsInFirstBox\\n          }\\n          .pipe(firstBox -> _)\\n      }\\n      .collect {\\n        case (firstBox, secondBox) if firstBox.count(_ > 0) == secondBox.count(_ > 0) =>\\n          multinomial(firstBox: _*) * multinomial(secondBox: _*)\\n      }\\n      .sum\\n      .pipe(_ / multinomial(balls: _*))\\n  }\\n\\n  private def cartesianProduct[A](iterables: Iterable[A]*): LazyList[Seq[A]] = {\\n    iterables match {\\n      case Seq(head, tail@_*) => cartesianProduct(tail: _*).flatMap(seq => head.map(_ +: seq))\\n      case _ => LazyList(Seq[A]())\\n    }\\n  }\\n\\n  private def multinomial(counts: Int*) = {\\n    factorial(counts.sum) / counts.map(factorial).product\\n  }\\n\\n  private def factorial(n: Int) = (2 to n).map(_.toDouble).product\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 775939,
                "title": "rust-translated",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Probability of a Two Boxes Having The Same Number of Distinct Balls.\\nMemory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Probability of a Two Boxes Having The Same Number of Distinct Balls.\\nhttps://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/discuss/665680/Java-From-TLE-to-1000ms-to-25ms-to-1ms%3A-Combination-%2B-DP\\n\\n```rust\\nconst EPSILON: f64 = 1.0e-5;\\n\\nimpl Solution {\\n    pub fn get_probability(balls: Vec<i32>) -> f64 {\\n        let m = balls.len();\\n        let n = balls.iter().fold(0, |acc, x| acc + *x) as usize / 2;\\n        let mut combinations = vec![vec![0.0f64; (n + 1) as usize]; (2 * n + 1) as usize];\\n        combinations[0][0] = 1.0;\\n        for i in 1..(2 * n + 1) as usize {\\n            combinations[i][0] = 1.0;\\n            for j in 1..(n + 1) as usize {\\n                combinations[i][j] = combinations[i - 1][j] + combinations[i - 1][j - 1]\\n            }\\n        }\\n        let mut dp = vec![vec![0.0f64; n + 1]; 2 * m + 1];\\n        dp[m][0] = 1.0;\\n        let mut sum = 0usize;\\n        for b in balls {\\n            sum += b as usize;\\n            let mut ndp = vec![vec![0.0f64; n + 1]; 2 * m + 1];\\n            for i in 0..=b as usize {\\n                for j in 0..2 * m + 1 {\\n                    for k in 0..n + 1 {\\n                        if dp[j][k] == 0.0 {\\n                            continue;\\n                        }\\n                        let nk = k + i;\\n                        let nr = sum - nk;\\n                        if nk <= n && nr <= n {\\n                            let nj = if i == 0 {\\n                                j - 1\\n                            } else {\\n                                if i == b as usize {\\n                                    j + 1\\n                                } else {\\n                                    j\\n                                }\\n                            };\\n                            ndp[nj][nk] += dp[j][k] * combinations[b as usize][i];\\n                        }\\n                    }\\n                }\\n            }\\n            dp = ndp;\\n        }\\n        dp[m][n] / combinations[2 * n][n]\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_get_probability() {\\n        assert_eq!(Solution::get_probability(vec![1, 1]), 1.00000)\\n    }\\n\\n    #[test]\\n    fn test_get_probability_02() {\\n        assert!((Solution::get_probability(vec![2, 1, 1]) - 0.66667).abs() < EPSILON)\\n    }\\n\\n    #[test]\\n    fn test_get_probability_03() {\\n        assert_eq!(Solution::get_probability(vec![1, 2, 1, 2]), 0.6)\\n    }\\n\\n    #[test]\\n    fn test_get_probability_04() {\\n        assert!((Solution::get_probability(vec![6, 6, 6, 6, 6, 6]) - 0.90327).abs() < EPSILON)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nconst EPSILON: f64 = 1.0e-5;\\n\\nimpl Solution {\\n    pub fn get_probability(balls: Vec<i32>) -> f64 {\\n        let m = balls.len();\\n        let n = balls.iter().fold(0, |acc, x| acc + *x) as usize / 2;\\n        let mut combinations = vec![vec![0.0f64; (n + 1) as usize]; (2 * n + 1) as usize];\\n        combinations[0][0] = 1.0;\\n        for i in 1..(2 * n + 1) as usize {\\n            combinations[i][0] = 1.0;\\n            for j in 1..(n + 1) as usize {\\n                combinations[i][j] = combinations[i - 1][j] + combinations[i - 1][j - 1]\\n            }\\n        }\\n        let mut dp = vec![vec![0.0f64; n + 1]; 2 * m + 1];\\n        dp[m][0] = 1.0;\\n        let mut sum = 0usize;\\n        for b in balls {\\n            sum += b as usize;\\n            let mut ndp = vec![vec![0.0f64; n + 1]; 2 * m + 1];\\n            for i in 0..=b as usize {\\n                for j in 0..2 * m + 1 {\\n                    for k in 0..n + 1 {\\n                        if dp[j][k] == 0.0 {\\n                            continue;\\n                        }\\n                        let nk = k + i;\\n                        let nr = sum - nk;\\n                        if nk <= n && nr <= n {\\n                            let nj = if i == 0 {\\n                                j - 1\\n                            } else {\\n                                if i == b as usize {\\n                                    j + 1\\n                                } else {\\n                                    j\\n                                }\\n                            };\\n                            ndp[nj][nk] += dp[j][k] * combinations[b as usize][i];\\n                        }\\n                    }\\n                }\\n            }\\n            dp = ndp;\\n        }\\n        dp[m][n] / combinations[2 * n][n]\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_get_probability() {\\n        assert_eq!(Solution::get_probability(vec![1, 1]), 1.00000)\\n    }\\n\\n    #[test]\\n    fn test_get_probability_02() {\\n        assert!((Solution::get_probability(vec![2, 1, 1]) - 0.66667).abs() < EPSILON)\\n    }\\n\\n    #[test]\\n    fn test_get_probability_03() {\\n        assert_eq!(Solution::get_probability(vec![1, 2, 1, 2]), 0.6)\\n    }\\n\\n    #[test]\\n    fn test_get_probability_04() {\\n        assert!((Solution::get_probability(vec![6, 6, 6, 6, 6, 6]) - 0.90327).abs() < EPSILON)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 754246,
                "title": "cpp-solution-with-dp-backtracking-commented",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    double fact[7] = { 1, 1, 2, 6, 24, 120, 720 };      //need to take factorial to account for number of ways that color counts can be mismatched among the two buckets\\n    double total = 0, match = 0;\\n    \\n \\n    \\n    void dfs(vector<int>& balls, int i , int n , int c , double w) {\\n        if (i == balls.size()) {                    //condition to exit the recursion and do calculation\\n            total += w * !n;                        //calculation for the total\\n            match += w * !n * !c;                   //calculation for the match\\n            return;\\n            \\n        }\\n        for (int b2 = 0, b1 = balls[i]; b1 >= 0; b2++, b1--) { // going through the ball set for each color\\n           \\n            dfs(balls, i + 1, n + b1 -b2, c + !b2 - !b1, w / fact[b1] / fact[b2]);  // b1 - b2 tracks the difference in the number of balls between the two buckets\\n                                                                                    // !b2 - !b1 tells you if one bucket has 0 balls which means missing the color\\n        }\\n    }\\n    \\n    double getProbability(vector<int>& balls) {\\n        dfs(balls,0,0,0,1.0);\\n        return match / total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    double fact[7] = { 1, 1, 2, 6, 24, 120, 720 };      //need to take factorial to account for number of ways that color counts can be mismatched among the two buckets\\n    double total = 0, match = 0;\\n    \\n \\n    \\n    void dfs(vector<int>& balls, int i , int n , int c , double w) {\\n        if (i == balls.size()) {                    //condition to exit the recursion and do calculation\\n            total += w * !n;                        //calculation for the total\\n            match += w * !n * !c;                   //calculation for the match\\n            return;\\n            \\n        }\\n        for (int b2 = 0, b1 = balls[i]; b1 >= 0; b2++, b1--) { // going through the ball set for each color\\n           \\n            dfs(balls, i + 1, n + b1 -b2, c + !b2 - !b1, w / fact[b1] / fact[b2]);  // b1 - b2 tracks the difference in the number of balls between the two buckets\\n                                                                                    // !b2 - !b1 tells you if one bucket has 0 balls which means missing the color\\n        }\\n    }\\n    \\n    double getProbability(vector<int>& balls) {\\n        dfs(balls,0,0,0,1.0);\\n        return match / total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669431,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    double perm(vector<int> &A) {\\n        double ans = 1;\\n        for (int i = 0, j = 1; i < A.size(); ++i) {\\n            for (int k = 1; k <= A[i]; ++k, ++j) ans = ans * j / k; \\n        }\\n        return ans;\\n    }\\n    int sum = 0;\\n    double dfs(vector<int> &A, vector<int>& a, vector<int> &b, int i, int sa, int sb) {\\n        if (sa > sum / 2 || sb > sum / 2) return 0;\\n        else if (i == A.size()) {\\n            int ca = 0, cb = 0;\\n            for (int j = 0; j < A.size(); ++j) ca += a[j] > 0;\\n            for (int j = 0; j < A.size(); ++j) cb += b[j] > 0;\\n            if (ca != cb) return 0;\\n            return perm(a) * perm(b);\\n        }\\n        double ans = 0;\\n        for (int j = 0; j <= A[i]; ++j) {\\n            a[i] = j;\\n            b[i] = A[i] - j;\\n            ans += dfs(A, a, b, i + 1, sa + a[i], sb + b[i]);\\n        }\\n        return ans;\\n    }\\npublic:\\n    double getProbability(vector<int>& A) {\\n        sum = accumulate(begin(A), end(A), 0);\\n        vector<int> a(A.size()), b(A.size());\\n        return dfs(A, a, b, 0, 0, 0) / perm(A);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double perm(vector<int> &A) {\\n        double ans = 1;\\n        for (int i = 0, j = 1; i < A.size(); ++i) {\\n            for (int k = 1; k <= A[i]; ++k, ++j) ans = ans * j / k; \\n        }\\n        return ans;\\n    }\\n    int sum = 0;\\n    double dfs(vector<int> &A, vector<int>& a, vector<int> &b, int i, int sa, int sb) {\\n        if (sa > sum / 2 || sb > sum / 2) return 0;\\n        else if (i == A.size()) {\\n            int ca = 0, cb = 0;\\n            for (int j = 0; j < A.size(); ++j) ca += a[j] > 0;\\n            for (int j = 0; j < A.size(); ++j) cb += b[j] > 0;\\n            if (ca != cb) return 0;\\n            return perm(a) * perm(b);\\n        }\\n        double ans = 0;\\n        for (int j = 0; j <= A[i]; ++j) {\\n            a[i] = j;\\n            b[i] = A[i] - j;\\n            ans += dfs(A, a, b, i + 1, sa + a[i], sb + b[i]);\\n        }\\n        return ans;\\n    }\\npublic:\\n    double getProbability(vector<int>& A) {\\n        sum = accumulate(begin(A), end(A), 0);\\n        vector<int> a(A.size()), b(A.size());\\n        return dfs(A, a, b, 0, 0, 0) / perm(A);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669097,
                "title": "javascript-recursive-approach-4-days-after-test",
                "content": "304ms (60%) 42.9MB\\nKudos to those who finished this during the test.\\nThis approach basically looks at every valid combination, as follows:\\n- Starting with nothing in the first box, go to the first color.\\n- Try everything with none of that color in the first box, then with 1 of that color, up to the # of balls with that color.\\n- When you get to the last color, put in the # of that color necessary to get half the balls in the first box, if impossible record no tries, and no matches.\\n- Otherwise count the # of colors in each box.  If they match, matches = 1, otherwise 0.\\n- Multiply tries (1) and matches (0 or 1) by the # of permutations.  This took me a while, but I finally used this:\\n```Pn = (# of balls in box n)!/((# of balls of 1st color)!(# of balls of 2nd color)! ... (# of balls of last color)!)```\\nI returned P1 * P2\\n- Probability = # of matches / # of tries\\n ```\\n /**\\n * @param {number[]} balls\\n * @return {number}\\n */\\nvar getProbability = function(balls) \\n{\\n        var k = balls.length;\\n        var halfUsed = balls.reduce((acc,val)=>acc+val,0)/2;\\n        var startArray = new Array(k);\\n        startArray.fill(0);\\n        \\n        const perm = function(b1,b2)\\n        {\\n                var p1, p2, s1, s2;\\n                \\n                s1 =  b1.reduce((acc,val)=>acc+val,0);\\n                s2 =  b2.reduce((acc,val)=>acc+val,0);\\n                \\n                const fact = function(n)\\n                {\\n                        var f=1;\\n                        for(let i=2; i<=n; i++)\\n                                f *= i;\\n                        return  f;\\n                };\\n                \\n                p1 = fact(s1);\\n                p2 = fact(s2);\\n                \\n                b1.forEach(val=>{if(val>1)p1/=fact(val);});\\n                b2.forEach(val=>{if(val>1)p2/=fact(val);});\\n\\n                return p1*p2;\\n        };\\n        \\n        const getValidCombos = function(ballsUsed,colorNum=0)\\n        {\\n                var box1Used = ballsUsed.reduce((acc,val)=>acc+val,0);\\n                var matches = {good:0,total:0}, thisColorMax = halfUsed - box1Used;\\n\\n                if(colorNum === k-1)\\n                {\\n                        /* \\n                                Last ball color - adjust # of balls of this color to equal half\\n                                (if possible).  Then count # of different balls in each box.\\n                        */\\n                        if(thisColorMax > balls[colorNum])\\n                                return {good:0,total:0};\\n\\n                        ballsUsed[colorNum] = thisColorMax;\\n                        let ballsLeft = [];\\n                        let colorsUsed = [0,0];\\n                        for(let i=0; i<k; i++)\\n                        {\\n                                ballsLeft[i] = balls[i] - ballsUsed[i];\\n                                if(ballsUsed[i] > 0)\\n                                        colorsUsed[0]++;\\n                                if(ballsLeft[i] > 0)\\n                                        colorsUsed[1]++;\\n                        }\\n                        \\n                        /* Count the # of permutations for the boxes represented by this 1 combination. */\\n                        let permutations = perm(ballsUsed,ballsLeft,k);\\n                        return {good:(colorsUsed[1] === colorsUsed[0]) ? permutations : 0, total:permutations};\\n                }\\n\\n                thisColorMax = Math.min(thisColorMax,balls[colorNum]);\\n                for(let i=0; i<=thisColorMax; i++)\\n                {\\n                        let match = getValidCombos([...ballsUsed], colorNum+1);\\n                        matches = {good:matches.good+match.good, total:matches.total+match.total};\\n                        ballsUsed[colorNum]++;\\n                }\\n                return matches;\\n        }\\n    \\n        /* Probability = (total # of permutations with equal # of balls) / (permutations with same # of unique balls) */\\n        let res = getValidCombos(startArray);\\n        return res.good/res.total;\\n};\\n```",
                "solutionTags": [],
                "code": "```Pn = (# of balls in box n)!/((# of balls of 1st color)!(# of balls of 2nd color)! ... (# of balls of last color)!)```\n```\\n /**\\n * @param {number[]} balls\\n * @return {number}\\n */\\nvar getProbability = function(balls) \\n{\\n        var k = balls.length;\\n        var halfUsed = balls.reduce((acc,val)=>acc+val,0)/2;\\n        var startArray = new Array(k);\\n        startArray.fill(0);\\n        \\n        const perm = function(b1,b2)\\n        {\\n                var p1, p2, s1, s2;\\n                \\n                s1 =  b1.reduce((acc,val)=>acc+val,0);\\n                s2 =  b2.reduce((acc,val)=>acc+val,0);\\n                \\n                const fact = function(n)\\n                {\\n                        var f=1;\\n                        for(let i=2; i<=n; i++)\\n                                f *= i;\\n                        return  f;\\n                };\\n                \\n                p1 = fact(s1);\\n                p2 = fact(s2);\\n                \\n                b1.forEach(val=>{if(val>1)p1/=fact(val);});\\n                b2.forEach(val=>{if(val>1)p2/=fact(val);});\\n\\n                return p1*p2;\\n        };\\n        \\n        const getValidCombos = function(ballsUsed,colorNum=0)\\n        {\\n                var box1Used = ballsUsed.reduce((acc,val)=>acc+val,0);\\n                var matches = {good:0,total:0}, thisColorMax = halfUsed - box1Used;\\n\\n                if(colorNum === k-1)\\n                {\\n                        /* \\n                                Last ball color - adjust # of balls of this color to equal half\\n                                (if possible).  Then count # of different balls in each box.\\n                        */\\n                        if(thisColorMax > balls[colorNum])\\n                                return {good:0,total:0};\\n\\n                        ballsUsed[colorNum] = thisColorMax;\\n                        let ballsLeft = [];\\n                        let colorsUsed = [0,0];\\n                        for(let i=0; i<k; i++)\\n                        {\\n                                ballsLeft[i] = balls[i] - ballsUsed[i];\\n                                if(ballsUsed[i] > 0)\\n                                        colorsUsed[0]++;\\n                                if(ballsLeft[i] > 0)\\n                                        colorsUsed[1]++;\\n                        }\\n                        \\n                        /* Count the # of permutations for the boxes represented by this 1 combination. */\\n                        let permutations = perm(ballsUsed,ballsLeft,k);\\n                        return {good:(colorsUsed[1] === colorsUsed[0]) ? permutations : 0, total:permutations};\\n                }\\n\\n                thisColorMax = Math.min(thisColorMax,balls[colorNum]);\\n                for(let i=0; i<=thisColorMax; i++)\\n                {\\n                        let match = getValidCombos([...ballsUsed], colorNum+1);\\n                        matches = {good:matches.good+match.good, total:matches.total+match.total};\\n                        ballsUsed[colorNum]++;\\n                }\\n                return matches;\\n        }\\n    \\n        /* Probability = (total # of permutations with equal # of balls) / (permutations with same # of unique balls) */\\n        let res = getValidCombos(startArray);\\n        return res.good/res.total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 665033,
                "title": "java-solution-using-combinations-backtracking-dp",
                "content": "1) Use Back tracking to find all the possible combinations. For each combination find the favourable events.\\n2) Use Dp to store the factorials.\\n\\n```\\nclass Solution {\\n     double favEvents = 0,totalEvents = 0;\\n     double[] fact;\\n     int n =0;\\n    public double getProbability(int[] balls) {\\n        int[] ways = balls.clone();\\n        for(int i:balls)n+=i;\\n        fact = new double[n/2+1];\\n        \\n        factorial();\\n        findCombinations(balls,ways,0,0);\\n        return (favEvents)/(totalEvents);\\n    }\\n    \\n    public void findCombinations(int[] balls,int[] ways,int lev,int k){\\n        if(lev == n/2){\\n            int events1=0,events2=0;\\n            double f1 = fact[lev],f2 = fact[lev];\\n            for(int i=0;i<ways.length;i++){\\n                 if(balls[i]-ways[i] != 0){\\n                    events1++;\\n                    f1/=(fact[balls[i]-ways[i]]);\\n                }\\n                if(ways[i] !=0){\\n                  events2++;\\n                  f2/=fact[ways[i]];\\n                }\\n            }\\n                totalEvents+=f1*f2;\\n                if(events1 == events2) favEvents+=f1*f2;\\n        }\\n        else{\\n         for(int i=k;i<balls.length;i++){\\n            ways[i]--;\\n            findCombinations(balls,ways,lev+1,ways[i] == 0 ?i+1:i);\\n            ways[i]++;  \\n           }\\n        }\\n    }   \\n    \\n    public void factorial(){\\n        fact[0] = 1;\\n        for(int i=1;i<fact.length;i++) fact[i] = i*fact[i-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     double favEvents = 0,totalEvents = 0;\\n     double[] fact;\\n     int n =0;\\n    public double getProbability(int[] balls) {\\n        int[] ways = balls.clone();\\n        for(int i:balls)n+=i;\\n        fact = new double[n/2+1];\\n        \\n        factorial();\\n        findCombinations(balls,ways,0,0);\\n        return (favEvents)/(totalEvents);\\n    }\\n    \\n    public void findCombinations(int[] balls,int[] ways,int lev,int k){\\n        if(lev == n/2){\\n            int events1=0,events2=0;\\n            double f1 = fact[lev],f2 = fact[lev];\\n            for(int i=0;i<ways.length;i++){\\n                 if(balls[i]-ways[i] != 0){\\n                    events1++;\\n                    f1/=(fact[balls[i]-ways[i]]);\\n                }\\n                if(ways[i] !=0){\\n                  events2++;\\n                  f2/=fact[ways[i]];\\n                }\\n            }\\n                totalEvents+=f1*f2;\\n                if(events1 == events2) favEvents+=f1*f2;\\n        }\\n        else{\\n         for(int i=k;i<balls.length;i++){\\n            ways[i]--;\\n            findCombinations(balls,ways,lev+1,ways[i] == 0 ?i+1:i);\\n            ways[i]++;  \\n           }\\n        }\\n    }   \\n    \\n    public void factorial(){\\n        fact[0] = 1;\\n        for(int i=1;i<fact.length;i++) fact[i] = i*fact[i-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664837,
                "title": "java-dp-solution-beats-99",
                "content": "Idea is simple \\ndp[currentDistinctBall index][ distinct Ball in first box][distinct ball in second box][ ball to be filled in first box][ball to be filled in second box]\\n\\nso for currentDistinctBall index we fill \\n0 balls in first box balls[index] in second box // here the distinct in first remains same // in seconbox increase by1\\n1 balls in first box balls[index] -1 in second box// here the distinct in first and seconbox increase by1\\n.\\n.\\nballs[index] balls in first 0 in second box\\n\\nbecome is the code for function calculate which does this exactly\\n```\\nclass Solution {\\n    int[] balls;\\n    int n;\\n    Double dp[][][][][];\\n    Double ncrdp[][];\\n    \\n    public double getProbability(int[] balls) {\\n        this.balls = balls;\\n        int sum =0 ;\\n        \\n        for(int ball : balls) {\\n            sum = sum + ball;\\n        }\\n        n = sum/2;\\n        dp= new Double[9][balls.length][balls.length][n+1][n+1];\\n        ncrdp = new Double[sum+1][sum+1] ;\\n        double totalDistinctWays = fact(sum);\\n        for(int ball : balls) {\\n            totalDistinctWays = totalDistinctWays / fact(ball);\\n        }\\n        double possibleWaysWithCondition = calculate(0, 0, 0, n, n);\\n        return possibleWaysWithCondition/totalDistinctWays;\\n        \\n    }\\n    private double calculate(int index, int df, int ds, int firstBox, int secondBox) {\\n        // df is distinct element in first box\\n        // ds is distinct element in second box\\n        // firstBox is element to be filled in firstBox \\n        // secondBox is element to be filled in second box\\n        if (firstBox== 0 && secondBox ==0) {\\n            if (df == ds) return 1.0;\\n            else return 0;\\n        }\\n        if (firstBox < 0 || secondBox < 0) {\\n            return 0;\\n        }\\n        if (dp[index][df][ds][firstBox][secondBox] != null) return dp[index][df][ds][firstBox][secondBox];\\n        double ans = 0;\\n        for(int i = 0; i <= balls[index]; i++ ) {\\n         ans = ans +  nCr(secondBox, (balls[index] - i))* nCr(firstBox, i) * \\n             calculate(index+1,\\n                       df + (i > 0 ? 1 : 0),  \\n                       ds + ( (balls[index] - i) > 0 ? 1 : 0),\\n                       firstBox - i,\\n                       secondBox - (balls[index] - i));\\n        }\\n        dp[index][df][ds][firstBox][secondBox] = ans;\\n        return ans;\\n    }\\n  \\n    private double nCr(int n, int r) \\n    { \\n        if(ncrdp[n][r] != null) return ncrdp[n][r];\\n        ncrdp[n][r] =  fact(n) / (fact(r) * fact(n - r)); \\n        return ncrdp[n][r];\\n    } \\n\\n    private double fact(int n) \\n    { \\n        double res = 1; \\n        for (int i = 2; i <= n; i++) \\n            res = res * i; \\n        return res; \\n    } \\n} \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] balls;\\n    int n;\\n    Double dp[][][][][];\\n    Double ncrdp[][];\\n    \\n    public double getProbability(int[] balls) {\\n        this.balls = balls;\\n        int sum =0 ;\\n        \\n        for(int ball : balls) {\\n            sum = sum + ball;\\n        }\\n        n = sum/2;\\n        dp= new Double[9][balls.length][balls.length][n+1][n+1];\\n        ncrdp = new Double[sum+1][sum+1] ;\\n        double totalDistinctWays = fact(sum);\\n        for(int ball : balls) {\\n            totalDistinctWays = totalDistinctWays / fact(ball);\\n        }\\n        double possibleWaysWithCondition = calculate(0, 0, 0, n, n);\\n        return possibleWaysWithCondition/totalDistinctWays;\\n        \\n    }\\n    private double calculate(int index, int df, int ds, int firstBox, int secondBox) {\\n        // df is distinct element in first box\\n        // ds is distinct element in second box\\n        // firstBox is element to be filled in firstBox \\n        // secondBox is element to be filled in second box\\n        if (firstBox== 0 && secondBox ==0) {\\n            if (df == ds) return 1.0;\\n            else return 0;\\n        }\\n        if (firstBox < 0 || secondBox < 0) {\\n            return 0;\\n        }\\n        if (dp[index][df][ds][firstBox][secondBox] != null) return dp[index][df][ds][firstBox][secondBox];\\n        double ans = 0;\\n        for(int i = 0; i <= balls[index]; i++ ) {\\n         ans = ans +  nCr(secondBox, (balls[index] - i))* nCr(firstBox, i) * \\n             calculate(index+1,\\n                       df + (i > 0 ? 1 : 0),  \\n                       ds + ( (balls[index] - i) > 0 ? 1 : 0),\\n                       firstBox - i,\\n                       secondBox - (balls[index] - i));\\n        }\\n        dp[index][df][ds][firstBox][secondBox] = ans;\\n        return ans;\\n    }\\n  \\n    private double nCr(int n, int r) \\n    { \\n        if(ncrdp[n][r] != null) return ncrdp[n][r];\\n        ncrdp[n][r] =  fact(n) / (fact(r) * fact(n - r)); \\n        return ncrdp[n][r];\\n    } \\n\\n    private double fact(int n) \\n    { \\n        double res = 1; \\n        for (int i = 2; i <= n; i++) \\n            res = res * i; \\n        return res; \\n    } \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 664036,
                "title": "dfs-memo-c",
                "content": "Consider every ball as different, for example, color 1 has two balls, these two are different, 1(a) and 1(b), divide these balls to two boxes, don\\'t consider the order of balls in each box. Each ball has two choices, in box1 or in box2. For the returned pair, the first is the valid numbers, the second is the total numbers.\\n```c++\\nclass Solution {\\npublic:\\n    #define LL long long\\n    int sum;\\n    unordered_map<int,unordered_map<int,pair<LL,LL>>> memo[50][25];\\n    double getProbability(vector<int>& balls) {\\n        vector<int> vs;\\n        for(int i=0;i<balls.size();i++){\\n            sum+=balls[i];\\n            int cnt=balls[i];\\n            for(int j=0;j<cnt;j++){\\n                vs.push_back(i);\\n            }\\n        }\\n        auto ret=dfs(0,vs,0,0,0);\\n        return 1.0*ret.first/ret.second;\\n    }\\n    pair<LL,LL> dfs(int idx, vector<int>& vs, int cnt1, int box1, int box2){  //box1 and box2 record the colors we have in each box, cnt1 is the numbers of balls in box1\\n        if(cnt1>sum/2 || idx-cnt1>sum/2) return {0,0};\\n        if(idx==vs.size()){\\n            int tmp1=0;\\n            int tmp2=0;\\n            for(int i=0;i<8;i++){\\n                if((box1&(1<<i))!=0) tmp1++;\\n            }\\n            for(int i=0;i<8;i++){\\n                if((box2&(1<<i))!=0) tmp2++;\\n            }\\n            if(tmp1==tmp2) return {1,1};\\n            else return {0,1};\\n        }\\n        if(memo[idx][cnt1].find(box1)!=memo[idx][cnt1].end() && memo[idx][cnt1][box1].find(box2)!=memo[idx][cnt1][box1].end()) return memo[idx][cnt1][box1][box2];\\n        int col=vs[idx];\\n        auto a1=dfs(idx+1,vs,cnt1+1,box1|(1<<col),box2);\\n        auto a2=dfs(idx+1,vs,cnt1,box1, box2|(1<<col));\\n        return memo[idx][cnt1][box1][box2]= {a1.first+a2.first,a1.second+a2.second};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    #define LL long long\\n    int sum;\\n    unordered_map<int,unordered_map<int,pair<LL,LL>>> memo[50][25];\\n    double getProbability(vector<int>& balls) {\\n        vector<int> vs;\\n        for(int i=0;i<balls.size();i++){\\n            sum+=balls[i];\\n            int cnt=balls[i];\\n            for(int j=0;j<cnt;j++){\\n                vs.push_back(i);\\n            }\\n        }\\n        auto ret=dfs(0,vs,0,0,0);\\n        return 1.0*ret.first/ret.second;\\n    }\\n    pair<LL,LL> dfs(int idx, vector<int>& vs, int cnt1, int box1, int box2){  //box1 and box2 record the colors we have in each box, cnt1 is the numbers of balls in box1\\n        if(cnt1>sum/2 || idx-cnt1>sum/2) return {0,0};\\n        if(idx==vs.size()){\\n            int tmp1=0;\\n            int tmp2=0;\\n            for(int i=0;i<8;i++){\\n                if((box1&(1<<i))!=0) tmp1++;\\n            }\\n            for(int i=0;i<8;i++){\\n                if((box2&(1<<i))!=0) tmp2++;\\n            }\\n            if(tmp1==tmp2) return {1,1};\\n            else return {0,1};\\n        }\\n        if(memo[idx][cnt1].find(box1)!=memo[idx][cnt1].end() && memo[idx][cnt1][box1].find(box2)!=memo[idx][cnt1][box1].end()) return memo[idx][cnt1][box1][box2];\\n        int col=vs[idx];\\n        auto a1=dfs(idx+1,vs,cnt1+1,box1|(1<<col),box2);\\n        auto a2=dfs(idx+1,vs,cnt1,box1, box2|(1<<col));\\n        return memo[idx][cnt1][box1][box2]= {a1.first+a2.first,a1.second+a2.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663852,
                "title": "tle-on-6-6-6-6-6-6-can-anyone-help-in-improving-the-code-efficiency",
                "content": "\\n```\\n double getProbability(vector<int>& balls) {\\n        int n = balls.size();\\n        vector<int> nums;\\n        // generate the all balls array in sorted fashion.\\n        for(int i = 0; i < n; i++){\\n            int a = balls[i];\\n            while(a){\\n                nums.push_back(i + 1);\\n                a--;\\n            }\\n        }\\n        \\n        double total = 0;\\n        double favorable = 0;\\n        int p = nums.size();\\n        \\n        // generate all permutaion. See which permutaion has equal colors.\\n    do {\\n        map<int, int> m1;\\n        map<int, int> m2;\\n        for(int i = 0; i < p / 2; i++){\\n            m1[nums[i]]++;\\n        }\\n        for(int i = p / 2; i < p; i++){\\n            m2[nums[i]]++;\\n        }\\n        \\n        if(m1.size() == m2.size())favorable++;\\n        total++;\\n   \\n    } while (next_permutation(nums.begin(),nums.end()) );\\n       \\n        // final answer.\\n        return (favorable / total);\\n    }",
                "solutionTags": [],
                "code": "\\n```\\n double getProbability(vector<int>& balls) {\\n        int n = balls.size();\\n        vector<int> nums;\\n        // generate the all balls array in sorted fashion.\\n        for(int i = 0; i < n; i++){\\n            int a = balls[i];\\n            while(a){\\n                nums.push_back(i + 1);\\n                a--;\\n            }\\n        }\\n        \\n        double total = 0;\\n        double favorable = 0;\\n        int p = nums.size();\\n        \\n        // generate all permutaion. See which permutaion has equal colors.\\n    do {\\n        map<int, int> m1;\\n        map<int, int> m2;\\n        for(int i = 0; i < p / 2; i++){\\n            m1[nums[i]]++;\\n        }\\n        for(int i = p / 2; i < p; i++){\\n            m2[nums[i]]++;\\n        }\\n        \\n        if(m1.size() == m2.size())favorable++;\\n        total++;\\n   \\n    } while (next_permutation(nums.begin(),nums.end()) );\\n       \\n        // final answer.\\n        return (favorable / total);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 663645,
                "title": "python-dfs-backtracking",
                "content": "1. pre-compute factorial.\\n2. treat input balls array as right half. \\n3. take balls from right half and put in left half.\\n4. calculate combinations when balls in left half and right half are equal.\\n\\n```\\nt = 0\\nr = 0\\nhc = 0\\n# backtracking\\ndef getProbability(self, balls: List[int]) -> float:\\n\\n\\tla = [0 for i in range(len(balls))]\\n\\tself.hc = self.fact[sum(balls)//2]\\n\\n\\tself.backtracking(0, sum(balls)//2, la, balls)\\n\\n\\treturn self.r/self.t\\n\\n\\ndef backtracking(self, i, lc, la, ra):\\n\\n\\tif lc == 0:\\n\\n\\t\\tlu = ru = 0\\n\\t\\tld = rd = 1\\n\\t\\tfor j in range(len(la)):\\n\\n\\t\\t\\tif la[j] > 0:\\n\\t\\t\\t\\tlu += 1\\n\\t\\t\\t\\tld *= self.fact[la[j]]\\n\\n\\t\\t\\tif ra[j] > 0:\\n\\t\\t\\t\\tru += 1\\n\\t\\t\\t\\trd *= self.fact[ra[j]]\\n\\n\\t\\tcmb = (self.hc/ld)*(self.hc/rd)\\n\\t\\tself.t += cmb\\n\\n\\t\\tif lu == ru:\\n\\t\\t\\tself.r += cmb\\n\\n\\telif lc > 0 and i < len(ra):\\n\\t\\tfor k in range(ra[i]+1):\\n\\n\\t\\t\\tlc -= k; la[i] = k; ra[i] -= k\\n\\t\\t\\tself.backtracking(i+1, lc, la, ra)\\n\\t\\t\\tlc += k; la[i] = 0; ra[i] += k\\n\\n\\n#up to 4*6=24\\nfact = [\\n\\t0\\n\\t,1\\n\\t,2\\n\\t,6\\n\\t,24\\n\\t,120\\n\\t,720\\n\\t,5040\\n\\t,40320\\n\\t,362880\\n\\t,3628800\\n\\t,39916800\\n\\t,479001600\\n\\t,6227020800\\n\\t,87178291200\\n\\t,1307674368000\\n\\t,20922789888000\\n\\t,355687428096000\\n\\t,6402373705728000\\n\\t,121645100408832000\\n\\t,2432902008176640000\\n\\t,51090942171709440000\\n\\t,1124000727777607680000\\n\\t,25852016738884976640000\\n\\t,620448401733239439360000\\n]\\n```",
                "solutionTags": [],
                "code": "```\\nt = 0\\nr = 0\\nhc = 0\\n# backtracking\\ndef getProbability(self, balls: List[int]) -> float:\\n\\n\\tla = [0 for i in range(len(balls))]\\n\\tself.hc = self.fact[sum(balls)//2]\\n\\n\\tself.backtracking(0, sum(balls)//2, la, balls)\\n\\n\\treturn self.r/self.t\\n\\n\\ndef backtracking(self, i, lc, la, ra):\\n\\n\\tif lc == 0:\\n\\n\\t\\tlu = ru = 0\\n\\t\\tld = rd = 1\\n\\t\\tfor j in range(len(la)):\\n\\n\\t\\t\\tif la[j] > 0:\\n\\t\\t\\t\\tlu += 1\\n\\t\\t\\t\\tld *= self.fact[la[j]]\\n\\n\\t\\t\\tif ra[j] > 0:\\n\\t\\t\\t\\tru += 1\\n\\t\\t\\t\\trd *= self.fact[ra[j]]\\n\\n\\t\\tcmb = (self.hc/ld)*(self.hc/rd)\\n\\t\\tself.t += cmb\\n\\n\\t\\tif lu == ru:\\n\\t\\t\\tself.r += cmb\\n\\n\\telif lc > 0 and i < len(ra):\\n\\t\\tfor k in range(ra[i]+1):\\n\\n\\t\\t\\tlc -= k; la[i] = k; ra[i] -= k\\n\\t\\t\\tself.backtracking(i+1, lc, la, ra)\\n\\t\\t\\tlc += k; la[i] = 0; ra[i] += k\\n\\n\\n#up to 4*6=24\\nfact = [\\n\\t0\\n\\t,1\\n\\t,2\\n\\t,6\\n\\t,24\\n\\t,120\\n\\t,720\\n\\t,5040\\n\\t,40320\\n\\t,362880\\n\\t,3628800\\n\\t,39916800\\n\\t,479001600\\n\\t,6227020800\\n\\t,87178291200\\n\\t,1307674368000\\n\\t,20922789888000\\n\\t,355687428096000\\n\\t,6402373705728000\\n\\t,121645100408832000\\n\\t,2432902008176640000\\n\\t,51090942171709440000\\n\\t,1124000727777607680000\\n\\t,25852016738884976640000\\n\\t,620448401733239439360000\\n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 663637,
                "title": "python3-dfs-with-backtracking-90",
                "content": "```\\nclass Solution:\\n    def getProbability(self, b: List[int]) -> float:\\n        # virtually move ball[i] from pool to right, decrease pool, decrease avail right boxes\\n        def dfs(i, r_p, r_l, uniq_r_sum, uniq_l_sum):\\n            if r_l == 0:\\n                return uniq_r_sum == uniq_l_sum, 1\\n            sr, snr = 0, 0\\n            js = range(max(0, r_l-(r_p-b[i])), # to prevent having extra boxes\\n                       min(b[i], r_l)+1) # to prevent having extra balls\\n            for j in js:\\n                nCk = comb(b[i], j)\\n                r, nr = dfs(i+1, \\n                            r_p - b[i],\\n                            r_l - j,\\n                            uniq_r_sum - (j == b[i]),\\n                            uniq_l_sum + (j > 0))\\n                sr, snr = sr+r*nCk, snr+nr*nCk\\n            return sr, snr\\n        num, den = dfs(0, sum(b), sum(b)//2, len(b), 0)\\n        return num/den\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getProbability(self, b: List[int]) -> float:\\n        # virtually move ball[i] from pool to right, decrease pool, decrease avail right boxes\\n        def dfs(i, r_p, r_l, uniq_r_sum, uniq_l_sum):\\n            if r_l == 0:\\n                return uniq_r_sum == uniq_l_sum, 1\\n            sr, snr = 0, 0\\n            js = range(max(0, r_l-(r_p-b[i])), # to prevent having extra boxes\\n                       min(b[i], r_l)+1) # to prevent having extra balls\\n            for j in js:\\n                nCk = comb(b[i], j)\\n                r, nr = dfs(i+1, \\n                            r_p - b[i],\\n                            r_l - j,\\n                            uniq_r_sum - (j == b[i]),\\n                            uniq_l_sum + (j > 0))\\n                sr, snr = sr+r*nCk, snr+nr*nCk\\n            return sr, snr\\n        num, den = dfs(0, sum(b), sum(b)//2, len(b), 0)\\n        return num/den\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663542,
                "title": "",
                "content": "rt\\n\\n\\n```\\ndouble getProbability_(int idx, int sumVal, string& t, string& s, unordered_map<string, double>& m) {\\n\\n\\tif (m.count(s)) return m[s];\\n\\n\\tif (idx >= sumVal) {\\n\\t\\tint color1 = 0, color2 = 0;\\n\\t\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\t\\tif (s[i] > \\'0\\') ++color1;\\n\\t\\t\\tif (t[i] - s[i] > 0) ++color2;\\n\\t\\t}\\n\\t\\tm[s] = (double)(color1 == color2);\\n\\t\\treturn m[s];\\n\\t}\\n\\n\\tdouble res = 0;\\n\\tdouble totalBall = 0;\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\ttotalBall += (t[i] - s[i]);\\n\\t}\\n\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\tif (t[i] - s[i] > 0) {\\n\\t\\t\\tdouble p = t[i] - s[i];\\n\\t\\t\\t++s[i];\\n\\t\\t\\tres += p/totalBall * getProbability_(idx + 1, sumVal, t, s, m);\\n\\t\\t\\t--s[i];\\n\\t\\t}\\n\\t}\\n\\n\\tm[s] = res;\\n\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\tfor (int j = i + 1; j < t.length(); ++j) {\\n\\t\\t\\tif (t[i] == t[j]) {\\n\\t\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t\\t\\tm[s] = res;\\n\\t\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\ndouble getProbability(vector<int>& balls) {\\n\\n\\tstring t = \"\", s = \"\";\\n\\tunordered_map<string, double> m;\\n\\tfor (int i = 0; i < balls.size(); ++i) {\\n\\t\\tt.push_back(balls[i] + \\'0\\');\\n\\t\\ts.push_back(\\'0\\');\\n\\t}\\n\\n\\tint sumVal = 0;\\n\\tfor (int& ball : balls) sumVal += ball;\\n\\tsumVal /= 2;\\n\\treturn getProbability_(0, sumVal, t, s, m);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble getProbability_(int idx, int sumVal, string& t, string& s, unordered_map<string, double>& m) {\\n\\n\\tif (m.count(s)) return m[s];\\n\\n\\tif (idx >= sumVal) {\\n\\t\\tint color1 = 0, color2 = 0;\\n\\t\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\t\\tif (s[i] > \\'0\\') ++color1;\\n\\t\\t\\tif (t[i] - s[i] > 0) ++color2;\\n\\t\\t}\\n\\t\\tm[s] = (double)(color1 == color2);\\n\\t\\treturn m[s];\\n\\t}\\n\\n\\tdouble res = 0;\\n\\tdouble totalBall = 0;\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\ttotalBall += (t[i] - s[i]);\\n\\t}\\n\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\tif (t[i] - s[i] > 0) {\\n\\t\\t\\tdouble p = t[i] - s[i];\\n\\t\\t\\t++s[i];\\n\\t\\t\\tres += p/totalBall * getProbability_(idx + 1, sumVal, t, s, m);\\n\\t\\t\\t--s[i];\\n\\t\\t}\\n\\t}\\n\\n\\tm[s] = res;\\n\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\tfor (int j = i + 1; j < t.length(); ++j) {\\n\\t\\t\\tif (t[i] == t[j]) {\\n\\t\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t\\t\\tm[s] = res;\\n\\t\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\ndouble getProbability(vector<int>& balls) {\\n\\n\\tstring t = \"\", s = \"\";\\n\\tunordered_map<string, double> m;\\n\\tfor (int i = 0; i < balls.size(); ++i) {\\n\\t\\tt.push_back(balls[i] + \\'0\\');\\n\\t\\ts.push_back(\\'0\\');\\n\\t}\\n\\n\\tint sumVal = 0;\\n\\tfor (int& ball : balls) sumVal += ball;\\n\\tsumVal /= 2;\\n\\treturn getProbability_(0, sumVal, t, s, m);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 663539,
                "title": "simple-c-code-using-backtrace-beat-100-56ms-no-math-required",
                "content": "```\\ndouble getProbability_(int idx, int sumVal, string& t, string& s, unordered_map<string, double>& m) {\\n\\n\\tif (m.count(s)) return m[s];\\n\\n\\tif (idx >= sumVal) {\\n\\t\\tint color1 = 0, color2 = 0;\\n\\t\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\t\\tif (s[i] > \\'0\\') ++color1;\\n\\t\\t\\tif (t[i] - s[i] > 0) ++color2;\\n\\t\\t}\\n\\t\\tm[s] = (double)(color1 == color2);\\n\\t\\treturn m[s];\\n\\t}\\n\\n\\tdouble res = 0;\\n\\tdouble totalBall = 0;\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\ttotalBall += (t[i] - s[i]);\\n\\t}\\n\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\tif (t[i] - s[i] > 0) {\\n\\t\\t\\tdouble p = t[i] - s[i];\\n\\t\\t\\t++s[i];\\n\\t\\t\\tres += p/totalBall * getProbability_(idx + 1, sumVal, t, s, m);\\n\\t\\t\\t--s[i];\\n\\t\\t}\\n\\t}\\n\\n\\tm[s] = res;\\n\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\tfor (int j = i + 1; j < t.length(); ++j) {\\n\\t\\t\\tif (t[i] == t[j]) {\\n\\t\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t\\t\\tm[s] = res;\\n\\t\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\ndouble getProbability(vector<int>& balls) {\\n\\n\\tstring t = \"\", s = \"\";\\n\\tunordered_map<string, double> m;\\n\\tfor (int i = 0; i < balls.size(); ++i) {\\n\\t\\tt.push_back(balls[i] + \\'0\\');\\n\\t\\ts.push_back(\\'0\\');\\n\\t}\\n\\n\\tint sumVal = 0;\\n\\tfor (int& ball : balls) sumVal += ball;\\n\\tsumVal /= 2;\\n\\treturn getProbability_(0, sumVal, t, s, m);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble getProbability_(int idx, int sumVal, string& t, string& s, unordered_map<string, double>& m) {\\n\\n\\tif (m.count(s)) return m[s];\\n\\n\\tif (idx >= sumVal) {\\n\\t\\tint color1 = 0, color2 = 0;\\n\\t\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\t\\tif (s[i] > \\'0\\') ++color1;\\n\\t\\t\\tif (t[i] - s[i] > 0) ++color2;\\n\\t\\t}\\n\\t\\tm[s] = (double)(color1 == color2);\\n\\t\\treturn m[s];\\n\\t}\\n\\n\\tdouble res = 0;\\n\\tdouble totalBall = 0;\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\ttotalBall += (t[i] - s[i]);\\n\\t}\\n\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\tif (t[i] - s[i] > 0) {\\n\\t\\t\\tdouble p = t[i] - s[i];\\n\\t\\t\\t++s[i];\\n\\t\\t\\tres += p/totalBall * getProbability_(idx + 1, sumVal, t, s, m);\\n\\t\\t\\t--s[i];\\n\\t\\t}\\n\\t}\\n\\n\\tm[s] = res;\\n\\n\\tfor (int i = 0; i < t.length(); ++i) {\\n\\t\\tfor (int j = i + 1; j < t.length(); ++j) {\\n\\t\\t\\tif (t[i] == t[j]) {\\n\\t\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t\\t\\tm[s] = res;\\n\\t\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\ndouble getProbability(vector<int>& balls) {\\n\\n\\tstring t = \"\", s = \"\";\\n\\tunordered_map<string, double> m;\\n\\tfor (int i = 0; i < balls.size(); ++i) {\\n\\t\\tt.push_back(balls[i] + \\'0\\');\\n\\t\\ts.push_back(\\'0\\');\\n\\t}\\n\\n\\tint sumVal = 0;\\n\\tfor (int& ball : balls) sumVal += ball;\\n\\tsumVal /= 2;\\n\\treturn getProbability_(0, sumVal, t, s, m);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 663306,
                "title": "36ms-python-take-advantage-of-recursion-no-permutation-no-binomial-coefficient",
                "content": "A key step here is that to realize that to choose a permutation uniformly from all permutations, is the same thing as the following procedure: Suppose there are 2n slots for the permutation, iterate over all balls, for each ball, randomly put it in one of the available slots with the same probability, once a slot is occupied, it is not available for the following balls.\\n\\nThen, helper(i, cur, num1, num2) computes the probability that array1 has num1 slots occupied, array2 has num2 slots occupied, and we are at the i-th color, we want to compute the probability that array 1 has cur number of colors more than array 2.\\n\\nThe recursion is easy, for the balls[i] number of i-th colored balls, you can either put them all in array1, then array1 has one more color than array2, so cur -= 1, then compute helper(i+1, cur - 1, num1 + m, num2), similarly you can put them all in array2. Or you can split then, put j in array1, put m - j in array2, this way cur doesn\\'t change.\\n\\nIt all boils down to compute prob(total, give, num1, num2) which means you have total number of balls, array1 has num1 available slots, array2 has num2 available slots, what is the probability that you put give number of balls in array1. You can compute it in terms of binomial coefficient, but you can also consider where the first ball go to, and create another recursion.\\n\\n\\'\\'\\'\\nfrom functools import lru_cache\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        k = len(balls)\\n        n = sum(balls)//2\\n        pre = [0]\\n        for b in balls:\\n            pre.append(pre[-1] + b)\\n            \\n        @lru_cache(None)\\n        def prob(total, give, num1, num2):\\n            if total == 0:\\n                return int(give == 0)\\n            if give > num1 or total -give > num2:\\n                return 0\\n            return prob(total - 1, give - 1, num1 - 1, num2)*(num1/(num1 + num2)) + prob(total - 1, give, num1, num2 - 1)*(num2/(num1 + num2))\\n        \\n        \\n        \\n        @lru_cache(None)\\n        def helper(i = 0, cur = 0, num1 = 0): # cur = need number 1st - 2nd disintct colors\\n            num2 = pre[i] - num1\\n            if num1 == n:\\n                return int(k - i == -cur)\\n            if num2 == n:\\n                return int(k - i == cur)\\n            if i == k:\\n                return int(cur == 0)\\n            \\n            m = balls[i]\\n            ans = p1 = p2 = 0\\n            if num1 + m <= n:\\n                p1 = prob(m,m, n - num1, n - num2)\\n                ans += p1*helper(i + 1, cur - 1, num1 + m)\\n            if num2 + m <= n:\\n                p2 = prob(m,0, n - num1, n - num2)\\n                ans+= p2*helper(i + 1, cur + 1, num1)\\n            for j in range(1, m):\\n                ans += prob(m, j,n - num1,n - num2)*helper(i + 1, cur, num1 + j)\\n            return ans\\n        return helper()\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "A key step here is that to realize that to choose a permutation uniformly from all permutations, is the same thing as the following procedure: Suppose there are 2n slots for the permutation, iterate over all balls, for each ball, randomly put it in one of the available slots with the same probability, once a slot is occupied, it is not available for the following balls.\\n\\nThen, helper(i, cur, num1, num2) computes the probability that array1 has num1 slots occupied, array2 has num2 slots occupied, and we are at the i-th color, we want to compute the probability that array 1 has cur number of colors more than array 2.\\n\\nThe recursion is easy, for the balls[i] number of i-th colored balls, you can either put them all in array1, then array1 has one more color than array2, so cur -= 1, then compute helper(i+1, cur - 1, num1 + m, num2), similarly you can put them all in array2. Or you can split then, put j in array1, put m - j in array2, this way cur doesn\\'t change.\\n\\nIt all boils down to compute prob(total, give, num1, num2) which means you have total number of balls, array1 has num1 available slots, array2 has num2 available slots, what is the probability that you put give number of balls in array1. You can compute it in terms of binomial coefficient, but you can also consider where the first ball go to, and create another recursion.\\n\\n\\'\\'\\'\\nfrom functools import lru_cache\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        k = len(balls)\\n        n = sum(balls)//2\\n        pre = [0]\\n        for b in balls:\\n            pre.append(pre[-1] + b)\\n            \\n        @lru_cache(None)\\n        def prob(total, give, num1, num2):\\n            if total == 0:\\n                return int(give == 0)\\n            if give > num1 or total -give > num2:\\n                return 0\\n            return prob(total - 1, give - 1, num1 - 1, num2)*(num1/(num1 + num2)) + prob(total - 1, give, num1, num2 - 1)*(num2/(num1 + num2))\\n        \\n        \\n        \\n        @lru_cache(None)\\n        def helper(i = 0, cur = 0, num1 = 0): # cur = need number 1st - 2nd disintct colors\\n            num2 = pre[i] - num1\\n            if num1 == n:\\n                return int(k - i == -cur)\\n            if num2 == n:\\n                return int(k - i == cur)\\n            if i == k:\\n                return int(cur == 0)\\n            \\n            m = balls[i]\\n            ans = p1 = p2 = 0\\n            if num1 + m <= n:\\n                p1 = prob(m,m, n - num1, n - num2)\\n                ans += p1*helper(i + 1, cur - 1, num1 + m)\\n            if num2 + m <= n:\\n                p2 = prob(m,0, n - num1, n - num2)\\n                ans+= p2*helper(i + 1, cur + 1, num1)\\n            for j in range(1, m):\\n                ans += prob(m, j,n - num1,n - num2)*helper(i + 1, cur, num1 + j)\\n            return ans\\n        return helper()\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 663211,
                "title": "java-iterative-dp-fast-3-4-ms-as-of-2020-05-31",
                "content": "```\\nclass Solution {\\n    public double getProbability(int[] balls) {\\n        int k = balls.length; // number of types\\n        int n = 0;            // number of balls\\n        for(int c: balls) n += c;\\n        \\n        double[][][] dp = new double[1][1][1]; // first index is the number of balls in first box\\n                                               // second index is the number of types in first box\\n                                               // third index is the number of types in second box\\n        dp[0][0][0] = 1;\\n        \\n        // binomial coefficients. Pre-compute for performance\\n        long[][] C = new long[n+1][n+1];\\n        for(int i = 0; i <= n; i++) {\\n            C[i][0] = 1; C[i][i] = 1;\\n        }\\n        \\n        for(int i = 2; i <= n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                C[i][j] = C[i-1][j-1] + C[i-1][j];\\n            }\\n        }\\n\\n        int total = 0;\\n        for(int i = 0; i < k; i++) {\\n            int cnt = balls[i];\\n            total += cnt;\\n            double[][][] tmp = new double[total+1][i+2][i+2];\\n            for(int p = 0; p <= cnt; p++) {\\n                // p is the number of balls that are added to the first box\\n                for(int a = p; a <= total; a++) {\\n                    // a is the number of balls in the first box afterwards\\n                    for(int b = 0; b <= i+1; b++) {\\n                        // b is the number of types in the first box afterwards\\n                        for(int c = 0; c <= i+1; c++) {\\n                            // c is the number of types in the second box afterwards\\n                            int pa = a - p; // previous count of balls in the first box\\n                            int pb = b - (p == 0 ? 0 : 1); // previous number of types in the first box\\n                            int pc = c - (p == cnt ? 0 : 1); // previous number of types in the second box\\n                            if (pb < 0 || pc < 0 || pb > i || pc > i || pa > total - cnt) continue;\\n                            \\n                            tmp[a][b][c] += dp[pa][pb][pc] * C[a][p] * C[total - a][cnt - p];\\n                        }\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        \\n        double totalCases = 0;\\n        double validCases = 0;\\n        int h = n / 2;\\n        for(int i = 0; i <= k; i++) {\\n            for(int j = 0; j <= k; j++) {\\n                totalCases += dp[h][i][j];\\n                if (i == j) validCases += dp[h][i][j];\\n            }\\n        }\\n        return validCases / totalCases;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double getProbability(int[] balls) {\\n        int k = balls.length; // number of types\\n        int n = 0;            // number of balls\\n        for(int c: balls) n += c;\\n        \\n        double[][][] dp = new double[1][1][1]; // first index is the number of balls in first box\\n                                               // second index is the number of types in first box\\n                                               // third index is the number of types in second box\\n        dp[0][0][0] = 1;\\n        \\n        // binomial coefficients. Pre-compute for performance\\n        long[][] C = new long[n+1][n+1];\\n        for(int i = 0; i <= n; i++) {\\n            C[i][0] = 1; C[i][i] = 1;\\n        }\\n        \\n        for(int i = 2; i <= n; i++) {\\n            for(int j = 1; j < n; j++) {\\n                C[i][j] = C[i-1][j-1] + C[i-1][j];\\n            }\\n        }\\n\\n        int total = 0;\\n        for(int i = 0; i < k; i++) {\\n            int cnt = balls[i];\\n            total += cnt;\\n            double[][][] tmp = new double[total+1][i+2][i+2];\\n            for(int p = 0; p <= cnt; p++) {\\n                // p is the number of balls that are added to the first box\\n                for(int a = p; a <= total; a++) {\\n                    // a is the number of balls in the first box afterwards\\n                    for(int b = 0; b <= i+1; b++) {\\n                        // b is the number of types in the first box afterwards\\n                        for(int c = 0; c <= i+1; c++) {\\n                            // c is the number of types in the second box afterwards\\n                            int pa = a - p; // previous count of balls in the first box\\n                            int pb = b - (p == 0 ? 0 : 1); // previous number of types in the first box\\n                            int pc = c - (p == cnt ? 0 : 1); // previous number of types in the second box\\n                            if (pb < 0 || pc < 0 || pb > i || pc > i || pa > total - cnt) continue;\\n                            \\n                            tmp[a][b][c] += dp[pa][pb][pc] * C[a][p] * C[total - a][cnt - p];\\n                        }\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        \\n        double totalCases = 0;\\n        double validCases = 0;\\n        int h = n / 2;\\n        for(int i = 0; i <= k; i++) {\\n            for(int j = 0; j <= k; j++) {\\n                totalCases += dp[h][i][j];\\n                if (i == j) validCases += dp[h][i][j];\\n            }\\n        }\\n        return validCases / totalCases;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663145,
                "title": "python-90-run-time-and-100-memory",
                "content": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        \\n        self.total = 0\\n        self.good = 0\\n\\n        self.n = len(balls)\\n        self.sum = sum(balls)\\n\\n        def dfs(i,box1,box2,color1,color2,left,right):\\n            \"\"\"\\n            \\n            i - current color of the ball\\n            box1 - total number of balls in box1\\n            box2 - total number of balls in box2\\n            color1 - total number of unqiue balls in box1\\n            color2 - total number of unique balls in box2\\n            left - total number of redundant arrangement in box1\\n            right - total number of redundant arrangement in box2\\n            \\n            \"\"\"\\n            # if remaining number of elements is not enough to cover the difference then cancel\\n            if abs(box1-box2) > self.sum - box1 -box2: return \\n            #if we have reached the end of the elements\\n            if i == self.n:\\n                #elements should be divided equally - 2n \\n                if box1 != box2: return\\n                # permutation(p1) * permutation(p2)\\n                p12 = math.factorial(box1)/left * math.factorial(box2)/right\\n                #adding the total permutation possible\\n                self.total = self.total + p12\\n                #permutation for which colors are equal\\n                self.good = self.good + p12 * (color1 == color2)\\n            else:\\n                # loop through the elements for all the possible distribution of a certain color of the ball\\n                for c in range(balls[i]+1):\\n                    \"\"\"\\n                    c -> number of balls added to box1\\n                    balls[i] - c -> number of balls added to box2\\n                    \\n                    if c is not 0 -> increment colors1 by 1\\n                    if balls[i] - c is not 0 -> increment colors2 by 1\\n                    \"\"\"\\n                    dfs(i+1,\\n                        box1 + c,\\n                        box2 + balls[i] -c,\\n                        color1+(c!=0),\\n                        color2+(c!=balls[i]),\\n                        left*math.factorial(c),\\n                        right*math.factorial(balls[i]-c))\\n\\n\\n        dfs(0,0,0,0,0,1,1)\\n        return round(self.good/self.total,5)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        \\n        self.total = 0\\n        self.good = 0\\n\\n        self.n = len(balls)\\n        self.sum = sum(balls)\\n\\n        def dfs(i,box1,box2,color1,color2,left,right):\\n            \"\"\"\\n            \\n            i - current color of the ball\\n            box1 - total number of balls in box1\\n            box2 - total number of balls in box2\\n            color1 - total number of unqiue balls in box1\\n            color2 - total number of unique balls in box2\\n            left - total number of redundant arrangement in box1\\n            right - total number of redundant arrangement in box2\\n            \\n            \"\"\"\\n            # if remaining number of elements is not enough to cover the difference then cancel\\n            if abs(box1-box2) > self.sum - box1 -box2: return \\n            #if we have reached the end of the elements\\n            if i == self.n:\\n                #elements should be divided equally - 2n \\n                if box1 != box2: return\\n                # permutation(p1) * permutation(p2)\\n                p12 = math.factorial(box1)/left * math.factorial(box2)/right\\n                #adding the total permutation possible\\n                self.total = self.total + p12\\n                #permutation for which colors are equal\\n                self.good = self.good + p12 * (color1 == color2)\\n            else:\\n                # loop through the elements for all the possible distribution of a certain color of the ball\\n                for c in range(balls[i]+1):\\n                    \"\"\"\\n                    c -> number of balls added to box1\\n                    balls[i] - c -> number of balls added to box2\\n                    \\n                    if c is not 0 -> increment colors1 by 1\\n                    if balls[i] - c is not 0 -> increment colors2 by 1\\n                    \"\"\"\\n                    dfs(i+1,\\n                        box1 + c,\\n                        box2 + balls[i] -c,\\n                        color1+(c!=0),\\n                        color2+(c!=balls[i]),\\n                        left*math.factorial(c),\\n                        right*math.factorial(balls[i]-c))\\n\\n\\n        dfs(0,0,0,0,0,1,1)\\n        return round(self.good/self.total,5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663109,
                "title": "javascript-permutations-w-dfs",
                "content": "```\\n/**\\n * @param {number[]} balls\\n * @return {number}\\n */\\nvar getProbability = function(balls) {\\n\\t// ball containers\\n    let firstHalf = {};\\n    let secondHalf = {};\\n    \\n\\t// good is the successful permutations (unique ball count match)\\n    let good = 0;\\n\\t// all is total permutations created\\n    let all = 0;\\n    var dfs = function(i) {\\n        if (i === balls.length) {\\n            // If we have reached the end of the permutation creation\\n            \\n            // First sum up the values in both containers\\n            let firstKeys = Object.keys(firstHalf);\\n            let s1 = 0;\\n            for (const key of firstKeys) {\\n                s1 += firstHalf[key]\\n            }\\n            let secondKeys = Object.keys(secondHalf);\\n            let s2 = 0;\\n            for (const key of secondKeys) {\\n                s2 += secondHalf[key]\\n            }\\n            // If total ball count in each container is not equal, this is an invalid permutation\\n            if (s1 !== s2) return 0;\\n            \\n            // get permutation count for first half of result\\n            let prod1 = 1;\\n            for (const key of firstKeys) {\\n                prod1 *= factorialize(firstHalf[key])\\n            }\\n            let p1 = factorialize(s1) / prod1;\\n            \\n            // get permutation count for second half of result\\n            let prod2 = 1;\\n            for (const key of secondKeys) {\\n                prod2 *= factorialize(secondHalf[key])\\n            }\\n            let p2 = factorialize(s2) / prod2;\\n            \\n            // sum up total permutations\\n            all += p1 * p2;\\n            // sum up \\'successful\\' permutations if it meets the criteria (unique balls, which means key count is equal)\\n            good += Object.keys(firstHalf).length === Object.keys(secondHalf).length ? p1 * p2 : 0;\\n        } else {\\n            // set all balls of color to be in first half of result\\n            firstHalf[i] = balls[i];\\n            for (let j = 0; j < balls[i] + 1; j++) {\\n                // dfs with that index + 1\\n                dfs(i + 1);\\n                // throughout the loop, decrease the number of balls in the first half & add them to the second half\\n                // this will allow us to visit all permutations for each ball count\\n                if (firstHalf[i] !== undefined) {\\n                    firstHalf[i] -= 1;\\n                    if (firstHalf[i] === 0) {\\n                        delete firstHalf[i];\\n                    }\\n                }\\n                secondHalf[i] = secondHalf[i] !== undefined ? secondHalf[i] + 1 : 1;\\n            }\\n            delete secondHalf[i];\\n        }\\n    }\\n    // dfs the root ball\\n    dfs(0);\\n    // return the ratio\\n    return good/all;\\n};\\n\\n// Function to get factorial of a given #\\nvar factorialize = function(num) {\\n  if (num === 0 || num === 1)\\n    return 1;\\n  for (var i = num - 1; i >= 1; i--) {\\n    num *= i;\\n  }\\n  return num;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} balls\\n * @return {number}\\n */\\nvar getProbability = function(balls) {\\n\\t// ball containers\\n    let firstHalf = {};\\n    let secondHalf = {};\\n    \\n\\t// good is the successful permutations (unique ball count match)\\n    let good = 0;\\n\\t// all is total permutations created\\n    let all = 0;\\n    var dfs = function(i) {\\n        if (i === balls.length) {\\n            // If we have reached the end of the permutation creation\\n            \\n            // First sum up the values in both containers\\n            let firstKeys = Object.keys(firstHalf);\\n            let s1 = 0;\\n            for (const key of firstKeys) {\\n                s1 += firstHalf[key]\\n            }\\n            let secondKeys = Object.keys(secondHalf);\\n            let s2 = 0;\\n            for (const key of secondKeys) {\\n                s2 += secondHalf[key]\\n            }\\n            // If total ball count in each container is not equal, this is an invalid permutation\\n            if (s1 !== s2) return 0;\\n            \\n            // get permutation count for first half of result\\n            let prod1 = 1;\\n            for (const key of firstKeys) {\\n                prod1 *= factorialize(firstHalf[key])\\n            }\\n            let p1 = factorialize(s1) / prod1;\\n            \\n            // get permutation count for second half of result\\n            let prod2 = 1;\\n            for (const key of secondKeys) {\\n                prod2 *= factorialize(secondHalf[key])\\n            }\\n            let p2 = factorialize(s2) / prod2;\\n            \\n            // sum up total permutations\\n            all += p1 * p2;\\n            // sum up \\'successful\\' permutations if it meets the criteria (unique balls, which means key count is equal)\\n            good += Object.keys(firstHalf).length === Object.keys(secondHalf).length ? p1 * p2 : 0;\\n        } else {\\n            // set all balls of color to be in first half of result\\n            firstHalf[i] = balls[i];\\n            for (let j = 0; j < balls[i] + 1; j++) {\\n                // dfs with that index + 1\\n                dfs(i + 1);\\n                // throughout the loop, decrease the number of balls in the first half & add them to the second half\\n                // this will allow us to visit all permutations for each ball count\\n                if (firstHalf[i] !== undefined) {\\n                    firstHalf[i] -= 1;\\n                    if (firstHalf[i] === 0) {\\n                        delete firstHalf[i];\\n                    }\\n                }\\n                secondHalf[i] = secondHalf[i] !== undefined ? secondHalf[i] + 1 : 1;\\n            }\\n            delete secondHalf[i];\\n        }\\n    }\\n    // dfs the root ball\\n    dfs(0);\\n    // return the ratio\\n    return good/all;\\n};\\n\\n// Function to get factorial of a given #\\nvar factorialize = function(num) {\\n  if (num === 0 || num === 1)\\n    return 1;\\n  for (var i = num - 1; i >= 1; i--) {\\n    num *= i;\\n  }\\n  return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 663057,
                "title": "c-with-backtracking-and-math",
                "content": "````\\nclass Solution {\\n    int sumg;\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        sumg = accumulate(balls.begin(), balls.end(), 0);\\n        vector<int> l;\\n        vector<int> r;\\n        double same = dfs(balls, 0, 0, l, r);\\n        return same*1.0/fac(balls);\\n    }\\n    \\n    //here sum is the left side sum\\n    double dfs(vector<int>& balls, int ind, int sum, vector<int>& l, vector<int>& r){\\n        if(ind > balls.size()) return 0;\\n        if(ind ==balls.size()){\\n            if(sum == sumg/2){//ensure that half of balls\\n                if(l.size() == r.size()){ // ensure that same number of different color types\\n                    return fac(l)*fac(r);//calculate all permutation\\n                }\\n            }\\n            return 0;\\n        }\\n        \\n        if(sum > sumg/2) return 0;\\n        \\n        double res{0};\\n        for(int i=0; i<= balls[ind]; ++i){\\n            if(i==0){\\n                l.push_back(balls[ind]);\\n                res += dfs(balls, ind+1, sum+balls[ind], l, r);\\n                l.pop_back();\\n            }else if(i == balls[ind]){\\n                r.push_back(i);\\n                res += dfs(balls, ind+1, sum, l, r);\\n                r.pop_back();\\n            }else{\\n                l.push_back(i);\\n                r.push_back(balls[ind]-i);\\n                res += dfs(balls, ind+1, sum+i, l, r);\\n                l.pop_back();\\n                r.pop_back();\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    double fac(vector<int>& l){\\n        int count{1};\\n        double val{1};\\n        for(auto&x:l){\\n            for(int i=1; i<= x; ++i){\\n                val *=count++;\\n                val /= i;\\n            }\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int sumg;\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        sumg = accumulate(balls.begin(), balls.end(), 0);\\n        vector<int> l;\\n        vector<int> r;\\n        double same = dfs(balls, 0, 0, l, r);\\n        return same*1.0/fac(balls);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 663017,
                "title": "java-simple-dfs-fake-permutation-fix-overflow",
                "content": "**Basic idea** - `result = valid cases / all possibile cases`\\n\\n**Steps**\\n1. use dfs to find all distributions (don\\'t care order) of balls in two boxes a and b;\\n2. if num(a) == num(b), add its permutation to \"possible cases\";\\n3. if distinct(a) == distinct(b), also add its permutation to \"valid cases\"\\n\\n**How to compute permutation**\\nTherotically, `permutation(a and b) = n!/(a1!a2!..ak!) * n!/(b1!b2!..ak!) = n!n!(a1!b1!...an!bn!)`\\n\\nE.g  `[2, 1, 1]`\\n`a = [1, 1, 0]`, `b = [1, 0, 1]` is a valid case\\n            `permutation(a and b) = 2!/(1!1!0!) * 2!/(1!0!1!) = 2!2! / (1!1! 1!0! 0!1!)`\\n\\nHowever, `n!` could be up to `24!` which will cause overflow in Java (Python is fine). To fix overflow, we can simply ignore `n!n!` when computing permutations. The reason why we can do that is all `n!n!` in \"valid\" and \"possbile\" will be removed by division at last. See https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/discuss/661648/JAVA-or-Valid-casesAll-cases-or-Simple-solution/561209 for detailed explanation (@svll).  \\n\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662647,
                "title": "java-simple-solution",
                "content": "```\\n    double even = 0;\\n    public double getProbability(int[] balls) {\\n        int sum = 0;\\n        for(int e : balls) sum += e;\\n        int[] count = new int[balls.length];\\n        dfs(count, 0, balls, sum >> 1, sum);\\n\\n        double total = getFib(sum);\\n        for(int e : balls) if(e > 1) total /= getFib(e);\\n        return (double)even/(double)(total);\\n    }\\n    \\n    void dfs(int[] count, int idx, int[] balls, int remain, int sum) {\\n        if(remain == 0) {   \\n            int color_1 = 0, color_2 = 0;\\n            for(int i = 0; i < balls.length; i++) {\\n                if(count[i] > 0) color_1++;\\n                if(count[i] < balls[i]) color_2++;\\n            }\\n            \\n            if(color_1 == color_2) {\\n                even += getRes(count, balls, sum);\\n            }\\n            return;\\n        }\\n\\n        if(idx == balls.length) return;\\n        \\n        for(int c = 0; c <= Math.min(balls[idx], remain); c++) {\\n            count[idx] = c;\\n            dfs(count, idx + 1, balls, remain - c, sum);\\n        }\\n        count[idx] = 0;\\n    }\\n    \\n    double getRes(int[] count, int[] balls, int sum) {\\n        double t = getFib(sum >> 1), t1 = t, t2 = t;\\n        for(int i = 0; i < balls.length; i++) {\\n            int c2 = balls[i] - count[i];\\n            if(count[i] > 1) t1 /= getFib(count[i]);\\n            if(balls[i]-count[i] > 1) t2 /= getFib(balls[i]-count[i]);\\n        }\\n        return t1 * t2;\\n    }\\n    \\n    double getFib(int n) {\\n        double res = 1;\\n        while(n > 1) res *= n--;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    double even = 0;\\n    public double getProbability(int[] balls) {\\n        int sum = 0;\\n        for(int e : balls) sum += e;\\n        int[] count = new int[balls.length];\\n        dfs(count, 0, balls, sum >> 1, sum);\\n\\n        double total = getFib(sum);\\n        for(int e : balls) if(e > 1) total /= getFib(e);\\n        return (double)even/(double)(total);\\n    }\\n    \\n    void dfs(int[] count, int idx, int[] balls, int remain, int sum) {\\n        if(remain == 0) {   \\n            int color_1 = 0, color_2 = 0;\\n            for(int i = 0; i < balls.length; i++) {\\n                if(count[i] > 0) color_1++;\\n                if(count[i] < balls[i]) color_2++;\\n            }\\n            \\n            if(color_1 == color_2) {\\n                even += getRes(count, balls, sum);\\n            }\\n            return;\\n        }\\n\\n        if(idx == balls.length) return;\\n        \\n        for(int c = 0; c <= Math.min(balls[idx], remain); c++) {\\n            count[idx] = c;\\n            dfs(count, idx + 1, balls, remain - c, sum);\\n        }\\n        count[idx] = 0;\\n    }\\n    \\n    double getRes(int[] count, int[] balls, int sum) {\\n        double t = getFib(sum >> 1), t1 = t, t2 = t;\\n        for(int i = 0; i < balls.length; i++) {\\n            int c2 = balls[i] - count[i];\\n            if(count[i] > 1) t1 /= getFib(count[i]);\\n            if(balls[i]-count[i] > 1) t2 /= getFib(balls[i]-count[i]);\\n        }\\n        return t1 * t2;\\n    }\\n    \\n    double getFib(int n) {\\n        double res = 1;\\n        while(n > 1) res *= n--;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662446,
                "title": "python-10-lines-faster-than-100-00-36ms-14mb",
                "content": "\\n```\\nfrom math import comb\\nfrom functools import lru_cache\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        # to distribute i-th kind of ball\\n        # c1 num of color in box1\\n        # c2 num of color in box2\\n        # size_diff of box1 and box2\\n        @lru_cache(None)\\n        def helper(i, c1, c2, size_diff):\\n            if i == len(balls):\\n                return 1 if c1 == c2 and size_diff == 0 else 0\\n            p, left = 0, sum(balls[i:]) # prob, available balls\\n            b1_need = (left - size_diff) // 2  # the balls needed by box1\\n            for j in range(max(0, b1_need - left + balls[i]), min(balls[i], b1_need) + 1):\\n                w0 = comb(balls[i], j) * comb(left - balls[i], b1_need - j) / comb(left, b1_need)\\n                p0 = helper(i + 1, c1 + (1 if j != 0 else 0), c2 + (1 if j != balls[i] else 0), size_diff + (2 * j - balls[i]))\\n                p += p0 * w0\\n            return p\\n        return helper(0, 0, 0, 0)\\n\\n\\n```\\n![image](https://assets.leetcode.com/users/shentm/image_1590915945.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom math import comb\\nfrom functools import lru_cache\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        # to distribute i-th kind of ball\\n        # c1 num of color in box1\\n        # c2 num of color in box2\\n        # size_diff of box1 and box2\\n        @lru_cache(None)\\n        def helper(i, c1, c2, size_diff):\\n            if i == len(balls):\\n                return 1 if c1 == c2 and size_diff == 0 else 0\\n            p, left = 0, sum(balls[i:]) # prob, available balls\\n            b1_need = (left - size_diff) // 2  # the balls needed by box1\\n            for j in range(max(0, b1_need - left + balls[i]), min(balls[i], b1_need) + 1):\\n                w0 = comb(balls[i], j) * comb(left - balls[i], b1_need - j) / comb(left, b1_need)\\n                p0 = helper(i + 1, c1 + (1 if j != 0 else 0), c2 + (1 if j != balls[i] else 0), size_diff + (2 * j - balls[i]))\\n                p += p0 * w0\\n            return p\\n        return helper(0, 0, 0, 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662201,
                "title": "c-backtracking-carefully-handled-overflows-issue",
                "content": "So basically before going throught the solution:\\n\\n1. Given no of each type of ball as **balls[i]**,The ball of ith type can be taken in the follwing ways, (0,balls[i]);(1,balls[i]-1);(2,balls[i]-2)......................(balls[i]-1,1);(balls[i],0) \\t\\n\\n2. If any box takes a ball of ith type with the with quantity grater then zero then no of distinct in that box inxcrease by 1\\n\\n3. So now you can apply backtracking to go through all possible states.\\n\\n**Now  when you reach at the i==balls.size() the you cannot iterate any more so you first find the number of ways a box can have those balls that is permutation of Identical objects,Nut many can have overflow Issue for finding the Factorial of higher number,which can be easily handled by the perform function in my code** \\n```\\nclass Solution {\\npublic:\\n    vector<int> A,B;\\n    int Fact[7]={1,1,2,6,24,120,720};\\n    double perform(vector<int>&arr) \\n    {\\n        int sum = 0;\\n        double ans = 1.0;\\n        for (auto v : arr) \\n        {\\n            sum += v;\\n            ans/=Fact[v];\\n        }\\n        while(sum>=1)\\n            ans*=sum--;\\n        return ans;\\n    }\\n    double totl=0;\\n    double util(int ind,int rem1,int rem2,int d1,int d2,vector<int>&balls)\\n    {\\n        if(rem1<0 || rem2<0)\\n            return 0;\\n        if(rem1==0 && rem2==0 && ind==balls.size())\\n        {\\n            totl+=perform(A)*perform(B);\\n            return d1==d2?perform(A)*perform(B):0; \\n        }\\n        if(ind==balls.size())\\n            return 0;\\n        double cnt=0;\\n        for(int i=0;i<=balls[ind];i++)\\n        {\\n            A.push_back(i);\\n            B.push_back(balls[ind]-i);\\n            cnt+=util(ind+1,rem1-i,rem2-(balls[ind]-i),d1+(i!=0),d2+(balls[ind]!=i),balls);\\n            A.pop_back();\\n            B.pop_back();\\n        }\\n        return cnt;\\n    }\\n    double getProbability(vector<int>& balls) \\n    {\\n        int sum=0,i,n=balls.size();\\n        for(i=0;i<n;i++)\\n            sum+=balls[i];\\n        double cnt=util(0,sum/2,sum/2,0,0,balls);\\n        return cnt/totl;\\n    }\\n};\\n```\\n\\nIf you like then upvote or have any suggestion to improve the solution,let me know in the comments",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> A,B;\\n    int Fact[7]={1,1,2,6,24,120,720};\\n    double perform(vector<int>&arr) \\n    {\\n        int sum = 0;\\n        double ans = 1.0;\\n        for (auto v : arr) \\n        {\\n            sum += v;\\n            ans/=Fact[v];\\n        }\\n        while(sum>=1)\\n            ans*=sum--;\\n        return ans;\\n    }\\n    double totl=0;\\n    double util(int ind,int rem1,int rem2,int d1,int d2,vector<int>&balls)\\n    {\\n        if(rem1<0 || rem2<0)\\n            return 0;\\n        if(rem1==0 && rem2==0 && ind==balls.size())\\n        {\\n            totl+=perform(A)*perform(B);\\n            return d1==d2?perform(A)*perform(B):0; \\n        }\\n        if(ind==balls.size())\\n            return 0;\\n        double cnt=0;\\n        for(int i=0;i<=balls[ind];i++)\\n        {\\n            A.push_back(i);\\n            B.push_back(balls[ind]-i);\\n            cnt+=util(ind+1,rem1-i,rem2-(balls[ind]-i),d1+(i!=0),d2+(balls[ind]!=i),balls);\\n            A.pop_back();\\n            B.pop_back();\\n        }\\n        return cnt;\\n    }\\n    double getProbability(vector<int>& balls) \\n    {\\n        int sum=0,i,n=balls.size();\\n        for(i=0;i<n;i++)\\n            sum+=balls[i];\\n        double cnt=util(0,sum/2,sum/2,0,0,balls);\\n        return cnt/totl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662195,
                "title": "python-backtracking",
                "content": "```class Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        N, k = sum(balls), len(balls)\\n        \\n        res = 0\\n        \\n\\t\\t# i: index of balls\\n\\t\\t# left_color: distinct color of left partition\\n\\t\\t# right_color: distinct color of right partition\\n\\t\\t# left_count: number of balls in left partition\\n\\t\\t# right_color: number of balls in right partition\\n\\t\\t# prev: number of combination\\n        def backtracking(i, left_color, right_color, left_count, right_count, prev):\\n            nonlocal res\\n            if max(left_count, right_count) > N // 2:\\n                return\\n            if i == k:\\n                if left_color == right_color and left_count == N // 2:\\n                    res += prev\\n                return\\n            # balls[i]: total num of this color\\n            for j in range(balls[i] + 1):\\n                backtracking(\\n                    i+1, \\n                    left_color + (j!=0), \\n                    right_color + (j!=balls[i]), \\n                    left_count + j, \\n                    right_count + balls[i] - j, \\n                    prev * self.comb(balls[i], j)  # number of combination choose j from balls[i]\\n                )\\n            \\n        backtracking(0, 0, 0, 0, 0, 1)\\n\\n        return res * 1.0 / self.comb(N, N//2)\\n    \\n    def comb(self, n, p):\\n        return math.factorial(n) / (math.factorial(p) * math.factorial(n-p))",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```class Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        N, k = sum(balls), len(balls)\\n        \\n        res = 0\\n        \\n\\t\\t# i: index of balls\\n\\t\\t# left_color: distinct color of left partition\\n\\t\\t# right_color: distinct color of right partition\\n\\t\\t# left_count: number of balls in left partition\\n\\t\\t# right_color: number of balls in right partition\\n\\t\\t# prev: number of combination\\n        def backtracking(i, left_color, right_color, left_count, right_count, prev):\\n            nonlocal res\\n            if max(left_count, right_count) > N // 2:\\n                return\\n            if i == k:\\n                if left_color == right_color and left_count == N // 2:\\n                    res += prev\\n                return\\n            # balls[i]: total num of this color\\n            for j in range(balls[i] + 1):\\n                backtracking(\\n                    i+1, \\n                    left_color + (j!=0), \\n                    right_color + (j!=balls[i]), \\n                    left_count + j, \\n                    right_count + balls[i] - j, \\n                    prev * self.comb(balls[i], j)  # number of combination choose j from balls[i]\\n                )\\n            \\n        backtracking(0, 0, 0, 0, 0, 1)\\n\\n        return res * 1.0 / self.comb(N, N//2)\\n    \\n    def comb(self, n, p):\\n        return math.factorial(n) / (math.factorial(p) * math.factorial(n-p))",
                "codeTag": "Java"
            },
            {
                "id": 662185,
                "title": "c-dp-0ms",
                "content": "```\\nclass Solution {\\n    double make(int x, int y) {\\n        double v = 1.;\\n        for (; y; --y) {\\n            v *= (x + y);\\n            v /= y;\\n        }\\n        return v;\\n        \\n    }\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        int n = 0;\\n        for (int x : balls) {\\n            n += x;\\n        }\\n        int m = n / 2;\\n        const int c = balls.size();\\n        vector<vector<vector<double>>> dp(c + 1, vector<vector<double>>(m + 1, vector<double>(c * 2 + 1)));\\n        dp[0][0][c] = 1;\\n        int sum = 0;\\n        double d = 1.;\\n        for (int t = 1; t <= c; ++t) {\\n            const int x = balls[t - 1];\\n            for (int i = min(sum + x, m); i >= 0; --i) {\\n                for (int j = max(i - sum, 0); j <= x && j <= i; ++j) {\\n                    const auto& p = dp[t - 1][i - j];\\n                    for (int k = 0; k < p.size(); ++k) {\\n                        int kk = k;\\n                        if (j) {\\n                            ++kk;\\n                        }\\n                        if (x - j) {\\n                            --kk;\\n                        }\\n                        if (kk < 0 || kk >= p.size()) continue;\\n                        dp[t][i][kk] += p[k] * make(sum - (i - j), x - j) * make(i - j, j);\\n                    }\\n                }\\n            }\\n            d *= make(sum, x);\\n            sum += x;\\n        }\\n        return dp[c][m][c] / d;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double make(int x, int y) {\\n        double v = 1.;\\n        for (; y; --y) {\\n            v *= (x + y);\\n            v /= y;\\n        }\\n        return v;\\n        \\n    }\\npublic:\\n    double getProbability(vector<int>& balls) {\\n        int n = 0;\\n        for (int x : balls) {\\n            n += x;\\n        }\\n        int m = n / 2;\\n        const int c = balls.size();\\n        vector<vector<vector<double>>> dp(c + 1, vector<vector<double>>(m + 1, vector<double>(c * 2 + 1)));\\n        dp[0][0][c] = 1;\\n        int sum = 0;\\n        double d = 1.;\\n        for (int t = 1; t <= c; ++t) {\\n            const int x = balls[t - 1];\\n            for (int i = min(sum + x, m); i >= 0; --i) {\\n                for (int j = max(i - sum, 0); j <= x && j <= i; ++j) {\\n                    const auto& p = dp[t - 1][i - j];\\n                    for (int k = 0; k < p.size(); ++k) {\\n                        int kk = k;\\n                        if (j) {\\n                            ++kk;\\n                        }\\n                        if (x - j) {\\n                            --kk;\\n                        }\\n                        if (kk < 0 || kk >= p.size()) continue;\\n                        dp[t][i][kk] += p[k] * make(sum - (i - j), x - j) * make(i - j, j);\\n                    }\\n                }\\n            }\\n            d *= make(sum, x);\\n            sum += x;\\n        }\\n        return dp[c][m][c] / d;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662173,
                "title": "python-one-more-recursive-solution",
                "content": "Counting every valid permutations with given conditions:\\n1. Number of total balls in both boxes needs to be equal\\n2. Number of unique balls in both boxes needs to be equal\\n\\nVariable exaplaination:\\n* `ind` : current index of `balls`\\n* `n1`  : number of unique balls in box A\\n* `n2`  : number of unique balls in box B\\n* `rep1` : number of repeated balls in box A\\n* `rep2` : number of repeated balls in box B\\n* `t1` : number of total balls in box A\\n* `t2` : number of total balls in box B\\n```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n       \\n        def rec(ind,n1,n2,rep1,rep2,t1,t2):\\n            nonlocal sm\\n            #if ball count in either box exceeds required count `sm` then pruin it\\n            if t1>sm or t2>sm:\\n                return 0\\n            #balls list is processed successfully\\n            if ind == len(balls):\\n                #if number of unique balls in both bucket is equal and also number of balls\\n                if n1==n2 and t1 == t2:\\n                    c1=fact[t1]\\n                    #removing repeating colors ball permutation\\n                    for i in rep1:\\n                        c1/=fact[i]\\n                    c2=fact[t2]\\n                    #removing repeating colors ball permutation\\n                    for i in rep2:\\n                        c2/=fact[i]\\n                    return c1*c2    #as [1,2/2,3] and [2,1/2,3] is treated different\\n                return 0\\n            cnt = 0\\n            cnt+=rec(ind+1,n1+1,n2,rep1+[balls[ind]],rep2,t1+balls[ind],t2) #assigning all the balls to box1\\n            cnt+=rec(ind+1,n1,n2+1,rep1,rep2+[balls[ind]],t1,t2+balls[ind]) #assigning all the balls to box2\\n            #when more than 1 ball exist, then split them, i.e if 3 then (1,2),(2,1). (0,3) and (3,0) has been already processed\\n            if balls[ind]>1:\\n                for i in range(1,balls[ind]):\\n                    cnt+=rec(ind+1,n1+1,n2+1,rep1+[i],rep2+[balls[ind]-i],t1+i,t2+balls[ind]-i)\\n            return cnt\\n\\n        sm = sum(balls)//2  #one box will have this many boxes\\n        fact = [1]\\n        for i in range(1,50):\\n            fact.append(fact[-1]*i)\\n        \\n        tot = fact[sum(balls)]  #total permutations of all balls\\n        for i in balls:\\n            tot/=fact[i]    #removing same color permutations\\n        \\n        return rec(0,0,0,[],[],0,0)/tot\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n       \\n        def rec(ind,n1,n2,rep1,rep2,t1,t2):\\n            nonlocal sm\\n            #if ball count in either box exceeds required count `sm` then pruin it\\n            if t1>sm or t2>sm:\\n                return 0\\n            #balls list is processed successfully\\n            if ind == len(balls):\\n                #if number of unique balls in both bucket is equal and also number of balls\\n                if n1==n2 and t1 == t2:\\n                    c1=fact[t1]\\n                    #removing repeating colors ball permutation\\n                    for i in rep1:\\n                        c1/=fact[i]\\n                    c2=fact[t2]\\n                    #removing repeating colors ball permutation\\n                    for i in rep2:\\n                        c2/=fact[i]\\n                    return c1*c2    #as [1,2/2,3] and [2,1/2,3] is treated different\\n                return 0\\n            cnt = 0\\n            cnt+=rec(ind+1,n1+1,n2,rep1+[balls[ind]],rep2,t1+balls[ind],t2) #assigning all the balls to box1\\n            cnt+=rec(ind+1,n1,n2+1,rep1,rep2+[balls[ind]],t1,t2+balls[ind]) #assigning all the balls to box2\\n            #when more than 1 ball exist, then split them, i.e if 3 then (1,2),(2,1). (0,3) and (3,0) has been already processed\\n            if balls[ind]>1:\\n                for i in range(1,balls[ind]):\\n                    cnt+=rec(ind+1,n1+1,n2+1,rep1+[i],rep2+[balls[ind]-i],t1+i,t2+balls[ind]-i)\\n            return cnt\\n\\n        sm = sum(balls)//2  #one box will have this many boxes\\n        fact = [1]\\n        for i in range(1,50):\\n            fact.append(fact[-1]*i)\\n        \\n        tot = fact[sum(balls)]  #total permutations of all balls\\n        for i in balls:\\n            tot/=fact[i]    #removing same color permutations\\n        \\n        return rec(0,0,0,[],[],0,0)/tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662135,
                "title": "java-brute-force-with-biginteger",
                "content": "Just use dfs and backtrack to try each pair.\\ncheck if it\\'s a valid pair add to valid and total. Otherwise only add to the total.\\n\\n```\\nimport java.math.*; \\nclass Solution {\\n    int half = 0;\\n    BigInteger valid = BigInteger.valueOf(0), total = BigInteger.valueOf(0);\\n    long[] factorial;\\n    public double getProbability(int[] balls) {\\n        int[] a = new int[balls.length];        \\n        for(int i : balls)\\n            half += i;\\n        half /= 2;\\n        factorial = new long[half + 1];\\n        long tmp = 1;\\n        for(int i = 1; i < factorial.length; ++i){\\n            tmp *= i;\\n            factorial[i] = tmp;\\n        }\\n        dfs(0,balls,a,0);\\n        BigDecimal quotient = new BigDecimal(valid).divide(new BigDecimal(total), 6, RoundingMode.HALF_EVEN);\\n        return quotient.doubleValue();\\n    }\\n    \\n    void dfs(int s, int[] balls, int[] a, int count){\\n        if(count > half)\\n            return;\\n        if(s == a.length){\\n            if(count == half)\\n                check(balls,a);\\n            return;\\n        }\\n        for(int i = 0; i <= balls[s]; ++i){\\n            a[s] = i;\\n            dfs(s + 1, balls, a, count + i);\\n        }\\n    }\\n    \\n    void check(int[] a, int [] b){\\n        int color = 0;\\n        long da = 1, db = 1;\\n        for(int i = 0; i < a.length; ++i){\\n            if(b[i] > 0){\\n                color++;\\n                da *= factorial[b[i]];\\n            }\\n            if(a[i] - b[i] > 0){\\n                color--;\\n                db *= factorial[a[i] - b[i]];\\n            }\\n        }\\n        BigInteger times = BigInteger.valueOf(factorial[half] / da).multiply(BigInteger.valueOf(factorial[half] / db));\\n        if(color == 0)\\n            valid = valid.add(times); \\n        total = total.add(times);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nimport java.math.*; \\nclass Solution {\\n    int half = 0;\\n    BigInteger valid = BigInteger.valueOf(0), total = BigInteger.valueOf(0);\\n    long[] factorial;\\n    public double getProbability(int[] balls) {\\n        int[] a = new int[balls.length];        \\n        for(int i : balls)\\n            half += i;\\n        half /= 2;\\n        factorial = new long[half + 1];\\n        long tmp = 1;\\n        for(int i = 1; i < factorial.length; ++i){\\n            tmp *= i;\\n            factorial[i] = tmp;\\n        }\\n        dfs(0,balls,a,0);\\n        BigDecimal quotient = new BigDecimal(valid).divide(new BigDecimal(total), 6, RoundingMode.HALF_EVEN);\\n        return quotient.doubleValue();\\n    }\\n    \\n    void dfs(int s, int[] balls, int[] a, int count){\\n        if(count > half)\\n            return;\\n        if(s == a.length){\\n            if(count == half)\\n                check(balls,a);\\n            return;\\n        }\\n        for(int i = 0; i <= balls[s]; ++i){\\n            a[s] = i;\\n            dfs(s + 1, balls, a, count + i);\\n        }\\n    }\\n    \\n    void check(int[] a, int [] b){\\n        int color = 0;\\n        long da = 1, db = 1;\\n        for(int i = 0; i < a.length; ++i){\\n            if(b[i] > 0){\\n                color++;\\n                da *= factorial[b[i]];\\n            }\\n            if(a[i] - b[i] > 0){\\n                color--;\\n                db *= factorial[a[i] - b[i]];\\n            }\\n        }\\n        BigInteger times = BigInteger.valueOf(factorial[half] / da).multiply(BigInteger.valueOf(factorial[half] / db));\\n        if(color == 0)\\n            valid = valid.add(times); \\n        total = total.add(times);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566610,
                "content": [
                    {
                        "username": "flyg",
                        "content": "[1,1 / 2,3]\\'s probability is 2 times the [1,2 / 1,3] right?\\n"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "It is not. There are exactly 2 ways to get each. Suppose we labeled the individual 1 balls also with A/B\\n[1A,1B / 2,3] + [1B,1A / 2,3] = [1,1 / 2,3]\\n[1A,2 / 1B,3] + [1B,2 / 1A,3] = [1,2 / 1,3]"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if the Sentence Is Pangram",
        "question_content": "<p>A <strong>pangram</strong> is a sentence where every letter of the English alphabet appears at least once.</p>\n\n<p>Given a string <code>sentence</code> containing only lowercase English letters, return<em> </em><code>true</code><em> if </em><code>sentence</code><em> is a <strong>pangram</strong>, or </em><code>false</code><em> otherwise.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;thequickbrownfoxjumpsoverthelazydog&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> sentence contains at least one of every letter of the English alphabet.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;leetcode&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 1000</code></li>\n\t<li><code>sentence</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1164135,
                "title": "simple-solution-no-set-map",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int seen = 0;\\n        for(char c : sentence.toCharArray()) {\\n            int ci = c - \\'a\\';\\n            seen = seen | (1 << ci);\\n        }\\n        return seen == ((1 << 26) - 1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int seen = 0;\\n        for(char c : sentence.toCharArray()) {\\n            int ci = c - \\'a\\';\\n            seen = seen | (1 << ci);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1164047,
                "title": "java-c-python-set-solution",
                "content": "\\n# **Explanation**\\nPut all characters in a set,\\nreturn if the size of set equals to 26.\\nCan return earlier if you like.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(26)`\\n<br>\\n\\n**Java**\\n```java\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> s = new HashSet<>();\\n        for (int i = 0; i < sentence.length(); ++i)\\n            s.add(sentence.charAt(i));\\n        return s.size() == 26;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    bool checkIfPangram(string sentence) {\\n        set<int> s;\\n        for (auto& c: sentence)\\n            s.insert(c);\\n        return s.size() == 26;\\n    }\\n```\\n**C++, 1-line**\\nby @alvin-777\\n```cpp\\n    bool checkIfPangram(string s) {\\n        return set<char>(s.begin(), s.end()).size() == 26;\\n    }\\n```\\n**Python**\\n```py\\n    def checkIfPangram(self, s):\\n        return len(set(s)) == 26\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> s = new HashSet<>();\\n        for (int i = 0; i < sentence.length(); ++i)\\n            s.add(sentence.charAt(i));\\n        return s.size() == 26;\\n    }\\n```\n```cpp\\n    bool checkIfPangram(string sentence) {\\n        set<int> s;\\n        for (auto& c: sentence)\\n            s.insert(c);\\n        return s.size() == 26;\\n    }\\n```\n```cpp\\n    bool checkIfPangram(string s) {\\n        return set<char>(s.begin(), s.end()).size() == 26;\\n    }\\n```\n```py\\n    def checkIfPangram(self, s):\\n        return len(set(s)) == 26\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1164224,
                "title": "java-simple-and-easy-to-understand-solution-1-ms-faster-than-100-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        boolean[] letters  = new boolean[26];\\n        \\n        for(char c : sentence.toCharArray()) {\\n            letters[c - \\'a\\'] = true;\\n        }\\n        \\n        //find any letter that not exist\\n        for(boolean existLetter : letters) {\\n            if(!existLetter) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        boolean[] letters  = new boolean[26];\\n        \\n        for(char c : sentence.toCharArray()) {\\n            letters[c - \\'a\\'] = true;\\n        }\\n        \\n        //find any letter that not exist\\n        for(boolean existLetter : letters) {\\n            if(!existLetter) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201598,
                "title": "simple-java-0ms",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n\\t\\tif (sentence.length() < 26) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tString alphas = \"abcdefghijklmnopqrstuvwxyz\";\\n\\t\\tfor (int i = 0; i < alphas.length(); i++) {\\n\\t\\t\\tif (sentence.indexOf(alphas.charAt(i)) == -1) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n\\t\\tif (sentence.length() < 26) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tString alphas = \"abcdefghijklmnopqrstuvwxyz\";\\n\\t\\tfor (int i = 0; i < alphas.length(); i++) {\\n\\t\\t\\tif (sentence.indexOf(alphas.charAt(i)) == -1) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712263,
                "title": "c-0ms-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\n--------------------------------------------------------\\n\\n**Intuition 1 -** Using a frequency vector store to store count and then traversing it to check for any 0 occurence.\\n\\n\\tbool checkIfPangram(string sentence) {\\n        \\n        vector<int> freq(26);                      //create a frequency vector \\n        \\n        for(auto ch:sentence) freq[ch-\\'a\\']++;      //update count of each character\\n        \\n        for(auto it:freq){                         //traverse freq vector\\n            if(it==0) return false;                //if any aplhabet\\'s occurence is 0\\n        }                                          //return false;\\n        return true;\\n    }\\n\\t\\n---------------------------------------------------\\n\\n**Intuition 2 -** Using a hash set, push all characters of the given string into hash set and check if set\\'s size == 26\\n\\t\\n\\tbool checkIfPangram(string sentence) {\\n        \\n        unordered_set<char> st (sentence.begin(), sentence.end());         //push all characters of string into set\\n        return st.size()==26;                                              //check if it\\'s size = 26 or not\\n\\t\\n\\t}\\n\\t\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\n--------------------------------------------------------\\n\\n**Intuition 1 -** Using a frequency vector store to store count and then traversing it to check for any 0 occurence.\\n\\n\\tbool checkIfPangram(string sentence) {\\n        \\n        vector<int> freq(26);                      //create a frequency vector \\n        \\n        for(auto ch:sentence) freq[ch-\\'a\\']++;      //update count of each character\\n        \\n        for(auto it:freq){                         //traverse freq vector\\n            if(it==0) return false;                //if any aplhabet\\'s occurence is 0\\n        }                                          //return false;\\n        return true;\\n    }\\n\\t\\n---------------------------------------------------\\n\\n**Intuition 2 -** Using a hash set, push all characters of the given string into hash set and check if set\\'s size == 26\\n\\t\\n\\tbool checkIfPangram(string sentence) {\\n        \\n        unordered_set<char> st (sentence.begin(), sentence.end());         //push all characters of string into set\\n        return st.size()==26;                                              //check if it\\'s size = 26 or not\\n\\t\\n\\t}\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2713135,
                "title": "c-7-different-approaches-clean-code",
                "content": "<!--\\nTitle: C++ || 7 different approaches || clean code\\nProblem: 1832\\nURL: https://leetcode.com/problems/check-if-the-sentence-is-pangram/discuss/2713135/c-7-different-approaches-clean-code\\n-->\\n\\nI had way too much fun coming up with different approach to solve this problem. Please let me know if you have any suggestions for another approach or on how to improve one of the approach below. ... and leave a like before you go. :)\\n\\n\\n### Approach 1: hash set\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        const unordered_set<char> seen(begin(s), end(s));\\n        return size(seen) == 26;\\n    }\\n```\\n\\nThis can be writen as a one-liner as well:\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        return size(unordered_set<char>{begin(s), end(s)}) == 26;\\n    }\\n```\\n\\nWe could also use a ```set```, but since we only care about the since and not the order of elements, this would just make things less efficient.\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$ we need to insert all the characters into a hash set, with each insert operation being $$O(1)$$\\n  * Space complexity: $$O(1)$$ as the size of the hash set is limited to 26 entries.\\n\\n### Approach 2: std::sort and std::unique\\n\\n```cpp\\n    static bool checkIfPangram(string& s) {\\n        sort(begin(s), end(s));\\n        return distance(begin(s), unique(begin(s), end(s))) == 26;\\n    }\\n```\\n\\nInstead of modifying the string with ```unique``` again. We could also just count the number of unique elements by comparying adjacent elements, something like the following (kudos to @vonser):\\n\\n```cpp\\n    static bool checkIfPangram(string& s) {\\n        sort(begin(s), end(s));\\n        int count = 1;\\n        for (int i = 1; i < size(s); ++i)\\n            if (s[i - 1] != s[i]) ++count;\\n        return count == 26;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n \\\\log n)$$ for sorting the rest is linear or constant time\\n  * Space complexity: $$O(1)$$\\n\\n\\n### Approach 3: brute force with std::string::find\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ++ch)\\n            if (s.find(ch) == string::npos) return false;\\n\\n        return true;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(26 n)$$ which is $$O(n)$$\\n  * Space complexity: $$O(1)$$\\n\\n\\n### Approach 4: bit masking and std::accumulate\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        int seen = 0;\\n        for (char ch : s) seen |= 1 << (ch - \\'a\\');\\n        return seen == (1 << 26) - 1;\\n    }\\n```\\n\\nWe could add an early exit if we have already seen all different characters:\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        int seen = 0;\\n        int rem = 26;\\n        for (char ch : sentence) {\\n            int mask = 1 << (ch - \\'a\\');\\n            if (!(seen & mask)) {\\n                if (!--rem) return true;\\n                seen |= mask;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\nOr combining the two ideas above:\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        int seen = 0;\\n        for (char ch : s) {\\n            seen |= 1 << (ch - \\'a\\');\\n            if (seen == (1 << 26) - 1) return true;\\n        }\\n        return false;\\n    }\\n```\\n\\nWithout raw loops and using ```std::accumulate``` we can turn this into a one-liner (a long though):\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        return accumulate(begin(s), end(s), 0, [](int seen, char ch) { return seen | (1 << (ch - \\'a\\')); }) == (1 << 26) - 1;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$\\n  * Space complexity: $$O(1)$$\\n\\n### Approach 5: std::transform and std::reduce w/ std::bit_or\\n\\nThis builds on the idea from approach 4. We first transform this into bit masks first and then reduce them. What\\'s intersting about ```std::reduce``` is that it coudl be executed in parallel. The down side of this approach is that we need a more extra memory. It should be noted that the reduce step doesn\\'t guartee an execution order and this is only correct because ```bit_or``` (```|```) is associative and commutative.\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        vector<int> tmp(size(s));\\n        transform(begin(s), end(s), back_inserter(tmp), [](char ch) { return 1 << (ch - \\'a\\'); });\\n        return reduce(begin(tmp), end(tmp), 0, bit_or{}) == (1 << 26) - 1;\\n    }\\n```\\n\\n**Complexity Analsysis**\\n  * Time complexity: $$O(n)$$\\n  * Space complexity: $$O(n)$$ for the temporary arrary\\n\\n### Approach 6: std::transform_reduce\\n\\nThe idea is the same as for approach 5, but we can reduce this to a one-liner w/o temporary memory. As w/ approach 5 this could also be executed in parallel for very large inputs.\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        return transform_reduce(begin(s), end(s), 0, bit_or{}, [](char ch) { return 1 << (ch - \\'a\\'); }) == (1 << 26) - 1;\\n    }\\n```\\n\\n**Complexity Analsysis**\\n  * Time complexity: $$O(n)$$\\n  * Space complexity: $$O(1)$$\\n\\n### Approach 7: array\\n\\nLast but not least there are several variations of using an array to keep track of the characters we have seen.\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        array<bool, 26> seen = {};\\n        for (char ch : s) seen[ch - \\'a\\'] = true;\\n        // TODO(heder): std::identity is C++ 20. Is there another library function?\\n        return all_of(begin(seen), end(seen), [](int x) { return x; });\\n    }\\n ```\\n \\n A variation of the above could be the use ```reduce``` / ```accumulate``` instead of ```all_of```. NB. we are using an ```array<char, 26>``` instead of a bool array:\\n \\n ```cpp\\n     static bool checkIfPangram(const string& s) {\\n        array<char, 26> seen = {};\\n        for (char ch : s) seen[ch - \\'a\\'] = 1;\\n        return reduce(begin(seen), end(seen)) == 26;\\n    }\\n```\\n\\nSimilar to the approach with the bit mask, we could also do an early exit here:\\n\\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        array<bool, 128> seen = {};\\n        int rem = 26;\\n        for (char ch : s) {\\n            if (!seen[ch]) {\\n                if (!--rem) return true;\\n                seen[ch] = true;\\n            }\\n        }\\n        return false;\\n    }\\n ```\\n\\n**Complexity Analsysis**\\n  * Time complexity: $$O(n)$$\\n  * Space complexity: $$O(1)$$\\n\\n### Appendix\\n\\nI have seen a few solution how are doing something like ```if (size(sentence) < 26) return false;``` which is a nice optimisation.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n    static bool checkIfPangram(const string& s) {\\n        const unordered_set<char> seen(begin(s), end(s));\\n        return size(seen) == 26;\\n    }\\n```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        return size(unordered_set<char>{begin(s), end(s)}) == 26;\\n    }\\n```\n```set```\n```cpp\\n    static bool checkIfPangram(string& s) {\\n        sort(begin(s), end(s));\\n        return distance(begin(s), unique(begin(s), end(s))) == 26;\\n    }\\n```\n```unique```\n```cpp\\n    static bool checkIfPangram(string& s) {\\n        sort(begin(s), end(s));\\n        int count = 1;\\n        for (int i = 1; i < size(s); ++i)\\n            if (s[i - 1] != s[i]) ++count;\\n        return count == 26;\\n    }\\n```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ++ch)\\n            if (s.find(ch) == string::npos) return false;\\n\\n        return true;\\n    }\\n```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        int seen = 0;\\n        for (char ch : s) seen |= 1 << (ch - \\'a\\');\\n        return seen == (1 << 26) - 1;\\n    }\\n```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        int seen = 0;\\n        int rem = 26;\\n        for (char ch : sentence) {\\n            int mask = 1 << (ch - \\'a\\');\\n            if (!(seen & mask)) {\\n                if (!--rem) return true;\\n                seen |= mask;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        int seen = 0;\\n        for (char ch : s) {\\n            seen |= 1 << (ch - \\'a\\');\\n            if (seen == (1 << 26) - 1) return true;\\n        }\\n        return false;\\n    }\\n```\n```std::accumulate```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        return accumulate(begin(s), end(s), 0, [](int seen, char ch) { return seen | (1 << (ch - \\'a\\')); }) == (1 << 26) - 1;\\n    }\\n```\n```std::reduce```\n```bit_or```\n```|```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        vector<int> tmp(size(s));\\n        transform(begin(s), end(s), back_inserter(tmp), [](char ch) { return 1 << (ch - \\'a\\'); });\\n        return reduce(begin(tmp), end(tmp), 0, bit_or{}) == (1 << 26) - 1;\\n    }\\n```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        return transform_reduce(begin(s), end(s), 0, bit_or{}, [](char ch) { return 1 << (ch - \\'a\\'); }) == (1 << 26) - 1;\\n    }\\n```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        array<bool, 26> seen = {};\\n        for (char ch : s) seen[ch - \\'a\\'] = true;\\n        // TODO(heder): std::identity is C++ 20. Is there another library function?\\n        return all_of(begin(seen), end(seen), [](int x) { return x; });\\n    }\\n ```\n```reduce```\n```accumulate```\n```all_of```\n```array<char, 26>```\n```cpp\\n     static bool checkIfPangram(const string& s) {\\n        array<char, 26> seen = {};\\n        for (char ch : s) seen[ch - \\'a\\'] = 1;\\n        return reduce(begin(seen), end(seen)) == 26;\\n    }\\n```\n```cpp\\n    static bool checkIfPangram(const string& s) {\\n        array<bool, 128> seen = {};\\n        int rem = 26;\\n        for (char ch : s) {\\n            if (!seen[ch]) {\\n                if (!--rem) return true;\\n                seen[ch] = true;\\n            }\\n        }\\n        return false;\\n    }\\n ```\n```if (size(sentence) < 26) return false;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711868,
                "title": "all-languages-only-1-line",
                "content": "\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        return unordered_set<char>(sentence.begin(), sentence.end()).size() == 26;\\n    }\\n};\\n```\\n\\n```java []\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        return sentence.chars().distinct().count() == 26;\\n    }\\n}\\n\\n\\n// Stream\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        return sentence.chars().boxed().collect(Collectors.toSet()).size() == 26;\\n    }\\n}\\n\\n```\\n```kotlin []\\nclass Solution {\\n    fun checkIfPangram(sentence: String): Boolean {\\n        return sentence.toSet().count() == 26\\n    }\\n}\\n```\\n\\n\\n```python []\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence)) == 26\\n```\\n\\n```javascript []\\nvar checkIfPangram = function (sentence) {\\n    return new Set(sentence).size === 26\\n};\\n```\\n```typescript []\\nfunction checkIfPangram(sentence: string): boolean {\\n    return [...new Set(sentence)].length >= 26;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        return unordered_set<char>(sentence.begin(), sentence.end()).size() == 26;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        return sentence.chars().distinct().count() == 26;\\n    }\\n}\\n\\n\\n// Stream\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        return sentence.chars().boxed().collect(Collectors.toSet()).size() == 26;\\n    }\\n}\\n\\n```\n```kotlin []\\nclass Solution {\\n    fun checkIfPangram(sentence: String): Boolean {\\n        return sentence.toSet().count() == 26\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence)) == 26\\n```\n```javascript []\\nvar checkIfPangram = function (sentence) {\\n    return new Set(sentence).size === 26\\n};\\n```\n```typescript []\\nfunction checkIfPangram(sentence: string): boolean {\\n    return [...new Set(sentence)].length >= 26;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170251,
                "title": "c-simple-question-needs-simple-solution-o-n-26-o-n",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int> n(26,0);\\n        \\n        for(char c:sentence)n[c-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++)\\n            if(n[i]==0)return false;\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int> n(26,0);\\n        \\n        for(char c:sentence)n[c-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++)\\n            if(n[i]==0)return false;\\n        \\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2712076,
                "title": "multiple-solution-in-python",
                "content": "**Fastest Solution:**\\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        lst=[0]*26\\n        for i in sentence:\\n            lst[ord(i)-ord(\\'a\\')]+=1\\n        return 0 not in lst\\n```\\n\\n**One line solution:**\\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence))==26\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        lst=[0]*26\\n        for i in sentence:\\n            lst[ord(i)-ord(\\'a\\')]+=1\\n        return 0 not in lst\\n```\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence))==26\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712357,
                "title": "one-liner",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, se: str) -> bool:\\n        return(len(set(se))==26) \\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, se: str) -> bool:\\n        return(len(set(se))==26) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380853,
                "title": "easy-3-approaches-with-explanation-c-100-time-one-liner",
                "content": "Very Easy solutions with quick explanation \\n**Approach 1 Basic approach of counting frequency**\\nI have used array for this approach\\n100% time for this approach\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int> v(26,0);\\n        for(auto x:sentence)\\n        {\\n            v[x-\\'a\\'] = 1;\\n        }\\n        return accumulate(begin(v),end(v),0) == 26;\\n    }\\n};\\n```\\n**Approach**\\nCounting all the unique charcters and check if they are equal to 26 (26 letters are there in the english alphabet series)\\n\\n**Working of code**\\n**Step 1 :**\\nCreate an int array of size 26 and fill with all 0s\\n```\\nv = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] length = 26\\n```\\n**Step 2:**\\nIterate all the elements of given sentence and mark the character present in our array...\\n\\n```\\nExample if we are at character \\'g\\'\\nso ascii value of g = 103\\nso we subtract ascii value of \\'a\\' (97) to get the correct index of g in our array\\nso now it would be 6 (103-97 = 6)\\nNow you can verify that 6 is the position of \\'g\\' in alphabetic sequence (0 based indexing)\\n\\n0 1 2 3 4 5 \\'6\\'\\na b c d e f \\'g\\'\\n\\nso we put 1 at the position 6 in our array\\nv = [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] length = 26\\n\\n```\\nNow we will fill all the position if the corresponding character is present in the string\\n\\n**Step 3:**\\nNow we can sum up all the elements present in the array. so if any 0 left unchanged then the sum would not be equal to 26..\\nAnd that\\'s the strategy...\\n<hr>\\n\\n**Approach 2 with integer variable as container**\\n100% time for this approach\\n```\\nbool checkIfPangram(string sentence) {\\n    int n = 0;\\n    for(auto &x:sentence){\\n        n|=(1<<(x-\\'a\\'));\\n    }\\n    cout<<n;\\n    return n==67108863;\\n}\\n```\\n**Approach**\\nApproach is same but as we know integer variable can hold a number of 32 bits, so istead of using a vector of size 26, we can simply use the bits of integer as flag bits (If ith bit is set then ith char in alphabetic series is presnt in the string.\\n**Working of code**\\n**Step 1 :**\\nCreate an int var and initialise with 0\\n```\\nHere our variable will start behaving like vector of bool of size 32\\nbits of int will be\\ni = bits(00000000000000000000000000000000)\\n```\\n**Step 2 :**\\nNow we can run a for loop same as in approach 1 to iterte over the string\\nAnd we will set the ith bit of the int variable\\n```\\nExample : if curr char is \\'d\\'\\nthen position of \\'d\\' is 4 in alphabet series...\\nSo we will try to set the 4th bit if it is 0 initially by using this\\nn|=(1<<(x-\\'a\\'));\\n\\nHere in 1 all bits are zeroes and last bit is 1\\nSo we move that last set bit to 4th position (for \\'d\\') (Here x-\\'a\\' will give the exact position of the bit)\\nAfter this we will do bit wise OR with our number so that its ith bit will became 1\\n```\\n**Step 3 :**\\nNow we can simply compare our number with 67108863...\\nHere 67108863 is the number in which last 26 bits are 1\\nSo if we reach the state where all 26 bits are 1 then we can conclude that we have iterated all the characters in the alphabet as we have done in previous approach\\n\\n<hr>\\n\\n**Approach 3 with set**\\nThis is not the time optimised solution, still good if you are a lazy person when it comes to typing\\n```\\nbool checkIfPangram(string sentence) {\\n        return unordered_set<char> (begin(sentence),end(sentence)).size()==26;\\n}\\n```\\n\\n**Approach**\\nApproach is same but working is slightly different\\n\\n**Working**\\n**Step 1:**\\nCreate a set and fill it with all the characters present in the string..\\n\\n**Step 2:**\\nAs per the property of sets you can not have duplicates in the set. \\nSo you can simply check the size of set whether it has 26 unique elements or not\\n\\nTime Complexity is O(n) for all the approaches\\n\\n**NOTE :** If you find any errors or any improvements required, then feel free to comment down below.\\n\\nThanks\\nGood Luck",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int> v(26,0);\\n        for(auto x:sentence)\\n        {\\n            v[x-\\'a\\'] = 1;\\n        }\\n        return accumulate(begin(v),end(v),0) == 26;\\n    }\\n};\\n```\n```\\nv = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] length = 26\\n```\n```\\nExample if we are at character \\'g\\'\\nso ascii value of g = 103\\nso we subtract ascii value of \\'a\\' (97) to get the correct index of g in our array\\nso now it would be 6 (103-97 = 6)\\nNow you can verify that 6 is the position of \\'g\\' in alphabetic sequence (0 based indexing)\\n\\n0 1 2 3 4 5 \\'6\\'\\na b c d e f \\'g\\'\\n\\nso we put 1 at the position 6 in our array\\nv = [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] length = 26\\n\\n```\n```\\nbool checkIfPangram(string sentence) {\\n    int n = 0;\\n    for(auto &x:sentence){\\n        n|=(1<<(x-\\'a\\'));\\n    }\\n    cout<<n;\\n    return n==67108863;\\n}\\n```\n```\\nHere our variable will start behaving like vector of bool of size 32\\nbits of int will be\\ni = bits(00000000000000000000000000000000)\\n```\n```\\nExample : if curr char is \\'d\\'\\nthen position of \\'d\\' is 4 in alphabet series...\\nSo we will try to set the 4th bit if it is 0 initially by using this\\nn|=(1<<(x-\\'a\\'));\\n\\nHere in 1 all bits are zeroes and last bit is 1\\nSo we move that last set bit to 4th position (for \\'d\\') (Here x-\\'a\\' will give the exact position of the bit)\\nAfter this we will do bit wise OR with our number so that its ith bit will became 1\\n```\n```\\nbool checkIfPangram(string sentence) {\\n        return unordered_set<char> (begin(sentence),end(sentence)).size()==26;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1355353,
                "title": "simple-easy-o-1-java-solution",
                "content": "if you like this \\n***please upvote and like this***\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n         if(sentence.length()<26) return false;\\n        for(int i=1;i<=26;i++)\\n            if(sentence.indexOf((char)i+96)<0)\\n                return false;        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n         if(sentence.length()<26) return false;\\n        for(int i=1;i<=26;i++)\\n            if(sentence.indexOf((char)i+96)<0)\\n                return false;        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164127,
                "title": "python-one-liner-easy-understandable-sol-sets",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence)) == 26\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence)) == 26\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712103,
                "title": "java-easy-solution",
                "content": "IF YOU LIKE THE SOLUTION\\nMAKE SURE TO UPVOTE IT !\\n\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        // Created count array to take count of every character.\\n       int[] count = new int[26];\\n        \\n        // Fill our count array\\n        for(int i = 0; i<sentence.length(); i++)\\n            count[sentence.charAt(i) - \\'a\\']++;\\n        \\n        // Check in count array that every element is present or not !\\n        for(int i : count)\\n            if(i < 1) return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        // Created count array to take count of every character.\\n       int[] count = new int[26];\\n        \\n        // Fill our count array\\n        for(int i = 0; i<sentence.length(); i++)\\n            count[sentence.charAt(i) - \\'a\\']++;\\n        \\n        // Check in count array that every element is present or not !\\n        for(int i : count)\\n            if(i < 1) return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290277,
                "title": "simple-solution-without-using-extra-space",
                "content": "**UPvote If you got it**\\n\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        if(sentence.length()<26 || sentence == null)\\n            return false;\\n        \\n        for(char i=97;i<=122;i++){\\n            if(!sentence.contains(String.valueOf(i)))\\n                return false;\\n        }\\n        return true;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        if(sentence.length()<26 || sentence == null)\\n            return false;\\n        \\n        for(char i=97;i<=122;i++){\\n            if(!sentence.contains(String.valueOf(i)))\\n                return false;\\n        }\\n        return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164565,
                "title": "javascript-one-liner-100-o-n",
                "content": "```\\nvar checkIfPangram = function(sentence) {\\n    return new Set(sentence.split(\"\")).size == 26;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkIfPangram = function(sentence) {\\n    return new Set(sentence.split(\"\")).size == 26;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3628998,
                "title": "only-1-line-code-for-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkIfPangram(self, s: str) -> bool:\\n        return len(set(s))==26 \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, s: str) -> bool:\\n        return len(set(s))==26 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164888,
                "title": "javascript-one-liner",
                "content": "var checkIfPangram = function(sentence) {\\n    return new Set([...sentence]).size === 26;\\n};",
                "solutionTags": [],
                "code": "var checkIfPangram = function(sentence) {\\n    return new Set([...sentence]).size === 26;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1164065,
                "title": "c-java-count-array",
                "content": "**C++**\\n```cpp\\nbool checkIfPangram(string sentence) {\\n    int cnt[26] = {}, total = 0;\\n    for (auto ch: sentence)\\n        if (++cnt[ch - \\'a\\'] == 1)\\n            total++;\\n    return total == 26;\\n}\\n```\\n**Java**\\n```java\\npublic boolean checkIfPangram(String sentence) {\\n    int cnt[] = new int[26], total = 0;\\n    for (var ch: sentence.toCharArray())\\n        if (++cnt[ch - \\'a\\'] == 1)\\n            total++;\\n    return total == 26;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool checkIfPangram(string sentence) {\\n    int cnt[26] = {}, total = 0;\\n    for (auto ch: sentence)\\n        if (++cnt[ch - \\'a\\'] == 1)\\n            total++;\\n    return total == 26;\\n}\\n```\n```java\\npublic boolean checkIfPangram(String sentence) {\\n    int cnt[] = new int[26], total = 0;\\n    for (var ch: sentence.toCharArray())\\n        if (++cnt[ch - \\'a\\'] == 1)\\n            total++;\\n    return total == 26;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2712517,
                "title": "java-using-frequency-array-using-set-using-hashmap",
                "content": "**1. using Frequency Array**\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int [] freq=new int[26];\\n        for(int i=0;i<sentence.length();i++){\\n            freq[sentence.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(freq[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**2. using HashSet**\\n\\n```\\nclass Solution{\\n    public boolean checkIfPangram(String sentence){\\n        Set<Character> set=new HashSet<>();\\n        for(int i=0;i<sentence.length();i++){\\n            set.add(sentence.charAt(i));\\n        }\\n        if(set.size()==26){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**3. using HashMap**\\n\\n```\\nclass Solution{\\n    public boolean checkIfPangram(String sentence){\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        for(int i=0;i<sentence.length();i++){\\n            hm.put(sentence.charAt(i),0);\\n        }\\n        if(hm.size()==26){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int [] freq=new int[26];\\n        for(int i=0;i<sentence.length();i++){\\n            freq[sentence.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(freq[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution{\\n    public boolean checkIfPangram(String sentence){\\n        Set<Character> set=new HashSet<>();\\n        for(int i=0;i<sentence.length();i++){\\n            set.add(sentence.charAt(i));\\n        }\\n        if(set.size()==26){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution{\\n    public boolean checkIfPangram(String sentence){\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        for(int i=0;i<sentence.length();i++){\\n            hm.put(sentence.charAt(i),0);\\n        }\\n        if(hm.size()==26){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166400,
                "title": "simple-python-solution-o-n",
                "content": "__Goal__: We need to check if all the letters from a-z have occured atleast once or not in a given sentence\\n\\n### Approach:\\n\\n- We don\\'t care if any letter between a-z occurs more than once.\\n- So we get only the single occurances of each character in the string by converting it into a set which is an ordered sequence of unique elements.\\n- Now, we need to check if all the elements between a-z are there. In other words, if our resulting set has all  the 26 letters of English alphabet\\n- So we just check if it\\'s length is 26.\\n\\n```python\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n\\n        return len(set(sentence)) == 26\\n```\\n\\n__TIME COMPLEXITY__: O(n)\\n\\n- set(str) would be O(k) where k is the length of the string k . [Reference](https://stackoverflow.com/questions/34642155/what-is-time-complexity-of-a-list-to-set-conversion/34642209)\\n- len() has O(1) in python. [Reference](https://stackoverflow.com/questions/1115313/cost-of-len-function)\\n\\n_NOTE_: In case you have anything to add or suggest any corrections, please do so in the comments. I am open to feedback!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n\\n        return len(set(sentence)) == 26\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005266,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:   \\n    bool checkIfPangram(string s) {\\n        vector<int>v(26);\\n        for(int p=0;p<s.length();p++){\\n            v[s[p]-97]++;\\n        }\\n        for(int p=0;p<26;p++){\\n            if(v[p]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    bool checkIfPangram(string s) {\\n        vector<int>v(26);\\n        for(int p=0;p<s.length();p++){\\n            v[s[p]-97]++;\\n        }\\n        for(int p=0;p<26;p++){\\n            if(v[p]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277373,
                "title": "python-2-different-approaches-beats-96-time-o-1-solution",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        \\n        # naive approach - 1\\n        # freq = {}\\n        # for i in sentence:\\n        #     freq[i] = freq.get(i, 0) + 1\\n        # if len(freq) == 26: return True\\n        # return False\\n        \\n        # optimized approach - 2\\n        occurred = 0\\n        for i in sentence:\\n            temp = ord(i) - ord(\\'a\\')\\n            occurred |= (1 << temp)\\n        if occurred == (1 << 26) - 1:\\n            return True\\n        return False\\n```\\nFor more such solutions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        \\n        # naive approach - 1\\n        # freq = {}\\n        # for i in sentence:\\n        #     freq[i] = freq.get(i, 0) + 1\\n        # if len(freq) == 26: return True\\n        # return False\\n        \\n        # optimized approach - 2\\n        occurred = 0\\n        for i in sentence:\\n            temp = ord(i) - ord(\\'a\\')\\n            occurred |= (1 << temp)\\n        if occurred == (1 << 26) - 1:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196552,
                "title": "one-liner-faster-than-97-solution",
                "content": "```\\ndef checkIfPangram(self, s: str) -> bool:\\n        return True if len(set(s))==26 else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef checkIfPangram(self, s: str) -> bool:\\n        return True if len(set(s))==26 else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2712760,
                "title": "easy-1-liner-0-ms-100-explained-java-c-python-js-python3",
                "content": "A pangram is a sentence where every letter of the English alphabet appears at least once...\\nGiven a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise...\\n\\n# **Java Solution:**\\n```\\n// Time Complexity: O(n)\\n// Space Complexity: O(1)\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        // Create a hashSet containing only unique values...\\n        Set<Character> hset = new HashSet<>();\\n        // Add all elements to hset...\\n        for (final char ch : sentence.toCharArray())\\n            hset.add(ch);\\n        // Check the size of the hset if it is 26 then the string is a pangram...\\n        return hset.size() == 26;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n/** Approach 1 **/\\n// Time Complexity: O(n)\\n// Space Complexity: O(1)\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Check if the Sentence Is Pangram.\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        // Add all elements to set and check if there are 26 different letters...\\n        return set<char>(begin(sentence), end(sentence)).size() == 26;\\n    }\\n};\\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\\n/** Approach 2 **/\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        // Check if length of sentence is less than 26, then return false...\\n        if (sentence.size() < 26) return false;\\n        // Declare an Array with a size of 26 & initialize each index value as 0...\\n        int arr[26] = {0};\\n        // Iterate every character of the given string and store the occurrence of the particular character...\\n        for(char ch : sentence) {\\n            // If ch equal to space, continue...\\n            if (ch == \\' \\') continue;\\n            // Initialize a index...\\n            // Suppose a character is \\u2018a\\u2018. then idx = (int)a-97 = 97 \\u2013 97 = 0...\\n            int idx = (int)ch - 97;\\n            // arr[idx] = arr[idx] + 1 => arr[0] = arr[0] + 1 = 0 + 1 = 1...\\n            arr[idx]++;\\n        }\\n        for (int i : arr) {\\n            // Now check if any value of the arr is 0 then the string is not a Pangram...\\n            if (i == 0)\\n                return false;\\n        }\\n        // Otherwise the sentece is a Pangram...\\n        return true;\\n    }\\n};\\n```\\n\\n# **Python / Python3 Solution:**\\n```\\n# Time Complexity: O(n)\\n# Space Complexity: O(1)\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        # Add all elements to set and check if there are 26 different letters...\\n        return len(set(sentence)) == 26\\n```\\n            \\n# **JavaScript Solution:**\\n```\\n// Time Complexity: O(n)\\n// Space Complexity: O(1)\\nvar checkIfPangram = function(sentence) {\\n    return new Set(sentence.split(\"\")).size === 26\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// Time Complexity: O(n)\\n// Space Complexity: O(1)\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        // Create a hashSet containing only unique values...\\n        Set<Character> hset = new HashSet<>();\\n        // Add all elements to hset...\\n        for (final char ch : sentence.toCharArray())\\n            hset.add(ch);\\n        // Check the size of the hset if it is 26 then the string is a pangram...\\n        return hset.size() == 26;\\n    }\\n}\\n```\n```\\n/** Approach 1 **/\\n// Time Complexity: O(n)\\n// Space Complexity: O(1)\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Check if the Sentence Is Pangram.\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        // Add all elements to set and check if there are 26 different letters...\\n        return set<char>(begin(sentence), end(sentence)).size() == 26;\\n    }\\n};\\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\\n/** Approach 2 **/\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        // Check if length of sentence is less than 26, then return false...\\n        if (sentence.size() < 26) return false;\\n        // Declare an Array with a size of 26 & initialize each index value as 0...\\n        int arr[26] = {0};\\n        // Iterate every character of the given string and store the occurrence of the particular character...\\n        for(char ch : sentence) {\\n            // If ch equal to space, continue...\\n            if (ch == \\' \\') continue;\\n            // Initialize a index...\\n            // Suppose a character is \\u2018a\\u2018. then idx = (int)a-97 = 97 \\u2013 97 = 0...\\n            int idx = (int)ch - 97;\\n            // arr[idx] = arr[idx] + 1 => arr[0] = arr[0] + 1 = 0 + 1 = 1...\\n            arr[idx]++;\\n        }\\n        for (int i : arr) {\\n            // Now check if any value of the arr is 0 then the string is not a Pangram...\\n            if (i == 0)\\n                return false;\\n        }\\n        // Otherwise the sentece is a Pangram...\\n        return true;\\n    }\\n};\\n```\n```\\n# Time Complexity: O(n)\\n# Space Complexity: O(1)\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        # Add all elements to set and check if there are 26 different letters...\\n        return len(set(sentence)) == 26\\n```\n```\\n// Time Complexity: O(n)\\n// Space Complexity: O(1)\\nvar checkIfPangram = function(sentence) {\\n    return new Set(sentence.split(\"\")).size === 26\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712442,
                "title": "simple-c-soln",
                "content": "```\\nclass Solution {\\npublic:   \\n    bool checkIfPangram(string s) {\\n        vector<int>v(26);\\n        for(int p=0;p<s.length();p++){\\n            v[s[p]-97]++;\\n        }\\n        for(int p=0;p<26;p++){\\n            if(v[p]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:   \\n    bool checkIfPangram(string s) {\\n        vector<int>v(26);\\n        for(int p=0;p<s.length();p++){\\n            v[s[p]-97]++;\\n        }\\n        for(int p=0;p<26;p++){\\n            if(v[p]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573442,
                "title": "simple-python3-solution-one-line-faster",
                "content": "***UPVOTE*** me if it is helpful**\\n``` \\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return(len(set(list(sentence))) == 26)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return(len(set(list(sentence))) == 26)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455103,
                "title": "java-0ms-solution-faster-than-100-of-solutions",
                "content": "```\\n    //Runtime: 0 ms, faster than 100.00% of Java online submissions for Check if the Sentence Is Pangram.\\n    public boolean checkIfPangram(String sentence) {\\n        String alphabet = \"abcdefghijklmnopqrstuvwxyz\";    \\n        for (char ch : alphabet.toCharArray()) {\\n            if (sentence.indexOf(ch) == -1) return false;\\n        }        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //Runtime: 0 ms, faster than 100.00% of Java online submissions for Check if the Sentence Is Pangram.\\n    public boolean checkIfPangram(String sentence) {\\n        String alphabet = \"abcdefghijklmnopqrstuvwxyz\";    \\n        for (char ch : alphabet.toCharArray()) {\\n            if (sentence.indexOf(ch) == -1) return false;\\n        }        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717561,
                "title": "optimizing-space-complexity-using-bitmasks-with-intuition",
                "content": "```\\nbool checkIfPangram(string sentence) {\\n\\tint mask = 0;\\n\\tfor(char &c : sentence) mask |= (1 << (c - \\'a\\'));\\n\\treturn (1 + mask) == (1 << 26);\\n}\\n```\\n\\n**Space Complexity**\\n*We can reduce our space complexity from* \\n* **O( 26 * 4bytes (*int*) )** using set / hashset to\\n* **O( 26 * 1byte (*bool*) )** using boolean array to\\n* **O( 4bytes (*int*) )** using a single integer\\n\\n\\n**Intuition**\\n* A boolean array can be used to mark the characters which occur in the string.\\n* The boolean values can be represented using bits of an integer.\\n* Since there are only 26 characters, we can easily accomodate them inside the available 31 bits of an integer.\\n\\n\\n**Advantage of integer over boolean array**\\n* In order to check presence of characters in the boolean array, you have to use a loop of size 26.\\n* For an integer, If all the characters are present, the integer will have 26 bits[0 - 25] set from its left end.\\n* Adding another 1 to it will set the 26th bit and unset the bits on the right.\\n*eg : 0111 + 1 = 1000*\\n* Thus the condition can be checked in a single step, removing the need of a loop. (*please refer the source code*)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nbool checkIfPangram(string sentence) {\\n\\tint mask = 0;\\n\\tfor(char &c : sentence) mask |= (1 << (c - \\'a\\'));\\n\\treturn (1 + mask) == (1 << 26);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717476,
                "title": "js-hash-table-with-explanation",
                "content": "To solve this problem, we can use a Hash table (in this case, I use Set()). \\n**The first** thing to do is check for the number of characters in the string, if it is less than 26, it makes no sense to check it. \\nIf the string is still larger, we **create a new Set()**, filling it with characters from the string, and setting its size to 26, since Set() can only store **unique** values, 26 unique letters will fall into it, which will mean the **true** in this task, otherwise, if there are less than 26 unique letters - **false**.\\n\\n```\\nvar checkIfPangram = function (sentence) {\\n\\n    if (sentence.length < 26) return false;\\n    return new Set(sentence.split(\"\")).size === 26;\\n\\n};\\n```\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nvar checkIfPangram = function (sentence) {\\n\\n    if (sentence.length < 26) return false;\\n    return new Set(sentence.split(\"\")).size === 26;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2712098,
                "title": "easy-to-understand-java-solution",
                "content": "The thinking is intuitive:\\n\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        boolean a = false;\\n        boolean b = false;\\n        boolean c = false;\\n        boolean d = false;\\n        boolean e = false;\\n        boolean f = false;\\n        boolean g = false;\\n        boolean h = false;\\n        boolean ii = false;\\n        boolean j = false;\\n        boolean k = false;\\n        boolean l = false;\\n        boolean m = false;\\n        boolean n = false;\\n        boolean o = false;\\n        boolean p = false;\\n        boolean q = false;\\n        boolean r = false;\\n        boolean s = false;\\n        boolean t = false;\\n        boolean u = false;\\n        boolean v = false;\\n        boolean w = false;\\n        boolean x = false;\\n        boolean y = false;\\n        boolean z = false;\\n        for (int i = 0; i < sentence.length(); i++) {\\n            if (sentence.charAt(i) == \\'a\\') {\\n                a = true;\\n            } else if (sentence.charAt(i) == \\'b\\') {\\n                b = true;\\n            } else if (sentence.charAt(i) == \\'c\\') {\\n                c = true;\\n            } else if (sentence.charAt(i) == \\'d\\') {\\n                d = true;\\n            } else if (sentence.charAt(i) == \\'e\\') {\\n                e = true;\\n            } else if (sentence.charAt(i) == \\'f\\') {\\n                f = true;\\n            } else if (sentence.charAt(i) == \\'g\\') {\\n                g = true;\\n            } else if (sentence.charAt(i) == \\'h\\') {\\n                h = true;\\n            } else if (sentence.charAt(i) == \\'i\\') {\\n                ii = true;\\n            } else if (sentence.charAt(i) == \\'j\\') {\\n                j = true;\\n            } else if (sentence.charAt(i) == \\'k\\') {\\n                k = true;\\n            } else if (sentence.charAt(i) == \\'l\\') {\\n                l = true;\\n            } else if (sentence.charAt(i) == \\'m\\') {\\n                m = true;\\n            } else if (sentence.charAt(i) == \\'n\\') {\\n                n = true;\\n            } else if (sentence.charAt(i) == \\'o\\') {\\n                o = true;\\n            } else if (sentence.charAt(i) == \\'p\\') {\\n                p = true;\\n            } else if (sentence.charAt(i) == \\'q\\') {\\n                q = true;\\n            } else if (sentence.charAt(i) == \\'r\\') {\\n                r = true;\\n            } else if (sentence.charAt(i) == \\'s\\') {\\n                s = true;\\n            } else if (sentence.charAt(i) == \\'t\\') {\\n                t = true;\\n            } else if (sentence.charAt(i) == \\'u\\') {\\n                u = true;\\n            } else if (sentence.charAt(i) == \\'v\\') {\\n                v = true;\\n            } else if (sentence.charAt(i) == \\'w\\') {\\n                w = true;\\n            } else if (sentence.charAt(i) == \\'x\\') {\\n                x = true;\\n            } else if (sentence.charAt(i) == \\'y\\') {\\n                y = true;\\n            } else if (sentence.charAt(i) == \\'z\\') {\\n                z = true;\\n            }\\n        }\\n        return a && b && c && d && e && f && g && h && ii && j && k && l && m && n && o && p && q && r && s && t && u && v && w && x && y && z;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        boolean a = false;\\n        boolean b = false;\\n        boolean c = false;\\n        boolean d = false;\\n        boolean e = false;\\n        boolean f = false;\\n        boolean g = false;\\n        boolean h = false;\\n        boolean ii = false;\\n        boolean j = false;\\n        boolean k = false;\\n        boolean l = false;\\n        boolean m = false;\\n        boolean n = false;\\n        boolean o = false;\\n        boolean p = false;\\n        boolean q = false;\\n        boolean r = false;\\n        boolean s = false;\\n        boolean t = false;\\n        boolean u = false;\\n        boolean v = false;\\n        boolean w = false;\\n        boolean x = false;\\n        boolean y = false;\\n        boolean z = false;\\n        for (int i = 0; i < sentence.length(); i++) {\\n            if (sentence.charAt(i) == \\'a\\') {\\n                a = true;\\n            } else if (sentence.charAt(i) == \\'b\\') {\\n                b = true;\\n            } else if (sentence.charAt(i) == \\'c\\') {\\n                c = true;\\n            } else if (sentence.charAt(i) == \\'d\\') {\\n                d = true;\\n            } else if (sentence.charAt(i) == \\'e\\') {\\n                e = true;\\n            } else if (sentence.charAt(i) == \\'f\\') {\\n                f = true;\\n            } else if (sentence.charAt(i) == \\'g\\') {\\n                g = true;\\n            } else if (sentence.charAt(i) == \\'h\\') {\\n                h = true;\\n            } else if (sentence.charAt(i) == \\'i\\') {\\n                ii = true;\\n            } else if (sentence.charAt(i) == \\'j\\') {\\n                j = true;\\n            } else if (sentence.charAt(i) == \\'k\\') {\\n                k = true;\\n            } else if (sentence.charAt(i) == \\'l\\') {\\n                l = true;\\n            } else if (sentence.charAt(i) == \\'m\\') {\\n                m = true;\\n            } else if (sentence.charAt(i) == \\'n\\') {\\n                n = true;\\n            } else if (sentence.charAt(i) == \\'o\\') {\\n                o = true;\\n            } else if (sentence.charAt(i) == \\'p\\') {\\n                p = true;\\n            } else if (sentence.charAt(i) == \\'q\\') {\\n                q = true;\\n            } else if (sentence.charAt(i) == \\'r\\') {\\n                r = true;\\n            } else if (sentence.charAt(i) == \\'s\\') {\\n                s = true;\\n            } else if (sentence.charAt(i) == \\'t\\') {\\n                t = true;\\n            } else if (sentence.charAt(i) == \\'u\\') {\\n                u = true;\\n            } else if (sentence.charAt(i) == \\'v\\') {\\n                v = true;\\n            } else if (sentence.charAt(i) == \\'w\\') {\\n                w = true;\\n            } else if (sentence.charAt(i) == \\'x\\') {\\n                x = true;\\n            } else if (sentence.charAt(i) == \\'y\\') {\\n                y = true;\\n            } else if (sentence.charAt(i) == \\'z\\') {\\n                z = true;\\n            }\\n        }\\n        return a && b && c && d && e && f && g && h && ii && j && k && l && m && n && o && p && q && r && s && t && u && v && w && x && y && z;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485678,
                "title": "best-solution-for-sure",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        int res = ((1 << 26) - 1),check = 0;\\n        for(int i = 0; i < sentence.size(); i++)\\n        {\\n            check = check | (1 << (sentence[i] - \\'a\\'));\\n            if(check == res) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        int res = ((1 << 26) - 1),check = 0;\\n        for(int i = 0; i < sentence.size(); i++)\\n        {\\n            check = check | (1 << (sentence[i] - \\'a\\'));\\n            if(check == res) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174705,
                "title": "java-bitwise-or-1-ms",
                "content": "This solution uses 26 bits in an integer for each of the 26 lowercase English letters. Then, it checks if all the 26 least significant bits are set.\\n\\nTime complexity: `O(N)`.\\nSpace complexity: `O(N)`.\\n\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        var seen = 0;\\n        for (var i = 0; i < sentence.length(); i++) {\\n            seen |= 1 << (sentence.charAt(i) - \\'a\\');\\n        }\\n        return seen == (1 << 26) - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        var seen = 0;\\n        for (var i = 0; i < sentence.length(); i++) {\\n            seen |= 1 << (sentence.charAt(i) - \\'a\\');\\n        }\\n        return seen == (1 << 26) - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164098,
                "title": "java-python-3-two-codes-count-the-chars-in-sentence",
                "content": "**Method 1**\\n\\n**Java**\\n\\n```java\\n    public boolean checkIfPangram(String sentence) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < sentence.length(); ++i) {\\n            ++cnt[sentence.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt[i] == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\nMake the above to 1 pass as follows:\\n\\n```java\\n    public boolean checkIfPangram(String sentence) {\\n        int[] cnt = new int[26];\\n        for (int i = 0, pan = 0; i < sentence.length(); ++i) {\\n            if (++cnt[sentence.charAt(i) - \\'a\\'] == 1 && ++pan == 26) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n```python\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(Counter(sentence)) == 26\\n```\\n\\n----\\n\\n**Method 2: Bit Manipulation** -- credit to **@KenpachiZaraki1**.\\n\\n```java\\n    public boolean checkIfPangram(String sentence) {\\n        for (int i = 0, cnt = 0, pan = (1 << 26) - 1; i < sentence.length(); ++i) {\\n            cnt |= 1 << sentence.charAt(i) - \\'a\\';\\n            if (cnt == pan) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n```python\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        cnt, pan = 0, (1 << 26) - 1\\n        for c in sentence:\\n            cnt |= 1 << ord(c) - ord(\\'a\\')\\n            if cnt == pan:\\n                return True\\n        return False\\n```\\nIn case you are interested in one liner:\\n```java\\n    public boolean checkIfPangram(String sentence) {\\n        return sentence.chars().map(i -> 1 << i - \\'a\\').reduce(0, (a, b) -> a | b) == (1 << 26) - 1;\\n    }\\n```\\n```python\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return functools.reduce(operator.ior, map(lambda c: 1 << ord(c) - ord(\\'a\\'), sentence)) == (1 << 26) - 1\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = sentence.length()`.",
                "solutionTags": [],
                "code": "```java\\n    public boolean checkIfPangram(String sentence) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < sentence.length(); ++i) {\\n            ++cnt[sentence.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt[i] == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```java\\n    public boolean checkIfPangram(String sentence) {\\n        int[] cnt = new int[26];\\n        for (int i = 0, pan = 0; i < sentence.length(); ++i) {\\n            if (++cnt[sentence.charAt(i) - \\'a\\'] == 1 && ++pan == 26) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```python\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(Counter(sentence)) == 26\\n```\n```java\\n    public boolean checkIfPangram(String sentence) {\\n        for (int i = 0, cnt = 0, pan = (1 << 26) - 1; i < sentence.length(); ++i) {\\n            cnt |= 1 << sentence.charAt(i) - \\'a\\';\\n            if (cnt == pan) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```python\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        cnt, pan = 0, (1 << 26) - 1\\n        for c in sentence:\\n            cnt |= 1 << ord(c) - ord(\\'a\\')\\n            if cnt == pan:\\n                return True\\n        return False\\n```\n```java\\n    public boolean checkIfPangram(String sentence) {\\n        return sentence.chars().map(i -> 1 << i - \\'a\\').reduce(0, (a, b) -> a | b) == (1 << 26) - 1;\\n    }\\n```\n```python\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return functools.reduce(operator.ior, map(lambda c: 1 << ord(c) - ord(\\'a\\'), sentence)) == (1 << 26) - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3561516,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            if(sentence.indexOf(i) < 0) {\\n                return false;\\n            }\\n        }\\n       return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            if(sentence.indexOf(i) < 0) {\\n                return false;\\n            }\\n        }\\n       return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472710,
                "title": "java-basic-and-simple-logic-0ms-100-faster-40-6-mb-beats-76-in-memory-clean-code",
                "content": "# Intuition\\nRun a loop over letter a - z and check whether each char occurs in the String\\n\\n# Approach\\nIterate over 26 available alphabets and check whether we have the character in the String.\\n\\n# Complexity\\n- Time complexity:\\nO(1). Instead of running over every character in the string which can range from 0 to 1000, we can run over 26 alphabets. \\n\\n- Space complexity:\\nUse byte type to declare the iterator variable since we need numbers from 97 to 122 inclusive. Using byte will consume 1 byte where int consumes 4 bytes of memory.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for( byte i = 97;i<=122;i++ ){\\n            if( sentence.indexOf( i ) == -1 ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for( byte i = 97;i<=122;i++ ){\\n            if( sentence.indexOf( i ) == -1 ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712897,
                "title": "easy-and-simple-java-solution-using-arrays",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        //declare a array to maintain every char occurance\\n        int a[]=new int[26];\\n        //traverse String\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            int ch;\\n            ch=sentence.charAt(i);\\n            if(a[ch-97]==1)\\n                continue;\\n            else\\n                a[ch-97]=1;\\n        }\\n        //traverse the Array to check for every char occurance \\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]!=1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        //declare a array to maintain every char occurance\\n        int a[]=new int[26];\\n        //traverse String\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            int ch;\\n            ch=sentence.charAt(i);\\n            if(a[ch-97]==1)\\n                continue;\\n            else\\n                a[ch-97]=1;\\n        }\\n        //traverse the Array to check for every char occurance \\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]!=1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711772,
                "title": "daily-leetcoding-challenge-october-day-17",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/check-if-the-sentence-is-pangram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/check-if-the-sentence-is-pangram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2601657,
                "title": "0ms-java-easy-solution-w-array-indexof",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if (sentence.length() < 26) {\\n            return false;\\n        }\\n\\n        int[] tracer = new int[26]; //For Storing Index of a-z charecters from sentence;\\n        char alpha = \\'a\\'; \\n        for (int i = 0; i < tracer.length; i++) {\\n            tracer[i] = sentence.indexOf(alpha); //assigning index of alphabets\\n            \\n            if (tracer[i] == -1) {\\n                return false; \\n                //if any alphabet isn\\'t present -1 will be stored in array && return with false value;\\n            }\\n            alpha++; //else increment of alphabet\\n\\n        }\\n        return true; //there isn\\'t any -1 stored in array so every alphabet will be present\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if (sentence.length() < 26) {\\n            return false;\\n        }\\n\\n        int[] tracer = new int[26]; //For Storing Index of a-z charecters from sentence;\\n        char alpha = \\'a\\'; \\n        for (int i = 0; i < tracer.length; i++) {\\n            tracer[i] = sentence.indexOf(alpha); //assigning index of alphabets\\n            \\n            if (tracer[i] == -1) {\\n                return false; \\n                //if any alphabet isn\\'t present -1 will be stored in array && return with false value;\\n            }\\n            alpha++; //else increment of alphabet\\n\\n        }\\n        return true; //there isn\\'t any -1 stored in array so every alphabet will be present\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250518,
                "title": "python3-o-n-o-1-or-o-26-runtime-40ms-71-99-memory-13-9mb-54-83",
                "content": "```\\nclass Solution:\\n#     O(n) || O(1) because we are dealing with lower case english alphabets O(26)\\n# Runtime: 40ms 71.99% || Memory: 13.9mb 54.83%\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        allAlpha = [False] * 26\\n\\n        for char in sentence:\\n            index = ord(char) - ord(\\'a\\')\\n            allAlpha[index] = True\\n\\n\\n        return all(allAlpha[i] for i in range(26))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(1) because we are dealing with lower case english alphabets O(26)\\n# Runtime: 40ms 71.99% || Memory: 13.9mb 54.83%\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        allAlpha = [False] * 26\\n\\n        for char in sentence:\\n            index = ord(char) - ord(\\'a\\')\\n            allAlpha[index] = True\\n\\n\\n        return all(allAlpha[i] for i in range(26))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684074,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Python**\\n```\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        return len(set(sentence)) == 26\\n```\\n**JavaScript**\\n```\\nvar checkIfPangram = function(sentence) {\\n    return new Set(sentence).size == 26;\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set set = new HashSet<>();\\n        for(char c : sentence.toCharArray())    set.add(c);\\n        return set.size() == 26;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        return len(set(sentence)) == 26\\n```\n```\\nvar checkIfPangram = function(sentence) {\\n    return new Set(sentence).size == 26;\\n};\\n```\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set set = new HashSet<>();\\n        for(char c : sentence.toCharArray())    set.add(c);\\n        return set.size() == 26;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566783,
                "title": "java-simple-solution-100-faster",
                "content": "Instead of iterating through sentence string, iterating through these 26 characters will be faster.\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length() < 26) return false;\\n        for(char c = \\'a\\' ; c <= \\'z\\'; c++){\\n            if(sentence.indexOf(c) == -1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length() < 26) return false;\\n        for(char c = \\'a\\' ; c <= \\'z\\'; c++){\\n            if(sentence.indexOf(c) == -1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424271,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] count = new int[26];\\n        for (char ch : sentence.toCharArray()) {\\n            count[ch - \\'a\\']++;\\n        }\\n        for (int i : count) {\\n            if (i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\nfeel free to ask any question\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] count = new int[26];\\n        for (char ch : sentence.toCharArray()) {\\n            count[ch - \\'a\\']++;\\n        }\\n        for (int i : count) {\\n            if (i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\nfeel free to ask any question\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287779,
                "title": "c-bit-manipulation",
                "content": "Edit : Adding explanation\\n\\nWe need to check if a string has all the 26 lowercase english alphabets from \\'a\\' to \\'z\\'. Also, we do not care about the number of occurances, the only thing we need to check is : each character should have atleast 1 occurance. So we can use a set and keep inserting all the characters of the string till the end and finally we can check if the set size is equal to 26. But we can notice that in summary we are only required to store 26 elements at max in the set so we can use bit manipulation instead of a set to do it. \\nWe can use an integer\\'s 26 least significant bits to store presence of each character , i.e.\\n\\n\\n```\\nb26 b25 ... b2 b1\\n```\\n\\nwhere `bi` is the bit at `ith` position. We will set `ith` bit if we have `ith` english lowercase alphabet in the string (starting from \\'a\\' ). We will iterate over the string, store the presence of each lowercase english alphabet like below : \\n\\ne.g. If we get \\'a\\' , we will set the 1st bit using , \\n```\\nn = n | (1<<(c-\\'a\\'))\\n```\\nThis will set the 1st bit ( read [this](https://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit) if you are unable to understand the above statement ) , similarly if we get \\'z\\', we will set the 26th bit and at last, after we are done iterating over the complete string, we just need to check if all the 26bits of the number are set (i.e. all the 26 lowercase english alphabtes are present in the input string). We can do this by 1 simple observation, \\n```\\n1111 (base 2) = 15 (base 10)\\n111111 (base 2) = 63 (base 10)\\n```\\n\\nIn general, if the `n` bit binary number contains only `n` set bits, then its decimal equivalent = `2^(number of bits) - 1` \\n\\nSo, we can check if all bits are set using above observation and return true only if \\n\\n```\\nn == pow(2,26) -1\\n```\\n\\nC++ CODE : \\n\\n```    \\nbool checkIfPangram(string s) {\\n        int n = 0;\\n        for(char c:s){\\n            n = n | (1<<(c-\\'a\\')); // set character\\'s corresponding bit\\n        }\\n        return n==pow(2,26)-1; // check if all 26 bits are set\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nb26 b25 ... b2 b1\\n```\n```\\nn = n | (1<<(c-\\'a\\'))\\n```\n```\\n1111 (base 2) = 15 (base 10)\\n111111 (base 2) = 63 (base 10)\\n```\n```\\nn == pow(2,26) -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1250922,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return all(letter in sentence for letter in \\'abcdefghijklmnopqrstuvwxyz\\')\\n```\\nRuntime: 28 ms, **faster than 86.51%** of Python3 online submissions for Check if the Sentence Is Pangram.\\nMemory Usage: 14 MB, **less than 91.22%** of Python3 online submissions for Check if the Sentence Is Pangram.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return all(letter in sentence for letter in \\'abcdefghijklmnopqrstuvwxyz\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173959,
                "title": "python-one-liner-faster-than-99-15",
                "content": "\\n\\t\\tdef checkIfPangram(self, sentence):\\n\\t\\t\\treturn len(set(sentence)) == 26\\n\\t\\t\\t\\n\\t\\t\\t\\nEdited: The code is more optamized by @chrislwzy. Thanks buddy.",
                "solutionTags": [],
                "code": "\\n\\t\\tdef checkIfPangram(self, sentence):\\n\\t\\t\\treturn len(set(sentence)) == 26\\n\\t\\t\\t\\n\\t\\t\\t\\nEdited: The code is more optamized by @chrislwzy. Thanks buddy.",
                "codeTag": "Python3"
            },
            {
                "id": 1164229,
                "title": "java-beginner-friendly-constant-space",
                "content": "**Given constraint :**\\n`sentence consists of lowercase English letters.`\\nIdea is to make a 26 size array (representing a to z ) and mark the presence of character in it.\\n\\n**CODE:**\\n```\\n public boolean checkIfPangram(String sentence) {\\n         boolean[] arr=new boolean[26];\\n        for(char ch:sentence.toCharArray()){\\n             int idx=(int)(ch-\\'a\\');\\n            arr[idx]=true;\\n        }\\n       \\n         for(boolean val:arr){\\n             if(!val) return false;\\n         }\\n        return true;\\n    }\\n```\\n\\n**Complexity:**\\n`Time:O(n) and Space:O(1) [ constant space]`\\n\\nPlease **UPVOTE** if found it helpful :). Feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public boolean checkIfPangram(String sentence) {\\n         boolean[] arr=new boolean[26];\\n        for(char ch:sentence.toCharArray()){\\n             int idx=(int)(ch-\\'a\\');\\n            arr[idx]=true;\\n        }\\n       \\n         for(boolean val:arr){\\n             if(!val) return false;\\n         }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164034,
                "title": "c-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int> vec(26,0);\\n        for(char ch : sentence){\\n            vec[ch-\\'a\\']++;\\n        }\\n        int zero_count = count(vec.begin(), vec.end(), 0);\\n        return zero_count==0;\\n    }\\n};\\n``` \\n\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_set<char> set(sentence.begin(), sentence.end());\\n        return set.size() == 26;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case,**please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int> vec(26,0);\\n        for(char ch : sentence){\\n            vec[ch-\\'a\\']++;\\n        }\\n        int zero_count = count(vec.begin(), vec.end(), 0);\\n        return zero_count==0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_set<char> set(sentence.begin(), sentence.end());\\n        return set.size() == 26;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235498,
                "title": "java-100-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length() < 26)\\n        return false;\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n            if(!sentence.contains(String.valueOf(c)))\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length() < 26)\\n        return false;\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n            if(!sentence.contains(String.valueOf(c)))\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739808,
                "title": "python-2-lines-sets-t-m-98-45",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return  len(set(sentence)) == 26\\n```\\nhttps://leetcode.com/submissions/detail/599255950/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return  len(set(sentence)) == 26\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714193,
                "title": "python-rust-just-one-liners-using-hashset-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n\\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/824403614/) employs a simple one-liner using *set*. It demonstrated **28 ms runtime (97.56%)** and used **13.8 MB memory (95.55%)**. Time complexity is linear: **O(n)**. Space complexity is constant: **O(1)**. \\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        # in Python, a set can automatically be constructed\\n        # from iterables such as strings, lists, ...\\n        return len(set(sentence)) == 26\\n```\\n\\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/824403614/) employs a simple one-liner using *HashSet*. It demonstrated **0 ms runtime (100.00%)** and used **2.2 MB memory (26.92%)**. Time complexity is linear: **O(n)**. Space complexity is constant: **O(1)**. \\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution \\n{\\n    pub fn check_if_pangram(sentence: String) -> bool \\n    {\\n        // in Rust, a HashSet can automatically be\\n        // built (collected) from an iterator \\n        sentence.chars().collect::<HashSet<char>>().len() == 26\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        # in Python, a set can automatically be constructed\\n        # from iterables such as strings, lists, ...\\n        return len(set(sentence)) == 26\\n```\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution \\n{\\n    pub fn check_if_pangram(sentence: String) -> bool \\n    {\\n        // in Rust, a HashSet can automatically be\\n        // built (collected) from an iterator \\n        sentence.chars().collect::<HashSet<char>>().len() == 26\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712785,
                "title": "daily-leetcoding-challenge-october-day-17",
                "content": "The approach followed here is very simple. We store the frequency of charecters in an array or a vector. Then we simply traverse through the array or vector to check if element is present at least once.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence)\\n    {\\n        int start=\\'a\\',end=\\'z\\';\\n        vector<int> a(26,0);\\n        for(char ch:sentence)\\n        {\\n            if(!(ch>=start && ch<=end))\\n                return false;\\n            a[ch-\\'a\\']++;\\n        }\\n        for(int i:a)\\n            if(i<1)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence)\\n    {\\n        int start=\\'a\\',end=\\'z\\';\\n        vector<int> a(26,0);\\n        for(char ch:sentence)\\n        {\\n            if(!(ch>=start && ch<=end))\\n                return false;\\n            a[ch-\\'a\\']++;\\n        }\\n        for(int i:a)\\n            if(i<1)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634189,
                "title": "begineer-friendly",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] arr = new int[26];\\n        \\n        // checks the frequency of the alphabets\\n        for(var i: sentence.toCharArray()){\\n            arr[i - \\'a\\']++;\\n        }\\n        \\n        // checks if any of the arr index contains zero\\n        for(var i: arr){\\n            if(i == 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] arr = new int[26];\\n        \\n        // checks the frequency of the alphabets\\n        for(var i: sentence.toCharArray()){\\n            arr[i - \\'a\\']++;\\n        }\\n        \\n        // checks if any of the arr index contains zero\\n        for(var i: arr){\\n            if(i == 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869212,
                "title": "python-easy-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        appear = {}\\n        for i in sentence:\\n            if i not in appear:\\n                appear[i] = 1\\n            else:\\n                appear[i] += 1\\n        if len(appear) == 26:\\n            return True\\n        return False",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "class Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        appear = {}",
                "codeTag": "Java"
            },
            {
                "id": 1775982,
                "title": "java-3-line-solution-88-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for(char c  = \\'a\\'; c <= \\'z\\'; c++)\\n            if(!sentence.contains(\"\"+c))return false;\\n        return true;\\n    }\\n}\\n```\\nPlease **UPVOTE** if you find this solution helpful.\\nThanks : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for(char c  = \\'a\\'; c <= \\'z\\'; c++)\\n            if(!sentence.contains(\"\"+c))return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684069,
                "title": "short-javascript-solution",
                "content": "**Time Complexity : O(n)**\\n```javascript []\\nvar checkIfPangram = function(sentence) {\\n    return new Set(sentence.split(\"\")).size == 26;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\nvar checkIfPangram = function(sentence) {\\n    return new Set(sentence.split(\"\")).size == 26;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563492,
                "title": "python-one-line-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef checkIfPangram(self, sentence: str) -> bool:\\n\\treturn set(sentence) == set(list(string.ascii_lowercase)) \\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkIfPangram(self, sentence: str) -> bool:\\n\\treturn set(sentence) == set(list(string.ascii_lowercase)) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1407237,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence)) == 26\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence)) == 26\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259085,
                "title": "python3-faster-than-86",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        if len(set(sentence.lower())) == 26:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        if len(set(sentence.lower())) == 26:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210398,
                "title": "simple-cpp-solution",
                "content": "bool checkIfPangram(string sentence) {\\n        \\n        set<char>s;\\n        for(int i=0;i<sentence.size();i++)\\n            s.insert(sentence[i]);\\n        int n=s.size();\\n        if(n==26)\\n            return true;\\n        else\\n            return false;\\n        \\n    }",
                "solutionTags": [],
                "code": "bool checkIfPangram(string sentence) {\\n        \\n        set<char>s;\\n        for(int i=0;i<sentence.size();i++)\\n            s.insert(sentence[i]);\\n        int n=s.size();\\n        if(n==26)\\n            return true;\\n        else\\n            return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1204908,
                "title": "c-simple-one-liner",
                "content": "```\\npublic class Solution {\\n    public bool CheckIfPangram(string s) {\\n        return ((new HashSet<char>(s)).Count == 26);      \\n}\\n```\\n\\nAnother Approach:\\n```\\npublic class Solution {\\n    public bool CheckIfPangram(string s) {\\n        return ((s.ToCharArray()).Distinct().Count()) == 26;\\n    }\\n}\\n```\\n\\n\\nAnother Approach:\\n```\\npublic class Solution {\\n    public bool CheckIfPangram(string s) {\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n            if(!s.Contains(ch))\\n                return false;\\n        return true;\\n    }\\n}\\n```\\n\\nAnother Approach:\\n```\\npublic class Solution {\\n    public bool CheckIfPangram(string s) {\\n        int[] count = new int[26];\\n        foreach(char ch in s)\\n            count[ch-\\'a\\']++;\\n        for(int i=0; i<26; i++)\\n            if(count[i] == 0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CheckIfPangram(string s) {\\n        return ((new HashSet<char>(s)).Count == 26);      \\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckIfPangram(string s) {\\n        return ((s.ToCharArray()).Distinct().Count()) == 26;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckIfPangram(string s) {\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n            if(!s.Contains(ch))\\n                return false;\\n        return true;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckIfPangram(string s) {\\n        int[] count = new int[26];\\n        foreach(char ch in s)\\n            count[ch-\\'a\\']++;\\n        for(int i=0; i<26; i++)\\n            if(count[i] == 0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164589,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn check_if_pangram(sentence: String) -> bool {\\n        sentence\\n            .as_bytes()\\n            .iter()\\n            .fold([false; 26], |mut count_arr, &x| {\\n                count_arr[(x - b\\'a\\') as usize] = true;\\n                count_arr\\n            })\\n            .iter()\\n            .all(|&x| x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_if_pangram(sentence: String) -> bool {\\n        sentence\\n            .as_bytes()\\n            .iter()\\n            .fold([false; 26], |mut count_arr, &x| {\\n                count_arr[(x - b\\'a\\') as usize] = true;\\n                count_arr\\n            })\\n            .iter()\\n            .all(|&x| x)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867613,
                "title": "c-solution-with-explanation-beats-100-of-c-solutions",
                "content": "# Approach\\nI just created a hashset of chars in the given string. Then checked every letter in English alphabet if it exists in the hashset using the letter\\'s ASCII code.\\n\\n# Runtime\\nBeats 100% of solutions with C#\\n\\n![image.png](https://assets.leetcode.com/users/images/daec8957-9e13-4870-9d05-a8889478deab_1691245447.3697243.png)\\n# Code\\n```\\npublic class Solution {\\n    public bool CheckIfPangram(string sentence) {\\n        var hashSet = new HashSet<char>(sentence);\\n        for (int i = 97; i <= 122; i++)\\n        {\\n            if(!hashSet.Contains((char)i))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckIfPangram(string sentence) {\\n        var hashSet = new HashSet<char>(sentence);\\n        for (int i = 97; i <= 122; i++)\\n        {\\n            if(!hashSet.Contains((char)i))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844366,
                "title": "easy-solution-java-and-python-0ms-runtime-optimised",
                "content": "# Code\\n```java []\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for (int i=97;i<=122;i++)\\n        {\\n            if(sentence.indexOf((char)i)<0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        for num in range(97,123):\\n            if chr(num) not in sentence:\\n                return False\\n        return True;\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```java []\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for (int i=97;i<=122;i++)\\n        {\\n            if(sentence.indexOf((char)i)<0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        for num in range(97,123):\\n            if chr(num) not in sentence:\\n                return False\\n        return True;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844352,
                "title": "easy-and-highly-optimized-solution-java-and-python-beats-100-runtime",
                "content": "```Java []\\n    public boolean checkIfPangram(String sentence) {\\n        for (int i=97;i<=122;i++)\\n        {\\n            if(sentence.indexOf((char)i)<0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        for num in range(97,123):\\n            if chr(num) not in sentence:\\n                return False\\n    \\xA0\\xA0\\xA0\\xA0return\\xA0True\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```Java []\\n    public boolean checkIfPangram(String sentence) {\\n        for (int i=97;i<=122;i++)\\n        {\\n            if(sentence.indexOf((char)i)<0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        for num in range(97,123):\\n            if chr(num) not in sentence:\\n                return False\\n    \\xA0\\xA0\\xA0\\xA0return\\xA0True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777353,
                "title": "beats-100-simple-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for(char i = \\'a\\'; i<=\\'z\\'; i++){\\n            if(sentence.indexOf(i)<0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        for(char i = \\'a\\'; i<=\\'z\\'; i++){\\n            if(sentence.indexOf(i)<0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189427,
                "title": "js-ts-one-liner-using-set-beats-94",
                "content": "# Intuition\\nJavascript\\'s set contains only unique values, and total of lowercase english alphabet is 26.\\n\\n# Approach\\n1. We split the characters in the sentence into an array.\\n2. Convert the array into a set.\\n3. Check if the set\\'s size is equal to 26.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunction checkIfPangram(sentence: string): boolean {\\n    return new Set(sentence.split(\"\")).size == 26;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction checkIfPangram(sentence: string): boolean {\\n    return new Set(sentence.split(\"\")).size == 26;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3022122,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:   \\n    bool checkIfPangram(string s) {\\n        vector<int>v(26);\\n        for(int p=0;p<s.length();p++){\\n            v[s[p]-97]++;\\n        }\\n        for(int p=0;p<26;p++){\\n            if(v[p]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    bool checkIfPangram(string s) {\\n        vector<int>v(26);\\n        for(int p=0;p<s.length();p++){\\n            v[s[p]-97]++;\\n        }\\n        for(int p=0;p<26;p++){\\n            if(v[p]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977758,
                "title": "o-1-java-solution-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n\\n    Character[] charArray = \\n    sentence.chars().mapToObj(c -> (char)c).toArray(Character[]::new); //don\\'t get confused about it because i also copied it from stack overflow , this function basically create the Character[] type array from the string.\\n\\n    List<Character>check=Arrays.asList(charArray);//now we convert the Character type of array into List<Character>\\n\\n    Set<Character>st=new HashSet<>(check);//now we store that list into set\\n    \\n    return st.size()==26;//as we all know that the set contains unique character so it is confirmed that if the set size is 26 which means that set contains all the characters from a to z.\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n\\n    Character[] charArray = \\n    sentence.chars().mapToObj(c -> (char)c).toArray(Character[]::new); //don\\'t get confused about it because i also copied it from stack overflow , this function basically create the Character[] type array from the string.\\n\\n    List<Character>check=Arrays.asList(charArray);//now we convert the Character type of array into List<Character>\\n\\n    Set<Character>st=new HashSet<>(check);//now we store that list into set\\n    \\n    return st.size()==26;//as we all know that the set contains unique character so it is confirmed that if the set size is 26 which means that set contains all the characters from a to z.\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841981,
                "title": "java-set-2-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nturn string into **character array** and then put those values into **SET** and as we know that SET doesn\\'t contain duplicate values, so after putting values in set, if the **size of set is less than 26,** then it is false, because english alpahbeth has 26 letters.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        char[] ch = sentence.toCharArray();\\n        Set<Character> s = new HashSet<>();\\n        for(char c:ch) s.add(c);\\n        return set.size() >= 26;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        char[] ch = sentence.toCharArray();\\n        Set<Character> s = new HashSet<>();\\n        for(char c:ch) s.add(c);\\n        return set.size() >= 26;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789382,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<Character>();\\n        int length = sentence.length();\\n        for (int i = 0; i < length; i++) {\\n            char c = sentence.charAt(i);\\n            if (c >= \\'a\\' && c <= \\'z\\')\\n                set.add(c);\\n        }\\n        return set.size() == 26;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<Character>();\\n        int length = sentence.length();\\n        for (int i = 0; i < length; i++) {\\n            char c = sentence.charAt(i);\\n            if (c >= \\'a\\' && c <= \\'z\\')\\n                set.add(c);\\n        }\\n        return set.size() == 26;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748086,
                "title": "0ms-solution",
                "content": "# C++ code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<short int> s(26);\\n\\n        // add 1 to corresponding ascii indexes in vector\\n        for(char x:sentence) s[x-\\'a\\']++;\\n\\n        // if any of the positions have 0, then that corresponding ascii character is missing\\n        // Eg, if sentence[3] is 0, then \\'d\\' is absent (since \\'d\\'-\\'a\\'=3)\\n        for (short int x:s) if (x==0) return false;\\n        \\n        // return true if all characters is present\\n        return true;\\n    }\\n};\\n```\\n\\nFeel free to ask away any doubts you have",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<short int> s(26);\\n\\n        // add 1 to corresponding ascii indexes in vector\\n        for(char x:sentence) s[x-\\'a\\']++;\\n\\n        // if any of the positions have 0, then that corresponding ascii character is missing\\n        // Eg, if sentence[3] is 0, then \\'d\\' is absent (since \\'d\\'-\\'a\\'=3)\\n        for (short int x:s) if (x==0) return false;\\n        \\n        // return true if all characters is present\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715601,
                "title": "python-solution-using-list",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        counter = [0 for _ in range(97, 123)]\\n        \\n        for i in sentence:\\n            counter[ord(i)-97] += 1\\n        \\n        for i in counter:\\n            if i == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        counter = [0 for _ in range(97, 123)]\\n        \\n        for i in sentence:\\n            counter[ord(i)-97] += 1\\n        \\n        for i in counter:\\n            if i == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715578,
                "title": "easy-java-solution-hashset-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for(int i = 0 ; i < sentence.length() ; i ++){\\n            hs.add(sentence.charAt(i));\\n            if(hs.size() == 26){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for(int i = 0 ; i < sentence.length() ; i ++){\\n            hs.add(sentence.charAt(i));\\n            if(hs.size() == 26){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715080,
                "title": "golang-short-solution",
                "content": "O(n) store O(n)\\n```\\nfunc checkIfPangram(sentence string) bool {\\n    store:=make(map[rune]struct{})\\n    for _,ch:=range sentence{\\n        if _,ok:=store[ch];!ok{\\n            store[ch]=struct{}{}\\n        }\\n    }\\n    return len(store)==26\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkIfPangram(sentence string) bool {\\n    store:=make(map[rune]struct{})\\n    for _,ch:=range sentence{\\n        if _,ok:=store[ch];!ok{\\n            store[ch]=struct{}{}\\n        }\\n    }\\n    return len(store)==26\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2714127,
                "title": "character-traversal-simple-solution",
                "content": "Traverse from `a to  z`, if any character not found in the String return false.\\n\\nAt the end return true.\\n\\n```\\npublic boolean checkIfPangram(String s) {\\n        \\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n            if(s.indexOf(ch) == -1){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\nPlease UpVote !!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkIfPangram(String s) {\\n        \\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n            if(s.indexOf(ch) == -1){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2714052,
                "title": "easy-python-one-liner",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return(len(set(sentence))==26)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return(len(set(sentence))==26)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713665,
                "title": "c-100-runtime-explained",
                "content": "\\n# **My simple and fast solution (beats 100% Runtime\\uD83D\\uDD25and 82.91% in memory)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        int arr[26] = {0};\\n\\t\\t//First traverse every letter of sentence in arr and increase its count if found\\n        for(int i=0; i<sentence.length(); i++){\\n            arr[sentence[i] - \\'a\\']++;\\n        }\\n\\t\\t\\n\\t\\t//Then traverse through the arr and see if any element has 0 count\\n        for(int i=0; i<26; i++){\\n\\t\\t\\t//if count = 0, then return False\\n            if(arr[i] == 0){\\n                return false;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//if you have reached here then every letter is there so return True\\n        return true;\\n    }\\n};\\n\\n```\\n                 ** If you like the solution and understand it then Please Upvote.\\uD83D\\uDC4D**\\n\\t\\t\\t\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        int arr[26] = {0};\\n\\t\\t//First traverse every letter of sentence in arr and increase its count if found\\n        for(int i=0; i<sentence.length(); i++){\\n            arr[sentence[i] - \\'a\\']++;\\n        }\\n\\t\\t\\n\\t\\t//Then traverse through the arr and see if any element has 0 count\\n        for(int i=0; i<26; i++){\\n\\t\\t\\t//if count = 0, then return False\\n            if(arr[i] == 0){\\n                return false;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//if you have reached here then every letter is there so return True\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713351,
                "title": "3-line-solution-easy-understanding-c-and-unordered-map",
                "content": "1 we declayer an unordered map of type <char,int>\\n2 loop through each letter in string and place it in unordered map\\n3 if size of map is equal to 26 then all the letters are included\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_map<char,int> mappa;\\n        for(int i=0;i<sentence.size();++i)mappa[sentence[i]]++;\\n        return 26 == mappa.size();\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_map<char,int> mappa;\\n        for(int i=0;i<sentence.size();++i)mappa[sentence[i]]++;\\n        return 26 == mappa.size();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2713116,
                "title": "rust-bit-set-with-comments",
                "content": "A simple problem, but so many ways to solve it. :) This is my preferred implementation. Perform a linear scan of the letters in `sentence`, recording which letters that we have encountered so far using a bit set. If the bit set ever becomes full (26 lowest bits set), we perform an early exit with true as the return value. If not, we return false.\\n\\nImplementation notes:\\n* Input is ASCII, so characters are bytes.\\n* Using `scan` here to yield the bitset after ORing in the bit mask for each letter.\\n* Using `any()` to get an early return whenever the bit set is full, so that we do not process additional letters unnecessarily.\\n* Using N_LETTERS instead of the magic number 26. `1 << N_LETTERS` is a one followed by `N_LETTERS` zeros, and subtracting one from that, we get a value with the `N_LETTERS` lowest bits set.\\n\\n```\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn check_if_pangram(sentence: String) -> bool {\\n        sentence.bytes().scan(0_u32, |bitset, b| {\\n            *bitset |= 1 << (b - b\\'a\\');\\n            Some(*bitset)\\n        }).any(|bitset| bitset == (1 << N_LETTERS) - 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn check_if_pangram(sentence: String) -> bool {\\n        sentence.bytes().scan(0_u32, |bitset, b| {\\n            *bitset |= 1 << (b - b\\'a\\');\\n            Some(*bitset)\\n        }).any(|bitset| bitset == (1 << N_LETTERS) - 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2713063,
                "title": "c-100-and-0ms-simple-solution-with-explaination",
                "content": "class Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n\\t\\n        //condition to check if size more than num of alphabets\\n        if(sentence.size() < 26)return false;\\n        \\n        unordered_map<char,int> m;\\n        \\n\\t\\t//loop to fill map \\n        for(int i=0; i<sentence.size(); i++)\\n            m[sentence[i]]++;\\n        \\n\\t\\t//check size of map to be 26 or not\\n        if(m.size() == 26)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n**pls do upvote, thanks**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n\\t\\n        //condition to check if size more than num of alphabets\\n        if(sentence.size() < 26)return false;\\n        \\n        unordered_map<char,int> m;\\n        \\n\\t\\t//loop to fill map \\n        for(int i=0; i<sentence.size(); i++)\\n            m[sentence[i]]++;\\n        \\n\\t\\t//check size of map to be 26 or not\\n        if(m.size() == 26)\\n            return true;\\n        else\\n            return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2712408,
                "title": "java-0-ms-o-1-100-faster-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n      if(sentence.length() < 26) return false;\\n      for(int i = 1; i <= 26; i ++) {\\n         if(sentence.indexOf(( char) i + 96) < 0)\\n         return false;\\n      }\\n      return true; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n      if(sentence.length() < 26) return false;\\n      for(int i = 1; i <= 26; i ++) {\\n         if(sentence.indexOf(( char) i + 96) < 0)\\n         return false;\\n      }\\n      return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711814,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] res= new int[26];\\n            for (int i=0;i<sentence.length();i++){\\n                    res[sentence.charAt(i)-97]++;\\n            }\\n            for(int i=0;i<26;i++){\\n                    if(res[i]==0){\\n                            return false;\\n                    }\\n            }\\n            return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] res= new int[26];\\n            for (int i=0;i<sentence.length();i++){\\n                    res[sentence.charAt(i)-97]++;\\n            }\\n            for(int i=0;i<26;i++){\\n                    if(res[i]==0){\\n                            return false;\\n                    }\\n            }\\n            return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461887,
                "title": "100-faster-solution-with-0-ms",
                "content": "```\\nI come with the solution to this question with three different approach:\\nFirst Approach:\\nUsing String \\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n       if(sentence.length()<26){\\n           return false;\\n       }\\n      String s=\"abcdefghijklmnopqrstuvwxyz\";\\n      for(int i=0;i<s.length();i++){\\n          if(sentence.indexOf(s.charAt(i))==-1){\\n              return false;\\n          }\\n      }\\n        return true;\\n}\\n}\\n\\n```\\n```\\nSecond Approach:\\nUsing Array\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int arr[]=new int[26];\\n        for(char x:sentence.toCharArray()){\\n            arr[x-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```\\nThird Approach:\\nUsing HashSet\\n\\n\\n\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        HashSet<Character> h = new HashSet<>();\\n        for(char x:sentence.toCharArray()){\\n            h.add(x);\\n        }\\n        if(h.size()==26){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nI come with the solution to this question with three different approach:\\nFirst Approach:\\nUsing String \\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n       if(sentence.length()<26){\\n           return false;\\n       }\\n      String s=\"abcdefghijklmnopqrstuvwxyz\";\\n      for(int i=0;i<s.length();i++){\\n          if(sentence.indexOf(s.charAt(i))==-1){\\n              return false;\\n          }\\n      }\\n        return true;\\n}\\n}\\n\\n```\n```\\nSecond Approach:\\nUsing Array\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int arr[]=new int[26];\\n        for(char x:sentence.toCharArray()){\\n            arr[x-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nThird Approach:\\nUsing HashSet\\n\\n\\n\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        HashSet<Character> h = new HashSet<>();\\n        for(char x:sentence.toCharArray()){\\n            h.add(x);\\n        }\\n        if(h.size()==26){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343108,
                "title": "c-1-line-3-methods",
                "content": "**Method 1**\\n```\\n    public bool CheckIfPangram(string sentence)\\n    {\\n        return sentence.ToHashSet().Count == 26;\\n    }\\n```\\n**Method 2**\\n```\\n    public bool CheckIfPangram(string sentence)\\n    {\\n        return new HashSet<char>(sentence).Count == 26;\\n    }\\n```\\n**Method 3**\\n```\\n    public bool CheckIfPangram(string sentence)\\n    {\\n        return sentence.Distinct().Count() == 26;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool CheckIfPangram(string sentence)\\n    {\\n        return sentence.ToHashSet().Count == 26;\\n    }\\n```\n```\\n    public bool CheckIfPangram(string sentence)\\n    {\\n        return new HashSet<char>(sentence).Count == 26;\\n    }\\n```\n```\\n    public bool CheckIfPangram(string sentence)\\n    {\\n        return sentence.Distinct().Count() == 26;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228854,
                "title": "c-sets-2-line-code-very-easy",
                "content": "![image](https://assets.leetcode.com/users/images/44ab17e1-3b4f-4dd3-b587-8ea72eaab8cd_1656789125.9426277.png)\\n\\n**T->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool checkIfPangram(string s) {\\n\\t\\t\\t\\tset<char>st;\\n\\t\\t\\t\\tfor(int i=0;i<s.size();i++) st.insert(s[i]);\\n\\t\\t\\t\\treturn st.size()==26;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool checkIfPangram(string s) {\\n\\t\\t\\t\\tset<char>st;\\n\\t\\t\\t\\tfor(int i=0;i<s.size();i++) st.insert(s[i]);\\n\\t\\t\\t\\treturn st.size()==26;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2080729,
                "title": "java-solution-without-set-map-extra-space-easy-solution",
                "content": "the idea is to count the length of string and total repeated characters, and if the difference of both == 26 then it is a pangram else not.\\nu can put a small check also that if the length is less than 26 then its clearly not a pangram\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String a) {\\n\\t\\tif(a.length() < 26) return false;\\n        int count = 0;\\n        for(int i = 0 ; i < a.length(); ++i){\\n            char num = a.charAt(i);\\n            if(a.indexOf(num) != i) ++count;\\n        }\\n        return (a.length() - count ==26);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkIfPangram(String a) {\\n\\t\\tif(a.length() < 26) return false;\\n        int count = 0;\\n        for(int i = 0 ; i < a.length(); ++i){\\n            char num = a.charAt(i);\\n            if(a.indexOf(num) != i) ++count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1878130,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        \\n        //Made an occurence Array for 26 characters\\n        int occ[26]={0};\\n        \\n        //Storing the Occurrence\\n        for(int i=0;i<sentence.length();i++)\\n            occ[sentence[i] - \\'a\\']++;\\n        \\n        //Checking if any letter doesn\\'t come even once then return false;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(occ[i]==0)\\n                return false;\\n                \\n        }\\n        return true;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        \\n        //Made an occurence Array for 26 characters\\n        int occ[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1790982,
                "title": "simple-easy-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int> v(26,0);\\n        \\n        for(int i=0;i<sentence.length();i++){\\n            v[sentence[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(v[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int> v(26,0);\\n        \\n        for(int i=0;i<sentence.length();i++){\\n            v[sentence[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(v[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715876,
                "title": "java-easy-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        String check = \"abcdefghijklmnopqrstuvwxyz\";        \\n        int count =0;\\n\\t\\tif(sentence.length()>25){\\n\\t\\t\\tfor(int i=0;i<check.length();i++){\\n\\t\\t\\tfor(int j=0;j<sentence.length();j++){\\n\\t\\t\\t\\t if(sentence.charAt(j)==check.charAt(i)){\\n\\t\\t\\t\\t\\t count++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t }\\n\\t\\t\\t}\\n\\t\\t\\tif(count!=i+1){\\n\\t\\t\\t return false;\\n\\t\\t}\\n\\n\\t\\t}\\n\\t\\t}\\n        else return false;\\n        return true;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        String check = \"abcdefghijklmnopqrstuvwxyz\";        \\n        int count =0;\\n\\t\\tif(sentence.length()>25){\\n\\t\\t\\tfor(int i=0;i<check.length();i++){\\n\\t\\t\\tfor(int j=0;j<sentence.length();j++){\\n\\t\\t\\t\\t if(sentence.charAt(j)==check.charAt(i)){\\n\\t\\t\\t\\t\\t count++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 1659259,
                "title": "java-hashset-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        // base condition\\n        if(sentence.length()<26)return false;\\n        // using HashSet to store the coming characters\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            char current = sentence.charAt(i);\\n            if(!set.contains(current)) set.add(current);\\n        }\\n        System.out.println(set.size());\\n        // if the size of the set is 26 then return true else return false\\n        return set.size() == 26 ? true:false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        // base condition\\n        if(sentence.length()<26)return false;\\n        // using HashSet to store the coming characters\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n            char current = sentence.charAt(i);\\n            if(!set.contains(current)) set.add(current);\\n        }\\n        System.out.println(set.size());\\n        // if the size of the set is 26 then return true else return false\\n        return set.size() == 26 ? true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567133,
                "title": "python-one-line-simple-solution-with-96-84-faster",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return True if len(set(sentence)) == 26 else False    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return True if len(set(sentence)) == 26 else False    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418738,
                "title": "simple-easy-java-hashset",
                "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n         if(sentence.length()<26)\\n       {\\n        return false;\\n        }\\n        Set<Character>set=new HashSet<>();\\n        \\n        for(var ch:sentence.toCharArray())\\n        {\\n            set.add(ch);\\n        }\\n        \\n        for(char i=\\'a\\';i<=\\'z\\';i++)\\n        {\\n            if(!set.contains(i))\\n                return false;\\n                \\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n         if(sentence.length()<26)\\n       {\\n        return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1415625,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions-o-n",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Check if the Sentence Is Pangram.\\nMemory Usage: 37.3 MB, less than 55.88% of Java online submissions for Check if the Sentence Is Pangram.**\\n```\\n public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<26)return false;\\n        String alpha=\"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<alpha.length();i++)\\n            if(sentence.indexOf(alpha.charAt(i))==-1)return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<26)return false;\\n        String alpha=\"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<alpha.length();i++)\\n            if(sentence.indexOf(alpha.charAt(i))==-1)return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406649,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions-in-o-n",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        \\n        String alpha = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<alpha.length();i++){\\n            if(sentence.indexOf(alpha.charAt(i))==-1){\\n                return false;\\n            }\\n        }return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        \\n        String alpha = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<alpha.length();i++){\\n            if(sentence.indexOf(alpha.charAt(i))==-1){\\n                return false;\\n            }\\n        }return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386327,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<26)\\n            return false;\\n        \\n        int[] arr = new int[26];\\n        \\n        // String str = sentence.toLowerCase(); // it is already being said that all the letters are in lowercase\\n        \\n        for(Character ch: sentence.toCharArray()){\\n            int ascii = (int)ch;\\n            arr[ascii-97] = 1;\\n        }\\n        for(int element:arr){\\n            if(element==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<26)\\n            return false;\\n        \\n        int[] arr = new int[26];\\n        \\n        // String str = sentence.toLowerCase(); // it is already being said that all the letters are in lowercase\\n        \\n        for(Character ch: sentence.toCharArray()){\\n            int ascii = (int)ch;\\n            arr[ascii-97] = 1;\\n        }\\n        for(int element:arr){\\n            if(element==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304961,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_map<char,bool>seen;\\n        for(auto c:sentence)\\n            seen[c]=1;\\n        return seen.size()==26;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_map<char,bool>seen;\\n        for(auto c:sentence)\\n            seen[c]=1;\\n        return seen.size()==26;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259972,
                "title": "java-easy-to-understand-solution",
                "content": "if you like it pls upvote\\n\\nJAVA\\n\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] arr = new int[26];\\n        \\n        for(int i =0;i<sentence.length();i++){\\n            arr[sentence.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i = 0;i<26;i++){\\n            if(arr[i] == 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] arr = new int[26];\\n        \\n        for(int i =0;i<sentence.length();i++){\\n            arr[sentence.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i = 0;i<26;i++){\\n            if(arr[i] == 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175554,
                "title": "pangram-solution-in-python-3-96-fast",
                "content": "Simple Python 3 Solution:\\n\\n```\\nimport string\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        checker = set(string.ascii_lowercase)\\n        \\n        for i in checker:\\n            if i not in sentence.lower():\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport string\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        checker = set(string.ascii_lowercase)\\n        \\n        for i in checker:\\n            if i not in sentence.lower():\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168467,
                "title": "c",
                "content": "```\\npublic bool CheckIfPangram(string sentence) =>\\n\\tsentence.Select(c => c - \\'a\\').ToHashSet().Count == \\'z\\' - \\'a\\' + 1;\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool CheckIfPangram(string sentence) =>\\n\\tsentence.Select(c => c - \\'a\\').ToHashSet().Count == \\'z\\' - \\'a\\' + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167781,
                "title": "typescript-2-one-liner-solutions",
                "content": "every\\n```\\nfunction checkIfPangram(sentence: string): boolean {\\n    return \"abcdefghijklmnopqrstuvwxyz\".split(\"\").every(a => sentence.includes(a));\\n};\\n```\\nSet\\n```\\nfunction checkIfPangram(sentence: string): boolean {\\n    return new Set(sentence).size === 26;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction checkIfPangram(sentence: string): boolean {\\n    return \"abcdefghijklmnopqrstuvwxyz\".split(\"\").every(a => sentence.includes(a));\\n};\\n```\n```\\nfunction checkIfPangram(sentence: string): boolean {\\n    return new Set(sentence).size === 26;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165069,
                "title": "javascript",
                "content": "Any feedback?\\n```javascript\\n    \\n  var word = sentence.split(\"\");\\n\\n  word = [...new Set(word)];\\n    \\n  // alphabet has 26 letters\\n  if (word.length === 26) {\\n    return true;\\n  }\\n  return false;\\n```",
                "solutionTags": [],
                "code": "```javascript\\n    \\n  var word = sentence.split(\"\");\\n\\n  word = [...new Set(word)];\\n    \\n  // alphabet has 26 letters\\n  if (word.length === 26) {\\n    return true;\\n  }\\n  return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164830,
                "title": "c-simple-solution-o-n-easy-understanding",
                "content": "**C++ solution:**\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        vector<int>vis(26,0);\\n        int count=0;\\n        for(auto i:s)\\n        {\\n            if(!vis[i-\\'a\\'])\\n            {\\n                vis[i-\\'a\\']=1;\\n                count++;\\n            }\\n        }\\n        if(count>=26)\\n            return 1;\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        vector<int>vis(26,0);\\n        int count=0;\\n        for(auto i:s)\\n        {\\n            if(!vis[i-\\'a\\'])\\n            {\\n                vis[i-\\'a\\']=1;\\n                count++;\\n            }\\n        }\\n        if(count>=26)\\n            return 1;\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164650,
                "title": "c-solution-using-set-o-n-time-and-o-26-space",
                "content": "We just need to count if there are 26 unique alphabets or not.\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_set<char> s;\\n        for(auto i: sentence)\\n            s.insert(i);\\n        return s.size()==26;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_set<char> s;\\n        for(auto i: sentence)\\n            s.insert(i);\\n        return s.size()==26;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164124,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n\\t\\treturn len(set(sentence))==26\\n```\\n\\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        for i in range(97,123):\\n            if chr(i) not in sentence:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n\\t\\treturn len(set(sentence))==26\\n```\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        for i in range(97,123):\\n            if chr(i) not in sentence:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164005,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        int index = 0;\\n        for (int i = 97; i< 123;i++) set.add((char)(i));        \\n        for (char c: sentence.toCharArray()) set.remove(c);\\n        return set.size()==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        int index = 0;\\n        for (int i = 97; i< 123;i++) set.add((char)(i));        \\n        for (char c: sentence.toCharArray()) set.remove(c);\\n        return set.size()==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028355,
                "title": "hash-map-solution-with-step-by-step-explanation",
                "content": "# Intuition\\nFor this problem we would use hashmap\\n\\n# Approach\\nWe use hashmap for this problem to store all alphabet letter from input string, and then simply check that size of our hashmap are equals to size of english alphabet.\\n# Complexity\\n- Time complexity:\\nO(n) - we iterate only once to get all letters\\n- Space complexity:\\nO(1) - we create hashmap but we know that it can\\'t grow more than 26, so it\\'s constant from 0 to 26, but we can get n length sentience and this will not change size of hashmap\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        // declare hashmap to store letters from sentience\\n        Map<Character, Integer> hash = new HashMap<>();\\n        // iterate over sentience:\\n        for(int i = 0; i < sentence.length(); i++) {\\n            // put letters into hashmap, since we dont neet to calculate specific number of letters we can just always set it to 1\\n            hash.put(sentence.charAt(i), 1);\\n        }\\n        // if hashmap is size of english alphabet return true, false otherwise\\n        return hash.size() == 26 ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        // declare hashmap to store letters from sentience\\n        Map<Character, Integer> hash = new HashMap<>();\\n        // iterate over sentience:\\n        for(int i = 0; i < sentence.length(); i++) {\\n            // put letters into hashmap, since we dont neet to calculate specific number of letters we can just always set it to 1\\n            hash.put(sentence.charAt(i), 1);\\n        }\\n        // if hashmap is size of english alphabet return true, false otherwise\\n        return hash.size() == 26 ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974469,
                "title": "easy-way-javascript-set-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} sentence\\n * @return {boolean}\\n */\\nvar checkIfPangram = function(sentence) {\\n  return sentence.length > 25 && ((new Set(sentence)).size) == 26\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @return {boolean}\\n */\\nvar checkIfPangram = function(sentence) {\\n  return sentence.length > 25 && ((new Set(sentence)).size) == 26\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968722,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        \\n        int freq[26] = {0};\\n\\n        for(int i =0;i<sentence.size();i++){\\n            freq[sentence[i]-\\'a\\']++;\\n        }\\n        for(int i =0;i<26;i++){\\n            if(freq[i]==0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        \\n        int freq[26] = {0};\\n\\n        for(int i =0;i<sentence.size();i++){\\n            freq[sentence[i]-\\'a\\']++;\\n        }\\n        for(int i =0;i<26;i++){\\n            if(freq[i]==0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822308,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe problem is asking us to determine if the input sentence is a pangram, i.e., it contains every letter of the alphabet at least once. To solve this problem, we can iterate through each character in the sentence and store each unique character in a data structure. If the total number of unique characters is 26 (the number of letters in the English alphabet), we know that the sentence is a pangram.\\n\\n# Approach\\nThe approach in this implementation is to use a map data structure, where each character in the sentence is a key. We iterate over each character in the sentence, adding new characters to the map. This ensures each character only appears once in the map, since map keys are unique. Finally, we check if the size of the map is 26. If so, this means that the sentence is a pangram; otherwise, it\\'s not.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n), where n is the length of the sentence. This is because we\\'re iterating through each character in the sentence once.\\n- Space complexity: The space complexity is also O(n), where n is the length of the sentence. This is the space used by the map to store unique characters. In the worst case, if each character in the sentence is unique, we\\'d have to store every character in the map. Note that since the map\\'s size won\\'t exceed 26 (the number of letters in the alphabet), we could also argue that the space complexity is O(1), or constant.\\n\\n# Code\\n```\\nfunc checkIfPangram(sentence string) bool {\\n    store:=make(map[rune]struct{})\\n    for _,ch:=range sentence{\\n        if _,ok:=store[ch];!ok{\\n            store[ch]=struct{}{}\\n        }\\n    }\\n    return len(store)==26\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nfunc checkIfPangram(sentence string) bool {\\n    store:=make(map[rune]struct{})\\n    for _,ch:=range sentence{\\n        if _,ok:=store[ch];!ok{\\n            store[ch]=struct{}{}\\n        }\\n    }\\n    return len(store)==26\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745507,
                "title": "python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        if len(set(sentence))==26:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        if len(set(sentence))==26:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552804,
                "title": "java-easy-and-understandable-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String s1) {\\n        char c[]=s1.toCharArray();\\n        Arrays.sort(c);\\n        String s=new String(c);\\n        String a=\"abcdefghijklmnopqrstuvwxyz\";\\n        int k=0;\\n        for(int i=0;i<s.length();i++){\\n            if(k==26){\\n                break;\\n            }\\n           if(s.charAt(i)==a.charAt(k)){\\n            k++;\\n          }\\n        }\\n        if(k==26)\\n        return true;\\n        else\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String s1) {\\n        char c[]=s1.toCharArray();\\n        Arrays.sort(c);\\n        String s=new String(c);\\n        String a=\"abcdefghijklmnopqrstuvwxyz\";\\n        int k=0;\\n        for(int i=0;i<s.length();i++){\\n            if(k==26){\\n                break;\\n            }\\n           if(s.charAt(i)==a.charAt(k)){\\n            k++;\\n          }\\n        }\\n        if(k==26)\\n        return true;\\n        else\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481465,
                "title": "easy-solution-using-unordered-map-explained",
                "content": "\\n\\n# Approach\\nfirst of all we took an unordered map; yes we can do with unordered map also\\n\\nwe need all 26 alphabet so our stringh length should be at list 26.\\nother wise return false\\n\\n    if(sentence.size()<26){\\n           return false;\\n       }\\n\\nby a for loop we are going through all alphabet  one by one;\\nwe have to check if the alphabet  is allready in map or not if not then it is a new alphabet  .lets enter it in our map;and increase the sum++;\\n\\n    if(!mpp.count(sentence[i])){\\n               mpp[sentence[i]]++;\\n                sum++; \\n           }\\n\\nif our sum reaches 26 then only we got 26 alphabet .return true ;\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n       unordered_map<char,int>mpp;  \\n       int sum=0;\\n       \\n       if(sentence.size()<26){\\n           return false;\\n       }\\n     \\n       for(int i=0;i<sentence.size();i++)\\n       {\\n           if(!mpp.count(sentence[i])){  //check if allready there in map or not\\n               mpp[sentence[i]]++;\\n                sum++; \\n           }\\n        }\\n       if(sum==26){\\n           return true;\\n       }\\n       return false;\\n    }\\n\\n};\\n```\\n# please Upvote :(",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n       unordered_map<char,int>mpp;  \\n       int sum=0;\\n       \\n       if(sentence.size()<26){\\n           return false;\\n       }\\n     \\n       for(int i=0;i<sentence.size();i++)\\n       {\\n           if(!mpp.count(sentence[i])){  //check if allready there in map or not\\n               mpp[sentence[i]]++;\\n                sum++; \\n           }\\n        }\\n       if(sum==26){\\n           return true;\\n       }\\n       return false;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386367,
                "title": "c-4-lines-easy-simple",
                "content": "**If you find the solution helpful, please Upvote.**\\n\\n**Code:**\\n\\n```\\n        vector<int>hash(26,0);\\n        for(auto i:sentence)hash[i-\\'a\\']++;\\n        for(auto i:hash)if(i<1)return false;\\n        return true;",
                "solutionTags": [
                    "C++"
                ],
                "code": "**If you find the solution helpful, please Upvote.**\\n\\n**Code:**\\n\\n```\\n        vector<int>hash(26,0);\\n        for(auto i:sentence)hash[i-\\'a\\']++;\\n        for(auto i:hash)if(i<1)return false;\\n        return true;",
                "codeTag": "Unknown"
            },
            {
                "id": 3340401,
                "title": "simple-java-program-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n       int a[]=new int[26];\\n       for(char ch:sentence.toCharArray()){\\n           a[ch-\\'a\\']++;\\n       } \\n       for(int i:a){\\n           if(i==0)\\n           return false;\\n       }\\n       return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n       int a[]=new int[26];\\n       for(char ch:sentence.toCharArray()){\\n           a[ch-\\'a\\']++;\\n       } \\n       for(int i:a){\\n           if(i==0)\\n           return false;\\n       }\\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337028,
                "title": "js-solution",
                "content": "\\n\\n```\\nvar checkIfPangram = function(sentence) {\\n    let basket = new Set(sentence);\\n    if(sentence.length < 26) return false;\\n    let alpha = [...Array(26)].map((_, i) => String.fromCharCode(i + 97));\\n    return alpha.every(l => basket.has(l));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkIfPangram = function(sentence) {\\n    let basket = new Set(sentence);\\n    if(sentence.length < 26) return false;\\n    let alpha = [...Array(26)].map((_, i) => String.fromCharCode(i + 97));\\n    return alpha.every(l => basket.has(l));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3332173,
                "title": "i-do-the-same-as-low-run-time-but-it-take-more-for-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        new=set(sentence)\\n        if len(new)>=26:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        new=set(sentence)\\n        if len(new)>=26:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254968,
                "title": "simple-approach-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou know, if we just add each unique element in a map/set/array, and if the resultant size is 26 then the string is pangram, else not a pangram.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple, we just have to insert the unique elements in a list, or map, or set, we can use any one of them, for now lets keep it simple, lets just use a map, after adding unique elements, the size needs to be 26 if the input string is a pangram.\\n\\n# Complexity\\n- Time complexity: O(N) coz we\\'ve used an unordered_map\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) we know that the size will not exceed 26, and thats why constant. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_map<char, int> mp;\\n        for(auto i:sentence) {\\n            ++mp[i];\\n        }\\n        if(mp.size()==26) return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_map<char, int> mp;\\n        for(auto i:sentence) {\\n            ++mp[i];\\n        }\\n        if(mp.size()==26) return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165799,
                "title": "simple-c-solution-using-vector",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int>v(26,0);\\n        for(char c:sentence){\\n            v[c-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(v[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        vector<int>v(26,0);\\n        for(char c:sentence){\\n            v[c-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(v[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154031,
                "title": "easy-c-approach-100-runtime-beginner-friendly",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing for loop we first push each char to ordered set as we know the property of set that it hold only unique element so it will only hold each char one time and after that we checked if  the lenght of set if equal to 26 which are the total number of the alphabet then return true otherwise return false.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        set<char> res;\\n        for(int i=0;i<sentence.size();i++)\\n        {\\n            res.insert(sentence[i]);\\n        }\\n        if(res.size()==26)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\nIF FOUND USEFULL DO UPVOTE \\uD83E\\uDEE1\\uD83E\\uDEE1\\uD83E\\uDEE1",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        set<char> res;\\n        for(int i=0;i<sentence.size();i++)\\n        {\\n            res.insert(sentence[i]);\\n        }\\n        if(res.size()==26)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087134,
                "title": "java-solution-0-ms-beats-100-easy-beginner-friendly",
                "content": "\\n# Approach\\nfirst we make a string that contains all letters of the alphabet and then checks if all the letters are present in the `sentence` or not.\\nThen we return the output as per requirement ;\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        for(int i = 0 ; i < str.length() ; i++){\\n            char chr = str.charAt(i) ;\\n            String ch = Character.toString(chr);            \\n\\n            if(sentence.contains(ch)){\\n                continue;\\n            }else{\\n                return false;\\n            }\\n        }\\n\\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        for(int i = 0 ; i < str.length() ; i++){\\n            char chr = str.charAt(i) ;\\n            String ch = Character.toString(chr);            \\n\\n            if(sentence.contains(ch)){\\n                continue;\\n            }else{\\n                return false;\\n            }\\n        }\\n\\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004030,
                "title": "python-one-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence))==26\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence))==26\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937488,
                "title": "java-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n       if(sentence.length()<26) return false;\\n          int[] arr= new int[26];\\n        for(int i=0;i<sentence.length();i++){\\n            arr[sentence.charAt(i)-\\'a\\']=1;\\n        }\\n        for(int x : arr)\\n          if(x == 0)\\n          return false;\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n       if(sentence.length()<26) return false;\\n          int[] arr= new int[26];\\n        for(int i=0;i<sentence.length();i++){\\n            arr[sentence.charAt(i)-\\'a\\']=1;\\n        }\\n        for(int x : arr)\\n          if(x == 0)\\n          return false;\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917016,
                "title": "easy-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} sentence\\n * @return {boolean}\\n */\\nvar checkIfPangram = function(sentence) {\\n    \\n    //verify if sentence have at least 26 letters;\\n    if(sentence.length<26)\\n    return false;\\n\\n   //create a set of distinct letters from the given sentence;\\n   let distinctLetters= new Set (sentence); \\n  \\n   //verify if the sentence contains 26 distinctive letters;\\n   if(distinctLetters.size<26)\\n   return false;\\n   else \\n   return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @return {boolean}\\n */\\nvar checkIfPangram = function(sentence) {\\n    \\n    //verify if sentence have at least 26 letters;\\n    if(sentence.length<26)\\n    return false;\\n\\n   //create a set of distinct letters from the given sentence;\\n   let distinctLetters= new Set (sentence); \\n  \\n   //verify if the sentence contains 26 distinctive letters;\\n   if(distinctLetters.size<26)\\n   return false;\\n   else \\n   return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2771489,
                "title": "the-simplest-solution-no-set-map-100-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length() < 26) return false;\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n            if(sentence.indexOf(c) == -1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length() < 26) return false;\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n            if(sentence.indexOf(c) == -1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752488,
                "title": "easy-java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String str) {\\n      HashSet <Character> set=new HashSet<>();\\n        for(int i=0;i<str.length();i++){\\n            if(set.contains(str.charAt(i))){\\n                if(set.size()==26) return true;\\n            }\\n            set.add(str.charAt(i));\\n\\n        }\\n\\n        if(set.size()<26) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String str) {\\n      HashSet <Character> set=new HashSet<>();\\n        for(int i=0;i<str.length();i++){\\n            if(set.contains(str.charAt(i))){\\n                if(set.size()==26) return true;\\n            }\\n            set.add(str.charAt(i));\\n\\n        }\\n\\n        if(set.size()<26) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747085,
                "title": "java-simple-explanation-1-ms-faster-than-92-76",
                "content": "First we are just checking the length of the string, if it is less than 26 there is no way it can have all characters in the string.\\n\\nNow we are creating a boolean array of length 26 so that we can map each character to it. \\nWhat I mean by that statement is, when we initialise the array we will have an array something like this:\\n`[false, false, false, ... , false]`\\n\\nNow let\\'s say we found a string `\"thequickbrownfoxjumpsoverthelazydo\"` it contains all English alphabets atleast once right? So we will go to the boolean array each time and set it to true for each element. For a, we will set first element to true. For b, second and as such.\\n\\n* Why are we doing `ch - \\'a\\'`?\\n-> Then we will get the value of char element. In our previous string (`\"thequickbrownfoxjumpsoverthelazydo\"`) the first element is t, so after doing the operation \\'t\\' - \\'a\\', we will get 19. Then we will simply go to 19th element of the boolean array and set it to true.\\n\\nAt the end, we will check if any element is false in the boolean array, if yes then it doesn\\'t contain all the alphabets and we will just return false.\\n\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        if (sentence.length() < 26) {\\n            return false;\\n        }\\n        \\n        boolean[] check = new boolean[26];\\n\\n        for (char ch : sentence.toCharArray()) {\\n            check[ch - \\'a\\'] = true;\\n        }\\n        \\n        for (boolean exist : check) {\\n            if(!exist) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        if (sentence.length() < 26) {\\n            return false;\\n        }\\n        \\n        boolean[] check = new boolean[26];\\n\\n        for (char ch : sentence.toCharArray()) {\\n            check[ch - \\'a\\'] = true;\\n        }\\n        \\n        for (boolean exist : check) {\\n            if(!exist) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738661,
                "title": "java-simple-array-solution",
                "content": "\\n        int[] arr = new int[26];\\n        int count = 0;\\n        \\n        for (int i = 0; i < sentence.length(); i++) {\\n            if (arr[sentence.charAt(i) - \\'a\\'] == 0) {\\n                arr[sentence.charAt(i) - \\'a\\'] += 1;\\n                count++;\\n            }\\n            if (count == 26) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "\\n        int[] arr = new int[26];\\n        int count = 0;\\n        \\n        for (int i = 0; i < sentence.length(); i++) {\\n            if (arr[sentence.charAt(i) - \\'a\\'] == 0) {\\n                arr[sentence.charAt(i) - \\'a\\'] += 1;\\n                count++;\\n            }\\n            if (count == 26) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2716072,
                "title": "python-1-line-solution",
                "content": "This code uses the set() method to obtain all the unique letters in an alphabet. Once the number of letters is 26, it returns True, else False.\\n\\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return True if len(set(sentence)) == 26 else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return True if len(set(sentence)) == 26 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715780,
                "title": "easy-c-solution-using-set",
                "content": "```\\nbool checkIfPangram(string sentence) {\\n\\tunordered_set<char> s;\\n\\n\\tfor (int i=0;i<sentence.length();i++)\\n\\t\\ts.insert(sentence[i]);\\n\\n\\treturn s.size() >= 26;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nbool checkIfPangram(string sentence) {\\n\\tunordered_set<char> s;\\n\\n\\tfor (int i=0;i<sentence.length();i++)\\n\\t\\ts.insert(sentence[i]);\\n\\n\\treturn s.size() >= 26;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715592,
                "title": "python-solution-using-ascii-values",
                "content": "* Here we are going to check the sentence with all 26 lower case english alphabets \\n* `chr(97)` will be lowercase a so starting from there we will check whether every alphabet is there in the given sentence or not \\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        for i in range(26):\\n            if chr(97+i) not in sentence:\\n                return False\\n        return True\\n```\\nA single liner code would be \\n```\\nreturn len(set(sentence))==26\\n```\\nHere we are converting the given sentence into set which wouldn\\'t allow duplicate values and checking whether the length is 26 or not \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        for i in range(26):\\n            if chr(97+i) not in sentence:\\n                return False\\n        return True\\n```\n```\\nreturn len(set(sentence))==26\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715581,
                "title": "java-very-easy-frequency-array-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] arr = new int[26];\\n        for (int i=0; i<26; i++) {\\n            arr[i] = 0;\\n        }\\n        \\n        for (int i=0; i<sentence.length(); i++) {\\n            arr[sentence.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for (int i=0; i<26; i++) {\\n            if (arr[i]==0) {\\n                return false;\\n            }\\n        }\\n          \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int[] arr = new int[26];\\n        for (int i=0; i<26; i++) {\\n            arr[i] = 0;\\n        }\\n        \\n        for (int i=0; i<sentence.length(); i++) {\\n            arr[sentence.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for (int i=0; i<26; i++) {\\n            if (arr[i]==0) {\\n                return false;\\n            }\\n        }\\n          \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715506,
                "title": "c-100-faster-easy-understanding-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int cnt=0;\\n        sort(s.begin(), s.end());\\n        for(int i=0; i<s.size(); i++){\\n            if (s[i] != s[i + 1])\\n            cnt++;\\n        }\\n        if (cnt == 26)\\n\\t\\t\\treturn 1;\\n  \\n\\t\\telse\\n\\t\\t\\treturn 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int cnt=0;\\n        sort(s.begin(), s.end());\\n        for(int i=0; i<s.size(); i++){\\n            if (s[i] != s[i + 1])\\n            cnt++;\\n        }\\n        if (cnt == 26)\\n\\t\\t\\treturn 1;\\n  \\n\\t\\telse\\n\\t\\t\\treturn 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715432,
                "title": "daily-leetcode-october-17",
                "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        boolean[] alpha = new boolean[26];\\n        \\n        for(int i=0;i<sentence.length();i++){\\n            \\n            alpha[sentence.charAt(i)-\\'a\\']=true;\\n            \\n        }\\n        \\n        for(int i=0;i<alpha.length;i++){\\n            if(alpha[i]==false) return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        \\n        boolean[] alpha = new boolean[26];\\n        \\n        for(int i=0;i<sentence.length();i++){\\n            \\n            alpha[sentence.charAt(i)-\\'a\\']=true;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2715226,
                "title": "c-easy-o-1-space-complexity",
                "content": "# Approach \\nUsed int(32 bits) to update the occurence of characters. Since we know that total count will not be greater than 26. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int x=0;\\n        for(int i=0;i<s.size();i++){\\n            x = x | (1<<(s[i]-\\'a\\'));\\n        }\\n       return (x == (1<<26) -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int x=0;\\n        for(int i=0;i<s.size();i++){\\n            x = x | (1<<(s[i]-\\'a\\'));\\n        }\\n       return (x == (1<<26) -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715026,
                "title": "easiest-solution-c-unordered-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++){\\n            m[s[i]]++;\\n        }\\n        if(m.size()>=26){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++){\\n            m[s[i]]++;\\n        }\\n        if(m.size()>=26){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714844,
                "title": "simple-python-code",
                "content": "```\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        \"\"\"\\n        :type sentence: str\\n        :rtype: bool\\n        \"\"\"\\n        l=[]\\n        for j in range(len(sentence)):\\n            if sentence[j] not in l:\\n                l.append(sentence[j])\\n        if len(l)==26:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkIfPangram(self, sentence):\\n        \"\"\"\\n        :type sentence: str\\n        :rtype: bool\\n        \"\"\"\\n        l=[]\\n        for j in range(len(sentence)):\\n            if sentence[j] not in l:\\n                l.append(sentence[j])\\n        if len(l)==26:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714805,
                "title": "java-fast-runtime-easy-and-elegant-solution",
                "content": "```\\nHashSet alphabet = new HashSet();\\nfor (int i : sentence.toCharArray())\\n\\tif (alphabet.add(i))\\n\\t\\tif (alphabet.size() == 26)\\n\\t\\t\\treturn true;\\nreturn false;\\n```\\nexplanation\\n\\n```\\nHashSet alphabet = new HashSet();\\nfor (int i : sentence.toCharArray()) {\\n\\tif (alphabet.add(i)) {\\n//  above code automatically add distinct alphabets, \\n//  also if distinct alphabet is added then\\n//  it will enter the if-condition and checks if total size of set is 26 or not\\n//  if size is 26 that means all 26 characters of english alphabets are present \\n//  if not then after loop ends then it will return false\\n\\t\\tif (alphabet.size() == 26)\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\nreturn false;\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nHashSet alphabet = new HashSet();\\nfor (int i : sentence.toCharArray())\\n\\tif (alphabet.add(i))\\n\\t\\tif (alphabet.size() == 26)\\n\\t\\t\\treturn true;\\nreturn false;\\n```\n```\\nHashSet alphabet = new HashSet();\\nfor (int i : sentence.toCharArray()) {\\n\\tif (alphabet.add(i)) {\\n//  above code automatically add distinct alphabets, \\n//  also if distinct alphabet is added then\\n//  it will enter the if-condition and checks if total size of set is 26 or not\\n//  if size is 26 that means all 26 characters of english alphabets are present \\n//  if not then after loop ends then it will return false\\n\\t\\tif (alphabet.size() == 26)\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\nreturn false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2714755,
                "title": "c-easy-to-understand-with-the-use-of-a-set",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_set<char>words;\\n        for(char p: sentence)\\n            words.insert(p);\\n\\n        return words.size() == 26;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        unordered_set<char>words;\\n        for(char p: sentence)\\n            words.insert(p);\\n\\n        return words.size() == 26;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714491,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence))==26\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence))==26\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714393,
                "title": "python-one-liner-easy-solution-93-35-faster",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence))==26\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(sentence))==26\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714313,
                "title": "python-intuitive-solution-with-dictionary",
                "content": "```\\ndef checkIfPangram(self, sentence: str) -> bool:\\n        ref = {v:False for i,v in enumerate(\\'abcdefghijklmnopqrstuvwxyz\\')}\\n        for i in sentence: \\n            ref[i] = True\\n        for i in ref: \\n            if not ref[i]: \\n                return False\\n        return True",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\ndef checkIfPangram(self, sentence: str) -> bool:\\n        ref = {v:False for i,v in enumerate(\\'abcdefghijklmnopqrstuvwxyz\\')}\\n        for i in sentence: \\n            ref[i] = True\\n        for i in ref: \\n            if not ref[i]: \\n                return False\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 2714242,
                "title": "c-2-line-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {        \\n        unordered_set <char> st(sentence.begin() , sentence.end());\\n        return st.size() == 26;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {        \\n        unordered_set <char> st(sentence.begin() , sentence.end());\\n        return st.size() == 26;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714161,
                "title": "c-easy-o-1-space-bit-manipulation",
                "content": "**INTUITION :**\\n\\tMy approach is to mark all the occurrence in the \\'i\\'th bit of ans as 1.\\n\\tThen we can easy try xor with (1 << 26) - 1 to check whether all the character were marked in the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        // Initialize ans as 0\\n        int ans = 0;\\n        for(auto i : sentence){\\n            // Make the (ch - \\'a\\')th bit as 1;\\n            int v = i - \\'a\\';\\n            int r = (1 << v);\\n            ans |= r;\\n            // Check whether (1 << 26) - 1 xor ans is 0\\n            // (1 << 26) - 1 makes 26 bit from lsb as 1 => (11111111111111111111111111)\\n            if((ans ^ ((1 << 26) - 1)) == 0) return true;\\n        }\\n        // Else return false\\n        return false;\\n    }\\n};\\n```\\n\\nPlease do Upvote if you like my Solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        // Initialize ans as 0\\n        int ans = 0;\\n        for(auto i : sentence){\\n            // Make the (ch - \\'a\\')th bit as 1;\\n            int v = i - \\'a\\';\\n            int r = (1 << v);\\n            ans |= r;\\n            // Check whether (1 << 26) - 1 xor ans is 0\\n            // (1 << 26) - 1 makes 26 bit from lsb as 1 => (11111111111111111111111111)\\n            if((ans ^ ((1 << 26) - 1)) == 0) return true;\\n        }\\n        // Else return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713862,
                "title": "java-set-solution-very-easy",
                "content": "Upvote if you like!!!\\n\\n```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<26) return false;\\n         HashSet<Character> set = new HashSet<>();\\n        for(char c:sentence.toCharArray()){\\n            set.add(c);\\n        }\\n        \\n        return set.size()==26;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<26) return false;\\n         HashSet<Character> set = new HashSet<>();\\n        for(char c:sentence.toCharArray()){\\n            set.add(c);\\n        }\\n        \\n        return set.size()==26;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713578,
                "title": "hashmap-solution-easy-understanding",
                "content": "```class Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        h = {}\\n        for i in sentence:\\n            if i not in h:\\n                h[i] = 1\\n        if len(h) < 26:\\n            return False\\n        else:\\n            return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def checkIfPangram(self, sentence: str) -> bool:\\n        h = {}",
                "codeTag": "Java"
            },
            {
                "id": 2713490,
                "title": "java-solution-hashset-one-pass",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int n = sentence.length();\\n        \\n        Set<Character> set = new HashSet<>();\\n        for (int idx = 0; idx < n; idx++) {\\n            Character c = sentence.charAt(idx);\\n            set.add(c);\\n        }\\n        \\n        return set.size() == 26;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        int n = sentence.length();\\n        \\n        Set<Character> set = new HashSet<>();\\n        for (int idx = 0; idx < n; idx++) {\\n            Character c = sentence.charAt(idx);\\n            set.add(c);\\n        }\\n        \\n        return set.size() == 26;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713215,
                "title": "java-easy-solution-using-set-with-comment",
                "content": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>(); //characterset.\\n        \\n        for(int i = 0; i < sentence.length();i++){\\n            set.add(sentence.charAt(i)); //adding char to set.\\n        }\\n        return set.size() == 26; //if set.size == 26 all the alphabet are there at least one hence true else false. \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>(); //characterset.\\n        \\n        for(int i = 0; i < sentence.length();i++){\\n            set.add(sentence.charAt(i)); //adding char to set.\\n        }\\n        return set.size() == 26; //if set.size == 26 all the alphabet are there at least one hence true else false. \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713086,
                "title": "single-loop-one-liner-c-stl-efficient-easy-understanding-no-need-to-count",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        for(char c=\\'a\\';c<=\\'z\\';c++){\\n            if(sentence.find(c)==string::npos)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string sentence) {\\n        for(char c=\\'a\\';c<=\\'z\\';c++){\\n            if(sentence.find(c)==string::npos)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712800,
                "title": "2-lines-beats-70-hashset-c",
                "content": "```\\nbool checkIfPangram(string sen) {\\n        unordered_set<int> s={sen.begin(),sen.end()};\\n        return s.size()==26;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nbool checkIfPangram(string sen) {\\n        unordered_set<int> s={sen.begin(),sen.end()};\\n        return s.size()==26;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1648229,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1570692,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1648477,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1743395,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1769678,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 2034106,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 2031369,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1889532,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1858413,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1848081,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1648229,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1570692,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1648477,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1743395,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1769678,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 2034106,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 2031369,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1889532,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1858413,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1848081,
                "content": [
                    {
                        "username": "Knight-03",
                        "content": "3 Approach :  \\uD83D\\uDE0B \\n\\n1) Using Set :-  \\n- create the Set of Character.\\n- Put the Character in the set.\\n- Check size of set is 26 then return true else return false\\n\\n2) Using Vector :-  \\n- create vector of 26 size \\n- use the count frequency algo using vector to count the frequency of alphabet ( you just need to subtract something while counting ) \\n- check if any particular index value is 0 \\n       - if yes then return false \\n       - else return true \\n\\n3) Using Map :- \\n- declare a `chat , int` map  \\n- count the frequency  ( easier then vector count ) \\n- check if map size is equal to 26 \\n          - return true if it is \\n          - or false if its not \\n\\n\\nAny other solutions... appreciated : )  "
                    },
                    {
                        "username": "unclekoin",
                        "content": "const checkIfPangram = (sentence) =>  return new Set([...sentence]).size === 26;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "Using indexOf() is faster that writing a for-loop to check?"
                    },
                    {
                        "username": "alert2",
                        "content": "The \"in\" keyword is very useful in python."
                    },
                    {
                        "username": "shruti_singh_07",
                        "content": "class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < sentence.length(); i++) {\\n            set.add(sentence.charAt(i));\\n        }\\n        return set.size() == 26;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "AnkitG0",
                        "content": "you need to convert letters to either upper or lower case right? otherwise a and A will be treated as two characters."
                    },
                    {
                        "username": "Rishipandey14",
                        "content": "\n        letter_set = set()\n        for char in sentence:\n            if 'a' <= char <= 'z':\n                letter_set.add(char)\n\n        return len(letter_set) == 26\n"
                    },
                    {
                        "username": "abhistin",
                        "content": "If you want to use set for this, approach would be:- \\n1. Create a character type set.\\n2. Iterate through the whole string and save every character in a set\\n3. Check if the count of set == 26 , return true, else return false."
                    },
                    {
                        "username": "Kunal_Pawar_7788",
                        "content": "1. First check for sentence length if less than 26 return false.\\n2. Take a for loop and declare iterable variable as character and assign value as a, condition as iterable variable should be less than equals to z and increment the iterable variable.\\n3. Second check for sentence using indexOf(iterable variable) if equals to -1, return false.\\n4. End of for loop, return true."
                    },
                    {
                        "username": "sudhansusekharweb",
                        "content": "why this code is 33% beats -> for( auto &i:s) alp[ i - 'a' ]++;\nAnd this code is 100% beats -> for( int i=0; i<s.size(); i++) alp[ s[ i ] - 'a' ]++;\ncan any one expline me please\n\n\n"
                    },
                    {
                        "username": "adi123jha",
                        "content": "Tried doing normally using arrays concept and successfully cleared many testcases but some of the corner cases aren\\'t cleared. Anyone please check and let me know if you get what\\'s the problem.\\n\\nclass Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        if(sentence.length()<27)\\n\\t\\t\\treturn false;\\n\\t\\tint[] arr= new int[26];\\n\\t\\tfor(int i=0;i<sentence.length();i++) {\\n\\t\\t\\tint val = sentence.charAt(i)-97;\\n\\t\\t\\tarr[val]=-1;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(arr[i]==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}"
                    },
                    {
                        "username": "adi123jha",
                        "content": "[@budhojuraju](/budhojuraju) yes. it works perfectly when \"sentence.length()<26\" in 3rd line."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "if (sentence.length() < 27) , why 27 ?? I think its 26. There may be a sentence with all unique alphabets with length 26."
                    }
                ]
            },
            {
                "id": 1812163,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1772980,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1731934,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1687747,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1672316,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1648726,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1648551,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1648332,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1648315,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            },
            {
                "id": 1648309,
                "content": [
                    {
                        "username": "dev_akash001",
                        "content": "The code starts by declaring an array of 26 Boolean values.\\n The code then iterates through the sentence and sets each value to true if it is not already set to false.\\n After that, the for loop iterates through all 26 values in the array and checks if they are false or not.\\n If any value is true, then it returns false from the function.\\n Otherwise, it returns true from the function.\\n The first line declares a variable called sentence which will be used as a string with one character per element in order to create an array of 26 characters long (one for each letter).\\n The next two lines declare variables called pangram and i which will be used later on in this program when we want to check whether a given character exists within our sentence or not: pangram stores all possible letters that can appear at position 97 while i stores 0-25 so we know where we are currently located within our string: After those two lines have been executed, there\\'s nothing left but for us to start using these variables!\\n We do this by creating an infinite loop inside of another infinite loop: This means that every time you see \"for(int i = 0 ; i < 26 ; i++)\\n The code will return true if the sentence is a pangram."
                    },
                    {
                        "username": "deepankar_gupta2003",
                        "content": "String temp = \"\" + s.charAt(0);\\n    for (int i = 1; i < s.length(); i++) {\\n        if (!temp.contains(String.valueOf(s.charAt(i))))\\n            temp = temp + s.charAt(i);\\n    }\\n    char[] ch = temp.toCharArray();\\n    Arrays.sort(ch);\\n    // System.out.println(Arrays.toString(ch));\\n\\n    for (int i = 0; i < ch.length-1; i++) {\\n        if (ch[i] != ch[i + 1]) {\\n            if (ch.length == 26){\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "[leetcode](https://leetcode.com)\\nclass Solution {\\npublic:\\n    bool checkIfPangram(string s) {\\n        int ans[26]={0};\\n        if(s.size()< 26){\\n            return false;\\n        }\\n        else{\\n            for(int i=0;i<s.size();i++){\\n                ans[int(s[i]-\\'a\\')]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(ans[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "natest77",
                        "content": "i used ascii code to solve this problem. as i beginner i recommend using ascii code to solve this problem. "
                    },
                    {
                        "username": "Sherkhan_Tazhibayev",
                        "content": "TIP: The easiest way is to use a data structure for non-repeatable elements."
                    },
                    {
                        "username": "mihneadumi",
                        "content": "I think the shortest (and easiest to understand) solution for PYTHON is:\\n- using sett = set(sentence) to get a set consisting of the unique letters from our string\\n- compare len(sett) to 26: - if len(set) != 26 return false"
                    },
                    {
                        "username": "adjoint",
                        "content": "keep track of the seen chars (array, map, set, bit-vector) and check if all the alphabets were present. best option is to use a bit-vector as both setting (like arrays), and checking is in constant time (unlike arrays), with no extra memory for meta-data (unlike maps, sets)"
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Easiest solution is to find the unique set of input and just find the length if length<26 its not a pangram else it is."
                    },
                    {
                        "username": "rovin-singh",
                        "content": "JAVASCRIPT METHOD :-\n\nvar checkIfPangram = function(sentence) {\n    let myset=new Set();\n    for(let i=0;i<sentence.length;i++){\n        myset.add(sentence[i])\n    }\n    if(myset.size===26){\n        return true\n    }\n    else{\n        return false\n    }\n};"
                    },
                    {
                        "username": "Vivek_Goswami",
                        "content": "var checkIfPangram = function(sentence) {\\n\\n    let map ={}\\n\\n    for(let item of sentence){\\n        map[item] =( map[item]  || 0) + 1\\n    }\\n    \\n    if(Object.keys(map).length == 26) return true;\\n\\n    return false ;\\n    \\n};\\n\\n\\n//very easy solution with O(N) complexity"
                    }
                ]
            }
        ]
    }
]