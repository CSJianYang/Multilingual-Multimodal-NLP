[
    {
        "title": "Divide Two Integers",
        "question_content": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [&minus;231, 231 &minus; 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n&nbsp;\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n\n&nbsp;\nConstraints:\n\n\t-231 <= dividend, divisor <= 231 - 1\n\tdivisor != 0",
        "solutions": [
            {
                "id": 13407,
                "title": "c-bit-manipulations",
                "content": "The key observation is that the quotient of a division is just the number of times that we can subtract the `divisor` from the `dividend` without making it negative.\\n\\nSuppose `dividend = 15` and `divisor = 3`, `15 - 3 > 0`. We now try to subtract more by *shifting* `3` to the left by `1` bit (`6`). Since `15 - 6 > 0`, shift `6` again to `12`. Now `15 - 12 > 0`, shift `12` again to `24`, which is larger than `15`. So we can at most subtract `12` from `15`. Since `12` is obtained by shifting `3` to left twice, it is `1 << 2 = 4` times of `3`. We add `4` to an answer variable (initialized to be `0`). The above process is like `15 = 3 * 4 + 3`. We now get part of the quotient (`4`), with a remaining dividend `3`.\\n\\nThen we repeat the above process by subtracting `divisor = 3` from the remaining `dividend = 3` and obtain `0`. We are done. In this case, no shift happens. We simply add `1 << 0 = 1` to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle one overflow case: `dividend = INT_MIN` and `divisor = -1`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516367,
                "title": "complete-thinking-process-intuitive-explanation-all-rules-followed-c-code",
                "content": "# **Explanation:**\\n```\\n\\tdividend = (quotient) * divisor + remainder\\n```\\nWe have to find the quotient in this equation and we are given divisor and dividend.\\nAny number can be represented in binary form. Same goes for `quotient` :\\n\\nLet us have an example: `58/5`:\\n`58 = (11) * 5 + 3`\\nRepresenting the quotient in binary form:  (11)<sub>10</sub> = (1011)<sub>2</sub>:\\n```\\n\\t58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\\n\\t58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)\\n```\\n\\nSince we dont know the quotient and remainder the equation we know is:\\n`58 = (q) * 5 + rem`\\n\\nWe get a hint at what we would like to do here. We will first multiply 5 with maximum power of 2 such that the resulting number is still smaller than the dividend (read further if you don\\'t understand why). Since multiplication operator is not allowed, we would use bitwise left shift to achieve this multiplication: each time we shift 5 by 1, we multiply it by 2:\\n```\\n\\t5 << 0 = 5               // less than dividend\\n\\t5 << 1 = 5*2 = 10        // less than dividend\\n\\t5 << 2 = 5*2*2 = 20      // less than dividend\\n\\t5 << 3 = 5*2*2*2 = 40    // less than dividend\\n\\t5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend\\n```\\n\\nWe observe that:\\n`58 = (2^3 * 5) + (something * 5) + rem      // --- (III)`\\nYou can see we are getting close to the equation we initialy wanted (eqa II). \\n\\nSince 5 is multiplied with 2<sup>3</sup>, ***we add 2<sup>3</sup> to our answer***.\\nFurther operating on equation III:\\n```\\n\\t58 - (2^3 * 5)  =  (something * 5) + rem\\n\\t58 - (8 * 5) = something * 5 + rem\\n\\t58 - 40 = something * 5 + rem\\n\\t18 = something * 5 + rem\\n```\\n\\nWhat we effectively have done is, subtracted the result we got from our first step from dividend `(58 - 40)`.\\nWe arived at the same question again but with a smaller dividend this time. \\n`dividend = 18, divisor = 5`\\n\\nTherefore let us repeat the process:\\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // less than dividend\\n\\t5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend\\n```\\n***We add  2<sup>1</sup> to our answer***.\\nLooking back: \\n```\\n\\t18  =  (2^1 * 5) + (something * 5) + rem\\n\\t58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\\n\\t58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem\\n```\\nYou can notice we are gradually advancing towards equ II:\\nOur new dividend is now:\\n```\\n\\t18 - (2^1 * 5)  =  (something * 5) + rem\\n\\t18 - (2 * 5) = something * 5 + rem\\n\\t18 - 10 = something * 5 + rem\\n\\t8 = something * 5 + rem\\n```\\n`dividend = 8, divisor = 5`\\nRepeating the process:\\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend\\n```\\n***We add  2<sup>0</sup> to our answer.***\\nNew dividend: \\n```\\n\\t8 = (2^0 * 5) + (something * 5) + rem\\n\\t8 - 5 = something * 5 + rem\\n\\t3 = something * 5 + rem\\n```\\n`dividend = 3, divisor = 5`\\nAt this step, we stop iterating as our dividend is less than the divisor (we have also found our remainder = 3, as 5 should be multiplied with 0 and what remains is the remainder).\\n\\nLooking back again for the last time:\\n```\\n\\t3 = 0*5 + rem\\n\\t8 = (2^0 * 5) + 3\\n\\t18  =  (2^0 * 5) + (2^1 * 5) + 3\\n\\t58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3\\n```\\nIn the process, we have finally reached the equation we wanted to, and have got the answer as:\\n`quotient = (2^3 + 2^1 + 2^0)`\\n\\n# **Code:**\\nSince we are not allowed to have any numerical data type bigger than 32 bit integer, we will use the last bit reserved for sign to avoid overflow by using the unsinged int in c++:\\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```\\n***Please upvote if you find this helpful, or if you think someone else might find it useful :)***\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tdividend = (quotient) * divisor + remainder\\n```\n```\\n\\t58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\\n\\t58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)\\n```\n```\\n\\t5 << 0 = 5               // less than dividend\\n\\t5 << 1 = 5*2 = 10        // less than dividend\\n\\t5 << 2 = 5*2*2 = 20      // less than dividend\\n\\t5 << 3 = 5*2*2*2 = 40    // less than dividend\\n\\t5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t58 - (2^3 * 5)  =  (something * 5) + rem\\n\\t58 - (8 * 5) = something * 5 + rem\\n\\t58 - 40 = something * 5 + rem\\n\\t18 = something * 5 + rem\\n```\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // less than dividend\\n\\t5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t18  =  (2^1 * 5) + (something * 5) + rem\\n\\t58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\\n\\t58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem\\n```\n```\\n\\t18 - (2^1 * 5)  =  (something * 5) + rem\\n\\t18 - (2 * 5) = something * 5 + rem\\n\\t18 - 10 = something * 5 + rem\\n\\t8 = something * 5 + rem\\n```\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t8 = (2^0 * 5) + (something * 5) + rem\\n\\t8 - 5 = something * 5 + rem\\n\\t3 = something * 5 + rem\\n```\n```\\n\\t3 = 0*5 + rem\\n\\t8 = (2^0 * 5) + 3\\n\\t18  =  (2^0 * 5) + (2^1 * 5) + 3\\n\\t58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3\\n```\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142849,
                "title": "c-java-python-should-not-use-long-int",
                "content": "## **Update 2019/02**\\nUsed to work on Leetcode when I wrote this solution, before 2019/02.\\nNow it\\'s broken. The C++ compiler on the Leetcode is changed.\\nI have locally clang-1000 and the solutions work very well.\\n\\n## **Preword**\\nThe description note that:\\n\"Assume we are dealing with an environment,\\nwhich could **only store integers within the 32-bit** signed integer range: `[\\u22122^31,  2^31 \\u2212 1]`.\"\\n\\nBut most of solution use \"long\" integer.\\nSo I share my solution here.\\n\\n## **Solution 1**\\n\\nOnly one corner case is `-2^31 / 1` and I deal with it at the first line.\\n\\nThis solution has `O(logN^2)` time complexity.\\n\\n**C++:**\\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n## **Solution 2**\\nAnother solution is also `O(32)`\\n\\n**C++:**\\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((signed)((unsigned)a >> x) - b >= 0)\\n                res += 1 << x, a -= b << x;\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((a >>> x) - b >= 0) {\\n                res += 1 << x;\\n                a -= b << x;\\n            }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n**Python:**\\n```python\\n    def divide(self, A, B):\\n        if (A == -2147483648 and B == -1): return 2147483647\\n        a, b, res = abs(A), abs(B), 0\\n        for x in range(32)[::-1]:\\n            if (a >> x) - b >= 0:\\n                res += 1 << x\\n                a -= b << x\\n        return res if (A > 0) == (B > 0) else -res\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((signed)((unsigned)a >> x) - b >= 0)\\n                res += 1 << x, a -= b << x;\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((a >>> x) - b >= 0) {\\n                res += 1 << x;\\n                a -= b << x;\\n            }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```python\\n    def divide(self, A, B):\\n        if (A == -2147483648 and B == -1): return 2147483647\\n        a, b, res = abs(A), abs(B), 0\\n        for x in range(32)[::-1]:\\n            if (a >> x) - b >= 0:\\n                res += 1 << x\\n                a -= b << x\\n        return res if (A > 0) == (B > 0) else -res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13403,
                "title": "clear-python-code",
                "content": "    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        positive = (dividend < 0) is (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n        if not positive:\\n            res = -res\\n        return min(max(-2147483648, res), 2147483647)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        positive = (dividend < 0) is (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n        if not positive:\\n            res = -res\\n        return min(max(-2147483648, res), 2147483647)",
                "codeTag": "Java"
            },
            {
                "id": 13397,
                "title": "clean-java-solution-with-some-comment",
                "content": "  \\tpublic int divide(int dividend, int divisor) {\\n\\t\\t//Reduce the problem to positive long integer to make it easier.\\n\\t\\t//Use long to avoid integer overflow cases.\\n\\t\\tint sign = 1;\\n\\t\\tif ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n\\t\\t\\tsign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\t\\n\\t\\t//Take care the edge cases.\\n\\t\\tif (ldivisor == 0) return Integer.MAX_VALUE;\\n\\t\\tif ((ldividend == 0) || (ldividend < ldivisor))\\treturn 0;\\n\\t\\t\\n\\t\\tlong lans = ldivide(ldividend, ldivisor);\\n\\t\\t\\n\\t\\tint ans;\\n\\t\\tif (lans > Integer.MAX_VALUE){ //Handle overflow.\\n\\t\\t\\tans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE;\\n\\t\\t} else {\\n\\t\\t\\tans = (int) (sign * lans);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate long ldivide(long ldividend, long ldivisor) {\\n\\t\\t// Recursion exit condition\\n\\t\\tif (ldividend < ldivisor) return 0;\\n\\t\\t\\n\\t\\t//  Find the largest multiple so that (divisor * multiple <= dividend), \\n\\t\\t//  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.\\n\\t\\t//  Think this as a binary search.\\n\\t\\tlong sum = ldivisor;\\n\\t\\tlong multiple = 1;\\n\\t\\twhile ((sum+sum) <= ldividend) {\\n\\t\\t\\tsum += sum;\\n\\t\\t\\tmultiple += multiple;\\n\\t\\t}\\n\\t\\t//Look for additional value for the multiple from the reminder (dividend - sum) recursively.\\n\\t\\treturn multiple + ldivide(ldividend - sum, ldivisor);\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "  \\tpublic int divide(int dividend, int divisor) {\\n\\t\\t//Reduce the problem to positive long integer to make it easier.\\n\\t\\t//Use long to avoid integer overflow cases.\\n\\t\\tint sign = 1;\\n\\t\\tif ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n\\t\\t\\tsign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\t\\n\\t\\t//Take care the edge cases.\\n\\t\\tif (ldivisor == 0) return Integer.MAX_VALUE;\\n\\t\\tif ((ldividend == 0) || (ldividend < ldivisor))\\treturn 0;\\n\\t\\t\\n\\t\\tlong lans = ldivide(ldividend, ldivisor);\\n\\t\\t\\n\\t\\tint ans;\\n\\t\\tif (lans > Integer.MAX_VALUE){ //Handle overflow.\\n\\t\\t\\tans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE;\\n\\t\\t} else {\\n\\t\\t\\tans = (int) (sign * lans);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate long ldivide(long ldividend, long ldivisor) {\\n\\t\\t// Recursion exit condition\\n\\t\\tif (ldividend < ldivisor) return 0;\\n\\t\\t\\n\\t\\t//  Find the largest multiple so that (divisor * multiple <= dividend), \\n\\t\\t//  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.\\n\\t\\t//  Think this as a binary search.\\n\\t\\tlong sum = ldivisor;\\n\\t\\tlong multiple = 1;\\n\\t\\twhile ((sum+sum) <= ldividend) {\\n\\t\\t\\tsum += sum;\\n\\t\\t\\tmultiple += multiple;\\n\\t\\t}\\n\\t\\t//Look for additional value for the multiple from the reminder (dividend - sum) recursively.\\n\\t\\treturn multiple + ldivide(ldividend - sum, ldivisor);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 13467,
                "title": "very-detailed-step-by-step-explanation-java-solution",
                "content": "This seems to be a very difficult question with whole lot of restriction, but if you break down the question and tackle every sub-problem individually, it might not seem as hard as it is.\\n\\nFirst, we need to check whether the end result is positive or negative. Two cases will lead to negative case which is when dividend and divisor has different signs. Alright, first part is done.\\n\\nSecond part is to deal with overflow. You know, there are so many corner cases which will lead to overflow. So it is better to convert them to long first, and convert it back to integer when returning the value.\\n\\nAlright, now we get to the main part. We know that division is actually the backward of multiplication, for example , `20 / 5  = 4` can be seen as `4 * 5 = 20`. Here what we are going to do is to find the multiplication. We set tmp as divisor `(5)` and set count to `1`.  As long as the tmp is less than or equal to dividend `(20)`, we left shift `<<` **which is same as multiply 2 but without using multiplication**. \\n\\n    1st loop --- tmp = 10 , count = 2 \\n    2nd loop --- tmp = 20, count = 4\\n    3rd loop --- tmp = 40, count = 8 (exit the loop)\\n\\nNow we right shift both tmp and count by 1, which gives us result of `4` . After subtraction of `20` from dividend, which gives us dividend = `0` and that we break out the outer loop and get to the last part.\\n\\nFinally, we gotta check if the sign is positive or negative. If it is negative, then we apply negation `~result` + `1` (two's complement) to get the negative result (why not just `result * -1` ? Well, critics might say you use multiplication -_-!!! (lol jk). Also make sure to check if result is overflow, because you know, leetcode is pretty strict to corner cases as well.\\n\\n----------\\n\\nAnother example : `10 / 3 = 3`\\n\\n    1st outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6 , count = 2\\n    2nd inner loop --- tmp = 12, count = 4 (exit the inner loop, result = 0 + (4 >> 1) = 2)\\n\\n    dividend = 10 - (12 >> 1) = 10 - 6 = 4 (4 >  divisor, so here we go second outer loop)\\n\\n    2nd outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6, count = 2 (exit the inner loop, result = 2 + (2 >> 1) = 3)\\n\\n    dividend = 4 - (6 >> 1) = 4 - 3 = 1( divisor > 1, exit outer loop, return result)\\n\\n----------\\n\\nCredits to @HelloWorld123456. Here is the simplified code: \\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean isNegative = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) ? true : false;\\n        long absDividend = Math.abs((long) dividend);\\n        long absDivisor = Math.abs((long) divisor);\\n        long result = 0;\\n        while(absDividend >= absDivisor){\\n            long tmp = absDivisor, count = 1;\\n            while(tmp <= absDividend){\\n                tmp <<= 1;\\n                count <<= 1;\\n            }\\n            result += count >> 1;\\n            absDividend -= tmp >> 1;\\n        }\\n        return  isNegative ? (int) ~result + 1 : result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This seems to be a very difficult question with whole lot of restriction, but if you break down the question and tackle every sub-problem individually, it might not seem as hard as it is.\\n\\nFirst, we need to check whether the end result is positive or negative. Two cases will lead to negative case which is when dividend and divisor has different signs. Alright, first part is done.\\n\\nSecond part is to deal with overflow. You know, there are so many corner cases which will lead to overflow. So it is better to convert them to long first, and convert it back to integer when returning the value.\\n\\nAlright, now we get to the main part. We know that division is actually the backward of multiplication, for example , `20 / 5  = 4` can be seen as `4 * 5 = 20`. Here what we are going to do is to find the multiplication. We set tmp as divisor `(5)` and set count to `1`.  As long as the tmp is less than or equal to dividend `(20)`, we left shift `<<` **which is same as multiply 2 but without using multiplication**. \\n\\n    1st loop --- tmp = 10 , count = 2 \\n    2nd loop --- tmp = 20, count = 4\\n    3rd loop --- tmp = 40, count = 8 (exit the loop)\\n\\nNow we right shift both tmp and count by 1, which gives us result of `4` . After subtraction of `20` from dividend, which gives us dividend = `0` and that we break out the outer loop and get to the last part.\\n\\nFinally, we gotta check if the sign is positive or negative. If it is negative, then we apply negation `~result` + `1` (two's complement) to get the negative result (why not just `result * -1` ? Well, critics might say you use multiplication -_-!!! (lol jk). Also make sure to check if result is overflow, because you know, leetcode is pretty strict to corner cases as well.\\n\\n----------\\n\\nAnother example : `10 / 3 = 3`\\n\\n    1st outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6 , count = 2\\n    2nd inner loop --- tmp = 12, count = 4 (exit the inner loop, result = 0 + (4 >> 1) = 2)\\n\\n    dividend = 10 - (12 >> 1) = 10 - 6 = 4 (4 >  divisor, so here we go second outer loop)\\n\\n    2nd outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6, count = 2 (exit the inner loop, result = 2 + (2 >> 1) = 3)\\n\\n    dividend = 4 - (6 >> 1) = 4 - 3 = 1( divisor > 1, exit outer loop, return result)\\n\\n----------\\n\\nCredits to @HelloWorld123456. Here is the simplified code: \\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean isNegative = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) ? true : false;\\n        long absDividend = Math.abs((long) dividend);\\n        long absDivisor = Math.abs((long) divisor);\\n        long result = 0;\\n        while(absDividend >= absDivisor){\\n            long tmp = absDivisor, count = 1;\\n            while(tmp <= absDividend){\\n                tmp <<= 1;\\n                count <<= 1;\\n            }\\n            result += count >> 1;\\n            absDividend -= tmp >> 1;\\n        }\\n        return  isNegative ? (int) ~result + 1 : result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089533,
                "title": "easy-solution-in-c",
                "content": "The idea here is to use addition efficiently to compute the final result...\\nwe know that division can be done using addition or subtraction...\\nfor example 20/3 = 3+3+3+3+3+3+(2, ignored) (result is 6 times 3 hence 6)\\n\\nHence the loop is run, n times where n is our result...\\nTo more efficiently compute this, we can reduce the loops to log n time by adding divisor everytime it is added on...\\n\\nSo 20/3 = 3 + 6 + 12 + (24, ignore) (curr result is 2^(3-1)=4, 3 here is number of iterations...) \\nleft over sum, 20-12 = 8, and we repeat the process...\\nSo 8/3 = 3 + 6 + (12, ignore) (this time result is 2^(2-1)=2, 2 here is number of iterations...)\\nleft over sum, 8-6 = 2, since 2 is less than 3, we terminate the process...\\n\\nHence final result is 4+2 = 6\\n\\n**Pls upvote the  thread if you found it helpful.**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        //Handling corner cases\\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n        //Converting divisors and dividend to their positive values\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n        //Result Variables\\n        int res=0;\\n        while(dv<=dd) {\\n            long int mul=dv, tmp=1;\\n            while(mul<=dd-mul) {\\n                mul+=mul;\\n                tmp+=tmp;\\n            }\\n            res+=tmp;\\n            dd-=mul;\\n        }\\n        \\n        //If either of dividend or divisor is negative our result will be negative\\n        if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        //Handling corner cases\\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n        //Converting divisors and dividend to their positive values\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n        //Result Variables\\n        int res=0;\\n        while(dv<=dd) {\\n            long int mul=dv, tmp=1;\\n            while(mul<=dd-mul) {\\n                mul+=mul;\\n                tmp+=tmp;\\n            }\\n            res+=tmp;\\n            dd-=mul;\\n        }\\n        \\n        //If either of dividend or divisor is negative our result will be negative\\n        if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13417,
                "title": "no-use-of-long-java-solution",
                "content": "Integer.MIN_VALUE as dividend is really troublesome. Thus, I turn everything to negative value and keep finding closest 1,2,4,8... multiples and recursive on rest. The only case that will cause overflow is Integer.MIN_VALUE / -1, so I list it alone as an edge case. \\n\\n\\n    public class Solution {\\n        public int divide(int dividend, int divisor) {\\n    \\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n            if(dividend > 0 && divisor > 0) return divideHelper(-dividend, -divisor);\\n            else if(dividend > 0) return -divideHelper(-dividend,divisor);\\n            else if(divisor > 0) return -divideHelper(dividend,-divisor);\\n            else return divideHelper(dividend, divisor);\\n        }\\n        \\n        private int divideHelper(int dividend, int divisor){\\n            // base case\\n            if(divisor < dividend) return 0;\\n            // get highest digit of divisor\\n            int cur = 0, res = 0;\\n            while((divisor << cur) >= dividend && divisor << cur < 0 && cur < 31) cur++;\\n            res = dividend - (divisor << cur-1);\\n            if(res > divisor) return 1 << cur-1;\\n            return (1 << cur-1)+divide(res, divisor);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int divide(int dividend, int divisor) {\\n    \\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n            if(dividend > 0 && divisor > 0) return divideHelper(-dividend, -divisor);\\n            else if(dividend > 0) return -divideHelper(-dividend,divisor);\\n            else if(divisor > 0) return -divideHelper(dividend,-divisor);\\n            else return divideHelper(dividend, divisor);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 427345,
                "title": "python-24ms-beats-99-with-and-w-o-bitwise-operators",
                "content": "**With [bitwise operators](https://wiki.python.org/moin/BitwiseOperators):**\\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        divisor, dividend = abs(divisor), abs(dividend)\\n\\n        quotient = 0\\n        the_sum = divisor\\n\\n        while the_sum <= dividend:\\n            current_quotient = 1\\n            while (the_sum << 1) <= dividend:\\n                the_sum <<= 1\\n                current_quotient <<= 1            \\n            dividend -= the_sum\\n            the_sum = divisor\\n            quotient += current_quotient\\n\\n        return min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\\nRuntime: 24 ms, faster than 99.56% of Python3 online submissions for Divide Two Integers.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Divide Two Integers.\\n\\n**Without bitwise operators:**\\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tis_negative = (dividend < 0) != (divisor < 0)\\n\\t\\tdivisor, dividend = abs(divisor), abs(dividend)\\n\\n\\t\\tquotient = 0\\n\\t\\tthe_sum = divisor\\n\\n\\t\\twhile the_sum <= dividend:\\n\\t\\t\\tcurrent_quotient = 1\\n\\t\\t\\twhile (the_sum + the_sum) <= dividend:\\n\\t\\t\\t\\tthe_sum += the_sum\\n\\t\\t\\t\\tcurrent_quotient += current_quotient\\n\\t\\t\\tdividend -= the_sum\\n\\t\\t\\tthe_sum = divisor\\n\\t\\t\\tquotient += current_quotient\\n\\n\\t\\treturn min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\\n**How it works**\\nFor example, we `divide(5000, 14)`:\\n1) After the first inner loop: `the_sum = 3584` which is `14` multiplied `256` times. \\nWe can\\'t multiply any more \\u2014 because after `256` is coming `256 + 256 = 512` and `14 * 512 = 7168` which is larger than our `dividend`, so we exit the inner loop,\\nReducing dividend: `dividend = 5000 - 3584 = 1416` \\nAnd moving to another cycle of outer loop\\n2) After the second inner loop: `the_sum = 896` which is `14` multiplied `64` times.  \\n3) Third: `the_sum = 448` which is `14` multiplied `32` times.  \\n4) And so on\\n5) Finally we have: `quotient = 256 + 64 + 32 + 4 + 1 = 357`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        divisor, dividend = abs(divisor), abs(dividend)\\n\\n        quotient = 0\\n        the_sum = divisor\\n\\n        while the_sum <= dividend:\\n            current_quotient = 1\\n            while (the_sum << 1) <= dividend:\\n                the_sum <<= 1\\n                current_quotient <<= 1            \\n            dividend -= the_sum\\n            the_sum = divisor\\n            quotient += current_quotient\\n\\n        return min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tis_negative = (dividend < 0) != (divisor < 0)\\n\\t\\tdivisor, dividend = abs(divisor), abs(dividend)\\n\\n\\t\\tquotient = 0\\n\\t\\tthe_sum = divisor\\n\\n\\t\\twhile the_sum <= dividend:\\n\\t\\t\\tcurrent_quotient = 1\\n\\t\\t\\twhile (the_sum + the_sum) <= dividend:\\n\\t\\t\\t\\tthe_sum += the_sum\\n\\t\\t\\t\\tcurrent_quotient += current_quotient\\n\\t\\t\\tdividend -= the_sum\\n\\t\\t\\tthe_sum = divisor\\n\\t\\t\\tquotient += current_quotient\\n\\n\\t\\treturn min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13428,
                "title": "15-line-easy-understand-solution-129ms",
                "content": "for example, if we want to calc (17/2)\\n\\nret = 0;\\n\\n17-2  ,ret+=1; left=15\\n\\n15-4  ,ret+=2; left=11\\n\\n11-8  ,ret+=4; left=3\\n\\n3-2    ,ret+=1; left=1\\n\\n\\nret=8;\\n\\n\\n\\n\\n\\n\\n    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        isMinus= ((dividend<0 and divisor >0) or (dividend>0 and divisor <0));\\n        ret=0;        \\n        dividend,divisor=abs(dividend),abs(divisor);\\n        c,sub=1,divisor;\\n\\n        while(dividend >= divisor):\\n            if(dividend>=sub):\\n                dividend-=sub;\\n                ret+=c;\\n                sub=(sub<<1);\\n                c=(c<<1);\\n            else:\\n                sub=(sub>>1);\\n                c=(c>>1);\\n        \\n        if(isMinus):\\n            ret=-ret;\\n        return min(max(-2147483648,ret),2147483647);",
                "solutionTags": [
                    "Python"
                ],
                "code": "for example, if we want to calc (17/2)\\n\\nret = 0;\\n\\n17-2  ,ret+=1; left=15\\n\\n15-4  ,ret+=2; left=11\\n\\n11-8  ,ret+=4; left=3\\n\\n3-2    ,ret+=1; left=1\\n\\n\\nret=8;\\n\\n\\n\\n\\n\\n\\n    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        isMinus= ((dividend<0 and divisor >0) or (dividend>0 and divisor <0));\\n        ret=0;        \\n        dividend,divisor=abs(dividend),abs(divisor);\\n        c,sub=1,divisor;\\n\\n        while(dividend >= divisor):\\n            if(dividend>=sub):\\n                dividend-=sub;\\n                ret+=c;\\n                sub=(sub<<1);\\n                c=(c<<1);\\n            else:\\n                sub=(sub>>1);\\n                c=(c>>1);\\n        \\n        if(isMinus):\\n            ret=-ret;\\n        return min(max(-2147483648,ret),2147483647);",
                "codeTag": "Java"
            },
            {
                "id": 13460,
                "title": "6-line-solution-c",
                "content": "Basic idea: a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b))\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if (dividend==0) return 0;\\n            if (divisor==0) return INT_MAX;\\n            long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n            if ((dividend<0)^(divisor<0)) res=-res;\\n            if (res>INT_MAX) res=INT_MAX;\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if (dividend==0) return 0;\\n            if (divisor==0) return INT_MAX;\\n            long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n            if ((dividend<0)^(divisor<0)) res=-res;\\n            if (res>INT_MAX) res=INT_MAX;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1327339,
                "title": "java-0ms-100-faster-obeys-all-conditions",
                "content": "If you are furiously looking for answers as i was, let me shed some light. I had to spend a lots of time to understand the secret behind the solutions to this problem. \\n\\nFirst of all, As we all know already the basic idea for solving the problem with out the mod operator is simply **identifying the number of times the divisor can fully SUBSTRACT the dividend as a whole** but iterations are so costly and it will not work for large numbers. The obvious secret is to identify **effective way to reduce the number of substractions**\\n\\nThe following is simply my idea but there can be many as well, \\n\\n**1. Exponensly increase the divisor until before it surpass the dividend then substract with it.\\n2. Add up the divisor and find the remainder.\\n3. Repeat the same until it brings to 0**\\n\\nFor an example, 116 divided by 3, Following is the way to gradually reduce the possibilities and idendify the final quotient\\n\\n![image](https://assets.leetcode.com/users/images/31c9c3ac-8bd5-437a-a976-ad74d369e0f0_1624215160.6451015.png)\\n\\nLets start with 3, then double it which is 6 then 12, 24,..until we stop at 96 because 192 can be substracted. So here 96 == 3 * 2^5 ==  3 << 5 and quotient = 32, remainder = 20\\n\\nLet start the same process again with 20, it can go upto which gets to 12 == 3 * 2^2 == 3 << 2 then the quotient is now 32 + 4 = 36, reminder = 8\\n\\nLets start over again, i can go upto 6 which is again 6 == 3 * 2^1 == 3 << 1 the quotient is not 36+2 = 38, remainder = 2 which is less than divisor so we can not continue with the cycle and all ends here.\\n\\nHowever multiplication is not allowed to use let see what else we can do for replacing it. \\n\\n**Programmatic Rule:**\\nLeft Shift (<<) shall be considered as multiplication by 2^N\\nSimilarly, Right Shift (>>) shall be considered as division by 2^N \\n\\nSince the environment only allows to accomodate `integer`  data type, overflow cases are the corner cases.\\n\\nLets dive into the code,\\n\\n```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13420,
                "title": "32-times-bit-shift-operation-in-c-with-o-1-solution",
                "content": "we assure the factor `ret`'s binary fomula is\\n\\n`ret = a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31;  ai = 0 or 1, i = 0......31`\\n\\nthe dividend `B` and divisor `A` is non-negative, then\\n\\n`A(a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31) = B;    Eq1`\\n\\n(1) when `Eq1` divided by `2^31`, we can get  `A*a31 = B>>31`;  then `a31 = (B>>31)/A`;\\n\\nif `(B>>31) > A`, then `a31 = 1`; else `a31 = 0`;\\n\\n(2) when `Eq1` divided by `2^30`, we can get  `A*a30 + A*a31*2 = B>>30`;  then `a30 = ((B>>30) - a31*A*2)/A`;  and `(B>>30) - a31*A*2` can be rewritten by `(B-a31*A<<31)>>30`, so we make `B' = B-a31*A<<31`, the formula simplified to `a30 = (B'>>30)/A`\\n\\nif `(B'>>30) > A`, then `a30 = 1`; else `a30 = 0`;\\n\\n(3) in the same reason, we can get  `a29 = ((B-a31*A<<31-a30*A<<30)>>29)/A`, we make `B'' = B' - a30*A<<30`, the formula simplified to `a29 = (B''>>29)/A`;\\n\\ndo the same bit operation `32` times, we can get `a31 ..... a0`, so we get the `ret` finally.\\n\\nthe C solution with constant time complexity\\n\\n    int divide(int dividend, int divisor) {\\n        //special cases\\n        if(divisor == 0 || (dividend == INT_MIN && divisor == -1))\\n            return INT_MAX;\\n        \\n        // transform to unsigned int\\n        bool sign = (dividend > 0)^(divisor > 0);\\n        unsigned int A = (divisor < 0) ? -divisor : divisor;\\n        unsigned int B = (dividend < 0) ? -dividend : dividend;\\n        int ret = 0;\\n        \\n        // shift 32 times\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if((B>>i) >= A)\\n            {\\n                ret = (ret<<1)|0x01;\\n                B -= (A<<i);   // update B\\n            }\\n            else\\n                ret = ret<<1;\\n        }\\n        \\n        if(sign)\\n            ret = -ret;\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "we assure the factor `ret`'s binary fomula is\\n\\n`ret = a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31;  ai = 0 or 1, i = 0......31`\\n\\nthe dividend `B` and divisor `A` is non-negative, then\\n\\n`A(a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31) = B;    Eq1`\\n\\n(1) when `Eq1` divided by `2^31`, we can get  `A*a31 = B>>31`;  then `a31 = (B>>31)/A`;\\n\\nif `(B>>31) > A`, then `a31 = 1`; else `a31 = 0`;\\n\\n(2) when `Eq1` divided by `2^30`, we can get  `A*a30 + A*a31*2 = B>>30`;  then `a30 = ((B>>30) - a31*A*2)/A`;  and `(B>>30) - a31*A*2` can be rewritten by `(B-a31*A<<31)>>30`, so we make `B' = B-a31*A<<31`, the formula simplified to `a30 = (B'>>30)/A`\\n\\nif `(B'>>30) > A`, then `a30 = 1`; else `a30 = 0`;\\n\\n(3) in the same reason, we can get  `a29 = ((B-a31*A<<31-a30*A<<30)>>29)/A`, we make `B'' = B' - a30*A<<30`, the formula simplified to `a29 = (B''>>29)/A`;\\n\\ndo the same bit operation `32` times, we can get `a31 ..... a0`, so we get the `ret` finally.\\n\\nthe C solution with constant time complexity\\n\\n    int divide(int dividend, int divisor) {\\n        //special cases\\n        if(divisor == 0 || (dividend == INT_MIN && divisor == -1))\\n            return INT_MAX;\\n        \\n        // transform to unsigned int\\n        bool sign = (dividend > 0)^(divisor > 0);\\n        unsigned int A = (divisor < 0) ? -divisor : divisor;\\n        unsigned int B = (dividend < 0) ? -dividend : dividend;\\n        int ret = 0;\\n        \\n        // shift 32 times\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if((B>>i) >= A)\\n            {\\n                ret = (ret<<1)|0x01;\\n                B -= (A<<i);   // update B\\n            }\\n            else\\n                ret = ret<<1;\\n        }\\n        \\n        if(sign)\\n            ret = -ret;\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3233898,
                "title": "best-c-2-solution-easy-solution-math-bit-manipulation-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Math + Bit Manipulation.\\n2. Solved using Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(log(N)*log(N)), The time complexity of the code is O(log(N)*log(N)) since the outer loop\\n    and the inner loop both runs log(N) times, where N is the dividend.\\n\\n    Space Complexity : O(1), The space complexity of the above code is O(1) since we\\u2019re using constant extra\\n    space.\\n\\n    Solved using Math + Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        long long dvd = labs(dividend), dvs = labs(divisor), result = 0;\\n        int sign = (dividend > 0) ^ (divisor > 0) == 0 ? 1 : -1;\\n        while(dvd >= dvs){\\n            long long temp = dvs, mul = 1;\\n            while(temp << 1 <= dvd){\\n                temp <<= 1;\\n                mul <<= 1;\\n            }\\n            dvd -= temp;\\n            result += mul;\\n        } \\n        return sign*result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), Constant Operation.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        return dividend/divisor;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(log(N)*log(N)), The time complexity of the code is O(log(N)*log(N)) since the outer loop\\n    and the inner loop both runs log(N) times, where N is the dividend.\\n\\n    Space Complexity : O(1), The space complexity of the above code is O(1) since we\\u2019re using constant extra\\n    space.\\n\\n    Solved using Math + Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        long long dvd = labs(dividend), dvs = labs(divisor), result = 0;\\n        int sign = (dividend > 0) ^ (divisor > 0) == 0 ? 1 : -1;\\n        while(dvd >= dvs){\\n            long long temp = dvs, mul = 1;\\n            while(temp << 1 <= dvd){\\n                temp <<= 1;\\n                mul <<= 1;\\n            }\\n            dvd -= temp;\\n            result += mul;\\n        } \\n        return sign*result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), Constant Operation.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        return dividend/divisor;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13402,
                "title": "fast-and-simple-python-solutions-56ms-64ms-no-bitwise-operators",
                "content": "idea: \\nkeep subtracting the new divisor `div` from the remaining `left` and then doubling `div` (by `div += div`). if `left < div`, start from the original divisor. Do these until `left < divisor.`<p>\\n\\n\\n----------\\n\\n\\n    def divide(self, dividend, divisor):     \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)\\n        Q = 1\\n        ans = 0\\n        while left >= divisor:\\n            left -= div\\n            ans  += Q \\n            Q    += Q\\n            div  += div\\n            if left < div:\\n                div = divisor\\n                Q = 1\\n        if neg:\\n            return max(-ans, -2147483648)\\n        else:\\n            return min(ans, 2147483647)\\n\\n\\n----------\\n\\n\\nRecursive version: \\n\\n    def divide(self, dividend, divisor):  \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)       \\n        if dividend < divisor:\\n            return 0\\n        Q = 1\\n        ans = 0\\n        while left >= div:\\n            left -= div\\n            ans  += Q\\n            Q    += Q\\n            div  += div\\n        if neg:\\n            return max(-(ans + self.divide(left, divisor)), -2147483648)\\n        else:\\n            return min(ans + self.divide(left, divisor), 2147483647)",
                "solutionTags": [
                    "Python"
                ],
                "code": "idea: \\nkeep subtracting the new divisor `div` from the remaining `left` and then doubling `div` (by `div += div`). if `left < div`, start from the original divisor. Do these until `left < divisor.`<p>\\n\\n\\n----------\\n\\n\\n    def divide(self, dividend, divisor):     \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)\\n        Q = 1\\n        ans = 0\\n        while left >= divisor:\\n            left -= div\\n            ans  += Q \\n            Q    += Q\\n            div  += div\\n            if left < div:\\n                div = divisor\\n                Q = 1\\n        if neg:\\n            return max(-ans, -2147483648)\\n        else:\\n            return min(ans, 2147483647)\\n\\n\\n----------\\n\\n\\nRecursive version: \\n\\n    def divide(self, dividend, divisor):  \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)       \\n        if dividend < divisor:\\n            return 0\\n        Q = 1\\n        ans = 0\\n        while left >= div:\\n            left -= div\\n            ans  += Q\\n            Q    += Q\\n            div  += div\\n        if neg:\\n            return max(-(ans + self.divide(left, divisor)), -2147483648)\\n        else:\\n            return min(ans + self.divide(left, divisor), 2147483647)",
                "codeTag": "Python3"
            },
            {
                "id": 13528,
                "title": "ac-javascript-code",
                "content": "The algorithm is just the same as many other posts, double the divisor by shifting left 1 bit.\\n\\nBut I still got TLE 3 times, the trick is: JavaScript bitwise op is for signed 32-bit, so \\n\\n    while ((base << 1) <= dividend) {\\n\\ndoesn't work. Because \"base\" overflows.\\n\\n    while (base <= (dividend >> 1)) {\\n\\nworks.\\n\\n    /**\\n     * @param {number} dividend\\n     * @param {number} divisor\\n     * @return {number}\\n     */\\n    var divide = function(dividend, divisor) {\\n      if (divisor === 0) return 0;\\n      if (dividend === 0) return 0;\\n      if (dividend === -2147483648 && divisor === -1) return 2147483647;\\n    \\n      var isPositive = true;\\n      if (dividend > 0 !== divisor > 0) isPositive = false;\\n    \\n      divisor = Math.abs(divisor);\\n      dividend = Math.abs(dividend);\\n    \\n      var count = 1,\\n        result = 0,\\n        base = divisor;\\n    \\n      while (dividend >= divisor) {\\n        count = 1;\\n        base = divisor;\\n        while (base <= (dividend >> 1)) {\\n          base = base << 1;\\n          count = count << 1;\\n        }\\n        result += count;\\n        dividend -= base;\\n      }\\n    \\n      if (!isPositive) result = -result;\\n      return result;\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "The algorithm is just the same as many other posts, double the divisor by shifting left 1 bit.\\n\\nBut I still got TLE 3 times, the trick is: JavaScript bitwise op is for signed 32-bit, so \\n\\n    while ((base << 1) <= dividend) {\\n\\ndoesn't work. Because \"base\" overflows.\\n\\n    while (base <= (dividend >> 1)) {\\n\\nworks.\\n\\n    /**\\n     * @param {number} dividend\\n     * @param {number} divisor\\n     * @return {number}\\n     */\\n    var divide = function(dividend, divisor) {\\n      if (divisor === 0) return 0;\\n      if (dividend === 0) return 0;\\n      if (dividend === -2147483648 && divisor === -1) return 2147483647;\\n    \\n      var isPositive = true;\\n      if (dividend > 0 !== divisor > 0) isPositive = false;\\n    \\n      divisor = Math.abs(divisor);\\n      dividend = Math.abs(dividend);\\n    \\n      var count = 1,\\n        result = 0,\\n        base = divisor;\\n    \\n      while (dividend >= divisor) {\\n        count = 1;\\n        base = divisor;\\n        while (base <= (dividend >> 1)) {\\n          base = base << 1;\\n          count = count << 1;\\n        }\\n        result += count;\\n        dividend -= base;\\n      }\\n    \\n      if (!isPositive) result = -result;\\n      return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 13426,
                "title": "simple-o-log-n-2-c-solution",
                "content": "Long division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations. \\n So  the overall complexity is O(( log N)^2) \\n\\n    typedef long long ll;\\n\\n    int divide(int n_, int d_) {\\n        ll ans=0;\\n        ll n=abs((ll)n_);\\n        ll d=abs((ll)d_);\\n        while(n>=d){\\n            ll a=d;\\n            ll m=1;\\n            while((a<<1) < n){a<<=1;m<<=1;}\\n            ans+=m;\\n            n-=a;\\n        }\\n        if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n            return -ans;\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Long division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations. \\n So  the overall complexity is O(( log N)^2) \\n\\n    typedef long long ll;\\n\\n    int divide(int n_, int d_) {\\n        ll ans=0;\\n        ll n=abs((ll)n_);\\n        ll d=abs((ll)d_);\\n        while(n>=d){\\n            ll a=d;\\n            ll m=1;\\n            while((a<<1) < n){a<<=1;m<<=1;}\\n            ans+=m;\\n            n-=a;\\n        }\\n        if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n            return -ans;\\n        return ans;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1163652,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func divide(_ dd: Int, _ dr: Int) -> Int {\\n        let dd64 = Int64(abs(dd)), dr64 = Int64(abs(dr))\\n        var val: Int64 = 0, lhs: Int64 = 1, rhs = dd64\\n        while lhs <= rhs {\\n            let mid = (lhs + rhs) / 2\\n            if mid * dr64 <= dd64 {\\n                val = mid\\n                lhs = mid + 1\\n            } else {\\n                rhs = mid - 1\\n            }\\n        }\\n        return max(min(Int((dd * dr) < 0 ? -val : val), Int(Int32.max)), Int(Int32.min))\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p><details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<p><pre>\\nResult: Executed 4 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 10/3 = 3.33333.. which is truncated to 3.\\n    func test0() {\\n        let value = solution.divide(10, 3)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // 7/-3 = -2.33333.. which is truncated to -2.\\n    func test1() {\\n        let value = solution.divide(7, -3)\\n        XCTAssertEqual(value, -2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.divide(0, -1)\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    func test3() {\\n        let value = solution.divide(1, 1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func divide(_ dd: Int, _ dr: Int) -> Int {\\n        let dd64 = Int64(abs(dd)), dr64 = Int64(abs(dr))\\n        var val: Int64 = 0, lhs: Int64 = 1, rhs = dd64\\n        while lhs <= rhs {\\n            let mid = (lhs + rhs) / 2\\n            if mid * dr64 <= dd64 {\\n                val = mid\\n                lhs = mid + 1\\n            } else {\\n                rhs = mid - 1\\n            }\\n        }\\n        return max(min(Int((dd * dr) < 0 ? -val : val), Int(Int32.max)), Int(Int32.min))\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 10/3 = 3.33333.. which is truncated to 3.\\n    func test0() {\\n        let value = solution.divide(10, 3)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // 7/-3 = -2.33333.. which is truncated to -2.\\n    func test1() {\\n        let value = solution.divide(7, -3)\\n        XCTAssertEqual(value, -2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.divide(0, -1)\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    func test3() {\\n        let value = solution.divide(1, 1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084819,
                "title": "python-o-log-n-honest-solution-explained",
                "content": "I do not really like these type of problems, where you restricted in using operations. What we can use if we can not use multiplications and divisions: we can use only addition and subtraction. Let consider an example:\\n`100 // 7`\\n\\nWe can try just to subtract `7` while it is possible.  However potentially it can be quite long, if `dividend` is big and `divisor` is small. Let us multiply `7` by `2` (in fact it is not multiplication, but addition with itself), until we are smaller than `100`.  `7 -> 14 -> 28 -> 56`. Ans subtract `56` now, so we have `8` as result and we need to divide `44` by `7` now. Repeat procedure, so we subtract `28`, and we have `8 + 4` as result and `44 - 28 = 16 = 2`. Finally, we subtract `14` and we have `8 + 4 + 2 = 14` as result.\\n\\nLet us precalculate pairs `(7, 1), (14, 2), (28, 4), (56, 8)`. Then we iterate through these pairs in opposite direction and if we can subtract corresponding number, we subtract, if not - we go to the next one. Also we need to deal with signs and overflows here.\\n\\n**Complexity**: time complexity is `O(log n)`, where `n = divident/divisor`: there will be `O(log n)` terms in our `cand` list as well as this is limit for number of steps. Space complexity is `O(log n)` as well. What I mean by **honest** here, that a lot of people here in discussion either use some tricks which are not allowed, or complexity is wrong.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        if dividend == -1<<31 and divisor == -1: return (1<<31)-1\\n\\n        a, b = abs(dividend), abs(divisor)\\n        sign = (dividend < 0) == (divisor < 0)\\n        res, cand = 0, [(1, b)]\\n        \\n        while b << 1 <= a:\\n            cand += [(cand[-1][0]<<1, b<<1)]\\n            b <<= 1\\n            \\n        for pw, num in cand[::-1]:\\n            if a >= num:\\n                a, res = a - num, res + pw\\n                \\n        return res if sign else -res\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        if dividend == -1<<31 and divisor == -1: return (1<<31)-1\\n\\n        a, b = abs(dividend), abs(divisor)\\n        sign = (dividend < 0) == (divisor < 0)\\n        res, cand = 0, [(1, b)]\\n        \\n        while b << 1 <= a:\\n            cand += [(cand[-1][0]<<1, b<<1)]\\n            b <<= 1\\n            \\n        for pw, num in cand[::-1]:\\n            if a >= num:\\n                a, res = a - num, res + pw\\n                \\n        return res if sign else -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715094,
                "title": "python-fast-code-with-detailed-explanation",
                "content": "I took the code of  [@tusizi](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code) and made it easier to understand by changing variable names, and adding a detailed explanation for each line. I\\'m also not experienced myself and whatever I right here comes from discussion forums and googling. The high level idea is that you substract `dividend` by `divisor` until `dividend` is less than `divisor`.  Also, the solution has two `while` loops. The inner `while` loop tries to substract `divisor`, `2*divisor`, `4*divisor` and so on, until `dividend` is less than `divisor` where it starts over the outer `while` loop. \\n\\n```\\nclass Solution:\\n# @return an integer\\ndef divide(self, dividend, divisor):\\n    positive = (dividend < 0) is (divisor < 0) # 1\\n    dividend, divisor = abs(dividend), abs(divisor) # 2\\n    res = 0 # 3\\n    while dividend >= divisor: # 4\\n            curr_divisor, num_divisors = divisor, 1 # 5\\n            while dividend >= curr_divisor: # 6\\n                dividend -= curr_divisor # 7\\n                res += num_divisors # 8\\n                \\n                curr_divisor = curr_divisor << 1 # 9\\n                num_divisors = num_divisors << 1 # 10\\n\\t\\t\\t\\t\\n    if not positive: # 11\\n        res = -res # 12\\n\\t\\t\\n    return min(max(-2147483648, res), 2147483647) # 13\\n```\\n\\n`#1`: `is` operator is similar to `==` operator except that it compares that whether both the operands refer to the same object or not. check [this](https://www.***.org/difference-operator-python/).\\nSo here, if both of `dividend` and `divisor` have similar sign, it returns `True`. Otherwise, `False`. This will be used in line `#11` when we check if the `positive` variable is `True` or `False`. And, if it\\'s not `True` (meaning if they don\\'t have similar signs, we add a `-` to the output (`#12`). Note that in this example `==` works just fine as `is`. \\n\\n`#2`: No that we decided on the sign in line `#1`, we can use absolute values of `dividend` and `divisor`. That\\'s what\\'s being done here. \\n\\n`#3`: Initiating the output by setting it to zero. \\n\\n`#4`: So the high level idea is that we substract `divisor` from `dividend` until we can\\'t substract anymore. Imagine you want to divide 7 by 2. 7-2 =5, 5-2=3, 3-2 = 1 ! You can\\'t substract anymore. Them the `while` loope stops. \\n\\n`#5`: Now, we enter the main (tricky, challenging, confusing) part of the code. This line is not complicated. It simply initilize some values, meaning `curr_divisor` and `num_divisors\\' with `divisor` and `1`, recpectively. This means we assume `curr_divisor = divisor` and `num_divisor = 1`, initially. \\n\\n`#7` and `#8`: These two lines are updating `dividend` and `res`. When you substract `dividend` by `curr_divisor`, you\\'re basically saying if I was going to calculating the quotient of division, I could still cut another piece with the size of `divisor` from `dividend`, and that\\'s why you update the `res` variable by num_divisor (`res += num_divisors` means `res = res + num_divisors`). \\n\\n`#9` and `#10`: `currdivisor = currdivisor << 1` is the same as `currdivisor = currdivisor  2`, and `numdivisors = numdivisors << 1`, is the same as`numdivisors = numdivisors2`. This is called bitwise operation. Check [this](https://wiki.python.org/moin/BitwiseOperators). `<<` sign is left-shifting bitwise operator which shift bits in binary of a number by one to the left. Imaging you have number 4, (`bin(4) = 0b100`)! doing `4 >> 1` make the new binary `1000` (shifted to the left by 1 and added a zero to the rightmost bit) which is the binary for 8. The reason it tries to do the multiplicaion is to fasten the process. From [here](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code/329694), A naive method here is to repeatedly subtract divisor from dividend, until there is none enough left. Then the count of subtractions will be the answer. Yet this takes linear time and is thus slow. A better method is to subtract divisor in a more efficient way. We can subtract divisor, 2divisor, 4divisor, 8*divisor... as is implemented above. .It will go to the outer loop once it cannot substract anymore of `curr_divisor` from `dividend`, and set the `curr_divisor = divisor` and tries the actual divisor (no 2  multiplications). \\n\\n`#13`: We are told by problem statement to limit the output to 32-bit integers, meaning the `res` parameter fall in the [-2^31, 2*^31-1] range. Here, the line has two components. First, it compares output (`res`) with -2^31 value and return the max of the two since we don\\'t want values less than -2^31. Next, it compares the value from `max(-2147483648, res)` with the maximum allowable value (meaning 2^31). So, if we put `a = max(-2147483648, res)`, then it does `min(a, 2147483647)` and return the min of two since we\\'re not allowed to go above 2^31 = 2147483647 number. \\n\\n=========================================\\n\\nFinal note: In order to fully understand the code, I suggest to grab a piece of paper and pen (or write on a notepad or something similar in out laptop/pc) and write a simple example and try to pass through the algorithm by hand. Here is an example from [this](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code/144026). \\n\\nLet\\'s take an example: `50 / 4`\\nAt the start,\\n`curr_divisor, num_divisors = divisor, 1` # dividend = 50, curr_divisor = 4, num_divisors = 1\\n`dividend -= curr_divisor` # dividend = 46, curr_divisor = 4 ,num_divisors = 1\\n`res += num_divisors` # res = 1\\n`num_divisors <<= 1 ` # dividend = 46, curr_divisor = 4 , num_divisors = 2\\n`curr_divisor <<= 1` # dividend = 46, curr_divisor = 8 , num_divisors = 2\\n\\nSecond iteration:\\n`dividend -= curr_divisor` # dividend = 38, curr_divisor = 8 , num_divisors= 2\\n`res += num_divisors` # res = 3\\n`num_divisors <<= 1` # dividend = 38, curr_divisor = 8 , num_divisors = 3\\n`curr_divisor <<= 1` # dividend = 38, curr_divisor = 12 ,  num_divisors = 3\\n\\nand so on, when `dividend > curr_divisor`, we start over again with `curr_divisor = 4`, and `num_divisors = 1`\\n\\n\\n===========================================================================\\nFinal note 2: Since I believe if I could explain something to others in a simple manner, it would be helpful to me, I try to add more posts like this as I move forward through my leetcode journey. \\n\\nFinal note 3: There might be some typos in the writing above!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n# @return an integer\\ndef divide(self, dividend, divisor):\\n    positive = (dividend < 0) is (divisor < 0) # 1\\n    dividend, divisor = abs(dividend), abs(divisor) # 2\\n    res = 0 # 3\\n    while dividend >= divisor: # 4\\n            curr_divisor, num_divisors = divisor, 1 # 5\\n            while dividend >= curr_divisor: # 6\\n                dividend -= curr_divisor # 7\\n                res += num_divisors # 8\\n                \\n                curr_divisor = curr_divisor << 1 # 9\\n                num_divisors = num_divisors << 1 # 10\\n\\t\\t\\t\\t\\n    if not positive: # 11\\n        res = -res # 12\\n\\t\\t\\n    return min(max(-2147483648, res), 2147483647) # 13\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076061,
                "title": "broken-calculator-js-python-java-c-simple-solution-w-detailed-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first thing we should be able to understand is that one of the operations increases **X** while the other one decreases it. So the natural tendency is to think about the solution in terms of applying these operations in order. That is, multiply as many times as you need to before subtracting as many times as you need to.\\n\\nWe see that that\\'s not a viable solution, however, once we recognize that one of the operations is quite obviously multiplicative rather than additive, meaning that a subtraction done *before* a multiplication has twice the impact, for example.\\n\\nSo the trick here is to think of the problem backwards: moving from **Y** to **X** instead of from **X** to **Y**. If **Y** is odd, we\\'re forced to do the additive operation (reversed from the subtractive operation) as we can\\'t divide an odd number by **2** and be able to reach **X**. If **Y** is even, we can prioritize the division operation instead. At each step we can increment our **ans**.\\n\\nOnce **Y** drops below **X**, the remaining difference must be made via the additive operation, so we can just **return** that difference plus **ans**.\\n\\n**To illustrate why the backwards order leads to the correct solution**, let\\'s take a look at an example: **X = 3, Y = 13**. Under the naive approach discussed at the very beginning of this section, we could apply the multiplication operation **3** times to achieve **24**, then apply the subtraction operation **11** times to bring **Y** back down to **13**.\\n\\nAs we observed before, that **11** is not very efficient, considering that some/all of those subtraction operations could have been done before some/all of the multiplication operations with greater impact.\\n\\nSo what if we had applied as many of those operations as necessary just *before* the last of the three multiplications? Then we would only have needed **5** operations to effect **10** subtraction, plus the leftover **1** to get to **11** at the end.\\n\\nIf we go back one more step before the second of three multiplications, we could have instead done **2** operations then which would have the effect of **8** substraction, plus an extra operation after the second multiplication (adding another **2** subtraction), plus the final operation after all multiplications to reach **11**.\\n\\nThis quickly begins to represent a binary representation of our target difference of **11**:\\n```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\\nWe can already see that this is starting to look like our backwards approach. At each additional multiplication operation available, we\\'re forced to perform a subtraction operation if the difference is still odd, otherwise, we can divide the remainder by **2** and push it back one multiplication earlier.\\n\\nBasically, for each multiplication we need to take **X** over **Y**, we take the remaining difference, count the first bit, then shift the difference to the right. And that should sound *exactly* like our backwards approach, because the first bit is a **0** if even and **1** if odd, and shifting to the right is the same as dividing by **2**.\\n\\n**So why can\\'t we go forwards with X instead of backwards with Y?** As mentioned before, the multiplication operation is, quite obviously, multiplicative, and will have an enhancing effect on any subtraction operations performed before it. Therefore, *we cannot possibly know* how much impact any given subtraction operation will have on the difference between **X** and **Y** until we find out how many multiplication operations we will need after it.\\n\\nSo any solution involving moving **X** to **Y** would at least require \"peeking\" ahead at part of the solution before progressing with the subtraction operations.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis solution is almost identical in all four languages.\\n\\nPython will convert our integer into a float if we simply divide by 2, so we can use the floor division operator instead to maintain the integer.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.2MB** (beats 100% / 90%).\\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.1MB** (beats 99% / 90%).\\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.4MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871168,
                "title": "python3-easiest-solution",
                "content": "1) Define the result\\'s sign and operate with positive dividend and divisor.\\n2) Calculate the result using the length of range.\\n3) Apply the sign.\\n4) Apply the 32-bit integer limitations.\\n\\nNo multiplication, division, or mod used.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "1) Define the result\\'s sign and operate with positive dividend and divisor.\\n2) Calculate the result using the length of range.\\n3) Apply the sign.\\n4) Apply the 32-bit integer limitations.\\n\\nNo multiplication, division, or mod used.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 778597,
                "title": "javascript-with-explanation-80ms-21-lines",
                "content": "Think of multiplication as just a * b = c. This can be rewritten as a + a + a + ... + a + a = c where a is repeated b times. Using this fact, we could naively keep subtracting a from c until c is too small, but this takes too long for large numbers. In order to speed this up, we keep doubling the total number of a\\'s we can subtract, there by making large calculations logarithmic instead of linear. I.e. we check if we can subtract one a, then 2 a\\'s, then 4 a\\'s, then 8 a\\'s, all the way until we cannot subtract anymore. \\n\\nI\\'ll also note that I\\'ve seen a lot of bit manipulation answers here as well. While that is cool, and very useful for lower level coding, if your goal is to understand algorithms I wouldn\\'t worry about these implementations. Just my two cents.\\n\\nStay coding!\\n\\n```\\nvar divide = function(dividend, divisor) {\\n    const retIsNegative = Math.sign(divisor) !== Math.sign(dividend);\\n    dividend = Math.abs(dividend)\\n    divisor = Math.abs(divisor)\\n    \\n    let ret = 0\\n    while (divisor <= dividend) {\\n        let value = divisor\\n        let multiple = 1\\n        while (value + value <= dividend) {\\n            value += value\\n            multiple += multiple\\n        }\\n        dividend = dividend - value\\n        ret += multiple\\n    }\\n    \\n    if (ret > ((2**31) - 1)) {\\n        return retIsNegative ? -(2**31) : 2**31 - 1\\n    }\\n    return retIsNegative ? -ret : ret\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar divide = function(dividend, divisor) {\\n    const retIsNegative = Math.sign(divisor) !== Math.sign(dividend);\\n    dividend = Math.abs(dividend)\\n    divisor = Math.abs(divisor)\\n    \\n    let ret = 0\\n    while (divisor <= dividend) {\\n        let value = divisor\\n        let multiple = 1\\n        while (value + value <= dividend) {\\n            value += value\\n            multiple += multiple\\n        }\\n        dividend = dividend - value\\n        ret += multiple\\n    }\\n    \\n    if (ret > ((2**31) - 1)) {\\n        return retIsNegative ? -(2**31) : 2**31 - 1\\n    }\\n    return retIsNegative ? -ret : ret\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13422,
                "title": "accepted-java-solution-with-comments",
                "content": "    public int divide(int dividend, int divisor) {\\n\\t\\tlong result = divideLong(dividend, divisor);\\n\\t\\treturn result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;\\n    }\\n\\t\\n\\t// It's easy to handle edge cases when\\n\\t// operate with long numbers rather than int\\n\\tpublic long divideLong(long dividend, long divisor) {\\n\\t\\t\\n\\t\\t// Remember the sign\\n\\t\\tboolean negative = dividend < 0 != divisor < 0;\\n\\t\\t\\n\\t\\t// Make dividend and divisor unsign\\n\\t\\tif (dividend < 0) dividend = -dividend;\\n\\t\\tif (divisor < 0) divisor = -divisor;\\n\\t\\t\\n\\t\\t// Return if nothing to divide\\n\\t\\tif (dividend < divisor) return 0;\\n\\t\\t\\n\\t\\t// Sum divisor 2, 4, 8, 16, 32 .... times\\n        long sum = divisor;\\n        long divide = 1;\\n        while ((sum+sum) <= dividend) {\\n        \\tsum += sum;\\n        \\tdivide += divide;\\n        }\\n        \\n        // Make a recursive call for (devided-sum) and add it to the result\\n        return negative ? -(divide + divideLong((dividend-sum), divisor)) :\\n        \\t(divide + divideLong((dividend-sum), divisor));\\n    }",
                "solutionTags": [],
                "code": "    public int divide(int dividend, int divisor) {\\n\\t\\tlong result = divideLong(dividend, divisor);\\n\\t\\treturn result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;\\n    }\\n\\t\\n\\t// It's easy to handle edge cases when\\n\\t// operate with long numbers rather than int\\n\\tpublic long divideLong(long dividend, long divisor) {\\n\\t\\t\\n\\t\\t// Remember the sign\\n\\t\\tboolean negative = dividend < 0 != divisor < 0;\\n\\t\\t\\n\\t\\t// Make dividend and divisor unsign\\n\\t\\tif (dividend < 0) dividend = -dividend;\\n\\t\\tif (divisor < 0) divisor = -divisor;\\n\\t\\t\\n\\t\\t// Return if nothing to divide\\n\\t\\tif (dividend < divisor) return 0;\\n\\t\\t\\n\\t\\t// Sum divisor 2, 4, 8, 16, 32 .... times\\n        long sum = divisor;\\n        long divide = 1;\\n        while ((sum+sum) <= dividend) {\\n        \\tsum += sum;\\n        \\tdivide += divide;\\n        }\\n        \\n        // Make a recursive call for (devided-sum) and add it to the result\\n        return negative ? -(divide + divideLong((dividend-sum), divisor)) :\\n        \\t(divide + divideLong((dividend-sum), divisor));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1085017,
                "title": "js-python-java-c-updated-logarithmic-bit-manipulation-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n*(Note: Some have questioned whether or not bitwise shifts should count as multiplication/division, so I\\'ve added an alternate solution explanation taking advantage of the algebraic qualities of logarithms below in the **Alaternate Idea** section.)*\\n\\nThe naive approach here would be to use a loop to just work down the difference between the dividend (**A**) and the divisor (**B**) through subtraction, but that\\'s obviously not a very efficient solution.\\n\\nInstead, we can use **bit manipulation** to simulate multiplication/division. Since a **bitwise shift** to the left is the equivalent of a multiplication by **2**, if we count how many times we can bitwise shift **B** to the left while still staying under **A**, then we can quickly work out a chunk of the solution. All that\\'s left is to start over with the remaining amount of **A** and repeat this process, adding the results to our answer (**ans**) as we go.\\n\\nOf course, negative numbers will play havoc with our bitwise shifting, so we should first extract the **sign** difference and then use only positive numbers for **A** and **B**.\\n\\nThere\\'s also the stated edge case, which only occurs at one permutation of **A** and **B**, so we can handle that at the outset.\\n\\n---\\n\\n#### ***Alternate Idea:***\\n\\nFor those who consider bitwise shifts to be too close to multiplication/division, we can instead use the rules of **logarithms** to our advantage:\\n```c++\\n  if:  exp(log(c) = c                   // Logarithmic rule #1\\n  if:  log(a / b) = log(a) - log(b)     // Logarithmic rule #2\\n\\nthen:  a / b = exp(log(a / b))          // From rule #1\\n       a / b = exp(log(a) - log(b))     // From rule #2\\n\\n       (if m and n are > 0)\\n```\\nSince we\\'ll have to use the absolute values of **A** and **B**, we\\'ll have to define the same edge cases as in the earlier solutions. Finally, we\\'ll also have to apply a **floor()** to the result to truncate the decimal before we **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript and Python both handle numbers larger than **32-bit** internally, and Java requires only a small change to the conditions on its loops to avoid an issue.\\n\\nC++, on the other hand, adheres strictly to the **32-bit** limit, so we have to define a few more edge cases to avoid exceeding these boundaries. That does allow us to simplify the code for both loops, however.\\n\\n---\\n\\n#### ***Javascript Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **84ms / 39.8MB** (beats 99% / 96%).\\n```javascript\\nvar divide = function(A, B) {\\n    if (A === -2147483648 && B === -1) return 2147483647\\n    let ans = 0, sign = 1\\n    if (A < 0) A = -A, sign = -sign\\n    if (B < 0) B = -B, sign = -sign\\n    if (A === B) return sign\\n    for (let i = 0, val = B; A >= B; i = 0, val = B) {\\n        while (val > 0 && val <= A) val = B << ++i\\n        A -= B << i - 1, ans += 1 << i - 1\\n    }\\n    return sign < 0 ? -ans : ans\\n};\\n```\\n\\n---\\n\\n#### ***Javascript Code w/ Logarithms:***\\n\\nThe best result for the code below is **84ms / 40.1MB** (beats 99% / 63%).\\n```javascript\\nvar divide = function(A, B) {\\n    let ans = 0\\n    if (B === -2147483648) return A === B\\n    if (A === -2147483648)\\n        if (B === 1) return -2147483648\\n        else if (B === -1) return 2147483647\\n        else A += Math.abs(B), ans++\\n    ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))))\\n    return A > 0 === B > 0 ? ans : -ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **20ms / 14.0MB** (beats 100% / 95%).\\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans, sign = 0, 1\\n        if A < 0: A, sign = -A, -sign\\n        if B < 0: B, sign = -B, -sign\\n        if A == B: return sign\\n        while A >= B:\\n            b = 0\\n            while B << b <= A: b += 1\\n            A -= B << b - 1\\n            ans += 1 << b - 1\\n        return -ans if sign < 0 else ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Logarithms:***\\n\\nThe best result for the code below is **28ms / 14.1MB** (beats 92% / 95%).\\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == 0: return 0\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans = math.floor(math.exp(math.log(abs(A)) - math.log(abs(B))))\\n        return ans if (A > 0) == (B > 0) else -ans\\n```\\n\\n---\\n\\n#### ***Java Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        if (A == -2147483648 && B == -1) return 2147483647;\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (A < 0) A = -A;\\n        if (B < 0) B = -B;\\n        if (A == B) return sign;\\n        for (int i = 0, val = B; A - B >= 0; i = 0, val = B) {\\n            while (val > 0 && A - val >= 0) val = B << ++i;\\n            A -= B << i - 1;\\n            ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***Java Code w/ Logarithms:***\\n\\nThe best result for the code below is **1ms / 35.9MB** (beats 100% / 84%).\\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B ? 1 : 0;\\n        if (A == -2147483648) {\\n            if (B == 1) return -2147483648;\\n            if (B == -1) return 2147483647;\\n            A += Math.abs(B);\\n            ans++;\\n        }\\n        ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        A = abs(A), B = abs(B);\\n        for (int i = 0; A >= B; i = 0) {\\n            while (A >> i >= B) i++;\\n            A -= B << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code w/ Logarithms:***\\n\\nThe best result for the code below is **0ms / 6.1MB** (beats 100% / 48%).\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        ans += floor(exp(log(abs(A)) - log(abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```c++\\n  if:  exp(log(c) = c                   // Logarithmic rule #1\\n  if:  log(a / b) = log(a) - log(b)     // Logarithmic rule #2\\n\\nthen:  a / b = exp(log(a / b))          // From rule #1\\n       a / b = exp(log(a) - log(b))     // From rule #2\\n\\n       (if m and n are > 0)\\n```\n```javascript\\nvar divide = function(A, B) {\\n    if (A === -2147483648 && B === -1) return 2147483647\\n    let ans = 0, sign = 1\\n    if (A < 0) A = -A, sign = -sign\\n    if (B < 0) B = -B, sign = -sign\\n    if (A === B) return sign\\n    for (let i = 0, val = B; A >= B; i = 0, val = B) {\\n        while (val > 0 && val <= A) val = B << ++i\\n        A -= B << i - 1, ans += 1 << i - 1\\n    }\\n    return sign < 0 ? -ans : ans\\n};\\n```\n```javascript\\nvar divide = function(A, B) {\\n    let ans = 0\\n    if (B === -2147483648) return A === B\\n    if (A === -2147483648)\\n        if (B === 1) return -2147483648\\n        else if (B === -1) return 2147483647\\n        else A += Math.abs(B), ans++\\n    ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))))\\n    return A > 0 === B > 0 ? ans : -ans\\n};\\n```\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans, sign = 0, 1\\n        if A < 0: A, sign = -A, -sign\\n        if B < 0: B, sign = -B, -sign\\n        if A == B: return sign\\n        while A >= B:\\n            b = 0\\n            while B << b <= A: b += 1\\n            A -= B << b - 1\\n            ans += 1 << b - 1\\n        return -ans if sign < 0 else ans\\n```\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == 0: return 0\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans = math.floor(math.exp(math.log(abs(A)) - math.log(abs(B))))\\n        return ans if (A > 0) == (B > 0) else -ans\\n```\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        if (A == -2147483648 && B == -1) return 2147483647;\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (A < 0) A = -A;\\n        if (B < 0) B = -B;\\n        if (A == B) return sign;\\n        for (int i = 0, val = B; A - B >= 0; i = 0, val = B) {\\n            while (val > 0 && A - val >= 0) val = B << ++i;\\n            A -= B << i - 1;\\n            ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B ? 1 : 0;\\n        if (A == -2147483648) {\\n            if (B == 1) return -2147483648;\\n            if (B == -1) return 2147483647;\\n            A += Math.abs(B);\\n            ans++;\\n        }\\n        ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        A = abs(A), B = abs(B);\\n        for (int i = 0; A >= B; i = 0) {\\n            while (A >> i >= B) i++;\\n            A -= B << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        ans += floor(exp(log(abs(A)) - log(abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084803,
                "title": "python-bitwise",
                "content": "We don\\'t need multiplication, division, or modulo operator, as long as we have addition, subtraction, and bitwise shift.\\n\\nSuppose that `x,y >0` (we handle negatives at the end) and `x = y*m + remainder` where we are interested in `m`. This multiple is a positive integer and can be expressed in binary form. Consider a simple case and say `m=16`. In terms of bit strings, `m = \\'0b10000\\'`. How do you multiply `y` by `m` here? Simply shift `y` by the number of shifts `1` has in `m`. So in python-speak this is `y<<4`. For the general case just do it iteratively.\\n\\n```python\\nclass Solution:\\n    def divide(self, x, y):\\n        ans = 0\\n        xx, yy = abs(x), abs(y)\\n        for i in range(32, -1, -1):\\n            if xx >= (yy<<i):\\n                xx -= (yy<<i)\\n                ans += (1<<i)\\n        \\n        if (x>0 and y<0) or (x<0 and y>0): \\n            ans = -ans\\n        \\n        return min(2**31-1, max(-2**31, ans))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def divide(self, x, y):\\n        ans = 0\\n        xx, yy = abs(x), abs(y)\\n        for i in range(32, -1, -1):\\n            if xx >= (yy<<i):\\n                xx -= (yy<<i)\\n                ans += (1<<i)\\n        \\n        if (x>0 and y<0) or (x<0 and y>0): \\n            ans = -ans\\n        \\n        return min(2**31-1, max(-2**31, ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13524,
                "title": "summary-of-3-c-solutions",
                "content": "-1-  log-based solution\\n \\n\\n       class Solution {\\n        public:\\n            int divide(int dividend, int divisor) {\\n                /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/\\n                if(dividend==0)  return 0;\\n                if(divisor==0)  return INT_MAX;\\n                \\n                double t1=log(fabs(dividend));\\n                double t2=log(fabs(divisor));\\n                long long result=double(exp(t1-t2));\\n                if((dividend<0) ^ (divisor<0))  result=-result;\\n                if(result>INT_MAX)  result=INT_MAX;\\n                return result;\\n            }\\n        };\\n\\n\\n-2-   Binary Index tree idea inspired solution, \\n\\nas we can decompose any result number to sum of the power \\n\\nof 2.\\n\\nHere is the C++ implementation.\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor || (dividend==INT_MIN && divisor==-1))   return INT_MAX;\\n            \\n            int sign=((dividend<0)^(divisor<0)) ? -1:1;\\n            long long m=labs(dividend);\\n            long long n=labs(divisor);\\n            int result=0;\\n            \\n            /** dvd >= 2^k1*dvs + 2^k2*dvs ... **/\\n            while(m>=n){\\n                long long temp=n, count=1;\\n                while(m >= (temp<<1)){\\n                    temp<<=1;\\n                    count<<=1;\\n                }\\n                m-=temp;\\n                result+=count;\\n            }\\n            \\n            return sign==1?result:-result;\\n        }\\n    };\\n\\n-3-  concise version of the solution 2\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            long long result=0;\\n            long long m=abs((long long)dividend);\\n            long long n=abs((long long)divisor);\\n            while(m>=n){\\n                long long s=n, power=1;\\n                while((s<<1) <= m) { s<<=1; power<<=1; }\\n                result+=power;\\n                m-=s;\\n            }\\n            \\n            if( (dividend>0) ^ (divisor>0))  result = -result;\\n            return result>INT_MAX ? INT_MAX:result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int divide(int dividend, int divisor) {\\n                /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/\\n                if(dividend==0)  return 0;\\n                if(divisor==0)  return INT_MAX;\\n                \\n                double t1=log(fabs(dividend));\\n                double t2=log(fabs(divisor));\\n                long long result=double(exp(t1-t2));\\n                if((dividend<0) ^ (divisor<0))  result=-result;\\n                if(result>INT_MAX)  result=INT_MAX;\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 251447,
                "title": "c-easy-to-understand-code-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    long long divide(long long dividend, long long divisor) {\\n        if (dividend < divisor)\\n            return 0;\\n        \\n        long long sum = divisor;\\n        long long multiple = 1; // 1 2 4 8 16 32 64...\\n        while ((sum + sum) <= dividend) {\\n            sum += sum;\\n            multiple += multiple;\\n        }\\n        \\n        return multiple + divide(dividend - sum, divisor);\\n    }\\n    \\n    int divide(int dividend, int divisor) {\\n        bool positive = (dividend >= 0 == divisor > 0);\\n        \\n        long long ldividend = abs((long long) dividend);\\n        long long ldivisor = abs((long long) divisor);\\n        long long lres = divide(ldividend, ldivisor);\\n        if (lres > INT_MAX) {\\n            lres = positive ? INT_MAX : INT_MIN; \\n        } else {\\n            lres = positive ? lres : -lres;\\n        }\\n        \\n        return lres;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long divide(long long dividend, long long divisor) {\\n        if (dividend < divisor)\\n            return 0;\\n        \\n        long long sum = divisor;\\n        long long multiple = 1; // 1 2 4 8 16 32 64...\\n        while ((sum + sum) <= dividend) {\\n            sum += sum;\\n            multiple += multiple;\\n        }\\n        \\n        return multiple + divide(dividend - sum, divisor);\\n    }\\n    \\n    int divide(int dividend, int divisor) {\\n        bool positive = (dividend >= 0 == divisor > 0);\\n        \\n        long long ldividend = abs((long long) dividend);\\n        long long ldivisor = abs((long long) divisor);\\n        long long lres = divide(ldividend, ldivisor);\\n        if (lres > INT_MAX) {\\n            lres = positive ? INT_MAX : INT_MIN; \\n        } else {\\n            lres = positive ? lres : -lres;\\n        }\\n        \\n        return lres;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179759,
                "title": "python-7-lines-beats-99-how-you-learned-to-divide-when-you-were-7-years-old",
                "content": "The core algorithm is simple. There are 2 phases:\\n1. Determine how far left to shift the divisor.\\n2. Divide like a 7-year-old (or 5, or 6, or 8, or 9, depending on where you\\'re from).\\n\\nTime: O(log(answer)) = O(log(dividend // divisor)) = O(log(dividend) - log(divisor))\\nSpace: O(1)\\n\\nAlgorithm for integer division of `p/q`, where `p` and `q` are positive:\\n```python\\ni, result = 0, 0 # Initialize stuff.\\n\\nwhile q << i <= p: i += 1 # Phase 1: Figure out how far left you should go.\\n\\nfor j in reversed(range(i)): # Phase 2: Divide like a 7-year-old.\\n    if q << j <= p:\\n        p -= q << j\\n        result += 1 << j\\n```\\n---\\n\\n### Explanation\\n\\nYou probably learned to do something like this in school:\\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n                         60         60         60  \\n                         ----       ----       ----\\n                          78         78         78 \\n                                     72         72 \\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\\nHere\\'s a clearer view of what\\'s happening behind the scenes:\\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n              0000       0000       0000       0000\\n              ----       ----       ----       ----\\n              6789       6789       6789       6789\\n                         6000       6000       6000\\n                         ----       ----       ----\\n                          789        789        789\\n                                     720        720\\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\\nBinary division is actually a lot easier, because at each step, `?` can only be 0 or 1. Example:\\n```\\n   00101\\n  +-----\\n11|10001\\n       0 == 0 * 110000 because 110000 >  10001\\n   -----\\n   10001\\n       0 == 0 * 11000  because  11000 >  10001\\n   -----\\n   10001\\n    1100 == 1 * 1100   because   1100 <= 10001\\n   -----\\n     101\\n       0 == 0 * 110    because    110 >  101\\n   -----\\n     101\\n      11 == 1 * 11     because     11 <= 101\\n   -----    ^\\n      10    |\\n            this column is the answer (00101)\\n```\\nThe algorithm should be pretty obvious now: First you try to subtract `110000`; it\\'s too big, so you try to subtract `11000`; it\\'s still too big, so you try to subtract `1100`; it works, so you subtract it and add `100` to the result; then you try to subtract `110`; it\\'s too big, so you try to subtract `11`; it works, so you subtract it and add `1` to the result. That\\'s it.\\n\\nOf course, in the example above, we know that the first two `0`s are unnecessary. That is what Phase 1 is for: Shift `q` as far left as possible without exceeding `p`.\\n\\nFull solution:\\n```python\\ndef divide(self, dividend, divisor):\\n\\n    # this is necessary; otherwise phase 1 never terminates\\n    if dividend == 0: return 0\\n\\n    # initialize\\n    i, result, p, q = map(abs, (0, 0, dividend, divisor))\\n    \\n    # phase 1\\n    while q << i <= p: i += 1\\n\\n    # phase 2\\n    for j in reversed(range(i)):\\n        if q << j <= p: p, result = p - (q << j), result + (1 << j)\\n\\n    # stupid leetcode restrictions\\n    if (dividend > 0) != (divisor > 0) or result < -1 << 31: result = -result\\n    return min(result, (1 << 31) - 1)\\n```",
                "solutionTags": [],
                "code": "```python\\ni, result = 0, 0 # Initialize stuff.\\n\\nwhile q << i <= p: i += 1 # Phase 1: Figure out how far left you should go.\\n\\nfor j in reversed(range(i)): # Phase 2: Divide like a 7-year-old.\\n    if q << j <= p:\\n        p -= q << j\\n        result += 1 << j\\n```\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n                         60         60         60  \\n                         ----       ----       ----\\n                          78         78         78 \\n                                     72         72 \\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n              0000       0000       0000       0000\\n              ----       ----       ----       ----\\n              6789       6789       6789       6789\\n                         6000       6000       6000\\n                         ----       ----       ----\\n                          789        789        789\\n                                     720        720\\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\n```\\n   00101\\n  +-----\\n11|10001\\n       0 == 0 * 110000 because 110000 >  10001\\n   -----\\n   10001\\n       0 == 0 * 11000  because  11000 >  10001\\n   -----\\n   10001\\n    1100 == 1 * 1100   because   1100 <= 10001\\n   -----\\n     101\\n       0 == 0 * 110    because    110 >  101\\n   -----\\n     101\\n      11 == 1 * 11     because     11 <= 101\\n   -----    ^\\n      10    |\\n            this column is the answer (00101)\\n```\n```python\\ndef divide(self, dividend, divisor):\\n\\n    # this is necessary; otherwise phase 1 never terminates\\n    if dividend == 0: return 0\\n\\n    # initialize\\n    i, result, p, q = map(abs, (0, 0, dividend, divisor))\\n    \\n    # phase 1\\n    while q << i <= p: i += 1\\n\\n    # phase 2\\n    for j in reversed(range(i)):\\n        if q << j <= p: p, result = p - (q << j), result + (1 << j)\\n\\n    # stupid leetcode restrictions\\n    if (dividend > 0) != (divisor > 0) or result < -1 << 31: result = -result\\n    return min(result, (1 << 31) - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13591,
                "title": "a-readable-java-implementation",
                "content": "At first, I used dividend / divisor, just to check. But that was cheating.\\n\\nThen, I implemented a solution which failed the corner cases. I solved it by using long instead of int. But I felt that was also cheating.\\n\\nAt last, I came up with this solution. It handles all the corner cases. Running time analysis after the code.\\n\\n    public class Solution {\\n        public int divide(int dividend, int divisor) {\\n            if (divisor == 1) // Trival case 1\\n                return dividend;\\n            \\n            // Use negative integers to avoid integer overflow\\n            if (dividend > 0)\\n                return -divide(-dividend, divisor);\\n            if (divisor > 0)\\n                return -divide(dividend, -divisor);\\n            \\n            if (dividend > divisor) // Trivial case 2\\n                return 0;\\n            \\n            if ((dividend == Integer.MIN_VALUE) && (divisor == -1)) // Overflow case\\n                return Integer.MAX_VALUE;\\n            \\n            // Find the highest mult = (divisor * 2^shifts) which is <= dividend\\n            // by shifting mult to the left without causing an overflow.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations.\\n            int min_divisor = Integer.MIN_VALUE >> 1;\\n            int mult = divisor; // = divisor * 2^shifts\\n            int shifts = 0;\\n            while ((mult >= min_divisor) && (mult > dividend)) {\\n                mult <<= 1;\\n                ++shifts;\\n            }\\n            \\n            // Compute the result by shifting mult to the right.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the outer loop.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the inner loop\\n            // (in total, not per outer iteration).\\n            int result = 0;\\n            int power = 1 << shifts; // = 2^shifts\\n            while (dividend <= divisor) {\\n                shifts = 0;\\n                while (mult < dividend) {\\n                    mult >>= 1;\\n                    ++shifts;\\n                }\\n                dividend -= mult;\\n                power >>= shifts;\\n                result |= power; // Adds power to result\\n            }\\n            \\n            return result;\\n        }\\n    }\\n\\nI see lots of people talking about O(log(n)) solutions. Since n is bounded by -2^31 and 2^31-1, I'm not sure the Big-Oh notation is appropriate here. Anyway, here's a rough worst-case analysis of this code.\\n\\nThe first loop runs (log2(|dividend|) - log2(|divisor|) + 1) times. There are\\n\\n - 2 comparisons\\n - 1 bit shift\\n - 1 increment\\n\\nThe second loop runs between 1 time and (log2(|dividend|) - log2(|divisor|) + 1) times. For worst-case, we take the latter. There are\\n\\n - 1 comparison\\n - 1 assignment\\n - 1 substraction\\n - 1 bit shift\\n - 1 bitwise or\\n\\nThe inner while loop runs (log2(|dividend|) - log2(|divisor|) + 1) times also (in total, not per outer loop iteration). There are\\n\\n - 1 comparison\\n - 1 bit shift\\n - 1 increment\\n\\nSo, roughly, the overall worst-case running time is 12(log2(dividend) - log2(divisor) + 1) operations. You can notice that (log2(|dividend|) - log2(|divisor|)) = log2(|result|). Thus, the running time is (worst-case) 12(log2(|result|) + 1) operations.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int divide(int dividend, int divisor) {\\n            if (divisor == 1) // Trival case 1\\n                return dividend;\\n            \\n            // Use negative integers to avoid integer overflow\\n            if (dividend > 0)\\n                return -divide(-dividend, divisor);\\n            if (divisor > 0)\\n                return -divide(dividend, -divisor);\\n            \\n            if (dividend > divisor) // Trivial case 2\\n                return 0;\\n            \\n            if ((dividend == Integer.MIN_VALUE) && (divisor == -1)) // Overflow case\\n                return Integer.MAX_VALUE;\\n            \\n            // Find the highest mult = (divisor * 2^shifts) which is <= dividend\\n            // by shifting mult to the left without causing an overflow.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations.\\n            int min_divisor = Integer.MIN_VALUE >> 1;\\n            int mult = divisor; // = divisor * 2^shifts\\n            int shifts = 0;\\n            while ((mult >= min_divisor) && (mult > dividend)) {\\n                mult <<= 1;\\n                ++shifts;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2139178,
                "title": "simple-eficient-100-faster",
                "content": "**<++++++++ Press upvote Button Please !!!!!!!**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n    \\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n     \\n        int res=0;\\n        while(dv<=dd) {\\n            long int sum=dv, count=1;\\n            while(sum<=dd-sum) {\\n                sum+=sum;\\n                count+=count;\\n            }\\n            res+=count;\\n            dd-=sum;\\n        }\\n        \\nif((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n          \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/da759167-b79f-448a-b13b-07fbbd8b216d_1654964334.5319335.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n    \\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n     \\n        int res=0;\\n        while(dv<=dd) {\\n            long int sum=dv, count=1;\\n            while(sum<=dd-sum) {\\n                sum+=sum;\\n                count+=count;\\n            }\\n            res+=count;\\n            dd-=sum;\\n        }\\n        \\nif((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179466,
                "title": "20ms-binary-search-java-with-explanations",
                "content": "We eastablish variables `sum` and `quotient` with the invariant `quotient * divisor = sum`.\\nTake dividend = 20, divisor = 3 for example,\\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n9     3        11\\n12    4        8\\n15    5        5\\n18    6        2\\n ^\\n 18 + 3 > 20, so the answer is 6\\n```\\nCode\\n```\\n    public int divide(int dividend, int divisor) {\\n        // Corner cases\\n        if (dividend == 0) return 0;\\n        if (divisor == 1) return dividend;\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        long ldividend = (long)dividend; // To avoid integer overflow in calculations after\\n        if (ldividend < 0) ldividend = -ldividend;\\n        long ldivisor = (long)divisor; // To avoid integer overflow in calculations after\\n        if (ldivisor < 0) ldivisor = -ldivisor;\\n        \\n        // sum = ldivisor * lquotient\\n        long lquotient = 1, sum = ldivisor; \\n        while (sum < ldividend) {\\n            lquotient++;  \\n            sum += ldivisor;  \\n        }\\n        \\n        if (sum > ldividend) lquotient--;\\n        boolean isPositive = (dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0);\\n        \\n        return isPositive ? (int)lquotient: -(int)lquotient;\\n    }\\n```\\n****\\nTo increase `quotient` one by one costs much time. We could apply **Binary Search** here, i.e. `quotient = quotient * 2` each time. \\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n12    4        8\\n ^\\n 12 + 12 > 20, so the answer is 4 --- X wrong for we missed quotient of 8 / 3\\nInstead, \\nsum  quotient  target\\n3     1        8\\n6     2        5\\n^\\n6 + 6 > 8, so the answer for 8 / 3 is 2\\n\\nThe final answer is 4 + 2 = 6\\n```\\nWe remove negative sign of dividend and divisor in the beginning and add `signNegative` to make up the difference.\\nIn case of Integer Overflows, we use long to while addition. And we need to make sure the final result is within the range `[\\u22122^31,  2^31 \\u2212 1]`.\\n\\n**Code**\\n```\\n    public int divide(int dividend, int divisor) {\\n\\n        long ldividend = (long) dividend, ldivisor = (long) divisor;\\n\\n        boolean signNegative = false;\\n        if (ldividend < 0) {\\n            signNegative = !signNegative;\\n            ldividend = -ldividend;\\n        }\\n        if (ldivisor < 0) {\\n            signNegative = !signNegative;\\n            ldivisor = -ldivisor;\\n        }\\n\\n        long result = divideRecur(ldividend, ldivisor);\\n\\n        if (result > Integer.MAX_VALUE && !signNegative) {\\n            result = Integer.MAX_VALUE;\\n        } else if (result < Integer.MIN_VALUE) {\\n            result = Integer.MIN_VALUE;\\n        }\\n\\n        return signNegative ? (int) -result : (int) result;\\n    }\\n\\n    private long divideRecur(long dividend, long divisor) {\\n\\n        if (dividend < divisor)\\n            return 0;\\n\\n        long sum = divisor, quotient = 1;\\n        while (sum + sum < dividend) {\\n            sum += sum;\\n            quotient += quotient;\\n        }\\n\\n        return quotient + divideRecur(dividend - sum, divisor);\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n9     3        11\\n12    4        8\\n15    5        5\\n18    6        2\\n ^\\n 18 + 3 > 20, so the answer is 6\\n```\n```\\n    public int divide(int dividend, int divisor) {\\n        // Corner cases\\n        if (dividend == 0) return 0;\\n        if (divisor == 1) return dividend;\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        long ldividend = (long)dividend; // To avoid integer overflow in calculations after\\n        if (ldividend < 0) ldividend = -ldividend;\\n        long ldivisor = (long)divisor; // To avoid integer overflow in calculations after\\n        if (ldivisor < 0) ldivisor = -ldivisor;\\n        \\n        // sum = ldivisor * lquotient\\n        long lquotient = 1, sum = ldivisor; \\n        while (sum < ldividend) {\\n            lquotient++;  \\n            sum += ldivisor;  \\n        }\\n        \\n        if (sum > ldividend) lquotient--;\\n        boolean isPositive = (dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0);\\n        \\n        return isPositive ? (int)lquotient: -(int)lquotient;\\n    }\\n```\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n12    4        8\\n ^\\n 12 + 12 > 20, so the answer is 4 --- X wrong for we missed quotient of 8 / 3\\nInstead, \\nsum  quotient  target\\n3     1        8\\n6     2        5\\n^\\n6 + 6 > 8, so the answer for 8 / 3 is 2\\n\\nThe final answer is 4 + 2 = 6\\n```\n```\\n    public int divide(int dividend, int divisor) {\\n\\n        long ldividend = (long) dividend, ldivisor = (long) divisor;\\n\\n        boolean signNegative = false;\\n        if (ldividend < 0) {\\n            signNegative = !signNegative;\\n            ldividend = -ldividend;\\n        }\\n        if (ldivisor < 0) {\\n            signNegative = !signNegative;\\n            ldivisor = -ldivisor;\\n        }\\n\\n        long result = divideRecur(ldividend, ldivisor);\\n\\n        if (result > Integer.MAX_VALUE && !signNegative) {\\n            result = Integer.MAX_VALUE;\\n        } else if (result < Integer.MIN_VALUE) {\\n            result = Integer.MIN_VALUE;\\n        }\\n\\n        return signNegative ? (int) -result : (int) result;\\n    }\\n\\n    private long divideRecur(long dividend, long divisor) {\\n\\n        if (dividend < divisor)\\n            return 0;\\n\\n        long sum = divisor, quotient = 1;\\n        while (sum + sum < dividend) {\\n            sum += sum;\\n            quotient += quotient;\\n        }\\n\\n        return quotient + divideRecur(dividend - sum, divisor);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246094,
                "title": "java-solutions",
                "content": "**Solution 1: Brute-Force Algorithm**\\n\\n- A **brute-force** approach is to iteratively subtract `y` from `x` until what remains is less than `y`. The number of such subtractions is exactly the quotient, `x / y`, and the remainder is the term that\\'s less than `y` the complexity of brute-force approach is very high.\\nFor Example- when x = 2<sup>31</sup> - 1 and `y = 1`, then it will take 2<sup>31</sup> - 1 iterations.\\n\\nTime complexity: `O(x) ` - where `x` is the `dividend`.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            x -= y;\\n            result++;\\n        }\\n        return result * sign;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n- A **better approach** is to try and get more work done in each iteration. The idea is to compute the largest `k` such that 2<sup>k</sup>y <= x, then subtract 2<sup>k</sup>y from `x` and 2<sup>k</sup> to the `quotient`.\\nFor Example- if x = (1011)<sub>2</sub> and y = (10)<sub>2</sub>, then `k = 2`, since 2 * 2<sup>2</sup> <= 11 and 2 * 2<sup>3</sup> > 11. We subtract (1000)<sub>2</sub> from (1011)<sub>2</sub> to get (11)<sub>2</sub>, add 2<sup>k</sup> = 2<sup>2</sup> = (100)<sub>2</sub> to the `quotient`, and continue by updating `x` to (11)<sub>2</sub>.\\n- The advantage of using 2<sup>k</sup>y is that it can be computed very efficiently using shifting, and `x` is halved in each iteration. If it takes `n` bits to represent `x / y`, there are `O(n)` iterations. If the largest `k` such that 2<sup>k</sup>y <= x is computed by iterating through `k`, and since each iteration has time complexity `O(n)`, this leads to O(n<sup>2</sup>) algorithm.\\n\\nTime complexity: O(n<sup>2</sup>) - where `n` is the number of bits required to represent `x / y`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            int shift = 1;\\n\\n            while(x >= (y << shift))\\n\\t\\t\\t{\\n                shift++;\\n            }\\n            x -= y << (shift - 1);\\n            result += 1 << (shift - 1);\\n        }\\n        return result * sign;\\n    }\\n}\\n```\\n\\n**Solution 3:**\\n\\n- The **best way** to find the largest `k` in each iteration is to recongnize that it keeps decreasing. Therefore, instead of testing in each iteration whether 2<sup>0</sup>y, 2<sup>1</sup>y, 2<sup>2</sup>y . . . is less than or equal to `x`, after we initially find the largest `k` such that 2<sup>k</sup>y <= x, in susequent iterations we test 2<sup>k-1</sup>y, 2<sup>k-2</sup>y, 2<sup>k-3</sup>y, . . . with `x`.\\n- For the example given earliar, after setting the `quotient`, to (100)<sub>2</sub> we continue with (11)<sub>2</sub>. Now the largest `k` such that 2<sup>k</sup>y <= (11)<sub>2</sub> is `0`, so we add 2<sup>0</sup> = (1)<sub>2</sub> to the `quotient`, which is now (101)<sub>2</sub>. We continue with (11)<sub>2</sub> - (10)<sub>2</sub> = (1)<sub>2</sub>. Since (1)<sub>2</sub> < y, we are done. So the `quotient` is (101)<sub>2</sub> and the `remainder` is (1)<sub>2</sub>.\\n\\nTime complexity: `O(n)` - where `n` is the number of bits required to represent `x / y`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n        int power = 32;\\n        long x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n       while(x >= y)\\n\\t\\t{\\n            while((y << power) > x)\\n\\t\\t\\t{\\n                power--;\\n            }\\n            x -= y << power;\\n            result += 1 << power;\\n        }\\n        return result * sign;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            x -= y;\\n            result++;\\n        }\\n        return result * sign;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            int shift = 1;\\n\\n            while(x >= (y << shift))\\n\\t\\t\\t{\\n                shift++;\\n            }\\n            x -= y << (shift - 1);\\n            result += 1 << (shift - 1);\\n        }\\n        return result * sign;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n        int power = 32;\\n        long x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n       while(x >= y)\\n\\t\\t{\\n            while((y << power) > x)\\n\\t\\t\\t{\\n                power--;\\n            }\\n            x -= y << power;\\n            result += 1 << power;\\n        }\\n        return result * sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13516,
                "title": "javascript-solution-with-o-logn-time-and-o-logn-stack-space",
                "content": "    function divide(dividend, divisor) {\\n        if (dividend === -2147483648 && divisor === -1) {\\n            return 2147483647;\\n        }\\n        var isNeg = dividend > 0 ^ divisor > 0;\\n        var res = 0;\\n        \\n        dividend = Math.abs(dividend);\\n        subtract(Math.abs(divisor), 1);\\n        \\n        function subtract(d, q) {\\n            if (dividend > d) {\\n                subtract(d + d, q + q);\\n            }\\n            if (dividend >= d) {\\n                dividend -= d;\\n                res += q;\\n            }\\n        }\\n        \\n        return isNeg ? -res : res;\\n    }",
                "solutionTags": [],
                "code": "    function divide(dividend, divisor) {\\n        if (dividend === -2147483648 && divisor === -1) {\\n            return 2147483647;\\n        }\\n        var isNeg = dividend > 0 ^ divisor > 0;\\n        var res = 0;\\n        \\n        dividend = Math.abs(dividend);\\n        subtract(Math.abs(divisor), 1);\\n        \\n        function subtract(d, q) {\\n            if (dividend > d) {\\n                subtract(d + d, q + q);\\n            }\\n            if (dividend >= d) {\\n                dividend -= d;\\n                res += q;\\n            }\\n        }\\n        \\n        return isNeg ? -res : res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3222214,
                "title": "efficient-bit-manipulation-algorithm-for-integer-division-without-multiplication-or-mod-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to divide two integers, `dividend` and `divisor`, and return the quotient without using multiplication, division, and mod operator.\\n\\nWe can solve this problem using bit manipulation and binary search. We can find the largest multiple of the divisor that is less than or equal to the dividend using bit manipulation. Then we can perform division using binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Handle division by zero: If the divisor is 0, return `2**31 - 1`.\\n\\n- Handle overflow case: If the dividend is `-2**31` and divisor is `-1`, return `2**31 - 1`.\\n\\n- Get the sign of the result: If both dividend and divisor are negative or positive, the sign of the result will be positive. If either dividend or divisor is negative, the sign of the result will be negative.\\n\\n- Find the largest multiple of the divisor that is less than or equal to the dividend using bit manipulation. We can do this by left-shifting the divisor and multiple by 1 until the left-shifted divisor is greater than the dividend.\\n\\n- Perform division using binary search. We can do this by right-shifting the divisor and multiple by 1 until multiple is 0. If the dividend is greater than or equal to the divisor, subtract the divisor from the dividend and add the multiple to the quotient. Repeat until multiple is 0.\\n\\n- Apply the sign to the quotient and return it.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is $$O(log(dividend))$$.\\n\\nFinding the largest multiple of the divisor that is less than or equal to the dividend takes `log(dividend)` iterations. Performing division using binary search takes `log(dividend) `iterations as well.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this solution is `O(1)`.\\n\\nWe only use a constant amount of extra space to store variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Explanation\\n\\nThe code is an implementation of the binary division algorithm. The algorithm is used to divide two integers (dividend and divisor) and return the quotient (integer division result). Here is how the code works:\\n\\n- The function accepts two integer parameters, dividend and divisor, and returns an integer (quotient).\\n- The function first checks if the divisor is zero. If it is, it returns the maximum 32-bit integer value (2^31 - 1). This is because dividing by zero is not possible, and we need to handle this edge case.\\n- The function then checks for an overflow case where the dividend is the minimum 32-bit integer value (-2^31) and the divisor is -1. In this case, the quotient is the maximum 32-bit integer value (2^31 - 1) since dividing the minimum value by -1 would result in an overflow error.\\n- The function determines the sign of the result by checking the signs of the dividend and divisor. If both are negative or both are positive, the sign is positive. Otherwise, the sign is negative, and we make both values positive for the next step.\\n- The function then finds the largest multiple of the divisor that is less than or equal to the dividend. It does this by left-shifting the divisor and multiple variables (initially set to 1) until the shifted divisor is greater than the dividend. At this point, the last multiple that was less than or equal to the dividend is the largest multiple we need to find. The function keeps track of this multiple value and the divisor value for the next step.\\n- The function then performs the division using binary search. It does this by right-shifting the divisor and multiple variables until multiple is zero. At each step, it checks if the dividend is greater than or equal to the divisor. If it is, it subtracts the divisor from the dividend, adds the multiple to the quotient, and continues the loop. Otherwise, it right-shifts the divisor and multiple variables to check for the next value. At the end of this step, the quotient variable contains the integer division result.\\n- Finally, the function applies the sign to the result and returns it.\\n\\n\\nOverall, the binary division algorithm is an efficient way to perform integer division using bit manipulation. The code handles edge cases such as division by zero and overflow and returns the correct result with the correct sign.\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # Handle division by zero\\n        if divisor == 0:\\n            return 2**31 - 1\\n        \\n        # Handle overflow case\\n        if dividend == -2**31 and divisor == -1:\\n            return 2**31 - 1\\n        \\n        # Get the sign of the result\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        \\n        # Find the largest multiple of the divisor that is less than or equal to the dividend\\n        multiple = 1\\n        while dividend >= (divisor << 1):\\n            divisor <<= 1\\n            multiple <<= 1\\n        \\n        # Perform division using binary search\\n        quotient = 0\\n        while multiple > 0:\\n            if dividend >= divisor:\\n                dividend -= divisor\\n                quotient += multiple\\n            divisor >>= 1\\n            multiple >>= 1\\n        \\n        # Apply the sign to the result\\n        return sign * quotient\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # Handle division by zero\\n        if divisor == 0:\\n            return 2**31 - 1\\n        \\n        # Handle overflow case\\n        if dividend == -2**31 and divisor == -1:\\n            return 2**31 - 1\\n        \\n        # Get the sign of the result\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        \\n        # Find the largest multiple of the divisor that is less than or equal to the dividend\\n        multiple = 1\\n        while dividend >= (divisor << 1):\\n            divisor <<= 1\\n            multiple <<= 1\\n        \\n        # Perform division using binary search\\n        quotient = 0\\n        while multiple > 0:\\n            if dividend >= divisor:\\n                dividend -= divisor\\n                quotient += multiple\\n            divisor >>= 1\\n            multiple >>= 1\\n        \\n        # Apply the sign to the result\\n        return sign * quotient\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086538,
                "title": "c-bit-manipulation-o-logn-2-0ms-beats-100-explanation",
                "content": "**EXPLANATION**\\n- First, find the **highest number (less than dividend)** that can be **substracted** from the `dividend` which is a **multiple of divisor**, then subtract it from the `dividend` and add that multiplier to the answer (`ans`).\\n- **Repeat** the process as long as `dividend >= divisor`.\\n- The algorithm is implemented on positive `dividend` and positive `divisor`, so we add the **sign** at the *end*.\\n- Also, handle few **special cases** before starting the algorithm (shown in the code below).\\n\\n**Note**: Instead of directly finding the \"highest number (less than dividend) that can be subtracted from the dividend which is a multiple of divisor\", we will be finding the lowest multiple of dividend that is greater than the divisor. This is because of handling the case of **integer overflow**.\\n\\n---\\n\\n**EXAMPLE**\\nConsider the **input** as `dividend = 10` and `divisor = 3`,\\n**(1)** Now, first we find the **lowest number** (formed by dividing the `dividend` by 2) that is **greater** than the `divisor` in a loop. Initially `curr_dvd = dividend = 10` and multiplier(`t`) is `1`. The loop will continue only if `curr_dvd >= divisor`. Here, we are trying to find the multiplier by right shifting the `dividend`  by 2 (dividing by 2) in each iteration, this makes the *worst-case time complexity* of finding it `O(logn)`.\\n- **First Iteration** : 10/2 = 5, Since `5>=3(divisor)`, so `curr_dvd=5`, so our multiplier(`t`) becomes `t = t*2 = 2`.\\n- **Second Iteration** : 5/2 = 2, Since `2<3(divisor)`, so after this we will stop.\\n\\nNow, subtract `divisor * multiplier` from `dividend`, that is 10 - 3`*`**2** = 4.\\nAfter that add the multiplier to answer that is `ans+=2`\\n\\n**(2)** From the output of the previous step, since `4>=3(divisor)` repeat **(1)** on 4,\\n- **First Iteration** : 4/2 = 2, Since `2<3(divisor)`, so we will stop.\\n\\nAgain, do the same thing as **(1)**, 4 - 3`*`**1** = 1, so `ans+=1`. (As by default our *multiplier* is `1`)\\n\\n**(3)** From the output of the previous step, `1<3(divisor)`, so we will not repeat **(1)**.\\n\\nHence, the final answer is **`ans = 2 (from 1) + 1 (from 2) = 3`**.\\n\\n***Note**: The code is more optimized than explained in the above example. But, the working is the same.*\\n\\n---\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { // dividend / divisor\\n        \\n        int ans = 0;\\n\\n        // Handle special cases\\n        if (divisor == INT_MIN)\\n            if (dividend == divisor) return 1;\\n            else return 0;\\n        \\n        if (dividend == INT_MIN)\\n            if (divisor == 1) return INT_MIN;\\n            else if (divisor == -1) return INT_MAX;\\n            else dividend += abs(divisor), ans++; // INT_MIN + abs(divisor) / abs(divisor) = 1 + INT_MIN / abs(divisor)\\n\\n        // find the sign of the answer\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        \\n        // making both dividend and divisor positive\\n        dividend = abs(dividend), divisor = abs(divisor);\\n        \\n        // main code\\n        while(dividend >= divisor) { \\n            int t=1; // multiplier by default 1 since (dividend >= divisor)\\n            int curr_dvs=divisor;\\n            int curr_dvd=dividend >> 1;\\n            \\n            while (curr_dvd >= divisor){\\n                curr_dvs = curr_dvs << 1;\\n                t = t << 1;\\n                curr_dvd = curr_dvd>>1;\\n            }\\n\\n            dividend -= curr_dvs;\\n            ans += t;\\n        }\\n        return sign > 0 ? ans : -ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(logn * logn)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { // dividend / divisor\\n        \\n        int ans = 0;\\n\\n        // Handle special cases\\n        if (divisor == INT_MIN)\\n            if (dividend == divisor) return 1;\\n            else return 0;\\n        \\n        if (dividend == INT_MIN)\\n            if (divisor == 1) return INT_MIN;\\n            else if (divisor == -1) return INT_MAX;\\n            else dividend += abs(divisor), ans++; // INT_MIN + abs(divisor) / abs(divisor) = 1 + INT_MIN / abs(divisor)\\n\\n        // find the sign of the answer\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        \\n        // making both dividend and divisor positive\\n        dividend = abs(dividend), divisor = abs(divisor);\\n        \\n        // main code\\n        while(dividend >= divisor) { \\n            int t=1; // multiplier by default 1 since (dividend >= divisor)\\n            int curr_dvs=divisor;\\n            int curr_dvd=dividend >> 1;\\n            \\n            while (curr_dvd >= divisor){\\n                curr_dvs = curr_dvs << 1;\\n                t = t << 1;\\n                curr_dvd = curr_dvd>>1;\\n            }\\n\\n            dividend -= curr_dvs;\\n            ans += t;\\n        }\\n        return sign > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367837,
                "title": "building-up-solution-in-python-with-easy-explaination",
                "content": "How do we do division if we couldn\\'t use multiplication or division? \\nThe easiest way: we just substract or diviser from the dividend until there is nothing to substract.\\n# Easy but slow\\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tdividend -= divisor\\n\\tres += 1\\nreturn -res if sign else res\\n```\\n\\nOnly problem with that.. It\\'s too slow. \\n# Fast solution\\nWe want to speed up the process by substracting not the divisor, but divisor multiplied by something. \\nBut we couldn\\'t multiply directly due to the task conditions.\\nHow do we do than ? \\nWe use the fact that **bitwise left shift is equal to multiplying by two**:\\n101 << 1 = 1010 \\nSo we shift the divisor left as much as we can before substracting: \\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nreturn -res if sign else res\\n```\\n# The final solution\\nThe last thing we need to do is to account for the max number: \\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nMAX_INT =  (1 << 31) - 1\\nreturn -res if sign else (res if res <= MAX_INT else MAX_INT)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tdividend -= divisor\\n\\tres += 1\\nreturn -res if sign else res\\n```\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nreturn -res if sign else res\\n```\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nMAX_INT =  (1 << 31) - 1\\nreturn -res if sign else (res if res <= MAX_INT else MAX_INT)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13653,
                "title": "compiler-does-not-actually-check-for-division-operator",
                "content": "    return dividend / divisor;\\n\\nwas accepted.",
                "solutionTags": [],
                "code": "    return dividend / divisor;\\n\\nwas accepted.",
                "codeTag": "Unknown"
            },
            {
                "id": 1601170,
                "title": "java-1ms-single-recursive-function",
                "content": "This solution is based on the following two posts.\\nhttps://leetcode.com/problems/divide-two-integers/discuss/1579861/Java-no-longs-simple-solution-that-someone-could-actually-come-up-with\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13417/No-Use-of-Long-Java-Solution\\nI thought both of these were very nice but they used two different functions so I turned it into a single recursive function mainly for aesthetic purposes. \\nThe second link has bit manipulation if you\\'re freaky like that.\\nI much prefered the easier to understand and arguably prettier solution in the first link.\\n```\\npublic class Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t//all of these if else statements are only for edge cases and to make both dividend and divisor negative\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        if (divisor == 1)\\n            return dividend;\\n        if (dividend > 0 && divisor > 0)\\n            return divide(-dividend, -divisor);\\n        else if (dividend > 0)\\n            return -divide(-dividend, divisor);\\n        else if (divisor > 0)\\n            return -divide(dividend, -divisor);\\n        if (divisor < dividend || dividend == 0)\\n            return 0;\\n        int sum = divisor;\\n        int mult = 1;\\n        while ((sum + sum) < sum && (sum + sum) >= dividend) {\\n            sum += sum;\\n            mult += mult;\\n        }\\n        return mult + divide(dividend - sum, divisor);\\n    }\\n}\\n```\\nI hope this helps someone who wanted a neat answer in java.\\nthe while loop is used to basically create multiples of the divisor with the powers of 2 (eg 2 x divisor,4 x divisor,8 x divisor, ...) which makes the time complexity O(log n) vs the O(n) time complexity with the repeated subtraction method. (n being the quotient)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t//all of these if else statements are only for edge cases and to make both dividend and divisor negative\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        if (divisor == 1)\\n            return dividend;\\n        if (dividend > 0 && divisor > 0)\\n            return divide(-dividend, -divisor);\\n        else if (dividend > 0)\\n            return -divide(-dividend, divisor);\\n        else if (divisor > 0)\\n            return -divide(dividend, -divisor);\\n        if (divisor < dividend || dividend == 0)\\n            return 0;\\n        int sum = divisor;\\n        int mult = 1;\\n        while ((sum + sum) < sum && (sum + sum) >= dividend) {\\n            sum += sum;\\n            mult += mult;\\n        }\\n        return mult + divide(dividend - sum, divisor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837822,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1\\n        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        ans = 0      \\n        \\n        for power in range(31, -1, -1) :\\n            if (divisor << power) <= dividend:\\n                ans += (1 << power)\\n                dividend -= (divisor << power)\\n           \\n        ans = ans * sign\\n        \\n        if not (-2**31 <= ans <= 2**31-1):\\n            return 2**31 - 1\\n        else:\\n            return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1\\n        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        ans = 0      \\n        \\n        for power in range(31, -1, -1) :\\n            if (divisor << power) <= dividend:\\n                ans += (1 << power)\\n                dividend -= (divisor << power)\\n           \\n        ans = ans * sign\\n        \\n        if not (-2**31 <= ans <= 2**31-1):\\n            return 2**31 - 1\\n        else:\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204883,
                "title": "56ms-python-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        dividend1, divisor1 = abs(dividend), abs(divisor)\\n        quotient = 0\\n        while dividend1 >= divisor1:\\n            temp, i = divisor1, 1\\n            while dividend1 >= temp:\\n                dividend1 -= temp\\n                temp += temp\\n                quotient += i\\n                i += i\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            quotient = -quotient\\n        return min(max(quotient, -pow(2,31)),pow(2,31)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        dividend1, divisor1 = abs(dividend), abs(divisor)\\n        quotient = 0\\n        while dividend1 >= divisor1:\\n            temp, i = divisor1, 1\\n            while dividend1 >= temp:\\n                dividend1 -= temp\\n                temp += temp\\n                quotient += i\\n                i += i\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            quotient = -quotient\\n        return min(max(quotient, -pow(2,31)),pow(2,31)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13436,
                "title": "java-3ms-using-bit-operation-and-recursion",
                "content": "    public int divide(int a, int b) {\\n    \\t\\tif (b == 0)\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t\\t//\\u7531\\u4e8eInteger.MINVALUE\\u7684\\u7279\\u6b8a\\u6027(\\u5176\\u8865\\u7801\\u662f\\u5b83\\u672c\\u8eab)\\uff0c\\u4e0d\\u5f97\\u4e0d\\u5c06int\\u578b\\u8f6c\\u4e3along\\u578b\\n    \\t\\tlong dividend = (long)a;\\n    \\t\\tlong divisor = (long)b;\\n    \\t\\t//\\u7b26\\u53f7\\u4f4d\\u505a\\u548c\\uff0c-1\\u8868\\u793a\\u7ed3\\u679c\\u4e3a\\u8d1f\\uff0c\\u5426\\u5219\\u7ed3\\u679c\\u4e3a\\u6b63\\u6570\\n    \\t\\tlong sign = (dividend >> 31) + (divisor >> 31);\\n    \\t\\tdividend = (dividend >> 31) == 0 ? dividend : (~dividend + 1);\\n    \\t\\tdivisor = (divisor >> 31) == 0 ? divisor : (~divisor + 1);\\n    \\t\\t//\\u521d\\u59cb\\u5224\\u65ad\\uff0c\\u88ab\\u9664\\u6570\\u5c0f\\uff0c\\u76f4\\u63a5\\u8fd4\\u56de0\\n    \\t\\tif(divisor > dividend)\\n    \\t\\t\\treturn 0;\\n    \\t\\t//\\u5f00\\u59cb\\u9012\\u5f52\\n    \\t\\tlong quotient = recurse(dividend, divisor, divisor, 1);\\n    \\t\\t//\\u7ed9\\u5546\\u52a0\\u4e0a\\u7b26\\u53f7\\n    \\t\\tquotient = (sign == -1) ? (~quotient + 1) : quotient;\\n    \\t\\t//\\u5224\\u65ad\\u662f\\u5426\\u6ea2\\u51fa\\uff0c\\u5982a=Integer.MINVALUE,b=-1\\u7ed3\\u679c\\u662f\\u6ea2\\u51fa\\u7684\\n    \\t\\tif(quotient >= Integer.MIN_VALUE && quotient <= Integer.MAX_VALUE)\\n    \\t\\t\\treturn (int)quotient;\\n    \\t\\telse\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t}\\n    \\t/*\\n    \\t * \\u5927\\u81f4\\u601d\\u8def\\uff1a\\n    \\t * \\u9664\\u6570\\u4f9d\\u6b21\\u5de6\\u79fb\\u4e00\\u4f4d(\\u4e582)\\uff0c\\u76f4\\u81f3\\u5927\\u4e8e\\u88ab\\u9664\\u6570\\n    \\t * \\u56de\\u9000\\uff0c\\u5224\\u65ad\\uff0c\\u82e5\\u5dee\\u5c0f\\u4e8e\\u521d\\u59cb\\u9664\\u6570\\uff0c\\u7ed3\\u675f\\uff0c\\u5426\\u5219\\u88ab\\u9664\\u6570\\u7f6e\\u4e3a\\u4e24\\u8005\\u4e4b\\u5dee\\uff0c\\u9664\\u6570\\u4e3a\\u521d\\u59cb\\u6570\\uff1b\\n    \\t * \\u4f8b\\u5982\\uff0c(7,2,2,1)->(7,4,2,2)->(7,8,2,4)->(3>2)->(3,2,2,1)+2->(3,4,2,1)+2->(1<2)->return 1+2=3;\\n    \\t */\\n    \\tpublic long recurse(long dividend, long divisor, long init, long quotient){\\n    \\t\\tif(dividend > divisor){\\n    \\t\\t\\treturn recurse(dividend, divisor << 1, init, quotient << 1);\\n    \\t\\t} else if(dividend == divisor){\\n    \\t\\t\\treturn quotient;\\n    \\t\\t} else{\\n    \\t\\t\\tif(dividend-(divisor >> 1) < init)\\n    \\t\\t\\t\\treturn quotient>>1;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn recurse(dividend - (divisor >> 1), init, init, 1) + (quotient >> 1);\\n    \\t\\t}\\n    \\t}",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    public int divide(int a, int b) {\\n    \\t\\tif (b == 0)\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t\\t//\\u7531\\u4e8eInteger.MINVALUE\\u7684\\u7279\\u6b8a\\u6027(\\u5176\\u8865\\u7801\\u662f\\u5b83\\u672c\\u8eab)\\uff0c\\u4e0d\\u5f97\\u4e0d\\u5c06int\\u578b\\u8f6c\\u4e3along\\u578b\\n    \\t\\tlong dividend = (long)a;\\n    \\t\\tlong divisor = (long)b;\\n    \\t\\t//\\u7b26\\u53f7\\u4f4d\\u505a\\u548c\\uff0c-1\\u8868\\u793a\\u7ed3\\u679c\\u4e3a\\u8d1f\\uff0c\\u5426\\u5219\\u7ed3\\u679c\\u4e3a\\u6b63\\u6570\\n    \\t\\tlong sign = (dividend >> 31) + (divisor >> 31);\\n    \\t\\tdividend = (dividend >> 31) == 0 ? dividend : (~dividend + 1);\\n    \\t\\tdivisor = (divisor >> 31) == 0 ? divisor : (~divisor + 1);\\n    \\t\\t//\\u521d\\u59cb\\u5224\\u65ad\\uff0c\\u88ab\\u9664\\u6570\\u5c0f\\uff0c\\u76f4\\u63a5\\u8fd4\\u56de0\\n    \\t\\tif(divisor > dividend)\\n    \\t\\t\\treturn 0;\\n    \\t\\t//\\u5f00\\u59cb\\u9012\\u5f52\\n    \\t\\tlong quotient = recurse(dividend, divisor, divisor, 1);\\n    \\t\\t//\\u7ed9\\u5546\\u52a0\\u4e0a\\u7b26\\u53f7\\n    \\t\\tquotient = (sign == -1) ? (~quotient + 1) : quotient;\\n    \\t\\t//\\u5224\\u65ad\\u662f\\u5426\\u6ea2\\u51fa\\uff0c\\u5982a=Integer.MINVALUE,b=-1\\u7ed3\\u679c\\u662f\\u6ea2\\u51fa\\u7684\\n    \\t\\tif(quotient >= Integer.MIN_VALUE && quotient <= Integer.MAX_VALUE)\\n    \\t\\t\\treturn (int)quotient;\\n    \\t\\telse\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t}\\n    \\t/*\\n    \\t * \\u5927\\u81f4\\u601d\\u8def\\uff1a\\n    \\t * \\u9664\\u6570\\u4f9d\\u6b21\\u5de6\\u79fb\\u4e00\\u4f4d(\\u4e582)\\uff0c\\u76f4\\u81f3\\u5927\\u4e8e\\u88ab\\u9664\\u6570\\n    \\t * \\u56de\\u9000\\uff0c\\u5224\\u65ad\\uff0c\\u82e5\\u5dee\\u5c0f\\u4e8e\\u521d\\u59cb\\u9664\\u6570\\uff0c\\u7ed3\\u675f\\uff0c\\u5426\\u5219\\u88ab\\u9664\\u6570\\u7f6e\\u4e3a\\u4e24\\u8005\\u4e4b\\u5dee\\uff0c\\u9664\\u6570\\u4e3a\\u521d\\u59cb\\u6570\\uff1b\\n    \\t * \\u4f8b\\u5982\\uff0c(7,2,2,1)->(7,4,2,2)->(7,8,2,4)->(3>2)->(3,2,2,1)+2->(3,4,2,1)+2->(1<2)->return 1+2=3;\\n    \\t */\\n    \\tpublic long recurse(long dividend, long divisor, long init, long quotient){\\n    \\t\\tif(dividend > divisor){\\n    \\t\\t\\treturn recurse(dividend, divisor << 1, init, quotient << 1);\\n    \\t\\t} else if(dividend == divisor){\\n    \\t\\t\\treturn quotient;\\n    \\t\\t} else{\\n    \\t\\t\\tif(dividend-(divisor >> 1) < init)\\n    \\t\\t\\t\\treturn quotient>>1;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn recurse(dividend - (divisor >> 1), init, init, 1) + (quotient >> 1);\\n    \\t\\t}\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2029618,
                "title": "c-easy-to-understand-detailed-explanation-beginner-friendly-bitwise-o-log-n",
                "content": "Ayo! Another question that\\'s a bit tricky to get because, you guessed it, it involves a trick lol.\\nDon\\'t worry though, here\\'s the explanation, as simple as it can get!\\n\\nWe will follow a simple rule here.\\n- We are given 2 things. Dividend and Divisor.\\n- The dividend is divided by the divisor.\\n- Our job is to multiply divisor as long as it\\'s less than dividend.\\n\\n**Take this example: Dividend = 10. Divisor = 3.**\\nWe know the answer should be 3 because 3x3=9. Which is the greatest number we can achieve, by multiplying 3 n times and when subtracted from dividend, will be as close to 0 as possible. So, 10-9=1, which is very close to 0. \\n\\nOur job is to multiply divisor again and again, to make it such a large number that when subtracted from dividend, will give us a number as close to 0 as possible.\\n\\n**Steps Taken:**\\n1. The dividend and divisor can be negative. So store their sign for later use and for now, convert them into positive integers by using the abs() function.\\n2. While dividend is greater than divisor, we do the following operations on divisor:\\n3. We take a copy of divisor and try to double it as long as it\\'s smaller than dividend.\\n4. The number of times we double, is twice the number of times we multiply. So, if we double once, we are just multiplying the number by 2^1 in reality. If we double 4 times, then we\\'re actually multiplying the number by 2^4=8 (basic math: we\\'re just multiplying the number by 2 every time).\\n5. So keep doubling divisor\\'s copy and keep tracking how many times we multiplied divisor\\'s copy.\\n6. Now after a while, the divisor\\'s copy\\'s double will be greater than the dividend. So stop the doubling loop for now.\\n7. Now, whatever we have from doubling divisor\\'s copy. Subtract that from the dividend and store that back into the dividend. So, if we doubled 5 thrice, the divisor\\'s copy will be 40 or in other words, we multiplied 5 by 2^3=8 (5 doubled=10 doubled=20 doubled=40). So if we doubled 3 times, we basically multiplied 5 by 2^3=8. So if the divisor\\'s copy is now 40 and if our dividend was 48, our dividend after subtraction will be: 48-40=8, which is still less than original divisor 5. So our loop will run once again. This time, dividend is 8. Divisor is 5. Divisor\\'s copy\\'s double is 10, which is greater than 8. So we won\\'t double the divisor this time. So, if we didn\\'t double it, we just multiplied the 5 with 1, instead of 2. Now again, subtract 8-5=3. So, we first multiplied 5 by 8, then multiplied 5 by 1. Overall, we multiplied 5 by 9 (8+1), which is our answer. More loops won\\'t work because dividend is now 3, which is less than 5.\\n8. If our original dividend and divisor would have given positive result, we return ans as is.\\n9. Otherwise, if one of the numbers was negative, then we return ans with negative sign.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int divd, int divs) {\\n        // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(divd == INT_MIN and divs == -1){\\n            return INT_MAX;\\n        }\\n        // If dividend and divisor are both positive/negative\\n        // total is positive, else not.\\n        bool positiveSign = (divd < 0 == divs < 0);\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long dividend = abs(divd);\\n        long divisor = abs(divs);\\n        // our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n        long ans = 0;\\n        \\n        // while dividend is less/equal to divisor do the following:\\n        while(dividend >= divisor){\\n            // take a copy of divisor. we\\'re not modifying divisor,\\n            // because we still need to check if dividend is greater/equal to\\n            // our original divisor\\n            long divisor2 = divisor;\\n            // divisorMultipliedBy tells us how many times we can double\\n            // divisor so as to keep it less than dividend.\\n            // for example: 3x2=6. 3 doubled is 6, which is still less than 10\\n            long divisorMultipliedBy = 1;\\n            \\n            // while dividend is greater than double the divisor2 do the following:\\n            while(dividend >= (divisor2 << 1)){\\n                // double the divisor2, if it was 3 at first, make it 6\\n                divisor2 = divisor2 << 1;\\n                // Since we doubled divisor, store the amount of how many times\\n                // we multiplied divisor.\\n                // 3 doubled once=6, so we multiplied divisor by 2.\\n                // 3 doubled twice=12. So we multiplied 3 by 4.\\n                divisorMultipliedBy = divisorMultipliedBy << 1;\\n            }\\n            // divisorMultipliedBy should now have the number of times\\n            // we multiplied divisor to get a value less than dividend.\\n            ans+= divisorMultipliedBy;\\n            // so if now divisor2 is 6, after doubling once.\\n            // dividend was 10, but after subtracting dividend will become 10-6=4.\\n            // So now 4 is dividend, 3 is divisor and we try to find out the number\\n            // of multiplications again and add them up.\\n            // In the second iteration, we\\'ll multiply 3 by 1. So now it\\'ll be\\n            // 4-3=1. dividend is now as close to 0 as possible and is also less\\n            // than divisor. So, our final ans is 3. We x2 the 3 once and now x1.\\n            dividend -= divisor2;\\n        }\\n                  \\n        // if PositiveSign was true, then we return ans as is.\\n        if(positiveSign){\\n            return ans;\\n        }\\n        // otherwise, multiply by -1 (you can also directly write `return -ans`\\n        return ans * -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int divide(int divd, int divs) {\\n        // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(divd == INT_MIN and divs == -1){\\n            return INT_MAX;\\n        }\\n        // If dividend and divisor are both positive/negative\\n        // total is positive, else not.\\n        bool positiveSign = (divd < 0 == divs < 0);\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long dividend = abs(divd);\\n        long divisor = abs(divs);\\n        // our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n        long ans = 0;\\n        \\n        // while dividend is less/equal to divisor do the following:\\n        while(dividend >= divisor){\\n            // take a copy of divisor. we\\'re not modifying divisor,\\n            // because we still need to check if dividend is greater/equal to\\n            // our original divisor\\n            long divisor2 = divisor;\\n            // divisorMultipliedBy tells us how many times we can double\\n            // divisor so as to keep it less than dividend.\\n            // for example: 3x2=6. 3 doubled is 6, which is still less than 10\\n            long divisorMultipliedBy = 1;\\n            \\n            // while dividend is greater than double the divisor2 do the following:\\n            while(dividend >= (divisor2 << 1)){\\n                // double the divisor2, if it was 3 at first, make it 6\\n                divisor2 = divisor2 << 1;\\n                // Since we doubled divisor, store the amount of how many times\\n                // we multiplied divisor.\\n                // 3 doubled once=6, so we multiplied divisor by 2.\\n                // 3 doubled twice=12. So we multiplied 3 by 4.\\n                divisorMultipliedBy = divisorMultipliedBy << 1;\\n            }\\n            // divisorMultipliedBy should now have the number of times\\n            // we multiplied divisor to get a value less than dividend.\\n            ans+= divisorMultipliedBy;\\n            // so if now divisor2 is 6, after doubling once.\\n            // dividend was 10, but after subtracting dividend will become 10-6=4.\\n            // So now 4 is dividend, 3 is divisor and we try to find out the number\\n            // of multiplications again and add them up.\\n            // In the second iteration, we\\'ll multiply 3 by 1. So now it\\'ll be\\n            // 4-3=1. dividend is now as close to 0 as possible and is also less\\n            // than divisor. So, our final ans is 3. We x2 the 3 once and now x1.\\n            dividend -= divisor2;\\n        }\\n                  \\n        // if PositiveSign was true, then we return ans as is.\\n        if(positiveSign){\\n            return ans;\\n        }\\n        // otherwise, multiply by -1 (you can also directly write `return -ans`\\n        return ans * -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902484,
                "title": "100-fastest-swift-solution-log-n",
                "content": "```\\nclass Solution {\\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\\n        let is_negtive = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)\\n        let dividend = abs(dividend)\\n        let divisor = abs(divisor)\\n        var tmp = divisor\\n        var rem = dividend\\n        var res = 0\\n\\n        while rem >= tmp {\\n            var count = 0\\n            while rem >= tmp {\\n                count += 1\\n                tmp *= 10\\n            }\\n            tmp = divisor\\n            rem = rem - Int(pow(10, Double(count-1))) * tmp\\n            if rem >= 0 {\\n                res += Int(pow(10, Double(count-1)))\\n            }\\n        }\\n        \\n        if (is_negtive && res >= 2147483648) { res = 2147483648 }\\n        if (!is_negtive && res >= 2147483647) { res = 2147483647 }\\n        return is_negtive ? -1 * res : res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\\n        let is_negtive = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)\\n        let dividend = abs(dividend)\\n        let divisor = abs(divisor)\\n        var tmp = divisor\\n        var rem = dividend\\n        var res = 0\\n\\n        while rem >= tmp {\\n            var count = 0\\n            while rem >= tmp {\\n                count += 1\\n                tmp *= 10\\n            }\\n            tmp = divisor\\n            rem = rem - Int(pow(10, Double(count-1))) * tmp\\n            if rem >= 0 {\\n                res += Int(pow(10, Double(count-1)))\\n            }\\n        }\\n        \\n        if (is_negtive && res >= 2147483648) { res = 2147483648 }\\n        if (!is_negtive && res >= 2147483647) { res = 2147483647 }\\n        return is_negtive ? -1 * res : res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303141,
                "title": "python-beats-99-77-time-28ms-and-88-memory",
                "content": "Uses bit shifting until it cannot be performed anymore. Shifting by 1 bit to the left means multiplying the number by 2. If we shift two times, then it means we multiplied number by 4, etc.\\nExample `dividend = 31` and `divisor = 2`:\\n```\\n2 << 1 = 4 (31 > 4 == True)\\n4 << 1 = 8 (31 > 8 == True)\\n8 << 1 = 16 (31 > 16 == True)  # <-- pause here\\n16 << 1 = 32 (31 > 32 == False)\\n```\\nSo far we got `quotient = 8`, now we adjust `dividend = divident - 16 = 15` and repeat:\\n```\\n2 << 1 = 4 < 15\\n4 << 1 = 8 < 15\\n8 << 1 = 16 > 15\\n```\\nNow `quotient = 8 + 4` and new `dividend = divident - 8 = 15 - 8 = 7`\\n```\\n2 << 1 = 4 < 7\\n4 << 1 = 8 > 7\\n```\\nUpdate `quotient = 8 + 4 + 2` and `dividend = 7 - 4 = 3`\\nAs `2 << 1 = 4` which is > 3, but 3 > 2, we add one more unit to the quotient, resulting in `q = 15`.\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend >= 0 and divisor >= 0 or (dividend < 0 and divisor < 0):\\n            sign = 1\\n        else:\\n            sign = -1\\n        \\n\\t\\t# some shortcuts\\n        if divisor == -1 and dividend == -2147483648:\\n            return 2147483647\\n        elif divisor == 1:\\n            return abs(dividend) if sign == 1 else -abs(dividend)\\n        \\n        divisor = abs(divisor)\\n        dividend = abs(dividend)\\n        \\n        if dividend < divisor:\\n            return 0\\n        \\n        d = divisor\\n        q = 1\\n        rq = 0\\n        while True:\\n            t = divisor << 1\\n            if dividend >= t:\\n                divisor = t\\n                q += q\\n            else:\\n                rq += q\\n                q = 1\\n                dividend -= divisor\\n                divisor = d\\n                if (divisor << 1) > dividend:\\n                    if dividend >= divisor:\\n                        rq += 1\\n                    break\\n\\n        return rq if sign == 1 else -rq\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n2 << 1 = 4 (31 > 4 == True)\\n4 << 1 = 8 (31 > 8 == True)\\n8 << 1 = 16 (31 > 16 == True)  # <-- pause here\\n16 << 1 = 32 (31 > 32 == False)\\n```\n```\\n2 << 1 = 4 < 15\\n4 << 1 = 8 < 15\\n8 << 1 = 16 > 15\\n```\n```\\n2 << 1 = 4 < 7\\n4 << 1 = 8 > 7\\n```\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend >= 0 and divisor >= 0 or (dividend < 0 and divisor < 0):\\n            sign = 1\\n        else:\\n            sign = -1\\n        \\n\\t\\t# some shortcuts\\n        if divisor == -1 and dividend == -2147483648:\\n            return 2147483647\\n        elif divisor == 1:\\n            return abs(dividend) if sign == 1 else -abs(dividend)\\n        \\n        divisor = abs(divisor)\\n        dividend = abs(dividend)\\n        \\n        if dividend < divisor:\\n            return 0\\n        \\n        d = divisor\\n        q = 1\\n        rq = 0\\n        while True:\\n            t = divisor << 1\\n            if dividend >= t:\\n                divisor = t\\n                q += q\\n            else:\\n                rq += q\\n                q = 1\\n                dividend -= divisor\\n                divisor = d\\n                if (divisor << 1) > dividend:\\n                    if dividend >= divisor:\\n                        rq += 1\\n                    break\\n\\n        return rq if sign == 1 else -rq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203085,
                "title": "python-best-explanation-line-by-line-fast-efficient-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        #A condition to check whether both are positivie or not\\n        positive = (dividend < 0) == (divisor < 0)\\n        \\n        #Now we\\'ve stored our sign in poistive variable so we make both numbers positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        #This is the quotient\\n        ans = 0\\n        \\n        #Outer while loop which checks the lower multiples of divisor\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            \\n             #Inner while loop where values value of multiples of divisor keep doubling after each iteration for less number of operations\\n            while dividend >= temp:\\n                dividend -= temp\\n                \\n                ans += i #Storing the number of times number multiplied\\n                \\n                i <<= 1 #Doubling -- 1,2,4..\\n                \\n                temp <<= 1 #Doubling Divisor values -- x,2x,4x...\\n        \\n        #Re-assigning the sign to our answer\\n        if not positive:\\n            ans = -ans\\n            \\n        #Returning answer within range\\n        return min(max(-2147483648, ans), 2147483647)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        #A condition to check whether both are positivie or not\\n        positive = (dividend < 0) == (divisor < 0)\\n        \\n        #Now we\\'ve stored our sign in poistive variable so we make both numbers positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        #This is the quotient\\n        ans = 0\\n        \\n        #Outer while loop which checks the lower multiples of divisor\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            \\n             #Inner while loop where values value of multiples of divisor keep doubling after each iteration for less number of operations\\n            while dividend >= temp:\\n                dividend -= temp\\n                \\n                ans += i #Storing the number of times number multiplied\\n                \\n                i <<= 1 #Doubling -- 1,2,4..\\n                \\n                temp <<= 1 #Doubling Divisor values -- x,2x,4x...\\n        \\n        #Re-assigning the sign to our answer\\n        if not positive:\\n            ans = -ans\\n            \\n        #Returning answer within range\\n        return min(max(-2147483648, ans), 2147483647)",
                "codeTag": "Java"
            },
            {
                "id": 314856,
                "title": "c-0ms-100-using-log",
                "content": "\\nUsing  Fact : log(a/b) = log(a)-log(b)\\nans = a/b\\nlog(ans) = log(a/b)\\nlog(ans) = log(a)-log(b)\\nans = exp( log(a)-log(b) )\\n\\n```\\n  int divide(int dividend, int divisor) {\\n        int sign= (dividend<0 ^ divisor<0) ? -1 : 1; //same ? 0(false) (XOR)\\n        \\n        long ldividend=labs(dividend);\\n        long ldivisor=labs(divisor);\\n     \\n        long res = exp(log(ldividend)-log(ldivisor));\\n        cout<<ldividend<<\"/\"<<ldivisor<<\"=\"<<res;\\n        if(res>INT_MAX)\\n            return sign==1 ? INT_MAX:INT_MIN;\\n        return sign*(int)res;\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int divide(int dividend, int divisor) {\\n        int sign= (dividend<0 ^ divisor<0) ? -1 : 1; //same ? 0(false) (XOR)\\n        \\n        long ldividend=labs(dividend);\\n        long ldivisor=labs(divisor);\\n     \\n        long res = exp(log(ldividend)-log(ldivisor));\\n        cout<<ldividend<<\"/\"<<ldivisor<<\"=\"<<res;\\n        if(res>INT_MAX)\\n            return sign==1 ? INT_MAX:INT_MIN;\\n        return sign*(int)res;\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13607,
                "title": "accepted-cpp-solution-with-explainations",
                "content": "    int divide(int64_t n, int64_t m) {\\n    \\t// determine sign of the quotient\\n    \\tint sign = n < 0 ^ m < 0 ? -1 : 1;\\n    \\n    \\t// remove sign of operands\\n    \\tn = abs(n), m = abs(m);\\n    \\n    \\t// q stores the quotient in computation\\n    \\tint64_t q = 0;\\n    \\n    \\t// test down from the highest bit\\n    \\t// accumulate the tentative value for valid bits\\n    \\tfor (int64_t t = 0, i = 31; i >= 0; i--)\\n    \\t\\tif (t + (m << i) <= n)\\n    \\t\\t\\tt += m << i, q |= 1LL << i;\\n    \\n    \\t// assign back the sign\\n    \\tif (sign < 0) q = -q;\\n    \\n    \\t// check for overflow and return\\n    \\treturn q >= INT_MAX ? INT_MAX : q <= INT_MIN ? INT_MIN : q;\\n    }",
                "solutionTags": [],
                "code": "    int divide(int64_t n, int64_t m) {\\n    \\t// determine sign of the quotient\\n    \\tint sign = n < 0 ^ m < 0 ? -1 : 1;\\n    \\n    \\t// remove sign of operands\\n    \\tn = abs(n), m = abs(m);\\n    \\n    \\t// q stores the quotient in computation\\n    \\tint64_t q = 0;\\n    \\n    \\t// test down from the highest bit\\n    \\t// accumulate the tentative value for valid bits\\n    \\tfor (int64_t t = 0, i = 31; i >= 0; i--)\\n    \\t\\tif (t + (m << i) <= n)\\n    \\t\\t\\tt += m << i, q |= 1LL << i;\\n    \\n    \\t// assign back the sign\\n    \\tif (sign < 0) q = -q;\\n    \\n    \\t// check for overflow and return\\n    \\treturn q >= INT_MAX ? INT_MAX : q <= INT_MIN ? INT_MIN : q;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089781,
                "title": "go-back-to-the-elementary-school-basics-w-examples",
                "content": "We will follow the **same exact division algorithm we all learn in elementary school** to divide integers, but in binary:\\n\\n*\"We traverse `dividend` from left to right, looking at the first `k` digits, where `k` is the number of digits of `divisor`. If the number formed by those first `k` digits is larger than or equal to `divisor`, then we write `1` in the quotient, subtract and move on to the next digit.\"*\\n\\n# Examples\\n*53 &div; 3 = 17*\\n![image](https://assets.leetcode.com/users/images/0cbe7c91-feb1-4c1b-8527-5b820aa35478_1653891963.4127522.png)\\n\\n\\n*246 &div; 7 = 35*\\n![image](https://assets.leetcode.com/users/images/5b1e8a36-cc5e-4eee-a01d-3128b1ac4f4a_1653891972.2472856.png)\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0:\\n            return 0\\n\\t\\t# only case that gives answer outside of [-2 ** 31, 2 ** 31 - 1]\\n        if dividend == -2 ** 31 and divisor == -1:\\n            return 2 ** 31 - 1\\n\\t\\t\\t\\n\\t\\t# we work with positive numbers only and worry about the sign in the end\\n        if dividend > 0 and divisor > 0 or dividend < 0 and divisor < 0:\\n            positiveSign = True\\n        else:\\n            positiveSign = False\\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        quotient = 0\\n        for i in reversed(range(dividend.bit_length() - divisor.bit_length() + 1)):\\n            if dividend >> i >= divisor:\\n                dividend -= divisor << i\\n                quotient |= 1 << i\\n        \\n        return quotient if positiveSign else -quotient\\n```\\n# Notes\\n* **Time complexity:** *O(log(`dividend`))*\\n* **Space complexity:** *O(1)*\\n\\nWe don\\'t need to worry about `quotient` being smaller than `-2 ** 31` since `abs(quotient) <= abs(dividend) <= 2 ** 31`.\\n\\nEdit: Updated handling of corner case so that we **only** work with integers in `[-2 ** 31, 2 ** 31 - 1]` at all times.",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0:\\n            return 0\\n\\t\\t# only case that gives answer outside of [-2 ** 31, 2 ** 31 - 1]\\n        if dividend == -2 ** 31 and divisor == -1:\\n            return 2 ** 31 - 1\\n\\t\\t\\t\\n\\t\\t# we work with positive numbers only and worry about the sign in the end\\n        if dividend > 0 and divisor > 0 or dividend < 0 and divisor < 0:\\n            positiveSign = True\\n        else:\\n            positiveSign = False\\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        quotient = 0\\n        for i in reversed(range(dividend.bit_length() - divisor.bit_length() + 1)):\\n            if dividend >> i >= divisor:\\n                dividend -= divisor << i\\n                quotient |= 1 << i\\n        \\n        return quotient if positiveSign else -quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089277,
                "title": "with-explanation-3-possible-solution-in-c",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE IT\\n```\\nsolution 1:\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12. Now 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice, it is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens. We simply add 1 << 0 = 1 to the answer variable.\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```\\n\\nsolution 2:\\nBasic idea: a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b))\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend==0) return 0;\\n        if (divisor==0) return INT_MAX;\\n        long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n        if ((dividend<0)^(divisor<0)) res=-res;\\n        if (res>INT_MAX) res=INT_MAX;\\n        return res;\\n    }\\n};\\n```\\n\\nsolution 3:\\nLong division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations.\\nSo the overall complexity is O(( log N)^2)\\n\\n```\\ntypedef long long ll;\\n\\nint divide(int n_, int d_) {\\n    ll ans=0;\\n    ll n=abs((ll)n_);\\n    ll d=abs((ll)d_);\\n    while(n>=d){\\n        ll a=d;\\n        ll m=1;\\n        while((a<<1) < n){a<<=1;m<<=1;}\\n        ans+=m;\\n        n-=a;\\n    }\\n    if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n        return -ans;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE IT\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend==0) return 0;\\n        if (divisor==0) return INT_MAX;\\n        long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n        if ((dividend<0)^(divisor<0)) res=-res;\\n        if (res>INT_MAX) res=INT_MAX;\\n        return res;\\n    }\\n};\\n```\n```\\ntypedef long long ll;\\n\\nint divide(int n_, int d_) {\\n    ll ans=0;\\n    ll n=abs((ll)n_);\\n    ll d=abs((ll)d_);\\n    while(n>=d){\\n        ll a=d;\\n        ll m=1;\\n        while((a<<1) < n){a<<=1;m<<=1;}\\n        ans+=m;\\n        n-=a;\\n    }\\n    if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n        return -ans;\\n    return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13418,
                "title": "c-8ms-solution-without-long-long",
                "content": "\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor) return INT_MAX;\\n            if(divisor == 1) return dividend;\\n            if(divisor == -1){\\n                if(dividend == INT_MIN) {return INT_MAX;}\\n                else {return -dividend;}\\n            }\\n            \\n            bool s1 = dividend<0;\\n            bool s2 = divisor<0;\\n            \\n            unsigned int nom = s1?-dividend:dividend;\\n            unsigned int den = s2?-divisor:divisor;\\n            \\n            unsigned int rem = 0;\\n            unsigned int quot = 0;\\n            \\n            for(int i=31; i>=0;--i){\\n                rem <<= 1;\\n                rem |= (nom >> i) & 1;\\n                if(rem >= den){\\n                    rem -= den;\\n                    quot |= (1<<i);\\n                }\\n            }\\n    \\n            return s1^s2?-quot:quot;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor) return INT_MAX;\\n            if(divisor == 1) return dividend;\\n            if(divisor == -1){\\n                if(dividend == INT_MIN) {return INT_MAX;}",
                "codeTag": "Java"
            },
            {
                "id": 2719043,
                "title": "python-subtraction-o-logn",
                "content": "You can refer to this [video solution](https://www.youtube.com/watch?v=xefkgtd44hg&ab_channel=CheatCodeNinja) \\n\\nHere we are doubling the divisor everytime and hence compressing the total number of subtraction operations. \\nIf the doubled divisor is greater than the dividend, we reset our divisor to its initial value and try again.\\n\\nAt the end, we make sure that the output is within the given range and avoid an overflow.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        a = abs(dividend)\\n        b=abs(divisor)\\n        \\n        negative = (dividend<0 and divisor>=0) or (dividend>=0 and divisor<0)\\n        \\n        output = 0\\n        \\n        while a>=b:\\n            counter = 1\\n            decrement = b\\n            \\n            while a>=decrement:\\n                a-=decrement\\n                \\n                output+=counter\\n                counter+=counter\\n                decrement+=decrement\\n                \\n        output = output if not negative else -output\\n        \\n        return min(max(-2147483648, output), 2147483647)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "You can refer to this [video solution](https://www.youtube.com/watch?v=xefkgtd44hg&ab_channel=CheatCodeNinja) \\n\\nHere we are doubling the divisor everytime and hence compressing the total number of subtraction operations. \\nIf the doubled divisor is greater than the dividend, we reset our divisor to its initial value and try again.\\n\\nAt the end, we make sure that the output is within the given range and avoid an overflow.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        a = abs(dividend)\\n        b=abs(divisor)\\n        \\n        negative = (dividend<0 and divisor>=0) or (dividend>=0 and divisor<0)\\n        \\n        output = 0\\n        \\n        while a>=b:\\n            counter = 1\\n            decrement = b\\n            \\n            while a>=decrement:\\n                a-=decrement\\n                \\n                output+=counter\\n                counter+=counter\\n                decrement+=decrement\\n                \\n        output = output if not negative else -output\\n        \\n        return min(max(-2147483648, output), 2147483647)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1929540,
                "title": "java-solution-with-explanation",
                "content": "Logic explain\\nA dividend can be construct by the multiple of divisor\\n\\nE.g \\n`dividend = 20, divisor = 5 => 20 = 5 + 5 + 5 + 5 = 5 * 4`\\nOR\\n`dividend = 19, divisor = 5 => 19 = 5 + 5 + 5 +4 = 5 * 3 + 4 `\\nand what we need is to return the multiply of 5, which is  4 and 3 respectively.\\n\\nFirstly, we check dividend and divisor is negative. Then to ensure divident and divisor is possitive, do absolute value. \\n\\nThen all we need to do is to find out how many divisor is needed for dividend become 0 or less than divisor\\nwe create a counter to count number of divisor. \\n```\\n while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n\\t\\t\\tdividend -= divisor << count;\\n        }\\n```\\nThis count is number of left shift divisor did, for example 3 << 2 means 3 left shifted 2 times, each left shift equal to * 2, so 3 << 2 = 3 * 2 * 2 =  12. \\n\\nAnother example, dividend = 15, divisor = 3,\\nIn first outer loop, counter++ twice in inner loop, leading to 15 - 3 << 2, r += 1 << 2 (which is 4)\\nSince dividend (15 - 12 = 3) - divisor == 0, loop second times. Skip inner loop as the condition is false, r += 1 << 0 = 5 (1 << 0 == 1)\\n\\nLastly, if negative true, do\\n```\\n\\tr = ~r + 1;\\n```\\nwhich change a possitive number to negative, return answer.\\n\\n\\nThe most difficult part of this question is edge case.\\n\\nLets handle the first edge case, divident = -2147483648 and divisor =  -1.\\nthe answer should be 2147483648, however this overflow. We cannot calculate this, hence use this as if statement condition, and return max value directly.\\n```\\n\\tif(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n```\\n\\nAnother edge case is dividend = max_value or min_value and divisor =  1 (or -1 if divident = max_value)\\nYou can see in our inner loop, it is \\n```\\ndivisor << 1 << count\\n```\\ninstead of\\n```\\ndivisor << count\\n```\\nthis << 1 is a extra * 2 in order to prevent overflow. For example when dividend = min_value and divisor = 1, in\\n```\\n\\twhile(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n```\\ndivisor << count will eventually equal to -2147483648 (1 << 31 will overflow and get -2147483648), while dividend (for min_value, after abs it is overflow, so remain min_value) - -2147483648, it equal to 0 and while loop repeat endlessly. Adding << 1, 1 << 1 << 31 equal 0, and min_value - 0 will break the inner while loop.\\n\\nComplete code\\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean neg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0);\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int r = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n            dividend -= divisor << count;\\n        }\\n\\n        if(neg){\\n            r = ~r + 1;\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n\\t\\t\\tdividend -= divisor << count;\\n        }\\n```\n```\\n\\tr = ~r + 1;\\n```\n```\\n\\tif(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n```\n```\\ndivisor << 1 << count\\n```\n```\\ndivisor << count\\n```\n```\\n\\twhile(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n```\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean neg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0);\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int r = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n            dividend -= divisor << count;\\n        }\\n\\n        if(neg){\\n            r = ~r + 1;\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084897,
                "title": "c-o-1-using-exponential-and-log",
                "content": "**Approach** - \\n\\nLet\\'s say, a/b = c.\\n1 . Take log on both sides -> ```log(a/b) = log(c)```\\n2. Use log propery (log(a/b) = log(a) - log(b)) -> ```log(a) - log(b) = log(c)```\\n3. Take exponential on both sides (e(x) = 1/ln(x)) -> ```c = e^(log(a) - log(b))```, Find c now.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        int sign = (dividend < 0) ^ (divisor < 0);\\n        \\n        long dvnd = abs(dividend);\\n        long dvsr = abs(divisor);\\n        \\n        long res = exp(log(dvnd) - log(dvsr));\\n        \\n        res *= (sign ? -1 : 1);\\n        \\n        if(res > INT_MAX)\\n            return INT_MAX;\\n        \\n        if(res < INT_MIN)\\n            return INT_MIN;\\n        \\n        return res;\\n    }\\n};\\n\\n/*\\n\\na/b = c\\nlog(a) - log(b) = log(c)\\nc = e^(log(a) - log(b))\\n*/\\n```",
                "solutionTags": [],
                "code": "```log(a/b) = log(c)```\n```log(a) - log(b) = log(c)```\n```c = e^(log(a) - log(b))```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        int sign = (dividend < 0) ^ (divisor < 0);\\n        \\n        long dvnd = abs(dividend);\\n        long dvsr = abs(divisor);\\n        \\n        long res = exp(log(dvnd) - log(dvsr));\\n        \\n        res *= (sign ? -1 : 1);\\n        \\n        if(res > INT_MAX)\\n            return INT_MAX;\\n        \\n        if(res < INT_MIN)\\n            return INT_MIN;\\n        \\n        return res;\\n    }\\n};\\n\\n/*\\n\\na/b = c\\nlog(a) - log(b) = log(c)\\nc = e^(log(a) - log(b))\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016568,
                "title": "java-a-proper-approach",
                "content": "## Java: A proper approach\\n\\nSo a lot of the topics in this discussion are useless because they either do exactly what the problem tells you not to do and say \"look at me I can cheat\" or work around the problem by typecasting or some other bs. I will attempt to explain how you can implement this algorithm using only type `int`. I am open to questions, comments, concerns and improvements. \\n\\n*Note:* This problem and its solution are somewhat peculiar in that they\\'re less about practicing your algorithms than coming up with an interesting approach to a dull problem using what tools you have.\\n\\n### Approach \\n\\nSo you can\\'t (or at least the problem description tells you not to) use any math operations that would seem useful in this situation... thats a shame. \\n\\n#### Brute-force\\n\\nFrom a brute-force perspective, we can make a loop where we increment some counter by one and increment value $d$ by divisor until $d > $ dividend; then the answer we are looking for is simply the value of counter right before  $d > $ dividend. However, the runtime for this approach is linear, and so the solution won\\'t submit be accepted with a `Time Limit Exceeded` message.\\n\\nBut wait... if we can\\'t use multiplication or division to solve this problem, how can we achieve better than linear runtime (linear in the size of divisor that is)?\\n\\n#### The trick\\n\\nTurns out you can actually use integer multiplication and division ... as long as you realize that [bitwise shifting](https://stackoverflow.com/questions/3312853/how-does-bitshifting-work-in-java]) by 1 left or right is identically integer multiplication or division by 2 respectively and consequently accept that bitwise shifting is indeed allowed as part of the solution\\n\\n*Note:* I actually kind of just lied; bitwise operations only behave as I just described for `int` values $\\\\geq 0$, so well work around this by making both the dividend and that divisor positive and applying the proper sign at the end.\\n\\nNow, there are a couple of different directions we can go once we embrace the power of division by two. The solution I\\'ve chosen to role with here is simply long division... you know the long division that you learned in elementary school but don\\'t remember any more... just done in base two. Apparently this has a name, and it\\'s called binary division. If you can\\'t be bothered to remember/figure out exactly how it works, which is totally fair IMO, then the pseudo code is illustrated reasonably clearly [here](https://en.wikipedia.org/wiki/Division_algorithm#Integer_division_(unsigned)_with_remainder).\\n\\n### Why couldn\\'t they have restrained the dividend range by one more?\\n\\nI don\\'t want to spend a lot of time here, but there are some annoying and subtle problems that come with allowing the dividend to be `Int.MIN_VALUE` for example:\\n\\n``` java\\n    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE\\n```\\n\\nThus you need to be really careful dealing with this edge case, and I jerry-rigged my code so that I dealt with the consequences as I found them. It would have been so much nicer if LeetCode had just instead had the minimum allowed value be `Integer.MIN_VALUE + 1`\\n\\n### Runtime\\n\\nIts $O(log_2N)$ where $N$ is the size of the dividend: There only as many iterations as the number of bits in $N$. Note that in practice, we are restricting the inputs ot type `int`, which means that there is a maximum size of $N$, so in that sense the runtime is actually constant. I\\'m tired so someone else can come up with a better way to say this.\\n\\n### Ramblings\\n\\n- If you squint at the solution, you might be able to argue that binary long division is essentially\"binary-searching\" for the answer... but I think that\\'s a stretch.\\n\\n- Again, feel free to yell at me about the ways the code could be clearer... Looking back over it, it definitely doesn\\'t read easy.\\n\\n### Code\\n\\n``` java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Edge cases:\\n        // min integer value breaks things...\\n        boolean minValFlag = false;\\n        if(dividend == Integer.MIN_VALUE) {\\n            if(divisor == -1) return Integer.MAX_VALUE;\\n            else if(divisor == 1) return Integer.MIN_VALUE;\\n            // do the first iteration of binary division manually below\\n            else minValFlag = true;\\n        }\\n        if(divisor == Integer.MIN_VALUE) return minValFlag ? 1 : 0;\\n        \\n        //Determine the sign of the result (we know at this point neither is 0)\\n        boolean isNegative = dividend < 0 ^ divisor < 0;\\n        \\n        //make both dividend and divisor positive\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        //find the number of significant bits in the dividend\\n        int n = 1, dvdn = 1;\\n        while(dvdn < dividend && dvdn != Integer.MIN_VALUE) {\\n            dvdn <<=1;\\n            n++;\\n        }\\n        \\n        //Approach: do long division in binary\\n        int quotient = 0, remainder = 0;\\n        \\n        //deal with min-value annoyance\\n        if(minValFlag) {\\n            n = 31;\\n            remainder = 1;\\n        }\\n        \\n        for(n-- ; n >= 0; n--) {\\n            remainder <<= 1;\\n            remainder += (dividend >> n ) & 1;\\n            if(remainder >= divisor || remainder == Integer.MIN_VALUE) {\\n                remainder -= divisor;\\n                quotient += 1 << n;\\n            }\\n            //System.out.println(String.format(\"n is: %d %nremainder is: %d %nquotient is: %d %n\",n,remainder,quotient));\\n        }\\n        \\n        //return statement\\n        return isNegative ? 0 - quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\n    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE\\n```\n``` java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Edge cases:\\n        // min integer value breaks things...\\n        boolean minValFlag = false;\\n        if(dividend == Integer.MIN_VALUE) {\\n            if(divisor == -1) return Integer.MAX_VALUE;\\n            else if(divisor == 1) return Integer.MIN_VALUE;\\n            // do the first iteration of binary division manually below\\n            else minValFlag = true;\\n        }\\n        if(divisor == Integer.MIN_VALUE) return minValFlag ? 1 : 0;\\n        \\n        //Determine the sign of the result (we know at this point neither is 0)\\n        boolean isNegative = dividend < 0 ^ divisor < 0;\\n        \\n        //make both dividend and divisor positive\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        //find the number of significant bits in the dividend\\n        int n = 1, dvdn = 1;\\n        while(dvdn < dividend && dvdn != Integer.MIN_VALUE) {\\n            dvdn <<=1;\\n            n++;\\n        }\\n        \\n        //Approach: do long division in binary\\n        int quotient = 0, remainder = 0;\\n        \\n        //deal with min-value annoyance\\n        if(minValFlag) {\\n            n = 31;\\n            remainder = 1;\\n        }\\n        \\n        for(n-- ; n >= 0; n--) {\\n            remainder <<= 1;\\n            remainder += (dividend >> n ) & 1;\\n            if(remainder >= divisor || remainder == Integer.MIN_VALUE) {\\n                remainder -= divisor;\\n                quotient += 1 << n;\\n            }\\n            //System.out.println(String.format(\"n is: %d %nremainder is: %d %nquotient is: %d %n\",n,remainder,quotient));\\n        }\\n        \\n        //return statement\\n        return isNegative ? 0 - quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240862,
                "title": "c-solution-without-using-long-clear-fast",
                "content": "```cpp\\ntypedef numeric_limits<int> lim;\\n\\nint divide(int A, int B) {\\n    if (B == 0) return lim::max();\\n    // Check A and B for lim::min() before applying abs() to avoid overflow.\\n    if (B == lim::min()) return A == lim::min() ? 1 : 0;\\n    int quotient = 0;\\n    if (A == lim::min()) {\\n        // quotient is int thus cannot carry -lim::min() 1s,\\n        // so take special care when abs(B) == 1.\\n        if (B == -1) return lim::max();\\n        if (B == 1) return lim::min();\\n        // Add one B to A to avoid overflow.\\n        A += abs(B);\\n        quotient = 1;\\n    }\\n    bool positive = (A >= 0) == (B > 0);\\n    A = abs(A);\\n    B = abs(B);\\n    while (A >= B) {\\n        int quotient_ = 1;\\n        int B_ = B;\\n        while (A >= (B_ << 1) && (B_ << 1) > 0) {\\n            quotient_ <<= 1;\\n            B_ <<= 1;\\n        }\\n        A -= B_;\\n        quotient += quotient_;\\n    }\\n    return positive ? quotient : -quotient;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\ntypedef numeric_limits<int> lim;\\n\\nint divide(int A, int B) {\\n    if (B == 0) return lim::max();\\n    // Check A and B for lim::min() before applying abs() to avoid overflow.\\n    if (B == lim::min()) return A == lim::min() ? 1 : 0;\\n    int quotient = 0;\\n    if (A == lim::min()) {\\n        // quotient is int thus cannot carry -lim::min() 1s,\\n        // so take special care when abs(B) == 1.\\n        if (B == -1) return lim::max();\\n        if (B == 1) return lim::min();\\n        // Add one B to A to avoid overflow.\\n        A += abs(B);\\n        quotient = 1;\\n    }\\n    bool positive = (A >= 0) == (B > 0);\\n    A = abs(A);\\n    B = abs(B);\\n    while (A >= B) {\\n        int quotient_ = 1;\\n        int B_ = B;\\n        while (A >= (B_ << 1) && (B_ << 1) > 0) {\\n            quotient_ <<= 1;\\n            B_ <<= 1;\\n        }\\n        A -= B_;\\n        quotient += quotient_;\\n    }\\n    return positive ? quotient : -quotient;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3357353,
                "title": "beats-100-java-runtime-1ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (divisor == 0) {\\n            return 0;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        int quotient = 0;\\n        boolean negative = (dividend < 0) != (divisor < 0);\\n        long longDividend = Math.abs((long) dividend);\\n        long longDivisor = Math.abs((long) divisor);\\n        while (longDividend >= longDivisor) {\\n            int shift = 0;\\n            while (longDividend >= (longDivisor << shift)) {\\n                shift++;\\n            }\\n            shift--;\\n            longDividend -= longDivisor << shift;\\n            quotient += 1 << shift;\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (divisor == 0) {\\n            return 0;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        int quotient = 0;\\n        boolean negative = (dividend < 0) != (divisor < 0);\\n        long longDividend = Math.abs((long) dividend);\\n        long longDivisor = Math.abs((long) divisor);\\n        while (longDividend >= longDivisor) {\\n            int shift = 0;\\n            while (longDividend >= (longDivisor << shift)) {\\n                shift++;\\n            }\\n            shift--;\\n            longDividend -= longDivisor << shift;\\n            quotient += 1 << shift;\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130236,
                "title": "best-2-lines-of-code-in-java-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==(-2147483648) && divisor==(-1)) return 2147483647;\\n        return dividend/divisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==(-2147483648) && divisor==(-1)) return 2147483647;\\n        return dividend/divisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563104,
                "title": "c-bit-manuplation-easy-and-fast",
                "content": "**please upvote if it\\'s helpful**\\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400899,
                "title": "c-2-approaches-explained-brute-to-better-accepted-4ms",
                "content": "There are various approaches for this problem, two of them here I have discussed below :\\n\\n# Approach 1\\nThe first approach which comes to our mid is : **Repeated Subtraction**.\\nAll we need to do in this approach is keep subtracting divisor from dividend until dividend becomes less than divisor. The number of times we subtract will be our quotient and what\\'s left in dividend will be the remainder.\\n\\nExample: if dividend = 33 and divisor = 6, then we do\\n33 - 6 = 27\\n27 - 6 = 21\\n21 - 6 = 15\\n15 - 6 = 9\\n9 - 6 = 3\\nnow 3<6 , so we stop here and hence our remainder is 3 and no, of times we subtracted is 5 = quotient.\\n\\nFor this approach,\\n\\n```\\nint divide(int dividend, int divisor) {\\n \\n // if any one of them is negative then quotient will be negative else positive\\n  int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1; \\n \\n  // Update both divisor and\\n  // dividend positive\\n  dividend = abs(dividend);\\n  divisor = abs(divisor);\\n \\n  // Initialize the quotient\\n  int quotient = 0;\\n  while (dividend >= divisor) {\\n    dividend -= divisor;\\n    ++quotient;\\n  }\\n  //if the sign value computed earlier is -1 then negate the value of quotient\\n  if(sign==-1) quotient=-quotient;\\n   \\n  return quotient;\\n}\\n```\\n\\n**Time Complexity** : O(dividend) [consider case when dividend=n and divisor=1]\\n\\nNow we\\'ll try to optimize this time complexity.\\n\\n# Approach 2\\n\\nThe second approach includes **BIT MANIPULATION**.\\n\\nconsider the same example as above , dividend=33 and divisor=6\\n\\nhere we try to increase our divisor until it attains maximum value less than or equal to dividend, i.e.\\n\\n6 < 33\\n6 + 6 = 12 < 33\\n6 + 6 + 6 = 18 < 33\\n6 + 6 + 6 + 6 = 24 < 33\\n6 + 6 + 6 + 6 + 6 = 30 < 33\\n6 + 6 + 6 + 6 + 6 + 6 = 36 > 33 -----------------> stop here\\n\\nthus, max value of divisor can be 30 which is 5 times 6, hence quotient is 5.\\nnow instead of repeatedly adding this (which is same as in case of previous approach), we\\'ll use bit manipulation to do it more efficiently.\\n\\nwe iterate from i= 31 to 0 and try to find (divisor * (2^i)) if it is less than our dividend, we store it in a var, update our quotient and do the same. like in this example where dividend = 33 and divisor = 6\\n\\nintial t=0 (here we\\'ll be storing the current updated divisor), q=0 (quotient)\\nwe\\'ll be checking if t + (divisor * (2^i) <= dividend, if it is true we\\'ll do \\nt = t + (divisor * (2^i)) and q = q + (2^i)\\n\\ni = 31 : 0 + (6 * 2^31) > 33\\ni = 30 : 0 + (6 * 2^30) > 33\\n...\\n...\\n...\\n...\\ni = 3 : 0 + (6 * 2^3) = (6 * 8) = 48 > 33\\ni = 2 : 0 + (6 * 2^2) = (6 * 4) = **24 < 33** => t= 0 + 24 = 24  and  q = 0 + (2^2) = 4\\ni = 1 : 24 + (6 * 2^1) = 24 + 12 = 36 > 33\\ni = 0 : 24 + (6 * 2^0) = 24 + 6 = **30 < 33** => t = 24 + 6 = 30  and q = 4 + (2^0) = 5 \\n\\nnow we\\'ll put appropriate sign in front of q (if any one of divisor or dividend negative the negative else positive), then if q lies in range of int ,we return q else we return INT_MAX.\\n\\n**BIT Manipulation PART :**\\nsince , we aren\\'t allowed to use multiplication operator , thus we can calculate\\n\\ndivisor * (2^i)  as (divisor<<i) as left shift by i means same as multiplyin the number by (2^i)\\n\\n**CODE :**\\n\\n```\\nint divide(int dividend, int divisor) {\\n        \\n        long long t=0, q=0, n=labs(dividend), m=labs(divisor);\\n\\t\\t\\n\\t\\t//here we find the sign of the quotient, if both dividend and divisor\\n\\t\\t//have same sign then sign will be +1 else -1\\n        int sign = (dividend<0) ^ (divisor<0) ? -1 : 1;\\n        \\n        for(long long i=31;i>=0;i--)\\n        {\\n\\t\\t\\t//(m<<i) = m * (2^i)\\n            if(t + (m<<i) <= n)\\n            {\\n                t += (m<<i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//since 2^i here can be large for int so we typecast it in long long to prevent overflow \\n                q += (1LL<<i);\\n            }\\n        }\\n        \\n        if(sign<0) q=-q;\\n        \\n\\t\\t//if q goes out of bound, we return INT_MAX.\\n        return ((q>INT_MAX) or (q<INT_MIN)) ? INT_MAX : q;\\n        \\n        \\n    }\\n```\\n\\n**Time Complexity :** O( log(dividend) )",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint divide(int dividend, int divisor) {\\n \\n // if any one of them is negative then quotient will be negative else positive\\n  int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1; \\n \\n  // Update both divisor and\\n  // dividend positive\\n  dividend = abs(dividend);\\n  divisor = abs(divisor);\\n \\n  // Initialize the quotient\\n  int quotient = 0;\\n  while (dividend >= divisor) {\\n    dividend -= divisor;\\n    ++quotient;\\n  }\\n  //if the sign value computed earlier is -1 then negate the value of quotient\\n  if(sign==-1) quotient=-quotient;\\n   \\n  return quotient;\\n}\\n```\n```\\nint divide(int dividend, int divisor) {\\n        \\n        long long t=0, q=0, n=labs(dividend), m=labs(divisor);\\n\\t\\t\\n\\t\\t//here we find the sign of the quotient, if both dividend and divisor\\n\\t\\t//have same sign then sign will be +1 else -1\\n        int sign = (dividend<0) ^ (divisor<0) ? -1 : 1;\\n        \\n        for(long long i=31;i>=0;i--)\\n        {\\n\\t\\t\\t//(m<<i) = m * (2^i)\\n            if(t + (m<<i) <= n)\\n            {\\n                t += (m<<i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//since 2^i here can be large for int so we typecast it in long long to prevent overflow \\n                q += (1LL<<i);\\n            }\\n        }\\n        \\n        if(sign<0) q=-q;\\n        \\n\\t\\t//if q goes out of bound, we return INT_MAX.\\n        return ((q>INT_MAX) or (q<INT_MIN)) ? INT_MAX : q;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286238,
                "title": "0ms-java-solution-complies-to-all-conditions",
                "content": "If you are furiously looking for answers as i was, let me shed some light. I had to spend a lots of time to understand the secret behind the solutions to this problem. \\n\\nFirst of all, As we all know already the basic idea for solving the problem with out the mod operator is simply **identifying the number of times the divisor can fully SUBSTRACT the dividend as a whole** but iterations are so costly and it will not work for large numbers. The obvious secret is to identify **effective way to reduce the number of substractions**\\n\\nThe following is simply my idea but there can be many as well, \\n\\n**1. Exponensly increase the divisor until before it surpass the dividend then substract with it.\\n2. Add up the divisor until reduced\\n3. Repeat the same until it brings to 0**\\n\\nFor an example, 116 divided by 3, Following is the way to gradually reduce the possibilities and idendify the final quotient\\n\\n![image](https://assets.leetcode.com/users/images/31c9c3ac-8bd5-437a-a976-ad74d369e0f0_1624215160.6451015.png)\\n\\nLets start with 3, then double it which is 6 then 12, 24,..until we stop at 96 because 192 can be substracted. So here 96 == 3 * 2^5 ==  3 << 5 and quotient = 32, remainder = 20\\n\\nLet start the same process again with 20, it can go upto which gets to 12 == 3 * 2^2 == 3 << 2 then the quotient is now 32 + 4 = 36, reminder = 8\\n\\nLets start over again, i can go upto 6 which is again 6 == 3 * 2^1 == 3 << 1 the quotient is not 36+2 = 38, remainder = 2 which is less than divisor so we can not continue with the cycle and all ends here.\\n\\nHowever multiplication is not allowed to use let see what else we can do for replacing it. \\n\\n**Programmatic Rule:**\\nLeft Shift (<<) shall be considered as multiplication by 2^N\\nSimilarly, Right Shift (>>) shall be considered as division by 2^N \\n\\nSince the environment only allows to accomodate `integer`  data type, overflow cases are the corner cases.\\n\\nLets dive into the code,\\n\\n```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356127,
                "title": "small-c-program-logic-range",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint divide(long long int dividend, long long int divisor){\\n    if (dividend / divisor > pow(2,31) - 1)\\n    {\\n        return(pow(2,31) - 1);\\n    }\\n    else\\n     {\\n        return (dividend / divisor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint divide(long long int dividend, long long int divisor){\\n    if (dividend / divisor > pow(2,31) - 1)\\n    {\\n        return(pow(2,31) - 1);\\n    }\\n    else\\n     {\\n        return (dividend / divisor);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750712,
                "title": "java-faster-solution-runtime-2-ms-faster-than-81-21-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        int sign,result=0,value=31;\\n\\t\\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) sign = 1;  else sign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\twhile (ldividend >= ldivisor) {\\n\\t\\t\\twhile (ldividend < ldivisor << value) {\\n\\t\\t\\t\\tvalue--;\\n\\t\\t\\t}\\n\\t\\t\\tldividend -= ldivisor << value;\\n\\t\\t\\tresult += 1 << value;\\n\\t\\t}\\n\\t\\tif (result > Integer.MAX_VALUE) result = Integer.MAX_VALUE;\\n\\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) result=Integer.MAX_VALUE;\\n        result= sign > 0 ? result : -result; return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int sign,result=0,value=31;\\n\\t\\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) sign = 1;  else sign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\twhile (ldividend >= ldivisor) {\\n\\t\\t\\twhile (ldividend < ldivisor << value) {\\n\\t\\t\\t\\tvalue--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2089333,
                "title": "c-short-easy-explanation-w-comments",
                "content": "**Please upvote if you like it :)**\\n\\nUsing **long long** instead of **int** or **long** to avoid overflow.`\\n\\n***Code w/ Bit Manipulation:***\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t\\t// corner cases\\n        if (dividend == INT_MIN && divisor == -1 ) return INT_MAX;\\n        if (dividend == INT_MIN && divisor == 1 ) return INT_MIN;\\n\\t\\t\\n\\t\\t// initialization\\n        long long ans = 0, sign = dividend > 0 == divisor > 0 ? 1 : -1;\\n        if (divisor == -INT_MAX) return dividend == divisor;\\n        if (dividend == -INT_MAX)\\n            if (divisor == 1) return -INT_MAX;\\n        else if (divisor == -1) return INT_MAX;\\n        else dividend += abs(divisor), ans++;\\n        long long numerator = abs(dividend), denominator = abs(divisor);\\n        for (int i = 0; numerator >= denominator; i = 0) {\\n            while (numerator >> i >= denominator) i++;\\n            numerator -= denominator << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans; \\n    }\\n};\\n```\\n**Time Complexity : O(LogN^2)\\nSpace Complexity : O(N)**\\n\\n***Code w/ Logarithms:***\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { \\n        long long ans = 0; \\n        if ((long long)divisor== -INT_MAX) return dividend == divisor; \\n\\t\\t\\n\\t\\t//corner cases\\n        if ((long long)dividend == -INT_MAX) \\n            if ((long long)divisor == 1) return -INT_MAX; \\n            else if ((long long)divisor == -1) return INT_MAX; \\n\\t\\t\\t\\n\\t\\t\\t//update ans variable\\n            else dividend += abs((long long)divisor), ans++; \\n        ans += floor(exp(log(abs((long long)dividend)) - log(abs((long long)divisor)))); // exp(x) = e^x\\n        return dividend > 0 == divisor > 0 ? ans : -ans; \\n    }\\n};\\n```\\n**Time Complexity : O(LogN)\\nSpace Complexity : O(N)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t\\t// corner cases\\n        if (dividend == INT_MIN && divisor == -1 ) return INT_MAX;\\n        if (dividend == INT_MIN && divisor == 1 ) return INT_MIN;\\n\\t\\t\\n\\t\\t// initialization\\n        long long ans = 0, sign = dividend > 0 == divisor > 0 ? 1 : -1;\\n        if (divisor == -INT_MAX) return dividend == divisor;\\n        if (dividend == -INT_MAX)\\n            if (divisor == 1) return -INT_MAX;\\n        else if (divisor == -1) return INT_MAX;\\n        else dividend += abs(divisor), ans++;\\n        long long numerator = abs(dividend), denominator = abs(divisor);\\n        for (int i = 0; numerator >= denominator; i = 0) {\\n            while (numerator >> i >= denominator) i++;\\n            numerator -= denominator << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { \\n        long long ans = 0; \\n        if ((long long)divisor== -INT_MAX) return dividend == divisor; \\n\\t\\t\\n\\t\\t//corner cases\\n        if ((long long)dividend == -INT_MAX) \\n            if ((long long)divisor == 1) return -INT_MAX; \\n            else if ((long long)divisor == -1) return INT_MAX; \\n\\t\\t\\t\\n\\t\\t\\t//update ans variable\\n            else dividend += abs((long long)divisor), ans++; \\n        ans += floor(exp(log(abs((long long)dividend)) - log(abs((long long)divisor)))); // exp(x) = e^x\\n        return dividend > 0 == divisor > 0 ? ans : -ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898053,
                "title": "a-c-solution-using-bitwise-shift",
                "content": "To simplify the logic, assume dividend and divisor are positive. The main idea is making a loop to keep minusing divisor. But this way will lead to time limit exceeded when occuring a large dividend and a small divisor. So, let\\'s change the strategy. Before minusing divisor, we can make divisor as close dividend as possible but still lower than dividend. Then, we can greedily minus a large divisor in time complexity O(log(n)). And making this large divisor can be done by bitwise left-shift.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t    // If dividend is zero, return zero directly.\\n        if (dividend == 0) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// To let our strategy to work, we should handle the case if divisor is INT_MIN.\\n        if (divisor == INT_MIN) {\\n            return dividend == INT_MIN ? 1 : 0;\\n        }\\n        \\n\\t\\t// Use exclusive or to check the sign of answer.\\n        bool is_pos = (dividend > 0) ^ (divisor < 0);\\n        int ans = 0;\\n        \\n\\t\\t// Here is different from the description above.\\n\\t\\t// In practice, we force our dividend to be negative.\\n\\t\\t// Because the range of negative values (2^31) is larger than the range of positive values (2^31 - 1).\\n\\t\\t// If we force dividend to be positive, there may be integer overflow.\\n        if (dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        \\n\\t\\t// Divisor should be positive.\\n\\t\\t// Because we will apply bitwise shift to it.\\n\\t\\t// And we have handled the case when divisor is INT_MIN.\\n        if (divisor < 0) {\\n            divisor = 0 - divisor;\\n        }\\n        \\n\\t\\t// To compare negative dividend and positive divisor, we need to add negative sign to divisor.\\n        while (dividend <= -divisor) {\\n            int tmp = divisor;\\n            int step = 1;\\n            \\n\\t\\t\\t// \"tmp < 0x40000000\" is a trick. 0x40000000 is 2^30.\\n\\t\\t\\t// If we don\\'t limit the upper bound, tmp may keep shifting and lead an integer overflow.\\n            while (tmp < 0x40000000 && -tmp > dividend) {\\n                tmp <<= 1;\\n                step <<= 1;\\n            }\\n            \\n\\t\\t\\t// Here we find the largest divisor.\\n            if (-tmp < dividend) {\\n                tmp >>= 1;\\n                step >>= 1;\\n            }\\n            \\n            dividend += tmp;\\n\\t\\t\\t\\n\\t\\t\\t// Another trick is that using minus instead of using add.\\n\\t\\t\\t// The same reason as above: the range of negative values is larger than the range of positive values.\\n            ans -= step;\\n        }\\n        \\n        if (!is_pos) {\\n            return ans;\\n        } else {\\n            return ans == INT_MIN ? INT_MAX : -ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t    // If dividend is zero, return zero directly.\\n        if (dividend == 0) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// To let our strategy to work, we should handle the case if divisor is INT_MIN.\\n        if (divisor == INT_MIN) {\\n            return dividend == INT_MIN ? 1 : 0;\\n        }\\n        \\n\\t\\t// Use exclusive or to check the sign of answer.\\n        bool is_pos = (dividend > 0) ^ (divisor < 0);\\n        int ans = 0;\\n        \\n\\t\\t// Here is different from the description above.\\n\\t\\t// In practice, we force our dividend to be negative.\\n\\t\\t// Because the range of negative values (2^31) is larger than the range of positive values (2^31 - 1).\\n\\t\\t// If we force dividend to be positive, there may be integer overflow.\\n        if (dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        \\n\\t\\t// Divisor should be positive.\\n\\t\\t// Because we will apply bitwise shift to it.\\n\\t\\t// And we have handled the case when divisor is INT_MIN.\\n        if (divisor < 0) {\\n            divisor = 0 - divisor;\\n        }\\n        \\n\\t\\t// To compare negative dividend and positive divisor, we need to add negative sign to divisor.\\n        while (dividend <= -divisor) {\\n            int tmp = divisor;\\n            int step = 1;\\n            \\n\\t\\t\\t// \"tmp < 0x40000000\" is a trick. 0x40000000 is 2^30.\\n\\t\\t\\t// If we don\\'t limit the upper bound, tmp may keep shifting and lead an integer overflow.\\n            while (tmp < 0x40000000 && -tmp > dividend) {\\n                tmp <<= 1;\\n                step <<= 1;\\n            }\\n            \\n\\t\\t\\t// Here we find the largest divisor.\\n            if (-tmp < dividend) {\\n                tmp >>= 1;\\n                step >>= 1;\\n            }\\n            \\n            dividend += tmp;\\n\\t\\t\\t\\n\\t\\t\\t// Another trick is that using minus instead of using add.\\n\\t\\t\\t// The same reason as above: the range of negative values is larger than the range of positive values.\\n            ans -= step;\\n        }\\n        \\n        if (!is_pos) {\\n            return ans;\\n        } else {\\n            return ans == INT_MIN ? INT_MAX : -ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914066,
                "title": "3-approach-for-your-interview-prep-o-dividend-o-1-o-logn",
                "content": "\\n<h4> <strong>Approach  1: Brute force (repetitve deduction) [ O(dividend) ] </strong> </h4><br>\\n\\n**step1:**  if a,b is like any one the below case, \\n{-ve, +ve}, or { `-a/b` }  ->set the sign flag\\n{+ve, -ve}   or  { ` a/-b` } ->set the sign flag\\n\\n**step2:** handle the overflow result at first\\n\\n**step3:** repetitive deduction logic\\n\\n**step4:** if any of them(divisor,dividend) is negative, \\nthen to match the result, we have to make the result negative \\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n    \\n\\t\\n\\t\\n\\t// step2\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n    // step3 \\n    let res=0\\n    b = Math.abs(b)\\n    a = Math.abs(a)\\n    \\n    while (a >= b) {\\n      a -= b;\\n      res++;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (res*-1) // res = (-res)\\n    else return res\\n    \\n};\\n\\n```\\n<hr><hr><br><br> <br>\\n<h4> <strong>Approach  2: using log properties [ O(1) ] </strong> </h4>\\n\\n**step1:**  if a,b is like any one the below case, \\n{-ve, +ve}, or { `-a/b` }  ->set the sign flag\\n{+ve, -ve}   or  { ` a/-b` } ->set the sign flag\\n\\n**step2:** handle the overflow result at first\\n\\n**step3:** using formula: \\n```\\na/b = result\\nlog(a/b) = log(result)\\nlog(a)-log(b) = log(result)\\nexp(log(a) - log(b)) = result\\n```\\n**step4:** if any of them(divisor,dividend) is negative, \\nthen to match the result, we have to make the result negative \\n<br> <br> <hr><hr>\\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n\\n      \\n\\t  \\n\\t\\n\\t\\n\\t// step2 : overflow error handling\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n\\t\\n\\t//step3\\n    let ans = Math.exp(   Math.log(Math.abs(a))  -  Math.log(Math.abs(b))    )\\n    ans = Math.floor(ans)\\n    \\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (ans*-1) // ans = (-ans)\\n    else return ans\\n    \\n};\\n```\\n<hr><hr><br><br> <br>\\n<h4> <strong>Approach  3: Double the divisor everytime, and decrease it from dividend [ O(Logn) ] </strong> </h4>\\n\\n**step1:**  handle overflow cases\\n**step2:**  handle negative cases\\n**step3:**  \\nExample : dividend = 10, divisor = 3\\n```\\n 10      10                  10\\n- 3    -3x2              -3x2x2\\n---     ---               ------\\n\\n  7       4      (dvsr>dvd) exit\\n  \\nso, here twice we operated\\n\\n\\n\\n\\n 4                       4\\n-3                    -3x2\\n---                  -----\\n1            (dvsr>dvd) exit\\n\\nso here once we operated\\n\\n\\n\\n\\n\\n\\nso, twice+once= 3\\nso result is 3.\\n\\n```\\n\\n\\n\\n<br><br><br>\\n\\n```\\n\\n\\n\\n\\nvar divide = function(dividend, divisor) {\\n    \\n\\n\\n\\t // step 1 \\n     let INT_MAX =(2**31)-1, INT_MIN = -(2**31) \\n     if(dividend==INT_MIN && divisor==-1) return INT_MAX\\n     if(dividend==INT_MIN && divisor== 1) return INT_MIN\\n      \\n\\n\\t let double = 0, count = 0, res = 0\\n\\n\\n\\n\\n\\n\\t // step 2\\n     let sign = dividend<0 ^ divisor<0     \\n     dividend = Math.abs(dividend)\\n     divisor = Math.abs(divisor)\\n        \\n\\n\\n\\n\\n\\n     // step 3\\n     while (divisor <= dividend) {\\n        let double = divisor, count = 1\\n\\n        while( (double*2) <= dividend) {\\n            double = double*2\\n            count  = count*2\\n        }\\n\\n        res = res + count \\n        dividend = dividend - double\\n    }\\n\\n    return sign ? -res : res\\n};\\n    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n    \\n\\t\\n\\t\\n\\t// step2\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n    // step3 \\n    let res=0\\n    b = Math.abs(b)\\n    a = Math.abs(a)\\n    \\n    while (a >= b) {\\n      a -= b;\\n      res++;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (res*-1) // res = (-res)\\n    else return res\\n    \\n};\\n\\n```\n```\\na/b = result\\nlog(a/b) = log(result)\\nlog(a)-log(b) = log(result)\\nexp(log(a) - log(b)) = result\\n```\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n\\n      \\n\\t  \\n\\t\\n\\t\\n\\t// step2 : overflow error handling\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n\\t\\n\\t//step3\\n    let ans = Math.exp(   Math.log(Math.abs(a))  -  Math.log(Math.abs(b))    )\\n    ans = Math.floor(ans)\\n    \\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (ans*-1) // ans = (-ans)\\n    else return ans\\n    \\n};\\n```\n```\\n 10      10                  10\\n- 3    -3x2              -3x2x2\\n---     ---               ------\\n\\n  7       4      (dvsr>dvd) exit\\n  \\nso, here twice we operated\\n\\n\\n\\n\\n 4                       4\\n-3                    -3x2\\n---                  -----\\n1            (dvsr>dvd) exit\\n\\nso here once we operated\\n\\n\\n\\n\\n\\n\\nso, twice+once= 3\\nso result is 3.\\n\\n```\n```\\n\\n\\n\\n\\nvar divide = function(dividend, divisor) {\\n    \\n\\n\\n\\t // step 1 \\n     let INT_MAX =(2**31)-1, INT_MIN = -(2**31) \\n     if(dividend==INT_MIN && divisor==-1) return INT_MAX\\n     if(dividend==INT_MIN && divisor== 1) return INT_MIN\\n      \\n\\n\\t let double = 0, count = 0, res = 0\\n\\n\\n\\n\\n\\n\\t // step 2\\n     let sign = dividend<0 ^ divisor<0     \\n     dividend = Math.abs(dividend)\\n     divisor = Math.abs(divisor)\\n        \\n\\n\\n\\n\\n\\n     // step 3\\n     while (divisor <= dividend) {\\n        let double = divisor, count = 1\\n\\n        while( (double*2) <= dividend) {\\n            double = double*2\\n            count  = count*2\\n        }\\n\\n        res = res + count \\n        dividend = dividend - double\\n    }\\n\\n    return sign ? -res : res\\n};\\n    \\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186952,
                "title": "notes-on-solution-not-using-long-bit-shifting-etc-for-realistic-interview",
                "content": "At this point I'm sure most solutions are well understood. Without simply posting yet another ever so slightly different solution, I want to discuss a few points where some have discussed in comments, but may not be easily found; as well as giving those who don't have as many real interview experiences some ideas about what companies may prefer. \n\nFirst of all, this question is all about the limitation and constraints. For these type of questions, there may be cheesy ways to make it easier, but in a real interview, you shouldn't bank on it being allowed. For this very question it is specified the system can only handle Integers, thus **using Long should be out of the question.** If it's not clearly stated, you can always ask, just don't assume. We see it ain't too hard without long by turning numbers negative as many solutions have.\n\nSecondly, a straight forward adding solution may return wrong answers due to overflow during adding. A better way would be to use bit shifting, but unless you started interview solution on this direction initially (which can be weird tbh unless you do bits a lot), **it is easy to add a condition check to make sure that new sum isn't overflowing by seeing if it switched signs**. Though I find this slightly hacky from coding perspective because the purpose isn't obvious from code.\n\nIt is a good chance to discuss with interviewer what's preferred. For example, another cheap way is to define a value that's half of Max or Min (for using negatives), and use that as a loop guard to be more explicit. The constraint of not allowing multiplication and division is obviously for avoiding direct solutions, but we should always be able to hardcode a value if necessary. \n\nThough for this question, **some interviewer may be looking specifically for bit shifting operations** cuz it can be better or \"leet\", in which case communication is the most important to find out. I'd argue for code readability above all else.\n\nLast but not least, when discussing edge cases, it's important to not blast thru it without thought. For things like dividing by 0, if it wasn't explicitely stated to be impossible by the question, **It should be handled as an Exception**. Same for MIN_VALUE divide by -1 as well. \n\nPeople never throw catch exceptions on Leetcode but it's a great talking point in interviews. They may follow up and say for now assume it won't happen, or return a specific value to represent error for simplicity. If the interviewer said that, it's fine, but you should never come up with that yourself, that's bad code, confusing and can be factually incorrect. Of course, Leetcode make these explicit so people don't rage over unclear requirements, but it's good to think about. If an exception is to be thrown, it's also good to discuss with interviewer about whose responsibility it should be for handling it. This method, or the caller. \n\nI will attach my solution for reference, but nothing special. Recursive, no long or bit shifting though. \n\n```\n    public int divide(int dividend, int divisor) {\n        // Handle edge cases\n        if (dividend == 0) {\n            return 0;\n        } else if (dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE; \n        } \n        \n        // Get sign and switch to negative\n        boolean positive = true; \n        if (dividend > 0) {\n            dividend = -dividend;\n            positive = !positive;\n        }\n        \n        if (divisor > 0) {\n            divisor = -divisor;\n            positive = !positive;\n        }\n        \n        int res = helper(dividend, divisor);\n        return positive ? res : -res;\n    }\n    \n    public int helper(int dividend, int divisor) {\n        if (dividend > divisor) {\n            return 0;\n        } \n        \n        int multiple = divisor;\n        int count = 1;\n        while (multiple + multiple > dividend && multiple + multiple < 0) {\n            count += count;\n            multiple += multiple; \n        }\n        \n        int leftOver = dividend - multiple; \n        \n        int res = count + helper(leftOver, divisor);\n        \n        return res;\n    }\n```\n\nAnd a quick reminder on throwing exceptions - if others should handle it, simply modify method signature to be \n```\n    public int divide(int dividend, int divisor) throws Exception {\n        if (divisor == 0) {\n            throw new Exception(\"plz no\"); // Can make or use a more meaningful Exception class \n        } \n        ...\n```\n\nIf you were to handle it yourself, but have to return a value for the time. Then it's pointless unless printing a message or calling a log would suffice \n```\n    public int divide(int dividend, int divisor) {\n        try {\n            ...\n        } catch (Exception e) {\n            System.out.println(e.getMessage()); // or call some log / method to make this meaningful\n            return Integer.MAX_VALUE; // or w.e defined value to resolve this so caller can move on\n        } \n```\n\nI know this isn't the standard solution for leetcode discussion. But I hope it will help some newer people out there. Cheers. ",
                "solutionTags": [],
                "code": "```\n    public int divide(int dividend, int divisor) {\n        // Handle edge cases\n        if (dividend == 0) {\n            return 0;\n        } else if (dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE; \n        } \n        \n        // Get sign and switch to negative\n        boolean positive = true; \n        if (dividend > 0) {\n            dividend = -dividend;\n            positive = !positive;\n        }\n        \n        if (divisor > 0) {\n            divisor = -divisor;\n            positive = !positive;\n        }\n        \n        int res = helper(dividend, divisor);\n        return positive ? res : -res;\n    }\n    \n    public int helper(int dividend, int divisor) {\n        if (dividend > divisor) {\n            return 0;\n        } \n        \n        int multiple = divisor;\n        int count = 1;\n        while (multiple + multiple > dividend && multiple + multiple < 0) {\n            count += count;\n            multiple += multiple; \n        }\n        \n        int leftOver = dividend - multiple; \n        \n        int res = count + helper(leftOver, divisor);\n        \n        return res;\n    }\n```\n```\n    public int divide(int dividend, int divisor) throws Exception {\n        if (divisor == 0) {\n            throw new Exception(\"plz no\"); // Can make or use a more meaningful Exception class \n        } \n        ...\n```\n```\n    public int divide(int dividend, int divisor) {\n        try {\n            ...\n        } catch (Exception e) {\n            System.out.println(e.getMessage()); // or call some log / method to make this meaningful\n            return Integer.MAX_VALUE; // or w.e defined value to resolve this so caller can move on\n        } \n```",
                "codeTag": "Java"
            },
            {
                "id": 13573,
                "title": "wrong-answer-input-2147483648-1-output-2147483648-expected-2147483647",
                "content": "\\n\\n{\\n\\nclass Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        \\n        if dividend == 0:\\n            return 0\\n            \\n        sign = 1 if(dividend <0 and divisor <0) or (dividend >0 and divisor >0) else -1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        \\n        ans = 0\\n        \\n        while dividend >= divisor:\\n            shift = 0\\n            while ((divisor << shift) <= dividend):\\n                shift +=1\\n            \\n            ans += 1<<(shift-1)\\n            dividend -= divisor<<(shift-1)\\n            \\n        return ans if (sign==1) else -ans\\n}\\n\\n{\\nSubmission Result: \\nWrong Answer  Input:\\t-2147483648, -1 \\nOutput:\\t2147483648 \\nExpected:\\t2147483647\\n}\\n\\nI think my output is correct instead of the expected answer, but my code cannot be accepted. I think it should be some overflow problem. Could someone tell me how can I make this problem? Thanks!",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        \\n        if dividend == 0:\\n            return 0\\n            \\n        sign = 1 if(dividend <0 and divisor <0) or (dividend >0 and divisor >0) else -1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        \\n        ans = 0\\n        \\n        while dividend >= divisor:\\n            shift = 0\\n            while ((divisor << shift) <= dividend):\\n                shift +=1\\n            \\n            ans += 1<<(shift-1)\\n            dividend -= divisor<<(shift-1)\\n            \\n        return ans if (sign==1) else -ans\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3849831,
                "title": "c-solution-with-explanation-bit-manipulation-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the Bit Manipulation concept\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to represent the dividend in terms of power of 2 using divisor.\\nex1 -> `43/8 = 8*5 + 3 => 8(pow(2,2)+pow(2,0))+1`\\nex2 -> `7/3 = 3*2 + 1 => 3(pow(2,0))+1`\\n\\n1. Store the sign bit and make the dividend and divisor positive as it is difficult to work on the negative numbers \\n2. Now starting from the highest power of 2 if any multiple of (divisor * pow(2,i)) is less than dividend we add it to temp and store that power of 2 in ans. \\n3. Boundary condition are if (dividend is Minimum value and divisor is -1 then it led to bufferoverflow) and if (dividend is minimum and divisor is 1 than return the minimum value)\\n# Complexity\\n- Time complexity:O(31) ~ O(1)      \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long a = (long long) dividend, b = (long long)divisor;\\n        if (a == INT_MIN and b == -1) return INT_MAX;\\n        if (a == INT_MIN and b == 1) return INT_MIN;\\n        bool flg = (a > 0) == (b > 0) ? true : false;\\n        a = abs(a);\\n        b = abs(b);\\n        long long ans =0, temp = 0;\\n        for (int i = 31 ; i >= 0 ; i--){\\n            if (temp + ( b << i ) <= a){\\n                temp+= (b<<i);\\n                ans+= (1<<i);\\n            }\\n        }\\n        if (!flg) ans = -ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long a = (long long) dividend, b = (long long)divisor;\\n        if (a == INT_MIN and b == -1) return INT_MAX;\\n        if (a == INT_MIN and b == 1) return INT_MIN;\\n        bool flg = (a > 0) == (b > 0) ? true : false;\\n        a = abs(a);\\n        b = abs(b);\\n        long long ans =0, temp = 0;\\n        for (int i = 31 ; i >= 0 ; i--){\\n            if (temp + ( b << i ) <= a){\\n                temp+= (b<<i);\\n                ans+= (1<<i);\\n            }\\n        }\\n        if (!flg) ans = -ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219166,
                "title": "easy-and-fast-python-solution-with-explanation-and-example",
                "content": "**Approach**\\n1. Get sign \\n\\t```\\n\\tsign = 1\\n\\tif (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n\\t```\\n2. Till divisor exceeds dividend:\\n\\t- Get nearest multiple of 2 greater than dividend.\\n\\t- Once get the multiple, do right shift and get the multiple of 2 less than dividend.\\n\\t- Add quotient to result and update dividend.\\n\\t```\\n\\tresult = 0\\n\\tdividend = abs(dividend)\\n\\tdivisor = abs(divisor)\\n\\tmax_int = 2 ** 31 - 1\\n\\n\\twhile dividend >= divisor:\\n\\t\\ttemp = divisor\\n\\t\\tquotient = 1\\n\\t\\twhile temp <= dividend:\\n\\t\\t\\ttemp <<= 1\\n\\t\\t\\tquotient <<= 1\\n\\t\\tresult += quotient >> 1\\n\\t\\tdividend -= temp >> 1\\n\\t```\\n3. Return result based on sign.\\n\\t```\\n\\t# edge_case\\n\\tif result > max_int:\\n\\t\\tif sign == -1 and divisor == 1: return ~max_int\\n\\t\\telse: return max_int\\n\\n\\t# If sign is -1, take 1\\'s compliment of result and add 1 to get negative value\\n\\treturn ~(result) + 1 if sign == -1 else result\\n\\t```\\n\\n**Example**\\n- Lets say, dividend = 48 and divisor = 5. So its quotient should be 9 with remainder as 3.\\n- With first step sign will be 1.\\n- Here\\'s the second step:\\n![image](https://assets.leetcode.com/users/images/6504b41f-6bd5-47d1-804c-df87376c5f61_1656606768.27768.jpeg)\\n\\n- Will simply return result since sign is 1.\\n\\n\\n**Complete Solution**\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = 1\\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n        \\n        result = 0\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        max_int = 2 ** 31 - 1\\n        \\n        while dividend >= divisor:\\n            temp = divisor\\n            quotient = 1\\n            while temp <= dividend:\\n                temp <<= 1\\n                quotient <<= 1\\n            result += quotient >> 1\\n            dividend -= temp >> 1\\n        \\n        if result > max_int:\\n            if sign == -1 and divisor == 1: return ~max_int\\n            else: return max_int\\n        \\n        return ~(result) + 1 if sign == -1 else result\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tsign = 1\\n\\tif (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n\\t```\n```\\n\\tresult = 0\\n\\tdividend = abs(dividend)\\n\\tdivisor = abs(divisor)\\n\\tmax_int = 2 ** 31 - 1\\n\\n\\twhile dividend >= divisor:\\n\\t\\ttemp = divisor\\n\\t\\tquotient = 1\\n\\t\\twhile temp <= dividend:\\n\\t\\t\\ttemp <<= 1\\n\\t\\t\\tquotient <<= 1\\n\\t\\tresult += quotient >> 1\\n\\t\\tdividend -= temp >> 1\\n\\t```\n```\\n\\t# edge_case\\n\\tif result > max_int:\\n\\t\\tif sign == -1 and divisor == 1: return ~max_int\\n\\t\\telse: return max_int\\n\\n\\t# If sign is -1, take 1\\'s compliment of result and add 1 to get negative value\\n\\treturn ~(result) + 1 if sign == -1 else result\\n\\t```\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = 1\\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n        \\n        result = 0\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        max_int = 2 ** 31 - 1\\n        \\n        while dividend >= divisor:\\n            temp = divisor\\n            quotient = 1\\n            while temp <= dividend:\\n                temp <<= 1\\n                quotient <<= 1\\n            result += quotient >> 1\\n            dividend -= temp >> 1\\n        \\n        if result > max_int:\\n            if sign == -1 and divisor == 1: return ~max_int\\n            else: return max_int\\n        \\n        return ~(result) + 1 if sign == -1 else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091540,
                "title": "c-bit-manipulation-easy",
                "content": "```\\nThe key observation is that the quotient of a division is just the number of times that we can subtract the divisor from the dividend without making\\nit negative.\\n\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12.\\nNow 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice,\\nit is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the \\nquotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens.\\nWe simply add 1 << 0 = 1 to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle \\none overflow case: dividend = INT_MIN and divisor = -1.\\n\\n\\nclass Solution {\\npublic:\\n\\tint divide(int dividend, int divisor) {\\n         if (dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\tlong a = labs(dividend), b = labs(divisor), ans = 0;\\n        long sign = dividend<0 ^ divisor<0? -1 : 1;\\n\\t\\twhile (a >= b) {\\n\\t\\t\\tlong temp = b, m = 1;\\n\\t\\t\\twhile (temp << 1 <= a) {\\n\\t\\t\\t\\ttemp <<= 1;\\n\\t\\t\\t\\tm <<= 1;\\n\\t\\t\\t}\\n\\t\\t\\ta -= temp;\\n\\t\\t\\tans += m;\\n\\t\\t}\\n\\t\\treturn sign *ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nThe key observation is that the quotient of a division is just the number of times that we can subtract the divisor from the dividend without making\\nit negative.\\n\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12.\\nNow 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice,\\nit is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the \\nquotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens.\\nWe simply add 1 << 0 = 1 to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle \\none overflow case: dividend = INT_MIN and divisor = -1.\\n\\n\\nclass Solution {\\npublic:\\n\\tint divide(int dividend, int divisor) {\\n         if (dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\tlong a = labs(dividend), b = labs(divisor), ans = 0;\\n        long sign = dividend<0 ^ divisor<0? -1 : 1;\\n\\t\\twhile (a >= b) {\\n\\t\\t\\tlong temp = b, m = 1;\\n\\t\\t\\twhile (temp << 1 <= a) {\\n\\t\\t\\t\\ttemp <<= 1;\\n\\t\\t\\t\\tm <<= 1;\\n\\t\\t\\t}\\n\\t\\t\\ta -= temp;\\n\\t\\t\\tans += m;\\n\\t\\t}\\n\\t\\treturn sign *ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091148,
                "title": "java-solution-1ms-bit-manipulation",
                "content": "```\\nclass Solution {\\n       public static int divide(int dividend, int divisor) {\\n        if (Integer.MIN_VALUE == dividend && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int ans = 0;\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        while (a - b >= 0) {\\n            int temp = b;\\n            int count = 1;\\n            while (a - (temp << 1) >= 0) {\\n                temp <<= 1;\\n                count <<= 1;\\n            }\\n            a -= temp;\\n            ans += count;\\n        }\\n        return (dividend > 0) == (divisor > 0) ? ans : -ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n       public static int divide(int dividend, int divisor) {\\n        if (Integer.MIN_VALUE == dividend && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int ans = 0;\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        while (a - b >= 0) {\\n            int temp = b;\\n            int count = 1;\\n            while (a - (temp << 1) >= 0) {\\n                temp <<= 1;\\n                count <<= 1;\\n            }\\n            a -= temp;\\n            ans += count;\\n        }\\n        return (dividend > 0) == (divisor > 0) ? ans : -ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089759,
                "title": "easy-c-sol-time-o-logn-2-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n     \\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        if(dividend == divisor){\\n            return 1;\\n        }\\n        \\n        bool flag = (dividend >= 0) == (divisor>=0)?true:false;\\n        \\n       unsigned int dividnd = abs(dividend);\\n       unsigned int divsor = abs(divisor);\\n        \\n        unsigned int res = 0;\\n        \\n        while(dividnd >= divsor){\\n            \\n            short cnt=0;\\n            \\n            while(dividnd > (divsor << cnt+1)){\\n                cnt++;\\n            }\\n            res += 1 << cnt;\\n            dividnd -= divsor<<cnt;\\n        }\\n        \\n        return flag?res: - res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n     \\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 979719,
                "title": "js-bitwise-division",
                "content": "```\\nvar divide = function (dividend, divisor) {\\n    var rem = Math.abs(dividend);\\n    var div = Math.abs(divisor);\\n    var quo = 0;\\n    // subtract divisor bit by bit, starting from most significant bit\\n    for (var b = 31; b >= 0; b--) {\\n        if ((rem >>> b) >= div) {\\n            quo |= 1 << b;\\n            rem -= div << b;\\n        }\\n    }\\n    quo >>>= 0; // make unsigned\\n    if (dividend > 0 !== divisor > 0) quo = -quo; // add sign\\n    return quo > -0x80000000 ? quo < 0x7FFFFFFF ? quo : 0x7FFFFFFF : -0x80000000; // check bounds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar divide = function (dividend, divisor) {\\n    var rem = Math.abs(dividend);\\n    var div = Math.abs(divisor);\\n    var quo = 0;\\n    // subtract divisor bit by bit, starting from most significant bit\\n    for (var b = 31; b >= 0; b--) {\\n        if ((rem >>> b) >= div) {\\n            quo |= 1 << b;\\n            rem -= div << b;\\n        }\\n    }\\n    quo >>>= 0; // make unsigned\\n    if (dividend > 0 !== divisor > 0) quo = -quo; // add sign\\n    return quo > -0x80000000 ? quo < 0x7FFFFFFF ? quo : 0x7FFFFFFF : -0x80000000; // check bounds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709731,
                "title": "java-very-slow-but-simple",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        // stupid edge case\\n        if (divisor == -1 && dividend == Integer.MIN_VALUE)\\n            return Integer.MAX_VALUE;\\n        \\n        int cnt = 0;\\n        int a = Math.abs(dividend), b = Math.abs(divisor);\\n        \\n        while (a - b >= 0) {\\n            cnt++;\\n            a -= b;\\n        }\\n        \\n        return (dividend >= 0 && divisor >= 0) || (dividend <= 0 && divisor <= 0) ? cnt : -cnt;   \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        // stupid edge case\\n        if (divisor == -1 && dividend == Integer.MIN_VALUE)\\n            return Integer.MAX_VALUE;\\n        \\n        int cnt = 0;\\n        int a = Math.abs(dividend), b = Math.abs(divisor);\\n        \\n        while (a - b >= 0) {\\n            cnt++;\\n            a -= b;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 472298,
                "title": "short-python-3-only-and-logical-operators-took-20-40-ms",
                "content": "Many solutions avoid mul/div by left/right shifting operators. I don\\'t believe it\\'s cheating, because these are different operators, and because these solutions are not easier than the ones using only +-. It\\'s just absolutely unnecessary, because it\\'s enough to double value simply using a += a which is also faster than a >>= 1 in python.\\n(Abs technically also uses only logical operators and -.)\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0 or divisor == 1: #not necessary but makes things simpler\\n            return dividend\\n        if dividend == -2**31 and divisor == -1: #accurately deal with overflow\\n            return 2**31-1\\n        neg = (dividend < 0) ^ (divisor < 0)\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        endres = 0\\n        while dividend >= divisor:\\n\\t\\t   #At each iteration subtract the largest possible divisor*r=divisor*(2**k)\\n            resm = divisor\\n            r = 1\\n            while resm + resm < dividend:\\n                r += r\\n                resm += resm\\n            dividend -= resm\\n            endres += r\\n        return 0 - endres if neg else endres\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0 or divisor == 1: #not necessary but makes things simpler\\n            return dividend\\n        if dividend == -2**31 and divisor == -1: #accurately deal with overflow\\n            return 2**31-1\\n        neg = (dividend < 0) ^ (divisor < 0)\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        endres = 0\\n        while dividend >= divisor:\\n\\t\\t   #At each iteration subtract the largest possible divisor*r=divisor*(2**k)\\n            resm = divisor\\n            r = 1\\n            while resm + resm < dividend:\\n                r += r\\n                resm += resm\\n            dividend -= resm\\n            endres += r\\n        return 0 - endres if neg else endres\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383218,
                "title": "easy-peasy-python-bit-solution-with-example",
                "content": "\\tdef divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == -2147483648 and divisor == -1:\\n            return 2147483647\\n        if divisor == 1:\\n            return dividend\\n        negative = (dividend < 0) ^ (divisor < 0)\\n        dvd = abs(dividend)\\n        dvs = abs(divisor)\\n        res = 0\\n\\n        while dvd >= dvs:\\n            tmp = dvs\\n            m = 1\\n            while (tmp << 1) <= dvd:\\n                tmp <<= 1\\n                m <<= 1  # I am doubling m\\n            dvd -= tmp\\n            res += m\\n            \\n        if not negative:\\n            return res\\n        else:\\n            return ~res + 1\\n\\t\\t\\t\\n\\t\\n\\t# example, \\n\\tlet dividend = 23\\n\\tdivisor = 2\\n\\t\\n\\tso basically in each for loop I am finding the max number which is multiple of divisor \\n\\tif num = 23, then 16 is the max that I can reach by doubling divisor each time\\n\\tso remaning is 23 - 16 = 7\\n\\tNow, 4 is the max that I can reach by doubling 2 and still be less than 7\\n\\tremaining = 7 - 4 = 3\\n\\tand so on untill my divisor is not greater than dividend",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "\\tdef divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == -2147483648 and divisor == -1:\\n            return 2147483647\\n        if divisor == 1:\\n            return dividend\\n        negative = (dividend < 0) ^ (divisor < 0)\\n        dvd = abs(dividend)\\n        dvs = abs(divisor)\\n        res = 0\\n\\n        while dvd >= dvs:\\n            tmp = dvs\\n            m = 1\\n            while (tmp << 1) <= dvd:\\n                tmp <<= 1\\n                m <<= 1  # I am doubling m\\n            dvd -= tmp\\n            res += m\\n            \\n        if not negative:\\n            return res\\n        else:\\n            return ~res + 1\\n\\t\\t\\t\\n\\t\\n\\t# example, \\n\\tlet dividend = 23\\n\\tdivisor = 2\\n\\t\\n\\tso basically in each for loop I am finding the max number which is multiple of divisor \\n\\tif num = 23, then 16 is the max that I can reach by doubling divisor each time\\n\\tso remaning is 23 - 16 = 7\\n\\tNow, 4 is the max that I can reach by doubling 2 and still be less than 7\\n\\tremaining = 7 - 4 = 3\\n\\tand so on untill my divisor is not greater than dividend",
                "codeTag": "Python3"
            },
            {
                "id": 2425683,
                "title": "using-repeated-exponential-searches-approach-c",
                "content": "Implementation\\n\\n**Using Repeated exponential searches approach\\nTime Complexity = O(logN * logN), we can store the internal while loop generated number and power of two into an array as well, but it was will cause us O(logN) space complexity as well.\\nSpace Complexity = O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        // special case\\n        // bcz, if dividend is INT_MIN = -2147483648, and divisor is -1, and if we are converting into positive (2147483648), it will overflow the int value, so in this case we need to return the INT_MAX value which is 2147483647\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        int HALF_INT_MIN = -1073741824;\\n        int countNegativeNumber = 2;\\n        \\n        // converting into negative to avoid int overflow\\n        if(dividend > 0){\\n            countNegativeNumber--;\\n            dividend = -dividend;\\n        }\\n        \\n        if(divisor > 0){\\n            countNegativeNumber--;\\n            divisor = -divisor;\\n        }\\n        \\n        int quotientResult = 0;\\n        while(dividend <= divisor){\\n            \\n            int value = divisor;\\n            int powerOfTwo = -1;\\n            \\n            // check HALF_INT_MIN as well bcz of the int overflow issue\\n            while(value >= HALF_INT_MIN && value+value >= dividend){\\n                value += value;\\n                powerOfTwo += powerOfTwo;\\n            }\\n            \\n            dividend -= value;\\n            quotientResult += powerOfTwo;\\n        }\\n        \\n        if(countNegativeNumber != 1){\\n            return -quotientResult;\\n        }\\n        \\n        return quotientResult;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        // special case\\n        // bcz, if dividend is INT_MIN = -2147483648, and divisor is -1, and if we are converting into positive (2147483648), it will overflow the int value, so in this case we need to return the INT_MAX value which is 2147483647\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        int HALF_INT_MIN = -1073741824;\\n        int countNegativeNumber = 2;\\n        \\n        // converting into negative to avoid int overflow\\n        if(dividend > 0){\\n            countNegativeNumber--;\\n            dividend = -dividend;\\n        }\\n        \\n        if(divisor > 0){\\n            countNegativeNumber--;\\n            divisor = -divisor;\\n        }\\n        \\n        int quotientResult = 0;\\n        while(dividend <= divisor){\\n            \\n            int value = divisor;\\n            int powerOfTwo = -1;\\n            \\n            // check HALF_INT_MIN as well bcz of the int overflow issue\\n            while(value >= HALF_INT_MIN && value+value >= dividend){\\n                value += value;\\n                powerOfTwo += powerOfTwo;\\n            }\\n            \\n            dividend -= value;\\n            quotientResult += powerOfTwo;\\n        }\\n        \\n        if(countNegativeNumber != 1){\\n            return -quotientResult;\\n        }\\n        \\n        return quotientResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194697,
                "title": "python-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        sum = divisor\\n        quo=0\\n        while sum<=dividend:\\n            q2=1\\n            while (sum<<1) <=dividend:\\n                sum<<=1\\n                q2<<=1\\n            dividend -= sum\\n            sum = divisor\\n            quo += q2\\n        return min(2147483647, max(-quo if is_negative else quo, -2147483648))   \\n```\\n***Pls upvote if you find it helpful.***",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        sum = divisor\\n        quo=0\\n        while sum<=dividend:\\n            q2=1\\n            while (sum<<1) <=dividend:\\n                sum<<=1\\n                q2<<=1\\n            dividend -= sum\\n            sum = divisor\\n            quo += q2\\n        return min(2147483647, max(-quo if is_negative else quo, -2147483648))   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889305,
                "title": "python-solution-faster-than-92",
                "content": "```\\n\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int):\\n        sign = 1 if (dividend > 0) == (divisor > 0) else -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n\\n        if sign < 0:\\n            res = -res\\n\\n        return min(max(-2147483648, res), 2147483647)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int):\\n        sign = 1 if (dividend > 0) == (divisor > 0) else -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n\\n        if sign < 0:\\n            res = -res\\n\\n        return min(max(-2147483648, res), 2147483647)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318451,
                "title": "solution-explanation-not-just-code",
                "content": "Let\\'s assume, \\na = dividend and b = divisor\\n\\nwe can write a/b as, a/b = q  or a = b*q\\n\\nNow, any number can be expressed as a unique sum of some powers of 2\\nFor example, 7 = 2^0 + 2^1 + 2^2 and 11 = 2^0 + 2^1 + 2^3\\n\\nLet\\'s assume,\\nq = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\n \\nNow,\\na = b * (2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n)\\nor\\na = (b * 2^p_1) + (b * 2^p_2) +  (b * 2^p_3) + ... + (b * 2^p_n)\\n\\nWe need to calculate these terms without using any sort of multiplication or division or modulo\\n\\nThe key to the solution is the \\'<<\\' operator or the left shift operator\\nx = x << 1 is equivalent to multiplying x with 2\\n\\nConsider this code,\\n```\\nint b_value = b;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n}\\n```\\n\\nThe above for loop would calculate the following,\\nb_value = b\\nb_value = b * 2\\nb_value = b * 2^2\\nb_value = b * 2^3\\nb_value = b * 2^4 and so on.....\\n\\nBut remember q = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\nSo we need the powers of 2\\n\\nWe can do it like this,\\n```\\nint b_value = b;\\nint q_value = 1;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tq_value = q_value << 1;\\n}\\n```\\n\\nNow the for loop would calculate the following,\\nb_value = b, q_value = 1\\nb_value = b * 2, q_value = 2\\nb_value = b * 2^2, q_value = 4 or 2^2\\nb_value = b * 2^3, q_value = 8 or 2^3\\nb_value = b * 2^4, q_value = 16 or 2^4 and so on.....\\n\\nBut this for loop is just multiplying b and 1 by 2s. We need to figure out which power of 2s sum up to q.\\nTo do this we need to first collect all the b_values and q_values into two vectors,\\n```\\nint b_value = b;\\nvector<int> b_values;\\nint q_value = 1;\\nvecotr<int> q_values;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tb_values.push_back(b_value);\\n\\tq_value = q_value << 1;\\n\\tq_values.push_back(q_value);\\n}\\n```\\n\\nAnother interesting fact!\\nIf we have power_of_2s = [2^0, 2^1, 2^2, ... , 2^n], we can figure out the terms that sum up to m like this (here m < 2^n+1),\\n```\\nvector<int> terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(power_of_2s[i] <= m)\\n\\t{\\n\\t\\tterms.push_back(power_of_2s[i]);\\n\\t\\tm -= power_of_2s[];\\n\\t}\\n}\\n```\\n\\nif power_of_2s = [1, 2, 4, 8] and m = 11 the for loop proceeds like this,\\niteration 1: 8 <= 11 is true, m is changed to 3, terms = [8]\\niteration 2: 4 <= 3 is false, terms = [8]\\niteration 3: 2 <= 3 is true, m is changed to 1, terms = [8, 2]\\niteration 4: 1 <= 1 is true, m is changed to 0, terms = [8, 2, 1]\\nThe sum of the terms, 8 + 2 + 1 = 11\\n\\nNow lets see the two equations that started all this\\nq = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\na = (b * 2^p_1) + (b * 2^p_2) +  (b * 2^p_3) + (b * 2^p_n)\\n\\nLet\\'s say we have collected the necessary b_values and q_values (see above) such that\\nq_values = [1, 2, 4, ... , 2^n]\\nb_values = [b, b * 2, b * 4, ..., b * 2^n] where a < b * 2^n+1\\nWe have to select the b_values that sum up to a\\nWhenever we select a b_value, we also select the corresponding q_value. These will sum up to q\\n```\\nvector<int> b_terms\\nvector<int> q_terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(b_values[i] <= a)\\n\\t{\\n\\t\\tb_terms.push_back(b_values[i]);\\n\\t\\tq_terms.push_back(q_values[i]);\\n\\t\\ta -= b_values[i];\\n\\t}\\n}\\n```\\nSumming up the q_terms will get us q\\nIt can also be verified that the b_terms sum up to a\\n\\nFor a = 36 and b = 3, q_values = [1, 2, 4, 8] and b_values = [3, 6, 12, 24]\\nThe for loop proceeds like this, \\niteration 1: 24 <= 36 is true, a is changed to 12, q_terms = [8], b_terms = [24]\\niteration 2: 12 <= 12 is true, a is changed to 0, q_terms = [8, 4], b_terms = [24, 12]\\niteration 3: 4 <= 0 is false, q_terms = [8, 4], b_terms = [24, 12]\\niteration 4: 1 <= 0 is false, q_terms = [8, 4], b_terms = [24, 12]\\n\\nq = 8+4 = 12\\nand\\nb = 24+12 = 36\\n\\nHope that clears things up ^_^\\n(P.S. I omitted to discuss the overflow issues as the explanation was getting too long. The code for handling overflow can be easily understood from other user\\'s code)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint b_value = b;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n}\\n```\n```\\nint b_value = b;\\nint q_value = 1;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tq_value = q_value << 1;\\n}\\n```\n```\\nint b_value = b;\\nvector<int> b_values;\\nint q_value = 1;\\nvecotr<int> q_values;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tb_values.push_back(b_value);\\n\\tq_value = q_value << 1;\\n\\tq_values.push_back(q_value);\\n}\\n```\n```\\nvector<int> terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(power_of_2s[i] <= m)\\n\\t{\\n\\t\\tterms.push_back(power_of_2s[i]);\\n\\t\\tm -= power_of_2s[];\\n\\t}\\n}\\n```\n```\\nvector<int> b_terms\\nvector<int> q_terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(b_values[i] <= a)\\n\\t{\\n\\t\\tb_terms.push_back(b_values[i]);\\n\\t\\tq_terms.push_back(q_values[i]);\\n\\t\\ta -= b_values[i];\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084794,
                "title": "divide-two-integers-java-easy-solution-w-explanation",
                "content": "In this problem we are asked two divide two integers without using multiplication, division, and mod operator.\\n\\nWe know that multiplication of M and N is nothing but addition of M, N times.\\nSimilarly, Division of M and N is nothing but subtraction of N from M as long as resulting value is positive. Here the number of subtractions made is the quotient and the last remaining positive number (including zero)  is the remainder.\\n\\nAlso, the problem wants us to limit the division result in integer range.\\nExtreme cases:\\n1. To always consider sign of the dividend and divisor. This will help in determining final sign of quotient\\n2. If dividend is Integer.MIN_VALUE and divisor is -1. Then quotient will exceed Integer.MAX_VALUE\\n\\n\\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == 0) {\\n            return 0;\\n        }\\n\\n        long posDivd = dividend;\\n        long posDivr = divisor;\\n        boolean divdSign = true, divrSign = true;\\n\\n        if(dividend < 0) {\\n            posDivd = -posDivd;\\n            if(posDivd < 0) {\\n                posDivd = Integer.MAX_VALUE;\\n            }\\n            divdSign = false;\\n        }\\n\\n        if(divisor < 0) {\\n            posDivr = -posDivr;\\n            if(posDivr < 0) {\\n                posDivr = Integer.MAX_VALUE;\\n            }\\n            divrSign = false;\\n        }\\n\\n        if(posDivr == 1) {\\n            if(divdSign == divrSign) {\\n                return (int) Math.min(posDivd, Integer.MAX_VALUE);\\n            } else {\\n                return (int) Math.max(-posDivd, Integer.MIN_VALUE);\\n            }\\n        }\\n\\n        long temp = posDivr;\\n        long count = 0;\\n        while(temp <= posDivd) {\\n            temp += posDivr;\\n            count++;\\n        }\\n\\n        if(divdSign == divrSign) {\\n            return (int) Math.min(count, Integer.MAX_VALUE);\\n        } else {\\n            return (int) Math.max(-count, Integer.MIN_VALUE);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == 0) {\\n            return 0;\\n        }\\n\\n        long posDivd = dividend;\\n        long posDivr = divisor;\\n        boolean divdSign = true, divrSign = true;\\n\\n        if(dividend < 0) {\\n            posDivd = -posDivd;\\n            if(posDivd < 0) {\\n                posDivd = Integer.MAX_VALUE;\\n            }\\n            divdSign = false;\\n        }\\n\\n        if(divisor < 0) {\\n            posDivr = -posDivr;\\n            if(posDivr < 0) {\\n                posDivr = Integer.MAX_VALUE;\\n            }\\n            divrSign = false;\\n        }\\n\\n        if(posDivr == 1) {\\n            if(divdSign == divrSign) {\\n                return (int) Math.min(posDivd, Integer.MAX_VALUE);\\n            } else {\\n                return (int) Math.max(-posDivd, Integer.MIN_VALUE);\\n            }\\n        }\\n\\n        long temp = posDivr;\\n        long count = 0;\\n        while(temp <= posDivd) {\\n            temp += posDivr;\\n            count++;\\n        }\\n\\n        if(divdSign == divrSign) {\\n            return (int) Math.min(count, Integer.MAX_VALUE);\\n        } else {\\n            return (int) Math.max(-count, Integer.MIN_VALUE);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480305,
                "title": "explained-java-1ms-without-long-100",
                "content": "**LOGIC:**\\n\\n![image](https://assets.leetcode.com/users/him431/image_1579014954.png)\\n\\n\\n **For a/b,\\n  1) We check like b,2b,4b,8b ,.. max value that can be subtracted from a\\n  2) Subtract from a , add 2^x in result and continue**\\n\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Base Cases\\n        if (divisor == 1) {\\n            return dividend;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        \\n        int result = 0;\\n        int a = dividend<0 ? -dividend : dividend;\\n        int b = divisor<0 ? -divisor : divisor;\\n        \\n        while(a-b>=0){\\n            int x=0;//by default start with : a-b*(2^0) = a-b\\n            while(a-(b<<x) >=0){ // a- b*(2^x) >= 0 , to get max x for this\\n                x++;\\n            }\\n            x--; // bcoz loop condition was not satisfied after last x++\\n            \\n            result += 1<<x; // count how many times b was added to itself i.e. 2^x\\n            a-= b<<x;       // subtract that max subtractable i.e. b*(2^x) from a\\n        }\\n        \\n        return (dividend >= 0) == (divisor >= 0) ? result : -result;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Base Cases\\n        if (divisor == 1) {\\n            return dividend;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        \\n        int result = 0;\\n        int a = dividend<0 ? -dividend : dividend;\\n        int b = divisor<0 ? -divisor : divisor;\\n        \\n        while(a-b>=0){\\n            int x=0;//by default start with : a-b*(2^0) = a-b\\n            while(a-(b<<x) >=0){ // a- b*(2^x) >= 0 , to get max x for this\\n                x++;\\n            }\\n            x--; // bcoz loop condition was not satisfied after last x++\\n            \\n            result += 1<<x; // count how many times b was added to itself i.e. 2^x\\n            a-= b<<x;       // subtract that max subtractable i.e. b*(2^x) from a\\n        }\\n        \\n        return (dividend >= 0) == (divisor >= 0) ? result : -result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448102,
                "title": "very-simple-c-solution-using-bit-shifting-using-only-32-bit-variables",
                "content": "```\\n/*\\n\\tDivision using bit manipulation without using long (constraint: use 32 bit values only)\\n    https://leetcode.com/problems/divide-two-integers/\\n*/\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        unsigned int divisor = static_cast<unsigned int>(y);\\n        unsigned int dividend = static_cast<unsigned int>(x);\\n        unsigned int quotient = 0;\\n        \\n        // decide the sign\\n        bool negative = (x < 0) ^ (y < 0);\\n        if(dividend == INT_MIN  && divisor == -1)\\n            return INT_MAX;\\n        if(y < 0) \\n            divisor = -1 * divisor;\\n        if(x < 0)\\n            dividend = -1 * dividend;\\n        \\n        // We start with the largest permissible multiple for the divisor\\n        // such that the divisor is still smaller than dividend,\\n        // then we add that bit to the quotient. The dividend is updated \\n        // with dividend = dividend - divisor*multiple\\n        // Then we again find the next largest multiple that when multiplied with divisor\\n        // gives a value closer to dividend. Continue doing this till we get 0\\n        const int N_BITS = sizeof(int) * 8;\\n        \\n        // find the MSB set bit(1 indexed)\\n        int msb_pos = 0;\\n        for(int i = N_BITS - 1; i >= 0; i--) {\\n            if((1 << i) & divisor) {\\n                msb_pos = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = (N_BITS - msb_pos); i >= 0; i--) {\\n            // 2^i * divisor <= dividend\\n            if((divisor << i) <= dividend) {\\n                dividend -= divisor << i;  // dividend = dividend - divisor*2^i\\n                quotient |= 1 << i;\\n            }\\n        }\\n        \\n        // check for overflow, happens when the quotient is storing max value\\n        // which in case negative sign is not there, needs to be made +ve and that\\n        // time overflow happens, quotient = INT_MIN and nagtive = false\\n        if(quotient == numeric_limits<int>::min() && !negative)\\n            return numeric_limits<int>::max();\\n        // add the sign if required\\n        quotient = negative ? -1 * quotient: quotient;\\n\\n        return quotient; \\n      }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tDivision using bit manipulation without using long (constraint: use 32 bit values only)\\n    https://leetcode.com/problems/divide-two-integers/\\n*/\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        unsigned int divisor = static_cast<unsigned int>(y);\\n        unsigned int dividend = static_cast<unsigned int>(x);\\n        unsigned int quotient = 0;\\n        \\n        // decide the sign\\n        bool negative = (x < 0) ^ (y < 0);\\n        if(dividend == INT_MIN  && divisor == -1)\\n            return INT_MAX;\\n        if(y < 0) \\n            divisor = -1 * divisor;\\n        if(x < 0)\\n            dividend = -1 * dividend;\\n        \\n        // We start with the largest permissible multiple for the divisor\\n        // such that the divisor is still smaller than dividend,\\n        // then we add that bit to the quotient. The dividend is updated \\n        // with dividend = dividend - divisor*multiple\\n        // Then we again find the next largest multiple that when multiplied with divisor\\n        // gives a value closer to dividend. Continue doing this till we get 0\\n        const int N_BITS = sizeof(int) * 8;\\n        \\n        // find the MSB set bit(1 indexed)\\n        int msb_pos = 0;\\n        for(int i = N_BITS - 1; i >= 0; i--) {\\n            if((1 << i) & divisor) {\\n                msb_pos = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = (N_BITS - msb_pos); i >= 0; i--) {\\n            // 2^i * divisor <= dividend\\n            if((divisor << i) <= dividend) {\\n                dividend -= divisor << i;  // dividend = dividend - divisor*2^i\\n                quotient |= 1 << i;\\n            }\\n        }\\n        \\n        // check for overflow, happens when the quotient is storing max value\\n        // which in case negative sign is not there, needs to be made +ve and that\\n        // time overflow happens, quotient = INT_MIN and nagtive = false\\n        if(quotient == numeric_limits<int>::min() && !negative)\\n            return numeric_limits<int>::max();\\n        // add the sign if required\\n        quotient = negative ? -1 * quotient: quotient;\\n\\n        return quotient; \\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13555,
                "title": "ac-python-solution",
                "content": "    MAX_INT = 0x7FFFFFFF\\n\\n    def divide(self, dividend, divisor):\\n        if divisor == 0:\\n            return self.MAX_INT\\n        if dividend == 0:\\n            return 0\\n        negative = (dividend > 0) ^ (divisor > 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        ans = 0\\n        while dividend >= divisor:\\n            x = divisor\\n            i = 1\\n            while dividend >= x + x:\\n                x += x\\n                i += i\\n            dividend -= x\\n            ans += i\\n        ans = self.MAX_INT if not negative and ans > self.MAX_INT else ans\\n        return -ans if negative else ans\\n\\n\\n    # 988 / 988 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 85.93%",
                "solutionTags": [
                    "Python"
                ],
                "code": "    MAX_INT = 0x7FFFFFFF\\n\\n    def divide(self, dividend, divisor):\\n        if divisor == 0:\\n            return self.MAX_INT\\n        if dividend == 0:\\n            return 0\\n        negative = (dividend > 0) ^ (divisor > 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        ans = 0\\n        while dividend >= divisor:\\n            x = divisor\\n            i = 1\\n            while dividend >= x + x:\\n                x += x\\n                i += i\\n            dividend -= x\\n            ans += i\\n        ans = self.MAX_INT if not negative and ans > self.MAX_INT else ans\\n        return -ans if negative else ans\\n\\n\\n    # 988 / 988 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 85.93%",
                "codeTag": "Python3"
            },
            {
                "id": 13605,
                "title": "15-ms-c-solution-with-explaination",
                "content": "    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            // for cases where dividend or divisor is INT_MIN, \\n            // by using a higher type, we take the whole number\\n            // else abs cannot work since its based on 2's complement\\n            // and 2's complement of n bit number is undefined if its \\n            // the min number. try taking out the 2's complement of \\n            // -8 for a 4 bit number, behaviour is undefined \\n            long a = labs(dividend);\\n            long b = labs(divisor);\\n            long sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;\\n            // overflow cases : denominator == 0 or dividing by a number makes the number \\n            // greater than INT_MAX\\n            if (b == 0 || dividend == INT_MIN && divisor == -1) {\\n                return INT_MAX;\\n            } else if (b == 1) {\\n                 return sign * a;\\n             }\\n            \\n            \\n            long result = 0;\\n            int i = 0;\\n            while(a >= b) {\\n                i = 0;\\n                while(a >= b<<i) {\\n                    a -= b<<i;\\n                    result += 1<<i;\\n                    i++;\\n                }\\n            }\\n            return (sign * result);\\n        }\\n    \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            // for cases where dividend or divisor is INT_MIN, \\n            // by using a higher type, we take the whole number\\n            // else abs cannot work since its based on 2's complement\\n            // and 2's complement of n bit number is undefined if its \\n            // the min number. try taking out the 2's complement of \\n            // -8 for a 4 bit number, behaviour is undefined \\n            long a = labs(dividend);\\n            long b = labs(divisor);\\n            long sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;\\n            // overflow cases : denominator == 0 or dividing by a number makes the number \\n            // greater than INT_MAX\\n            if (b == 0 || dividend == INT_MIN && divisor == -1) {\\n                return INT_MAX;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13631,
                "title": "difference-between-int-and-long",
                "content": "this may be so silly question, but I do not get it :\\nI found this solutions for the problem works ,\\nbut when I do not use long, it will get error, run out of time.\\nDo anyone can explain to me why. thanks a lot\\n\\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean signA = dividend >= 0, signB = divisor > 0;\\n    \\n        long num = Math.abs((long) dividend), div = Math.abs((long) divisor), res = 0, curr = 0;\\n    // using Long division\\n        for (int idx = 31; idx >= 0; idx--) {\\n            curr <<= 1;\\n            curr |= ((num >> idx) & 1);\\n    \\n            res = res << 1;\\n            if (curr >= div) {\\n                curr -= div;\\n                res |= 1;\\n            }\\n        }\\n    \\n        if (signA ^ signB)\\n            return -(int) res;\\n        return (int) res;\\n    }\\n    }",
                "solutionTags": [],
                "code": "this may be so silly question, but I do not get it :\\nI found this solutions for the problem works ,\\nbut when I do not use long, it will get error, run out of time.\\nDo anyone can explain to me why. thanks a lot\\n\\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean signA = dividend >= 0, signB = divisor > 0;\\n    \\n        long num = Math.abs((long) dividend), div = Math.abs((long) divisor), res = 0, curr = 0;\\n    // using Long division\\n        for (int idx = 31; idx >= 0; idx--) {\\n            curr <<= 1;\\n            curr |= ((num >> idx) & 1);\\n    \\n            res = res << 1;\\n            if (curr >= div) {\\n                curr -= div;\\n                res |= 1;\\n            }\\n        }\\n    \\n        if (signA ^ signB)\\n            return -(int) res;\\n        return (int) res;\\n    }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3795128,
                "title": "c-follow-the-rules-only-use-int-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFollow the rules, only use int + - & << operations\\n\\nIt handles edge cases like division by INT_MIN and potential overflows. The main algorithm involves repeated subtractions of B from A to calculate the quotient, accounting for signs and avoiding integer overflow. The dividend A is taken to be non-postive for the reason when A=INT_MIN, the number -INT_MAX=2^31 is not  32-bit unsigned int.\\n\\nThe implementation for integer division utilizes bit manipulation techniques. It handles edge cases and performs division using bit shifts, which is more efficient than repeated subtractions. Bit manipulation helps in efficiently doubling the divisor and finding the quotient by checking bit positions in the operands.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry these test cases\\n```\\n-2147483648\\n2147483647\\n2147483647\\n2147483647\\n1981445587\\n1172010393\\n1100540749\\n-1090366779\\n-2147483648\\n2\\n-2147483648\\n1\\n2147483647\\n2\\n```\\n![division.png](https://assets.leetcode.com/users/images/5398d3ee-d05a-4f89-b84b-528c66ef1905_1689916104.5670538.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N), where N is the absolute value of the dividend A\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code with Runtime 0 ms Beats 100%\\n```\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        //Consider the edge case INT_MIN=-2^31 whose change sign is not INT\\n        if (A==INT_MIN && B==-1) \\n            return INT_MAX;\\n        if (A==INT_MIN && B==1)\\n            return INT_MIN;\\n        if (B==INT_MIN && A!=INT_MIN) return 0;\\n\\n        //Edge cases can lead to TLE\\n        if (A==B) return 1;\\n        if ( (0<=A && A<B)||(A<0 && B<A)) return 0;\\n\\n        int ch_sgn=0;\\n        if (A>0){//A!=INT_MIN\\n            A=-A;\\n            ch_sgn++;\\n        }\\n        if (B<0){//quarantee B!=INT_MIN\\n            B=-B;\\n            ch_sgn++;\\n        }\\n        int sgn=(ch_sgn&1)?1:-1;\\n        int q=0;\\n        while(-B>=A){//TLE can happen when -A/B is large if only performing A+=B\\n            int b=B;\\n            int k=0;//Performing A+=b where b=B*(2^k)<=INT_MAX\\n            while(A<=-b && b<=INT_MAX){\\n                A+=b;\\n                q+=(1<<k);\\n                if (b<(1<<30)){\\n                    b<<=1;\\n                    k++;\\n                } \\n            } \\n        }\\n        return (sgn==1)?q:-q;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n-2147483648\\n2147483647\\n2147483647\\n2147483647\\n1981445587\\n1172010393\\n1100540749\\n-1090366779\\n-2147483648\\n2\\n-2147483648\\n1\\n2147483647\\n2\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        //Consider the edge case INT_MIN=-2^31 whose change sign is not INT\\n        if (A==INT_MIN && B==-1) \\n            return INT_MAX;\\n        if (A==INT_MIN && B==1)\\n            return INT_MIN;\\n        if (B==INT_MIN && A!=INT_MIN) return 0;\\n\\n        //Edge cases can lead to TLE\\n        if (A==B) return 1;\\n        if ( (0<=A && A<B)||(A<0 && B<A)) return 0;\\n\\n        int ch_sgn=0;\\n        if (A>0){//A!=INT_MIN\\n            A=-A;\\n            ch_sgn++;\\n        }\\n        if (B<0){//quarantee B!=INT_MIN\\n            B=-B;\\n            ch_sgn++;\\n        }\\n        int sgn=(ch_sgn&1)?1:-1;\\n        int q=0;\\n        while(-B>=A){//TLE can happen when -A/B is large if only performing A+=B\\n            int b=B;\\n            int k=0;//Performing A+=b where b=B*(2^k)<=INT_MAX\\n            while(A<=-b && b<=INT_MAX){\\n                A+=b;\\n                q+=(1<<k);\\n                if (b<(1<<30)){\\n                    b<<=1;\\n                    k++;\\n                } \\n            } \\n        }\\n        return (sgn==1)?q:-q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250771,
                "title": "superb-logic-whithout-operators",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        m,n=abs(dividend),abs(divisor)\\n        answer=0\\n        while (m-n)>=0:\\n            count=0\\n            while (m-(n<<1<<count))>=0:\\n                count+=1\\n            answer+=1<<count\\n            m-=n<<count\\n        if  dividend<0 and divisor<0:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            else:\\n                return answer\\n        elif dividend<0 or divisor<0:\\n            if answer<-2**31:\\n                return -2**31\\n            return -answer\\n        else:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            return answer\\n\\n\\n\\n\\n        \\n        \\n\\n\\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        m,n=abs(dividend),abs(divisor)\\n        answer=0\\n        while (m-n)>=0:\\n            count=0\\n            while (m-(n<<1<<count))>=0:\\n                count+=1\\n            answer+=1<<count\\n            m-=n<<count\\n        if  dividend<0 and divisor<0:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            else:\\n                return answer\\n        elif dividend<0 or divisor<0:\\n            if answer<-2**31:\\n                return -2**31\\n            return -answer\\n        else:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            return answer\\n\\n\\n\\n\\n        \\n        \\n\\n\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705667,
                "title": "easy-java-solution-beats-75",
                "content": "```\\nclass Solution {\\n     public int divide(int dividend, int divisor)\\n {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n             return Integer.MAX_VALUE; \\n\\n        boolean negative = dividend < 0 ^ divisor < 0; \\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n       \\n int quotient = 0, subQuotient = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuotient = 0; dividend - (divisor << subQuotient << 1) >= 0; subQuotient++);\\n            quotient += 1 << subQuotient; \\n            dividend -= divisor << subQuotient; \\n}\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int divide(int dividend, int divisor)\\n {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n             return Integer.MAX_VALUE; \\n\\n        boolean negative = dividend < 0 ^ divisor < 0; \\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n       \\n int quotient = 0, subQuotient = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuotient = 0; dividend - (divisor << subQuotient << 1) >= 0; subQuotient++);\\n            quotient += 1 << subQuotient; \\n            dividend -= divisor << subQuotient; \\n}\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511149,
                "title": "i-think-this-is-a-mistake-check-please",
                "content": "![image](https://assets.leetcode.com/users/images/3ca98b1f-e1dc-4301-8d33-1ed9cc8d7ce4_1661981987.023198.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/3ca98b1f-e1dc-4301-8d33-1ed9cc8d7ce4_1661981987.023198.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2501524,
                "title": "using-substraction-and-addition-only",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        n = 0\\n        md = 1\\n        if (dividend < 0):\\n            md = -md\\n            dividend = abs(dividend)\\n        if (divisor < 0):\\n            md = -md\\n            divisor = abs(divisor)\\n        nn = 1\\n        dvd = dividend\\n        dvr = divisor\\n        sn = 0\\n        while (dvd >= dvr):\\n            nn = 1\\n            dd = dvr\\n            while (dvd >= dd):\\n                sn += nn\\n                dvd -= dd\\n                dd += dd\\n                nn += nn\\n\\n        ans = sn\\n\\n        if (md < 0):\\n            ans = -ans\\n        if (ans > 2 ** 31 - 1):\\n            ans = 2 ** 31 - 1\\n        if (ans < -2 ** 31):\\n            ans = -2 ** 31\\n        return (ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        n = 0\\n        md = 1\\n        if (dividend < 0):\\n            md = -md\\n            dividend = abs(dividend)\\n        if (divisor < 0):\\n            md = -md\\n            divisor = abs(divisor)\\n        nn = 1\\n        dvd = dividend\\n        dvr = divisor\\n        sn = 0\\n        while (dvd >= dvr):\\n            nn = 1\\n            dd = dvr\\n            while (dvd >= dd):\\n                sn += nn\\n                dvd -= dd\\n                dd += dd\\n                nn += nn\\n\\n        ans = sn\\n\\n        if (md < 0):\\n            ans = -ans\\n        if (ans > 2 ** 31 - 1):\\n            ans = 2 ** 31 - 1\\n        if (ans < -2 ** 31):\\n            ans = -2 ** 31\\n        return (ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358872,
                "title": "javascript-solution-bit-manipulation-time-log-n-space-o-1",
                "content": "It\\'s important to understand how we\\'re using base(2) for our integers and that each bit is a power of 2...so for example the first bit is 2 to the power of 0 and the second is 2 to the power 1 and the third is 2 to the power of 2...all the way to 31. Basically you should be comfortable with converting a positive numbers by hand and the basics of negative numbers in binary to understand how we can use bit manipulation to solve this problem \\n\\nWe use that logic to count the number of times our divisor fits into the dividend and since we\\'re shifting the bits to get our answer the time complexity will be O(log(n))\\n\\nBasically here initially we set our count to 1 if the dividend is greater than or equal to the divisor. We check to see if we can shift the bit over by checking to see if the number will still be greater than our dividend. If it is than we shift the bits of the count, dividend and divisor. Probably best to write it down to see how the shifts are shifting to understand how we\\'re using the power of 2 to get our result. We handle negatives by converting the input to a positive number and than adding the sign at the end.\\n```\\n/**\\n * bit manipulation\\n * space O(1) \\n * time O(log n) we\\'re shifting the n bits\\n */\\n var divide = function(n, d) {\\n    if (n === 0 || d === 0) return 0\\n    let isNegative = false;\\n    let result = 0;\\n    if ((d < 0 || n < 0) && !(d < 0 && n < 0)) isNegative = true;\\n    n = Math.abs(n)\\n    d = Math.abs(d)\\n\\n    while (n >= d) {\\n        let count = 1, temp = n, tempd = d\\n        while (tempd <= (temp >> 1)){\\n            count <<= 1\\n            temp >>= 1\\n            tempd <<= 1\\n        }\\n        result += count\\n        n -= tempd\\n    }\\n    if (isNegative) return -result\\n    if (result >= 2**31) {\\n        return 2**31 - 1\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * bit manipulation\\n * space O(1) \\n * time O(log n) we\\'re shifting the n bits\\n */\\n var divide = function(n, d) {\\n    if (n === 0 || d === 0) return 0\\n    let isNegative = false;\\n    let result = 0;\\n    if ((d < 0 || n < 0) && !(d < 0 && n < 0)) isNegative = true;\\n    n = Math.abs(n)\\n    d = Math.abs(d)\\n\\n    while (n >= d) {\\n        let count = 1, temp = n, tempd = d\\n        while (tempd <= (temp >> 1)){\\n            count <<= 1\\n            temp >>= 1\\n            tempd <<= 1\\n        }\\n        result += count\\n        n -= tempd\\n    }\\n    if (isNegative) return -result\\n    if (result >= 2**31) {\\n        return 2**31 - 1\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2305274,
                "title": "easy-and-very-neat-code-bit-manipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n\\t  // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(a == INT_MIN and b == -1) \\n            return INT_MAX;\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long num = labs(a), div = labs(b);\\n\\t\\t// our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n      \\tlong ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n        // while div is less/equal to num do the following:\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```\\n**If you like the code then please upvote it. This will motivate me to post more codes with full explanation.**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n\\t  // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(a == INT_MIN and b == -1) \\n            return INT_MAX;\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long num = labs(a), div = labs(b);\\n\\t\\t// our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n      \\tlong ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n        // while div is less/equal to num do the following:\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090734,
                "title": "c-solution-0-ms-three-approaches-bit-manipulation",
                "content": "__Thanks for checking out my solution\\nMake sureyou upvote if it helped you :)__\\n\\n__Method 1:\\nTime Complexity : O(Dividend / Divisor) \\nNaive Method to get the solution, \\nGives TLE therefore it has to be optimised__\\n\\n```\\nclass Solution\\n{ // There is Reason why this questioh has so low accuracy\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        int sgn = ((dividend < 0) ^ (divisor < 0));\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;\\n        if (dv == 1)\\n            ans = d;\\n        else\\n            while (d >= dv)        //Exhaustive subtraction\\n            {\\n                ++ans;\\n                d -= dv;\\n            }\\n        if (sgn == 1)\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n__Now the task is to optimise the time-complexity, using bit-manipulation__\\n\\n>__The idea here is to understand that any number can be represented\\nas sum of powers of 2__\\n>>__Check for the sign of the quotient\\nint sign = (divisor < 0) ^ (divendend < 0);\\n//if only one of them is negative, sign = 1, else 0__\\n\\n>>__Pseudo Code\\nfor i = 31 to i = 0,  since the question assumes that the number is 32 bit__\\n>>>  __So check till (divisor << i)  <= dividend,    \\n>>>   i.e.  [ divisor * (2 ^ i) ]    <=  dividend \\n>>>   if true, add the power of 2 to the answer, and substract (divisor << i) from dividend\\n>>>   ans += 1 << i, i.e ans = ans + 2^i (power of 2)\\n>>>   dividend -= divisor << i__\\n\\n>>__if sign = 1\\nans = -ans;           //the quotient will be negative__\\n\\n>>__Now that we have to give the answer in the required constraints\\nif ans > INT_MAX ( 2^31 -1), return INT_MAX, min(ans, INT_MAX )\\nif ans < INT_MIN (-2^31), return INT_MIN, max(INT_MIN, ans )__\\n\\n\\n__Below is the coding implementation\\nMethod 2:\\nTime Complexity : O(31) ~ O(1)__\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);    //Speed Game\\n        cin.tie(0);\\n        int sgn = (dividend < 0) ^ (divisor < 0);     //Get the sign of the quotient \\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;   //Since left shift works only on positives, take absolute value\\n        for (int i = 31; i >= 0; i--)             //Explore all the 32 bits\\n            if (dv << i <= d)                     //If divisor * 2^i   <= dividend\\n            {\\n                ans += 1LL << i;                  //1LL prevents 2^31, to be treated as negative\\n                d -= dv << i;                      //Reduce the dividend\\n            }\\n        if (sgn == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n__Variation of the above given solution\\nThis time instead of taking the dividend to 0\\nWe take the divisor to the dividend\\nMethod 3:\\nTime Complexity : O(31) ~ O(1)__\\n```\\n// Same method but with addition with no subtraction\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        int sign = ((dividend < 0) ^ (divisor < 0));   //If only one of them is true, the quotient will be negative, i.e. sign = 1\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0, temp = 0;\\n        for (int i = 31; i >= 0; --i)\\n            if (temp + (d << i) <= dd)\\n            {\\n                temp += d << i;             //Taking the temp as close as to the dividend\\n                ans |= 1LL << i;\\n            }\\n        if (sign == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{ // There is Reason why this questioh has so low accuracy\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        int sgn = ((dividend < 0) ^ (divisor < 0));\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;\\n        if (dv == 1)\\n            ans = d;\\n        else\\n            while (d >= dv)        //Exhaustive subtraction\\n            {\\n                ++ans;\\n                d -= dv;\\n            }\\n        if (sgn == 1)\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);    //Speed Game\\n        cin.tie(0);\\n        int sgn = (dividend < 0) ^ (divisor < 0);     //Get the sign of the quotient \\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;   //Since left shift works only on positives, take absolute value\\n        for (int i = 31; i >= 0; i--)             //Explore all the 32 bits\\n            if (dv << i <= d)                     //If divisor * 2^i   <= dividend\\n            {\\n                ans += 1LL << i;                  //1LL prevents 2^31, to be treated as negative\\n                d -= dv << i;                      //Reduce the dividend\\n            }\\n        if (sgn == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\n```\\n// Same method but with addition with no subtraction\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        int sign = ((dividend < 0) ^ (divisor < 0));   //If only one of them is true, the quotient will be negative, i.e. sign = 1\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0, temp = 0;\\n        for (int i = 31; i >= 0; --i)\\n            if (temp + (d << i) <= dd)\\n            {\\n                temp += d << i;             //Taking the temp as close as to the dividend\\n                ans |= 1LL << i;\\n            }\\n        if (sign == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090591,
                "title": "rust-negative-division-i32-only",
                "content": "Since we are permitted to operate within the range of `i32` only, avoiding overflow with `i64` or `u32` should be considered illegal.\\n\\nThe problem is trivial when the dividend and the divisor are both positive. So it\\'s tempting for us to use `i32::abs()` to convert them into positive numbers and negate the result if necessary. But in this approach `i32::MIN.abs()` becomes a grave problem. According to the doc, it either panics or returns `i32::MIN` itself, which isn\\'t what we expect. So let\\'s do it the opposite way: convert both operands into their *negative* absolute values. \\n\\n```\\nimpl Solution {\\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\\n\\n        let is_neg = (dividend < 0) ^ (divisor < 0);\\n\\t\\t\\n        let mut p = if dividend > 0 { -dividend } else { dividend };\\n        let q = if divisor > 0 { -divisor } else { divisor };\\n\\n        // res is the *negative* absolute value of the quotient, in case the quotient is i32::MIN.\\n        let mut res = 0;\\n\\t\\t\\n\\t\\t// Here is the magic: the negative divisor(aka q) can left-shift atmost q.leading_ones() - 1 bits before it overflows.\\n        for shift in (0..q.leading_ones()).rev() {\\n\\t\\t\\t// Don\\'t apply \"p -= (q << shift)\" before overflow checking. Consider p = 0, q << shift = i32::MIN.\\n            if (p <= (q << shift)) {\\n                p -= q << shift;\\n                res += -1 << shift; // Not \"res -= 1 << shift;\" which may cause overflow.\\n            }\\n        }\\n        \\n        if is_neg {\\n            res\\n        } else if res == i32::MIN {\\n            i32::MAX\\n        } else {\\n            -res\\n        }\\n\\t\\t\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\\n\\n        let is_neg = (dividend < 0) ^ (divisor < 0);\\n\\t\\t\\n        let mut p = if dividend > 0 { -dividend } else { dividend };\\n        let q = if divisor > 0 { -divisor } else { divisor };\\n\\n        // res is the *negative* absolute value of the quotient, in case the quotient is i32::MIN.\\n        let mut res = 0;\\n\\t\\t\\n\\t\\t// Here is the magic: the negative divisor(aka q) can left-shift atmost q.leading_ones() - 1 bits before it overflows.\\n        for shift in (0..q.leading_ones()).rev() {\\n\\t\\t\\t// Don\\'t apply \"p -= (q << shift)\" before overflow checking. Consider p = 0, q << shift = i32::MIN.\\n            if (p <= (q << shift)) {\\n                p -= q << shift;\\n                res += -1 << shift; // Not \"res -= 1 << shift;\" which may cause overflow.\\n            }\\n        }\\n        \\n        if is_neg {\\n            res\\n        } else if res == i32::MIN {\\n            i32::MAX\\n        } else {\\n            -res\\n        }\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090009,
                "title": "c-bit-manipulation-easy-to-understand-with-example",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1)\\n            return INT_MAX;\\n     \\n        long long ans = 0;\\n        int s = 1;\\n        if(dividend<0 && divisor<0)\\n        s = 1;\\n        else if(divisor<0 || dividend<0)\\n        s = -1;\\n        long long dnd = abs((long)dividend),dsr = abs((long)divisor);\\n        while(dnd>=dsr)\\n        {\\n            long long temp = dsr, m = 1;\\n            while(temp<<1 <= dnd)\\n            {\\n                temp = temp<<1;\\n                m = m<<1;\\n                \\n            }\\n            dnd -= temp;\\n            ans += m;\\n        }\\n        return ans*s;\\n    }\\n};\\n```\\n\\n```\\n/*\\na = 15 , b  = 3;\\nwhile 15>=3 (outer while loop)\\n{\\ntemp = 3, m = 1;\\nif 3<<1 which is 6 <= 15\\nso, 3<<1 => temp = 6, m = m<<1 => 2;\\nif 6<<1 => 12<=15\\nso, 6<<1 => temp = 12 , m = 2<<1 => 4;\\nif(12<<1 => 24 <= 15) wrong \\nout of while loop ,\\nnow temp = 12, m = 4 => ans += 4 => 4;\\nsubtract 15-12 = 3;  \\n}  again\\nwhile 3>=3 (outer while loop)\\n{\\nso temp = 3, m = 1;\\nin inner while loop 3<<1 => 6 <= 3 (wrong) \\nso dnd = 3-3 = 0;\\nans += m => ans += 1 => ans = 5;\\n\\n}\\n(0>=3) (outer while loop ) (wrong)\\nso our ans is 5;\\n*/\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1)\\n            return INT_MAX;\\n     \\n        long long ans = 0;\\n        int s = 1;\\n        if(dividend<0 && divisor<0)\\n        s = 1;\\n        else if(divisor<0 || dividend<0)\\n        s = -1;\\n        long long dnd = abs((long)dividend),dsr = abs((long)divisor);\\n        while(dnd>=dsr)\\n        {\\n            long long temp = dsr, m = 1;\\n            while(temp<<1 <= dnd)\\n            {\\n                temp = temp<<1;\\n                m = m<<1;\\n                \\n            }\\n            dnd -= temp;\\n            ans += m;\\n        }\\n        return ans*s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089488,
                "title": "division-using-the-left-shift-operator-python3",
                "content": "# --> Division using the left shift operator\\n**The Bitwise left shift operator:-**\\nWe know that the binary number system is based on powers of 2. So, positional weight of each of the following bits is twice the previous bit i.e. its power is increased by 1. As a result, when we push a number towards the left by 1 bit the whole number gets multiplied by 2 power 1. Similarly when a number is pushed to the left by n bits means the number is multiplied by 2 power n.\\n\\nThus in general if you shift a number to left by n bits, it gets multiplied n times by 2.\\n\\n**Steps:**\\n1. Initially, set the quotient to 0.\\n2. Check if any one of the numbers is negative and store it in a separate variable.\\n3. Make both the numbers positive.\\n4. Start from n = 31 the most significant bit and loop till n = 0 the least significant bit.\\n\\t* \\tCheck if shifting the divisor by n bits is less than or equal to the dividend\\n\\t   a) if so subtract it from the dividend and update the dividend\\n\\t   b) Add 2 power n to the answer\\n\\t   ( Note: Here the dividend is reduced to the reminder each time the condition is true. )\\n5. And finally, return the quotient after checking if it should be positive or negative with the result from step 2.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend < 0 or divisor < 0:\\n\\t\\t\\t #Setting Negative Flag To true if any of the number is negative.\\n            Negative_Flag = True\\n        else:\\n            Negative_Flag = False\\n        \\n        quotient  = 0 #Initializing Quotient\\n\\t\\t\\n\\t\\t#Making negative number positive\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n\\t\\t\\n\\t\\t#Calculating Max and Min Limit\\n        maxLimit = (2**31)-1\\n        minLimit = -(2**31)\\n\\n        for i in range(31, -1, -1):\\n            if (divisor << i) <= dividend: # checking if divisor multiplied by 2**i is <= dividend\\n                dividend -= (divisor << i) #subtracting divisor << i from dividend\\n                quotient += 1 << i # adding 2 power i to the quotient\\n\\n\\t\\t # and finally checking if the output should be negative\\n        if Negative_Flag:\\n            quotient = -abs(quotient)\\n\\n        if quotient >= maxLimit:\\n            return maxLimit\\n        elif quotient <= minLimit:\\n            return minLimit\\n        else:\\n            return quotient\\n\\n```\\n*The time complexity of this algorithm is going to be O(log a), where a is the dividend.*\\n*The space complexity of this algorithm is O(1).*\\n\\n***Please upvote, if you found it helpful. Thanks..!!***",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend < 0 or divisor < 0:\\n\\t\\t\\t #Setting Negative Flag To true if any of the number is negative.\\n            Negative_Flag = True\\n        else:\\n            Negative_Flag = False\\n        \\n        quotient  = 0 #Initializing Quotient\\n\\t\\t\\n\\t\\t#Making negative number positive\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n\\t\\t\\n\\t\\t#Calculating Max and Min Limit\\n        maxLimit = (2**31)-1\\n        minLimit = -(2**31)\\n\\n        for i in range(31, -1, -1):\\n            if (divisor << i) <= dividend: # checking if divisor multiplied by 2**i is <= dividend\\n                dividend -= (divisor << i) #subtracting divisor << i from dividend\\n                quotient += 1 << i # adding 2 power i to the quotient\\n\\n\\t\\t # and finally checking if the output should be negative\\n        if Negative_Flag:\\n            quotient = -abs(quotient)\\n\\n        if quotient >= maxLimit:\\n            return maxLimit\\n        elif quotient <= minLimit:\\n            return minLimit\\n        else:\\n            return quotient\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774409,
                "title": "go-succinct-intuitive-100-with-explanation",
                "content": "```\\nfunc divide(dividend int, divisor int) int {\\n\\t// single special case that would cause overflow\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor divid >= divis {\\n\\t\\tsub := divis\\n\\t\\tadd := 1\\n\\t\\tfor divid >= sub<<1 {\\n\\t\\t\\tsub <<= 1\\n\\t\\t\\tadd <<= 1\\n\\t\\t}\\n\\t\\tdivid -= sub\\n\\t\\tquotient += add\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\\n\\nFor anyone confused about the bitshifts (`<<`), the idea is that it makes the subtractions and additions faster by multiplying each value by a higher power of 2 with each shift, requiring fewer iterations. This is logically equivalent to this more intuitive code but much faster:\\n\\n```\\nfunc divide_intuitive_but_slow(dividend int, divisor int) int {\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor ; divid >= divis; quotient++ {\\n\\t\\tdivid -= divis\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\\n\\nIn the most extreme case of `2147483647 / 1` (`math.MaxInt32` divided by `1`), the second program would take 2147483647 iterations and the first would only take 465.",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc divide(dividend int, divisor int) int {\\n\\t// single special case that would cause overflow\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor divid >= divis {\\n\\t\\tsub := divis\\n\\t\\tadd := 1\\n\\t\\tfor divid >= sub<<1 {\\n\\t\\t\\tsub <<= 1\\n\\t\\t\\tadd <<= 1\\n\\t\\t}\\n\\t\\tdivid -= sub\\n\\t\\tquotient += add\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\n```\\nfunc divide_intuitive_but_slow(dividend int, divisor int) int {\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor ; divid >= divis; quotient++ {\\n\\t\\tdivid -= divis\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579861,
                "title": "java-no-longs-simple-solution-that-someone-could-actually-come-up-with",
                "content": "\\nThis post basically steals ideas from the following,\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13417/No-Use-of-Long-Java-Solution\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13397/Clean-Java-solution-with-some-comment.\\n\\ncombining the clean solution to use only integers, and stealing some of the logic from the first, please take a look at both if you are confused.\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        boolean neg = false;\\n        if(dividend < 0) neg = !neg;\\n        if(divisor < 0) neg = !neg;\\n        \\n        int res = 0;\\n        \\n        if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\n        return neg ? -res : res;\\n        \\n    }\\n    \\n    private int divideR(int dividend, int divisor){\\n        \\n        \\n        if(divisor < dividend || dividend == 0) return 0;\\n        \\n        int sum = divisor;\\n        int mult = 1;\\n        \\n        while((sum + sum) < sum && (sum + sum) >= dividend){\\n            sum += sum;\\n            mult += mult;\\n        }\\n        \\n        return mult + divideR(dividend - sum, divisor);\\n    }\\n   \\n}\\n\\n```\\nI created this solution because I really did not enjoy any of the popular solutions posted here, my goals were to make it actually read-able and using the logic some of the better solutions had using longs, but supporting integers as well. There\\'s 3 things to really go over with this solution that are confusing.\\n\\n```\\n if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n ```\\n This case has to be checked because it\\'s a edge case, similar to other solutions.\\n \\n ```\\n if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\t\\t\\t\\n```\\n\\nHere we do a big conditional in order to conver the numbers to negative if they aren\\'t, there\\'s probably easier ways to do this. Why do we make our numbers negatives, well because programming sucks and negative numbers have 1 more than positives... so that means we get integer overflow if we try and convert all the negatives to positives. This might still not make sense why we do this, I encourage you to try programming the solution and you will see why it is advantageous to have all the numbers be either positive or negative ( makes defining the actual long division algorithm much more easy ), other solutions that don\\'t do this tend to lead to worse code in my opinion that would be hard to come up with without a lot of debugging...\\n\\n\\n\\n```\\n(sum + sum) < sum\\n```\\n\\nLastly this nice little line of code actually handles all of our overflow! since we are dealing with negatives, if we add two negative numbers and get a value that isn\\'t smaller, something went wrong!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        boolean neg = false;\\n        if(dividend < 0) neg = !neg;\\n        if(divisor < 0) neg = !neg;\\n        \\n        int res = 0;\\n        \\n        if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\n        return neg ? -res : res;\\n        \\n    }\\n    \\n    private int divideR(int dividend, int divisor){\\n        \\n        \\n        if(divisor < dividend || dividend == 0) return 0;\\n        \\n        int sum = divisor;\\n        int mult = 1;\\n        \\n        while((sum + sum) < sum && (sum + sum) >= dividend){\\n            sum += sum;\\n            mult += mult;\\n        }\\n        \\n        return mult + divideR(dividend - sum, divisor);\\n    }\\n   \\n}\\n\\n```\n```\\n if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n ```\n```\\n if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\t\\t\\t\\n```\n```\\n(sum + sum) < sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424021,
                "title": "c-easy-soln-using-bit-manipulation-in-o-logn-2",
                "content": "```\\n  int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        \\n        long a = abs(dividend);\\n        long b = abs(divisor);\\n        long res=0;\\n        while(a-b>=0){\\n            int x=0;\\n            while(a-(b<<x<<1)>=0){\\n                x++;\\n            }\\n            res+= 1<<x;\\n            a-= b<<x;\\n        }\\n        return (dividend>=0)==(divisor>=0)? res: (-res);\\n    }",
                "solutionTags": [],
                "code": "```\\n  int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        \\n        long a = abs(dividend);\\n        long b = abs(divisor);\\n        long res=0;\\n        while(a-b>=0){\\n            int x=0;\\n            while(a-(b<<x<<1)>=0){\\n                x++;\\n            }\\n            res+= 1<<x;\\n            a-= b<<x;\\n        }\\n        return (dividend>=0)==(divisor>=0)? res: (-res);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1085593,
                "title": "c-bitwise-solution-explained-100-time-85-space",
                "content": "I started to think about this problem with the same approach [I used for the power problem](https://leetcode.com/problems/powx-n/discuss/739646/): considering a number (`dividend`) as a sum of another (`divisor`) multiplied by 2 and this would have allowed me to know the quotient.\\n\\nFor example, assume that `dividend` is `60` and `divisors` is `3`: I can see `60 == 12 + 48` or, in a more explicit form (with `**` implying the power operation):\\n`60 == 3 * 2 ** 4 + 3 * 2 ** 2` and again: `60 == 1 * 3 * 2 ** 4 + 0 * 3 * 2 ** 3 + 1 * 3 * 2 ** 2 + 0 * 3 * 2 ** 1 + 0 * 3 * 2 ** 0`.\\n\\nIf I extract the first multiplying factors (`1` and `0`) and align them, I would get `10100`, which is indeed the binary representation of `20`, my goal!\\n\\nNow, to generalise this approach, we first of all need a few variables:\\n* `bits` is our counter variable that we will use in a bit (no pun intended) to know how many times we need to multiply our `divisor` by `2` to get a result, with initial value of `1`  (since down below we will increase the divisor by one extra step with my approach);\\n* `res` is our usual accumulator variable and it is going to be a `long`, same as `d1` and `d2`, to avoid annoyng overflows/edge cases;\\n* `isMinus` is a boolean to remind us what the sign of the final result should be, initially set to `false`.\\n\\nWe will then proceed making sure both `d1` and `d2` have the same sign (positive, for simplicity), flipping `isMinus` if we have to flip their sign.\\n\\nNow, in order to proceed with our logic discussed above, we will need a `d2` which is just bigger than `d1` and to keep track of how many times we need to multiply it by `2` - I know you could achieve the same with logarithms, but this is cheaper since we just stop with the last integer and on top of that we are also growing `d2` just as needed.\\n\\nAnd since after the previous loop we are going to know how many bits will make our result, time to go for a main loop `bits` time and:\\n* set `res` to double its previous value, plus `1` if `d1 >= d2` (meaning we can subtract it and it will make a bit in our final result);\\n* if the above condition is `true`, we will also have to decrease `d1` accordingly, subtracting `d2` to it;\\n* finally, time to reduce `d2` by one bit.\\n\\nA bit of (painfully annoying) extra logic to handle the edge cases and we can finally return `res` or `-res`, depending from `isMinus` :)\\n\\nOne more time, let\\'s assume we are dividing `70` by `3`, so we will have at the beginning of the main loop:\\n\\n```cpp\\n70 // d1\\n96 // d2\\n6 // bits\\n0 // res\\n```\\n\\nFirst iteration, since `70 > 96`, we proceed changing little, other than `d2` and of course decreasing `bits`:\\n\\n```cpp\\n70 // d1\\n48 // d2\\n5 // bits\\n0 // res\\n```\\n\\nOkay, now we can subtract, so we have:\\n\\n```cpp\\n22 // d1\\n24 // d2\\n4 // bits\\n1 // res\\n```\\n\\nAgain our condition `d1 >= d2` is `false`, so we just update `d2`, `bits` and this time also `res` increases (in the first step it was the same, given its initial value of `0`):\\n\\n```cpp\\n22 // d1\\n12 // d2\\n3 // bits\\n2 // res\\n```\\n\\nSince `22 >= 12`, we proceed like this:\\n\\n```cpp\\n10 // d1\\n6 // d2\\n2 // bits\\n5 // res\\n```\\n\\nAnd again, since `10 >= 4`:\\n\\n```cpp\\n4 // d1\\n3 // d2\\n1 // bits\\n11 // res\\n```\\n\\nAnd finally, since `4 >= 3`:\\n\\n```cpp\\n1 // d1\\n1 // d2\\n0 // bits\\n23 // res\\n```\\n\\nAnd at this point we can exit with the right result (and note that `d1` would also be our remainder).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        // support variables\\n        int bits = 1;\\n        long d1 = dividend, d2 = divisor, res = 0;\\n        bool isMinus = false;\\n        // setting the sign\\n        if (d1 < 0) isMinus = !isMinus, d1 = -d1;\\n        if (d2 < 0) isMinus = !isMinus, d2 = -d2;\\n        // adjusting d2\\n        while (d2 <= d1) d2 <<= 1, bits++;\\n        // composing res\\n        while (bits--) {\\n            res = res * 2 + (d1 >= d2);\\n            if (d1 >= d2) d1 -= d2;\\n            d2 >>= 1;\\n        }\\n        // handling overflows\\n        if (res > 2147483647l + isMinus) res = 2147483647;\\n        return isMinus ? -res : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n70 // d1\\n96 // d2\\n6 // bits\\n0 // res\\n```\n```cpp\\n70 // d1\\n48 // d2\\n5 // bits\\n0 // res\\n```\n```cpp\\n22 // d1\\n24 // d2\\n4 // bits\\n1 // res\\n```\n```cpp\\n22 // d1\\n12 // d2\\n3 // bits\\n2 // res\\n```\n```cpp\\n10 // d1\\n6 // d2\\n2 // bits\\n5 // res\\n```\n```cpp\\n4 // d1\\n3 // d2\\n1 // bits\\n11 // res\\n```\n```cpp\\n1 // d1\\n1 // d2\\n0 // bits\\n23 // res\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        // support variables\\n        int bits = 1;\\n        long d1 = dividend, d2 = divisor, res = 0;\\n        bool isMinus = false;\\n        // setting the sign\\n        if (d1 < 0) isMinus = !isMinus, d1 = -d1;\\n        if (d2 < 0) isMinus = !isMinus, d2 = -d2;\\n        // adjusting d2\\n        while (d2 <= d1) d2 <<= 1, bits++;\\n        // composing res\\n        while (bits--) {\\n            res = res * 2 + (d1 >= d2);\\n            if (d1 >= d2) d1 -= d2;\\n            d2 >>= 1;\\n        }\\n        // handling overflows\\n        if (res > 2147483647l + isMinus) res = 2147483647;\\n        return isMinus ? -res : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085349,
                "title": "rust-0ms-solution-using-32-bit-signed-integers-only",
                "content": "Question tells us to assume we are using an environment that only has up to 32-bit signed integers available, so let\\'s only use `i32`s for our computation.\\nAlso, we\\'re not allowed to use the `*`, `/ ` or `%` operators, obviously.\\n\\nTo achieve logarithmic runtime, we want to split the `dividend` into components of `divisor * (2^x)`, where `x` is a natural number (possibly including 0).\\nThe result of the division will be the sum of the `2^x` terms in our split components.\\n_For example, if we wish to divide 99 by 3: `99 == 3*(2^5) + 3*(2^0)`; therefore the answer is `2^5 + 2^0 == 32 + 1 == 33`._\\n\\nThe `2^x` terms are convenient, as we can use bitwise shifts to multiply and divide the `dividend` by powers of 2, due to binary being a base-2 number system.\\nIn many cases, we won\\'t be able to split `dividend` exactly, as there\\'ll be a remainder; in those cases we\\'ll want to get as close as possible such that the sum of our components doesn\\'t surpass `dividend`.\\n\\nTo avoid issues regarding overflow, we make our `dividend` and `divisor` negative, and use the negative signed integer range for our computation.\\nThe reason for this is that the negative integer range is always 1 greater than the positive range (excluding 0), which makes overflow checking a bit nicer (also avoids the temptation of cheesing the problem using `u32`s or `i64`s or similiar, **which is _very_ naughty**).\\n\\n```\\nimpl Solution {\\n    pub fn divide(mut dividend: i32, mut divisor: i32) -> i32 {\\n        assert!(divisor != 0);\\n\\n        let is_ans_neg = (dividend < 0) ^ (divisor < 0);\\n        dividend = -dividend.abs();\\n        divisor = -divisor.abs();\\n\\n        let (mut neg_ans, mut curr_div, mut curr_mul) = (0, divisor, -1);\\n        while curr_div <= divisor {\\n            if curr_div < dividend {\\n                curr_div = if curr_div == -1 { 0 } else { curr_div >> 1 };\\n                curr_mul = if curr_mul == -1 { 0 } else { curr_mul >> 1 };\\n            } else {\\n                neg_ans += curr_mul;\\n                dividend -= curr_div;\\n                curr_div <<= 1;\\n                curr_mul <<= 1;\\n            }\\n        }\\n\\n        match neg_ans {\\n            std::i32::MIN if !is_ans_neg => std::i32::MAX,\\n            _ if is_ans_neg => neg_ans,\\n            _ => -neg_ans,\\n        }\\n    }\\n}\\n```\\n\\nAlso, seeing that integers are stored as 2s complement, you may instead prefer to use `~variable + 1` to negate signs, rather than `-variable`. Do whatever suits you. :)\\n\\nTime complexity: `O(~log32) == O(1)` due to the constraints on the inputs.\\nExtra-space complexity: `O(1)`.",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn divide(mut dividend: i32, mut divisor: i32) -> i32 {\\n        assert!(divisor != 0);\\n\\n        let is_ans_neg = (dividend < 0) ^ (divisor < 0);\\n        dividend = -dividend.abs();\\n        divisor = -divisor.abs();\\n\\n        let (mut neg_ans, mut curr_div, mut curr_mul) = (0, divisor, -1);\\n        while curr_div <= divisor {\\n            if curr_div < dividend {\\n                curr_div = if curr_div == -1 { 0 } else { curr_div >> 1 };\\n                curr_mul = if curr_mul == -1 { 0 } else { curr_mul >> 1 };\\n            } else {\\n                neg_ans += curr_mul;\\n                dividend -= curr_div;\\n                curr_div <<= 1;\\n                curr_mul <<= 1;\\n            }\\n        }\\n\\n        match neg_ans {\\n            std::i32::MIN if !is_ans_neg => std::i32::MAX,\\n            _ if is_ans_neg => neg_ans,\\n            _ => -neg_ans,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976341,
                "title": "java-1ms-100-faster-bit-manipulation-with-comments",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n    \\n        \\n        if(dividend==Integer.MIN_VALUE&&divisor==-1) \\n            return Integer.MAX_VALUE;\\n        \\n        boolean isNegative=false;\\n        if(dividend<0||divisor<0){\\n            isNegative = true;\\n        }\\n        // if both are -ve it will be cancelled out\\n         if(dividend<0&&divisor<0){\\n            isNegative = false;\\n        }\\n        \\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int result=0;\\n        // 10-3>=0\\n        while(a-b>=0){\\n            int x = 0; //  its like 2^0=1 , at the end u will get to know\\n            \\n            //checking further we can able to subtract divisor(3)\\n            //10 - (3<<1<<0)\\n            //10 - (6) >=0\\n            while(a-(b<<1<<x)>=0){\\n                x++;\\n            }\\n            // after 1st iteration x = 1\\n            // 0 = 0 + (1<<1)\\n            // 0 = 0 + 2\\n            result +=1<<x;\\n            \\n            \\n            //10 =10 - (3<<1)\\n            //10 =10 - (6)\\n            a =  a-(b<<x);//  a = 4\\n\\t\\t\\t//again while loop continue.....\\n            \\n        }\\n        \\n        return isNegative?-result:result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n    \\n        \\n        if(dividend==Integer.MIN_VALUE&&divisor==-1) \\n            return Integer.MAX_VALUE;\\n        \\n        boolean isNegative=false;\\n        if(dividend<0||divisor<0){\\n            isNegative = true;\\n        }\\n        // if both are -ve it will be cancelled out\\n         if(dividend<0&&divisor<0){\\n            isNegative = false;\\n        }\\n        \\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int result=0;\\n        // 10-3>=0\\n        while(a-b>=0){\\n            int x = 0; //  its like 2^0=1 , at the end u will get to know\\n            \\n            //checking further we can able to subtract divisor(3)\\n            //10 - (3<<1<<0)\\n            //10 - (6) >=0\\n            while(a-(b<<1<<x)>=0){\\n                x++;\\n            }\\n            // after 1st iteration x = 1\\n            // 0 = 0 + (1<<1)\\n            // 0 = 0 + 2\\n            result +=1<<x;\\n            \\n            \\n            //10 =10 - (3<<1)\\n            //10 =10 - (6)\\n            a =  a-(b<<x);//  a = 4\\n\\t\\t\\t//again while loop continue.....\\n            \\n        }\\n        \\n        return isNegative?-result:result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919712,
                "title": "well-explained-python-solution",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    # division without using divide or multiply\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # repeatedly subtracting divisor n times is too slow, it times out\\n        # ( O(n) where n=dividend/divisor)\\n        # To speed it up we will still subtract divisor but instead of one at a time,\\n        # we will subtract divisor, divisor*2, divisor*4, divisor*8, divisor*16 etc\\n        # O(log n)\\n        \\n        if divisor == 0:\\n            return 2147483647 # error case\\n        positive = (dividend>0) == (divisor>0) # same sign? result will be positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        # first find the largest power of two we need:\\n        power = 1\\n        current_divisor = divisor\\n        current_dividend = dividend\\n        while current_dividend > current_divisor:\\n            current_dividend -= current_divisor\\n            power += power # double to next power of 2\\n            current_divisor += current_divisor # double to next power of 2 * divisor\\n        # divisor is now the largest power of two * divisor smaller than the dividend\\n        # (actually one larger)\\n        \\n        quotient = 0\\n        while power >= 1:\\n            if dividend >= current_divisor: # is this power of two in our dividend?\\n                dividend -= current_divisor # subtract it out\\n                quotient += power # and count it towards our answer\\n            power >>= 1 # half to next lower power of 2\\n            current_divisor >>= 1 # half to next lower power of 2 * divisor\\n            # Using bit shift for divide by 2 isn\\'t cheating. But is it really?\\n        if positive:\\n            if quotient > 2147483647:\\n                return 2147483647\\n            return quotient\\n        else:\\n            if quotient < -2147483648:\\n                return 2147483647\\n            return -quotient\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    # division without using divide or multiply\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # repeatedly subtracting divisor n times is too slow, it times out\\n        # ( O(n) where n=dividend/divisor)\\n        # To speed it up we will still subtract divisor but instead of one at a time,\\n        # we will subtract divisor, divisor*2, divisor*4, divisor*8, divisor*16 etc\\n        # O(log n)\\n        \\n        if divisor == 0:\\n            return 2147483647 # error case\\n        positive = (dividend>0) == (divisor>0) # same sign? result will be positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        # first find the largest power of two we need:\\n        power = 1\\n        current_divisor = divisor\\n        current_dividend = dividend\\n        while current_dividend > current_divisor:\\n            current_dividend -= current_divisor\\n            power += power # double to next power of 2\\n            current_divisor += current_divisor # double to next power of 2 * divisor\\n        # divisor is now the largest power of two * divisor smaller than the dividend\\n        # (actually one larger)\\n        \\n        quotient = 0\\n        while power >= 1:\\n            if dividend >= current_divisor: # is this power of two in our dividend?\\n                dividend -= current_divisor # subtract it out\\n                quotient += power # and count it towards our answer\\n            power >>= 1 # half to next lower power of 2\\n            current_divisor >>= 1 # half to next lower power of 2 * divisor\\n            # Using bit shift for divide by 2 isn\\'t cheating. But is it really?\\n        if positive:\\n            if quotient > 2147483647:\\n                return 2147483647\\n            return quotient\\n        else:\\n            if quotient < -2147483648:\\n                return 2147483647\\n            return -quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840662,
                "title": "very-short-math-pythonic-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        ans = math.exp(math.log(dividend) - math.log(divisor))\\n\\n        return min(2147483647, sign*math.trunc(ans))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        ans = math.exp(math.log(dividend) - math.log(divisor))\\n\\n        return min(2147483647, sign*math.trunc(ans))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752513,
                "title": "solution-using-log-in-c",
                "content": "```\\nint divide(double dividend, double divisor) { \\n\\n        int negFlag = (dividend < 0 ^ divisor < 0) ? 1 : 0;\\n        double logDiv = log(abs(dividend)) - log(abs(divisor));\\n\\t\\t\\n\\t\\t// take antilog to calculate the value \\n        double val = exp(logDiv);\\n        \\n        if(val >= INT_MAX)\\n            return negFlag ? INT_MIN : INT_MAX;\\n    \\n        return negFlag ? -val : val;    \\n    }\\n```\\n\\nWe use the property : log(a/b) = log(a) - log(b)",
                "solutionTags": [],
                "code": "```\\nint divide(double dividend, double divisor) { \\n\\n        int negFlag = (dividend < 0 ^ divisor < 0) ? 1 : 0;\\n        double logDiv = log(abs(dividend)) - log(abs(divisor));\\n\\t\\t\\n\\t\\t// take antilog to calculate the value \\n        double val = exp(logDiv);\\n        \\n        if(val >= INT_MAX)\\n            return negFlag ? INT_MIN : INT_MAX;\\n    \\n        return negFlag ? -val : val;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558335,
                "title": "seems-to-expect-the-wrong-answer-for-js",
                "content": "```\\nInput: \\n\\t-2147483648\\n\\t-1\\nOutput: \\n\\t2147483648\\nExpected: \\n\\t2147483647\\n```\\n\\nThis can\\'t be right, right? Why would it expect this 214748347? It should not be truncating when dividing by zero\\n",
                "solutionTags": [],
                "code": "```\\nInput: \\n\\t-2147483648\\n\\t-1\\nOutput: \\n\\t2147483648\\nExpected: \\n\\t2147483647\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 546970,
                "title": "c-faster-than-99-60-less-than-33-33-mem-o-1",
                "content": "O(1) since the while loops do at most 32 bit shifts combined.\\n\\nRuntime: 32 ms\\nMemory Usage: 14.7 MB\\n\\nLogic Highlights:\\n* If the dividend is int.MinValue, just remove the divisor from it one time to make sure we can convert it to a positive number. This allows us to stick to the int type. \\n* Convert dividend and divisor to positive numbers to simplify logic. \\n* Find out how many bits make up the divisor. Substracting this number from 31 gives us how far we can shift the divisor before it overflows. \\n* Starting with the largest possible multiple of the divisor to the smallest, see if we can remove it from the dividend. \\n\\nThanks to [jonlist](http://https://leetcode.com/problems/divide-two-integers/discuss/475971/C++-bitwise-and-32bit-int.-0ms-less100-8.2MBless72), that solution made me see things in a different way.\\n\\n```\\n    public int Divide(int dividend, int divisor) {\\n        if (divisor == 1) { return dividend; }\\n        if (divisor == -1 &&  dividend == int.MinValue) { return int.MaxValue; }\\n        if (dividend == divisor) { return 1; }\\n        if (dividend == 0 || divisor == int.MinValue) { return 0; }\\n        \\n        bool isNeg = (dividend < 0 && divisor > 0) ||  (dividend > 0 && divisor < 0);\\n        \\n        int count = 0;\\n        if (dividend == int.MinValue)\\n        {\\n            if (divisor < 0) {  dividend -= divisor; } else { dividend += divisor; }\\n            count++;\\n        }\\n        \\n        int dvd = (dividend < 0)? -dividend: dividend;\\n        int dvs = (divisor < 0)? -divisor: divisor;\\n         \\n        int temp = dvs;\\n        int i = 0;\\n        while(temp > 0)\\n        {\\n           i++;\\n           temp>>=1;\\n        }   \\n        \\n        int multi=31-i;\\n        \\n        while (dvd >= dvs)\\n        {   \\n            temp = dvs;\\n            while((temp << multi) > dvd) { multi--; }\\n                 \\n            dvd -= temp << multi;\\n            count += 1 << multi; \\n        }  \\n                  \\n        if (isNeg) { count = -count; }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "O(1) since the while loops do at most 32 bit shifts combined.\\n\\nRuntime: 32 ms\\nMemory Usage: 14.7 MB\\n\\nLogic Highlights:\\n* If the dividend is int.MinValue, just remove the divisor from it one time to make sure we can convert it to a positive number. This allows us to stick to the int type. \\n* Convert dividend and divisor to positive numbers to simplify logic. \\n* Find out how many bits make up the divisor. Substracting this number from 31 gives us how far we can shift the divisor before it overflows. \\n* Starting with the largest possible multiple of the divisor to the smallest, see if we can remove it from the dividend. \\n\\nThanks to [jonlist](http://https://leetcode.com/problems/divide-two-integers/discuss/475971/C++-bitwise-and-32bit-int.-0ms-less100-8.2MBless72), that solution made me see things in a different way.\\n\\n```\\n    public int Divide(int dividend, int divisor) {\\n        if (divisor == 1) { return dividend; }\\n        if (divisor == -1 &&  dividend == int.MinValue) { return int.MaxValue; }\\n        if (dividend == divisor) { return 1; }\\n        if (dividend == 0 || divisor == int.MinValue) { return 0; }\\n        \\n        bool isNeg = (dividend < 0 && divisor > 0) ||  (dividend > 0 && divisor < 0);\\n        \\n        int count = 0;\\n        if (dividend == int.MinValue)\\n        {\\n            if (divisor < 0) {  dividend -= divisor; } else { dividend += divisor; }\\n            count++;\\n        }\\n        \\n        int dvd = (dividend < 0)? -dividend: dividend;\\n        int dvs = (divisor < 0)? -divisor: divisor;\\n         \\n        int temp = dvs;\\n        int i = 0;\\n        while(temp > 0)\\n        {\\n           i++;\\n           temp>>=1;\\n        }   \\n        \\n        int multi=31-i;\\n        \\n        while (dvd >= dvs)\\n        {   \\n            temp = dvs;\\n            while((temp << multi) > dvd) { multi--; }\\n                 \\n            dvd -= temp << multi;\\n            count += 1 << multi; \\n        }  \\n                  \\n        if (isNeg) { count = -count; }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 484686,
                "title": "javascript",
                "content": "Runtime: 3396 ms, faster than 24.62% of JavaScript online submissions for Divide Two Integers.\\nMemory Usage: 36.2 MB, less than 33.33% of JavaScript online submissions for Divide Two Integers.\\n\\n```\\nvar divide = function(dividend, divisor) {\\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\\n      return Math.pow(2, 31) - 1;\\n    }\\n    if (divisor === 1) {\\n      return dividend;\\n    }\\n    let isNegative = false;\\n    if (dividend < 0 && divisor > 0 || (dividend > 0 && divisor < 0)) {\\n      isNegative = true;\\n    }\\n    let newDividend = Math.abs(dividend);\\n    const newDivisor = Math.abs(divisor);\\n    let result = 0;\\n    while(newDividend >= newDivisor) {\\n      newDividend = newDividend - newDivisor;\\n      result++;\\n    }\\n    return isNegative ? -result : result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar divide = function(dividend, divisor) {\\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\\n      return Math.pow(2, 31) - 1;\\n    }\\n    if (divisor === 1) {\\n      return dividend;\\n    }\\n    let isNegative = false;\\n    if (dividend < 0 && divisor > 0 || (dividend > 0 && divisor < 0)) {\\n      isNegative = true;\\n    }\\n    let newDividend = Math.abs(dividend);\\n    const newDivisor = Math.abs(divisor);\\n    let result = 0;\\n    while(newDividend >= newDivisor) {\\n      newDividend = newDividend - newDivisor;\\n      result++;\\n    }\\n    return isNegative ? -result : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 385840,
                "title": "c-0ms-without-using-long-math-h-covert-both-to-negative-to-avoid-coding-for-different-cases",
                "content": "My idea is coverting both dividend and divisor to be negative, to make the code shorter. Here is my code:\\n```\\nint divide(int dividend, int divisor) {\\n        // I will change both dividend and divisor to be negative\\n        \\n        bool sign = true; // true -> result positive; false -> result negative;\\n        if (dividend > 0) {\\n            sign = !sign;\\n            dividend = -dividend;\\n        }\\n        if (divisor > 0){\\n            sign = !sign;\\n            divisor = -divisor;\\n        }\\n        \\n        // now dividend and divisor are both smaller than or equal to 0\\n        int res = 0;\\n        while (dividend <= divisor){\\n            int i = 0;\\n            int x = divisor;\\n            // This while loop finds i \\n            // such that  2^(i+1) * divisor < dividend <= 2^i * divisor\\n            while (true) {\\n                if (x < - (1<<30)) break; // keep x + x in integer range\\n                if (dividend > x + x) break;\\n                x = x + x;\\n                i++;\\n            }\\n            res += 1<<i;\\n            dividend -= x;\\n        }\\n        // res should be larger than 0\\n        // If res == INT_MIN && sign, \\n        // it indicates the result is -INT_MIN, which overflows;\\n        if (res == INT_MIN) return sign?INT_MAX:INT_MIN;\\n        return sign? res:-res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint divide(int dividend, int divisor) {\\n        // I will change both dividend and divisor to be negative\\n        \\n        bool sign = true; // true -> result positive; false -> result negative;\\n        if (dividend > 0) {\\n            sign = !sign;\\n            dividend = -dividend;\\n        }\\n        if (divisor > 0){\\n            sign = !sign;\\n            divisor = -divisor;\\n        }\\n        \\n        // now dividend and divisor are both smaller than or equal to 0\\n        int res = 0;\\n        while (dividend <= divisor){\\n            int i = 0;\\n            int x = divisor;\\n            // This while loop finds i \\n            // such that  2^(i+1) * divisor < dividend <= 2^i * divisor\\n            while (true) {\\n                if (x < - (1<<30)) break; // keep x + x in integer range\\n                if (dividend > x + x) break;\\n                x = x + x;\\n                i++;\\n            }\\n            res += 1<<i;\\n            dividend -= x;\\n        }\\n        // res should be larger than 0\\n        // If res == INT_MIN && sign, \\n        // it indicates the result is -INT_MIN, which overflows;\\n        if (res == INT_MIN) return sign?INT_MAX:INT_MIN;\\n        return sign? res:-res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165649,
                "title": "another-clear-python-code-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        sign = -1 if ((dividend < 0) ^ (divisor < 0)) else 1\\n        \\n        dividend = abs(dividend)\\n        divisor =  abs(divisor)\\n        \\n        if dividend == 0:\\n            return 0 \\n        else:\\n            ans = sign * math.exp(math.log(dividend) - math.log(divisor))\\n            if ans > 0:\\n        \\t    return min(max(-2147483648, math.floor(ans)), 2147483647)\\n            else:\\n                return math.ceil(ans)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        ",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        sign = -1 if ((dividend < 0) ^ (divisor < 0)) else 1\\n        \\n        dividend = abs(dividend)\\n        divisor =  abs(divisor)\\n        \\n        if dividend == 0:\\n            return 0 \\n        else:\\n            ans = sign * math.exp(math.log(dividend) - math.log(divisor))\\n            if ans > 0:\\n        \\t    return min(max(-2147483648, math.floor(ans)), 2147483647)\\n            else:\\n                return math.ceil(ans)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        ",
                "codeTag": "Java"
            },
            {
                "id": 161358,
                "title": "concise-java-solution-without-using-long",
                "content": "To avoid using long, the key point is to represent both dividend and divisor as negative integer, and check the corner case that will cause overflow at the beginning.\\n\\nThen use a while loop and addition to calculate the quotients.\\n\\n\\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int flag = 1;\\n        if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n            flag = -1;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        int result = 0;\\n        while(dividend <= divisor){\\n            int count = 1, tempDivisor = divisor;\\n            while(dividend - tempDivisor <= tempDivisor){\\n                count <<= 1;\\n                tempDivisor <<= 1;\\n            }\\n            result += count;\\n            dividend -= tempDivisor;\\n        }\\n        return flag * result;\\n    }\\n}\\n```\\n**UPDATE**\\nThanks to @yuhangjiang for pointing out the use of * at the return statement. Please see the updated version, to completely avoid using *, I used bit operations instead to get the negative result.\\n\\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        boolean neg = dividend > 0 && divisor < 0 || dividend < 0 && divisor > 0;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        int res = 0;\\n        while(divisor >= dividend){\\n            int count = 1;\\n            int newDivisor = divisor;\\n            while(newDivisor >= dividend - newDivisor){\\n                newDivisor <<= 1;\\n                count <<= 1;\\n            }\\n            dividend -= newDivisor;\\n            res += count;\\n        }\\n        if(neg)\\n            res = ~res + 1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int flag = 1;\\n        if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n            flag = -1;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        int result = 0;\\n        while(dividend <= divisor){\\n            int count = 1, tempDivisor = divisor;\\n            while(dividend - tempDivisor <= tempDivisor){\\n                count <<= 1;\\n                tempDivisor <<= 1;\\n            }\\n            result += count;\\n            dividend -= tempDivisor;\\n        }\\n        return flag * result;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        boolean neg = dividend > 0 && divisor < 0 || dividend < 0 && divisor > 0;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        int res = 0;\\n        while(divisor >= dividend){\\n            int count = 1;\\n            int newDivisor = divisor;\\n            while(newDivisor >= dividend - newDivisor){\\n                newDivisor <<= 1;\\n                count <<= 1;\\n            }\\n            dividend -= newDivisor;\\n            res += count;\\n        }\\n        if(neg)\\n            res = ~res + 1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13543,
                "title": "a-concise-java-solution",
                "content": "        public int divide(int dividend, int divisor) {\\n            if (dividend == Integer.MIN_VALUE && divisor == -1)\\n                return Integer.MAX_VALUE;\\n    \\n            long divd = Math.abs((long)dividend);\\n            long divs = Math.abs((long)divisor);\\n    \\n            int ret = 0;\\n            while (divd >= divs) {\\n                int counter = 0;\\n                while (divd >= (divs << counter)) { // keep multiply by 2 until divs > divd\\n                    counter++;\\n                }\\n                counter--;  // rollback counter so that (divs<<counter) <= divd\\n                ret += 1 << counter;  // quotient\\n                divd -= divs << counter;\\n            }\\n    \\n            if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\\n                return ret;\\n            else\\n                return -ret;\\n        }",
                "solutionTags": [],
                "code": "        public int divide(int dividend, int divisor) {\\n            if (dividend == Integer.MIN_VALUE && divisor == -1)\\n                return Integer.MAX_VALUE;\\n    \\n            long divd = Math.abs((long)dividend);\\n            long divs = Math.abs((long)divisor);\\n    \\n            int ret = 0;\\n            while (divd >= divs) {\\n                int counter = 0;\\n                while (divd >= (divs << counter)) { // keep multiply by 2 until divs > divd\\n                    counter++;\\n                }\\n                counter--;  // rollback counter so that (divs<<counter) <= divd\\n                ret += 1 << counter;  // quotient\\n                divd -= divs << counter;\\n            }\\n    \\n            if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\\n                return ret;\\n            else\\n                return -ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 13634,
                "title": "my-fast-solution-using-bit-operation-36ms",
                "content": "As for any integer can be writen by 2n+1 or 2n. Think about 123/5:\\n\\ndivisor        dividend\\n\\n5                     123\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   5*16 = 80\\n\\n5                    123-80=43\\n\\n  <<1\\n\\n  <<1\\n\\n  <<1\\n\\n5*8 = 40\\n\\n5                     43-40=3\\n\\n5<3, thus result = 16+8 = 24\\n\\n(if dividend == 125, finally we have:)\\n\\n5==5, thus result = 16+8+1 = 25;\\n\\n\\nHowever, I play a little trick by using long long .. o_____O\\n\\n--------------------------------------------------------------------------------------------\\n\\n    int divide(long long a, long long b) {\\n        if(b==0) return a>=0?0x7fffffff:0x80000000;\\n        if(a==0) return 0;\\n        if(b==1) return a;\\n        int sgn = (a^b) & 0x80000000; //0 -> +,  0x80000000 -> -\\n        if(a<0) a=-a;\\n        if(b<0) b=-b;\\n        //a,b>0\\n        if(a<b) return 0;\\n        int res = 0, _b = b, twon;\\n        while(a>b)\\n        {\\n            twon = 1;\\n            while(a>b)\\n            {\\n                //cout <<b<<' '<<a<<' '<<twon<<endl;\\n                b<<=1;\\n                twon<<=1;\\n                //getchar();\\n            }\\n            b>>=1;\\n            twon>>=1;\\n            a -= b;\\n            b = _b;\\n            res += twon;\\n        }\\n        if(a==b) res++;\\n        if(sgn) \\n            return -res;\\n        else return res;\\n    }",
                "solutionTags": [],
                "code": "As for any integer can be writen by 2n+1 or 2n. Think about 123/5:\\n\\ndivisor        dividend\\n\\n5                     123\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   5*16 = 80\\n\\n5                    123-80=43\\n\\n  <<1\\n\\n  <<1\\n\\n  <<1\\n\\n5*8 = 40\\n\\n5                     43-40=3\\n\\n5<3, thus result = 16+8 = 24\\n\\n(if dividend == 125, finally we have:)\\n\\n5==5, thus result = 16+8+1 = 25;\\n\\n\\nHowever, I play a little trick by using long long .. o_____O\\n\\n--------------------------------------------------------------------------------------------\\n\\n    int divide(long long a, long long b) {\\n        if(b==0) return a>=0?0x7fffffff:0x80000000;\\n        if(a==0) return 0;\\n        if(b==1) return a;\\n        int sgn = (a^b) & 0x80000000; //0 -> +,  0x80000000 -> -\\n        if(a<0) a=-a;\\n        if(b<0) b=-b;\\n        //a,b>0\\n        if(a<b) return 0;\\n        int res = 0, _b = b, twon;\\n        while(a>b)\\n        {\\n            twon = 1;\\n            while(a>b)\\n            {\\n                //cout <<b<<' '<<a<<' '<<twon<<endl;\\n                b<<=1;\\n                twon<<=1;\\n                //getchar();\\n            }\\n            b>>=1;\\n            twon>>=1;\\n            a -= b;\\n            b = _b;\\n            res += twon;\\n        }\\n        if(a==b) res++;\\n        if(sgn) \\n            return -res;\\n        else return res;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 13608,
                "title": "after-5-tle-finally-got-ac-and-i-cant-figure-out-the-complexity",
                "content": "**(Given that English not my mother tongue, please forgive my mistake about my words below)**\\n\\nHere coming my code without / * % operator:\\n\\n        class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tint flag = 1;\\n    \\t\\tif (divisor > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdivisor = -divisor;\\n    \\t\\t}\\n    \\t\\tif (dividend > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdividend = -dividend;\\n    \\t\\t}\\n    \\n    \\t\\tunsigned int acc = divisor, tmp = 0;\\n    \\t\\tint counter = 0, ans = 0;;\\n    \\t\\twhile (dividend <= divisor){\\n    \\t\\t\\tacc = divisor; tmp = 0, counter=0;\\n    \\t\\t\\twhile (acc >= dividend){\\n    \\t\\t\\t\\ttmp = acc;\\n    \\t\\t\\t\\tacc += acc;\\n    \\t\\t\\t\\tcounter++;\\n    \\t\\t\\t}\\n    \\t\\t\\tans += (counter > 0) ? 1 << (counter - 1) : 0;// 1*pow(2, counter-1)\\n    \\t\\t\\tdividend -= tmp;\\n    \\t\\t}\\n    \\t\\treturn flag*ans;\\n    \\t}\\n    };\\n\\nFirstly, let me give you some hints with the input:\\n\\nI.have you ever thought that dividend or divisor maybe negative or both;\\n\\nII.have you ever thought about this input{2^32-1, 1};\\n\\nIII.have you ever thought that there existing -2^32 meanwhile the largest int is 2^32-1;\\n\\n**Now is my thoughts:**\\n\\nConsidering the III hints I gave above, I played a trick that making dividend and divisor both negative, and using a flag judging the sign symbol of answer. **(ooops, i use * operator in the end of my code, but never mind, it's nothing to do with my algorithm)**\\n\\n1 I double the acc (initialize  acc=divisor) if acc <= dividend. Like 1, 2, 4, 8, 16...etc; Count the times I double the acc, storage in variable counter \\n\\n2.If acc >dividend, then dividend = dividend-acc/2;(can use / operator, i used extra variable tmp to storage the acc/2 ) . \\n\\n3. calculate how many time I double the  divisor: ans += (counter > 0) ? 1 << (counter - 1) : 0;// 1*pow(2, counter-1), **Then**, dividend-=tmp;\\n\\n4. Loop 1-3  while divisor<dividend**(remember I make them both negative)**\\n\\n \\n**The complexity** when the **worst** situation dividend = 2^32 -1 and divisor = 1;\\n\\ncomplexity = (lg dividend) + (lg dividend/2) + (lg dividend/4) + (lg dividend/8) + ...=(lg dividend)^2\\n\\nI don't know if there any problems in my proof.\\n\\n\\n**FOOL I AM, I CAN USE BINARY OPERATOR**\\n\\n        class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tlong long a = abs((long long)dividend);\\n    \\t\\tlong long b = abs((long long)divisor);\\n    \\t\\tint ans = 0, i = 0;\\n    \\t\\twhile (a > b){\\n    \\t\\t\\ti++;\\n    \\t\\t\\tb = b << 1;\\n    \\t\\t}\\n    \\t\\twhile (i >= 0){\\n    \\t\\t\\tif (a >= b){\\n    \\t\\t\\t\\ta -= b;\\n    \\t\\t\\t\\tans += (1 << i);\\n    \\t\\t\\t}\\n    \\t\\t\\tb = b >> 1;\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\n    \\t\\treturn (((dividend >> 31)==(divisor >> 31))) ? ans : -ans\\n    \\t}\\n    };\\n\\n \\n**It's more simple somehow**",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tint flag = 1;\\n    \\t\\tif (divisor > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdivisor = -divisor;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3654349,
                "title": "bits-of-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529137,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    long ans;\\n    public int divide(int dividend, int divisor) {\\n        ans=(long)dividend/(long)divisor;\\n        if(ans > (long)Math.pow(2,31)-1) ans = (long)Math.pow(2,31)-1;\\n        if(ans < (-1)*(long)Math.pow(2,31)) ans = (long)Math.pow(-2,31);\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long ans;\\n    public int divide(int dividend, int divisor) {\\n        ans=(long)dividend/(long)divisor;\\n        if(ans > (long)Math.pow(2,31)-1) ans = (long)Math.pow(2,31)-1;\\n        if(ans < (-1)*(long)Math.pow(2,31)) ans = (long)Math.pow(-2,31);\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268612,
                "title": "easy-c-solution-beat-100-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long int s=1,e=abs(dividend),mid=0,ans=0;\\n        if (divisor == 0 || (dividend == INT_MIN && divisor == -1)) {\\n            return INT_MAX;\\n        }\\n          if (divisor == 0 || (dividend == INT_MIN && divisor == 1)) \\n            return INT_MIN;\\n        \\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            if(abs(divisor*mid)==abs(dividend))\\n            {\\n                ans=mid;\\n                break;\\n            }\\n            else if(abs(divisor*mid)>abs(dividend))\\n            e=mid-1;\\n            else\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n        }\\n        if((divisor>0&&dividend>0)||(divisor<0&&dividend<0))\\n        return ans;\\n        else\\n        return -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long int s=1,e=abs(dividend),mid=0,ans=0;\\n        if (divisor == 0 || (dividend == INT_MIN && divisor == -1)) {\\n            return INT_MAX;\\n        }\\n          if (divisor == 0 || (dividend == INT_MIN && divisor == 1)) \\n            return INT_MIN;\\n        \\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            if(abs(divisor*mid)==abs(dividend))\\n            {\\n                ans=mid;\\n                break;\\n            }\\n            else if(abs(divisor*mid)>abs(dividend))\\n            e=mid-1;\\n            else\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n        }\\n        if((divisor>0&&dividend>0)||(divisor<0&&dividend<0))\\n        return ans;\\n        else\\n        return -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033336,
                "title": "100-bit-manipulation-simple-explanation-no-long-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas we cant use multiplication & division and modulo operators , first thing that comes to mind is to maintain a variable quotient and substract divisor from dividend till it is greater or equal to it.\\nthis will take a lot of time but it is a accepted solution\\ncan we do it in better Time complexity ? \\'yes\\'\\nrather substracting the divisor linearly we can do it exponentially that is using left shift operator(1<<1 == 2 left is used to multiply any number by 2 in binary);\\nit is nothing but rather substracting 3 , 6 , 9 , 12 .... we gonna substract 3 , 6 , 12 , 24 , 48 ......\\n**hope you like the intution give a \\uD83D\\uDC4D to improve my profile**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- maintain a variable `quotient`.\\n- extract the resultant sign and typecast to `long` to avoid overflows.\\n- while `dividend is >= divisor` left shift the divisor till it is smaller than dividend.maintain number of leftshifts.\\n- substract dividend with the `divisor<<shift-1` as we shifted one extra bit. add number `1<<shifts-1` to quotient(number of times divisor is multiplied).\\n- return corresponding values for signs\\n# Complexity\\n- Time complexity:$$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        long quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        long dd = (long)dividend , dv = (long)divisor;\\n        dd = Math.abs(dd);dv = Math.abs(dv);\\n        while(dd >= dv){\\n            int shift = 0;\\n            while(dd >= (dv<<shift))shift++;\\n            quotient += (long)1l<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dd -= dv<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient > max)return max;\\n            return (int)quotient;\\n        }else{\\n            if((~quotient)+1 < min)return min; // ~quotient+1 = -quotient\\n            return (int)(~quotient)+1;\\n        }\\n    }\\n}\\n```\\n> we can store one bigger value in negetive numbers than positive numbers so this is an asset here to avoid using long, as question clearly says the environment can only store 32 bit integers.\\n- rather performing division of positive values we can do it with negative values and even quotient also can be integer.\\n\\n**Note : while rightshifting the divisor check for overflow.**\\n### updated code:\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        // System.out.println(-2147483648<<3);\\n        // System.out.println(Integer.toBinaryString(-1<<0));\\n        int quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        if(dividend > 0)dividend = -dividend;\\n        if(divisor > 0)divisor = -divisor;\\n        while(dividend <= divisor){\\n            int shift = 1;\\n            while((divisor<<shift) < divisor && dividend <= (divisor<<shift))shift++;\\n            quotient -= 1<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dividend -= divisor<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient == min)return max;\\n            return -quotient;\\n        }else{\\n            return quotient;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        long quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        long dd = (long)dividend , dv = (long)divisor;\\n        dd = Math.abs(dd);dv = Math.abs(dv);\\n        while(dd >= dv){\\n            int shift = 0;\\n            while(dd >= (dv<<shift))shift++;\\n            quotient += (long)1l<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dd -= dv<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient > max)return max;\\n            return (int)quotient;\\n        }else{\\n            if((~quotient)+1 < min)return min; // ~quotient+1 = -quotient\\n            return (int)(~quotient)+1;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        // System.out.println(-2147483648<<3);\\n        // System.out.println(Integer.toBinaryString(-1<<0));\\n        int quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        if(dividend > 0)dividend = -dividend;\\n        if(divisor > 0)divisor = -divisor;\\n        while(dividend <= divisor){\\n            int shift = 1;\\n            while((divisor<<shift) < divisor && dividend <= (divisor<<shift))shift++;\\n            quotient -= 1<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dividend -= divisor<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient == min)return max;\\n            return -quotient;\\n        }else{\\n            return quotient;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644837,
                "title": "easy-c-solution-faster-than-100-00-of-c-online-submissions",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*Please Upvote If You Find It Helpful.*\\n\\n\\t int divide(int dividend, int divisor) {\\n\\t\\t\\tif(divisor==-1 && dividend == INT_MIN)\\n\\t\\t\\t\\treturn INT_MAX;\\n\\t\\t\\tbool sign = (dividend>=0) == (divisor>=0) ? true : false;\\n\\t\\t\\tlong int did = abs(dividend);\\n\\t\\t\\tlong int div = abs(divisor);\\n\\t\\t\\tlong int result=0;\\n\\t\\t\\t// int count=0, temp=divisor;\\n\\t\\t\\twhile(did - div >= 0){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile((did - (div<<1<<count))>=0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tresult += 1<<count;\\n\\t\\t\\t\\tdid -= div<<count;\\n\\t\\t\\t}\\n\\t\\t\\treturn sign ? result : -result;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*Please Upvote If You Find It Helpful.*\\n\\n\\t int divide(int dividend, int divisor) {\\n\\t\\t\\tif(divisor==-1 && dividend == INT_MIN)\\n\\t\\t\\t\\treturn INT_MAX;\\n\\t\\t\\tbool sign = (dividend>=0) == (divisor>=0) ? true : false;\\n\\t\\t\\tlong int did = abs(dividend);\\n\\t\\t\\tlong int div = abs(divisor);\\n\\t\\t\\tlong int result=0;\\n\\t\\t\\t// int count=0, temp=divisor;\\n\\t\\t\\twhile(did - div >= 0){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile((did - (div<<1<<count))>=0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tresult += 1<<count;\\n\\t\\t\\t\\tdid -= div<<count;\\n\\t\\t\\t}\\n\\t\\t\\treturn sign ? result : -result;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2350079,
                "title": "java-solution",
                "content": "\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t//edge case ( we cant have quotient 2^31 ) since -2^31 / -1 gives 2^31 ( overflow case)  \\n        if (Integer.MIN_VALUE == dividend && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\t\\t\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int quo = 0;\\n        while (a - b >= 0) {\\n            int x = 0;\\n            while (a - ((b << 1) << x) >= 0) {\\n                x++;\\n            }\\n            quo += 1 << x;\\n            a -= b << x;\\n        }\\n\\t\\t\\n\\t\\t//both +ve or both -ve (dividend  and divisor) should return quo as it is else with a -ve sign\\n          if ((dividend >= 0) == (divisor >= 0)) {\\n            return quo;\\n        } else {\\n            return -1 * quo;\\n        }\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t//edge case ( we cant have quotient 2^31 ) since -2^31 / -1 gives 2^31 ( overflow case)  \\n        if (Integer.MIN_VALUE == dividend && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\t\\t\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int quo = 0;\\n        while (a - b >= 0) {\\n            int x = 0;\\n            while (a - ((b << 1) << x) >= 0) {\\n                x++;\\n            }\\n            quo += 1 << x;\\n            a -= b << x;\\n        }\\n\\t\\t\\n\\t\\t//both +ve or both -ve (dividend  and divisor) should return quo as it is else with a -ve sign\\n          if ((dividend >= 0) == (divisor >= 0)) {\\n            return quo;\\n        } else {\\n            return -1 * quo;\\n        }\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2091391,
                "title": "c-bit-manipulation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if(a == INT_MIN and b == -1) return INT_MAX;\\n        long num = labs(a), div = labs(b), ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```\\nDo consider upvoting if found useful :)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if(a == INT_MIN and b == -1) return INT_MAX;\\n        long num = labs(a), div = labs(b), ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090270,
                "title": "easy-to-understand-c-beats-100",
                "content": "**Pls upvote the thread if you found it helpful.**\\n\\t\\t\\n\\tint divide(int dividend, int divisor) {\\n\\t\\t\\t//Edge cases\\n\\t\\t\\tif(dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\t\\tif(dividend == INT_MIN && divisor == 1) return INT_MIN;\\n\\n\\t\\t\\t//Absolute\\n\\t\\t\\tlong int dd = abs(dividend), dv = abs(divisor);\\n\\t\\t\\t\\n\\t\\t\\t//Result\\n\\t\\t\\tint res =0;\\n\\t\\t\\twhile(dv<=dd){\\n\\t\\t\\t\\tlong int mul=dv,temp=1;\\n\\t\\t\\t\\twhile(mul<=dd-mul){\\n\\t\\t\\t\\t\\tmul+=mul;\\n\\t\\t\\t\\t\\ttemp+=temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tres+=temp;\\n\\t\\t\\tdd-=mul;\\n\\t\\t}\\n\\t\\t\\t//If dividend or divisor < 0 res will be -ve\\n\\t\\t\\t if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "**Pls upvote the thread if you found it helpful.**\\n\\t\\t\\n\\tint divide(int dividend, int divisor) {\\n\\t\\t\\t//Edge cases\\n\\t\\t\\tif(dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\t\\tif(dividend == INT_MIN && divisor == 1) return INT_MIN;\\n\\n\\t\\t\\t//Absolute\\n\\t\\t\\tlong int dd = abs(dividend), dv = abs(divisor);\\n\\t\\t\\t\\n\\t\\t\\t//Result\\n\\t\\t\\tint res =0;\\n\\t\\t\\twhile(dv<=dd){\\n\\t\\t\\t\\tlong int mul=dv,temp=1;\\n\\t\\t\\t\\twhile(mul<=dd-mul){\\n\\t\\t\\t\\t\\tmul+=mul;\\n\\t\\t\\t\\t\\ttemp+=temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tres+=temp;\\n\\t\\t\\tdd-=mul;\\n\\t\\t}\\n\\t\\t\\t//If dividend or divisor < 0 res will be -ve\\n\\t\\t\\t if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2089466,
                "title": "c-do-binary-removals-explainations",
                "content": "Dividing b/a means number of times we can remove a from b \\nb - a -a - a- a- a ............k time\\nb - k*a\\n\\nInstead of removing a one by one , we can remove it in groups. How?\\nany number k , can be written in the form of 2\\'s powers. So the algorithm will be:\\nWe solve the problem for positive dividend and divisior only and then decide the sign\\n1. Iterate from i=31 to 0, and try to remove the biggestpower * divisor\\n2. If it is removable, add it to the quotient and remove from dividend . Here adding and | is same as adding 2\\'s powers will give same ans as using or operator in binary\\n3. Use long long as during multiplication the values may overflow\\n4. In the end check the limits specified by the question.\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        int sign = ((x<0)^(y<0))?-1:+1;\\n        long long dividend = x, divisor=y,q=0;\\n        dividend=abs(dividend), divisor = abs(divisor);\\n        for(int i=31;i>=0;i--){\\n            if((divisor<<i) > dividend) continue;  \\n            q |= (1LL<<i);\\n            dividend -=  (divisor<<i);\\n        }\\n        q*=sign;\\n        if(q<0 and q<INT_MIN) q=INT_MIN;\\n        if(q>0 and q>INT_MAX) q=INT_MAX;\\n        return q;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        int sign = ((x<0)^(y<0))?-1:+1;\\n        long long dividend = x, divisor=y,q=0;\\n        dividend=abs(dividend), divisor = abs(divisor);\\n        for(int i=31;i>=0;i--){\\n            if((divisor<<i) > dividend) continue;  \\n            q |= (1LL<<i);\\n            dividend -=  (divisor<<i);\\n        }\\n        q*=sign;\\n        if(q<0 and q<INT_MIN) q=INT_MIN;\\n        if(q>0 and q>INT_MAX) q=INT_MAX;\\n        return q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089279,
                "title": "python-solution",
                "content": "*I am a bit unsure about the complexity of my solution but I think it is O(n) with n being the length of dividend,\\nplease feel free to confirm.\\nPython is not my main language, there\\'s probably some part of my code that you could write in a more elegant\\nand more readable way, same here, feel free to let me know.*\\n\\n**Full solution:**\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tsign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        if dividend < 0 :\\n            dividend = dividend - dividend - dividend\\n        if divisor < 0:\\n            divisor = divisor - divisor - divisor\\n            \\n        if divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n       \\n        result = 0\\n        while dividend >= divisor:\\n            toSubstract, quotient = self.computeIteration(dividend, divisor)\\n            dividend -= toSubstract\\n            result += quotient\\n\\n        \\n        return self.handleResult(sign * result)\\n    \\n    def handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n    \\n    def computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\\n\\n**Step by step:**\\n* First handling the sign of the result and getting rid of `-` signs for simplicity (**EDIT** : **USE OF MULTIPLICATION**, see next ):\\n\\n```\\n\\t\\tsign = 1\\n        if dividend < 0 :\\n            sign *= -1\\n            dividend *= -1\\n        if divisor < 0 :\\n            sign *= -1\\n            divisor *= -1\\n```\\n**EDIT** Thanks to @mihir_jr comment, finding absolute value without multiplication:\\n\\t\\t\\t\\n```\\nsign = 1\\nif (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n\\tsign = -1\\nif dividend < 0 :\\n\\tdividend = dividend - dividend - dividend\\nif divisor < 0:\\n\\tdivisor = divisor - divisor - divisor\\n```\\n\\n* This part is optional, just handling simple `-1 / 1` divisor case:\\n```\\nif divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n```\\n\\n* All our result will for through this function before being returned, to handle `-2^31 / 2^31 - 1` result cases:\\n\\n```\\ndef handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n```\\n\\n* This is the main part of the solution: \\n\\n```\\ndef computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\\n\\nWe determine the maximum number of zeros our quotient can have.\\nWe return this quotient to be added to the result and the `divisor` concatenated to the computed number of zeros which we will substract to dividend for the next loop round.\\n\\n```\\nresult = 0\\nwhile dividend >= divisor:\\n\\ttoSubstract, quotient = self.computeIteration(dividend, divisor)\\n\\tdividend -= toSubstract\\n\\tresult += quotient\\n\\nreturn self.handleResult(sign * result)\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tsign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        if dividend < 0 :\\n            dividend = dividend - dividend - dividend\\n        if divisor < 0:\\n            divisor = divisor - divisor - divisor\\n            \\n        if divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n       \\n        result = 0\\n        while dividend >= divisor:\\n            toSubstract, quotient = self.computeIteration(dividend, divisor)\\n            dividend -= toSubstract\\n            result += quotient\\n\\n        \\n        return self.handleResult(sign * result)\\n    \\n    def handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n    \\n    def computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\n```\\n\\t\\tsign = 1\\n        if dividend < 0 :\\n            sign *= -1\\n            dividend *= -1\\n        if divisor < 0 :\\n            sign *= -1\\n            divisor *= -1\\n```\n```\\nsign = 1\\nif (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n\\tsign = -1\\nif dividend < 0 :\\n\\tdividend = dividend - dividend - dividend\\nif divisor < 0:\\n\\tdivisor = divisor - divisor - divisor\\n```\n```\\nif divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n```\n```\\ndef handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n```\n```\\ndef computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\n```\\nresult = 0\\nwhile dividend >= divisor:\\n\\ttoSubstract, quotient = self.computeIteration(dividend, divisor)\\n\\tdividend -= toSubstract\\n\\tresult += quotient\\n\\nreturn self.handleResult(sign * result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957404,
                "title": "java-100-faster-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == 1<<31 && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean sign = (dividend >= 0) == (divisor >= 0) ? true : false;\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        int result = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            result += 1 <<count;\\n            dividend -= divisor << count;\\n        }\\n        return sign ? result : -result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == 1<<31 && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean sign = (dividend >= 0) == (divisor >= 0) ? true : false;\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        int result = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            result += 1 <<count;\\n            dividend -= divisor << count;\\n        }\\n        return sign ? result : -result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888339,
                "title": "cpp-0ms-100",
                "content": "```\\n/*\\n    childhood method:\\n     3) 10 (2\\n         6\\n    _________\\n       3)4(\\n         3\\n    __________\\n       3)1(\\n       \\n      same here too \\n      first we will remove maximum 2 multiple of divisor\\n      example: 10 3\\n      3 6 12 24  ---doubling each time\\n      so we can subtract 6 from 10 so we remainded with 10-6=>4  add 2 to result\\n      3 6 ..  \\n      so we can subtract 3 from 4 so remainded with 4-3=>1 add 1 to result\\n      \\n      2<<1 ==>4\\n      if we left shift 1 bit it indicates we are multiplying num by\\'2\\'\\n      \\n     \\n      \\n    */\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        bool sign= ((dividend>=0)==(divisor>=0))?true:false;\\n        long int res=0;\\n        long int ldividend=abs(dividend);\\n        long int ldivisor=abs(divisor);\\n        while((ldividend-ldivisor)>=0){\\n            int cnt=0;\\n            while(ldividend>=(ldivisor<<cnt))cnt++;\\n            res+=(1<<(cnt-1));\\n            ldividend-=ldivisor<<(cnt-1);\\n        }\\n        if(res>INT_MAX) return (sign)?INT_MAX:INT_MIN;\\n        return (sign)?res:-res;\\n    }",
                "solutionTags": [],
                "code": "```\\n/*\\n    childhood method:\\n     3) 10 (2\\n         6\\n    _________\\n       3)4(\\n         3\\n    __________\\n       3)1(\\n       \\n      same here too \\n      first we will remove maximum 2 multiple of divisor\\n      example: 10 3\\n      3 6 12 24  ---doubling each time\\n      so we can subtract 6 from 10 so we remainded with 10-6=>4  add 2 to result\\n      3 6 ..  \\n      so we can subtract 3 from 4 so remainded with 4-3=>1 add 1 to result\\n      \\n      2<<1 ==>4\\n      if we left shift 1 bit it indicates we are multiplying num by\\'2\\'\\n      \\n     \\n      \\n    */\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        bool sign= ((dividend>=0)==(divisor>=0))?true:false;\\n        long int res=0;\\n        long int ldividend=abs(dividend);\\n        long int ldivisor=abs(divisor);\\n        while((ldividend-ldivisor)>=0){\\n            int cnt=0;\\n            while(ldividend>=(ldivisor<<cnt))cnt++;\\n            res+=(1<<(cnt-1));\\n            ldividend-=ldivisor<<(cnt-1);\\n        }\\n        if(res>INT_MAX) return (sign)?INT_MAX:INT_MIN;\\n        return (sign)?res:-res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1846693,
                "title": "c-0ms-solution-that-follows-all-constraints-explained",
                "content": "Constraints:\\n- \"Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1].\" This means **no long long or unsigned int**.\\n- \"If the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\"\\n- No multiplication, division, or mod operator.\\n\\n```\\n    int int_min = -2147483648, int_max = 2147483647;\\n    \\n    int divide(int dividend, int divisor) {\\n        \\n        // edge cases (dividend or divisor is int_min)\\n        if(dividend == int_min) {\\n            if(divisor == -1) {return int_max;}\\n            else if(divisor == int_min) {return 1;}\\n            else if(divisor < 0) {\\n                // do this so we can avoid abs(dividend) overflowing the upper int limit\\n                return 1 + divide(dividend - divisor, divisor);\\n            }\\n            else {\\n                // same as above comment\\n                return -1 + divide(dividend + divisor, divisor);\\n            }\\n        }\\n        else if(divisor == int_min) {return 0;}\\n        \\n        // take care of negative later\\n        bool neg = (dividend < 0) ^ (divisor < 0); // final answer is negative if either dividend or divisor is negative\\n        dividend = abs(dividend); divisor = abs(divisor); // change both to positive\\n        \\n        int result = 0;\\n        for(int i = 31; i >= 0; --i) {\\n            int shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n            if(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n                result += (1 << i);\\n                dividend -= (divisor << i);\\n            }\\n        }\\n        \\n        return (neg ? -result : result);\\n    }\\n```\\n\\t\\nThe general idea is similar to many others. We change both the dividend and divisor to positive and then add in the negative sign at the end if needed. But firstly, we have a few edge cases:\\n- If dividend = int_min and divisor = -1, then the actual result of the divison would be -int_min, oer +2147483648. But this overflows int_max, so we just return int_max in this case.\\n- If dividend = int_min and divisor = int_min, then return 1.\\n- Even if the above two cases do not happen, we still need to modify dividend. The reason is if dividend = int_min, then abs(dividend) would overflow int_max, so we can\\'t allow this to happen. I take care of this by simply subtracting or adding one divisor from dividend, based on the sign of divisor. If you don\\'t understand this, consider the following logic: The quotient when 10000 is divided by 3 is also equal to 1 + the quotient of 9997 / 3. We basically remove one instance of divisor from the dividend so that abs(dividend) no longer overflows. \\n- If none of the above happens (basically, if dividend != int_min), but divisor is int_min, then obviously the correct quotient is `0`.\\n\\nWithout multiplication, division, or modulo operators, the only way we can do this is through **bit shift operators**. But more specifically, this program mainly relies on the **binary right shift (>>)** operator, because this helps us avoid overflow. This loop is the main part of the program:\\n\\n```\\nint result = 0;\\nfor(int i = 31; i >= 0; --i) {\\n\\tint shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n\\tif(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n\\t\\tresult += (1 << i);\\n\\t\\tdividend -= (divisor << i);\\n\\t}\\n}\\n```\\n\\nWhat happens here is the following.\\n- Loop from the most significant bit to the least significant bit in a 32-bit number. For each bit, we determine if the final quotient (result) should have this bit set or not. How do we decide this for each position i? Just do the following:\\n- Let ```shifted_dividend = (dividend >> i)```, which is the quotient of dividend / 2^i. Basically this is just how many times 2^i can go into dividend. Now, obviously, if 2^i can go into dividend at least ```divisor``` times, then we know that ```divisor * 2^i <= dividend```, which means that we should add 2^i to the quotient, and subtract ```divisor * 2^i``` from ```dividend```!\\n- Notice how ```(dividend >> i)``` never overflows, since it must result in a number smaller than ```dividend```. Also, it never becomes negative; if `i` too large, then ```(dividend >> i)``` would just equal `0`. This fits up with the conceptual definition that this is the number of times 2^i can go into ```dividend```.\\n- Obviously, we return ```result```, and make sure to take care of whether it\\'s negative or positive.\\n\\n**Note about C++ Undefined Behavior:** Right-shifting a negative signed integer is undefined behavior, but right-shifting a positive signed integer isn\\'t. cppreference.com says that \"For unsigned a and for signed and non-negative a, the value of a >> b is the integer part of a/2^b.\" This is one of the main reasons why we choose to change both numbers to positive before finding the quotient (and only adding the negative sign at the very end).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int int_min = -2147483648, int_max = 2147483647;\\n    \\n    int divide(int dividend, int divisor) {\\n        \\n        // edge cases (dividend or divisor is int_min)\\n        if(dividend == int_min) {\\n            if(divisor == -1) {return int_max;}\\n            else if(divisor == int_min) {return 1;}\\n            else if(divisor < 0) {\\n                // do this so we can avoid abs(dividend) overflowing the upper int limit\\n                return 1 + divide(dividend - divisor, divisor);\\n            }\\n            else {\\n                // same as above comment\\n                return -1 + divide(dividend + divisor, divisor);\\n            }\\n        }\\n        else if(divisor == int_min) {return 0;}\\n        \\n        // take care of negative later\\n        bool neg = (dividend < 0) ^ (divisor < 0); // final answer is negative if either dividend or divisor is negative\\n        dividend = abs(dividend); divisor = abs(divisor); // change both to positive\\n        \\n        int result = 0;\\n        for(int i = 31; i >= 0; --i) {\\n            int shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n            if(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n                result += (1 << i);\\n                dividend -= (divisor << i);\\n            }\\n        }\\n        \\n        return (neg ? -result : result);\\n    }\\n```\n```\\nint result = 0;\\nfor(int i = 31; i >= 0; --i) {\\n\\tint shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n\\tif(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n\\t\\tresult += (1 << i);\\n\\t\\tdividend -= (divisor << i);\\n\\t}\\n}\\n```\n```shifted_dividend = (dividend >> i)```\n```divisor```\n```divisor * 2^i <= dividend```\n```divisor * 2^i```\n```dividend```\n```(dividend >> i)```\n```dividend```\n```(dividend >> i)```\n```dividend```\n```result```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826773,
                "title": "my-o-1-solution-in-c",
                "content": "It\\'s been 15 years since I wrote C, please a gentle...\\n\\nHere\\'s my implementation based on the long division algorithm everyone learned in grade school.  It uses only 32 bit types and no multiplication or division, including in the standard library.\\n\\nThe solution is O(1) for 32 bit types, because it always loops exactly 32 times, one for each significant bit.  There\\'s probably opportunities to use bitwise math to speed up the loop body, and the loop itself could be unrolled.\\n\\n```\\n// Glibc\\'s implementation of abs uses multiplication for negative numbers and is undefined for\\n// INT_MIN as per the standard, because the return type is also a signed integer.\\ninline uint32_t uabs(int i)\\n{\\n    return i < 0 ? ~(uint32_t) i + 1 : i;\\n}\\n\\nint divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }\\n    }\\n    \\n    // Reintroduce the sign as appropriate\\n    if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {\\n        return result >= (uint32_t) INT_MAX ? INT_MAX : (int) result;\\n    }\\n    else {\\n        // Invert bits and add one instead of multiplying by -1\\n        return result > (uint32_t) INT_MAX ? INT_MIN : ((int) ~result) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Glibc\\'s implementation of abs uses multiplication for negative numbers and is undefined for\\n// INT_MIN as per the standard, because the return type is also a signed integer.\\ninline uint32_t uabs(int i)\\n{\\n    return i < 0 ? ~(uint32_t) i + 1 : i;\\n}\\n\\nint divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }\\n    }\\n    \\n    // Reintroduce the sign as appropriate\\n    if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {\\n        return result >= (uint32_t) INT_MAX ? INT_MAX : (int) result;\\n    }\\n    else {\\n        // Invert bits and add one instead of multiplying by -1\\n        return result > (uint32_t) INT_MAX ? INT_MIN : ((int) ~result) + 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696904,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = dividend>0 ^ divisor>0 ? true : false;\\n        int q = 0;\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        while(dividend - divisor >= 0) {\\n            int temp = divisor;\\n            int c=0;\\n            while (dividend - temp >= 0) {\\n                temp = temp << 1;\\n                c++;\\n            }\\n            temp = divisor;\\n            dividend = dividend - (temp << c-1);\\n            q += 1 << c-1;\\n        }\\n\\n        if(sign) return -q;\\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = dividend>0 ^ divisor>0 ? true : false;\\n        int q = 0;\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        while(dividend - divisor >= 0) {\\n            int temp = divisor;\\n            int c=0;\\n            while (dividend - temp >= 0) {\\n                temp = temp << 1;\\n                c++;\\n            }\\n            temp = divisor;\\n            dividend = dividend - (temp << c-1);\\n            q += 1 << c-1;\\n        }\\n\\n        if(sign) return -q;\\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691917,
                "title": "c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long ans = 0;\\n        bool cneg = false;\\n        if((dividend<0 && divisor>0) || (dividend>0 && divisor<0)){\\n            cneg = true;\\n        }\\n        long long divid = abs(dividend);\\n        long long divis = abs(divisor);\\n        if((dividend == INT_MAX && divisor==1) ||(dividend == INT_MIN && divisor==-1)){\\n            return INT_MAX;\\n        }\\n        if((dividend == INT_MIN && divisor == 1) || (dividend == INT_MAX && divisor==-1)){\\n            return INT_MIN;\\n        }\\n        int count = 1;\\n        if(divid-divis<0){\\n            return 0;\\n        }\\n        divid-=divis;\\n        ans = 1;\\n        while(divid-divis >= 0){\\n            divid-=divis;\\n            divis = divis<<1;\\n            ans+=count;\\n            count = count<<1;\\n        }\\n        divisor = abs(divisor);\\n        while(divid-divisor>=0){\\n            ans++;\\n            divid-=divisor;\\n            \\n        }\\n        return cneg ? (-1*ans) : ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long ans = 0;\\n        bool cneg = false;\\n        if((dividend<0 && divisor>0) || (dividend>0 && divisor<0)){\\n            cneg = true;\\n        }\\n        long long divid = abs(dividend);\\n        long long divis = abs(divisor);\\n        if((dividend == INT_MAX && divisor==1) ||(dividend == INT_MIN && divisor==-1)){\\n            return INT_MAX;\\n        }\\n        if((dividend == INT_MIN && divisor == 1) || (dividend == INT_MAX && divisor==-1)){\\n            return INT_MIN;\\n        }\\n        int count = 1;\\n        if(divid-divis<0){\\n            return 0;\\n        }\\n        divid-=divis;\\n        ans = 1;\\n        while(divid-divis >= 0){\\n            divid-=divis;\\n            divis = divis<<1;\\n            ans+=count;\\n            count = count<<1;\\n        }\\n        divisor = abs(divisor);\\n        while(divid-divisor>=0){\\n            ans++;\\n            divid-=divisor;\\n            \\n        }\\n        return cneg ? (-1*ans) : ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560454,
                "title": "python-easy-solution-faster-than-98",
                "content": "\\tclass Solution:\\n\\t\\tdef divide(self, dividend: int, divisor: int) -> int:\\n\\t\\t\\tif dividend == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tsign = 1 if ((dividend < 0) ^ (divisor < 0)) else 0\\n\\t\\t\\tdividend = abs(dividend)\\n\\t\\t\\tdivisor = abs(divisor)\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile dividend >= divisor:\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\twhile dividend >= divisor << (k+1):\\n\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\tdividend -= (divisor << k)\\n\\t\\t\\t\\tres += 1 << k\\n\\t\\t\\tMAX_INT = (1 << 31)-1\\n\\t\\t\\treturn -res if sign else (res if res <= MAX_INT else MAX_INT)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef divide(self, dividend: int, divisor: int) -> int:\\n\\t\\t\\tif dividend == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tsign = 1 if ((dividend < 0) ^ (divisor < 0)) else 0\\n\\t\\t\\tdividend = abs(dividend)\\n\\t\\t\\tdivisor = abs(divisor)\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile dividend >= divisor:\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\twhile dividend >= divisor << (k+1):\\n\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\tdividend -= (divisor << k)\\n\\t\\t\\t\\tres += 1 << k\\n\\t\\t\\tMAX_INT = (1 << 31)-1\\n\\t\\t\\treturn -res if sign else (res if res <= MAX_INT else MAX_INT)",
                "codeTag": "Java"
            },
            {
                "id": 1548253,
                "title": "python-24ms-98-38-without-bit-manipulation",
                "content": "The code is currently patchy for integer boundaries. Its on my todos.\\n\\nThe idea is to greedily increase divisor till we can\\'t.\\n\\nIf we have 14 / 2. (2 is the divisor, 14 is the dividend)\\n1. then we can increase 2 to 4 then to 8. Store the number of steps of the currend divisor 8. (4 steps)\\n2. Now reduce the dividend 14-8 = 6 and start divisor from 2 again. 2 then 4 (2 steps).\\n3. Reduce again ... 6-4=2. (1 step) since divisor == dividend.\\n\\nTotal number of steps = 7 which matches with integer divide of 14//2\\n\\nNumber of steps explanation\\nIf we have 8 .. then number of steps is 4 since .. \\nnumber of steps to reach 4 is 2 steps from 2. \\n\\nOriginal submisson:\\nhttps://leetcode.com/problems/divide-two-integers/submissions/\\n\\nLess code version:\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:        \\n                        \\n        sign = False\\n        if dividend < 0 and divisor > 0:\\n            sign = True\\n        if dividend > 0 and divisor < 0:\\n            sign = True        \\n                \\n        dividend = abs(dividend)\\n        divisor = abs(divisor) # original divisor\\n        \\n        # INT MIN PART IS PATCHY ... \\n        if dividend > 2147483647 and not sign:\\n            dividend = 2147483647\\n        if divisor > 2147483647 and not sign:\\n            divisor = 2147483647        \\n                \\n        if divisor > dividend:\\n            return 0\\n        \\n        cdivisor = divisor # current divisor\\n        count = 0\\n        prevCount = 0                \\n             \\n        count = 1        \\n        while dividend >= divisor:\\n            # if dividend is 14 .. and we get o 8+8= 16 .. deduct 14 - 8 = 6            \\n            if cdivisor + cdivisor > dividend:                \\n                dividend = dividend - cdivisor\\n                prevCount = prevCount + count\\n                \\n                # test case: 2 2\\n                if dividend >= divisor:\\n                    cdivisor = divisor\\n                    count = 1\\n                else:\\n                    count = 0\\n            else:                                                    \\n                cdivisor =  cdivisor + cdivisor\\n                count = count + count                                                     \\n                \\n        if sign:\\n            return - count - prevCount\\n        return count + prevCount\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:        \\n                        \\n        sign = False\\n        if dividend < 0 and divisor > 0:\\n            sign = True\\n        if dividend > 0 and divisor < 0:\\n            sign = True        \\n                \\n        dividend = abs(dividend)\\n        divisor = abs(divisor) # original divisor\\n        \\n        # INT MIN PART IS PATCHY ... \\n        if dividend > 2147483647 and not sign:\\n            dividend = 2147483647\\n        if divisor > 2147483647 and not sign:\\n            divisor = 2147483647        \\n                \\n        if divisor > dividend:\\n            return 0\\n        \\n        cdivisor = divisor # current divisor\\n        count = 0\\n        prevCount = 0                \\n             \\n        count = 1        \\n        while dividend >= divisor:\\n            # if dividend is 14 .. and we get o 8+8= 16 .. deduct 14 - 8 = 6            \\n            if cdivisor + cdivisor > dividend:                \\n                dividend = dividend - cdivisor\\n                prevCount = prevCount + count\\n                \\n                # test case: 2 2\\n                if dividend >= divisor:\\n                    cdivisor = divisor\\n                    count = 1\\n                else:\\n                    count = 0\\n            else:                                                    \\n                cdivisor =  cdivisor + cdivisor\\n                count = count + count                                                     \\n                \\n        if sign:\\n            return - count - prevCount\\n        return count + prevCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532163,
                "title": "wrong-testcase",
                "content": "-2147483648\\n-1\\n\\nwith the expected result\\n2147483647\\n\\nWas forced to do some dirty hacks. Seems that the testcases are generated by running the written  code.\\n```\\nclass Solution {\\npublic:\\n    std::uint64_t divideImpl(std::uint64_t dividend, std::uint64_t divisor, std::uint64_t origin, std::uint64_t count){\\n       auto tmp_count = count; \\n       if((divisor+divisor) > dividend) {\\n           divisor = origin;\\n           tmp_count = 1;\\n       }\\n        \\n       if(dividend < divisor) return 0;\\n       return tmp_count+divideImpl(dividend - divisor, divisor+divisor, origin, tmp_count+tmp_count);\\n    }\\n    \\n    int divide(std::int64_t dividend, std::int64_t divisor) {\\n       int sign = 1;\\n       if(dividend < 0) {\\n           sign = -sign;\\n           dividend = -dividend;\\n       }\\n       if(divisor < 0) {\\n           sign = -sign;\\n           divisor = -divisor;\\n       }\\n        \\n       auto result = divideImpl(dividend, divisor, divisor, 1);\\n       return (sign > 0)? std::min<std::uint64_t>(result, 2147483647u): -result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::uint64_t divideImpl(std::uint64_t dividend, std::uint64_t divisor, std::uint64_t origin, std::uint64_t count){\\n       auto tmp_count = count; \\n       if((divisor+divisor) > dividend) {\\n           divisor = origin;\\n           tmp_count = 1;\\n       }\\n        \\n       if(dividend < divisor) return 0;\\n       return tmp_count+divideImpl(dividend - divisor, divisor+divisor, origin, tmp_count+tmp_count);\\n    }\\n    \\n    int divide(std::int64_t dividend, std::int64_t divisor) {\\n       int sign = 1;\\n       if(dividend < 0) {\\n           sign = -sign;\\n           dividend = -dividend;\\n       }\\n       if(divisor < 0) {\\n           sign = -sign;\\n           divisor = -divisor;\\n       }\\n        \\n       auto result = divideImpl(dividend, divisor, divisor, 1);\\n       return (sign > 0)? std::min<std::uint64_t>(result, 2147483647u): -result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450328,
                "title": "python3-python-solution-w-comments",
                "content": "**WHY on the earth you need not to use divison, muliplication and mode operator?**\\n*This problem is just waste of time*\\n```\\nclass Solution:\\n    \\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        # -2147483648 through 2147483647\\n        MIN_VAL = -2147483648\\n        MAX_VAL = 2147483647\\n        \\n        # If divisor is 1 or -1\\n        if abs(divisor) == 1:\\n            if dividend == MIN_VAL and divisor == -1:\\n                return MAX_VAL\\n            else:\\n                return dividend if divisor > 0 else -dividend\\n            \\n        # Get if the answer will be negative or positive\\n        sign = -1 if (dividend < 0 and divisor > 0) or (divisor < 0 and dividend > 0) else 1\\n        res = 0 # result\\n        shift = 31 # At max 31 left shift can be done on a integer value \\n        dividend = abs(dividend) # always take absolute value\\n        divisor = abs(divisor) # always take absolute value\\n        \\n        # While dividend is greater than divisor\\n        while dividend >= divisor:\\n            \\n            # Check how many shifts require of divisor\\n            # to reach dividend in whole\\n            while dividend < (divisor << shift):\\n                shift -= 1\\n            \\n            # subtract the left shifted divisor from dividend\\n            # and do the same process for the remaining value\\n            dividend = dividend - (divisor<<shift)\\n            \\n            # Answer will be how many total left shifted value of 1\\n            res = res + (1<<shift)\\n\\n        # return result within range and with proper sign\\n        res = min(MAX_VAL, max(MIN_VAL, res))\\n        \\n        # return\\n        return  res if sign > 0 else -res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        # -2147483648 through 2147483647\\n        MIN_VAL = -2147483648\\n        MAX_VAL = 2147483647\\n        \\n        # If divisor is 1 or -1\\n        if abs(divisor) == 1:\\n            if dividend == MIN_VAL and divisor == -1:\\n                return MAX_VAL\\n            else:\\n                return dividend if divisor > 0 else -dividend\\n            \\n        # Get if the answer will be negative or positive\\n        sign = -1 if (dividend < 0 and divisor > 0) or (divisor < 0 and dividend > 0) else 1\\n        res = 0 # result\\n        shift = 31 # At max 31 left shift can be done on a integer value \\n        dividend = abs(dividend) # always take absolute value\\n        divisor = abs(divisor) # always take absolute value\\n        \\n        # While dividend is greater than divisor\\n        while dividend >= divisor:\\n            \\n            # Check how many shifts require of divisor\\n            # to reach dividend in whole\\n            while dividend < (divisor << shift):\\n                shift -= 1\\n            \\n            # subtract the left shifted divisor from dividend\\n            # and do the same process for the remaining value\\n            dividend = dividend - (divisor<<shift)\\n            \\n            # Answer will be how many total left shifted value of 1\\n            res = res + (1<<shift)\\n\\n        # return result within range and with proper sign\\n        res = min(MAX_VAL, max(MIN_VAL, res))\\n        \\n        # return\\n        return  res if sign > 0 else -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401070,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t// checking for overflow\\n        if(dividend == 1<<31 && divisor == -1) return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t// deciding the sign of the quotient\\n        boolean sign = (dividend>=0) == (divisor >=0) ? true : false;\\n\\t\\t\\n\\t\\t//using absolute values for the answer\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n\\t\\t\\n\\t\\t// our answer\\n        int result=0; \\n\\t\\t\\n        while(dividend - divisor >= 0 ){\\n\\t\\t // the number of times we need to left shift (or double our divisor)\\n            int count=0;\\n\\t\\t\\t\\n\\t\\t\\t// increment count till we can subtract the doubled divisor form dividend\\n            while(dividend  - (divisor<<1<<count) >= 0 ){\\n                count++; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t // incrementing quotient by the power of 2 by which we multiplied divisor\\n\\t\\t\\t// 2 power x can be written as 1<<x\\n            result += 1 << count;\\n\\t\\t\\t\\n\\t\\t\\t// decrease the dividend by the maximum value we can subtract\\n\\t\\t\\t//which is divisor*(2 power count)\\n            dividend -= divisor << count ; \\n        }\\n\\t\\t // if sign is false it means negative quotient\\n        return sign?result: -result ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t// checking for overflow\\n        if(dividend == 1<<31 && divisor == -1) return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t// deciding the sign of the quotient\\n        boolean sign = (dividend>=0) == (divisor >=0) ? true : false;\\n\\t\\t\\n\\t\\t//using absolute values for the answer\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n\\t\\t\\n\\t\\t// our answer\\n        int result=0; \\n\\t\\t\\n        while(dividend - divisor >= 0 ){\\n\\t\\t // the number of times we need to left shift (or double our divisor)\\n            int count=0;\\n\\t\\t\\t\\n\\t\\t\\t// increment count till we can subtract the doubled divisor form dividend\\n            while(dividend  - (divisor<<1<<count) >= 0 ){\\n                count++; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t // incrementing quotient by the power of 2 by which we multiplied divisor\\n\\t\\t\\t// 2 power x can be written as 1<<x\\n            result += 1 << count;\\n\\t\\t\\t\\n\\t\\t\\t// decrease the dividend by the maximum value we can subtract\\n\\t\\t\\t//which is divisor*(2 power count)\\n            dividend -= divisor << count ; \\n        }\\n\\t\\t // if sign is false it means negative quotient\\n        return sign?result: -result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258780,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\n    int divide(int dividend, int divisor) {\\n        if (divisor == INT_MIN) {\\n            if (dividend == INT_MIN) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        if (dividend == INT_MIN) {\\n            if (divisor == -1) {\\n                return INT_MAX;\\n            } \\n            if (divisor > 0) {\\n                return -1+divide(dividend+divisor, divisor);\\n            } else if (divisor < 0) {\\n                return 1+divide(dividend-divisor, divisor);\\n            }\\n        }\\n        \\n        int sign = 1;\\n        if ((dividend >0 && divisor <0) || (dividend <0 && divisor >0)) {\\n            sign = -1;\\n        }\\n        dividend=abs(dividend);\\n        divisor=abs(divisor);\\n        int remainder = dividend, quotient = 0;\\n        while (remainder >= divisor) {\\n            int shift = 0;\\n            while ((divisor<<shift) <= remainder && (divisor<<shift)>0 ) {\\n                ++shift;\\n            }\\n            --shift;\\n            quotient += (1<<shift);\\n            remainder -= (divisor<<shift);\\n        }\\n        if (sign < 0) quotient = -quotient;\\n        return quotient;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int divide(int dividend, int divisor) {\\n        if (divisor == INT_MIN) {\\n            if (dividend == INT_MIN) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        if (dividend == INT_MIN) {\\n            if (divisor == -1) {\\n                return INT_MAX;\\n            } \\n            if (divisor > 0) {\\n                return -1+divide(dividend+divisor, divisor);\\n            } else if (divisor < 0) {\\n                return 1+divide(dividend-divisor, divisor);\\n            }\\n        }\\n        \\n        int sign = 1;\\n        if ((dividend >0 && divisor <0) || (dividend <0 && divisor >0)) {\\n            sign = -1;\\n        }\\n        dividend=abs(dividend);\\n        divisor=abs(divisor);\\n        int remainder = dividend, quotient = 0;\\n        while (remainder >= divisor) {\\n            int shift = 0;\\n            while ((divisor<<shift) <= remainder && (divisor<<shift)>0 ) {\\n                ++shift;\\n            }\\n            --shift;\\n            quotient += (1<<shift);\\n            remainder -= (divisor<<shift);\\n        }\\n        if (sign < 0) quotient = -quotient;\\n        return quotient;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213715,
                "title": "simple-without-bitwise",
                "content": "\\n    public int divide(int dividend, int divisor) {\\n     \\n        if(dividend == 0)  return 0;\\n    \\n        if(dividend == Integer.MIN_VALUE && divisor == -1)  return Integer.MAX_VALUE;\\n          \\n        boolean Negative = true;\\n       \\n        if((dividend < 0 && divisor < 0) || (dividend > 0 && divisor > 0))\\n           Negative = false;\\n\\n        if(dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        if(divisor > 0) {\\n            divisor = 0 - divisor;\\n        }\\n\\n        int quotient = 0;\\n        while(dividend <= divisor) {\\n            dividend = dividend - divisor;\\n            quotient++;\\n        }\\n        \\n        if(Negative && quotient > 0)    return 0 - quotient;\\n        \\n         else     return quotient;\\n        \\n    \\n}",
                "solutionTags": [],
                "code": "\\n    public int divide(int dividend, int divisor) {\\n     \\n        if(dividend == 0)  return 0;\\n    \\n        if(dividend == Integer.MIN_VALUE && divisor == -1)  return Integer.MAX_VALUE;\\n          \\n        boolean Negative = true;\\n       \\n        if((dividend < 0 && divisor < 0) || (dividend > 0 && divisor > 0))\\n           Negative = false;\\n\\n        if(dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        if(divisor > 0) {\\n            divisor = 0 - divisor;\\n        }\\n\\n        int quotient = 0;\\n        while(dividend <= divisor) {\\n            dividend = dividend - divisor;\\n            quotient++;\\n        }\\n        \\n        if(Negative && quotient > 0)    return 0 - quotient;\\n        \\n         else     return quotient;\\n        \\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1087238,
                "title": "java-no-long-no-bitwise-log-n-solution-with-explanation",
                "content": "```\\nclass Solution {\\n\\t// Can specify the exact half value here as well instead of using the divide symbol\\n\\tint HALF_INT_MIN = Integer.MIN_VALUE/2;\\n\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t// Satisfying the overflow condition as specified in the problem\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) \\n            return Integer.MAX_VALUE;     \\n        \\n\\t\\t// Determining if the output result should be positive or negative;\\n        boolean isResultNegative = (divisor < 0) ^ (dividend < 0);\\n        \\n\\t\\t// Converting dividend and divisor to negative values to satisfy the overflow boundary conditions\\n        dividend = dividend > 0 ? -dividend : dividend;\\n        divisor = divisor > 0 ? -divisor : divisor;        \\n\\n\\t\\t// Defining 2 arrays, one for the powers of 2 that reaches upto the quotient and the other one the doubles of divisor\\n        List<Integer> powersOf2 = new ArrayList<>();\\n        List<Integer> doublesOfDivisor = new ArrayList<>();        \\n        \\n\\t\\t// Populating the 2 arrays\\n\\t\\tint powerOf2 = 1;        \\n        while(dividend <= divisor){\\n            powersOf2.add(powerOf2);\\n            doublesOfDivisor.add(divisor);\\n\\t\\t\\t// This condition check is for overflow condition check\\n            if (divisor < HALF_INT_MIN) \\n                break;                    \\n            powerOf2 += powerOf2;\\n            divisor += divisor;\\n        }\\n        \\n\\t\\t// Now we can iterate through the multiple of divisor list to calculate the quotient -\\n\\t\\t// The quotient of current dividend is the respective power of 2 (number when multiplied with original divisor). \\n\\t\\t// Some part of remainder can again be part of the quotient so we reduce dividend by subtracting it from the corresponding multiple of divisor\\n        int quotient = 0;\\n        for(int i=doublesOfDivisor.size()-1; i >= 0 ;i--){\\n            if(dividend <= doublesOfDivisor.get(i)){\\n                quotient += powersOf2.get(i);\\n                dividend -= doublesOfDivisor.get(i);\\n            }\\n        }\\n        \\n        return isResultNegative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t// Can specify the exact half value here as well instead of using the divide symbol\\n\\tint HALF_INT_MIN = Integer.MIN_VALUE/2;\\n\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t// Satisfying the overflow condition as specified in the problem\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) \\n            return Integer.MAX_VALUE;     \\n        \\n\\t\\t// Determining if the output result should be positive or negative;\\n        boolean isResultNegative = (divisor < 0) ^ (dividend < 0);\\n        \\n\\t\\t// Converting dividend and divisor to negative values to satisfy the overflow boundary conditions\\n        dividend = dividend > 0 ? -dividend : dividend;\\n        divisor = divisor > 0 ? -divisor : divisor;        \\n\\n\\t\\t// Defining 2 arrays, one for the powers of 2 that reaches upto the quotient and the other one the doubles of divisor\\n        List<Integer> powersOf2 = new ArrayList<>();\\n        List<Integer> doublesOfDivisor = new ArrayList<>();        \\n        \\n\\t\\t// Populating the 2 arrays\\n\\t\\tint powerOf2 = 1;        \\n        while(dividend <= divisor){\\n            powersOf2.add(powerOf2);\\n            doublesOfDivisor.add(divisor);\\n\\t\\t\\t// This condition check is for overflow condition check\\n            if (divisor < HALF_INT_MIN) \\n                break;                    \\n            powerOf2 += powerOf2;\\n            divisor += divisor;\\n        }\\n        \\n\\t\\t// Now we can iterate through the multiple of divisor list to calculate the quotient -\\n\\t\\t// The quotient of current dividend is the respective power of 2 (number when multiplied with original divisor). \\n\\t\\t// Some part of remainder can again be part of the quotient so we reduce dividend by subtracting it from the corresponding multiple of divisor\\n        int quotient = 0;\\n        for(int i=doublesOfDivisor.size()-1; i >= 0 ;i--){\\n            if(dividend <= doublesOfDivisor.get(i)){\\n                quotient += powersOf2.get(i);\\n                dividend -= doublesOfDivisor.get(i);\\n            }\\n        }\\n        \\n        return isResultNegative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084789,
                "title": "ruby-bit-manipulation",
                "content": "```\\n# @param {Integer} dividend\\n# @param {Integer} divisor\\n# @return {Integer}\\ndef divide(dividend, divisor)\\n  sign = (divisor > 0) ^ (dividend > 0) ? -1 : 1\\n\\t\\t\\n  return 2**31-1 if dividend == -2**31 && divisor == -1\\n\\n  dividend = dividend.abs\\n  divisor = divisor.abs\\n  result = 0\\n  \\n  while divisor <= dividend\\n    div = divisor\\n    temp = 1\\n    while (div << 1) <= dividend\\n      temp <<= 1\\n      div <<= 1\\n    end\\n    dividend -= div\\n    result += temp\\n  end\\n  \\n  result*sign \\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bit Manipulation"
                ],
                "code": "```\\n# @param {Integer} dividend\\n# @param {Integer} divisor\\n# @return {Integer}\\ndef divide(dividend, divisor)\\n  sign = (divisor > 0) ^ (dividend > 0) ? -1 : 1\\n\\t\\t\\n  return 2**31-1 if dividend == -2**31 && divisor == -1\\n\\n  dividend = dividend.abs\\n  divisor = divisor.abs\\n  result = 0\\n  \\n  while divisor <= dividend\\n    div = divisor\\n    temp = 1\\n    while (div << 1) <= dividend\\n      temp <<= 1\\n      div <<= 1\\n    end\\n    dividend -= div\\n    result += temp\\n  end\\n  \\n  result*sign \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1020340,
                "title": "shame-on-this-challange",
                "content": "To quote the website exactly, we will solve the following \"challange\":\\n> Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\\n\\n> Return the quotient after dividing dividend by divisor.\\n\\n> The integer division should truncate toward zero, which means losing its fractional part.\\n> For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.\\n\\n> Note:\\n>  Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [-2^31,  2^31 \\u2212 1].\\n>  For this problem, assume that your function returns 2^31 - 1 when the division result overflows.\\n\\nSounds easy enough, that is to people who studied a computer systems course.\\nFirst let\\'s look at a few of the \"best\" submissions that straight up violate the rules:\\n\\n1. Division operator used\\n```\\nint divide(long long dividend, long long divisor){\\n    if(dividend/divisor>pow(2,31)-1)\\n        return (pow(2,31)-1);//\\u7576\\u7D50\\u679C\\u6EA2\\u4F4D\\u6642\\u8FD4\\u56DE2^31\\u22121\\n    else\\n        return (dividend/divisor);//\\u5176\\u4ED6\\u76F4\\u63A5\\u9664\\u518D\\u8FD4\\u56DE\\u5176\\u7D50\\u679C(\\u56E0\\u6574\\u6578\\u7684\\u9664\\u6CD5\\u6703\\u76F4\\u63A5\\u6368\\u68C4\\u5C0F\\u6578\\uFF0C\\u8F38\\u51FA\\u6574\\u6578\\u503C)\\n}\\n```\\n\\n2. Impressive if ladder for sure, but the pesky division operator is still there\\n```\\n#define INT_MAX 2147483647\\n#define INT_MIN (-INT_MAX - 1)\\n\\nint divide(int dividend, int divisor){\\n    printf( \"%d\\\\n%d\", dividend, divisor );\\n    int output = 0;\\n    if ( ( dividend == 0 ) || ( divisor == 0 ) ) return 0;\\n    else if ( ( dividend <= INT_MIN ) && ( divisor < 0 ) && ( divisor != INT_MIN )  ) dividend = -INT_MAX;\\n    // else if ( ( dividend >= INT_MAX ) || ( dividend <= INT_MIN ) ) return 0;\\n    // else if ( ( divisor >= INT_MAX ) || ( divisor <= INT_MIN ) ) return 0;\\n    output = dividend / divisor;\\n    // printf(\"%d\\\\n\",output);\\n    return output;\\n}\\n```\\n\\nSo your software restoring division (or something similar) algorithm will compete against cheaters using\\ndivision hardware, no wonder you rank poorly.\\n\\nIn the end it doesn\\'t matter, as this problem in reality is asking for an algorithm that is of no use to any programmer,\\naka implementing division in software. It has a horrible number of edge cases with integer overflow, and is definitely\\nnot of \"medium\" difficulty to anyone, but a hardware designer.\\n\\nLet\\'s see the (terrible and pointless) code I came up with that should fit the requirements:\\n```\\n// This function implements restoring division taking two 32-bit unsigned inputs\\n// and outputs a 32-bit unsigned quotient, with no overflow possible\\nunsigned udiv(unsigned dividend, unsigned divisor) {\\n    unsigned quo = 0;\\n    unsigned long rem = dividend;\\n    unsigned long div = (unsigned long) divisor << 32;\\n\\n    for (int i = 0; i < 32; ++i) {\\n        rem <<= 1;\\n        if (rem >= div) {\\n            rem -= div;\\n            quo = quo << 1 | 1;\\n        } else {\\n            quo <<= 1;\\n        }\\n    }\\n\\n    return quo;\\n}\\n\\n// This function does a bunch of horrific edge case checking to\\n// make sure no integer overflow is possible\\nint divide(int dividend, int divisor) {\\n    int sgn = 0;\\n\\n    unsigned u_dividend;\\n    if (dividend < 0) {\\n        u_dividend = -(long)dividend;\\n        sgn ^= 1;\\n    } else {\\n        u_dividend = dividend;\\n    }\\n    unsigned u_divisor;\\n    if (divisor < 0) {\\n        u_divisor = -(long)divisor;\\n        sgn ^= 1;\\n    } else {\\n        u_divisor = divisor;\\n    }\\n\\n    unsigned u_result = udiv(u_dividend, u_divisor);\\n\\n    if (sgn) {\\n        if (-(long) u_result < INT_MIN)\\n            return INT_MAX;\\n        return -u_result;\\n    } else {\\n        if (u_result > INT_MAX)\\n            return  INT_MAX;\\n        return u_result;\\n    }\\n}\\n```\\n\\nTo add insult to injury, LeetCode is not able to actually measure the runtime of\\nany reasonable fast C code, so it presents mine and the two cheaters above as\\nhaving a \"0 ms\" runtime, and just as good. While mine is obviously slower, it\\nactually does what the question is asking.\\n",
                "solutionTags": [],
                "code": "```\\nint divide(long long dividend, long long divisor){\\n    if(dividend/divisor>pow(2,31)-1)\\n        return (pow(2,31)-1);//\\u7576\\u7D50\\u679C\\u6EA2\\u4F4D\\u6642\\u8FD4\\u56DE2^31\\u22121\\n    else\\n        return (dividend/divisor);//\\u5176\\u4ED6\\u76F4\\u63A5\\u9664\\u518D\\u8FD4\\u56DE\\u5176\\u7D50\\u679C(\\u56E0\\u6574\\u6578\\u7684\\u9664\\u6CD5\\u6703\\u76F4\\u63A5\\u6368\\u68C4\\u5C0F\\u6578\\uFF0C\\u8F38\\u51FA\\u6574\\u6578\\u503C)\\n}\\n```\n```\\n#define INT_MAX 2147483647\\n#define INT_MIN (-INT_MAX - 1)\\n\\nint divide(int dividend, int divisor){\\n    printf( \"%d\\\\n%d\", dividend, divisor );\\n    int output = 0;\\n    if ( ( dividend == 0 ) || ( divisor == 0 ) ) return 0;\\n    else if ( ( dividend <= INT_MIN ) && ( divisor < 0 ) && ( divisor != INT_MIN )  ) dividend = -INT_MAX;\\n    // else if ( ( dividend >= INT_MAX ) || ( dividend <= INT_MIN ) ) return 0;\\n    // else if ( ( divisor >= INT_MAX ) || ( divisor <= INT_MIN ) ) return 0;\\n    output = dividend / divisor;\\n    // printf(\"%d\\\\n\",output);\\n    return output;\\n}\\n```\n```\\n// This function implements restoring division taking two 32-bit unsigned inputs\\n// and outputs a 32-bit unsigned quotient, with no overflow possible\\nunsigned udiv(unsigned dividend, unsigned divisor) {\\n    unsigned quo = 0;\\n    unsigned long rem = dividend;\\n    unsigned long div = (unsigned long) divisor << 32;\\n\\n    for (int i = 0; i < 32; ++i) {\\n        rem <<= 1;\\n        if (rem >= div) {\\n            rem -= div;\\n            quo = quo << 1 | 1;\\n        } else {\\n            quo <<= 1;\\n        }\\n    }\\n\\n    return quo;\\n}\\n\\n// This function does a bunch of horrific edge case checking to\\n// make sure no integer overflow is possible\\nint divide(int dividend, int divisor) {\\n    int sgn = 0;\\n\\n    unsigned u_dividend;\\n    if (dividend < 0) {\\n        u_dividend = -(long)dividend;\\n        sgn ^= 1;\\n    } else {\\n        u_dividend = dividend;\\n    }\\n    unsigned u_divisor;\\n    if (divisor < 0) {\\n        u_divisor = -(long)divisor;\\n        sgn ^= 1;\\n    } else {\\n        u_divisor = divisor;\\n    }\\n\\n    unsigned u_result = udiv(u_dividend, u_divisor);\\n\\n    if (sgn) {\\n        if (-(long) u_result < INT_MIN)\\n            return INT_MAX;\\n        return -u_result;\\n    } else {\\n        if (u_result > INT_MAX)\\n            return  INT_MAX;\\n        return u_result;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981274,
                "title": "neat-python3-solution-fast-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        res = 0\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val+val <= dividend:\\n                val += val\\n                n += n\\n            dividend = dividend - val\\n            res += n\\n        \\n        if sign == 1:\\n            return min(res, 2**31-1)\\n        else:\\n            return max(-res, -2**31)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        res = 0\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val+val <= dividend:\\n                val += val\\n                n += n\\n            dividend = dividend - val\\n            res += n\\n        \\n        if sign == 1:\\n            return min(res, 2**31-1)\\n        else:\\n            return max(-res, -2**31)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937330,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        res = 0\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val + val <= dividend:\\n                val += val\\n                n += n\\n            \\n            res += n\\n            dividend -= val\\n\\n        \\n        if sign == 1:\\n            return min(res, 2**31 -1)\\n        else: \\n            return max(-res, -2**31)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        res = 0\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val + val <= dividend:\\n                val += val\\n                n += n\\n            \\n            res += n\\n            dividend -= val\\n\\n        \\n        if sign == 1:\\n            return min(res, 2**31 -1)\\n        else: \\n            return max(-res, -2**31)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887275,
                "title": "python-2-solutions-recursion-non-recursion-clean-concise-o-log-n-2",
                "content": "**Solution 1: Recursion**\\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        def helper(a, b):\\n            if a < b: return 0\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            return multiply + helper(a - sum, b)\\n        \\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        ans = helper(abs(a), abs(b))\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\\nComplexity:\\n- Time: `O(log(N) ^ 2)`, where `N` is absolute value of `dividend`\\n\\n**Solution 2: Non recursion**\\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        a, b = abs(a), abs(b)\\n        ans = 0\\n        while a >= b:\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            ans += multiply\\n            a -= sum\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\\nComplexity:\\n- Time: `O(log(N) ^ 2)`, where `N` is absolute value of `dividend`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        def helper(a, b):\\n            if a < b: return 0\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            return multiply + helper(a - sum, b)\\n        \\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        ans = helper(abs(a), abs(b))\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        a, b = abs(a), abs(b)\\n        ans = 0\\n        while a >= b:\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            ans += multiply\\n            a -= sum\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829428,
                "title": "java-binary-long-division-o-31",
                "content": "\\n```\\npublic int divide(int dividend, int divisor) {\\n        if (dividend == -Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n\\n        // Convert to +ves\\n        int negs = 0;\\n        if (dividend < 0) {\\n            negs++;\\n            dividend = -dividend;\\n        }\\n        if (divisor < 0) {\\n            negs++;\\n            divisor = -divisor;\\n        }\\n\\n        /**\\n         * Will do binary long division\\n         * starting from Left most bit of \\'dividend\\' (32),\\n         * going through the bits, comparing with \\'divisor\\'\\n         * and as and when results in \\'>= 0\\' get reminder\\n         * and append to quotient\\n         */\\n        int q = 0;\\n        int x = 31;\\n        while (x >= 0) {\\n            //Unsigned shift to handle case where dividend = Integer.MIN_VALUE\\n            //In which case -Integer.MIN_VALUE will also be Integer.MIN_VALUE\\n            if ((dividend >>> x) - divisor >= 0) {\\n                q += 1 << x;\\n                dividend -= divisor << x;\\n            }\\n            x--;\\n        }\\n\\n        if (negs == 1) //If only one of dividend/divisor is -Ve result as well is\\n            q = -q;\\n\\n        return q;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int divide(int dividend, int divisor) {\\n        if (dividend == -Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n\\n        // Convert to +ves\\n        int negs = 0;\\n        if (dividend < 0) {\\n            negs++;\\n            dividend = -dividend;\\n        }\\n        if (divisor < 0) {\\n            negs++;\\n            divisor = -divisor;\\n        }\\n\\n        /**\\n         * Will do binary long division\\n         * starting from Left most bit of \\'dividend\\' (32),\\n         * going through the bits, comparing with \\'divisor\\'\\n         * and as and when results in \\'>= 0\\' get reminder\\n         * and append to quotient\\n         */\\n        int q = 0;\\n        int x = 31;\\n        while (x >= 0) {\\n            //Unsigned shift to handle case where dividend = Integer.MIN_VALUE\\n            //In which case -Integer.MIN_VALUE will also be Integer.MIN_VALUE\\n            if ((dividend >>> x) - divisor >= 0) {\\n                q += 1 << x;\\n                dividend -= divisor << x;\\n            }\\n            x--;\\n        }\\n\\n        if (negs == 1) //If only one of dividend/divisor is -Ve result as well is\\n            q = -q;\\n\\n        return q;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 824443,
                "title": "100-faster-solution-using-bit-manipulation-in-cpp",
                "content": "```\\n//----------------------------Upvote if u loved the solution---------------------------------------------------------------\\n\\n\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)\\n            return INT_MAX;\\n        long dv=labs(dividend),ds=labs(divisor),ans=0,flag=0;\\n        if((dividend<0&&divisor>0)||(dividend>0&&divisor<0))\\n            flag=1;\\n        while(ds<=dv){\\n            long temp=ds,m=1;\\n            while(temp<<1<dv){\\n                temp<<=1;\\n                m<<=1;\\n            }\\n            ans+=m;\\n            dv-=temp;\\n        }\\n        if(flag)\\n            return -ans;\\n        return ans;\\n    }\\n\\t\\n\\t\\n//----------------------------Upvote if u loved the solution-------------------------------------------------------------\\n```",
                "solutionTags": [],
                "code": "```\\n//----------------------------Upvote if u loved the solution---------------------------------------------------------------\\n\\n\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)\\n            return INT_MAX;\\n        long dv=labs(dividend),ds=labs(divisor),ans=0,flag=0;\\n        if((dividend<0&&divisor>0)||(dividend>0&&divisor<0))\\n            flag=1;\\n        while(ds<=dv){\\n            long temp=ds,m=1;\\n            while(temp<<1<dv){\\n                temp<<=1;\\n                m<<=1;\\n            }\\n            ans+=m;\\n            dv-=temp;\\n        }\\n        if(flag)\\n            return -ans;\\n        return ans;\\n    }\\n\\t\\n\\t\\n//----------------------------Upvote if u loved the solution-------------------------------------------------------------\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777656,
                "title": "o-log-dividend-solution-python",
                "content": "\\n\\n    def divide(self, dividend, divisor):\\n        #The final Sign        \\n        sign = (dividend < 0) != (divisor < 0)\\n        \\n        #Absolute of dividend\\n        dividend = abs(dividend)\\n        \\n        #Absolute of divisor\\n        divisor = abs(divisor)\\n\\n        #Let\\'s Search at O(log(dividend)) complexity \\n        \\n        bit_width = 32\\n        remainder = 0\\n        modulus = 0\\n        for i in range(bit_width - 1 , -1, -1):\\n            \\n            # If we found a big 2^i slice that can be subtracted\\n            # Slice it off and search for the remaining value \\n            slice = divisor << i \\n            if remainder + slice <= dividend:\\n                remainder += slice\\n                # Since we \"add\" only less significant bits\\n                # The Addition can be replaced by Bitwise OR\\n                modulus = modulus | (1 << i)         \\n            # If the slice does not fit we continue\\n            # With the next possible slice\\n        \\n        if sign:\\n            return max(-modulus, -2147483648)\\n        else:\\n            return min( modulus,  2147483647)",
                "solutionTags": [],
                "code": "\\n\\n    def divide(self, dividend, divisor):\\n        #The final Sign        \\n        sign = (dividend < 0) != (divisor < 0)\\n        \\n        #Absolute of dividend\\n        dividend = abs(dividend)\\n        \\n        #Absolute of divisor\\n        divisor = abs(divisor)\\n\\n        #Let\\'s Search at O(log(dividend)) complexity \\n        \\n        bit_width = 32\\n        remainder = 0\\n        modulus = 0\\n        for i in range(bit_width - 1 , -1, -1):\\n            \\n            # If we found a big 2^i slice that can be subtracted\\n            # Slice it off and search for the remaining value \\n            slice = divisor << i \\n            if remainder + slice <= dividend:\\n                remainder += slice\\n                # Since we \"add\" only less significant bits\\n                # The Addition can be replaced by Bitwise OR\\n                modulus = modulus | (1 << i)         \\n            # If the slice does not fit we continue\\n            # With the next possible slice\\n        \\n        if sign:\\n            return max(-modulus, -2147483648)\\n        else:\\n            return min( modulus,  2147483647)",
                "codeTag": "Python3"
            },
            {
                "id": 554646,
                "title": "c-o-1-solution-runtime-beats-100",
                "content": "Math logic:\\n\\t\\na/b = e^(log(a) - log(b)) \\nSince log(a/b) is equal to log(a) - log(b), raise it to e power as e and log undo each other\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if (a == INT_MAX && b == INT_MIN) return 0;\\n        int x = a;\\n        int y = b;\\n        bool neg1 = 0, neg2 = 0;\\n        if (a < 0) neg1 = 1;\\n        if (b < 0) neg2 = 1; \\n        a = (a == INT_MIN) ? INT_MAX : abs(a);\\n        b = (b == INT_MIN) ? INT_MAX : abs(b);\\n        int ans = exp(log(a) - log(b));\\n        if (neg1 && neg2) return ans;\\n        else if (neg1 || neg2) return ans == INT_MAX ? INT_MIN : \\n                                        ((x == INT_MIN && y == 2) ? -ans-1 :-ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if (a == INT_MAX && b == INT_MIN) return 0;\\n        int x = a;\\n        int y = b;\\n        bool neg1 = 0, neg2 = 0;\\n        if (a < 0) neg1 = 1;\\n        if (b < 0) neg2 = 1; \\n        a = (a == INT_MIN) ? INT_MAX : abs(a);\\n        b = (b == INT_MIN) ? INT_MAX : abs(b);\\n        int ans = exp(log(a) - log(b));\\n        if (neg1 && neg2) return ans;\\n        else if (neg1 || neg2) return ans == INT_MAX ? INT_MIN : \\n                                        ((x == INT_MIN && y == 2) ? -ans-1 :-ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549683,
                "title": "java-o-lgn-time-o-1-space-no-bit-shift-no-long",
                "content": "I checked through all the solutions here and observed these trends:\\n- A lot of solutions use `long`, which violated the requirements of this problem\\n- Bit shift makes the code less readable\\n\\n This solution is similar to Approach 4 in this [solution](https://leetcode.com/problems/divide-two-integers/solution/). But instead of bit shifting, I am using plus and minus operations only. Below are the steps:\\n- First, we check for the special case `dividend == Integer.MIN_VALUE && divisor == -1`\\n- We get the absolute value of dividend and divisor\\n- Do the division for 2 positive numbers using \"Adding Powers Of Two\" technique\\n\\nA note on the check `dividend - divisor >= 0` instead of `divisor <= dividend` is to handle the corner case where original `dividend = Integer.MIN_VALUE` and `absDividend = Integer.MIN_VALUE`. \\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n\\n        int absDividend = getAbs(dividend);\\n        int absDivisor = getAbs(divisor);\\n        int res = dividePositive(absDividend, absDivisor);\\n        return (dividend > 0) == (divisor > 0) ? res : -res;\\n    }\\n    \\n    int getAbs(int num) {\\n        return num < 0 ? -num : num;\\n    }\\n    \\n    int dividePositive(int dividend, int divisor) {\\n        int count = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            int cur = divisor;\\n            int steps = 1; \\n            while (dividend - (cur + cur) > 0) {\\n                cur = cur + cur;\\n                steps += steps;\\n            }\\n            count += steps;\\n            dividend = dividend - cur;\\n        }\\n        \\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n\\n        int absDividend = getAbs(dividend);\\n        int absDivisor = getAbs(divisor);\\n        int res = dividePositive(absDividend, absDivisor);\\n        return (dividend > 0) == (divisor > 0) ? res : -res;\\n    }\\n    \\n    int getAbs(int num) {\\n        return num < 0 ? -num : num;\\n    }\\n    \\n    int dividePositive(int dividend, int divisor) {\\n        int count = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            int cur = divisor;\\n            int steps = 1; \\n            while (dividend - (cur + cur) > 0) {\\n                cur = cur + cur;\\n                steps += steps;\\n            }\\n            count += steps;\\n            dividend = dividend - cur;\\n        }\\n        \\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566062,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565701,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565492,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566906,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566683,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1820777,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566695,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566912,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566469,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566444,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566062,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565701,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565492,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566906,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566683,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1820777,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566695,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566912,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566469,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566444,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1568689,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1568341,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567137,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1568290,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1566739,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567540,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1569289,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1874916,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567735,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567731,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1979403,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1929966,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1840585,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816498,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568477,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568331,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568111,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567815,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1566392,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1962762,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1570818,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1576037,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1570024,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1569624,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1569408,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568849,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568850,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568851,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568548,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1858559,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1803482,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1734718,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576500,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576029,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576026,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1575168,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1574339,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1574140,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1572931,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1572613,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1571072,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571071,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571075,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571076,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571077,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571078,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571079,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571080,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1576825,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1574983,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1573475,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2067311,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2055990,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2055445,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2050348,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2039619,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2026681,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1996576,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1976165,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1975112,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1966655,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1966415,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1956654,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1951407,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1950343,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1944023,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1927471,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1913151,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1906055,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1900273,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1899087,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1896844,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1890247,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1875356,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1870594,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1869263,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1866761,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1855176,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1852708,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1846237,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1845848,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1841568,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1840442,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1834980,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1827868,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1824198,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1823408,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1819980,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1819431,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1818772,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1810021,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1808333,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1807452,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1804280,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1803658,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1803105,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1802264,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1797100,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1795698,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1795003,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1794172,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1791787,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778332,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1764711,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1762923,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1761438,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1757201,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1754878,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1753143,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1752956,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1751661,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740547,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1734768,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1731871,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729208,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729170,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728779,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728067,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1726065,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724578,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724023,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1722109,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1720936,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1719339,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1709932,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1709351,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1707888,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1700876,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1699724,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1693543,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1684081,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1678534,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1671289,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1666480,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1654024,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1649596,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1627800,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1570090,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1575027,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1574713,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            }
        ]
    }
]