[
    {
        "title": "Minimum Time to Eat All Grains",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Form Smallest Number From Two Digit Arrays",
        "question_content": "Given two arrays of <strong>unique</strong> digits <code>nums1</code> and <code>nums2</code>, return <em>the <strong>smallest</strong> number that contains <strong>at least</strong> one digit from each array</em>.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,1,3], nums2 = [5,7]\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,5,2,6], nums2 = [3,1,7]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The number 3 contains the digit 3 which exists in both arrays.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 9</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li>All digits in each array are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3366601,
                "title": "c-easiest-solution-ever-for-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are making a frequency array of values that are present in `nums1` and `nums2`. If the frequency of any element in this means it is present in both the array. So we will return the smallest number with frequecy 2. \\nOtherwise, we will fetch the smallest numbers from `nums1` andn `nums2` and will return the smallest number from their combination.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple. Read the intuition and see the code, you will understand the solution easily\\n\\n# Complexity\\n- Time complexity: O(1) : Size of both arrays is less than 10.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> freq(10);\\n        for(int i=0; i<nums1.size(); i++) freq[nums1[i]]++;\\n        for(int i=0; i<nums2.size(); i++) freq[nums2[i]]++;\\n            \\n        int k=2;\\n        int ans =0;\\n        int mn1 = *min_element(nums1.begin(), nums1.end());\\n        int mn2 = *min_element(nums2.begin(), nums2.end());\\n        for(int i=1; i<=9; i++)\\n            if(freq[i]==2) return i;\\n        \\n        if(mn2<mn1) swap(mn2, mn1);\\n        return mn1*10+mn2;\\n    }\\n};\\n// PLEASE UPVOTE THE SOLUTION IF IT HELPED YOU SOMEHOW\\n\\n```\\n![0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg](https://assets.leetcode.com/users/images/8832d8f0-1407-45e1-95c6-eba200006155_1680365505.4458308.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> freq(10);\\n        for(int i=0; i<nums1.size(); i++) freq[nums1[i]]++;\\n        for(int i=0; i<nums2.size(); i++) freq[nums2[i]]++;\\n            \\n        int k=2;\\n        int ans =0;\\n        int mn1 = *min_element(nums1.begin(), nums1.end());\\n        int mn2 = *min_element(nums2.begin(), nums2.end());\\n        for(int i=1; i<=9; i++)\\n            if(freq[i]==2) return i;\\n        \\n        if(mn2<mn1) swap(mn2, mn1);\\n        return mn1*10+mn2;\\n    }\\n};\\n// PLEASE UPVOTE THE SOLUTION IF IT HELPED YOU SOMEHOW\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366413,
                "title": "intersection",
                "content": "\\n**Python 3**\\n```python\\nclass Solution:\\n    def minNumber(self, n1: List[int], n2: List[int]) -> int:\\n        common, m1, m2 = set(n1).intersection(n2), min(n1), min(n2)\\n        return min(common) if common else min(m1, m2) * 10 + max(m1, m2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minNumber(self, n1: List[int], n2: List[int]) -> int:\\n        common, m1, m2 = set(n1).intersection(n2), min(n1), min(n2)\\n        return min(common) if common else min(m1, m2) * 10 + max(m1, m2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366407,
                "title": "java-python-3-using-set",
                "content": "\\n\\n```java\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = getHashSet(nums1), s2 = getHashSet(nums2);\\n        s1.retainAll(s2);\\n        if (!s1.isEmpty()) {\\n            return s1.stream().mapToInt(i -> i).min().getAsInt();\\n        }\\n        int a = IntStream.of(nums1).min().getAsInt();\\n        int b = IntStream.of(nums2).min().getAsInt();\\n        return Math.min(a, b) * 10 + Math.max(a, b);\\n    }\\n    private HashSet<Integer> getHashSet(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            set.add(num);\\n        }\\n        return set;\\n    }\\n```\\n```python\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        if s1 & s2:\\n            return min(s1 & s2)\\n        a, b = min(nums1), min(nums2)\\n        return min(a, b) * 10 + max(a, b)\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(m + n)`, where `m = nums1.length, n = nums2.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = getHashSet(nums1), s2 = getHashSet(nums2);\\n        s1.retainAll(s2);\\n        if (!s1.isEmpty()) {\\n            return s1.stream().mapToInt(i -> i).min().getAsInt();\\n        }\\n        int a = IntStream.of(nums1).min().getAsInt();\\n        int b = IntStream.of(nums2).min().getAsInt();\\n        return Math.min(a, b) * 10 + Math.max(a, b);\\n    }\\n    private HashSet<Integer> getHashSet(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            set.add(num);\\n        }\\n        return set;\\n    }\\n```\n```python\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        if s1 & s2:\\n            return min(s1 & s2)\\n        a, b = min(nums1), min(nums2)\\n        return min(a, b) * 10 + max(a, b)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366482,
                "title": "easiest-solution-in-n-2-no-fancy-solution-4-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int n=0,ans=INT_MAX;\\n        \\n        for(auto i:nums1){\\n            for(auto j:nums2){\\n                if(i==j) n=i;\\n                else n=min(i*10+j,j*10+i);\\n                ans=min(ans,n);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int n=0,ans=INT_MAX;\\n        \\n        for(auto i:nums1){\\n            for(auto j:nums2){\\n                if(i==j) n=i;\\n                else n=min(i*10+j,j*10+i);\\n                ans=min(ans,n);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366406,
                "title": "easy-short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int val = Integer.MAX_VALUE;\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                if(nums1[i] == nums2[j])  val = Math.min(val,nums1[i]);\\n                val = Math.min(val,Math.min(nums1[i]*10+nums2[j],nums2[j]*10+nums1[i]));\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int val = Integer.MAX_VALUE;\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                if(nums1[i] == nums2[j])  val = Math.min(val,nums1[i]);\\n                val = Math.min(val,Math.min(nums1[i]*10+nums2[j],nums2[j]*10+nums1[i]));\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366838,
                "title": "100-faster-and-easy-map-solution-with-explanation-using-c-my-approach-during-contest",
                "content": "**Step 1** : Sort both the Vectors.\\n\\n**Step 2** : Store the elements of nums1 into a map.\\n\\n**Step 3** : Now Traverse The map for each element in nums2 , if same element is found in both vectors return that element directly. \\n\\n**Step 4** : Simply return the nums1[0]*10 + nums2[0]   **if(nums1[0] < nums2[0])**\\nand nums2[0]*10 + nums1[0] **if(nums1[0] > nums2[0])**\\n\\n```\\nclass Solution {\\npublic:\\nint minNumber(vector<int> &nums1, vector<int> &nums2) {\\n\\n\\n    int n1 = nums1.size();\\n    int n2 = nums2.size();\\n    \\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n    \\n    \\n    map<int,int>map;   //Store the element of nums1 into a map.\\n    \\n    \\n    for(int i=0;i<n1;i++){\\n        map[nums1[i]]++;\\n    }\\n    \\n    // Now Traverse The map for each element in nums2 , if same element is found in both array return that element directly. \\n    for(int i=0;i<n2;i++){\\n        if(map.find(nums2[i])!=map.end()){\\n            return nums2[i];\\n        }\\n    }\\n\\n\\n \\n    if(nums1[0] < nums2[0]){\\n        return nums1[0]*10 + nums2[0];\\n    }\\n    else{\\n        return nums2[0]*10 + nums1[0];\\n    }\\n\\n\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minNumber(vector<int> &nums1, vector<int> &nums2) {\\n\\n\\n    int n1 = nums1.size();\\n    int n2 = nums2.size();\\n    \\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n    \\n    \\n    map<int,int>map;   //Store the element of nums1 into a map.\\n    \\n    \\n    for(int i=0;i<n1;i++){\\n        map[nums1[i]]++;\\n    }\\n    \\n    // Now Traverse The map for each element in nums2 , if same element is found in both array return that element directly. \\n    for(int i=0;i<n2;i++){\\n        if(map.find(nums2[i])!=map.end()){\\n            return nums2[i];\\n        }\\n    }\\n\\n\\n \\n    if(nums1[0] < nums2[0]){\\n        return nums1[0]*10 + nums2[0];\\n    }\\n    else{\\n        return nums2[0]*10 + nums1[0];\\n    }\\n\\n\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366789,
                "title": "simple-solution-with-1-won-extra-tip-to-remember-for-life-which-i-bet-no-won-will-provide",
                "content": "# Intuition\\nTHODA GYAN THODI BAKCHODI THODA CODE\\n\\n# Approach\\nSS\\nJUST SMILE AND SOLVE\\n\\n# Complexity\\nNOTHING COMPLEX\\n\\n# EXTRA TIP(GYAN)\\n![Bakchodi 1.jpg](https://assets.leetcode.com/users/images/68ea9a42-bce9-4ed3-85f3-843bd9e31ab6_1680367347.3906567.jpeg)\\n\\n\\n# POORA JAVA Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int sm=10,sm2=10,p=Integer.MAX_VALUE;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(sm>nums1[i])\\n                sm=nums1[i];\\n        }\\n         for(int i=0;i<nums2.length;i++)\\n        {\\n            if(sm2>nums2[i])\\n                sm2=nums2[i];\\n        }\\n        int x=Math.max(sm,sm2);\\n        int y=Math.min(sm,sm2);\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            for(int j=0;j<nums2.length;j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    if(p>nums1[i])\\n                        p=nums1[i];\\n                }\\n            }\\n        }\\n        return  Math.min(y*10+x,p);\\n        \\n        \\n    }\\n}\\n```\\n# THODI VINATI\\n![Bakchodi 2.jpeg](https://assets.leetcode.com/users/images/91bbdfde-02da-4b55-a3d1-669c0813fa29_1680367384.861429.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int sm=10,sm2=10,p=Integer.MAX_VALUE;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(sm>nums1[i])\\n                sm=nums1[i];\\n        }\\n         for(int i=0;i<nums2.length;i++)\\n        {\\n            if(sm2>nums2[i])\\n                sm2=nums2[i];\\n        }\\n        int x=Math.max(sm,sm2);\\n        int y=Math.min(sm,sm2);\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            for(int j=0;j<nums2.length;j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    if(p>nums1[i])\\n                        p=nums1[i];\\n                }\\n            }\\n        }\\n        return  Math.min(y*10+x,p);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385343,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        small1, small2, common = min(nums1), min(nums2), set(nums1) & set(nums2)\\n        output1, output2 = int(f\"{small1}{small2}\"), int(f\"{small2}{small1}\")\\n        if common:\\n            common = min(common)\\n            if common < output1 and common < output2:\\n                return common\\n        if small1 < small2:\\n            return output1\\n        return output2\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        small1, small2, common = min(nums1), min(nums2), set(nums1) & set(nums2)\\n        output1, output2 = int(f\"{small1}{small2}\"), int(f\"{small2}{small1}\")\\n        if common:\\n            common = min(common)\\n            if common < output1 and common < output2:\\n                return common\\n        if small1 < small2:\\n            return output1\\n        return output2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367793,
                "title": "python-3-3-lines-set-t-m-100-100",
                "content": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if mn := min(set(nums1)&set(nums2),\\n                    default = None): return mn      #  <-- one-digit case\\n\\n        d1, d2 = min(nums1), min(nums2)             #  <-- two-digit case\\n        return 10*d1+d2 if d1 < d2 else 10*d2+d1    #\\n```\\n[https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/submissions/926220757/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N1+N2*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if mn := min(set(nums1)&set(nums2),\\n                    default = None): return mn      #  <-- one-digit case\\n\\n        d1, d2 = min(nums1), min(nums2)             #  <-- two-digit case\\n        return 10*d1+d2 if d1 < d2 else 10*d2+d1    #\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366805,
                "title": "easiest-java-solution",
                "content": "![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/f2ae0a30-985d-4475-b60d-cf2cb9354b0a_1680367496.4392107.png)\\nFastest Java code. Please like and comment.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE,min=Integer.MAX_VALUE;\\n        boolean temp = false;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            min1 = Math.min(min1,nums1[i]);\\n            set.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            min2 = Math.min(min2,nums2[i]);\\n            if(set.contains(nums2[i])) \\n            {\\n                min = Math.min(min,nums2[i]);\\n                temp = true;\\n            }\\n        }\\n        if(temp) return min;\\n        if(min1<min2)\\n        {\\n            return min1*10+min2;\\n        }\\n        else\\n            return min2*10+min1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE,min=Integer.MAX_VALUE;\\n        boolean temp = false;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            min1 = Math.min(min1,nums1[i]);\\n            set.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            min2 = Math.min(min2,nums2[i]);\\n            if(set.contains(nums2[i])) \\n            {\\n                min = Math.min(min,nums2[i]);\\n                temp = true;\\n            }\\n        }\\n        if(temp) return min;\\n        if(min1<min2)\\n        {\\n            return min1*10+min2;\\n        }\\n        else\\n            return min2*10+min1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503533,
                "title": "optimized-c-easy-to-understand",
                "content": "check if a no present in both array if present than return minimum.\\nelse make smallest possible no using nums1[i] && nums2[j];\\n\\n# Complexity\\n- Time complexity:\\nO(n+m+81);\\n\\n- Space complexity:\\nO(10+10);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v1(10,0),v2(10,0);\\n        for(auto &i: nums1)v1[i]++;\\n        for(auto &i: nums2)v2[i]++;\\n        int i,j;\\n        for(i = 1; i <= 9; i++){\\n            if(v1[i]&&v2[i])return i;\\n        }\\n        int ans = 100;\\n        for(i =1; i <= 9; i++){\\n            if(v1[i]){\\n                for(j = 1; j <= 9; j++){\\n                    if(v2[j]){\\n                        ans = min({i*10+j,j*10+i,ans});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v1(10,0),v2(10,0);\\n        for(auto &i: nums1)v1[i]++;\\n        for(auto &i: nums2)v2[i]++;\\n        int i,j;\\n        for(i = 1; i <= 9; i++){\\n            if(v1[i]&&v2[i])return i;\\n        }\\n        int ans = 100;\\n        for(i =1; i <= 9; i++){\\n            if(v1[i]){\\n                for(j = 1; j <= 9; j++){\\n                    if(v2[j]){\\n                        ans = min({i*10+j,j*10+i,ans});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391461,
                "title": "java-solution",
                "content": "**JAVA SOLUTION**\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i = 0; i<nums1.length; i++){\\n            for(int j = 0; j<nums2.length; j++){\\n                if(nums1[i]==nums2[j])\\n                 ans = Math.min(ans,nums2[j]);\\n                else{\\n                    ans = Math.min(nums1[i]*10+nums2[j], ans);\\n                    ans = Math.min(nums2[j]*10 + nums1[i], ans);\\n                }\\n            }\\n        }\\n         return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i = 0; i<nums1.length; i++){\\n            for(int j = 0; j<nums2.length; j++){\\n                if(nums1[i]==nums2[j])\\n                 ans = Math.min(ans,nums2[j]);\\n                else{\\n                    ans = Math.min(nums1[i]*10+nums2[j], ans);\\n                    ans = Math.min(nums2[j]*10 + nums1[i], ans);\\n                }\\n            }\\n        }\\n         return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368216,
                "title": "python-o-n-very-easy-with-explanation-100-faster",
                "content": "# Intuition\\nDescribed the thought process and solution approach in the comments of the code.\\n\\n- Time complexity: o(n)\\n\\n- Space complexity: o(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        # Create a list of common numbers using \\'set\\' and \\'&\\'\\n        common = list(set(nums1) & set(nums2))\\n        # Check if there is any common element\\n        # Since it is given that the 1 <= nums1[i], nums2[i] <= 9, \\n        # we can confirm that the common element will be smaller\\n        # than creating a smalll number using two elements\\n        if common:\\n            # Ensure that we return the smallest common element\\n            # I have seen solutions where sort is used instead of using min\\n            # Time complexity when using sort: O(nlogn)\\n            # Time complexity when using min: O(n)\\n            return min(common)\\n\\n        # If there is no common element, we will have to create a \\n        # new 2-digit element such that we get the smallest value\\n        min1 = min(nums1)\\n        min2 = min(nums2)\\n        \\n        if min1 > min2:\\n            res = min2*10 + min1\\n        else:\\n            res = min1* 10 + min2\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        # Create a list of common numbers using \\'set\\' and \\'&\\'\\n        common = list(set(nums1) & set(nums2))\\n        # Check if there is any common element\\n        # Since it is given that the 1 <= nums1[i], nums2[i] <= 9, \\n        # we can confirm that the common element will be smaller\\n        # than creating a smalll number using two elements\\n        if common:\\n            # Ensure that we return the smallest common element\\n            # I have seen solutions where sort is used instead of using min\\n            # Time complexity when using sort: O(nlogn)\\n            # Time complexity when using min: O(n)\\n            return min(common)\\n\\n        # If there is no common element, we will have to create a \\n        # new 2-digit element such that we get the smallest value\\n        min1 = min(nums1)\\n        min2 = min(nums2)\\n        \\n        if min1 > min2:\\n            res = min2*10 + min1\\n        else:\\n            res = min1* 10 + min2\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367115,
                "title": "python3-check-intersection",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/1dc118daa80cfe1161dcee412e7c3536970ca60d) for solutions of biweely 101. \\n\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        inter = set(nums1) & set(nums2)\\n        if inter: return min(inter)\\n        d1 = min(nums1)\\n        d2 = min(nums2)\\n        return 10*d1+d2 if d1 < d2 else 10*d2+d1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        inter = set(nums1) & set(nums2)\\n        if inter: return min(inter)\\n        d1 = min(nums1)\\n        d2 = min(nums2)\\n        return 10*d1+d2 if d1 < d2 else 10*d2+d1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366512,
                "title": "python3-solution-well-explained-easy-clear",
                "content": "# Intuition:\\nThe problem asks us to find the smallest number that can be formed by concatenating two numbers, one from each of the given lists, nums1 and nums2. If there are common elements in both the lists, the smallest such element can be used to form the smallest number. If there are no common elements, then we need to choose the minimum elements from each list to form the smallest number.\\n\\n# Approach:\\nThe given solution has two parts. The first part checks if there are any common elements in the two lists. If there are, it selects the smallest common element as the starting digit of the smallest number. If there are no common elements, the second part selects the minimum element from each list to form the smallest number.\\n\\nThe code first initializes n as 10, a value that is higher than any possible element in the given lists. It then iterates through each element of nums1 and checks if it is present in nums2. If it is, n is updated to the minimum of its current value and the common element. If there is a common element, the method returns the value of n as the starting digit of the smallest number.\\n\\nIf there are no common elements, the method constructs two possible numbers by concatenating the minimum elements from nums1 and nums2 in different orders. It then returns the minimum of these two numbers as the smallest number.\\n\\n# Complexity:\\n# Time complexity \\nThe time complexity of this solution is O(mn), where m and n are the lengths of nums1 and nums2, respectively. This is because the code iterates through each element of nums1 and checks if it is present in nums2, resulting in an inner loop that runs m*n times in the worst case.\\n\\n# Space complexity\\nThe space complexity of this solution is O(1), because it only uses a fixed amount of additional space to store the variable n.\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=10\\n        for i in nums1:\\n            if i in nums2:\\n                n=min(n,i)\\n        if n!=10:\\n            return n\\n        \\n        x=min(nums1)\\n        y=min(nums2)\\n        a=x*10+y\\n        b=y*10+x\\n        return min(a,b)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=10\\n        for i in nums1:\\n            if i in nums2:\\n                n=min(n,i)\\n        if n!=10:\\n            return n\\n        \\n        x=min(nums1)\\n        y=min(nums2)\\n        a=x*10+y\\n        b=y*10+x\\n        return min(a,b)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366508,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int a=nums1[0];\\n        int b=nums2[0];\\n        HashSet<Integer> hs1=new HashSet<>();\\n        HashSet<Integer> hs2=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            hs1.add(nums1[i]);\\n        }\\n         for(int i=0;i<nums2.length;i++){\\n            hs2.add(nums2[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(hs1.contains(nums2[i]))\\n                return nums2[i];\\n        }\\n        if(a==b)\\n            return a;\\n        \\n        if(a<b)\\n        return (a*10)+b;\\n        \\n        return (b*10)+a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int a=nums1[0];\\n        int b=nums2[0];\\n        HashSet<Integer> hs1=new HashSet<>();\\n        HashSet<Integer> hs2=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            hs1.add(nums1[i]);\\n        }\\n         for(int i=0;i<nums2.length;i++){\\n            hs2.add(nums2[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(hs1.contains(nums2[i]))\\n                return nums2[i];\\n        }\\n        if(a==b)\\n            return a;\\n        \\n        if(a<b)\\n        return (a*10)+b;\\n        \\n        return (b*10)+a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366473,
                "title": "c-easy-and-concise-binary-search-and-sorting-o-n-log-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n)) \\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int s = 0;\\n            int e = m-1;\\n            while(s <= e) {\\n                int mid = s+(e-s)/2;\\n                if(nums1[i] == nums2[mid]) return nums1[i];\\n                else if(nums1[i] > nums2[mid]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        \\n        int min1 = nums1[0];\\n        int min2 = nums2[0];\\n        \\n        if(min1 > min2) return min2*10 + min1;\\n        return min1*10 + min2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int s = 0;\\n            int e = m-1;\\n            while(s <= e) {\\n                int mid = s+(e-s)/2;\\n                if(nums1[i] == nums2[mid]) return nums1[i];\\n                else if(nums1[i] > nums2[mid]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        \\n        int min1 = nums1[0];\\n        int min2 = nums2[0];\\n        \\n        if(min1 > min2) return min2*10 + min1;\\n        return min1*10 + min2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656099,
                "title": "simple-solution-in-python",
                "content": "\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n                break\\n        else:\\n            return min(nums1[0]*10+nums2[0],nums2[0]*10+nums1[0])\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n                break\\n        else:\\n            return min(nums1[0]*10+nums2[0],nums2[0]*10+nums1[0])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472051,
                "title": "form-smallest-number-from-two-digit-arrays-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        while(i<nums1.size() && j<nums2.size())\\n        {\\n            if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            else if(nums1[i]>nums2[j])\\n                j++;\\n            else\\n                i++;\\n        }\\n        if(nums1[0]<nums2[0])\\n            return nums1[0]*10+nums2[0];\\n        return nums2[0]*10+nums1[0];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1db5be82-d91f-4d49-9e59-72c2d1404cfa_1682917669.6928067.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        while(i<nums1.size() && j<nums2.size())\\n        {\\n            if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            else if(nums1[i]>nums2[j])\\n                j++;\\n            else\\n                i++;\\n        }\\n        if(nums1[0]<nums2[0])\\n            return nums1[0]*10+nums2[0];\\n        return nums2[0]*10+nums1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404618,
                "title": "c-easy-to-understand-math-short-sweet",
                "content": "````\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& v1, vector<int>& v2) {\\n        vector<int> v(10,0);\\n        for(auto &i: v1)v[i]++;\\n        for(auto &i: v2)v[i]++;\\n        for(int i = 1; i < 10; i++)if(v[i]>1)return i;\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        return min({v1[0]*10+v2[0],v1[0]+v2[0]*10});\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& v1, vector<int>& v2) {\\n        vector<int> v(10,0);\\n        for(auto &i: v1)v[i]++;\\n        for(auto &i: v2)v[i]++;\\n        for(int i = 1; i < 10; i++)if(v[i]>1)return i;\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        return min({v1[0]*10+v2[0],v1[0]+v2[0]*10});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382326,
                "title": "simple-approch-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int s1 = Integer.MAX_VALUE,s2=Integer.MAX_VALUE,ans=0;\\n\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i:nums2)\\n        {\\n            set.add(i);\\n        }\\n\\n        for(int i:nums1)\\n        {\\n            if(set.contains(i)) return i;\\n        }\\n\\n        ans = nums1[0]*10 + nums2[0];\\n        int ans2 = nums2[0]*10 + nums1[0];\\n\\n        return Math.min(ans,ans2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int s1 = Integer.MAX_VALUE,s2=Integer.MAX_VALUE,ans=0;\\n\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i:nums2)\\n        {\\n            set.add(i);\\n        }\\n\\n        for(int i:nums1)\\n        {\\n            if(set.contains(i)) return i;\\n        }\\n\\n        ans = nums1[0]*10 + nums2[0];\\n        int ans2 = nums2[0]*10 + nums1[0];\\n\\n        return Math.min(ans,ans2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370231,
                "title": "python-elegant-short-set-intersection",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, first: List[int], second: List[int]) -> int:\\n        a, b = sorted((min(first), min(second)))\\n        c = min(set(first) & set(second), default=maxsize)\\n        return min(c, a * 10 + b)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, first: List[int], second: List[int]) -> int:\\n        a, b = sorted((min(first), min(second)))\\n        c = min(set(first) & set(second), default=maxsize)\\n        return min(c, a * 10 + b)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367140,
                "title": "easy-c-solution-beats-100-using-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEasy map solution...\\n1. check for the the number which is present in both array and it must be smallest number for that sort the array in starting and then map the anyone array.\\n2. while checking for the presence in both if it\\'s find true return at that point.\\n3. final case when the array does not have any common number then two cases are possible  i.e nums1 = [1,2,4] nums2= [5,6,7] nums1[0]*10 + nums[0] = 15 or nums2[0]*10 + nums1[0]= 51 since we have to return the minimum so return the minimum of both\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(nlogn)  -> for sortting the array O(n) for liner mapping \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> mp1;\\n         sort(nums1.begin(),nums1.end());\\n         sort(nums2.begin(),nums2.end());\\n        for(auto it : nums1)\\n        {\\n            mp1[it]++;\\n        }\\n        for(auto it : nums2)\\n        {\\n            if(mp1[it] != 0)\\n            return it;\\n        }\\n     return min(nums1[0]*10 + nums2[0],nums2[0]*10 + nums1[0]);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> mp1;\\n         sort(nums1.begin(),nums1.end());\\n         sort(nums2.begin(),nums2.end());\\n        for(auto it : nums1)\\n        {\\n            mp1[it]++;\\n        }\\n        for(auto it : nums2)\\n        {\\n            if(mp1[it] != 0)\\n            return it;\\n        }\\n     return min(nums1[0]*10 + nums2[0],nums2[0]*10 + nums1[0]);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366785,
                "title": "javascript-direct-way-61ms",
                "content": "if have intersection, find the smallest intersected digit, otherwise, pick smallest from both array\\n```\\nconst minNumber = (a, b) => {\\n    let both = [];\\n    for (const x of a) {\\n        if (b.includes(x)) both.push(x);\\n    }\\n    if (both.length > 0) return Math.min(...both);\\n    let pa = Math.min(...a), pb = Math.min(...b);\\n    return pa < pb ? pa + \"\" + pb : pb + \"\" + pa; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst minNumber = (a, b) => {\\n    let both = [];\\n    for (const x of a) {\\n        if (b.includes(x)) both.push(x);\\n    }\\n    if (both.length > 0) return Math.min(...both);\\n    let pa = Math.min(...a), pb = Math.min(...b);\\n    return pa < pb ? pa + \"\" + pb : pb + \"\" + pa; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366706,
                "title": "java-hashset-explained",
                "content": "## Approach explained using comments:\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        // Create two sets to record the digits from nums1 and nums2\\n        Set<Integer> n1 = new HashSet<>();\\n        Set<Integer> n2 = new HashSet<>();\\n        for (int i : nums1) n1.add(i);\\n        for (int i : nums2) n2.add(i);\\n\\n        // Time to get common minimum digit\\n        int min = 10;\\n        for (int i : n1) {  // iterate on set n1\\n            // if that digit is present in set n2\\n            if (n2.contains(i)) {\\n                // update the common minimum\\n                min = Math.min(min, i);\\n            }\\n        }\\n        // if the common minimum was updated, \\n        // it won\\'t remain as the default initialized value\\n        // so return it\\n        if (min != 10) {\\n            return min;\\n        }\\n        \\n        // Otherwise sort both the arrays\\n        Arrays.sort(nums1); \\n        Arrays.sort(nums2);\\n        // and form the minimum number using the two numbers\\n        // at the 0-th index of both the sorted arrays\\n        int ans = Math.min(nums1[0], nums2[0]) * 10 + Math.max(nums1[0], nums2[0]);\\n        return ans;     // return the number\\n    }\\n}\\n\\n// This can be done without sorting as well, \\n// by iterating over both the arrays and\\n// recording the minimum digit from both arrays\\n```\\n---\\n\\n### Clean solution:\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> n1 = new HashSet<>();\\n        Set<Integer> n2 = new HashSet<>();\\n        for (int i : nums1) n1.add(i);\\n        for (int i : nums2) n2.add(i);\\n\\n        int min = 10;\\n        for (int i : n1) { \\n            if (n2.contains(i)) \\n                min = Math.min(min, i);\\n            \\n        if (min != 10) \\n            return min;\\n        \\n        Arrays.sort(nums1); \\n        Arrays.sort(nums2);\\n        int a = Math.min(nums1[0], nums2[0]);\\n        int b = Math.max(nums1[0], nums2[0]);\\n        return a * 10 + b;     \\n    }\\n}\\n```\\n##### Time complexity: $$O(2*9) + O(9) + O(2*9.log(9)) => O(n)$$\\n##### Space complexity: $$O(2*9) => O(n)$$\\n> $$n = 9$$ at worst case.",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        // Create two sets to record the digits from nums1 and nums2\\n        Set<Integer> n1 = new HashSet<>();\\n        Set<Integer> n2 = new HashSet<>();\\n        for (int i : nums1) n1.add(i);\\n        for (int i : nums2) n2.add(i);\\n\\n        // Time to get common minimum digit\\n        int min = 10;\\n        for (int i : n1) {  // iterate on set n1\\n            // if that digit is present in set n2\\n            if (n2.contains(i)) {\\n                // update the common minimum\\n                min = Math.min(min, i);\\n            }\\n        }\\n        // if the common minimum was updated, \\n        // it won\\'t remain as the default initialized value\\n        // so return it\\n        if (min != 10) {\\n            return min;\\n        }\\n        \\n        // Otherwise sort both the arrays\\n        Arrays.sort(nums1); \\n        Arrays.sort(nums2);\\n        // and form the minimum number using the two numbers\\n        // at the 0-th index of both the sorted arrays\\n        int ans = Math.min(nums1[0], nums2[0]) * 10 + Math.max(nums1[0], nums2[0]);\\n        return ans;     // return the number\\n    }\\n}\\n\\n// This can be done without sorting as well, \\n// by iterating over both the arrays and\\n// recording the minimum digit from both arrays\\n```\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> n1 = new HashSet<>();\\n        Set<Integer> n2 = new HashSet<>();\\n        for (int i : nums1) n1.add(i);\\n        for (int i : nums2) n2.add(i);\\n\\n        int min = 10;\\n        for (int i : n1) { \\n            if (n2.contains(i)) \\n                min = Math.min(min, i);\\n            \\n        if (min != 10) \\n            return min;\\n        \\n        Arrays.sort(nums1); \\n        Arrays.sort(nums2);\\n        int a = Math.min(nums1[0], nums2[0]);\\n        int b = Math.max(nums1[0], nums2[0]);\\n        return a * 10 + b;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366679,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        for(int i=0; i<nums1.size(); i++) {\\n            for(int j=0; j<nums2.size(); j++) {\\n                if(nums1[i] == nums2[j]) return nums1[i];\\n            }\\n        }\\n        int first = *min_element(nums1.begin(), nums1.end());\\n        int second = *min_element(nums2.begin(), nums2.end());\\n        int ans = min(first * 10 + second, second * 10 + first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        for(int i=0; i<nums1.size(); i++) {\\n            for(int j=0; j<nums2.size(); j++) {\\n                if(nums1[i] == nums2[j]) return nums1[i];\\n            }\\n        }\\n        int first = *min_element(nums1.begin(), nums1.end());\\n        int second = *min_element(nums2.begin(), nums2.end());\\n        int ans = min(first * 10 + second, second * 10 + first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366658,
                "title": "easy-c",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> x(10,0),y(10,0);\\n        int mn1=10,mn2=10;\\n        for(int i=0;i<nums1.size();i++){\\n            x[nums1[i]]=1;\\n            mn1=min(mn1,nums1[i]);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            y[nums2[i]]=1;\\n            mn2=min(mn2,nums2[i]);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(x[i]&&y[i]) return i;\\n        }\\n        return min(mn1,mn2)*10+max(mn1,mn2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> x(10,0),y(10,0);\\n        int mn1=10,mn2=10;\\n        for(int i=0;i<nums1.size();i++){\\n            x[nums1[i]]=1;\\n            mn1=min(mn1,nums1[i]);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            y[nums2[i]]=1;\\n            mn2=min(mn2,nums2[i]);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(x[i]&&y[i]) return i;\\n        }\\n        return min(mn1,mn2)*10+max(mn1,mn2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366558,
                "title": "java-take-intersection-self-explanatory",
                "content": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\t   //Sorted to find smallest element which has elements in both arrays\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        Set<Integer> set = new HashSet<>(); //To avoid duplicate values\\n\\t\\t\\n        for(int i : nums1) set.add(i);\\n        for(int n : nums2) if(set.contains(n)) return n; //If any common value found from both arrays, return it\\n        \\n       \\n       if(nums1[0] < nums2[0]) return nums1[0] * 10 + nums2[0];\\n       return nums2[0] * 10 + nums1[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\t   //Sorted to find smallest element which has elements in both arrays\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        Set<Integer> set = new HashSet<>(); //To avoid duplicate values\\n\\t\\t\\n        for(int i : nums1) set.add(i);\\n        for(int n : nums2) if(set.contains(n)) return n; //If any common value found from both arrays, return it\\n        \\n       \\n       if(nums1[0] < nums2[0]) return nums1[0] * 10 + nums2[0];\\n       return nums2[0] * 10 + nums1[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366511,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x: nums1) mp[x]++;\\n        for(auto x: nums2) mp[x]++;\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x: mp){\\n            if(x.second>1) return x.first;\\n        }\\n        string s;\\n        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);\\n        else s=to_string(mn2)+ to_string(mn1);\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x: nums1) mp[x]++;\\n        for(auto x: nums2) mp[x]++;\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x: mp){\\n            if(x.second>1) return x.first;\\n        }\\n        string s;\\n        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);\\n        else s=to_string(mn2)+ to_string(mn1);\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796688,
                "title": "beats-98-in-java",
                "content": "# Intuition\\nSort both the arrays, if there is a similar element return it or return min*10 +max elements\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\nPls upvote...!\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n   int ans=0;\\n   Arrays.sort(nums1);Arrays.sort(nums2);\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j]) return nums1[i];\\n        }\\n    }\\n    int min=Math.min(nums1[0],nums2[0]);\\n    int max=Math.max(nums1[0],nums2[0]);\\n    return (min*10 +max);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n   int ans=0;\\n   Arrays.sort(nums1);Arrays.sort(nums2);\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j]) return nums1[i];\\n        }\\n    }\\n    int min=Math.min(nums1[0],nums2[0]);\\n    int max=Math.max(nums1[0],nums2[0]);\\n    return (min*10 +max);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793989,
                "title": "beginner-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int min1=nums1[0];\\n        Arrays.sort(nums2);\\n        int min2=nums2[0];\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int n1: nums1) set.add(n1);\\n        for(int n2: nums2) {\\n            if(set.contains(n2))\\n                 return n2;\\n        }\\n  \\n       return min1<min2? min1*10+min2:min2*10+min1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int min1=nums1[0];\\n        Arrays.sort(nums2);\\n        int min2=nums2[0];\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int n1: nums1) set.add(n1);\\n        for(int n2: nums2) {\\n            if(set.contains(n2))\\n                 return n2;\\n        }\\n  \\n       return min1<min2? min1*10+min2:min2*10+min1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674880,
                "title": "the-best-memory-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Let\\'s sort the array 1\\n2. Using the for loop, we will find out if there is at least one minimum number of array 1 in array 2\\n3. If array 2 contains at least one minimum number from array 1, we will return it\\n4. Otherwise, we will find the minimum number of the second array\\n5. Finally we find the minimum number composed of the first element of the sorted array 1 and the minimum number of the array 2\\n\\n\\n# Code\\n```\\nfunction minNumber(nums1: number[], nums2: number[]): number {\\n    nums1.sort((a, b) => a - b);\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        if (nums2.includes(nums1[i])) {\\n            return nums1[i];\\n        }\\n    }\\n\\n    const firstChar = nums1[0];\\n    const secondChar = Math.min(...nums2);\\n    return Math.min(+`${firstChar}${secondChar}`, +`${secondChar}${firstChar}`)\\n};\\n```\\n\\n![form-smallest-number-from-two-digit-arrays.png](https://assets.leetcode.com/users/images/ffccc7cd-8a74-4834-8b05-ff8f511638ca_1687547843.8634896.png)",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minNumber(nums1: number[], nums2: number[]): number {\\n    nums1.sort((a, b) => a - b);\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        if (nums2.includes(nums1[i])) {\\n            return nums1[i];\\n        }\\n    }\\n\\n    const firstChar = nums1[0];\\n    const secondChar = Math.min(...nums2);\\n    return Math.min(+`${firstChar}${secondChar}`, +`${secondChar}${firstChar}`)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438688,
                "title": "very-easy",
                "content": "\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v(10);\\n        for(int i=0;i<nums1.size();i++) v[nums1[i]]++;\\n        for(int i=0;i<nums2.size();i++) v[nums2[i]]++;\\n\\n         for(int i=1;i<v.size();i++){\\n             if(v[i]==2) return i;\\n         }\\n         int ans =0;\\n         int a = *min_element(nums1.begin(), nums1.end());\\n        int b = *min_element(nums2.begin(), nums2.end());\\n        // we have to swap if a is less than b\\n        if(b<a) swap(a,b);\\n        ans = a*10 +b;\\n        return ans;\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Enumeration"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v(10);\\n        for(int i=0;i<nums1.size();i++) v[nums1[i]]++;\\n        for(int i=0;i<nums2.size();i++) v[nums2[i]]++;\\n\\n         for(int i=1;i<v.size();i++){\\n             if(v[i]==2) return i;\\n         }\\n         int ans =0;\\n         int a = *min_element(nums1.begin(), nums1.end());\\n        int b = *min_element(nums2.begin(), nums2.end());\\n        // we have to swap if a is less than b\\n        if(b<a) swap(a,b);\\n        ans = a*10 +b;\\n        return ans;\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422379,
                "title": "simple-approach-c",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2){\\n        int ans=0,first=0,second=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        if(nums1[0]<nums2[0]){\\n            first=nums1[0];\\n            second=nums2[0];\\n        }\\n        else{\\n            first=nums2[0];\\n            second=nums1[0];\\n        }\\n        for(int i=0, j=0; i < nums1.size() && j < nums2.size(); ){\\n    if(nums1[i] == nums2[j]){\\n       first=0;\\n       second=nums1[i];\\n       break;\\n        i++;\\n        j++;\\n    }\\n    else if(nums1[i] < nums2[j]){\\n        i++;\\n    }\\n    else{\\n        j++;\\n    }\\n}\\n       ans=first*10+second;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2){\\n        int ans=0,first=0,second=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        if(nums1[0]<nums2[0]){\\n            first=nums1[0];\\n            second=nums2[0];\\n        }\\n        else{\\n            first=nums2[0];\\n            second=nums1[0];\\n        }\\n        for(int i=0, j=0; i < nums1.size() && j < nums2.size(); ){\\n    if(nums1[i] == nums2[j]){\\n       first=0;\\n       second=nums1[i];\\n       break;\\n        i++;\\n        j++;\\n    }\\n    else if(nums1[i] < nums2[j]){\\n        i++;\\n    }\\n    else{\\n        j++;\\n    }\\n}\\n       ans=first*10+second;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417532,
                "title": "be-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is a digit that is in both the lists, then that is the answer.\\nElse, the concatenation of the two smallest numbers from the list will be the answer. See the code for more clarification.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n        ans = (str(nums1[0]) + str(nums2[0])) if nums1[0] < nums2[0] else str(nums2[0]) + str(nums1[0]) \\n        ans = int(ans)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n        ans = (str(nums1[0]) + str(nums2[0])) if nums1[0] < nums2[0] else str(nums2[0]) + str(nums1[0]) \\n        ans = int(ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393332,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun minNumber(nums1: IntArray, nums2: IntArray): Int {\\n        val set = HashSet<Int>()\\n        var (min, min1, min2) = arrayOf(10, 10, 10)\\n        for (num in nums1) {\\n            min1 = minOf(min1, num)\\n            set.add(num)\\n        }\\n        for (num in nums2) {\\n            min2 = minOf(min2, num)\\n            if (set.contains(num)) min = minOf(min, num)\\n        }\\n        if (min != 10) return min\\n        return minOf(min1, min2) * 10 + maxOf(min1, min2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minNumber(nums1: IntArray, nums2: IntArray): Int {\\n        val set = HashSet<Int>()\\n        var (min, min1, min2) = arrayOf(10, 10, 10)\\n        for (num in nums1) {\\n            min1 = minOf(min1, num)\\n            set.add(num)\\n        }\\n        for (num in nums2) {\\n            min2 = minOf(min2, num)\\n            if (set.contains(num)) min = minOf(min, num)\\n        }\\n        if (min != 10) return min\\n        return minOf(min1, min2) * 10 + maxOf(min1, min2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387450,
                "title": "my-first-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums1\\n     * @param Integer[] $nums2\\n     * @return Integer\\n     */\\n    function minNumber($nums1, $nums2) {\\n        sort($nums1);\\n        sort($nums2);\\n\\n        for ($i=0; $i < count($nums1); $i++){\\n            if(array_search($nums1[$i], $nums2) !== false) return $nums1[$i];\\n        }\\n\\n        $min1 = min($nums1);\\n        $min2 = min($nums2);\\n\\n        return strval(min($min1, $min2)) . strval(max($min1, $min2));\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums1\\n     * @param Integer[] $nums2\\n     * @return Integer\\n     */\\n    function minNumber($nums1, $nums2) {\\n        sort($nums1);\\n        sort($nums2);\\n\\n        for ($i=0; $i < count($nums1); $i++){\\n            if(array_search($nums1[$i], $nums2) !== false) return $nums1[$i];\\n        }\\n\\n        $min1 = min($nums1);\\n        $min2 = min($nums2);\\n\\n        return strval(min($min1, $min2)) . strval(max($min1, $min2));\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371203,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& n1, vector<int>& n2) {\\n        sort(n1.begin(),n1.end());\\n        sort(n2.begin(),n2.end());\\n        set<int>s;\\n        for(int i=0;i<n1.size();i++){\\n            s.insert(n1[i]);\\n        }\\n        for(int i=0;i<n2.size();i++){\\n            if(s.count(n2[i])!=0){\\n                return n2[i];\\n            }\\n        }\\n        if(n1[0]<n2[0])\\n            return n1[0]*10+n2[0];\\n        else\\n            return n2[0]*10+n1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& n1, vector<int>& n2) {\\n        sort(n1.begin(),n1.end());\\n        sort(n2.begin(),n2.end());\\n        set<int>s;\\n        for(int i=0;i<n1.size();i++){\\n            s.insert(n1[i]);\\n        }\\n        for(int i=0;i<n2.size();i++){\\n            if(s.count(n2[i])!=0){\\n                return n2[i];\\n            }\\n        }\\n        if(n1[0]<n2[0])\\n            return n1[0]*10+n2[0];\\n        else\\n            return n2[0]*10+n1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371114,
                "title": "form-smallest-number-from-two-digit-arrays-easy-java-sol",
                "content": "# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int temp = getCommon(nums1, nums2);\\n        if(temp > 0) return temp;\\n        int a = getMinimum(nums1);\\n        if(isPresent(nums2, a)){\\n            return a;\\n        }\\n        int b = getMinimum(nums2);\\n        if(a < b){\\n            return a*10+b;\\n        }else{\\n            return b*10+a;\\n        }\\n    }\\n    public int getMinimum(int[] nums){\\n        int min = Integer.MAX_VALUE;\\n        int ans;\\n        for(int i = 0; i < nums.length; i++){\\n            min = Math.min(min, nums[i]);\\n            ans = min;\\n        }\\n        return min;\\n    }\\n    public boolean isPresent(int[] nums, int k){\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == k) return true;\\n        }\\n        return false;\\n    }\\n    public int getCommon(int[] nums1, int[] nums2){\\n        int min = Integer.MAX_VALUE;\\n        List<Integer> list = new ArrayList<Integer>();\\n        int ans=-1;\\n        for(int i = 0; i < nums1.length; i++){\\n            for(int j = 0; j < nums2.length; j++){\\n                if(nums1[i] == nums2[j]){\\n                    list.add(nums1[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++){\\n            min = Math.min(min, list.get(i));\\n            ans = min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int temp = getCommon(nums1, nums2);\\n        if(temp > 0) return temp;\\n        int a = getMinimum(nums1);\\n        if(isPresent(nums2, a)){\\n            return a;\\n        }\\n        int b = getMinimum(nums2);\\n        if(a < b){\\n            return a*10+b;\\n        }else{\\n            return b*10+a;\\n        }\\n    }\\n    public int getMinimum(int[] nums){\\n        int min = Integer.MAX_VALUE;\\n        int ans;\\n        for(int i = 0; i < nums.length; i++){\\n            min = Math.min(min, nums[i]);\\n            ans = min;\\n        }\\n        return min;\\n    }\\n    public boolean isPresent(int[] nums, int k){\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == k) return true;\\n        }\\n        return false;\\n    }\\n    public int getCommon(int[] nums1, int[] nums2){\\n        int min = Integer.MAX_VALUE;\\n        List<Integer> list = new ArrayList<Integer>();\\n        int ans=-1;\\n        for(int i = 0; i < nums1.length; i++){\\n            for(int j = 0; j < nums2.length; j++){\\n                if(nums1[i] == nums2[j]){\\n                    list.add(nums1[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++){\\n            min = Math.min(min, list.get(i));\\n            ans = min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370184,
                "title": "c-5-lines-faster-100",
                "content": "**Code**\\n```c++\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& l, vector<int>& r) {\\n        vector<int> cntl(10, 0), cntr(10, 0);\\n        auto ml = INT_MAX, mr = INT_MAX;\\n        for (auto i: l) cntl[i]++, ml = min(ml, i);\\n        for (auto i: r) cntr[i]++, mr = min(mr, i);\\n        for (int i = 0; i < 10; i++)  if (cntl[i] && cntr[i]) return i;\\n        return min(ml, mr) * 10 + max(ml, mr);\\n    }\\n};\\n```\\n\\n**Complexity**\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n\\n**Result**\\n\\n![image](https://assets.leetcode.com/users/images/60f92e63-2b59-4ed1-8d62-f7472cfc0cee_1680429860.541825.png)\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& l, vector<int>& r) {\\n        vector<int> cntl(10, 0), cntr(10, 0);\\n        auto ml = INT_MAX, mr = INT_MAX;\\n        for (auto i: l) cntl[i]++, ml = min(ml, i);\\n        for (auto i: r) cntr[i]++, mr = min(mr, i);\\n        for (int i = 0; i < 10; i++)  if (cntl[i] && cntr[i]) return i;\\n        return min(ml, mr) * 10 + max(ml, mr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369602,
                "title": "python3-straightforward-solution-with-explanation",
                "content": "First we check if there is an intersection of two arrays. If yes, then the answer will be one digit. Otherwise we need to check permutation of the two minimum digits from each array and choose the smallest.\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        intersection = list(set(nums1) & set(nums2))\\n        \\n        if len(intersection):\\n            return min(intersection)\\n        else:\\n            return min(int(str(min(nums1)) + str(min(nums2))), int(str(min(nums2)) + str(min(nums1))))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        intersection = list(set(nums1) & set(nums2))\\n        \\n        if len(intersection):\\n            return min(intersection)\\n        else:\\n            return min(int(str(min(nums1)) + str(min(nums2))), int(str(min(nums2)) + str(min(nums1))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369396,
                "title": "easiest-solution-100-accuracy-loops",
                "content": "\\n# Approach\\nThere can be two possible cases\\n1. the number is formed by taking the smallest numbers from both the arrays\\n2. The number is common to both arrays\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)+O(nlogn)+O(mlogm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0; j < m; j++){\\n                 if(nums1[i]==nums2[j])\\n                 return nums1[i];            }\\n        }\\n        return min((nums1[0]*10)+nums2[0],(nums2[0]*10)+nums1[0]);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0; j < m; j++){\\n                 if(nums1[i]==nums2[j])\\n                 return nums1[i];            }\\n        }\\n        return min((nums1[0]*10)+nums2[0],(nums2[0]*10)+nums1[0]);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368065,
                "title": "c-logic-based-conditions-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int mini1=nums1[0],mini2=nums2[0];\\n        \\n        for(auto x:nums1){\\n            mini1=min(mini1,x);\\n        }\\n         for(auto x:nums2){\\n            mini2=min(mini2,x);\\n        }\\n        int commin=99999;\\n        for(auto x:nums1){\\n            for(auto y:nums2){\\n                if(x==y)\\n                   commin=min(x,commin); \\n            }\\n        }\\n        if(mini1==mini2)\\n            return min(mini1,commin);\\n        \\n        if(mini1<mini2)\\n        return min(mini1*10 +mini2,commin); \\n        \\n        return min(mini2*10 +mini1,commin); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int mini1=nums1[0],mini2=nums2[0];\\n        \\n        for(auto x:nums1){\\n            mini1=min(mini1,x);\\n        }\\n         for(auto x:nums2){\\n            mini2=min(mini2,x);\\n        }\\n        int commin=99999;\\n        for(auto x:nums1){\\n            for(auto y:nums2){\\n                if(x==y)\\n                   commin=min(x,commin); \\n            }\\n        }\\n        if(mini1==mini2)\\n            return min(mini1,commin);\\n        \\n        if(mini1<mini2)\\n        return min(mini1*10 +mini2,commin); \\n        \\n        return min(mini2*10 +mini1,commin); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367618,
                "title": "simple-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        map<int,int> m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]++;\\n        }\\n         for(int i=0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n        }\\n        for(auto it: m){\\n            if(it.second==2)\\n                return it.first;\\n                \\n        }\\n        int x= *min_element(nums1.begin(),nums1.end());\\n          int y= *min_element(nums2.begin(),nums2.end());\\n        if(x>y)\\n            return y*10+x;\\n        else if(x==y) return x;\\n        else  return x*10 + y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        map<int,int> m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]++;\\n        }\\n         for(int i=0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n        }\\n        for(auto it: m){\\n            if(it.second==2)\\n                return it.first;\\n                \\n        }\\n        int x= *min_element(nums1.begin(),nums1.end());\\n          int y= *min_element(nums2.begin(),nums2.end());\\n        if(x>y)\\n            return y*10+x;\\n        else if(x==y) return x;\\n        else  return x*10 + y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367185,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        for i in 1...9{\\n            if nums1.contains(i) && nums2.contains(i){\\n                return i\\n            }\\n        }\\n        \\n        var (nums, ans) = ([Int](), 0)\\n        nums.append(nums1.min()!)\\n        nums.append(nums2.min()!)\\n        nums.sort()\\n        \\n        for x in nums { ans = ans*10 + x }\\n        return ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        for i in 1...9{\\n            if nums1.contains(i) && nums2.contains(i){\\n                return i\\n            }\\n        }\\n        \\n        var (nums, ans) = ([Int](), 0)\\n        nums.append(nums1.min()!)\\n        nums.append(nums2.min()!)\\n        nums.sort()\\n        \\n        for x in nums { ans = ans*10 + x }\\n        return ans\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367074,
                "title": "c-easy-and-shorter-solution-100-accepted-intuitive-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n,m;\\n        n = nums1.size();\\n        m =nums2.size();\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int i,j;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    \\n                }\\n            }\\n        }\\n        \\n        int x=nums1[0];\\n        int y = nums2[0];\\n        \\n        if(x<y)\\n            return 10*x+y;\\n        else\\n            return 10*y+x;\\n        \\n       \\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n,m;\\n        n = nums1.size();\\n        m =nums2.size();\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int i,j;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    \\n                }\\n            }\\n        }\\n        \\n        int x=nums1[0];\\n        int y = nums2[0];\\n        \\n        if(x<y)\\n            return 10*x+y;\\n        else\\n            return 10*y+x;\\n        \\n       \\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366913,
                "title": "100-fast-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int com= INT_MAX;\\n        for (auto val: nums1){\\n            if (count(nums2.begin(),nums2.end(),val)>0)com= min(com,val);\\n        }\\n        if (com!= INT_MAX)return com;\\n        int a= *min_element(nums1.begin(),nums1.end());\\n        int b= *min_element(nums2.begin(),nums2.end());\\n        int m1= min(a,b);\\n        int m2= max(a,b);\\n        return(m1*10+m2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int com= INT_MAX;\\n        for (auto val: nums1){\\n            if (count(nums2.begin(),nums2.end(),val)>0)com= min(com,val);\\n        }\\n        if (com!= INT_MAX)return com;\\n        int a= *min_element(nums1.begin(),nums1.end());\\n        int b= *min_element(nums2.begin(),nums2.end());\\n        int m1= min(a,b);\\n        int m2= max(a,b);\\n        return(m1*10+m2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366907,
                "title": "sorting-c-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int m=nums1.size(),n=nums2.size();\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums1[i]<nums2[j])\\n                i++;\\n            else\\n                return nums1[i];\\n        }\\n        int a=nums1[0],b=nums2[0];\\n        if(a<b)\\n            return a*10+b;\\n        else if(a==b)\\n            return a;\\n        else\\n            return b*10+a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int m=nums1.size(),n=nums2.size();\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums1[i]<nums2[j])\\n                i++;\\n            else\\n                return nums1[i];\\n        }\\n        int a=nums1[0],b=nums2[0];\\n        if(a<b)\\n            return a*10+b;\\n        else if(a==b)\\n            return a;\\n        else\\n            return b*10+a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366812,
                "title": "easy-solution-t-c-o-nlogn-s-c-o-1",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the element is present in both the arrays then return that particular element. We have used the helper function that does the same.\\nNow if there is no element that is common in both the arrays, then simply take the minimum element from both the arrays and return the minimum number that can be formed using the two.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums1,vector<int>& nums2){\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i = 0, j = 0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n// return -1 if no common element is present\\n        return -1;\\n    }\\n    \\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int result=0;\\n//helper function to check if there is any common element in the given arrays.\\n        int common = helper(nums1, nums2);\\n        if (common != -1) {\\n            return common;\\n        }\\n        else{\\n            int num1=*min_element(nums1.begin(),nums1.end());\\n            int num2=*min_element(nums2.begin(),nums2.end());\\n            result = (num1 < num2) ? num1 * 10 + num2 : num2 * 10 + num1;\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums1,vector<int>& nums2){\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i = 0, j = 0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n// return -1 if no common element is present\\n        return -1;\\n    }\\n    \\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int result=0;\\n//helper function to check if there is any common element in the given arrays.\\n        int common = helper(nums1, nums2);\\n        if (common != -1) {\\n            return common;\\n        }\\n        else{\\n            int num1=*min_element(nums1.begin(),nums1.end());\\n            int num2=*min_element(nums2.begin(),nums2.end());\\n            result = (num1 < num2) ? num1 * 10 + num2 : num2 * 10 + num1;\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366778,
                "title": "easiest-c-code-beats-100-clean-and-understandable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=INT_MAX;\\n        int n1=0;\\n        int n2=0;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans=min(ans,nums1[i]);\\n                }\\n                else{\\n                    n1=nums1[i]*10+nums2[j];\\n                    n2=nums2[j]*10+nums1[i];\\n                    ans=min(ans,min(n1,n2));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=INT_MAX;\\n        int n1=0;\\n        int n2=0;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans=min(ans,nums1[i]);\\n                }\\n                else{\\n                    n1=nums1[i]*10+nums2[j];\\n                    n2=nums2[j]*10+nums1[i];\\n                    ans=min(ans,min(n1,n2));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366738,
                "title": "easy-peasy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j])return nums1[i];\\n            }\\n        }\\n        if(nums1[0]<nums2[0])return nums1[0]*10+nums2[0];\\n        return  nums2[0]*10+nums1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j])return nums1[i];\\n            }\\n        }\\n        if(nums1[0]<nums2[0])return nums1[0]*10+nums2[0];\\n        return  nums2[0]*10+nums1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366727,
                "title": "easy-just-read-the-simple-code",
                "content": "\\n```\\n     int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int m = INT_MAX;\\n        int n = INT_MAX;\\n        \\n        map<int,int> map;\\n        for(int i: nums1){\\n            m = min(m,i);\\n            map[i]++;\\n        }\\n        for(int &i: nums2 ){\\n            n = min(n,i);\\n            map[i]--;\\n        }\\n        \\n        for(auto &i:map){\\n            if(i.second == 0){\\n                return i.first;\\n            }\\n        }\\n        \\n        int ans;\\n        if(n>m){\\n            ans = m;\\n            ans *= 10;\\n            ans+= n;\\n            return ans;\\n        }\\n        ans = n;\\n        ans *= 10;\\n        ans+= m;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int m = INT_MAX;\\n        int n = INT_MAX;\\n        \\n        map<int,int> map;\\n        for(int i: nums1){\\n            m = min(m,i);\\n            map[i]++;\\n        }\\n        for(int &i: nums2 ){\\n            n = min(n,i);\\n            map[i]--;\\n        }\\n        \\n        for(auto &i:map){\\n            if(i.second == 0){\\n                return i.first;\\n            }\\n        }\\n        \\n        int ans;\\n        if(n>m){\\n            ans = m;\\n            ans *= 10;\\n            ans+= n;\\n            return ans;\\n        }\\n        ans = n;\\n        ans *= 10;\\n        ans+= m;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366655,
                "title": "easy-and-fast-execution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size)\\n{\\n    int i,j;\\n    int val=99;\\n    \\n     for(i=0;i<nums1Size;i++)\\n     {     for(j=0;j<nums2Size;j++)\\n         {\\n            if(nums1[i]==nums2[j])\\n            {\\n                    \\n                    if(nums1[i]<val)\\n                        val=nums1[i];\\n            }\\n         }\\n        \\n     }\\n    if(val!=99)\\n        return val;\\n    for(i=0;i<nums1Size;i++)\\n    {\\n            if(nums1[0]>nums1[i])\\n            nums1[0]=nums1[i];\\n    }\\n    for(j=0;j<nums2Size;j++)\\n    {\\n        if(nums2[0]>nums2[j])\\n        nums2[0]=nums2[j];\\n    }\\n    if(nums1[0]<nums2[0])\\n    {val=(nums1[0])*10+nums2[0];\\n    return val;}\\n    else\\n    val=(nums2[0]*10)+nums1[0];\\n    return val;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size)\\n{\\n    int i,j;\\n    int val=99;\\n    \\n     for(i=0;i<nums1Size;i++)\\n     {     for(j=0;j<nums2Size;j++)\\n         {\\n            if(nums1[i]==nums2[j])\\n            {\\n                    \\n                    if(nums1[i]<val)\\n                        val=nums1[i];\\n            }\\n         }\\n        \\n     }\\n    if(val!=99)\\n        return val;\\n    for(i=0;i<nums1Size;i++)\\n    {\\n            if(nums1[0]>nums1[i])\\n            nums1[0]=nums1[i];\\n    }\\n    for(j=0;j<nums2Size;j++)\\n    {\\n        if(nums2[0]>nums2[j])\\n        nums2[0]=nums2[j];\\n    }\\n    if(nums1[0]<nums2[0])\\n    {val=(nums1[0])*10+nums2[0];\\n    return val;}\\n    else\\n    val=(nums2[0]*10)+nums1[0];\\n    return val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366640,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let set1 = Set(nums1)\\n        let set2 = Set(nums2)\\n        let intersection = Array(set1.intersection(set2)).sorted()\\n        if (intersection.count > 0) { return intersection[0] }\\n        else { \\n            let num1 = nums1.sorted()[0]\\n            let num2 = nums2.sorted()[0]\\n            if (num1 < num2) { \\n                return num1 * 10 + num2\\n            } else { \\n                return num2 * 10 + num1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let set1 = Set(nums1)\\n        let set2 = Set(nums2)\\n        let intersection = Array(set1.intersection(set2)).sorted()\\n        if (intersection.count > 0) { return intersection[0] }\\n        else { \\n            let num1 = nums1.sorted()[0]\\n            let num2 = nums2.sorted()[0]\\n            if (num1 < num2) { \\n                return num1 * 10 + num2\\n            } else { \\n                return num2 * 10 + num1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366596,
                "title": "ez",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int a= *min_element(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        unordered_map<int,int> mp;\\n        for(auto i: nums1) mp[i]++;\\n        for(auto i: nums2) {\\n            if(mp.find(i)!=mp.end()) return i;\\n        }\\n        if(a<nums2[0]) return (a*10 +nums2[0]);\\n        else return (nums2[0]*10+a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int a= *min_element(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        unordered_map<int,int> mp;\\n        for(auto i: nums1) mp[i]++;\\n        for(auto i: nums2) {\\n            if(mp.find(i)!=mp.end()) return i;\\n        }\\n        if(a<nums2[0]) return (a*10 +nums2[0]);\\n        else return (nums2[0]*10+a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366566,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]\\n\\n        a=sorted(nums1)[0]\\n        b=sorted(nums2)[0]\\n        return min(a*10+b,b*10+a)    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]\\n\\n        a=sorted(nums1)[0]\\n        b=sorted(nums2)[0]\\n        return min(a*10+b,b*10+a)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366527,
                "title": "beats-100-submissions-easy-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        a=nums1[:]\\n        a.extend(nums2)\\n        dic=Counter(a)\\n        m=max(dic.values())\\n        ans=[]\\n        if m>1:\\n            for i,j in dic.items():\\n                if j==m:\\n                    ans.append(i)\\n            return min(ans)\\n        else:\\n            min1=min(nums1)\\n            min2=min(nums2)\\n            if min1>min2:\\n                return int(str(min2)+str(min1))\\n            else:\\n                return int(str(min1)+str(min2))\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        a=nums1[:]\\n        a.extend(nums2)\\n        dic=Counter(a)\\n        m=max(dic.values())\\n        ans=[]\\n        if m>1:\\n            for i,j in dic.items():\\n                if j==m:\\n                    ans.append(i)\\n            return min(ans)\\n        else:\\n            min1=min(nums1)\\n            min2=min(nums2)\\n            if min1>min2:\\n                return int(str(min2)+str(min1))\\n            else:\\n                return int(str(min1)+str(min2))\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366488,
                "title": "min-max-occurence-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int m1=INT_MAX;\\n        int m2=INT_MAX;\\n        int arr[10]={0};\\n        \\n        for(int i=0;i<nums1.size();i++)\\n           {\\n            m1=min(m1,nums1[i]);\\n            arr[nums1[i]]++;\\n           }\\n         for(int i=0;i<nums2.size();i++)\\n           { \\n             m2=min(m2,nums2[i]);\\n             arr[nums2[i]]++;\\n           }\\n        for(int i=0;i<10;i++)\\n            if(arr[i]==2)\\n                return i;\\n        \\n       \\n        return  m1 > m2 ? m2*10+m1 : m1*10+m2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int m1=INT_MAX;\\n        int m2=INT_MAX;\\n        int arr[10]={0};\\n        \\n        for(int i=0;i<nums1.size();i++)\\n           {\\n            m1=min(m1,nums1[i]);\\n            arr[nums1[i]]++;\\n           }\\n         for(int i=0;i<nums2.size();i++)\\n           { \\n             m2=min(m2,nums2[i]);\\n             arr[nums2[i]]++;\\n           }\\n        for(int i=0;i<10;i++)\\n            if(arr[i]==2)\\n                return i;\\n        \\n       \\n        return  m1 > m2 ? m2*10+m1 : m1*10+m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366474,
                "title": "most-easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            set.add(nums1[i]);\\n        }\\n        for(int j=0;j<nums2.length;j++){\\n            if(set.contains(nums2[j])){\\n                return nums2[j];\\n            }\\n        }\\n        int min1=Integer.MAX_VALUE;\\n        int min2=Integer.MAX_VALUE;\\n        for(int i=0;i<nums1.length;i++){\\n            min1=Math.min(min1,nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            min2=Math.min(min2,nums2[i]);\\n        }\\n        if(min1<min2){\\n            return min1*10+min2;\\n        }\\n        return min2*10+min1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            set.add(nums1[i]);\\n        }\\n        for(int j=0;j<nums2.length;j++){\\n            if(set.contains(nums2[j])){\\n                return nums2[j];\\n            }\\n        }\\n        int min1=Integer.MAX_VALUE;\\n        int min2=Integer.MAX_VALUE;\\n        for(int i=0;i<nums1.length;i++){\\n            min1=Math.min(min1,nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            min2=Math.min(min2,nums2[i]);\\n        }\\n        if(min1<min2){\\n            return min1*10+min2;\\n        }\\n        return min2*10+min1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366453,
                "title": "go-sort-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(2nlog(n) + n2)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunc minNumber(nums1 []int, nums2 []int) int {\\n\\tsort.Ints(nums1)\\n\\tsort.Ints(nums2)\\n\\n\\tfor i := range nums1 {\\n\\t\\tfor j := range nums2 {\\n\\t\\t\\tif nums1[i] == nums2[j] {\\n\\t\\t\\t\\treturn nums1[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif nums1[0] < nums2[0] {\\n\\t\\treturn nums1[0]*10 + nums2[0]\\n\\t}\\n\\treturn nums2[0]*10 + nums1[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minNumber(nums1 []int, nums2 []int) int {\\n\\tsort.Ints(nums1)\\n\\tsort.Ints(nums2)\\n\\n\\tfor i := range nums1 {\\n\\t\\tfor j := range nums2 {\\n\\t\\t\\tif nums1[i] == nums2[j] {\\n\\t\\t\\t\\treturn nums1[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif nums1[0] < nums2[0] {\\n\\t\\treturn nums1[0]*10 + nums2[0]\\n\\t}\\n\\treturn nums2[0]*10 + nums1[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366443,
                "title": "easy-solution-using-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int> mp;\\n        for(int i=0; i<nums1.size(); i++){\\n            mp[nums1[i]]++;\\n        }\\n        int flag =0;\\n        int ans = INT_MAX;\\n        for(int i=0; i<nums2.size(); i++){\\n            if(mp[nums2[i]]>=1){\\n                ans = min(ans,nums2[i]);\\n                flag =1;\\n\\n            }\\n        }\\n        if(flag){\\n            return ans;\\n\\n        }\\n        \\n        \\n        int mn1 = *min_element(nums1.begin(),nums1.end());\\n        // int mx1 = *max_element(nums1.begin(),nums1.end());\\n        int mn2 = *min_element(nums2.begin(),nums2.end());\\n        // int mx2 = *max_element(nums2.begin(),nums2.end());\\n        ans = min(mn1*10+mn2,mn2*10+mn1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int> mp;\\n        for(int i=0; i<nums1.size(); i++){\\n            mp[nums1[i]]++;\\n        }\\n        int flag =0;\\n        int ans = INT_MAX;\\n        for(int i=0; i<nums2.size(); i++){\\n            if(mp[nums2[i]]>=1){\\n                ans = min(ans,nums2[i]);\\n                flag =1;\\n\\n            }\\n        }\\n        if(flag){\\n            return ans;\\n\\n        }\\n        \\n        \\n        int mn1 = *min_element(nums1.begin(),nums1.end());\\n        // int mx1 = *max_element(nums1.begin(),nums1.end());\\n        int mn2 = *min_element(nums2.begin(),nums2.end());\\n        // int mx2 = *max_element(nums2.begin(),nums2.end());\\n        ans = min(mn1*10+mn2,mn2*10+mn1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366398,
                "title": "python-greedy-with-set",
                "content": "```python\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        for n in range(100):\\n            s = set(map(int, str(n)))\\n            if s1 & s and s2 & s:\\n                return n\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        for n in range(100):\\n            s = set(map(int, str(n)))\\n            if s1 & s and s2 & s:\\n                return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366367,
                "title": "form-smallest-number-from-two-digit-arrays",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int> &nums1, vector<int> &nums2) {\\n        vector<int> merged;\\n        merged.reserve(nums1.size() + nums2.size());\\n        merged.insert(merged.end(), nums1.begin(), nums1.end());\\n        merged.insert(merged.end(), nums2.begin(), nums2.end());\\n        sort(merged.begin(), merged.end());\\n\\n        for (int num: merged) {\\n            if (std::find(nums1.begin(), nums1.end(), num) != nums1.end() &&\\n                std::find(nums2.begin(), nums2.end(), num) != nums2.end()) {\\n                return num;\\n            }\\n        }\\n\\n        int mn1 = *min_element(nums1.begin(), nums1.end());\\n        int mn2 = *min_element(nums2.begin(), nums2.end());      \\n        return min(mn1,mn2) * 10 + max(mn1,mn2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int> &nums1, vector<int> &nums2) {\\n        vector<int> merged;\\n        merged.reserve(nums1.size() + nums2.size());\\n        merged.insert(merged.end(), nums1.begin(), nums1.end());\\n        merged.insert(merged.end(), nums2.begin(), nums2.end());\\n        sort(merged.begin(), merged.end());\\n\\n        for (int num: merged) {\\n            if (std::find(nums1.begin(), nums1.end(), num) != nums1.end() &&\\n                std::find(nums2.begin(), nums2.end(), num) != nums2.end()) {\\n                return num;\\n            }\\n        }\\n\\n        int mn1 = *min_element(nums1.begin(), nums1.end());\\n        int mn2 = *min_element(nums2.begin(), nums2.end());      \\n        return min(mn1,mn2) * 10 + max(mn1,mn2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366356,
                "title": "c-set-use",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s1(nums1.begin(),nums1.end()),s2(nums2.begin(),nums2.end());\\n        for(int i=0;i<=1e4;i++){\\n            bool f1=false,f2=false;\\n            string x = to_string(i);\\n            for(auto a : x){\\n                if(s1.find(a-\\'0\\')!=s1.end()) f1 = true;\\n                if(s2.find(a-\\'0\\')!=s2.end()) f2 = true;\\n            }\\n            if(f1 && f2) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s1(nums1.begin(),nums1.end()),s2(nums2.begin(),nums2.end());\\n        for(int i=0;i<=1e4;i++){\\n            bool f1=false,f2=false;\\n            string x = to_string(i);\\n            for(auto a : x){\\n                if(s1.find(a-\\'0\\')!=s1.end()) f1 = true;\\n                if(s2.find(a-\\'0\\')!=s2.end()) f2 = true;\\n            }\\n            if(f1 && f2) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089167,
                "title": "beats-100-loops",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        // Sort the input vectors\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int size1 = nums1.size();\\n        int size2 = nums2.size();\\n\\n        if (size1 == 0 && size2 == 0) {\\n            return 0;\\n        } else if (size1 == 0) {\\n            return nums2[0];\\n        } else if (size2 == 0) {\\n            return nums1[0];\\n        }\\n\\n        int i = 0, j = 0;\\n\\n        while (i < size1 && j < size2) {\\n            if (nums1[i] == nums2[j]) {\\n                return nums1[i];\\n            } else if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return (nums1[0] > nums2[0]) ? nums2[0]*10 + nums1[0] : nums1[0]*10 + nums2[0] ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        // Sort the input vectors\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int size1 = nums1.size();\\n        int size2 = nums2.size();\\n\\n        if (size1 == 0 && size2 == 0) {\\n            return 0;\\n        } else if (size1 == 0) {\\n            return nums2[0];\\n        } else if (size2 == 0) {\\n            return nums1[0];\\n        }\\n\\n        int i = 0, j = 0;\\n\\n        while (i < size1 && j < size2) {\\n            if (nums1[i] == nums2[j]) {\\n                return nums1[i];\\n            } else if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return (nums1[0] > nums2[0]) ? nums2[0]*10 + nums1[0] : nums1[0]*10 + nums2[0] ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079711,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        a = set(nums1) & set(nums2)\\n        return min(a) if a else int(\\'\\'.join(map(str, sorted((sorted(nums1)[0], sorted(nums2)[0])))))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        a = set(nums1) & set(nums2)\\n        return min(a) if a else int(\\'\\'.join(map(str, sorted((sorted(nums1)[0], sorted(nums2)[0])))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078966,
                "title": "easy-c-solution-for-beginners-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int i,k;\\n        map<int,int>mp;\\n        for(i=0; i<nums1.size(); i++){\\n          mp[nums1[i]]++;\\n        }\\n        for(i=0; i<nums2.size(); i++){\\n                     mp[nums2[i]]++;\\n\\n        }\\n        int mini=1000;\\n        int flag=0;\\n        for(auto i: mp){\\n            if(i.second==2){\\n                flag=1;\\n                k=i.first;\\n                mini=min(mini,k);\\n            }\\n        }\\n        if(flag==1){\\n            return mini;\\n        }\\n       sort(nums1.begin(),nums1.end());\\n       int val1=nums1[0];\\n        sort(nums2.begin(),nums2.end());\\n            int val2=nums2[0];\\n            int sum1=(val1*10)+val2;\\n            int sum2=(val2*10)+val1;\\n            if(sum1<sum2){\\n                return sum1;\\n            }\\n            return sum2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int i,k;\\n        map<int,int>mp;\\n        for(i=0; i<nums1.size(); i++){\\n          mp[nums1[i]]++;\\n        }\\n        for(i=0; i<nums2.size(); i++){\\n                     mp[nums2[i]]++;\\n\\n        }\\n        int mini=1000;\\n        int flag=0;\\n        for(auto i: mp){\\n            if(i.second==2){\\n                flag=1;\\n                k=i.first;\\n                mini=min(mini,k);\\n            }\\n        }\\n        if(flag==1){\\n            return mini;\\n        }\\n       sort(nums1.begin(),nums1.end());\\n       int val1=nums1[0];\\n        sort(nums2.begin(),nums2.end());\\n            int val2=nums2[0];\\n            int sum1=(val1*10)+val2;\\n            int sum2=(val2*10)+val1;\\n            if(sum1<sum2){\\n                return sum1;\\n            }\\n            return sum2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078666,
                "title": "python-solution-easy-to-understand-for-beginner",
                "content": "\\n\\n# Complexity\\n\\n![image.png](https://assets.leetcode.com/users/images/3a8b577f-b4a5-4cac-b950-25793293ba1e_1695432344.8772168.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        l=[i for i in nums1 if i in nums2 ]\\n        if l!=[]:\\n            return min(l)\\n        else:\\n            l.extend([min(nums1),min(nums2)])\\n            l.sort()\\n            return int(str(l[0])+str(l[1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        l=[i for i in nums1 if i in nums2 ]\\n        if l!=[]:\\n            return min(l)\\n        else:\\n            l.extend([min(nums1),min(nums2)])\\n            l.sort()\\n            return int(str(l[0])+str(l[1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072158,
                "title": "esay-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int small=nums1[0],small1=nums2[0],answer;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums1[i]<small)\\n            small=nums1[i];\\n        }\\n        // for(int i=0;i<nums2.size();i++)\\n        // {\\n        //     if(nums2[i]<small)\\n        //     small1=nums2[i];\\n        // }\\nsmall1=*min_element(nums2.begin(), nums2.end());\\n \\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n    \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n         for(int j=0;j<nums2.size();j++)\\n        {\\n            if(nums1[i]==nums2[j])\\n            return nums1[i];\\n            //small1=nums2[i];\\n        }\\n        }\\n   if(small1<small) swap(small1, small);\\n         answer=small*10+small1;\\n        \\n  return answer;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int small=nums1[0],small1=nums2[0],answer;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums1[i]<small)\\n            small=nums1[i];\\n        }\\n        // for(int i=0;i<nums2.size();i++)\\n        // {\\n        //     if(nums2[i]<small)\\n        //     small1=nums2[i];\\n        // }\\nsmall1=*min_element(nums2.begin(), nums2.end());\\n \\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n    \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n         for(int j=0;j<nums2.size();j++)\\n        {\\n            if(nums1[i]==nums2[j])\\n            return nums1[i];\\n            //small1=nums2[i];\\n        }\\n        }\\n   if(small1<small) swap(small1, small);\\n         answer=small*10+small1;\\n        \\n  return answer;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070730,
                "title": "java-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int res = Integer.MAX_VALUE;\\n        HashSet<Integer> set = new HashSet<>();\\n        int minOne = Integer.MAX_VALUE;\\n        int minTwo = Integer.MAX_VALUE;\\n        for(int num: nums1){\\n            minOne = Math.min(minOne, num);\\n            set.add(num);\\n        }\\n        for(int num: nums2){\\n            minTwo = Math.min(minTwo, num);\\n            if(set.contains(num)){\\n                res = Math.min(res, num);\\n            }\\n        }\\n        if(res != Integer.MAX_VALUE) return res;\\n        return minOne <= minTwo ? minOne * 10 + minTwo : minTwo * 10 + minOne;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int res = Integer.MAX_VALUE;\\n        HashSet<Integer> set = new HashSet<>();\\n        int minOne = Integer.MAX_VALUE;\\n        int minTwo = Integer.MAX_VALUE;\\n        for(int num: nums1){\\n            minOne = Math.min(minOne, num);\\n            set.add(num);\\n        }\\n        for(int num: nums2){\\n            minTwo = Math.min(minTwo, num);\\n            if(set.contains(num)){\\n                res = Math.min(res, num);\\n            }\\n        }\\n        if(res != Integer.MAX_VALUE) return res;\\n        return minOne <= minTwo ? minOne * 10 + minTwo : minTwo * 10 + minOne;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069927,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    let smallestNumberFirstArray = Number.MAX_VALUE;\\n    let smallestNumberSecondArray = Number.MAX_VALUE;\\n    const nums1Length = nums1.length;\\n    const nums2Length = nums2.length;\\n    let firstArrayMinValue = 0;\\n    let secondArrayMinValue = 0;\\n    let smallMatchedValue = Number.MAX_VALUE;\\n\\n    for (let i = 0; i < nums1Length; i++) {\\n        if (nums1[i] < smallestNumberFirstArray) {\\n            firstArrayMinValue = nums1[i];\\n            smallestNumberFirstArray = firstArrayMinValue;\\n        }\\n\\n        for (let j = 0; j < nums2Length; j++) {\\n            if (nums2[j] < smallestNumberSecondArray) {\\n                secondArrayMinValue = nums2[j];\\n                smallestNumberSecondArray = secondArrayMinValue;\\n            }\\n\\n            if (nums1[i] === nums2[j]) {\\n                if (nums1[i] < smallMatchedValue) {\\n                    smallMatchedValue = nums1[i];\\n                }\\n            }\\n        }\\n    }\\n\\n    if (smallMatchedValue < Number.MAX_VALUE) {\\n        return smallMatchedValue;\\n    }\\n\\n    if (firstArrayMinValue < secondArrayMinValue) {\\n        return parseInt(firstArrayMinValue.toString() + secondArrayMinValue.toString());\\n    } else {\\n        return parseInt(secondArrayMinValue.toString() + firstArrayMinValue.toString());\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    let smallestNumberFirstArray = Number.MAX_VALUE;\\n    let smallestNumberSecondArray = Number.MAX_VALUE;\\n    const nums1Length = nums1.length;\\n    const nums2Length = nums2.length;\\n    let firstArrayMinValue = 0;\\n    let secondArrayMinValue = 0;\\n    let smallMatchedValue = Number.MAX_VALUE;\\n\\n    for (let i = 0; i < nums1Length; i++) {\\n        if (nums1[i] < smallestNumberFirstArray) {\\n            firstArrayMinValue = nums1[i];\\n            smallestNumberFirstArray = firstArrayMinValue;\\n        }\\n\\n        for (let j = 0; j < nums2Length; j++) {\\n            if (nums2[j] < smallestNumberSecondArray) {\\n                secondArrayMinValue = nums2[j];\\n                smallestNumberSecondArray = secondArrayMinValue;\\n            }\\n\\n            if (nums1[i] === nums2[j]) {\\n                if (nums1[i] < smallMatchedValue) {\\n                    smallMatchedValue = nums1[i];\\n                }\\n            }\\n        }\\n    }\\n\\n    if (smallMatchedValue < Number.MAX_VALUE) {\\n        return smallMatchedValue;\\n    }\\n\\n    if (firstArrayMinValue < secondArrayMinValue) {\\n        return parseInt(firstArrayMinValue.toString() + secondArrayMinValue.toString());\\n    } else {\\n        return parseInt(secondArrayMinValue.toString() + firstArrayMinValue.toString());\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057567,
                "title": "96-runtime-67-memory-beautiful-solution-using-set-and-intersection",
                "content": "![image.png](https://assets.leetcode.com/users/images/3c192b64-f9b6-4451-9343-04ba8d57a932_1694988871.1216412.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        m1, m2 = min(s1), min(s2); intersect = s1 & s2\\n\\n        if intersect: min_inter = min(intersect)\\n        else:\\n            if m1 < m2: return m1*10 + m2\\n            else: return m2*10 + m1\\n\\n        if m1 < m2: smallest = m1*10 + m2\\n        else: smallest = m2*10 + m1\\n\\n        return min_inter if min_inter < smallest else smallest\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        m1, m2 = min(s1), min(s2); intersect = s1 & s2\\n\\n        if intersect: min_inter = min(intersect)\\n        else:\\n            if m1 < m2: return m1*10 + m2\\n            else: return m2*10 + m1\\n\\n        if m1 < m2: smallest = m1*10 + m2\\n        else: smallest = m2*10 + m1\\n\\n        return min_inter if min_inter < smallest else smallest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057023,
                "title": "c-easy-set-appraoch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n     set<int>st1(nums1.begin(),nums1.end()),st2(nums2.begin(),nums2.end());\\n       for(auto it:st1)\\n         {\\n           if(st2.find(it)!=st2.end())\\n               return it;\\n               \\n         }\\n         int mi1=*st1.begin();\\n         int mi2=*st2.begin();\\n         string s=to_string(min(mi1,mi2))+to_string(max(mi1,mi2));\\n         return stoi(s);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n     set<int>st1(nums1.begin(),nums1.end()),st2(nums2.begin(),nums2.end());\\n       for(auto it:st1)\\n         {\\n           if(st2.find(it)!=st2.end())\\n               return it;\\n               \\n         }\\n         int mi1=*st1.begin();\\n         int mi2=*st2.begin();\\n         string s=to_string(min(mi1,mi2))+to_string(max(mi1,mi2));\\n         return stoi(s);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056331,
                "title": "c-o-n",
                "content": "# Approach\\nIn single iteration try to find out the common and smallest element in each array.\\n\\n# Complexity\\n- Time complexity: $$O(max(n, m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> visited(10,0);\\n        int small1 = 1e9, small2 = 1e9;\\n\\n        for(int num: nums1)\\n        {\\n            small1 = min(small1, num);\\n            visited[num] = 1;\\n        }\\n        \\n        for(int num: nums2)\\n        {\\n            small2 = min(small2, num);\\n            if (visited[num] == 1)\\n                visited[num] = 2;\\n        }\\n\\n        for(int i = 1 ; i <10 ; i++)\\n        {\\n            if (visited[i] == 2)\\n                return i;\\n        }\\n         \\n         return (small1 + small2 * 10) > (small2 + small1 * 10) ? (small2 + small1 * 10) : (small1 + small2 * 10);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> visited(10,0);\\n        int small1 = 1e9, small2 = 1e9;\\n\\n        for(int num: nums1)\\n        {\\n            small1 = min(small1, num);\\n            visited[num] = 1;\\n        }\\n        \\n        for(int num: nums2)\\n        {\\n            small2 = min(small2, num);\\n            if (visited[num] == 1)\\n                visited[num] = 2;\\n        }\\n\\n        for(int i = 1 ; i <10 ; i++)\\n        {\\n            if (visited[i] == 2)\\n                return i;\\n        }\\n         \\n         return (small1 + small2 * 10) > (small2 + small1 * 10) ? (small2 + small1 * 10) : (small1 + small2 * 10);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049981,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n  const result=[];\\n        for(let i=0;i<nums1.length;i++){\\n          for(let j=0;j<nums2.length;j++){\\n            if(nums1[i]===nums2[j])\\n            result.push(nums1[i]);\\n            else\\n            result.push(parseInt(nums1[i].toString()+nums2[j].toString()));\\n          }\\n        }\\n        for(let i=0;i<nums1.length;i++){\\n          for(let j=0;j<nums2.length;j++){\\n            if(nums1[i]===nums2[j])\\n            result.push(nums1[i]);\\n            else\\n            result.push(parseInt(nums2[j].toString()+nums1[i].toString()));\\n          }\\n        }\\n        return Math.min(...result);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n  const result=[];\\n        for(let i=0;i<nums1.length;i++){\\n          for(let j=0;j<nums2.length;j++){\\n            if(nums1[i]===nums2[j])\\n            result.push(nums1[i]);\\n            else\\n            result.push(parseInt(nums1[i].toString()+nums2[j].toString()));\\n          }\\n        }\\n        for(let i=0;i<nums1.length;i++){\\n          for(let j=0;j<nums2.length;j++){\\n            if(nums1[i]===nums2[j])\\n            result.push(nums1[i]);\\n            else\\n            result.push(parseInt(nums2[j].toString()+nums1[i].toString()));\\n          }\\n        }\\n        return Math.min(...result);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044716,
                "title": "easy-solution-in-java-with-100-less-run-time-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int arr[] = new int[20];\\n        int a = -1, b = -1;\\n        for(int i : nums1)\\n            arr[i]++;\\n        for(int i : nums2)\\n            arr[i+10]++;\\n        for(int i=0; i<10; i++){\\n            if(arr[i] == 1 && arr[i+10] == 1)\\n                return i;\\n            if(a == -1 && arr[i] == 1)\\n                a = i;\\n            if(b == -1 && arr[i+10] == 1)\\n                b = i;\\n        }\\n        return Math.min(a,b)*10+Math.max(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int arr[] = new int[20];\\n        int a = -1, b = -1;\\n        for(int i : nums1)\\n            arr[i]++;\\n        for(int i : nums2)\\n            arr[i+10]++;\\n        for(int i=0; i<10; i++){\\n            if(arr[i] == 1 && arr[i+10] == 1)\\n                return i;\\n            if(a == -1 && arr[i] == 1)\\n                a = i;\\n            if(b == -1 && arr[i+10] == 1)\\n                b = i;\\n        }\\n        return Math.min(a,b)*10+Math.max(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022113,
                "title": "easiest-ever-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        unordered_map<int,int> h;\\n        for(auto i:nums2)\\n        h[i]++;\\n\\n        \\n        for(auto i:nums1)\\n        {\\n            if(h[i]>0)\\n            return i;\\n        }\\n\\n        int ans=0;\\n        ans=nums1[0];\\n        ans=ans*10+nums2[0];\\n\\n        int ans2=0;\\n        ans2=nums2[0];\\n        ans2=ans2*10+nums1[0];\\n\\n        return min(ans,ans2) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        unordered_map<int,int> h;\\n        for(auto i:nums2)\\n        h[i]++;\\n\\n        \\n        for(auto i:nums1)\\n        {\\n            if(h[i]>0)\\n            return i;\\n        }\\n\\n        int ans=0;\\n        ans=nums1[0];\\n        ans=ans*10+nums2[0];\\n\\n        int ans2=0;\\n        ans2=nums2[0];\\n        ans2=ans2*10+nums1[0];\\n\\n        return min(ans,ans2) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018951,
                "title": "java-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> hs1 =  new HashSet<>();\\n       Set<Integer> hs2 =  new HashSet<>();\\n       for(int i : nums1){hs1.add(i);}\\n       for(int i : nums2){hs2.add(i) ;}\\n       for(int  i =1 ; i<=99 ; i++){\\n           if(i<=9){if(hs1.contains(i) && hs2.contains(i))return  i ; }\\n           else {\\n               int j=i/10 ; \\n               if( hs1.contains(i%10) &&hs2.contains(j) || hs1.contains(j)&&hs2.contains(i%10)){return i ;}\\n           }\\n       }\\n\\n        return 0 ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> hs1 =  new HashSet<>();\\n       Set<Integer> hs2 =  new HashSet<>();\\n       for(int i : nums1){hs1.add(i);}\\n       for(int i : nums2){hs2.add(i) ;}\\n       for(int  i =1 ; i<=99 ; i++){\\n           if(i<=9){if(hs1.contains(i) && hs2.contains(i))return  i ; }\\n           else {\\n               int j=i/10 ; \\n               if( hs1.contains(i%10) &&hs2.contains(j) || hs1.contains(j)&&hs2.contains(i%10)){return i ;}\\n           }\\n       }\\n\\n        return 0 ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015002,
                "title": "python3-solution-using-sets-and-built-in-functions",
                "content": "# Intuition\\nWe need to first check if the answer can be 1-digit. Then we check the minimum value of 2 digit answers.\\n\\n# Approach\\nWe first get the intersection of 2 sets containing values in $$nums$$. If the intersection is not empty, that means we can come up with a 1-digit answer. So we return the minimum value in the intersection. \\n\\nIf the intersection is empty, then we need to create a 2-digit answer. We get the minimum value from each set and use the smaller value as the 10\\'s digit and the other as 1\\'s digit.\\n\\n# Complexity\\n- Time complexity: $$O(n+m)$$\\n    - $$n$$ is the size of $$nums1$$ \\n    - $$m$$ is the size of $$nums2$$\\n    - 1-pass for each list to convert to set => $$O(n+m)$$\\n    - 1-pass of the smaller set to get the intersection => $$O(min(n,m))$$ \\n    - 1-pass to iterate over the intersection => $$O(len(intersect(nums1, nums2)))$$\\n    - 1-pass to find minimum in each list => $$O(n+m)$$\\n    - The dominating term here is => $$O(n+m)$$\\n\\n- Space complexity: $$O(n+m)$$\\n    - We create sets to hold all the data  $$O(n+m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        single = set(nums1) & set(nums2)\\n        if single: return min(single)\\n        m1, m2 = min(nums1), min(nums2)\\n        return min(m1,m2) * 10 + max(m1, m2)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        single = set(nums1) & set(nums2)\\n        if single: return min(single)\\n        m1, m2 = min(nums1), min(nums2)\\n        return min(m1,m2) * 10 + max(m1, m2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014843,
                "title": "not-so-much-short-code-lines-but-here-is-my-solution",
                "content": "It is not short code lines. I think it could be more efficient when last 6 lines would change. Anyway, Thanks for reading :)\\nIf this is helpful, Please thumbs up! :)\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        total_num = nums1 + nums2\\n        same_ans = []\\n        hash_ = {}\\n        for i in total_num:\\n            if i in hash_:\\n                hash_[i] += 1\\n            else:\\n                hash_[i] = 1\\n        for i, k in enumerate(hash_):\\n            if hash_[k] == 2:\\n                same_ans.append(k)\\n        if same_ans:\\n            return min(same_ans)\\n        ans = []\\n        ans.append(min(nums1))\\n        ans.append(min(nums2))\\n        ans.sort()\\n        ans = [str(i) for i in ans]\\n        return int(\\'\\'.join(ans))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        total_num = nums1 + nums2\\n        same_ans = []\\n        hash_ = {}\\n        for i in total_num:\\n            if i in hash_:\\n                hash_[i] += 1\\n            else:\\n                hash_[i] = 1\\n        for i, k in enumerate(hash_):\\n            if hash_[k] == 2:\\n                same_ans.append(k)\\n        if same_ans:\\n            return min(same_ans)\\n        ans = []\\n        ans.append(min(nums1))\\n        ans.append(min(nums2))\\n        ans.sort()\\n        ans = [str(i) for i in ans]\\n        return int(\\'\\'.join(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014816,
                "title": "javascript-sets-min",
                "content": "# Code\\n```\\nvar minNumber = function(nums1, nums2) {\\n    const s1 = new Set(nums1);\\n    const s2 = new Set(nums2);\\n    for (let i = 0; i < 10; i++) {\\n        if (s1.has(i) && s2.has(i)) return i;\\n    }\\n    const m1 = Math.min(...nums1);\\n    const m2 = Math.min(...nums2);\\n    return +`${Math.min(m1, m2)}${Math.max(m1, m2)}`\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minNumber = function(nums1, nums2) {\\n    const s1 = new Set(nums1);\\n    const s2 = new Set(nums2);\\n    for (let i = 0; i < 10; i++) {\\n        if (s1.has(i) && s2.has(i)) return i;\\n    }\\n    const m1 = Math.min(...nums1);\\n    const m2 = Math.min(...nums2);\\n    return +`${Math.min(m1, m2)}${Math.max(m1, m2)}`\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013321,
                "title": "c-hash-concise-understandable",
                "content": "# Intuition\\nAt first sight, we can easily think of using **sort** to solve it, and after thinking for a while, using **hash table** is not a bad way.\\n\\n# Approach\\n1. **using two set(st1/st2) to store nums1 and nums2**;\\n2. **find the element of st2 in st1**, if successfully, then return the element;\\n3. if failingly, just **take the first element from st1 and st2, compare them and caculate the result**. \\n\\n# Complexity\\n- Time complexity:\\n$$O(logN1 + logN2)$$\\uFF1AN1 and N2 represent the length of nums1 and nums2.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st1, st2;\\n        for (auto &num : nums1) {\\n            st1.insert(num);\\n        }\\n\\n        for (auto &num : nums2) {\\n            st2.insert(num);\\n        }\\n\\n        for (auto it : st1) {\\n            if (st2.find(it) != st2.end()) {\\n                return it;\\n            }\\n        }\\n\\n        return *st1.begin() < *st2.begin() ? *st1.begin() * 10 + *st2.begin() : *st2.begin() * 10 + *st1.begin();        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st1, st2;\\n        for (auto &num : nums1) {\\n            st1.insert(num);\\n        }\\n\\n        for (auto &num : nums2) {\\n            st2.insert(num);\\n        }\\n\\n        for (auto it : st1) {\\n            if (st2.find(it) != st2.end()) {\\n                return it;\\n            }\\n        }\\n\\n        return *st1.begin() < *st2.begin() ? *st1.begin() * 10 + *st2.begin() : *st2.begin() * 10 + *st1.begin();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004880,
                "title": "c-hash-map-sort-100-beats",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        std::unordered_map<int, int> cache;\\n        std::size_t i = 0, j = 0;\\n        int oneDigitMin = INT_MAX;\\n\\n        while(i < nums1.size() && j < nums2.size())\\n        {\\n            ++cache[nums1[i++]];\\n            ++cache[nums2[j++]];\\n        }\\n\\n        while(i < nums1.size()) ++cache[nums1[i++]];\\n        while(j < nums2.size()) ++cache[nums2[j++]];\\n\\n        for(const auto &i : cache)\\n        {\\n            if(i.second == 2) oneDigitMin = std::min(oneDigitMin, i.first);\\n        }\\n\\n        if(oneDigitMin != INT_MAX) return oneDigitMin;\\n\\n        std::sort(nums1.begin(), nums1.end());\\n        std::sort(nums2.begin(), nums2.end());\\n\\n        return nums1[0] < nums2[0] ? nums1[0] * 10 + nums2[0] : nums2[0] * 10 + nums1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        std::unordered_map<int, int> cache;\\n        std::size_t i = 0, j = 0;\\n        int oneDigitMin = INT_MAX;\\n\\n        while(i < nums1.size() && j < nums2.size())\\n        {\\n            ++cache[nums1[i++]];\\n            ++cache[nums2[j++]];\\n        }\\n\\n        while(i < nums1.size()) ++cache[nums1[i++]];\\n        while(j < nums2.size()) ++cache[nums2[j++]];\\n\\n        for(const auto &i : cache)\\n        {\\n            if(i.second == 2) oneDigitMin = std::min(oneDigitMin, i.first);\\n        }\\n\\n        if(oneDigitMin != INT_MAX) return oneDigitMin;\\n\\n        std::sort(nums1.begin(), nums1.end());\\n        std::sort(nums2.begin(), nums2.end());\\n\\n        return nums1[0] < nums2[0] ? nums1[0] * 10 + nums2[0] : nums2[0] * 10 + nums1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003489,
                "title": "o-n-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> cnt(10,0);\\n        int min_1=nums1[0],min_2=nums2[0],min_common=10;\\n        for(auto num1:nums1){\\n            cnt[num1]++;\\n            min_1=min(min_1,num1);\\n        };\\n        for(auto num2:nums2){\\n            min_2=min(min_2,num2);\\n            if(cnt[num2]>0) min_common=min(min_common,num2);    \\n        }\\n        if(min_common!=10) return min_common;\\n        else return min_1>min_2? min_2*10+min_1: min_1*10+min_2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> cnt(10,0);\\n        int min_1=nums1[0],min_2=nums2[0],min_common=10;\\n        for(auto num1:nums1){\\n            cnt[num1]++;\\n            min_1=min(min_1,num1);\\n        };\\n        for(auto num2:nums2){\\n            min_2=min(min_2,num2);\\n            if(cnt[num2]>0) min_common=min(min_common,num2);    \\n        }\\n        if(min_common!=10) return min_common;\\n        else return min_1>min_2? min_2*10+min_1: min_1*10+min_2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003373,
                "title": "simple-beginner-level-c-solution-runtime-0-ms-beats-100-o-1-time-and-space",
                "content": "\\n# Complexity\\n- Time complexity:  ```O(n^2)``` --> ```O(9^2)``` --> ```O(81)``` --> ```O(1)```\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\n// Runtime 0 ms Beats 100% Memory 5.6 MB Beats 75%\\ninline int max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\ninline int min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\nint minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int result = 89;  // the largest smallest-number allowed is 89\\n    for (int i = 0; i < nums1Size; i++) {\\n        for (int j = 0; j < nums2Size; j++) {\\n            result = min(result, (nums1[i] == nums2[j] ? \\n                         nums1[i] : min(nums1[i], nums2[j]) * 10 + max(nums1[i], nums2[j])));\\n        }\\n    }\\n    return result;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Enumeration"
                ],
                "code": "```O(n^2)```\n```O(9^2)```\n```O(81)```\n```O(1)```\n```O(1)```\n```cpp\\n// Runtime 0 ms Beats 100% Memory 5.6 MB Beats 75%\\ninline int max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\ninline int min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\nint minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int result = 89;  // the largest smallest-number allowed is 89\\n    for (int i = 0; i < nums1Size; i++) {\\n        for (int j = 0; j < nums2Size; j++) {\\n            result = min(result, (nums1[i] == nums2[j] ? \\n                         nums1[i] : min(nums1[i], nums2[j]) * 10 + max(nums1[i], nums2[j])));\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987409,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int minNumber(int[] a, int[] b)\\n    {\\n        ArrayList<Integer>s=new ArrayList<Integer>();\\n         ArrayList<Integer>s1=new ArrayList<Integer>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<b.length;j++)\\n            {\\n                int n=(a[i]*10)+b[j];\\n                s.add(n);\\n                int r=reverse(n);\\n                s.add(r);           \\n            }\\n        }\\n        int arr[]=new int[s.size()];int c=0;\\n        for(int i:s)\\n            arr[c++]=i;\\n        Arrays.sort(arr);\\n        int max=arr[0];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]%11==0)\\n            {\\n                s1.add(arr[i]%10);\\n                int a1[]=new int[s1.size()];int x=0;\\n                for(int j:s1)\\n                a1[x++]=j;\\n                Arrays.sort(a1);\\n                max=a1[0];\\n            }\\n        }\\n        return max;\\n        \\n    }\\n    public static int reverse(int n)\\n    {\\n        int r=0;\\n        int d=0;\\n        while(n>0)\\n        {\\n            d=n%10;\\n            r=r*10+d;\\n            n=n/10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int minNumber(int[] a, int[] b)\\n    {\\n        ArrayList<Integer>s=new ArrayList<Integer>();\\n         ArrayList<Integer>s1=new ArrayList<Integer>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<b.length;j++)\\n            {\\n                int n=(a[i]*10)+b[j];\\n                s.add(n);\\n                int r=reverse(n);\\n                s.add(r);           \\n            }\\n        }\\n        int arr[]=new int[s.size()];int c=0;\\n        for(int i:s)\\n            arr[c++]=i;\\n        Arrays.sort(arr);\\n        int max=arr[0];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]%11==0)\\n            {\\n                s1.add(arr[i]%10);\\n                int a1[]=new int[s1.size()];int x=0;\\n                for(int j:s1)\\n                a1[x++]=j;\\n                Arrays.sort(a1);\\n                max=a1[0];\\n            }\\n        }\\n        return max;\\n        \\n    }\\n    public static int reverse(int n)\\n    {\\n        int r=0;\\n        int d=0;\\n        while(n>0)\\n        {\\n            d=n%10;\\n            r=r*10+d;\\n            n=n/10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987088,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int smallest1=nums1[0], smallest2=nums2[0], equal=INT_MAX, flag = 1;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i < nums1.size(); i++){\\n            if(smallest1 > nums1[i]) smallest1 = nums1[i];\\n            mp[nums1[i]]=1;\\n        }\\n        for(int i=0; i < nums2.size(); i++){\\n            if(mp.find(nums2[i])!=mp.end()){\\n                if(equal > nums2[i]) equal = nums2[i];\\n                flag = 0;\\n            }\\n            else if(flag and smallest2 > nums2[i]) smallest2 = nums2[i];\\n        }\\n        if(equal!=INT_MAX) return equal;\\n        else if(smallest1 < smallest2) return smallest1*10 + smallest2;\\n        return smallest2*10 + smallest1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int smallest1=nums1[0], smallest2=nums2[0], equal=INT_MAX, flag = 1;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i < nums1.size(); i++){\\n            if(smallest1 > nums1[i]) smallest1 = nums1[i];\\n            mp[nums1[i]]=1;\\n        }\\n        for(int i=0; i < nums2.size(); i++){\\n            if(mp.find(nums2[i])!=mp.end()){\\n                if(equal > nums2[i]) equal = nums2[i];\\n                flag = 0;\\n            }\\n            else if(flag and smallest2 > nums2[i]) smallest2 = nums2[i];\\n        }\\n        if(equal!=INT_MAX) return equal;\\n        else if(smallest1 < smallest2) return smallest1*10 + smallest2;\\n        return smallest2*10 + smallest1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981267,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort(reverse=True)\\n        nums2.sort(reverse=True)\\n\\n        \\n\\n        while nums1[-1] == 0:\\n            nums1.pop()\\n        \\n        while nums2[-1] == 0:\\n            nums2.pop()\\n       \\n        for i in nums1[::-1]:\\n            if i in nums2[::-1]:\\n                return i\\n        \\n        val1 = nums1[-1]\\n        val2 = nums2[-1]\\n\\n        if val1 < val2:\\n            return val1 * 10 + val2\\n        else:\\n            return val2 * 10 + val1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort(reverse=True)\\n        nums2.sort(reverse=True)\\n\\n        \\n\\n        while nums1[-1] == 0:\\n            nums1.pop()\\n        \\n        while nums2[-1] == 0:\\n            nums2.pop()\\n       \\n        for i in nums1[::-1]:\\n            if i in nums2[::-1]:\\n                return i\\n        \\n        val1 = nums1[-1]\\n        val2 = nums2[-1]\\n\\n        if val1 < val2:\\n            return val1 * 10 + val2\\n        else:\\n            return val2 * 10 + val1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977121,
                "title": "1ms-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int j=0;j<nums2.length;j++)\\n        {\\n            list.add(nums2[j]);\\n        }\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(list.contains(nums1[i]))\\n            {\\n                return nums1[i];\\n            }\\n        }\\n\\n        int x=nums1[0];\\n        int y=nums2[0];\\n        if(x<y)\\n        {\\n            return (x*10)+y;\\n        }\\n        return (y*10)+x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int j=0;j<nums2.length;j++)\\n        {\\n            list.add(nums2[j]);\\n        }\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(list.contains(nums1[i]))\\n            {\\n                return nums1[i];\\n            }\\n        }\\n\\n        int x=nums1[0];\\n        int y=nums2[0];\\n        if(x<y)\\n        {\\n            return (x*10)+y;\\n        }\\n        return (y*10)+x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974311,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int s1=nums1[0],s2=nums2[0];\\n        if(contains(nums1,nums2)!=-1){\\n            return contains(nums1,nums2);\\n        }\\n        else if(s1>s2){\\n            return s2*10+s1;\\n        }\\n        return s1*10+s2;\\n    }\\n    public static int contains(int[]nums1,int[]nums2){\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int s1=nums1[0],s2=nums2[0];\\n        if(contains(nums1,nums2)!=-1){\\n            return contains(nums1,nums2);\\n        }\\n        else if(s1>s2){\\n            return s2*10+s1;\\n        }\\n        return s1*10+s2;\\n    }\\n    public static int contains(int[]nums1,int[]nums2){\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968441,
                "title": "an-easy-way-to-solve-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = [0]*9\\n        for i in nums1:\\n            nums[i-1] = 2\\n        for i in nums2:\\n            nums[i-1] -= 1\\n        pos = 0\\n        neg = 0\\n        ans = 0\\n        for i in range(9):\\n            if nums[i] == 1:\\n                return i+1\\n            elif nums[i] == 2 and pos == 0 and neg == 0:\\n                ans = 10*(i+1)\\n                pos += 1\\n            elif nums[i] == -1 and pos == 0 and neg == 0:\\n                ans = 10*(i+1)\\n                neg += 1\\n            elif nums[i] == 2 and pos == 0 and neg == 1:\\n                ans += i+1\\n                pos += 1\\n            elif nums[i] == -1 and pos == 1 and neg == 0:\\n                ans += i+1\\n                neg += 1\\n            else:\\n                pass\\n        return ans\\n            \\n             \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = [0]*9\\n        for i in nums1:\\n            nums[i-1] = 2\\n        for i in nums2:\\n            nums[i-1] -= 1\\n        pos = 0\\n        neg = 0\\n        ans = 0\\n        for i in range(9):\\n            if nums[i] == 1:\\n                return i+1\\n            elif nums[i] == 2 and pos == 0 and neg == 0:\\n                ans = 10*(i+1)\\n                pos += 1\\n            elif nums[i] == -1 and pos == 0 and neg == 0:\\n                ans = 10*(i+1)\\n                neg += 1\\n            elif nums[i] == 2 and pos == 0 and neg == 1:\\n                ans += i+1\\n                pos += 1\\n            elif nums[i] == -1 and pos == 1 and neg == 0:\\n                ans += i+1\\n                neg += 1\\n            else:\\n                pass\\n        return ans\\n            \\n             \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964014,
                "title": "simple-solution-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        \\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] temp=new int[Math.max(nums1[nums1.length-1],nums2[nums2.length-1])+1];\\n\\n        int n1=nums1[0];\\n\\n        int n2=nums2[0];\\n\\n        int k=Math.min(n1*10+n2,n2*10+n1);\\n\\n        for(int i=0;i<nums1.length;i++){\\n            temp[nums1[i]]++;\\n        }\\n\\n        for(int j=0;j<nums2.length;j++){\\n            if(temp[nums2[j]]>0){\\n                k=Math.min(k,nums2[j]);\\n                return k;\\n            }\\n        }\\n\\n        return k;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        \\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] temp=new int[Math.max(nums1[nums1.length-1],nums2[nums2.length-1])+1];\\n\\n        int n1=nums1[0];\\n\\n        int n2=nums2[0];\\n\\n        int k=Math.min(n1*10+n2,n2*10+n1);\\n\\n        for(int i=0;i<nums1.length;i++){\\n            temp[nums1[i]]++;\\n        }\\n\\n        for(int j=0;j<nums2.length;j++){\\n            if(temp[nums2[j]]>0){\\n                k=Math.min(k,nums2[j]);\\n                return k;\\n            }\\n        }\\n\\n        return k;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958326,
                "title": "c-easy-solution-using-basic-sorting-knowledge",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n                    for(int i=0; i<nums1.size(); i++){\\n                            for(int j=0; j<nums2.size(); j++){\\n                                    if(nums1[i]==nums2[j]){\\n                                            return nums1[i];\\n                                    }\\n                            }\\n                    }\\n            if(nums1[0]<nums2[0]){\\n                    return (nums1[0]*10)+nums2[0];\\n            }\\n            \\n             return (nums2[0]*10)+nums1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n                    for(int i=0; i<nums1.size(); i++){\\n                            for(int j=0; j<nums2.size(); j++){\\n                                    if(nums1[i]==nums2[j]){\\n                                            return nums1[i];\\n                                    }\\n                            }\\n                    }\\n            if(nums1[0]<nums2[0]){\\n                    return (nums1[0]*10)+nums2[0];\\n            }\\n            \\n             return (nums2[0]*10)+nums1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955282,
                "title": "97-beats-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean flag = false;\\n        int num=0;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int i=0;int j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                return nums1[i];\\n            }\\n        }\\n        if(nums1[0]<nums2[0]){\\n           return nums1[0]*10+nums2[0];\\n        }else{\\n           return nums2[0]*10 + nums1[0];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean flag = false;\\n        int num=0;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int i=0;int j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                return nums1[i];\\n            }\\n        }\\n        if(nums1[0]<nums2[0]){\\n           return nums1[0]*10+nums2[0];\\n        }else{\\n           return nums2[0]*10 + nums1[0];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950490,
                "title": "one-line-solution-using-intersection-of-sets",
                "content": "# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        return min(set(nums1).intersection(set(nums2))) if len(set(nums1).intersection(set(nums2)))!=0 else min([min(nums1)*10+min(nums2),min(nums2)*10+min(nums1)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        return min(set(nums1).intersection(set(nums2))) if len(set(nums1).intersection(set(nums2)))!=0 else min([min(nums1)*10+min(nums2),min(nums2)*10+min(nums1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950242,
                "title": "c-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:\\noverall time complexity is O(n1 * log(n1) + n2 * log(n2) + n1 * n2), which simplifies to O(n1 * n2 + (n1 + n2) * log(n1 + n2)).\\n- Space complexity:\\nspace complexity of this code is O(n1+n2).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    cout<<nums1[i];\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        if(nums1[0]>nums2[0])\\n        {\\n            return (nums2[0]*10)+nums1[0];\\n        }\\n        else\\n        {\\n            return (nums1[0]*10)+nums2[0];\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    cout<<nums1[i];\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        if(nums1[0]>nums2[0])\\n        {\\n            return (nums2[0]*10)+nums1[0];\\n        }\\n        else\\n        {\\n            return (nums1[0]*10)+nums2[0];\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3946331,
                "title": "form-smallest-number-from-two-digit-arrays-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n\\tpublic int minNumber(int[] nums1, int[] nums2) {\\n\\t\\tint n = equalnum(nums1, nums2);\\n\\t\\tif(n==0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tArrays.sort(nums1);\\n\\t\\t\\tArrays.sort(nums2);\\n\\t\\t\\tlist.add(nums1[0]);\\n\\t\\t\\tlist.add(nums2[0]);\\n\\t\\t\\tCollections.sort(list);\\n\\t\\t\\tString s = \"\";\\n\\t\\t\\tfor(int l : list) {\\n\\t\\t\\t\\ts += l;\\n\\t\\t\\t}\\n\\t\\t\\treturn Integer.parseInt(s);\\n\\t\\t}else {\\n\\t\\t\\treturn n;\\n\\t\\t}\\n\\t}\\n\\tpublic int equalnum(int[] num1, int[] num2) {\\n\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\tif((num1.length==num2.length) || (num1.length<num2.length)) {\\n\\t\\t\\tfor(int i : num1) {\\n\\t\\t\\t\\tfor(int j : num2) {\\n\\t\\t\\t\\t\\tif(i==j) {\\n\\t\\t\\t\\t\\t\\tlist.add(i); break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}else if(num1.length>num2.length) {\\n\\t\\t\\tfor(int i : num2) {\\n\\t\\t\\t\\tfor(int j : num1) {\\n\\t\\t\\t\\t\\tif(i==j) {\\n\\t\\t\\t\\t\\t\\tlist.add(i); break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list.size() == 0 ? 0 : Collections.min(list);\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution smallestnum = new Solution();\\n\\t\\tint[] nums11 = {4,1,3}, nums12 = {5,7};\\n\\t\\tint[] nums21 = {3,5,2,6}, nums22 = {3,1,7};\\n\\t\\tSystem.out.println(\"Form Smallest Number From Two Digit Arrays : \" + smallestnum.minNumber(nums11, nums12));\\n\\t\\tSystem.out.println(\"Form Smallest Number From Two Digit Arrays : \" + smallestnum.minNumber(nums21, nums22));\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n\\tpublic int minNumber(int[] nums1, int[] nums2) {\\n\\t\\tint n = equalnum(nums1, nums2);\\n\\t\\tif(n==0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tArrays.sort(nums1);\\n\\t\\t\\tArrays.sort(nums2);\\n\\t\\t\\tlist.add(nums1[0]);\\n\\t\\t\\tlist.add(nums2[0]);\\n\\t\\t\\tCollections.sort(list);\\n\\t\\t\\tString s = \"\";\\n\\t\\t\\tfor(int l : list) {\\n\\t\\t\\t\\ts += l;\\n\\t\\t\\t}\\n\\t\\t\\treturn Integer.parseInt(s);\\n\\t\\t}else {\\n\\t\\t\\treturn n;\\n\\t\\t}\\n\\t}\\n\\tpublic int equalnum(int[] num1, int[] num2) {\\n\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\tif((num1.length==num2.length) || (num1.length<num2.length)) {\\n\\t\\t\\tfor(int i : num1) {\\n\\t\\t\\t\\tfor(int j : num2) {\\n\\t\\t\\t\\t\\tif(i==j) {\\n\\t\\t\\t\\t\\t\\tlist.add(i); break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}else if(num1.length>num2.length) {\\n\\t\\t\\tfor(int i : num2) {\\n\\t\\t\\t\\tfor(int j : num1) {\\n\\t\\t\\t\\t\\tif(i==j) {\\n\\t\\t\\t\\t\\t\\tlist.add(i); break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list.size() == 0 ? 0 : Collections.min(list);\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution smallestnum = new Solution();\\n\\t\\tint[] nums11 = {4,1,3}, nums12 = {5,7};\\n\\t\\tint[] nums21 = {3,5,2,6}, nums22 = {3,1,7};\\n\\t\\tSystem.out.println(\"Form Smallest Number From Two Digit Arrays : \" + smallestnum.minNumber(nums11, nums12));\\n\\t\\tSystem.out.println(\"Form Smallest Number From Two Digit Arrays : \" + smallestnum.minNumber(nums21, nums22));\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943319,
                "title": "clean-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int min1 = 10;\\n        int min2 = 10;\\n        int common = 10;\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            if(nums1[i] < min1)min1 = nums1[i];\\n            hs.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(nums2[i] < min2)min2=nums2[i];\\n            if(hs.contains(nums2[i])){\\n                if(nums2[i] < common){\\n                    common = nums2[i];\\n                }\\n            }\\n        }\\n        if(common<10)return common;\\n        if(min1<min2){\\n            return min1*10+min2;\\n        }else{\\n            return min2*10+min1;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int min1 = 10;\\n        int min2 = 10;\\n        int common = 10;\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            if(nums1[i] < min1)min1 = nums1[i];\\n            hs.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(nums2[i] < min2)min2=nums2[i];\\n            if(hs.contains(nums2[i])){\\n                if(nums2[i] < common){\\n                    common = nums2[i];\\n                }\\n            }\\n        }\\n        if(common<10)return common;\\n        if(min1<min2){\\n            return min1*10+min2;\\n        }else{\\n            return min2*10+min1;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939612,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int>m1;map<int,int>m2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            m2[nums2[i]]++;\\n        }\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(m1[i] and m2[i])\\n            {\\n                return i;\\n            }\\n        }\\n        int mi1=*min_element(nums1.begin(),nums1.end());\\n        int mi2=*min_element(nums2.begin(),nums2.end());\\n        if(mi1<=mi2)\\n        {\\n            return mi1*10+mi2;\\n        }   \\n        else return mi2*10+mi1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int>m1;map<int,int>m2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            m2[nums2[i]]++;\\n        }\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(m1[i] and m2[i])\\n            {\\n                return i;\\n            }\\n        }\\n        int mi1=*min_element(nums1.begin(),nums1.end());\\n        int mi2=*min_element(nums2.begin(),nums2.end());\\n        if(mi1<=mi2)\\n        {\\n            return mi1*10+mi2;\\n        }   \\n        else return mi2*10+mi1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935741,
                "title": "good-and-dynamic-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int ans=stoi(to_string(nums1[0])+to_string(nums2[0]));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans=min(ans,nums1[i]);\\n                }\\n                else{\\n                    int x;\\n                    if(nums1[i]<nums2[j]){\\n                        x=stoi(to_string(nums1[i])+to_string(nums2[j]));\\n                    }\\n                    else{\\n                        x=stoi(to_string(nums2[j])+to_string(nums1[i]));\\n                    }\\n                    ans=min(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int ans=stoi(to_string(nums1[0])+to_string(nums2[0]));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans=min(ans,nums1[i]);\\n                }\\n                else{\\n                    int x;\\n                    if(nums1[i]<nums2[j]){\\n                        x=stoi(to_string(nums1[i])+to_string(nums2[j]));\\n                    }\\n                    else{\\n                        x=stoi(to_string(nums2[j])+to_string(nums1[i]));\\n                    }\\n                    ans=min(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933582,
                "title": "easy-to-understand-c-brute",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        int q=(nums1[0]*10)+nums2[0];\\n        int r=(nums2[0]*10)+nums1[0];\\n        \\n        return min(q,r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        int q=(nums1[0]*10)+nums2[0];\\n        int r=(nums2[0]*10)+nums1[0];\\n        \\n        return min(q,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933579,
                "title": "best-time-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Hashmap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { // \\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int hash[10]={0};\\n        int min1=INT_MAX;\\n        for(int i=0;i<nums1.size();i++){\\n            hash[nums1[i]]++;\\n            min1=min(min1,nums1[i]);\\n        }\\n        int min2=INT_MAX;\\n        for(int j=0;j<nums2.size();j++){\\n            hash[nums2[j]]++;\\n            min2=min(min2,nums2[j]);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(hash[i]==2){\\n                return i;\\n            }\\n        }\\n        int k=min1*10+min2;\\n        int w=min2*10+min1;\\n        return min(k,w);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { // \\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int hash[10]={0};\\n        int min1=INT_MAX;\\n        for(int i=0;i<nums1.size();i++){\\n            hash[nums1[i]]++;\\n            min1=min(min1,nums1[i]);\\n        }\\n        int min2=INT_MAX;\\n        for(int j=0;j<nums2.size();j++){\\n            hash[nums2[j]]++;\\n            min2=min(min2,nums2[j]);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(hash[i]==2){\\n                return i;\\n            }\\n        }\\n        int k=min1*10+min2;\\n        int w=min2*10+min1;\\n        return min(k,w);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930321,
                "title": "c-using-bool-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n      // if(nums1||nums2==NULL){\\n      //   return;\\n      //   exit;\\n      // }\\n       int min1=*min_element(nums1.begin(),nums1.end());\\n       int min2=*min_element(nums2.begin(),nums2.end());\\n       bool isright= false;\\n       vector<int>store;\\n       int mn;\\n       for(int i=0;i<nums1.size();i++){\\n            for(int k=0;k<nums2.size();k++){\\n                if(nums1[i]==nums2[k]){\\n               store.push_back(nums1[i]);  \\n                  mn= *min_element(store.begin(),store.end());\\n                  isright=true;\\n                }\\n                \\n            }\\n       }      \\n       if(isright){\\n         return mn;\\n         exit;\\n       }\\n\\n        string s1= to_string(min1);\\n        string s2= to_string(min2);\\n        if(min1<min2){\\n        string s3= s1+s2;\\n        int ans= stoi(s3); \\n          return ans;\\n        }else{\\n          string s4= s2+s1;\\n        int ans1= stoi(s4); \\n          return ans1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n      // if(nums1||nums2==NULL){\\n      //   return;\\n      //   exit;\\n      // }\\n       int min1=*min_element(nums1.begin(),nums1.end());\\n       int min2=*min_element(nums2.begin(),nums2.end());\\n       bool isright= false;\\n       vector<int>store;\\n       int mn;\\n       for(int i=0;i<nums1.size();i++){\\n            for(int k=0;k<nums2.size();k++){\\n                if(nums1[i]==nums2[k]){\\n               store.push_back(nums1[i]);  \\n                  mn= *min_element(store.begin(),store.end());\\n                  isright=true;\\n                }\\n                \\n            }\\n       }      \\n       if(isright){\\n         return mn;\\n         exit;\\n       }\\n\\n        string s1= to_string(min1);\\n        string s2= to_string(min2);\\n        if(min1<min2){\\n        string s3= s1+s2;\\n        int ans= stoi(s3); \\n          return ans;\\n        }else{\\n          string s4= s2+s1;\\n        int ans1= stoi(s4); \\n          return ans1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924246,
                "title": "java-one-pass-o-m-n",
                "content": "# Intuition\\nEasy level. must have one pass.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int minBoth = Integer.MAX_VALUE, min1 = nums1[0], min2 = nums2[0];\\n        HashSet<Integer> set = new HashSet();\\n        for(int n : nums1) {\\n            min1 = Math.min(min1, n);\\n            set.add(n);\\n        }\\n\\n        for(int n : nums2) {\\n            min2 = Math.min(min2, n);\\n            if(set.contains(n)) minBoth = Math.min(minBoth, n);\\n        }\\n\\n        if(minBoth != Integer.MAX_VALUE) return minBoth;\\n        return min1 < min2 ? min1 * 10 + min2 : min2 * 10 + min1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int minBoth = Integer.MAX_VALUE, min1 = nums1[0], min2 = nums2[0];\\n        HashSet<Integer> set = new HashSet();\\n        for(int n : nums1) {\\n            min1 = Math.min(min1, n);\\n            set.add(n);\\n        }\\n\\n        for(int n : nums2) {\\n            min2 = Math.min(min2, n);\\n            if(set.contains(n)) minBoth = Math.min(minBoth, n);\\n        }\\n\\n        if(minBoth != Integer.MAX_VALUE) return minBoth;\\n        return min1 < min2 ? min1 * 10 + min2 : min2 * 10 + min1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893847,
                "title": "java-solution-hashmap-o-n-m-not-common-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust want to do this question whithout using 2 For Loops.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing hashMAp to solve this.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nVery Much\\n# Code\\n```\\nclass Solution {\\n\\n    HashMap<Integer, Integer> map1 = new HashMap<>();\\n    HashMap<Integer, Integer> map2 = new HashMap<>();\\n    boolean flag  = false;\\n    ArrayList<Integer> common = new ArrayList<>();\\n\\n    public void mapping(int[] arr, HashMap<Integer,Integer> map){\\n\\n        for(int x : arr){\\n            if(map.containsKey(x)){\\n                map.put(x,map.get(x)+1);\\n            }else{\\n                map.put(x,1);\\n            }\\n\\n            if(flag == true){\\n                if(map1.containsKey(x)){\\n                    common.add(x);\\n                }\\n            }\\n        }\\n\\n        flag = true;\\n    }\\n\\n    public String minist(HashMap<Integer,Integer> map){\\n        Integer minValue =  new Integer(Integer.MAX_VALUE);\\n\\n        for(Map.Entry<Integer,Integer> e : map.entrySet()){\\n            if(e.getKey() < minValue){\\n                minValue = e.getKey();\\n            }\\n        }\\n\\n        String res = minValue.toString();\\n\\n        return res;\\n\\n    }\\n\\n\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        mapping(nums1, map1);\\n        mapping(nums2, map2);\\n        flag = false;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int x : common){\\n            if(min > x){\\n                min = x;\\n                flag = true;\\n            }\\n        }\\n\\n        if(flag == true){\\n            return min;\\n        }\\n\\n        String str1 = minist(map1);\\n        String str2 = minist(map2);\\n        String ans = \"\";\\n\\n        if(Integer.parseInt(str1) <= Integer.parseInt(str2)){\\n            ans = str1 + str2;\\n        }else{\\n            ans = str2 + str1;\\n        }\\n\\n        \\n\\n\\n        return Integer.parseInt(ans);\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    HashMap<Integer, Integer> map1 = new HashMap<>();\\n    HashMap<Integer, Integer> map2 = new HashMap<>();\\n    boolean flag  = false;\\n    ArrayList<Integer> common = new ArrayList<>();\\n\\n    public void mapping(int[] arr, HashMap<Integer,Integer> map){\\n\\n        for(int x : arr){\\n            if(map.containsKey(x)){\\n                map.put(x,map.get(x)+1);\\n            }else{\\n                map.put(x,1);\\n            }\\n\\n            if(flag == true){\\n                if(map1.containsKey(x)){\\n                    common.add(x);\\n                }\\n            }\\n        }\\n\\n        flag = true;\\n    }\\n\\n    public String minist(HashMap<Integer,Integer> map){\\n        Integer minValue =  new Integer(Integer.MAX_VALUE);\\n\\n        for(Map.Entry<Integer,Integer> e : map.entrySet()){\\n            if(e.getKey() < minValue){\\n                minValue = e.getKey();\\n            }\\n        }\\n\\n        String res = minValue.toString();\\n\\n        return res;\\n\\n    }\\n\\n\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        mapping(nums1, map1);\\n        mapping(nums2, map2);\\n        flag = false;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int x : common){\\n            if(min > x){\\n                min = x;\\n                flag = true;\\n            }\\n        }\\n\\n        if(flag == true){\\n            return min;\\n        }\\n\\n        String str1 = minist(map1);\\n        String str2 = minist(map2);\\n        String ans = \"\";\\n\\n        if(Integer.parseInt(str1) <= Integer.parseInt(str2)){\\n            ans = str1 + str2;\\n        }else{\\n            ans = str2 + str1;\\n        }\\n\\n        \\n\\n\\n        return Integer.parseInt(ans);\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890453,
                "title": "from-the-smallest-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        for i in sorted(nums1):\\n            if i in nums2:\\n                return i\\n        i=str(min(nums1))\\n        j=str(min(nums2))\\n        return int(i+j) if j>i else int(j+i) \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        for i in sorted(nums1):\\n            if i in nums2:\\n                return i\\n        i=str(min(nums1))\\n        j=str(min(nums2))\\n        return int(i+j) if j>i else int(j+i) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887606,
                "title": "array-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime Complexity: O(N * M)\\nSpace Complexity: O(N * M)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) \\n    {\\n        int[] duplicatedAndMins = GetDuplicatedNumberAddMinNumbers(nums1, nums2);\\n        if(duplicatedAndMins.Length==2)\\n        {\\n            if(duplicatedAndMins[0] <= duplicatedAndMins[1])\\n            {\\n                return duplicatedAndMins[0] * 10 +  duplicatedAndMins[1];\\n            }\\n            else\\n            {\\n                return duplicatedAndMins[1] * 10 +  duplicatedAndMins[0];\\n            }\\n        }\\n        else\\n        {\\n            int min = duplicatedAndMins[0];\\n            for (int i = 0; i <= duplicatedAndMins.Length - 3; i++)\\n            {\\n                if(min > duplicatedAndMins[i])\\n                {\\n                    min = duplicatedAndMins[i];\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n\\n    private int[] GetDuplicatedNumberAddMinNumbers(int[] nums1, int[] nums2)\\n    {\\n        List<int> result = new List<int>();\\n        int minA = nums1[0];\\n        int minB = nums2[0];\\n\\n        foreach (int a in nums1)\\n        {\\n            if (minA > a)\\n            {\\n                minA = a;\\n            }\\n            foreach (int b in nums2)\\n            {\\n                if(minB > b)\\n                {\\n                    minB = b;\\n                }\\n                if(a==b)\\n                {\\n                    result.Add(a);\\n                }\\n            }\\n        }\\n        result.Add(minA);\\n        result.Add(minB);\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) \\n    {\\n        int[] duplicatedAndMins = GetDuplicatedNumberAddMinNumbers(nums1, nums2);\\n        if(duplicatedAndMins.Length==2)\\n        {\\n            if(duplicatedAndMins[0] <= duplicatedAndMins[1])\\n            {\\n                return duplicatedAndMins[0] * 10 +  duplicatedAndMins[1];\\n            }\\n            else\\n            {\\n                return duplicatedAndMins[1] * 10 +  duplicatedAndMins[0];\\n            }\\n        }\\n        else\\n        {\\n            int min = duplicatedAndMins[0];\\n            for (int i = 0; i <= duplicatedAndMins.Length - 3; i++)\\n            {\\n                if(min > duplicatedAndMins[i])\\n                {\\n                    min = duplicatedAndMins[i];\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n\\n    private int[] GetDuplicatedNumberAddMinNumbers(int[] nums1, int[] nums2)\\n    {\\n        List<int> result = new List<int>();\\n        int minA = nums1[0];\\n        int minB = nums2[0];\\n\\n        foreach (int a in nums1)\\n        {\\n            if (minA > a)\\n            {\\n                minA = a;\\n            }\\n            foreach (int b in nums2)\\n            {\\n                if(minB > b)\\n                {\\n                    minB = b;\\n                }\\n                if(a==b)\\n                {\\n                    result.Add(a);\\n                }\\n            }\\n        }\\n        result.Add(minA);\\n        result.Add(minB);\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887605,
                "title": "array-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime Complexity: O(N * M)\\nSpace Complexity: O(N * M)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) \\n    {\\n        int[] duplicatedAndMins = GetDuplicatedNumberAddMinNumbers(nums1, nums2);\\n        if(duplicatedAndMins.Length==2)\\n        {\\n            if(duplicatedAndMins[0] <= duplicatedAndMins[1])\\n            {\\n                return duplicatedAndMins[0] * 10 +  duplicatedAndMins[1];\\n            }\\n            else\\n            {\\n                return duplicatedAndMins[1] * 10 +  duplicatedAndMins[0];\\n            }\\n        }\\n        else\\n        {\\n            int min = duplicatedAndMins[0];\\n            for (int i = 0; i <= duplicatedAndMins.Length - 3; i++)\\n            {\\n                if(min > duplicatedAndMins[i])\\n                {\\n                    min = duplicatedAndMins[i];\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n\\n    private int[] GetDuplicatedNumberAddMinNumbers(int[] nums1, int[] nums2)\\n    {\\n        List<int> result = new List<int>();\\n        int minA = nums1[0];\\n        int minB = nums2[0];\\n\\n        foreach (int a in nums1)\\n        {\\n            if (minA > a)\\n            {\\n                minA = a;\\n            }\\n            foreach (int b in nums2)\\n            {\\n                if(minB > b)\\n                {\\n                    minB = b;\\n                }\\n                if(a==b)\\n                {\\n                    result.Add(a);\\n                }\\n            }\\n        }\\n        result.Add(minA);\\n        result.Add(minB);\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) \\n    {\\n        int[] duplicatedAndMins = GetDuplicatedNumberAddMinNumbers(nums1, nums2);\\n        if(duplicatedAndMins.Length==2)\\n        {\\n            if(duplicatedAndMins[0] <= duplicatedAndMins[1])\\n            {\\n                return duplicatedAndMins[0] * 10 +  duplicatedAndMins[1];\\n            }\\n            else\\n            {\\n                return duplicatedAndMins[1] * 10 +  duplicatedAndMins[0];\\n            }\\n        }\\n        else\\n        {\\n            int min = duplicatedAndMins[0];\\n            for (int i = 0; i <= duplicatedAndMins.Length - 3; i++)\\n            {\\n                if(min > duplicatedAndMins[i])\\n                {\\n                    min = duplicatedAndMins[i];\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n\\n    private int[] GetDuplicatedNumberAddMinNumbers(int[] nums1, int[] nums2)\\n    {\\n        List<int> result = new List<int>();\\n        int minA = nums1[0];\\n        int minB = nums2[0];\\n\\n        foreach (int a in nums1)\\n        {\\n            if (minA > a)\\n            {\\n                minA = a;\\n            }\\n            foreach (int b in nums2)\\n            {\\n                if(minB > b)\\n                {\\n                    minB = b;\\n                }\\n                if(a==b)\\n                {\\n                    result.Add(a);\\n                }\\n            }\\n        }\\n        result.Add(minA);\\n        result.Add(minB);\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886498,
                "title": "java-simple-solution-using-arrays-s-methods",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, sort two arrays\\n\\nThere are two scenarios of the result:\\n- One digit if exist at least one mutual number between two arrays (1)\\n- Two digits if no mutual number between two arrays (2)\\n\\nFor the first case (1), we return the smallest mutual number.\\n\\nFor the second case (2), we select the smallest number for each array, then the greater one will be the unit digit, and the other will be the dozen digit.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for (int num : nums1) {\\n            if (Arrays.binarySearch(nums2, num) >= 0) return num;\\n        }\\n        if (nums1[0] > nums2[0]) return nums2[0] * 10 + nums1[0];\\n        else return nums1[0] * 10 + nums2[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for (int num : nums1) {\\n            if (Arrays.binarySearch(nums2, num) >= 0) return num;\\n        }\\n        if (nums1[0] > nums2[0]) return nums2[0] * 10 + nums1[0];\\n        else return nums1[0] * 10 + nums2[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885491,
                "title": "easy-way-with-time-45ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    let min1 = 0;\\n    for(let a of nums1) {\\n        for (let b of nums2) {\\n            if ((a === b && min1 ===0) || (a === b && min1 > a)) min1 = a;\\n        }\\n    }\\n    if (min1 === 0) {\\n        Math.min(...nums1) >= Math.min(...nums2)? min1 =Math.min(...nums2) * 10 + Math.min(...nums1) : min1 =Math.min(...nums1) * 10 + Math.min(...nums2)\\n    }\\n\\n    return min1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    let min1 = 0;\\n    for(let a of nums1) {\\n        for (let b of nums2) {\\n            if ((a === b && min1 ===0) || (a === b && min1 > a)) min1 = a;\\n        }\\n    }\\n    if (min1 === 0) {\\n        Math.min(...nums1) >= Math.min(...nums2)? min1 =Math.min(...nums2) * 10 + Math.min(...nums1) : min1 =Math.min(...nums1) * 10 + Math.min(...nums2)\\n    }\\n\\n    return min1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879892,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x:nums1)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto x:nums2)\\n        {\\n            mp[x]++;\\n        }\\n\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x:mp)\\n        {\\n            if(x.second>1)\\n            {\\n                return x.first;\\n            }\\n        }\\n        string ans;\\n\\n        if(mn1>mn2)\\n        {\\n            ans=to_string(mn2)+to_string(mn1);\\n        }\\n        else\\n        {\\n            ans=ans=to_string(mn1)+to_string(mn2);\\n        }\\n        return stoi(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x:nums1)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto x:nums2)\\n        {\\n            mp[x]++;\\n        }\\n\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x:mp)\\n        {\\n            if(x.second>1)\\n            {\\n                return x.first;\\n            }\\n        }\\n        string ans;\\n\\n        if(mn1>mn2)\\n        {\\n            ans=to_string(mn2)+to_string(mn1);\\n        }\\n        else\\n        {\\n            ans=ans=to_string(mn1)+to_string(mn2);\\n        }\\n        return stoi(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867575,
                "title": "c-simplest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>m;\\n        int x=INT_MAX;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]++;\\n        }\\n       for(int i=0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n           if(m[nums2[i]]>1){\\n               x=min(x,nums2[i]);\\n           }\\n        }\\n        if(x==INT_MAX){\\n            sort(nums2.begin(),nums2.end());\\n            sort(nums1.begin(),nums1.end());\\n                return min(nums1[0]*10+nums2[0],nums2[0]*10+nums1[0]);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>m;\\n        int x=INT_MAX;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]++;\\n        }\\n       for(int i=0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n           if(m[nums2[i]]>1){\\n               x=min(x,nums2[i]);\\n           }\\n        }\\n        if(x==INT_MAX){\\n            sort(nums2.begin(),nums2.end());\\n            sort(nums1.begin(),nums1.end());\\n                return min(nums1[0]*10+nums2[0],nums2[0]*10+nums1[0]);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867384,
                "title": "most-easy-solution-fast-efficient-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                if(nums1[i]==nums2[j]){\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n\\n        if(nums1[0]<nums2[0]){\\n            ans += nums1[0];\\n            ans = (ans*10)+nums2[0];\\n        }else{\\n            ans += nums2[0];\\n            ans = (ans*10)+nums1[0];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                if(nums1[i]==nums2[j]){\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n\\n        if(nums1[0]<nums2[0]){\\n            ans += nums1[0];\\n            ans = (ans*10)+nums2[0];\\n        }else{\\n            ans += nums2[0];\\n            ans = (ans*10)+nums1[0];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864215,
                "title": "simple-o-n1-n2-solution-beat-100",
                "content": "# Intuition\\n1. Use an array of length 10 to store the frequency of each digit in nums1 and nums2 together. Then if some number has a frequency of 2, it meaning it appears in both nums1 and nums2 (each array contains unique digits).Then we could return this number directly(using the while loop we find this number).\\n2. When we traverse along nums1 and nums2 we also find the minimum value of each array (i.e. min1 and min2), if we could not find any number of frequency 2 we use min1 and min2 to form our final answer. We use the minimum of min1 and min2 to be the 1st digit and the other one to be the 2nd digit of our answer. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n1+n2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int freq[] = new int[10];\\n        int min1=Integer.MAX_VALUE, min2=Integer.MAX_VALUE;\\n        for (int i=0; i<nums1.length; i++){\\n            min1 = Math.min(nums1[i], min1);\\n            freq[nums1[i]]++;\\n        }\\n        for (int i=0; i<nums2.length; i++){\\n            min2 = Math.min(nums2[i], min2);\\n            freq[nums2[i]]++;\\n        }\\n        int i=1;\\n//this while loop find the first/min number that appears in both\\n//arrays. There are 3 cases\\n//case 1) more than one digit that appears in both arrays:\\n//e.g. both 2 and 7 appears in both arrays, i will be 2. \\n//case 2) only one digit appears in both arrays: \\n//if only 3 appears twice, i will be 3.\\n//and case 3)if none of the digit appears twice, i==10.\\n        while (i<10 && freq[i] < 2){\\n            i++;\\n        }\\n//if i<10, case 1 or 2, we return i, else we return the number\\n//formed by min1 and min2.\\n        return i<10? i : Math.min(min1, min2)*10 + Math.max(min1, min2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int freq[] = new int[10];\\n        int min1=Integer.MAX_VALUE, min2=Integer.MAX_VALUE;\\n        for (int i=0; i<nums1.length; i++){\\n            min1 = Math.min(nums1[i], min1);\\n            freq[nums1[i]]++;\\n        }\\n        for (int i=0; i<nums2.length; i++){\\n            min2 = Math.min(nums2[i], min2);\\n            freq[nums2[i]]++;\\n        }\\n        int i=1;\\n//this while loop find the first/min number that appears in both\\n//arrays. There are 3 cases\\n//case 1) more than one digit that appears in both arrays:\\n//e.g. both 2 and 7 appears in both arrays, i will be 2. \\n//case 2) only one digit appears in both arrays: \\n//if only 3 appears twice, i will be 3.\\n//and case 3)if none of the digit appears twice, i==10.\\n        while (i<10 && freq[i] < 2){\\n            i++;\\n        }\\n//if i<10, case 1 or 2, we return i, else we return the number\\n//formed by min1 and min2.\\n        return i<10? i : Math.min(min1, min2)*10 + Math.max(min1, min2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862261,
                "title": "sets-intersect-or-min-max-logic",
                "content": "## Code\\n![image.png](https://assets.leetcode.com/users/images/dcd81341-db36-4c55-960f-a646d2d20ed9_1691144859.8201437.png)\\n\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = set(nums1)\\n        nums2 = set(nums2)\\n        intersect = nums1 & nums2\\n        \\n        if intersect:\\n            return min(intersect)\\n        \\n        min_1, min_2 = min(nums1), min(nums2)\\n        return min(min_1, min_2) * 10 + max(min_1, min_2)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = set(nums1)\\n        nums2 = set(nums2)\\n        intersect = nums1 & nums2\\n        \\n        if intersect:\\n            return min(intersect)\\n        \\n        min_1, min_2 = min(nums1), min(nums2)\\n        return min(min_1, min_2) * 10 + max(min_1, min_2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861195,
                "title": "form-smallest-number-from-two-digit-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        String str = new String();\\n        int min = Integer.MAX_VALUE;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            arr.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(arr.contains(nums2[i]))\\n            min = Math.min(min,nums2[i]);\\n        }\\n        if(nums1[0]>nums2[0])\\n        {\\n            str = String.valueOf(nums2[0])+String.valueOf(nums1[0]);\\n        }\\n        else if(nums1[0]<nums2[0])\\n        {\\n            str = String.valueOf(nums1[0])+String.valueOf(nums2[0]);\\n        }\\n        if(str.isEmpty()==false)\\n        min = Math.min(min,Integer.valueOf(str));\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        String str = new String();\\n        int min = Integer.MAX_VALUE;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            arr.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(arr.contains(nums2[i]))\\n            min = Math.min(min,nums2[i]);\\n        }\\n        if(nums1[0]>nums2[0])\\n        {\\n            str = String.valueOf(nums2[0])+String.valueOf(nums1[0]);\\n        }\\n        else if(nums1[0]<nums2[0])\\n        {\\n            str = String.valueOf(nums1[0])+String.valueOf(nums2[0]);\\n        }\\n        if(str.isEmpty()==false)\\n        min = Math.min(min,Integer.valueOf(str));\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860532,
                "title": "swift-o-n-time-o-1-space-novel-bit-manipulation-answer",
                "content": "This solution sets bits in the variables `seen1` and `seen2` corresponding to the numbers seen in `nums1` and `nums2` respectively. The minimum integer seen can then be found using `trailingZeroBitCount`.\\n\\nIt then uses a logical AND to determine if a number occurs in both arrays, and if so returns a single digit answer.\\n\\nIf there is no single digit answer it forms the minimum integer from the minimum numbers seen in each input array.\\n\\n# Complexity\\n\\n$$ \\\\text{let}\\\\ N = max(nums_1.length, nums_2.length)$$\\n$$ \\\\text{Time:}\\\\ O(n)$$\\n$$ \\\\text{Space:}\\\\ O(1)$$\\n \\n# Code\\n```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        var seen1 = nums1.reduce(0) { $0 | 1 << $1 }\\n        var seen2 = nums2.reduce(0) { $0 | 1 << $1 }\\n        let both = seen1 & seen2\\n        if  both != 0 {\\n            return both.trailingZeroBitCount\\n        }\\n        let min1 = seen1.trailingZeroBitCount\\n        let min2 = seen2.trailingZeroBitCount\\n        return min1 < min2 ? min1 * 10 + min2 : min2 * 10 + min1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        var seen1 = nums1.reduce(0) { $0 | 1 << $1 }\\n        var seen2 = nums2.reduce(0) { $0 | 1 << $1 }\\n        let both = seen1 & seen2\\n        if  both != 0 {\\n            return both.trailingZeroBitCount\\n        }\\n        let min1 = seen1.trailingZeroBitCount\\n        let min2 = seen2.trailingZeroBitCount\\n        return min1 < min2 ? min1 * 10 + min2 : min2 * 10 + min1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856111,
                "title": "java-fastest-solution",
                "content": "# Complexity\\n- Time complexity: *O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n       boolean[] arr1 = new boolean[10];\\n       boolean[] arr2 = new boolean[10];\\n       int res = 0; \\n\\n       for(int i : nums1)\\n         arr1[i] = true;\\n        \\n       for(int j : nums2)\\n         arr2[j] = true;\\n       \\n       for(int i = 0; i < 10; i++)\\n         if(arr1[i] && arr2[i]) return i;\\n       \\n       for(int i = 0; i < 10; i++)\\n           if(arr1[i]){\\n             res = res * 10 + i;\\n             break;\\n           }\\n       for(int i = 0; i < 10; i++)\\n           if(arr2[i]){\\n             res = res * 10 + i;\\n             break;\\n           }\\n      return Math.min(res, res % 10 * 10 + res/10);    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n       boolean[] arr1 = new boolean[10];\\n       boolean[] arr2 = new boolean[10];\\n       int res = 0; \\n\\n       for(int i : nums1)\\n         arr1[i] = true;\\n        \\n       for(int j : nums2)\\n         arr2[j] = true;\\n       \\n       for(int i = 0; i < 10; i++)\\n         if(arr1[i] && arr2[i]) return i;\\n       \\n       for(int i = 0; i < 10; i++)\\n           if(arr1[i]){\\n             res = res * 10 + i;\\n             break;\\n           }\\n       for(int i = 0; i < 10; i++)\\n           if(arr2[i]){\\n             res = res * 10 + i;\\n             break;\\n           }\\n      return Math.min(res, res % 10 * 10 + res/10);    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849335,
                "title": "hashset-and-math-min-max-solution-code-only",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) {\\n        HashSet<int> h1 = new HashSet<int>(nums1);\\n        HashSet<int> h2 = new HashSet<int>(nums2);\\n        int m = 10;\\n        foreach (int k in h1)\\n            if (h2.Contains(k))\\n                m = Math.Min(m,k);\\n        if (m<10) return m;\\n\\n        int n1 = nums1.Min(), n2 = nums2.Min();\\n        return Math.Max(n1,n2) + 10*Math.Min(n1,n2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) {\\n        HashSet<int> h1 = new HashSet<int>(nums1);\\n        HashSet<int> h2 = new HashSet<int>(nums2);\\n        int m = 10;\\n        foreach (int k in h1)\\n            if (h2.Contains(k))\\n                m = Math.Min(m,k);\\n        if (m<10) return m;\\n\\n        int n1 = nums1.Min(), n2 = nums2.Min();\\n        return Math.Max(n1,n2) + 10*Math.Min(n1,n2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838199,
                "title": "dart-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minNumber(List<int> nums1, List<int> nums2) {\\n      nums1.sort();\\n      nums2.sort();\\n      int small = 100;\\n      int output = 0;\\n      if (nums1[0] > nums2[0]){\\n          output = int.parse(nums2[0].toString() + nums1[0].toString());\\n      } else {\\n        output = int.parse(nums1[0].toString() + nums2[0].toString());\\n      }\\n      \\n      for (final nums in nums1){\\n        if (nums2.any((element) => nums == element)){\\n          small = min(small,nums);\\n        }\\n      }\\n\\n      for (final nums in nums2){\\n        if (nums1.any((element) => nums == element)){\\n          small = min(small,nums);\\n        }\\n      }\\n      return min(small,output);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minNumber(List<int> nums1, List<int> nums2) {\\n      nums1.sort();\\n      nums2.sort();\\n      int small = 100;\\n      int output = 0;\\n      if (nums1[0] > nums2[0]){\\n          output = int.parse(nums2[0].toString() + nums1[0].toString());\\n      } else {\\n        output = int.parse(nums1[0].toString() + nums2[0].toString());\\n      }\\n      \\n      for (final nums in nums1){\\n        if (nums2.any((element) => nums == element)){\\n          small = min(small,nums);\\n        }\\n      }\\n\\n      for (final nums in nums2){\\n        if (nums1.any((element) => nums == element)){\\n          small = min(small,nums);\\n        }\\n      }\\n      return min(small,output);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834113,
                "title": "beats-98-29-runtime-using-min-set-and-for-loop-easy-to-understand",
                "content": "# Intuition\\nthe answer lies in just focusing on finding the min element from both the arrays and make sure if there is a repeated elements, u need to choose minimum from them\\n\\n# Approach\\nused min() fn to get \\'mn1\\' and \\'mn2\\' values\\ncreated \\'res[]\\' empty array to store the final answer if elemtns repeated in both arrays\\nconcatinated both the arrays in single unit using \\'extend()\\' fuction\\nthen used conditional statements to form the minimum possibe number (determining which one is minimum mn1 or mn2)\\nthen for case 2 (common elements) created res[] empty array and stored the value and then the minimum value from it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        mn1 = min(nums1)\\n        mn2 = min(nums2)\\n        res =[]\\n        nums1.extend(nums2)\\n        if len(nums1) == len(set(nums1)):\\n            if mn1 <= mn2:\\n                return mn1*10 + mn2\\n            return mn2*10 + mn1   \\n        for i in nums1:\\n            if nums1.count(i) == 2:\\n                res.append(i)\\n        return min(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        mn1 = min(nums1)\\n        mn2 = min(nums2)\\n        res =[]\\n        nums1.extend(nums2)\\n        if len(nums1) == len(set(nums1)):\\n            if mn1 <= mn2:\\n                return mn1*10 + mn2\\n            return mn2*10 + mn1   \\n        for i in nums1:\\n            if nums1.count(i) == 2:\\n                res.append(i)\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830266,
                "title": "easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int a=nums1[0];\\n        Arrays.sort(nums2);\\n        int b=nums2[0];\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            }\\n        }\\n        return (a>b)?b*10+a:a*10+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int a=nums1[0];\\n        Arrays.sort(nums2);\\n        int b=nums2[0];\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            }\\n        }\\n        return (a>b)?b*10+a:a*10+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828944,
                "title": "begginer-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int a=nums1[0];\\n        Arrays.sort(nums2);\\n        int b=nums2[0];\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            }\\n        }\\n        return (a>b)?b*10+a:a*10+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int a=nums1[0];\\n        Arrays.sort(nums2);\\n        int b=nums2[0];\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            }\\n        }\\n        return (a>b)?b*10+a:a*10+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828135,
                "title": "typescript-100",
                "content": "Your runtime beats 100 % of typescript submissions\\nYour memory usage beats 20.83 % of typescript submissions (44.8 MB)\\n\\n# Code\\n```\\nfunction minNumber(nums1: number[], nums2: number[]): number {\\n    const same: Array<number> = [];\\n    for (let i: number = 0; i < nums1.length; i++) {\\n        for (let j: number = 0; j < nums2.length; j++) {\\n            if (nums1[i] === nums2[j]) {\\n                same.push(nums1[i]);\\n            }\\n        }\\n    }\\n    same.sort((a, b) => a - b);\\n    if (same.length > 0) {\\n        return same[0];\\n    }\\n    nums1.sort((a, b) => a - b);\\n    nums2.sort((a, b) => a - b);\\n    return Math.min(nums1[0], nums2[0]) * 10 + Math.max(nums1[0], nums2[0]);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minNumber(nums1: number[], nums2: number[]): number {\\n    const same: Array<number> = [];\\n    for (let i: number = 0; i < nums1.length; i++) {\\n        for (let j: number = 0; j < nums2.length; j++) {\\n            if (nums1[i] === nums2[j]) {\\n                same.push(nums1[i]);\\n            }\\n        }\\n    }\\n    same.sort((a, b) => a - b);\\n    if (same.length > 0) {\\n        return same[0];\\n    }\\n    nums1.sort((a, b) => a - b);\\n    nums2.sort((a, b) => a - b);\\n    return Math.min(nums1[0], nums2[0]) * 10 + Math.max(nums1[0], nums2[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827826,
                "title": "simple-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for(int i=0; i<nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        int min = Math.min(nums1[0], nums2[0]);\\n        int max = Math.max(nums1[0], nums2[0]);\\n        return min * 10 + max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for(int i=0; i<nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        int min = Math.min(nums1[0], nums2[0]);\\n        int max = Math.max(nums1[0], nums2[0]);\\n        return min * 10 + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812421,
                "title": "dart",
                "content": "# Code\\n```\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int minNumber(List<int> nums1, List<int> nums2) {\\n    var count = List.filled(10, 0);\\n    var min1 = 1000000000, min2 = min1;\\n    for (int v in nums1) {\\n      count[v]++;\\n      min1 = min(min1, v);\\n    }\\n    for (int v in nums2) {\\n      count[v]++;\\n      min2 = min(min2, v);\\n    }\\n    for (int i = 1; i <= 9; i++)\\n      if (count[i] == 2) return i;\\n    return min(\\n      min1 * 10 + min2, min2 * 10 + min1\\n    );\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int minNumber(List<int> nums1, List<int> nums2) {\\n    var count = List.filled(10, 0);\\n    var min1 = 1000000000, min2 = min1;\\n    for (int v in nums1) {\\n      count[v]++;\\n      min1 = min(min1, v);\\n    }\\n    for (int v in nums2) {\\n      count[v]++;\\n      min2 = min(min2, v);\\n    }\\n    for (int i = 1; i <= 9; i++)\\n      if (count[i] == 2) return i;\\n    return min(\\n      min1 * 10 + min2, min2 * 10 + min1\\n    );\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805118,
                "title": "swift-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        \\n        for num in nums1.sorted() {\\n            if nums2.contains(num) { return num }\\n        }\\n\\n        guard let min1 = nums1.min(), let min2 = nums2.min() else { return 0 }\\n\\n        return min1 > min2 ? Int(String(min2) + String(min1))! : Int(String(min1) + String(min2))!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        \\n        for num in nums1.sorted() {\\n            if nums2.contains(num) { return num }\\n        }\\n\\n        guard let min1 = nums1.min(), let min2 = nums2.min() else { return 0 }\\n\\n        return min1 > min2 ? Int(String(min2) + String(min1))! : Int(String(min1) + String(min2))!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796895,
                "title": "beat-94ms-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = list(set(nums1))\\n        nums1.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n\\n        first = min(nums1)\\n        second = min(nums2)\\n        if first < second:\\n\\n            return int(str(first)+str(second))\\n\\n        return int(str(second)+str(first))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = list(set(nums1))\\n        nums1.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n\\n        first = min(nums1)\\n        second = min(nums2)\\n        if first < second:\\n\\n            return int(str(first)+str(second))\\n\\n        return int(str(second)+str(first))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791969,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n   \\n   Arrays.sort(nums1);\\n   Arrays.sort(nums2);\\n    for(int i:nums1)\\n    {\\n        for(int j:nums2)\\n        {\\n            if(i==j)\\n            {\\n                return i;\\n            }\\n        }\\n    }\\n   int result=nums1[0]*10+nums2[0];\\n   int result1=nums2[0]*10+nums1[0];\\n\\n   return (result<result1)?result:result1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n   \\n   Arrays.sort(nums1);\\n   Arrays.sort(nums2);\\n    for(int i:nums1)\\n    {\\n        for(int j:nums2)\\n        {\\n            if(i==j)\\n            {\\n                return i;\\n            }\\n        }\\n    }\\n   int result=nums1[0]*10+nums2[0];\\n   int result1=nums2[0]*10+nums1[0];\\n\\n   return (result<result1)?result:result1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791710,
                "title": "long-but-simplest-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int nu(string s){\\n        int sum = 0;\\n        for(int i=0; i<s.size(); i++){\\n            sum=sum*10+s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int minNumber(vector<int>&n1 , vector<int>&n2){\\n        unordered_map<int,int>mp;\\n        for(auto i:n1){\\n            mp[i]++;\\n        }\\n        for(auto i:n2){\\n            mp[i]++;\\n        }\\n        vector<int>h;\\n        for(auto i:mp){\\n            if(i.second==2){\\n                h.push_back(i.first);\\n            }\\n        }\\n        sort(h.begin(),h.end());\\n        if(h.size()!=0){\\n            return h[0];\\n        }\\n        sort(n1.begin(),n1.end());\\n        sort(n2.begin(),n2.end());\\n        string s1 , s2;\\n        s1+=n1[0];\\n        s1+=n2[0];\\n        s2+=n2[0];\\n        s2+=n1[0];\\n        int x = nu(s1);\\n        int y = nu(s2);\\n        return min(x,y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int nu(string s){\\n        int sum = 0;\\n        for(int i=0; i<s.size(); i++){\\n            sum=sum*10+s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int minNumber(vector<int>&n1 , vector<int>&n2){\\n        unordered_map<int,int>mp;\\n        for(auto i:n1){\\n            mp[i]++;\\n        }\\n        for(auto i:n2){\\n            mp[i]++;\\n        }\\n        vector<int>h;\\n        for(auto i:mp){\\n            if(i.second==2){\\n                h.push_back(i.first);\\n            }\\n        }\\n        sort(h.begin(),h.end());\\n        if(h.size()!=0){\\n            return h[0];\\n        }\\n        sort(n1.begin(),n1.end());\\n        sort(n2.begin(),n2.end());\\n        string s1 , s2;\\n        s1+=n1[0];\\n        s1+=n2[0];\\n        s2+=n2[0];\\n        s2+=n1[0];\\n        int x = nu(s1);\\n        int y = nu(s2);\\n        return min(x,y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779688,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n\\n        int x=nums1[0];\\n        int y=nums2[0];\\n\\n        if(x<y)\\n        {\\n            return x*10+y;\\n        }\\n        else\\n        {\\n           return y*10+x;\\n        }\\n        return 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n\\n        int x=nums1[0];\\n        int y=nums2[0];\\n\\n        if(x<y)\\n        {\\n            return x*10+y;\\n        }\\n        else\\n        {\\n           return y*10+x;\\n        }\\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774850,
                "title": "java-easy-to-understand-100-fastest",
                "content": "# Approach\\nsince our sample space is 1-9 digit, we\\'ll mark presence of digit as `True` in each boolean array for each num array\\nNow, if both boolean array has `True` in it, then it\\'s common digit and we\\'ll return that digit\\nOtherwise we\\'ll return min digit from one array * 10 + min digit from another array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean[] first = new boolean[9];\\n        boolean[] second = new boolean[9];\\n        int smallFirst = 10, smallSecond = 10;\\n        for(short i = 0; i <nums1.length; i++){\\n            first[nums1[i]-1] = true;\\n            if(nums1[i]<smallFirst) smallFirst = nums1[i];\\n        }\\n        for(short i = 0; i <nums2.length; i++){\\n            second[nums2[i]-1] = true;\\n            if(nums2[i]<smallSecond) smallSecond = nums2[i];\\n        }\\n        for(short i = 0; i < 9; i++){\\n            if(first[i] == true && second[i] == true) {\\n                return i+1;\\n            }\\n        }\\n        int ans = 0;\\n\\n        if(smallFirst < smallSecond) {\\n            ans = (smallFirst*10) + smallSecond;\\n        } else {\\n            ans = (smallSecond*10) + smallFirst;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean[] first = new boolean[9];\\n        boolean[] second = new boolean[9];\\n        int smallFirst = 10, smallSecond = 10;\\n        for(short i = 0; i <nums1.length; i++){\\n            first[nums1[i]-1] = true;\\n            if(nums1[i]<smallFirst) smallFirst = nums1[i];\\n        }\\n        for(short i = 0; i <nums2.length; i++){\\n            second[nums2[i]-1] = true;\\n            if(nums2[i]<smallSecond) smallSecond = nums2[i];\\n        }\\n        for(short i = 0; i < 9; i++){\\n            if(first[i] == true && second[i] == true) {\\n                return i+1;\\n            }\\n        }\\n        int ans = 0;\\n\\n        if(smallFirst < smallSecond) {\\n            ans = (smallFirst*10) + smallSecond;\\n        } else {\\n            ans = (smallSecond*10) + smallFirst;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768811,
                "title": "kotlin-one-pass-solution-with-booleanarray-and-without-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    fun minNumber(nums1: IntArray, nums2: IntArray): Int {\\n        val digitMap = BooleanArray(9)\\n        var minCommonDigit = 10\\n        var minDigit1 = 9\\n        var minDigit2 = 9\\n        var i = 0\\n\\n        while (i < Math.max(nums1.size, nums2.size)) {\\n            if (i < nums1.size) {\\n                minDigit1 = Math.min(minDigit1, nums1[i])\\n                if (digitMap[nums1[i]-1])\\n                    minCommonDigit = Math.min(minCommonDigit, nums1[i])\\n                else\\n                    digitMap[nums1[i]-1] = true\\n            }\\n\\n            if (i < nums2.size) {\\n                minDigit2 = Math.min(minDigit2, nums2[i])\\n                if (digitMap[nums2[i]-1])\\n                    minCommonDigit = Math.min(minCommonDigit, nums2[i])\\n                else\\n                    digitMap[nums2[i]-1] = true\\n            }\\n\\n            i++\\n        }\\n\\n        if (minCommonDigit < 10)\\n            return minCommonDigit\\n\\n        if (minDigit1 < minDigit2)\\n            return \"$minDigit1$minDigit2\".toInt()\\n\\n        return \"$minDigit2$minDigit1\".toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minNumber(nums1: IntArray, nums2: IntArray): Int {\\n        val digitMap = BooleanArray(9)\\n        var minCommonDigit = 10\\n        var minDigit1 = 9\\n        var minDigit2 = 9\\n        var i = 0\\n\\n        while (i < Math.max(nums1.size, nums2.size)) {\\n            if (i < nums1.size) {\\n                minDigit1 = Math.min(minDigit1, nums1[i])\\n                if (digitMap[nums1[i]-1])\\n                    minCommonDigit = Math.min(minCommonDigit, nums1[i])\\n                else\\n                    digitMap[nums1[i]-1] = true\\n            }\\n\\n            if (i < nums2.size) {\\n                minDigit2 = Math.min(minDigit2, nums2[i])\\n                if (digitMap[nums2[i]-1])\\n                    minCommonDigit = Math.min(minCommonDigit, nums2[i])\\n                else\\n                    digitMap[nums2[i]-1] = true\\n            }\\n\\n            i++\\n        }\\n\\n        if (minCommonDigit < 10)\\n            return minCommonDigit\\n\\n        if (minDigit1 < minDigit2)\\n            return \"$minDigit1$minDigit2\".toInt()\\n\\n        return \"$minDigit2$minDigit1\".toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752513,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    nums1.sort((a,b) => a - b);\\n    nums2.sort((a,b) => a - b);\\n    for(let num of nums1) {\\n        if (nums2.includes(num) ) {\\n            return num;\\n        }\\n    }\\n    if ( nums1[0] > nums2[0]) return Number(String(nums2[0]) + String(nums1[0]));\\n    else return Number(String(nums1[0]) + String(nums2[0]));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    nums1.sort((a,b) => a - b);\\n    nums2.sort((a,b) => a - b);\\n    for(let num of nums1) {\\n        if (nums2.includes(num) ) {\\n            return num;\\n        }\\n    }\\n    if ( nums1[0] > nums2[0]) return Number(String(nums2[0]) + String(nums1[0]));\\n    else return Number(String(nums1[0]) + String(nums2[0]));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748037,
                "title": "java-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\n        Set<Integer> s = new HashSet();\\n        for (int i = 0; i < nums1.length; i++) {\\n            s.add(nums1[i]);\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (s.contains(nums2[i])) {\\n                min = Math.min(min, nums2[i]);\\n            }\\n        }\\n\\n        if (min < Integer.MAX_VALUE) return min;\\n\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        if (nums1[0] < nums2[0]) return nums1[0] * 10 + nums2[0];\\n\\n        return nums2[0] * 10 + nums1[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\n        Set<Integer> s = new HashSet();\\n        for (int i = 0; i < nums1.length; i++) {\\n            s.add(nums1[i]);\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (s.contains(nums2[i])) {\\n                min = Math.min(min, nums2[i]);\\n            }\\n        }\\n\\n        if (min < Integer.MAX_VALUE) return min;\\n\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        if (nums1[0] < nums2[0]) return nums1[0] * 10 + nums2[0];\\n\\n        return nums2[0] * 10 + nums1[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746195,
                "title": "python-simple-bruteforce-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        min_1 = float(\\'inf\\')\\n        min_2 = float(\\'inf\\')\\n        min_3 = float(\\'inf\\')\\n        for i in range(len(nums1)):\\n            min_1 = min(min_1,nums1[i])\\n        for j in range(len(nums2)):\\n            min_2 = min(min_2,nums2[j])\\n        sub_str = \"\"\\n        if min_1 < min_2:\\n            sub_str += str(min_1) + str(min_2)\\n        else:\\n            sub_str += str(min_2) + str(min_1)\\n        for i in range(len(nums1)):\\n            if nums1[i] in nums2:\\n                min_3 = min(min_3,nums1[i]) \\n        return min(min_3,int(sub_str))\\n                \\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        min_1 = float(\\'inf\\')\\n        min_2 = float(\\'inf\\')\\n        min_3 = float(\\'inf\\')\\n        for i in range(len(nums1)):\\n            min_1 = min(min_1,nums1[i])\\n        for j in range(len(nums2)):\\n            min_2 = min(min_2,nums2[j])\\n        sub_str = \"\"\\n        if min_1 < min_2:\\n            sub_str += str(min_1) + str(min_2)\\n        else:\\n            sub_str += str(min_2) + str(min_1)\\n        for i in range(len(nums1)):\\n            if nums1[i] in nums2:\\n                min_3 = min(min_3,nums1[i]) \\n        return min(min_3,int(sub_str))\\n                \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741740,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String p = \"\";\\n        if(a[0]<b[0])\\n            p = a[0]+\"\"+b[0]+\"\";\\n        else\\n            p=b[0]+\"\"+a[0];\\n        boolean flag=false;\\n        int res = Integer.parseInt(p);\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<b.length;j++){\\n                if(a[i]==b[j]){\\n                    res = a[i];\\n                    flag = true;\\n                    break;\\n            }\\n            }\\n            if(flag)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String p = \"\";\\n        if(a[0]<b[0])\\n            p = a[0]+\"\"+b[0]+\"\";\\n        else\\n            p=b[0]+\"\"+a[0];\\n        boolean flag=false;\\n        int res = Integer.parseInt(p);\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<b.length;j++){\\n                if(a[i]==b[j]){\\n                    res = a[i];\\n                    flag = true;\\n                    break;\\n            }\\n            }\\n            if(flag)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741739,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String p = \"\";\\n        if(a[0]<b[0])\\n            p = a[0]+\"\"+b[0]+\"\";\\n        else\\n            p=b[0]+\"\"+a[0];\\n        boolean flag=false;\\n        int res = Integer.parseInt(p);\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<b.length;j++){\\n                if(a[i]==b[j]){\\n                    res = a[i];\\n                    flag = true;\\n                    break;\\n            }\\n            }\\n            if(flag)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String p = \"\";\\n        if(a[0]<b[0])\\n            p = a[0]+\"\"+b[0]+\"\";\\n        else\\n            p=b[0]+\"\"+a[0];\\n        boolean flag=false;\\n        int res = Integer.parseInt(p);\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<b.length;j++){\\n                if(a[i]==b[j]){\\n                    res = a[i];\\n                    flag = true;\\n                    break;\\n            }\\n            }\\n            if(flag)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734991,
                "title": "python-simple-sol-using-min",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minNumber(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        fn=min(int(str(min(nums1))+str(min(nums2))),int(str(min(nums2))+str(min(nums1))))\\n        for i in nums1:\\n            if i in nums2:\\n                fn=min(fn,i)\\n        return fn\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minNumber(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        fn=min(int(str(min(nums1))+str(min(nums2))),int(str(min(nums2))+str(min(nums1))))\\n        for i in nums1:\\n            if i in nums2:\\n                fn=min(fn,i)\\n        return fn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734281,
                "title": "c-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n      int b1 = 0, m1 = 9, b2 = 0, m2 = 9;\\n      tie(b1, m1) = helper(nums1);\\n      tie(b2, m2) = helper(nums2);\\n      if (b1&b2) {\\n        int i = 0;\\n        while ((b1&b2&(1<<i)) == 0)\\n          i++;\\n        return i;\\n      }\\n      return min(m1,m2)*10 + max(m1,m2);\\n    }\\n  private:\\n    pair<int, int> helper(vector<int>& nums) {\\n      int b = 0, m = INT_MAX;\\n      for (auto n : nums) {\\n        b |= 1<<n;\\n        m = min(m, n);\\n      }\\n      return {b, m};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n      int b1 = 0, m1 = 9, b2 = 0, m2 = 9;\\n      tie(b1, m1) = helper(nums1);\\n      tie(b2, m2) = helper(nums2);\\n      if (b1&b2) {\\n        int i = 0;\\n        while ((b1&b2&(1<<i)) == 0)\\n          i++;\\n        return i;\\n      }\\n      return min(m1,m2)*10 + max(m1,m2);\\n    }\\n  private:\\n    pair<int, int> helper(vector<int>& nums) {\\n      int b = 0, m = INT_MAX;\\n      for (auto n : nums) {\\n        b |= 1<<n;\\n        m = min(m, n);\\n      }\\n      return {b, m};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732585,
                "title": "count-using-array-c",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int mn = 10, mn1 = 10, mn2 = 10, n1 = 0, n2 = 0, cnt[10] = {};\\n\\n        for(int i = 0; i < nums1.size(); i++) {\\n            mn1 = min(mn1, nums1[i]);\\n            cnt[nums1[i]] = 1;\\n        }\\n\\n        for(int i = 0; i < nums2.size(); i++) {\\n            mn2 = min(mn2, nums2[i]);\\n            if(cnt[nums2[i]]) \\n                mn = min(mn, nums2[i]);\\n        }\\n\\n        return mn < 10 ? mn : min(mn1, mn2) * 10 + max(mn1, mn2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int mn = 10, mn1 = 10, mn2 = 10, n1 = 0, n2 = 0, cnt[10] = {};\\n\\n        for(int i = 0; i < nums1.size(); i++) {\\n            mn1 = min(mn1, nums1[i]);\\n            cnt[nums1[i]] = 1;\\n        }\\n\\n        for(int i = 0; i < nums2.size(); i++) {\\n            mn2 = min(mn2, nums2[i]);\\n            if(cnt[nums2[i]]) \\n                mn = min(mn, nums2[i]);\\n        }\\n\\n        return mn < 10 ? mn : min(mn1, mn2) * 10 + max(mn1, mn2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732062,
                "title": "java-easy-solution-o-1-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean arr1[]=new boolean[10];\\n        boolean arr2[]=new boolean[10];\\n        for(int num : nums1) arr1[num]=true;\\n        for(int num : nums2) arr2[num]=true;\\n        \\n        for(int i=1; i<10; i++)\\n            if(arr1[i] && arr2[i])\\n                return i;\\n\\n        int a=1, b=1;\\n        while(!arr1[a]) a++;\\n        while(!arr2[b]) b++;\\n\\n        return Math.min(a,b) * 10 + Math.max(a,b); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean arr1[]=new boolean[10];\\n        boolean arr2[]=new boolean[10];\\n        for(int num : nums1) arr1[num]=true;\\n        for(int num : nums2) arr2[num]=true;\\n        \\n        for(int i=1; i<10; i++)\\n            if(arr1[i] && arr2[i])\\n                return i;\\n\\n        int a=1, b=1;\\n        while(!arr1[a]) a++;\\n        while(!arr2[b]) b++;\\n\\n        return Math.min(a,b) * 10 + Math.max(a,b); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728337,
                "title": "c-set-intersection-solution",
                "content": "# Code\\n```c++\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        set_intersection(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), back_inserter(v));\\n        sort(v.begin(), v.end());\\n        if (v.size() > 0) {\\n            return v[0];\\n        }\\n        int v12 = nums1[0] * 10 + nums2[0];\\n        int v21 = nums1[0] + nums2[0] * 10;\\n        return min(v12, v21);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        set_intersection(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), back_inserter(v));\\n        sort(v.begin(), v.end());\\n        if (v.size() > 0) {\\n            return v[0];\\n        }\\n        int v12 = nums1[0] * 10 + nums2[0];\\n        int v21 = nums1[0] + nums2[0] * 10;\\n        return min(v12, v21);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723063,
                "title": "short-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        inters = set(nums1).intersection(nums2)\\n        \\n        fstnum = min(nums1)\\n        secnum = min(nums2)\\n        return min(inters) if inters \\\\\\n            else int(f\\'{min(fstnum, secnum)}{max(fstnum, secnum)}\\')\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        inters = set(nums1).intersection(nums2)\\n        \\n        fstnum = min(nums1)\\n        secnum = min(nums2)\\n        return min(inters) if inters \\\\\\n            else int(f\\'{min(fstnum, secnum)}{max(fstnum, secnum)}\\')\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716927,
                "title": "sexiest-and-easiest-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n     unordered_map<int,int>m;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++){\\n        \\n             m[nums1[i]]++;\\n        }\\n        vector<int>v;\\n        for(int i=0;i<nums2.size();i++){\\n            if(m.find(nums2[i])!=m.end()){\\n                v.push_back(nums2[i]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if(v.size()==0){\\n            return 10*min(nums1[0],nums2[0]) +max(nums1[0],nums2[0]);\\n        }\\n        else return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n     unordered_map<int,int>m;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++){\\n        \\n             m[nums1[i]]++;\\n        }\\n        vector<int>v;\\n        for(int i=0;i<nums2.size();i++){\\n            if(m.find(nums2[i])!=m.end()){\\n                v.push_back(nums2[i]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if(v.size()==0){\\n            return 10*min(nums1[0],nums2[0]) +max(nums1[0],nums2[0]);\\n        }\\n        else return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692481,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int[] arr = new int[10];\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n        int duplicate = Integer.MAX_VALUE;\\n        int max = Math.max(nums1.length, nums2.length);\\n        for (int i = 0; i < max; i++) {\\n            if (i < nums1.length) {\\n                min1 = Math.min(min1, nums1[i]);\\n                arr[nums1[i]]++;\\n            }\\n            if (i < nums2.length) {\\n                min2 = Math.min(min2, nums2[i]);\\n                arr[nums2[i]]++;\\n            }\\n            if (i == max - 1) {\\n                int j = 1;\\n                while (j < arr.length) {\\n                    if (arr[j] == 2) {\\n                        return j;\\n                    } else {\\n                        j++;\\n                    }\\n                }\\n            }\\n        }\\n        int output = 0;\\n        int firstD = Math.min(min1, min2);\\n        int secondD = Math.max(min2, min1);\\n        String s = String.valueOf(firstD) + secondD;\\n        output = Integer.parseInt(s);\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int[] arr = new int[10];\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n        int duplicate = Integer.MAX_VALUE;\\n        int max = Math.max(nums1.length, nums2.length);\\n        for (int i = 0; i < max; i++) {\\n            if (i < nums1.length) {\\n                min1 = Math.min(min1, nums1[i]);\\n                arr[nums1[i]]++;\\n            }\\n            if (i < nums2.length) {\\n                min2 = Math.min(min2, nums2[i]);\\n                arr[nums2[i]]++;\\n            }\\n            if (i == max - 1) {\\n                int j = 1;\\n                while (j < arr.length) {\\n                    if (arr[j] == 2) {\\n                        return j;\\n                    } else {\\n                        j++;\\n                    }\\n                }\\n            }\\n        }\\n        int output = 0;\\n        int firstD = Math.min(min1, min2);\\n        int secondD = Math.max(min2, min1);\\n        String s = String.valueOf(firstD) + secondD;\\n        output = Integer.parseInt(s);\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690991,
                "title": "python3-easy-to-understand",
                "content": "# Intuition\\nUsing an optimized brute force where we first sort both the lists, then take the first two elements from each lists and concatenate.\\nCheck if this is greater than the smallest number common between the two.\\n\\n# Complexity\\n- Time complexity:\\nnlogn + mlogm\\n\\n- Space complexity:\\nn+m for each set\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = sorted(nums1)\\n        nums2 = sorted(nums2)\\n        c = set(nums1).intersection(nums2)\\n        min_set = 99999\\n        if len(c) > 0:\\n            min_set = min(c)\\n        a = min(int(str(nums1[0])+str(nums2[0])),int(str(nums2[0])+str(nums1[0])))\\n        if min_set > a:\\n            return a\\n        return min_set\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = sorted(nums1)\\n        nums2 = sorted(nums2)\\n        c = set(nums1).intersection(nums2)\\n        min_set = 99999\\n        if len(c) > 0:\\n            min_set = min(c)\\n        a = min(int(str(nums1[0])+str(nums2[0])),int(str(nums2[0])+str(nums1[0])))\\n        if min_set > a:\\n            return a\\n        return min_set\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687791,
                "title": "easy-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;\\n        String k=\"\";\\n    for(int i=0;i<nums1.length;i++){\\n        if(nums1[i]<min1)min1=nums1[i];\\n        for(int j=0;j<nums2.length;j++){\\n           if(nums2[j]<min2)min2=nums2[j];\\n           if(nums1[i]==nums2[j])k+=nums1[i];\\n        }\\n    }\\n    if(k.equals(\"\")){\\n        String o=\"\";\\n        if(min1>min2)o+=min2+\"\"+min1;\\n        else o+=min1+\"\"+min2;\\n        return Integer.parseInt(o);\\n    }\\n    String r[]=k.split(\"\");\\n    Arrays.sort(r);\\n    return Integer.parseInt(r[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;\\n        String k=\"\";\\n    for(int i=0;i<nums1.length;i++){\\n        if(nums1[i]<min1)min1=nums1[i];\\n        for(int j=0;j<nums2.length;j++){\\n           if(nums2[j]<min2)min2=nums2[j];\\n           if(nums1[i]==nums2[j])k+=nums1[i];\\n        }\\n    }\\n    if(k.equals(\"\")){\\n        String o=\"\";\\n        if(min1>min2)o+=min2+\"\"+min1;\\n        else o+=min1+\"\"+min2;\\n        return Integer.parseInt(o);\\n    }\\n    String r[]=k.split(\"\");\\n    Arrays.sort(r);\\n    return Integer.parseInt(r[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684724,
                "title": "easy-and-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        x=set(nums1).intersection(set(nums2))\\n\\n        if len(x)>0:\\n            return sorted(list(x))[0]\\n        else:\\n            digit1=min(set(nums1))\\n            digit2=min(set(nums2))\\n\\n            if digit1 > digit2:\\n                return digit2*10 +digit1\\n            else:\\n                return digit1*10 +digit2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        x=set(nums1).intersection(set(nums2))\\n\\n        if len(x)>0:\\n            return sorted(list(x))[0]\\n        else:\\n            digit1=min(set(nums1))\\n            digit2=min(set(nums2))\\n\\n            if digit1 > digit2:\\n                return digit2*10 +digit1\\n            else:\\n                return digit1*10 +digit2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664810,
                "title": "easy-and-clean-solution",
                "content": "\\n\\n# Code\\n```\\nconst minNumber = (nums1, nums2) => {\\n    nums1.sort((a,b) => a - b);\\n    nums2.sort((a,b) => a - b);\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        if ( nums2.includes(nums1[i]) ) {\\n            return nums1[i];\\n        }\\n    }\\n\\n    if ( nums1[0] > nums2[0] ) {\\n        return Number(String(nums2[0]) + String(nums1[0]));\\n    } else {\\n        return Number(String(nums1[0]) + String(nums2[0]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minNumber = (nums1, nums2) => {\\n    nums1.sort((a,b) => a - b);\\n    nums2.sort((a,b) => a - b);\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        if ( nums2.includes(nums1[i]) ) {\\n            return nums1[i];\\n        }\\n    }\\n\\n    if ( nums1[0] > nums2[0] ) {\\n        return Number(String(nums2[0]) + String(nums1[0]));\\n    } else {\\n        return Number(String(nums1[0]) + String(nums2[0]));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1850323,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1959168,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1901140,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1871611,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1850684,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1850310,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Substring With Maximum Cost",
        "question_content": "<p>You are given a string <code>s</code>, a string <code>chars</code> of <strong>distinct</strong> characters and an integer array <code>vals</code> of the same length as <code>chars</code>.</p>\n\n<p>The <strong>cost of the substring </strong>is the sum of the values of each character in the substring. The cost of an empty string is considered <code>0</code>.</p>\n\n<p>The <strong>value of the character </strong>is defined in the following way:</p>\n\n<ul>\n\t<li>If the character is not in the string <code>chars</code>, then its value is its corresponding position <strong>(1-indexed)</strong> in the alphabet.\n\n\t<ul>\n\t\t<li>For example, the value of <code>&#39;a&#39;</code> is <code>1</code>, the value of <code>&#39;b&#39;</code> is <code>2</code>, and so on. The value of <code>&#39;z&#39;</code> is <code>26</code>.</li>\n\t</ul>\n\t</li>\n\t<li>Otherwise, assuming <code>i</code> is the index where the character occurs in the string <code>chars</code>, then its value is <code>vals[i]</code>.</li>\n</ul>\n\n<p>Return <em>the maximum cost among all substrings of the string</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;adaa&quot;, chars = &quot;d&quot;, vals = [-1000]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The value of the characters &quot;a&quot; and &quot;d&quot; is 1 and -1000 respectively.\nThe substring with the maximum cost is &quot;aa&quot; and its cost is 1 + 1 = 2.\nIt can be proven that 2 is the maximum cost.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;, chars = &quot;abc&quot;, vals = [-1,-1,-1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The value of the characters &quot;a&quot;, &quot;b&quot; and &quot;c&quot; is -1, -1, and -1 respectively.\nThe substring with the maximum cost is the empty substring &quot;&quot; and its cost is 0.\nIt can be proven that 0 is the maximum cost.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= chars.length &lt;= 26</code></li>\n\t<li><code>chars</code> consist of <strong>distinct</strong> lowercase English letters.</li>\n\t<li><code>vals.length == chars.length</code></li>\n\t<li><code>-1000 &lt;= vals[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3366677,
                "title": "c-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are making a vector `v` in which values of all the alphabets are assigned as default (which is equal to their index number).\\nSecondly, if an aphabet is present in `chars`string the replace the it value as present in `vals` array. Now, read the approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- You need to make a new vector `vt` which is corresponding to the string `s`. It contains the respective value of corresponding alphabets in string `s`.\\n- Now, run a for loop and take two variables `ans` and `temp`.\\n- After every iteration assign ans with `max(ans, temp)` and continuously add the element in temp.\\n- If temp becomes negative then reset it to zero as we wants the maximum possible sum.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        // vector v containing values of all the alphabets.\\n        vector<int> v(26);\\n        for(int i=0; i<26; i++) v[i]=i+1;\\n        for(int i=0; i<chars.size(); i++){\\n            v[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int n = s.size();\\n        // vector corresponding to string s\\n        vector<int> vt(n);\\n        for(int i=0; i<s.size(); i++){\\n            vt[i] = v[s[i]-\\'a\\'];\\n        }\\n        int ans=0, temp=0;\\n        for(int i=0; i<n; i++){\\n            temp += vt[i];\\n            if(temp<0) temp=0;\\n            // assign maximum value to ans\\n            ans = max(ans, temp);\\n        }\\n        return ans;\\n    }\\n};\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION.\\uD83D\\uDE42\\n```\\n![0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg](https://assets.leetcode.com/users/images/a14799d2-ba35-459f-89f0-5014b5daaf73_1680366112.5667481.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        // vector v containing values of all the alphabets.\\n        vector<int> v(26);\\n        for(int i=0; i<26; i++) v[i]=i+1;\\n        for(int i=0; i<chars.size(); i++){\\n            v[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int n = s.size();\\n        // vector corresponding to string s\\n        vector<int> vt(n);\\n        for(int i=0; i<s.size(); i++){\\n            vt[i] = v[s[i]-\\'a\\'];\\n        }\\n        int ans=0, temp=0;\\n        for(int i=0; i<n; i++){\\n            temp += vt[i];\\n            if(temp<0) temp=0;\\n            // assign maximum value to ans\\n            ans = max(ans, temp);\\n        }\\n        return ans;\\n    }\\n};\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION.\\uD83D\\uDE42\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366393,
                "title": "kadane",
                "content": "We use array `v` to store the resulting value of each character:\\n- We initialize it with `1, 2, 3, 4, ...`. This is what `iota` is doing.\\n- Then we override certain values from `vals`.\\n\\nNow, we can represent `s` as a numeric array, and we use Kadane to find the maximum sum subarray.\\n\\n**C++**\\n```cpp\\nint maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n    int v[26] = {}, max_cost = 0, cost = 0;\\n    iota(begin(v), end(v), 1);\\n    for (int i  = 0; i < chars.size(); ++i)\\n        v[chars[i] - \\'a\\'] = vals[i];\\n    for (char ch : s) {\\n        cost = max(0, cost + v[ch - \\'a\\']);\\n        max_cost = max(max_cost, cost);\\n    }\\n    return max_cost;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n    int v[26] = {}, max_cost = 0, cost = 0;\\n    iota(begin(v), end(v), 1);\\n    for (int i  = 0; i < chars.size(); ++i)\\n        v[chars[i] - \\'a\\'] = vals[i];\\n    for (char ch : s) {\\n        cost = max(0, cost + v[ch - \\'a\\']);\\n        max_cost = max(max_cost, cost);\\n    }\\n    return max_cost;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366705,
                "title": "java-c-python-kadane",
                "content": "# **Explanation**\\nTransform `<chars, vals>` into a hashmap `m`, so we can get each characters value in `O(1)`.\\nIf `m[c]` exist, the value is `m[c]`, otherwise is `c - \\'a\\' + 1`.\\n\\nThen we can iterate the string `s` as an array,\\nand apply Kadane\\u2019s algorithm to solve the maximum subarray.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        for (int i = 0; i < chars.length(); i++) {\\n            m.put(chars.charAt(i), vals[i]);\\n        }\\n        int res = 0, cur = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            cur = Math.max(cur + m.getOrDefault(s.charAt(i), s.charAt(i) - \\'a\\' + 1), 0);\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> m;\\n        for (int i = 0; i < chars.length(); i++)\\n            m[chars[i]] = vals[i];\\n        int res = 0, cur = 0;\\n        for (char& c : s) {\\n            cur = max(cur + (m.count(c) ? m[c] : c - \\'a\\' + 1), 0);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        m = dict(zip(chars, vals))\\n        res = cur = 0\\n        for c in s:\\n            cur = max(cur + m.get(c, ord(c) - ord(\\'a\\') + 1), 0)\\n            res = max(res, cur)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        for (int i = 0; i < chars.length(); i++) {\\n            m.put(chars.charAt(i), vals[i]);\\n        }\\n        int res = 0, cur = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            cur = Math.max(cur + m.getOrDefault(s.charAt(i), s.charAt(i) - \\'a\\' + 1), 0);\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> m;\\n        for (int i = 0; i < chars.length(); i++)\\n            m[chars[i]] = vals[i];\\n        int res = 0, cur = 0;\\n        for (char& c : s) {\\n            cur = max(cur + (m.count(c) ? m[c] : c - \\'a\\' + 1), 0);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        m = dict(zip(chars, vals))\\n        res = cur = 0\\n        for c in s:\\n            cur = max(cur + m.get(c, ord(c) - ord(\\'a\\') + 1), 0)\\n            res = max(res, cur)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366429,
                "title": "100-faster-beginner-friendly-c-kadanes-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>ch(26);                                  //make a map\\n        for(int i=0;i<26;i++){\\n            ch[i]=i+1;                                           // set default values i.e, \\'a\\':1, \\'b\\':2.....\\n        }\\n        int cnt=0;\\n        for(char &i:chars){                            \\n            ch[i-\\'a\\']=vals[cnt++];                        // update the default values to the given values in vals array\\n        } \\n        int maxxi=0;\\n        int cur=0;\\n        for(char &i:s){\\n            cur+=ch[i-\\'a\\'];                                 // add the value of the current character in the cur sum\\n            if(cur<0){                                        // if current sum <0 then make current sum =0\\n                cur=0;\\n            }\\n            maxxi=max(maxxi,cur);                 // update the maximum sum\\n        }\\n        return maxxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>ch(26);                                  //make a map\\n        for(int i=0;i<26;i++){\\n            ch[i]=i+1;                                           // set default values i.e, \\'a\\':1, \\'b\\':2.....\\n        }\\n        int cnt=0;\\n        for(char &i:chars){                            \\n            ch[i-\\'a\\']=vals[cnt++];                        // update the default values to the given values in vals array\\n        } \\n        int maxxi=0;\\n        int cur=0;\\n        for(char &i:s){\\n            cur+=ch[i-\\'a\\'];                                 // add the value of the current character in the cur sum\\n            if(cur<0){                                        // if current sum <0 then make current sum =0\\n                cur=0;\\n            }\\n            maxxi=max(maxxi,cur);                 // update the maximum sum\\n        }\\n        return maxxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366449,
                "title": "observation-kadanes-algo-c",
                "content": "we just need to make array of values of string S but checking whether s[i] is present in string char or not \\nif present then take the value from vals array of same index.\\n```\\nclass Solution {\\npublic:\\n    int maxSubArraySum(vector<int> &a){\\n        int mx1 = INT_MIN, mx = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            mx = mx + a[i];\\n            if (mx1 < mx)\\n                mx1 = mx;\\n\\n            if (mx < 0)\\n                mx = 0;\\n        }\\n        return mx1;\\n    }\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> map;\\n        \\n        for(int i=0;i<chars.size();i++){\\n            map[chars[i]] = i;\\n        }\\n        \\n        vector<int> arr(s.size());\\n        \\n        for(int i=0;i<arr.size();i++){\\n            if(map.count(s[i])){\\n                arr[i] = vals[map[s[i]]];\\n            }\\n            else{\\n                arr[i] = s[i] - \\'a\\'+1;\\n            }\\n        }\\n        \\n        int ans  = maxSubArraySum(arr);\\n        if(ans<0){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArraySum(vector<int> &a){\\n        int mx1 = INT_MIN, mx = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            mx = mx + a[i];\\n            if (mx1 < mx)\\n                mx1 = mx;\\n\\n            if (mx < 0)\\n                mx = 0;\\n        }\\n        return mx1;\\n    }\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> map;\\n        \\n        for(int i=0;i<chars.size();i++){\\n            map[chars[i]] = i;\\n        }\\n        \\n        vector<int> arr(s.size());\\n        \\n        for(int i=0;i<arr.size();i++){\\n            if(map.count(s[i])){\\n                arr[i] = vals[map[s[i]]];\\n            }\\n            else{\\n                arr[i] = s[i] - \\'a\\'+1;\\n            }\\n        }\\n        \\n        int ans  = maxSubArraySum(arr);\\n        if(ans<0){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366767,
                "title": "simple-solution-with-one-extra-tip-to-remember-for-life-which-i-bet-no-won-will-provide",
                "content": "# Intuition\\nTRIPPY\\'S BAKCHOD APPROACH\\nYou may easily convert into c++ and java\\n\\n# Approach\\nSS Smile and solve\\n\\n# Complexity\\nNothing\\n\\n# Extra Tip(Gyan)\\n![Bakchodi 1.jpg](https://assets.leetcode.com/users/images/59b427d8-747b-4b7d-924b-4d023f60f502_1680367075.684763.jpeg)\\n\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        char_dict = {}\\n        for i in range(len(chars)):\\n            char_dict[chars[i]] = vals[i]\\n        \\n        max_cost = 0\\n        curr_cost = 0\\n        for i in range(len(s)):\\n            if s[i] not in char_dict:\\n                curr_cost += ord(s[i]) - 96\\n            else:\\n                curr_cost += char_dict[s[i]]\\n            \\n            if curr_cost < 0:\\n                curr_cost = 0\\n            if curr_cost > max_cost:\\n                max_cost = curr_cost\\n        \\n        return max_cost\\n\\n        \\n```\\n# Humble Request\\n![Bakchodi 2.jpeg](https://assets.leetcode.com/users/images/9bfa152d-8c96-4cf8-a79d-3a083eb58c2e_1680367126.279916.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        char_dict = {}\\n        for i in range(len(chars)):\\n            char_dict[chars[i]] = vals[i]\\n        \\n        max_cost = 0\\n        curr_cost = 0\\n        for i in range(len(s)):\\n            if s[i] not in char_dict:\\n                curr_cost += ord(s[i]) - 96\\n            else:\\n                curr_cost += char_dict[s[i]]\\n            \\n            if curr_cost < 0:\\n                curr_cost = 0\\n            if curr_cost > max_cost:\\n                max_cost = curr_cost\\n        \\n        return max_cost\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366939,
                "title": "maintain-minimum-prefix-sum-dynamically",
                "content": "# Intuition\\nFor each index i, try to find the maximum cost of the substrings ending at index i which equals to the cost of the substring from 0 to i minus the cost of the substring from 0 to j where j <= i.  And this is just the difference of 2 \"prefix-sums\".\\n\\n# Approach\\nCalculate each prefix sum and save the minimum.\\n\\n# Complexity\\n- Time complexity:\\nO(m) where m is the alphabet size (here m = 26).\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for (int i = 0; i < 26; ++i) {\\n            v[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.length(); ++i) {\\n            v[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        int r = 0;\\n        for (int i = 0, m = 0, t = 0; i < s.length(); ++i) {\\n            t += v[s[i] - \\'a\\'];\\n            m = min(m, t);\\n            r = max(r, t - m);\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for (int i = 0; i < 26; ++i) {\\n            v[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.length(); ++i) {\\n            v[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        int r = 0;\\n        for (int i = 0, m = 0, t = 0; i < s.length(); ++i) {\\n            t += v[s[i] - \\'a\\'];\\n            m = min(m, t);\\n            r = max(r, t - m);\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366864,
                "title": "i-will-open-it-at-my-own-risk-some-ghost-may-appear-in-solution",
                "content": "# Intuition\\nTRIPPY\\'S BAKCHOD APPROACH\\nYou may easily convert into c++ and java\\n\\n# Approach\\nSS Smile and solve\\n\\n# Complexity\\nNothing\\n\\n# WARNING BEFORE MOVING TO SOL\\n![BAKCHODI 3.jpeg](https://assets.leetcode.com/users/images/14e754a5-83b4-4ff1-9b6f-0a5539482388_1680368578.8860812.jpeg)\\n\\n\\n![BAKCHODI 3.jpeg](https://assets.leetcode.com/users/images/14e754a5-83b4-4ff1-9b6f-0a5539482388_1680368578.8860812.jpeg)\\n\\n\\n\\n![BAKCHODI 3.jpeg](https://assets.leetcode.com/users/images/14e754a5-83b4-4ff1-9b6f-0a5539482388_1680368578.8860812.jpeg)\\n\\n\\n\\n# GHOST FREE Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        char_dict = {}\\n        for i in range(len(chars)):\\n            char_dict[chars[i]] = vals[i]\\n        \\n        max_cost = 0\\n        curr_cost = 0\\n        for i in range(len(s)):\\n            if s[i] not in char_dict:\\n                curr_cost += ord(s[i]) - 96\\n            else:\\n                curr_cost += char_dict[s[i]]\\n            \\n            if curr_cost < 0:\\n                curr_cost = 0\\n            if curr_cost > max_cost:\\n                max_cost = curr_cost\\n        \\n        return max_cost\\n\\n        \\n```\\n# Humble Request\\n![Bakchodi 2.jpeg](https://assets.leetcode.com/users/images/9bfa152d-8c96-4cf8-a79d-3a083eb58c2e_1680367126.279916.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        char_dict = {}\\n        for i in range(len(chars)):\\n            char_dict[chars[i]] = vals[i]\\n        \\n        max_cost = 0\\n        curr_cost = 0\\n        for i in range(len(s)):\\n            if s[i] not in char_dict:\\n                curr_cost += ord(s[i]) - 96\\n            else:\\n                curr_cost += char_dict[s[i]]\\n            \\n            if curr_cost < 0:\\n                curr_cost = 0\\n            if curr_cost > max_cost:\\n                max_cost = curr_cost\\n        \\n        return max_cost\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366749,
                "title": "c-fully-explained-kadane-s-algorithm-just-simulate-the-process-as-given-in-statement",
                "content": "# Intuition\\nFirstly take a map to store the characters and indexes of string **chars**.\\nNow, traverse string **s** and check if the current character is found in map(ie. if it is present in chars, as map has elements of chars as key), if the character is present in map then store its value(ie. value of the map is index of the element of chars) as index of vals and then add vals[index] to sum.\\nIf the character is not present then simply add the difference between the current character and \\'a\\' + 1 to sum, for eg. if s[i]=x, then sum += \\'z\\'-\\'a\\'+1 => sum += 25+1 => sum += 26.\\nKeep on updating the sum and maxi untill sum becomes negative.\\nWhen sum becomes negative make it 0 and then keep on repeating the process.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int sum = 0, maxi = INT_MIN;\\n        \\n        unordered_map<char,int> m;\\n        for(int i=0;i<chars.size();i++) m[chars[i]]=i;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(m.find(s[i])==m.end()) sum += (s[i]-\\'a\\'+1);\\n            else\\n            {\\n                int index = m[s[i]];\\n                sum += vals[index];\\n            }\\n            \\n            maxi = max(maxi,sum);\\n            if(sum<0) sum=0;\\n        }\\n        if(maxi<0) return 0;\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int sum = 0, maxi = INT_MIN;\\n        \\n        unordered_map<char,int> m;\\n        for(int i=0;i<chars.size();i++) m[chars[i]]=i;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(m.find(s[i])==m.end()) sum += (s[i]-\\'a\\'+1);\\n            else\\n            {\\n                int index = m[s[i]];\\n                sum += vals[index];\\n            }\\n            \\n            maxi = max(maxi,sum);\\n            if(sum<0) sum=0;\\n        }\\n        if(maxi<0) return 0;\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366391,
                "title": "java-python-3-kadane-algorithm",
                "content": "\\n\\n```java\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> charToVal = new HashMap<>();\\n        for (int i = 0; i < vals.length; ++i) {\\n            charToVal.put(chars.charAt(i), vals[i]);\\n        }\\n        int maxCost = 0;\\n        for (int i = 0, maxCostSubstringEndingAtCur = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            int v = charToVal.getOrDefault(c, c - \\'a\\' + 1);\\n            maxCostSubstringEndingAtCur = Math.max(maxCostSubstringEndingAtCur + v, v);\\n            maxCost = Math.max(maxCost, maxCostSubstringEndingAtCur);\\n        }\\n        return maxCost;\\n    }\\n```\\n```python\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        seen, max_cost = {c : v for c, v in zip(chars, vals)}, 0\\n        max_cost_substring_ending_at_cur = 0\\n        for c in s:\\n            v = seen.get(c, ord(c) - ord(\\'a\\') + 1)\\n            max_cost_substring_ending_at_cur = max(max_cost_substring_ending_at_cur + v, v)\\n            max_cost = max(max_cost, max_cost_substring_ending_at_cur)\\n        return max_cost    \\n```\\n\\n**Analysis:**\\n\\nTime: `O(m + n)`, space: `O(m)`, where `m = vals.length, n = s.length()`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> charToVal = new HashMap<>();\\n        for (int i = 0; i < vals.length; ++i) {\\n            charToVal.put(chars.charAt(i), vals[i]);\\n        }\\n        int maxCost = 0;\\n        for (int i = 0, maxCostSubstringEndingAtCur = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            int v = charToVal.getOrDefault(c, c - \\'a\\' + 1);\\n            maxCostSubstringEndingAtCur = Math.max(maxCostSubstringEndingAtCur + v, v);\\n            maxCost = Math.max(maxCost, maxCostSubstringEndingAtCur);\\n        }\\n        return maxCost;\\n    }\\n```\n```python\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        seen, max_cost = {c : v for c, v in zip(chars, vals)}, 0\\n        max_cost_substring_ending_at_cur = 0\\n        for c in s:\\n            v = seen.get(c, ord(c) - ord(\\'a\\') + 1)\\n            max_cost_substring_ending_at_cur = max(max_cost_substring_ending_at_cur + v, v)\\n            max_cost = max(max_cost, max_cost_substring_ending_at_cur)\\n        return max_cost    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366445,
                "title": "easy-short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int arr[] = new int[100001];\\n        for(int i=0; i<s.length(); i++){\\n            if(chars.contains(s.charAt(i)+\"\"))  arr[i] = vals[chars.indexOf(s.charAt(i))];\\n            else arr[i] = s.charAt(i)-\\'a\\'+1;\\n        }\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            sum += arr[i];\\n            max = Math.max(max, sum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return max < 0 ? 0 : max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int arr[] = new int[100001];\\n        for(int i=0; i<s.length(); i++){\\n            if(chars.contains(s.charAt(i)+\"\"))  arr[i] = vals[chars.indexOf(s.charAt(i))];\\n            else arr[i] = s.charAt(i)-\\'a\\'+1;\\n        }\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            sum += arr[i];\\n            max = Math.max(max, sum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return max < 0 ? 0 : max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366434,
                "title": "kadane-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n       vector<int>sc(26,2000);\\n        \\n        for(int i=0;i<chars.size();i++)\\n            sc[chars[i]-\\'a\\']=vals[i];\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(sc[i]==2000)\\n                sc[i]=i+1;\\n        }\\n        \\n        int ans=0;\\n        int sum=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            sum+=sc[s[i]-\\'a\\'];\\n            ans=max(ans,sum);\\n            \\n            if(sum<0)\\n                sum=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n       vector<int>sc(26,2000);\\n        \\n        for(int i=0;i<chars.size();i++)\\n            sc[chars[i]-\\'a\\']=vals[i];\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(sc[i]==2000)\\n                sc[i]=i+1;\\n        }\\n        \\n        int ans=0;\\n        int sum=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            sum+=sc[s[i]-\\'a\\'];\\n            ans=max(ans,sum);\\n            \\n            if(sum<0)\\n                sum=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375480,
                "title": "c-simple-use-of-kadane-and-map",
                "content": "# Intuition\\nThe intution behind the logic is finding the subarray with greatest sum.\\n\\n# Approach\\nUse unordered map to map the value of chars to the respective value.\\nAfter this for simplicity the value of the every charcter of the string \\'s\\' is stored in the temp array to find the maximum sum subarray.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n\\n        for(int i = 0;i<chars.size();i++)\\n            mp[chars[i]] = vals[i];\\n\\n        vector<int> temp;\\n\\n        for(char c : s){\\n            if(mp.find(c) != mp.end())\\n                temp.emplace_back(mp[c]); \\n            else\\n                temp.push_back(c - \\'a\\' + 1);\\n        }\\n\\n        int ans = 0;\\n        int curr = 0;\\n        int n = temp.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            curr = max(temp[i],curr + temp[i]);\\n            ans = max(ans,curr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n\\n        for(int i = 0;i<chars.size();i++)\\n            mp[chars[i]] = vals[i];\\n\\n        vector<int> temp;\\n\\n        for(char c : s){\\n            if(mp.find(c) != mp.end())\\n                temp.emplace_back(mp[c]); \\n            else\\n                temp.push_back(c - \\'a\\' + 1);\\n        }\\n\\n        int ans = 0;\\n        int curr = 0;\\n        int n = temp.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            curr = max(temp[i],curr + temp[i]);\\n            ans = max(ans,curr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371254,
                "title": "python-3-3-lines-w-example-t-m-288-ms-15-7-mb",
                "content": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int])-> int:\\n                                                            # Example: s = \"adcnc\"\\n                                                            #      chars = \"dn\" \\n                                                            #       vals = [-10,-2]\\n        d = {ch:ord(ch)-96 for ch in s} \\n                                                            # d = {\\'a\\':1,\\'d\\':  4,\\'c\\':3,\\'n\\':14} \\n        for ch,val in zip(chars,vals): d[ch] = val          # d = {\\'a\\':1,\\'d\\':-10,\\'c\\':3,\\'n\\':-2}\\n                                                            #       \\n                                                            # [d[ch] for ch in s] = [1,-10,3,-2,3]\\n    \\n        return max(accumulate([d[ch] for ch in s],          # <-- max([0,1,0,3,1,4])\\n                 lambda x, y: max(x+y, 0), initial = 0))    #                    |\\n                                                            #                  return\\n```\\n[https://leetcode.com/problems/find-the-substring-with-maximum-cost/submissions/926247641/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int])-> int:\\n                                                            # Example: s = \"adcnc\"\\n                                                            #      chars = \"dn\" \\n                                                            #       vals = [-10,-2]\\n        d = {ch:ord(ch)-96 for ch in s} \\n                                                            # d = {\\'a\\':1,\\'d\\':  4,\\'c\\':3,\\'n\\':14} \\n        for ch,val in zip(chars,vals): d[ch] = val          # d = {\\'a\\':1,\\'d\\':-10,\\'c\\':3,\\'n\\':-2}\\n                                                            #       \\n                                                            # [d[ch] for ch in s] = [1,-10,3,-2,3]\\n    \\n        return max(accumulate([d[ch] for ch in s],          # <-- max([0,1,0,3,1,4])\\n                 lambda x, y: max(x+y, 0), initial = 0))    #                    |\\n                                                            #                  return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366436,
                "title": "kadane-algorithm-easiest-c-solution-iterative-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum <= 0) {\\n                sum = 0;\\n                continue;\\n            }\\n            if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum <= 0) {\\n                sum = 0;\\n                continue;\\n            }\\n            if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503553,
                "title": "kadane-algorithms-c-easy-to-understnad",
                "content": "kadaane algorithms type solution.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26,0);\\n        int i;\\n        for(i = 0; i < 26; i++){\\n            v[i] = i+1;\\n        }\\n        for(i = 0; i < chars.length(); i++){\\n            v[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int ans = 0, sum = 0;\\n        for(i = 0; i < s.length(); i++){\\n            sum += v[s[i]-\\'a\\'];\\n            ans = max(ans,sum);\\n            if(sum<0)sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26,0);\\n        int i;\\n        for(i = 0; i < 26; i++){\\n            v[i] = i+1;\\n        }\\n        for(i = 0; i < chars.length(); i++){\\n            v[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int ans = 0, sum = 0;\\n        for(i = 0; i < s.length(); i++){\\n            sum += v[s[i]-\\'a\\'];\\n            ans = max(ans,sum);\\n            if(sum<0)sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481990,
                "title": "c-solution-kadane-algo",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char ch = chars[i];\\n            mp[ch] = vals[i];\\n        }\\n        int maxy = 0;\\n        int curr = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (curr < 0) curr = 0;\\n            char ch = s[i];\\n            int val = (ch - \\'a\\' + 1);\\n            if (mp.count(ch) == 1) {\\n                val = mp[ch];\\n            }\\n            curr += val;\\n            maxy = max(maxy, curr);\\n        }\\n\\n        return maxy;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char ch = chars[i];\\n            mp[ch] = vals[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3367136,
                "title": "simple-and-easy-solution-kadane-algo-python3",
                "content": "Kadane\\'s algorithm\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        v = {chars[i]:vals[i] for i in range(len(chars))}\\n        arr = [ v.get(c, ord(c) - 96 ) for c in s ]\\n        \\n        curSum = 0\\n        mSum = 0\\n        \\n        for n in arr:\\n            curSum = max(n, curSum+n)\\n            mSum = max(mSum, curSum)\\n        return mSum if mSum > 0 else 0\\n            \\n    \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        v = {chars[i]:vals[i] for i in range(len(chars))}\\n        arr = [ v.get(c, ord(c) - 96 ) for c in s ]\\n        \\n        curSum = 0\\n        mSum = 0\\n        \\n        for n in arr:\\n            curSum = max(n, curSum+n)\\n            mSum = max(mSum, curSum)\\n        return mSum if mSum > 0 else 0\\n            \\n    \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367118,
                "title": "python3-kadane-ish-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/1dc118daa80cfe1161dcee412e7c3536970ca60d) for solutions of biweely 101. \\n\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        mp = dict(zip(chars, vals))\\n        ans = val = 0 \\n        for i, ch in enumerate(s):\\n            val = max(0, val + mp.get(ch, ord(ch)-96))\\n            ans = max(ans, val)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        mp = dict(zip(chars, vals))\\n        ans = val = 0 \\n        for i, ch in enumerate(s):\\n            val = max(0, val + mp.get(ch, ord(ch)-96))\\n            ans = max(ans, val)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366541,
                "title": "python3-solution-well-explained-easy-clear",
                "content": "# Intuition:\\nThe problem requires finding the maximum cost among all substrings of the given string s. We can find the cost of each character by assigning a value to each character based on whether it is present in the given chars string or not. We can then find the cost of each substring using this assigned value for each character and return the maximum cost.\\n\\n# Approach:\\nWe first create a dictionary to map each character to its corresponding value based on whether it is present in the given chars string or not. We then create a list xx where we replace each character of the given string s with its assigned value using the dictionary we created. We then use the Kadane\\'s algorithm to find the maximum sum contiguous subarray of xx, which gives us the maximum cost of a substring. We return this maximum cost if it is greater than 0, else we return 0.\\n\\n# Complexity:\\n# Time Complexity: \\nThe time complexity of creating the dictionary is O(26+L) where L is the length of the chars string. The time complexity of creating the xx list is O(N) where N is the length of the given string s. The time complexity of the Kadane\\'s algorithm is O(N). Hence, the overall time complexity is O(N+L).\\n\\n# Space Complexity: \\nThe space complexity is O(26+L+N) where L is the length of the chars string and N is the length of the given string s. The extra space is used for the dictionary, xx list, and Kadane\\'s algorithm.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        i=1\\n        m=dict()\\n        for c in ascii_lowercase:\\n            if c in chars:\\n                m.update({c:vals[chars.index(c)]})\\n            else:\\n                m.update({c:i})\\n            i+=1\\n        xx=[]\\n        for i in range(len(s)):\\n            xx.append(m[s[i]])\\n        print(xx)\\n        def maxSubArray(nums: List[int]) -> int:\\n            max_sum=nums[0]\\n            temp=0\\n            for i in range(len(nums)):\\n                if temp<0:\\n                    temp=0\\n                temp+=nums[i]\\n                if temp>max_sum:\\n                    max_sum=temp\\n            return max_sum\\n        \\n        \\n        \\n        return max(maxSubArray(xx),0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        i=1\\n        m=dict()\\n        for c in ascii_lowercase:\\n            if c in chars:\\n                m.update({c:vals[chars.index(c)]})\\n            else:\\n                m.update({c:i})\\n            i+=1\\n        xx=[]\\n        for i in range(len(s)):\\n            xx.append(m[s[i]])\\n        print(xx)\\n        def maxSubArray(nums: List[int]) -> int:\\n            max_sum=nums[0]\\n            temp=0\\n            for i in range(len(nums)):\\n                if temp<0:\\n                    temp=0\\n                temp+=nums[i]\\n                if temp>max_sum:\\n                    max_sum=temp\\n            return max_sum\\n        \\n        \\n        \\n        return max(maxSubArray(xx),0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366456,
                "title": "python-kandane-s-algorithm",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = defaultdict(int)\\n        for i,c in enumerate(chars):\\n            d[c] = vals[i]\\n        for i, c in enumerate(\\'abcdefghijklmnopqrstuvwxyz\\'):\\n            if c not in d:\\n                d[c] = i + 1\\n        curmax = 0\\n        res = 0\\n        for c in s:\\n            curmax = max(curmax + d[c], 0)\\n            res = max(res, curmax)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = defaultdict(int)\\n        for i,c in enumerate(chars):\\n            d[c] = vals[i]\\n        for i, c in enumerate(\\'abcdefghijklmnopqrstuvwxyz\\'):\\n            if c not in d:\\n                d[c] = i + 1\\n        curmax = 0\\n        res = 0\\n        for c in s:\\n            curmax = max(curmax + d[c], 0)\\n            res = max(res, curmax)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073330,
                "title": "substring-maximum-cost-o-1-javascript-memory-95-45-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(26) ~= O(1)\\n```\\nvar maximumCostSubstring = function(s, chars, vals) {\\n    const charValues = {};\\n    for (let index = 0; index < chars.length; index++) {\\n        charValues[chars[index]] = vals[index];\\n    }\\n\\n    for (let index = 97; index <= 122; index++) {\\n        if (charValues[String.fromCharCode(index)] === undefined) {\\n            charValues[String.fromCharCode(index)] = index - 96;\\n        }\\n    }\\n    let sum = 0;\\n    let tempSum = 0;\\n    for (let index = 0; index < s.length; index++) {\\n        tempSum += charValues[s[index]];\\n        //Min Sum is 0, so if temp sum has gone below zero then adding prefixed sub string wont benefit\\n        if (tempSum < 0) {\\n            tempSum = 0;\\n        }\\n        if (sum < tempSum) {\\n            sum = tempSum;\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCostSubstring = function(s, chars, vals) {\\n    const charValues = {};\\n    for (let index = 0; index < chars.length; index++) {\\n        charValues[chars[index]] = vals[index];\\n    }\\n\\n    for (let index = 97; index <= 122; index++) {\\n        if (charValues[String.fromCharCode(index)] === undefined) {\\n            charValues[String.fromCharCode(index)] = index - 96;\\n        }\\n    }\\n    let sum = 0;\\n    let tempSum = 0;\\n    for (let index = 0; index < s.length; index++) {\\n        tempSum += charValues[s[index]];\\n        //Min Sum is 0, so if temp sum has gone below zero then adding prefixed sub string wont benefit\\n        if (tempSum < 0) {\\n            tempSum = 0;\\n        }\\n        if (sum < tempSum) {\\n            sum = tempSum;\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3404657,
                "title": "kadane-algo-100-beats-easy-to-understand-short-sweet-c-code",
                "content": "````\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26,0);\\n        int i;\\n        for(i = 0; i < 26; i++)v[i] = i+1;//FIRST ASSIGN COST TO IT\\'S INDEX\\n        for(i = 0; i < chars.length(); i++)v[chars[i]-\\'a\\'] = vals[i];//ASSIGN COST ACCORDING TO CHARS AND VALS\\n        int ans = 0;//LET\\'S ANS 0\\n\\t\\tint sum = 0;//CALCULATE ANS\\n        for(auto &i: s){\\n            sum += v[i-\\'a\\'];\\n            if(sum<0)sum = 0;//IF COST < 0 ASSIGN TO 0 BECAUSE HERE WE FIND MAX COST\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26,0);\\n        int i;\\n        for(i = 0; i < 26; i++)v[i] = i+1;//FIRST ASSIGN COST TO IT\\'S INDEX\\n        for(i = 0; i < chars.length(); i++)v[chars[i]-\\'a\\'] = vals[i];//ASSIGN COST ACCORDING TO CHARS AND VALS\\n        int ans = 0;//LET\\'S ANS 0\\n\\t\\tint sum = 0;//CALCULATE ANS\\n        for(auto &i: s){\\n            sum += v[i-\\'a\\'];\\n            if(sum<0)sum = 0;//IF COST < 0 ASSIGN TO 0 BECAUSE HERE WE FIND MAX COST\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379140,
                "title": "indirect-kadane",
                "content": "***INTUITION***\\nWe have to find the substring cost(maximized)\\n1. Create a hashmap with all the 26 charactes as key and their value as their positions (ex. Key: \\'a\\' :: Value : 1). Then update the key-value pairs on the basis of `string chars` and `vector vals`.\\n2. Create a vector array and push value corresponding to the `string s`.\\n3. Now Apply Kadanes to find the max contigious subarray sum.\\n4. `return max( 0 , sum )`\\n\\n***CODE***\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) \\n\\t{\\n        unordered_map<char,int>m;\\n        for(int i=0;i<26;i++)\\n        {\\n            char ch=i+\\'a\\';\\n            m[ch]=i+1;\\n        }\\n        for(int i=0;i<chars.length();i++) m[chars[i]]=vals[i];\\n        \\n        vector<int>v;\\n        for(auto ele:s)\\n        {\\n            v.push_back(m[ele]);\\n        }\\n        \\n\\t\\t//KADANES\\n        int max_so_far = INT_MIN, max_ending_here = 0;\\n \\n        for (int i = 0; i < v.size(); i++) \\n\\t\\t{\\n            max_ending_here = max_ending_here + v[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n\\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n\\t\\t\\n        return max( 0 , max_so_far );\\n    }\\n};\\n```\\n\\n# PLS UPVOTE \\n\\n![image](https://assets.leetcode.com/users/images/caf935a4-dfa6-4fa4-a285-f224af5583dd_1680611410.6690323.jpeg)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) \\n\\t{\\n        unordered_map<char,int>m;\\n        for(int i=0;i<26;i++)\\n        {\\n            char ch=i+\\'a\\';\\n            m[ch]=i+1;\\n        }\\n        for(int i=0;i<chars.length();i++) m[chars[i]]=vals[i];\\n        \\n        vector<int>v;\\n        for(auto ele:s)\\n        {\\n            v.push_back(m[ele]);\\n        }\\n        \\n\\t\\t//KADANES\\n        int max_so_far = INT_MIN, max_ending_here = 0;\\n \\n        for (int i = 0; i < v.size(); i++) \\n\\t\\t{\\n            max_ending_here = max_ending_here + v[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n\\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n\\t\\t\\n        return max( 0 , max_so_far );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367438,
                "title": "sliding-window-mapping-o-n-time-o-26-space",
                "content": "# Intuition\\nOne shall calculate the sum for every subarray using suitable algorithm and update it whenever there is a negative sum to 0.\\n\\n# Approach\\n Here, we shall keep a look-up table for all the char-value pair in order to be able to calculate their sum quick. And since we are talking about subarrays, we can always think of a possibility to use sliding window or kadane\\'s algorithm.\\n\\n# Complexity\\n- Time complexity\\n    O(max(n,26)) ~ O(n)\\n    - As we are traversing the string once for calculation ans\\n    - Traversing the 26 characters for storing their corresponding values\\n    - Coz in worst case we can have a string of all the 26 chars repeating themselves \\n    \\n- Space complexity:\\n    O(26)\\n    - As we are storing the corresponding values for each char in a map for easy access\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> m;\\n        for (int i=0; i<26; i++){\\n            m[\\'a\\'+i]=i+1;\\n        }\\n        for (int i=0; i<chars.size(); i++){\\n            m[chars[i]]=vals[i];\\n        }\\n        int start =0;\\n        int curr =0;\\n        int ans =0;\\n        for (int i=0; i<s.size(); i++){\\n            curr += m[s[i]];\\n            curr = max (curr, 0);\\n            ans = max (ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> m;\\n        for (int i=0; i<26; i++){\\n            m[\\'a\\'+i]=i+1;\\n        }\\n        for (int i=0; i<chars.size(); i++){\\n            m[chars[i]]=vals[i];\\n        }\\n        int start =0;\\n        int curr =0;\\n        int ans =0;\\n        for (int i=0; i<s.size(); i++){\\n            curr += m[s[i]];\\n            curr = max (curr, 0);\\n            ans = max (ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367030,
                "title": "maximum-sum-subarray-variation-kadane-s-algorithm",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst create a mapping of each lowercase alphabet to its position value. Then, it updates the values for the characters in the chars string based on their corresponding values in the vals vector.\\n\\nNext, the code iterates over all characters in the input string s, and calculates the cost of each substring by summing the values of the characters in the substring. If the cost of a substring is greater than the current maximum, the maximum is updated. If the sum of the cost of the substring is less than zero, the sum is reset to zero since any substring with negative cost cannot be a maximum cost substring.\\n\\nFinally, if the maximum cost is negative, the code returns zero, otherwise, it returns the maximum cost substring.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int>m;\\n        int count = 1;\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            m[i] = count;\\n            count++;\\n        }\\n        for(int i = 0; i < chars.size(); i++) {\\n            m[chars[i]] = vals[i];\\n        }\\n        int sum = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < s.size(); i++) {\\n            sum+=m[s[i]];\\n            if(maxi < sum){\\n                maxi = sum;\\n            }\\n            if(sum < 0) {\\n                sum = 0;\\n            }\\n        }\\n        if(maxi < 0){\\n            return 0;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int>m;\\n        int count = 1;\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            m[i] = count;\\n            count++;\\n        }\\n        for(int i = 0; i < chars.size(); i++) {\\n            m[chars[i]] = vals[i];\\n        }\\n        int sum = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < s.size(); i++) {\\n            sum+=m[s[i]];\\n            if(maxi < sum){\\n                maxi = sum;\\n            }\\n            if(sum < 0) {\\n                sum = 0;\\n            }\\n        }\\n        if(maxi < 0){\\n            return 0;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366959,
                "title": "simplest-java-solution-using-kadane-s-algorithm",
                "content": "# Intuition\\nUse Kadane\\'a algorithm\\n\\n# Approach\\nFirst calculate all values for each character of string s and store it to an array. Then calculate maximum subarray sum using Kadane\\'s algorithm.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(n)\\n\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/274181eb-f698-4c79-9ca2-4b8789eedeae_1680369453.4686017.png)\\n\\n# Code\\n```\\nclass Solution {\\n    //use Kadane\\'s algorithm to find maximum subarray sum\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE, currSum = 0;\\n        int max = Integer.MIN_VALUE;\\n        int count = 0;\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            if(nums[i]>=0)\\n            count++;\\n            max=Math.max(max,nums[i]);\\n        }\\n        if(count<=0)\\n        return max;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            currSum += nums[i];\\n            if(currSum<0)\\n                currSum = 0;\\n            maxSum = Math.max(maxSum,currSum);\\n        }\\n        return maxSum;\\n    }\\n    \\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashSet<Character> set = new HashSet<>();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        //calculate all values for String s and take it to the value array\\n        int[] value = new int[s.length()];\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            set.add(chars.charAt(i));\\n            map.put(chars.charAt(i),vals[i]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                value[i] = map.get(s.charAt(i));\\n            }\\n            else\\n            {\\n                value[i] = s.charAt(i) - \\'a\\' + 1;\\n            }\\n        }\\n        \\n        //check if there exists at least one positive value\\n        int temp=0;\\n        for(int i=0;i<value.length;i++)\\n        {\\n            if(value[i]>0)\\n                temp = 1;\\n        }\\n        //if all value are negetive return 0\\n        if(temp==0) return 0;\\n            \\n        return maxSubArray(value);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //use Kadane\\'s algorithm to find maximum subarray sum\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE, currSum = 0;\\n        int max = Integer.MIN_VALUE;\\n        int count = 0;\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            if(nums[i]>=0)\\n            count++;\\n            max=Math.max(max,nums[i]);\\n        }\\n        if(count<=0)\\n        return max;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            currSum += nums[i];\\n            if(currSum<0)\\n                currSum = 0;\\n            maxSum = Math.max(maxSum,currSum);\\n        }\\n        return maxSum;\\n    }\\n    \\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashSet<Character> set = new HashSet<>();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        //calculate all values for String s and take it to the value array\\n        int[] value = new int[s.length()];\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            set.add(chars.charAt(i));\\n            map.put(chars.charAt(i),vals[i]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                value[i] = map.get(s.charAt(i));\\n            }\\n            else\\n            {\\n                value[i] = s.charAt(i) - \\'a\\' + 1;\\n            }\\n        }\\n        \\n        //check if there exists at least one positive value\\n        int temp=0;\\n        for(int i=0;i<value.length;i++)\\n        {\\n            if(value[i]>0)\\n                temp = 1;\\n        }\\n        //if all value are negetive return 0\\n        if(temp==0) return 0;\\n            \\n        return maxSubArray(value);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366686,
                "title": "kadane-s-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int m = chars.size(), sum = 0, ans = 0;\\n        vector<int> value(26);\\n        for(int i=0; i<26; i++) value[i] = i + 1;\\n        for(int i=0; i<m; i++) value[chars[i] - \\'a\\'] = vals[i];\\n        \\n        for(char c : s) {\\n            sum += value[c - \\'a\\'];\\n            ans = max(ans, sum);\\n            if(sum < 0) sum = 0; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int m = chars.size(), sum = 0, ans = 0;\\n        vector<int> value(26);\\n        for(int i=0; i<26; i++) value[i] = i + 1;\\n        for(int i=0; i<m; i++) value[chars[i] - \\'a\\'] = vals[i];\\n        \\n        for(char c : s) {\\n            sum += value[c - \\'a\\'];\\n            ans = max(ans, sum);\\n            if(sum < 0) sum = 0; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366675,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Maximum Subarray\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> mp;\\n        int id = 1;\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++) mp[c] = id, id++;\\n        for(int i=0; i<vals.size(); i++) mp[chars[i]] = vals[i];\\n        vector<int> nums;\\n        for(auto x: s) nums.push_back(mp[x]);\\n        int ans = nums[0], sum = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            if(sum > ans) ans = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n        return max(ans, 0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> mp;\\n        int id = 1;\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++) mp[c] = id, id++;\\n        for(int i=0; i<vals.size(); i++) mp[chars[i]] = vals[i];\\n        vector<int> nums;\\n        for(auto x: s) nums.push_back(mp[x]);\\n        int ans = nums[0], sum = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            if(sum > ans) ans = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n        return max(ans, 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366656,
                "title": "c-kadane-s-algorithm-very-easy-solution",
                "content": "\\tclass Solution\\n\\t{\\n\\tpublic:\\n\\t\\tint maximumCostSubstring(string s, string chars, vector<int> &vals)\\n\\t\\t{\\n\\t\\t\\tint n = s.size();\\n\\n\\t\\t\\t// create an unordered map to store the mapping of characters to values\\n\\t\\t\\tunordered_map<char, int> mp;\\n\\n\\t\\t\\t// initialize the values for all lowercase letters from \\'a\\' to \\'z\\'\\n\\t\\t\\tfor (char i = \\'a\\'; i <= \\'z\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[i] = i - \\'a\\' + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update the values for the characters specified in \\'chars\\' using the values provided in \\'vals\\'\\n\\t\\t\\tfor (int i = 0; i < chars.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[chars[i]] = vals[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// create a vector to store the values of each character in the input string\\n\\t\\t\\tvector<int> vec;\\n\\n\\t\\t\\t// iterate through the input string and append the corresponding value for each character to the vector\\n\\t\\t\\tfor (auto a : s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout << mp[a] << \\',\\';\\n\\t\\t\\t\\tvec.push_back(mp[a]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the maximum sum of consecutive elements in the vector using the Kadane\\'s algorithm\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tint max1 = INT_MIN;\\n\\t\\t\\tif (vec.size() == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tfor (int i = 0; i < vec.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum += vec[i];\\n\\t\\t\\t\\tif (sum < 0)\\n\\t\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\tmax1 = max(max1, sum);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// return the maximum sum\\n\\t\\t\\treturn max1;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n\\t\\tint maximumCostSubstring(string s, string chars, vector<int> &vals)\\n\\t\\t{\\n\\t\\t\\tint n = s.size();\\n\\n\\t\\t\\t// create an unordered map to store the mapping of characters to values\\n\\t\\t\\tunordered_map<char, int> mp;\\n\\n\\t\\t\\t// initialize the values for all lowercase letters from \\'a\\' to \\'z\\'\\n\\t\\t\\tfor (char i = \\'a\\'; i <= \\'z\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[i] = i - \\'a\\' + 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3366477,
                "title": "simplest-c-solution-using-kadane-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->o(n)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum < 0) {\\n                sum = 0;\\n            }\\n            else if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum < 0) {\\n                sum = 0;\\n            }\\n            else if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366409,
                "title": "c-kadane-s-algorithm-easy-and-concise-o-n-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n) **where n size of s string**\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum <= 0) {\\n                sum = 0;\\n            }\\n            else if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum <= 0) {\\n                sum = 0;\\n            }\\n            else if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366370,
                "title": "easy-java-solution-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<chars.length();i++){\\n            hm.put(chars.charAt(i),vals[i]);\\n        }\\n        int k=1;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if(!hm.containsKey(ch)){\\n                hm.put(ch,k);\\n            }\\n            k++;\\n        }\\n\\n        int ref=0;\\n        int arr[]=new int[s.length()];\\n\\n<!-- converting into array of values corresponding to letters in string s, to perform Kadanes algo -->\\n\\n        for(int i=0;i<s.length();i++)\\n            arr[i]=hm.get(s.charAt(i));\\n        \\n        for(int i=0;i<s.length();i++){\\n            ref+=arr[i];\\n                if(ref>ans){\\n                    ans=ref;\\n                }\\n            if(ref<0){\\n                ref=0;\\n            }\\n        }\\n        return ans<0?0:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<chars.length();i++){\\n            hm.put(chars.charAt(i),vals[i]);\\n        }\\n        int k=1;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if(!hm.containsKey(ch)){\\n                hm.put(ch,k);\\n            }\\n            k++;\\n        }\\n\\n        int ref=0;\\n        int arr[]=new int[s.length()];\\n\\n<!-- converting into array of values corresponding to letters in string s, to perform Kadanes algo -->\\n\\n        for(int i=0;i<s.length();i++)\\n            arr[i]=hm.get(s.charAt(i));\\n        \\n        for(int i=0;i<s.length();i++){\\n            ref+=arr[i];\\n                if(ref>ans){\\n                    ans=ref;\\n                }\\n            if(ref<0){\\n                ref=0;\\n            }\\n        }\\n        return ans<0?0:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824152,
                "title": "simple-easy-solution-beats-99-accepted",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, a: str, c: str, x: List[int]) -> int:\\n        y=[]\\n        for i in a:\\n            if i in c: y.append(x[c.index(i)])\\n            else: y.append(ord(i)-96)\\n        s=t=0\\n        for i in y:\\n            t=max(t,0)\\n            s=max(s,t)\\n            t+=i\\n        return max(s,t,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, a: str, c: str, x: List[int]) -> int:\\n        y=[]\\n        for i in a:\\n            if i in c: y.append(x[c.index(i)])\\n            else: y.append(ord(i)-96)\\n        s=t=0\\n        for i in y:\\n            t=max(t,0)\\n            s=max(s,t)\\n            t+=i\\n        return max(s,t,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603025,
                "title": "kadane-c",
                "content": "\\n# Approach\\nWe use array hsh to store the resulting value of each character:\\n\\nWe initialize it with 1, 2, 3, 4... (key value from a to z)\\nand override certain values that are given in vals.\\nwe use Kadane to find the maximum sum subarray.\\n\\n# Complexity\\n- Time complexity:\\n- O(26)+O(26)+O(100000) ~= O(s.size()) \\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\n        int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n            // create key-value array\\n            vector<int> hsh(26);\\n            for(char i=\\'a\\'; i<=\\'z\\'; ++i) hsh[i-\\'a\\'] = i-\\'a\\'+1;\\n            for(int i=0; i<chars.size(); ++i) hsh[chars[i]-\\'a\\'] = vals[i];\\n\\n            //Kadane\\'s algo to find max substring sum\\n            int csum=0, maxsum=0;\\n            for(auto c : s){\\n                csum = max(0,csum+hsh[c-\\'a\\']);\\n                maxsum = max(maxsum,csum);\\n            }\\n            return maxsum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n        int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n            // create key-value array\\n            vector<int> hsh(26);\\n            for(char i=\\'a\\'; i<=\\'z\\'; ++i) hsh[i-\\'a\\'] = i-\\'a\\'+1;\\n            for(int i=0; i<chars.size(); ++i) hsh[chars[i]-\\'a\\'] = vals[i];\\n\\n            //Kadane\\'s algo to find max substring sum\\n            int csum=0, maxsum=0;\\n            for(auto c : s){\\n                csum = max(0,csum+hsh[c-\\'a\\']);\\n                maxsum = max(maxsum,csum);\\n            }\\n            return maxsum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478122,
                "title": "2606-find-the-substring-with-maximum-cost-java",
                "content": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int []ar=new int[26];\\n        for(int i=0;i<26;i++)\\n            ar[i]=i+1;\\n        for(int i=0;i<vals.length;i++ )\\n        {\\n            ar[chars.charAt(i)-\\'a\\']=vals[i];\\n        }\\n        int ans=0,cnt=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cnt+=ar[s.charAt(i)-\\'a\\'];\\n            ans=Math.max(cnt,ans);\\n            if(cnt<0)\\n                cnt=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int []ar=new int[26];\\n        for(int i=0;i<26;i++)\\n            ar[i]=i+1;\\n        for(int i=0;i<vals.length;i++ )\\n        {\\n            ar[chars.charAt(i)-\\'a\\']=vals[i];\\n        }\\n        int ans=0,cnt=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cnt+=ar[s.charAt(i)-\\'a\\'];\\n            ans=Math.max(cnt,ans);\\n            if(cnt<0)\\n                cnt=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382805,
                "title": "hashmap-kadane-c-solution-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert characters values with required integers and then apply kadane to find maximum subarray\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. storing characters as 1 based index values in map\\n2. if character present in chars, replace its value with value in vals\\n3. store all characters values in a vector as integers \\n4. Now we Apply Kadane\\'s Algorithm to find maximum subarray \\n        \\n# Complexity\\n- Time complexity: O(chars.size() + s.size()).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(s.size()) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPls Spare 10 Milliseconds to Upvote if this solution helped you  \\uD83D\\uDE4C\\uD83D\\uDE0A\\u2764\\uFE0F\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        unordered_map<char,int> mp;\\n\\n        int p=1;\\n        for(char c = \\'a\\';c<=\\'z\\';c++){\\n            mp[c] = p++; // storing characters as 1 based index values in map\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i]; // if character present in chars, replace its value with value in vals\\n        }\\n        vector<int> temp;\\n        for(auto i:s){\\n            temp.push_back(mp[i]); // store all characters values in a vector as integers \\n        }\\n// Now we Apply Kadane\\'s Algorithm to find maximum subarray \\n        int ans = 0;\\n        int count = 0;\\n        for(auto i:temp){\\n            count+=i;\\n            ans = max(ans,count);\\n            if(count<0){\\n                count=0;\\n            }\\n        }\\n    return ans;   \\n    }\\n};\\n```\\nPls Spare 10 Milliseconds to Upvote if this solution helped you  \\uD83D\\uDE4C\\uD83D\\uDE0A\\u2764\\uFE0F\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        unordered_map<char,int> mp;\\n\\n        int p=1;\\n        for(char c = \\'a\\';c<=\\'z\\';c++){\\n            mp[c] = p++; // storing characters as 1 based index values in map\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i]; // if character present in chars, replace its value with value in vals\\n        }\\n        vector<int> temp;\\n        for(auto i:s){\\n            temp.push_back(mp[i]); // store all characters values in a vector as integers \\n        }\\n// Now we Apply Kadane\\'s Algorithm to find maximum subarray \\n        int ans = 0;\\n        int count = 0;\\n        for(auto i:temp){\\n            count+=i;\\n            ans = max(ans,count);\\n            if(count<0){\\n                count=0;\\n            }\\n        }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375626,
                "title": "modifive-subarray-sum-well-explained-approach-inution-tc-sc-gauravthinks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- OOO DARO NA MALLO, YE TO BAS MODIFIVE SUBARRAY SUM HAI :-)\\n\\nwe keep athe record of max sum upto the current index and the moment our sum variable goes below 0, we reset it to 0 as negative values only decrease the max sum and not contribute much to the results.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- make a frequency array/hashset/map to keep the common characters of ```string s``` ans ```string chars```, with their respective values.\\nlike for each common value of ```s``` in ```chars```, we have been given ```vals``` array. so wee keep the common character\\'s as well as non common character\\'s values into the ```freq```\\n\\n-  then the rest is KADANE\\'S algorithm on the freq array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n-O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int res=0;\\n        // if(s==chars) return res;\\n        int sum=0;\\n        int n= s.size();\\n        int m= chars.size();\\n        vector<int> freq(26, 0);\\n        for(auto i=0;i<26; i++){\\n            freq[i] = i+1;\\n        }\\n        for(auto it=0; it<chars.size(); it++){\\n            freq[chars[it]-\\'a\\']= vals[it];\\n        }\\n        for(auto it: s){\\n            sum+= freq[it-\\'a\\'];\\n            res= max(res, sum);\\n            if(sum<0) sum=0;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you liked the solution and explanation, then do Upvote the solution and subscribe to our YouTube Channel down below.\\n\\n# @GauravThinks <----- youtube channel",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```string s```\n```string chars```\n```s```\n```chars```\n```vals```\n```freq```\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int res=0;\\n        // if(s==chars) return res;\\n        int sum=0;\\n        int n= s.size();\\n        int m= chars.size();\\n        vector<int> freq(26, 0);\\n        for(auto i=0;i<26; i++){\\n            freq[i] = i+1;\\n        }\\n        for(auto it=0; it<chars.size(); it++){\\n            freq[chars[it]-\\'a\\']= vals[it];\\n        }\\n        for(auto it: s){\\n            sum+= freq[it-\\'a\\'];\\n            res= max(res, sum);\\n            if(sum<0) sum=0;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373142,
                "title": "c-easy-using-kadane",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> m;\\n        for(int i = 0; i< chars.size(); i++)\\n        {\\n            m[chars[i]] = i;\\n        }\\n        int n = s.size();\\n        int sum = 0, maxi = INT_MIN;\\n        for(int i = 0; i< n ; i++)\\n        {\\n            if(m.find(s[i]) != m.end())\\n            {\\n                int index = m[s[i]];\\n                sum+= vals[index];\\n            }\\n            else\\n            {\\n                sum+= s[i]-\\'a\\'+1;\\n            }\\n            if(maxi < sum )\\n            {\\n                maxi = sum;\\n            }\\n            if( sum < 0)\\n            {\\n                sum = 0;\\n            }\\n        }\\n        if(maxi < 0)\\n            return 0;\\n        else\\n            return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> m;\\n        for(int i = 0; i< chars.size(); i++)\\n        {\\n            m[chars[i]] = i;\\n        }\\n        int n = s.size();\\n        int sum = 0, maxi = INT_MIN;\\n        for(int i = 0; i< n ; i++)\\n        {\\n            if(m.find(s[i]) != m.end())\\n            {\\n                int index = m[s[i]];\\n                sum+= vals[index];\\n            }\\n            else\\n            {\\n                sum+= s[i]-\\'a\\'+1;\\n            }\\n            if(maxi < sum )\\n            {\\n                maxi = sum;\\n            }\\n            if( sum < 0)\\n            {\\n                sum = 0;\\n            }\\n        }\\n        if(maxi < 0)\\n            return 0;\\n        else\\n            return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371417,
                "title": "cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n        \\n        for(int i=0 ; i<s.size() ; i++){\\n            for(int j=0 ; j<chars.size() ; j++){\\n                if(s[i] == chars[j]){\\n                    mp[s[i]] = vals[j];\\n                    break;\\n                }\\n            }\\n            if(mp.find(s[i]) == mp.end()){\\n                mp[s[i]] = s[i] - \\'a\\' + 1;\\n            }\\n        }\\n\\n        int sum = 0;\\n        int ans = 0;\\n        int j = 0;\\n\\n        while(j < s.size()){\\n            sum += mp[s[j]];\\n            ans = max(ans,sum);\\n\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n        \\n        for(int i=0 ; i<s.size() ; i++){\\n            for(int j=0 ; j<chars.size() ; j++){\\n                if(s[i] == chars[j]){\\n                    mp[s[i]] = vals[j];\\n                    break;\\n                }\\n            }\\n            if(mp.find(s[i]) == mp.end()){\\n                mp[s[i]] = s[i] - \\'a\\' + 1;\\n            }\\n        }\\n\\n        int sum = 0;\\n        int ans = 0;\\n        int j = 0;\\n\\n        while(j < s.size()){\\n            sum += mp[s[j]];\\n            ans = max(ans,sum);\\n\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371276,
                "title": "java-solution-beats-100-time-beats-100-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nkadane\\'s algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n      \\n        ArrayList<Integer> ans = new ArrayList();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(chars.contains(s.charAt(i)+\"\")){\\n                \\n                ans.add(vals[chars.indexOf(s.charAt(i))]);\\n                \\n            }else{\\n                \\n                ans.add((int)s.charAt(i)- 96);\\n                \\n                \\n            }\\n        }\\n        System.out.println(ans);\\n       \\n        \\n        int msum = ans.get(0);\\n        int sum = 0;\\n        for(int i = 0 ; i < ans.size() ; i++){\\n            sum +=ans.get(i);\\n            msum = Math.max(msum, sum);\\n            if(sum < 0 ){\\n                sum = 0;\\n            }\\n        }\\n        if(msum < 0){\\n            return 0;\\n        }\\n        return msum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n      \\n        ArrayList<Integer> ans = new ArrayList();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(chars.contains(s.charAt(i)+\"\")){\\n                \\n                ans.add(vals[chars.indexOf(s.charAt(i))]);\\n                \\n            }else{\\n                \\n                ans.add((int)s.charAt(i)- 96);\\n                \\n                \\n            }\\n        }\\n        System.out.println(ans);\\n       \\n        \\n        int msum = ans.get(0);\\n        int sum = 0;\\n        for(int i = 0 ; i < ans.size() ; i++){\\n            sum +=ans.get(i);\\n            msum = Math.max(msum, sum);\\n            if(sum < 0 ){\\n                sum = 0;\\n            }\\n        }\\n        if(msum < 0){\\n            return 0;\\n        }\\n        return msum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371206,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string c, vector<int>& v) {\\n        int d[26];\\n        for(int i=0;i<26;i++){\\n            d[i]=i+1;\\n        }\\n        for(int i=0;i<c.size();i++){\\n            int x=c[i]-\\'a\\';\\n            // cout<<x;\\n            d[x]=v[i];\\n        }\\n        \\n        vector<int>pre;\\n        long long int sum=0;\\n        // pre.push_back(sum);\\n        for(int i=0;i<s.size();i++){\\n            int x=s[i]-\\'a\\';\\n            \\n            pre.push_back(d[x]);\\n        }\\n        for(int i=0;i<pre.size();i++){\\n            cout<<pre[i]<<\" \";\\n        }\\n        long long int maxi=0;\\n        //int sum=0;\\n        for(int i=0;i<pre.size();i++){\\n            \\n            if(sum+pre[i]<0){\\n                maxi=max(sum,maxi);\\n                sum=0;\\n            }\\n            else{\\n                sum+=pre[i];\\n                 maxi=max(sum,maxi);\\n            }\\n        }\\n        if(sum>0){\\n            maxi=max(sum,maxi);\\n        }\\n        return maxi;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string c, vector<int>& v) {\\n        int d[26];\\n        for(int i=0;i<26;i++){\\n            d[i]=i+1;\\n        }\\n        for(int i=0;i<c.size();i++){\\n            int x=c[i]-\\'a\\';\\n            // cout<<x;\\n            d[x]=v[i];\\n        }\\n        \\n        vector<int>pre;\\n        long long int sum=0;\\n        // pre.push_back(sum);\\n        for(int i=0;i<s.size();i++){\\n            int x=s[i]-\\'a\\';\\n            \\n            pre.push_back(d[x]);\\n        }\\n        for(int i=0;i<pre.size();i++){\\n            cout<<pre[i]<<\" \";\\n        }\\n        long long int maxi=0;\\n        //int sum=0;\\n        for(int i=0;i<pre.size();i++){\\n            \\n            if(sum+pre[i]<0){\\n                maxi=max(sum,maxi);\\n                sum=0;\\n            }\\n            else{\\n                sum+=pre[i];\\n                 maxi=max(sum,maxi);\\n            }\\n        }\\n        if(sum>0){\\n            maxi=max(sum,maxi);\\n        }\\n        return maxi;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3369754,
                "title": "dart-o-n-mapping-to-kadane-s-algorithm",
                "content": "# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int maximumCostSubstring(String s, String chars, List<int> vals) {\\n    HashMap<String, int> map = HashMap();\\n    for (var i = 1; i <= 26; i++) {\\n      map.addAll({String.fromCharCode((96 + i)): i});\\n    }\\n    int n = s.length;\\n    int m = vals.length;\\n    for (var i = 0; i < m; i++) {\\n      map[chars[i]] = vals[i];\\n    }\\n    List<int> nums = List.filled(n, 0);\\n    for (var i = 0; i < n; i++) {\\n      nums[i] = map[s[i]]!;\\n    }\\n    int res = maxSubArraySum(nums);\\n\\n    return res.isNegative ? 0 : res;\\n  }\\n\\n  int maxSubArraySum(List<int> a) {\\n    int size = a.length;\\n    int maxSoFar = -2147483648, maxEndingHere = 0;\\n\\n    for (int i = 0; i < size; i++) {\\n      maxEndingHere = maxEndingHere + a[i];\\n      if (maxSoFar < maxEndingHere) {\\n        maxSoFar = maxEndingHere;\\n      }\\n      if (maxEndingHere < 0) {\\n        maxEndingHere = 0;\\n      }\\n    }\\n    return maxSoFar;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int maximumCostSubstring(String s, String chars, List<int> vals) {\\n    HashMap<String, int> map = HashMap();\\n    for (var i = 1; i <= 26; i++) {\\n      map.addAll({String.fromCharCode((96 + i)): i});\\n    }\\n    int n = s.length;\\n    int m = vals.length;\\n    for (var i = 0; i < m; i++) {\\n      map[chars[i]] = vals[i];\\n    }\\n    List<int> nums = List.filled(n, 0);\\n    for (var i = 0; i < n; i++) {\\n      nums[i] = map[s[i]]!;\\n    }\\n    int res = maxSubArraySum(nums);\\n\\n    return res.isNegative ? 0 : res;\\n  }\\n\\n  int maxSubArraySum(List<int> a) {\\n    int size = a.length;\\n    int maxSoFar = -2147483648, maxEndingHere = 0;\\n\\n    for (int i = 0; i < size; i++) {\\n      maxEndingHere = maxEndingHere + a[i];\\n      if (maxSoFar < maxEndingHere) {\\n        maxSoFar = maxEndingHere;\\n      }\\n      if (maxEndingHere < 0) {\\n        maxEndingHere = 0;\\n      }\\n    }\\n    return maxSoFar;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369494,
                "title": "kadane-s-algorithm-beats-100-time-o-n-time-o-1-space",
                "content": "# Intuition\\nWe can hash the values of characters using chars array and then find the subarray with maximum sum using Kadane\\'s Algorithm. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(26) = O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> values(26,1);\\n        \\n        for(int i = 0;i<26;i++){\\n            values[i] = i+1;\\n        }\\n        \\n        for(int i = 0;i<chars.size();i++){\\n            values[chars[i]-\\'a\\'] = vals[i];    \\n        }\\n        \\n        int mxsum = 0,curr = 0;\\n        for(int i = 0;i<s.size();i++){\\n            curr += values[s[i]-\\'a\\'];\\n            mxsum = max(mxsum,curr);\\n            \\n            if(curr < 0){\\n                curr = 0;\\n            }\\n        }\\n        \\n        return mxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> values(26,1);\\n        \\n        for(int i = 0;i<26;i++){\\n            values[i] = i+1;\\n        }\\n        \\n        for(int i = 0;i<chars.size();i++){\\n            values[chars[i]-\\'a\\'] = vals[i];    \\n        }\\n        \\n        int mxsum = 0,curr = 0;\\n        for(int i = 0;i<s.size();i++){\\n            curr += values[s[i]-\\'a\\'];\\n            mxsum = max(mxsum,curr);\\n            \\n            if(curr < 0){\\n                curr = 0;\\n            }\\n        }\\n        \\n        return mxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368128,
                "title": "java-solution",
                "content": "\\tpublic int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int l = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n            map.put(c, c - \\'a\\' + 1);\\n        for(int i=0;i<vals.length;i++) \\n            map.put(chars.charAt(i), vals[i]);\\n        int res = 0, max = 0;\\n        for(int i=0;i<s.length();i++) {\\n            max = Math.max(map.get(s.charAt(i)), max + map.get(s.charAt(i)));\\n            res = Math.max(res, max);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int l = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n            map.put(c, c - \\'a\\' + 1);\\n        for(int i=0;i<vals.length;i++) \\n            map.put(chars.charAt(i), vals[i]);\\n        int res = 0, max = 0;\\n        for(int i=0;i<s.length();i++) {\\n            max = Math.max(map.get(s.charAt(i)), max + map.get(s.charAt(i)));\\n            res = Math.max(res, max);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3368070,
                "title": "c-kadane-s-algorithm-for-char-representatives-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>st(26,0);\\n         for(int i=0;i<26;i++){\\n            st[i]=i+1;\\n        }\\n        for(int i=0;i<vals.size();i++){\\n            st[chars[i] - \\'a\\']=vals[i];\\n        }\\n        \\n        int maxi=0,sum=0;\\n        for(auto x:s){\\n            sum+=st[x-\\'a\\'];\\n            maxi=max(sum,maxi);\\n            if(sum<=0){\\n                sum=0;\\n            }       \\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>st(26,0);\\n         for(int i=0;i<26;i++){\\n            st[i]=i+1;\\n        }\\n        for(int i=0;i<vals.size();i++){\\n            st[chars[i] - \\'a\\']=vals[i];\\n        }\\n        \\n        int maxi=0,sum=0;\\n        for(auto x:s){\\n            sum+=st[x-\\'a\\'];\\n            maxi=max(sum,maxi);\\n            if(sum<=0){\\n                sum=0;\\n            }       \\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367983,
                "title": "standard-solution",
                "content": "# Intuition\\nFirst step is to calculate the cost for each position of string \\'s\\' and store it in vector. Then apply kadane algorithm to find maximum cost in subarrays of vector.  \\n\\n# Approach\\n-  First store the \\'chars\\' characters and it\\'s position in a map. \\n-  Calculate cost. 2 Possibilites:\\n-> \\'s\\' character is in \\'chars\\' then cost = vals[chars_map[ s[i] ] - 1]\\n-> \\'s\\' characters is **not** in \\'chars\\' then cost = s[i] - \\'a\\' + 1\\n- To find the maximum cost in subarrays of \\'cost_array\\' we use kadane\\'s algorithm.\\n\\n\\n# Complexity # \\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> chars_map;\\n        for(int i=0; i<chars.size(); i++){\\n            chars_map[chars[i]] = i+1;\\n        } // Entering chars characters and its index in a map\\n\\n        vector<int> cost(s.size());\\n        for(int i=0; i<s.size(); i++){\\n            if(chars_map[s[i]] > 0){\\n                cost[i] = vals[chars_map[s[i]]-1];\\n            }\\n            else cost[i] = s[i] - \\'a\\' + 1;\\n        } // calculating cost for each poisition in string s and storing it in vector.\\n\\n        int i=0, n=cost.size(), maxi = 0, temp_sum=0;\\n        while(i < n){\\n            temp_sum += cost[i];\\n            if(temp_sum < 0){\\n                temp_sum = 0;\\n            }\\n            else\\n                maxi = max(maxi, temp_sum);\\n            i++;\\n        } // Kadane\\'s Algorithm\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> chars_map;\\n        for(int i=0; i<chars.size(); i++){\\n            chars_map[chars[i]] = i+1;\\n        } // Entering chars characters and its index in a map\\n\\n        vector<int> cost(s.size());\\n        for(int i=0; i<s.size(); i++){\\n            if(chars_map[s[i]] > 0){\\n                cost[i] = vals[chars_map[s[i]]-1];\\n            }\\n            else cost[i] = s[i] - \\'a\\' + 1;\\n        } // calculating cost for each poisition in string s and storing it in vector.\\n\\n        int i=0, n=cost.size(), maxi = 0, temp_sum=0;\\n        while(i < n){\\n            temp_sum += cost[i];\\n            if(temp_sum < 0){\\n                temp_sum = 0;\\n            }\\n            else\\n                maxi = max(maxi, temp_sum);\\n            i++;\\n        } // Kadane\\'s Algorithm\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367666,
                "title": "java-beats-100",
                "content": "# Intuition\\nmap all the alphabets with there values and it become like maximum sub array problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character ,Integer> m=new HashMap<>();\\n        for(int i=0;i<26;i++){\\n            char x=(char) (97+i);\\n          m.put(x,chars.indexOf(x)!=-1 ? vals[chars.indexOf(x)] : i+1) ;\\n        }\\n        //now this is like maximum sub array problem\\n        int best=m.get(s.charAt(0));\\n        int sum=best;\\n        for(int i=1;i<s.length();i++){\\n            sum=Math.max(sum+m.get(s.charAt(i)),m.get(s.charAt(i)));\\n            best=Math.max(best,sum);\\n        }\\n        return best>0 ? best :0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character ,Integer> m=new HashMap<>();\\n        for(int i=0;i<26;i++){\\n            char x=(char) (97+i);\\n          m.put(x,chars.indexOf(x)!=-1 ? vals[chars.indexOf(x)] : i+1) ;\\n        }\\n        //now this is like maximum sub array problem\\n        int best=m.get(s.charAt(0));\\n        int sum=best;\\n        for(int i=1;i<s.length();i++){\\n            sum=Math.max(sum+m.get(s.charAt(i)),m.get(s.charAt(i)));\\n            best=Math.max(best,sum);\\n        }\\n        return best>0 ? best :0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367615,
                "title": "easy-code-simply-just-kaden-s-algo-used",
                "content": "\\n\\n# Approach\\nSimple kaden\\'s algorithm is being used.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n=s.size();\\n       \\n        //sara val store ho gaya maps me:\\n        unordered_map<char,int> m;\\n        for(int i=0;i<26;i++){\\n         m[97+i]=i+1;\\n            \\n       \\n        }\\n        for(int i=0;i<vals.size();i++){\\n          m[chars[i]]=vals[i];\\n           }\\n      // yha tk mee \\n       \\n         int ans=0;\\n      int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=m[s[i]];\\n            if(sum<0)\\n                sum=0;\\n            else if(sum>ans)  ans=sum;\\n        }\\n      \\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n=s.size();\\n       \\n        //sara val store ho gaya maps me:\\n        unordered_map<char,int> m;\\n        for(int i=0;i<26;i++){\\n         m[97+i]=i+1;\\n            \\n       \\n        }\\n        for(int i=0;i<vals.size();i++){\\n          m[chars[i]]=vals[i];\\n           }\\n      // yha tk mee \\n       \\n         int ans=0;\\n      int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=m[s[i]];\\n            if(sum<0)\\n                sum=0;\\n            else if(sum>ans)  ans=sum;\\n        }\\n      \\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367582,
                "title": "using-kadane-algo-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int maxSum(vector<int> nums) {\\n    int n = nums.size();\\n    int max_so_far = nums[0];\\n    int max_ending_here = nums[0];\\n    \\n    for (int i = 1; i < n; i++) {\\n        max_ending_here = max(max_ending_here + nums[i], nums[i]);\\n        max_so_far = max(max_so_far, max_ending_here);\\n    }\\n    \\n    return max_so_far;\\n}\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<int,int>m;\\n       for(int i=0;i<chars.size();i++){\\n           m[chars[i]]=vals[i];\\n       }\\n        int n=s.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            if(m.count(s[i])==0){\\n            v.push_back(s[i]-96);}\\n            else{\\n                v.push_back(m[s[i]]);\\n            }\\n            \\n        }\\n        int max_sum = maxSum(v);\\n        if(max_sum<0) return 0;\\n        return max_sum;\\n      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int maxSum(vector<int> nums) {\\n    int n = nums.size();\\n    int max_so_far = nums[0];\\n    int max_ending_here = nums[0];\\n    \\n    for (int i = 1; i < n; i++) {\\n        max_ending_here = max(max_ending_here + nums[i], nums[i]);\\n        max_so_far = max(max_so_far, max_ending_here);\\n    }\\n    \\n    return max_so_far;\\n}\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<int,int>m;\\n       for(int i=0;i<chars.size();i++){\\n           m[chars[i]]=vals[i];\\n       }\\n        int n=s.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            if(m.count(s[i])==0){\\n            v.push_back(s[i]-96);}\\n            else{\\n                v.push_back(m[s[i]]);\\n            }\\n            \\n        }\\n        int max_sum = maxSum(v);\\n        if(max_sum<0) return 0;\\n        return max_sum;\\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367075,
                "title": "kadane-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int kadanes(vector<int> &v,int n)\\n    {\\n        int ans = 0,t=0;\\n        for(int i=0; i<n; ++i){\\n            t += v[i];\\n            if(t < 0) t = 0;\\n            ans = max(ans,t);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> mp;\\n        int n=1;\\n        for(char c=\\'a\\'; c<=\\'z\\'; ++c){\\n            mp[c] = n++;\\n        }\\n        n=size(chars);\\n        for(int i=0; i<n; ++i){\\n            mp[chars[i]] = vals[i];\\n        }\\n        n = size(s);\\n        vector<int> v(n);\\n        for(int i=0; i<n; ++i){\\n            v[i] = mp[s[i]];\\n        }\\n        return kadanes(v,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int kadanes(vector<int> &v,int n)\\n    {\\n        int ans = 0,t=0;\\n        for(int i=0; i<n; ++i){\\n            t += v[i];\\n            if(t < 0) t = 0;\\n            ans = max(ans,t);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> mp;\\n        int n=1;\\n        for(char c=\\'a\\'; c<=\\'z\\'; ++c){\\n            mp[c] = n++;\\n        }\\n        n=size(chars);\\n        for(int i=0; i<n; ++i){\\n            mp[chars[i]] = vals[i];\\n        }\\n        n = size(s);\\n        vector<int> v(n);\\n        for(int i=0; i<n; ++i){\\n            v[i] = mp[s[i]];\\n        }\\n        return kadanes(v,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366887,
                "title": "form-an-array-from-given-string-apply-kadane-s-algo-explained",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\nIt is a variation of this question :\\n 53. Maximum Subarray\\n[https://leetcode.com/problems/maximum-subarray/description/]()\\n\\nFirst go through it\\'s solution here : \\n[https://leetcode.com/problems/maximum-subarray/solutions/3045580/kadane-s-algo-optimal-solution-intuition-explained/?orderBy=most_votes]()\\n\\n# Code\\n```\\nclass Solution {\\n//this is standard KADANE\\'s Algo\\n        int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currSum = 0,maxi = INT_MIN;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n               //step 1\\n               currSum += nums[i]; \\n               //step 2 -> update the max value so far\\n                maxi = max(maxi,currSum); \\n              //step 3 -> no need to carry negative sum in next iteration, because it will only reduce the sum\\n                if(currSum < 0)  \\n                   currSum = 0;  \\n        }\\n        return maxi;\\n    }\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> m;\\n        \\n        for(int i=0; i<chars.size(); i++)\\n            m[chars[i]] = vals[i];\\n        \\n        vector<int> temp;\\n        \\n        for(auto it : s)\\n        {\\n            if(m.find(it) != m.end()) //if chracter is present in map ( i.e. it was present in vals)\\n             temp.push_back(m[it]); //push value given in vector vals\\n            else\\n             temp.push_back(int(it - \\'a\\') + 1); //otherwise push its position relative to a\\n        }\\n\\n        //now, apply Standard KADANE\\'s Algo on vector temp to find max Sum\\n        int ans = maxSubArray(temp); \\n        //since, ans should at least be 0\\n        return (ans > 0) ? ans : 0;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n//this is standard KADANE\\'s Algo\\n        int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currSum = 0,maxi = INT_MIN;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n               //step 1\\n               currSum += nums[i]; \\n               //step 2 -> update the max value so far\\n                maxi = max(maxi,currSum); \\n              //step 3 -> no need to carry negative sum in next iteration, because it will only reduce the sum\\n                if(currSum < 0)  \\n                   currSum = 0;  \\n        }\\n        return maxi;\\n    }\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> m;\\n        \\n        for(int i=0; i<chars.size(); i++)\\n            m[chars[i]] = vals[i];\\n        \\n        vector<int> temp;\\n        \\n        for(auto it : s)\\n        {\\n            if(m.find(it) != m.end()) //if chracter is present in map ( i.e. it was present in vals)\\n             temp.push_back(m[it]); //push value given in vector vals\\n            else\\n             temp.push_back(int(it - \\'a\\') + 1); //otherwise push its position relative to a\\n        }\\n\\n        //now, apply Standard KADANE\\'s Algo on vector temp to find max Sum\\n        int ans = maxSubArray(temp); \\n        //since, ans should at least be 0\\n        return (ans > 0) ? ans : 0;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366841,
                "title": "easy-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is classical problem of kadane algorithm but I have used sliding window to solve this problem during contest \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Here I have store chars[] array character in map with its value in vals.\\n2.Then I used to sum the element and moved the point till negative sum.\\n3.Once I have found sum to negative, start i pointer from then end till i<=j && sum<=0 .\\n4.Then store the maximum obtained till now.\\n5.At the end if maxi is negative then return 0 else return the maxi.\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity: \\n   O(26)\\n\\nPlease vote me if it is helpful to you.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i=0,j=0;\\n        map<char,int> mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        int sum=0;\\n        int maxi=INT_MIN;\\n        while(j<s.size()){\\n            if(mp.find(s[j])!=mp.end()){\\n                sum+=mp[s[j]];\\n            }else{\\n                sum+=(s[j]-\\'a\\' + 1);\\n            }\\n            while(i<=j && sum<=0){\\n                if(mp.find(s[i])!=mp.end()){\\n                sum-=mp[s[i]];\\n            }else{\\n                sum-=(s[i]-\\'a\\' + 1);\\n            }\\n                i++;\\n            }\\n            maxi=max(maxi,sum);\\n            j++;\\n        }\\n        if(maxi<0){\\n            return 0;\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i=0,j=0;\\n        map<char,int> mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3366813,
                "title": "simple-o-n-time-o-1-space-solution-nice-application-of-kadane-s-algorithm",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> allvals(26,0);\\n        for(int i=0;i<26;i++){\\n            allvals[i]=i+1;\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            allvals[chars[i]-97]=vals[i];\\n        }\\n        int maxans=0;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++){\\n            sum+=allvals[s[i]-97];\\n            maxans=max(maxans,sum);\\n            if(sum<0) sum=0;\\n        }\\n        return maxans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> allvals(26,0);\\n        for(int i=0;i<26;i++){\\n            allvals[i]=i+1;\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            allvals[chars[i]-97]=vals[i];\\n        }\\n        int maxans=0;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++){\\n            sum+=allvals[s[i]-97];\\n            maxans=max(maxans,sum);\\n            if(sum<0) sum=0;\\n        }\\n        return maxans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366730,
                "title": "simple-kadane-s-application",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        int res=INT_MIN;\\n        for(int i=0;i<chars.size();i++){\\n            m[chars[i]]=vals[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){\\n               \\n                if(ans+m[s[i]]>=0){\\n                        ans+=m[s[i]];\\n                      res=max(res,ans);\\n                }\\n                else{\\n                    ans=0;\\n                }\\n                    \\n            }\\n            else{\\n                ans+=s[i]-\\'a\\'+1;\\n                res=max(res,ans);\\n            }\\n        }\\n        if(res<0)return 0;\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        int res=INT_MIN;\\n        for(int i=0;i<chars.size();i++){\\n            m[chars[i]]=vals[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){\\n               \\n                if(ans+m[s[i]]>=0){\\n                        ans+=m[s[i]];\\n                      res=max(res,ans);\\n                }\\n                else{\\n                    ans=0;\\n                }\\n                    \\n            }\\n            else{\\n                ans+=s[i]-\\'a\\'+1;\\n                res=max(res,ans);\\n            }\\n        }\\n        if(res<0)return 0;\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366683,
                "title": "kadane-s-algorithm-c",
                "content": "\\n\\n# Approach\\nKadane\\'s Algorithm is used here\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        map<char,int> mp;\\n        \\n        for(int i=0; i<chars.size(); i++){\\n            mp[chars[i]]=i;\\n\\n        }\\n        \\n        int sum=0;\\n        int maxe=INT_MIN;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(mp.find(s[i])!=mp.end()){\\n                sum+=vals[mp[s[i]]];\\n            }\\n            else{\\n                sum+= s[i]-\\'a\\'+1;\\n            }\\n\\n            \\n            if(sum<0){\\n                sum=0;\\n            }\\n            maxe=max(maxe,sum);\\n        }\\n\\n        return maxe;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        map<char,int> mp;\\n        \\n        for(int i=0; i<chars.size(); i++){\\n            mp[chars[i]]=i;\\n\\n        }\\n        \\n        int sum=0;\\n        int maxe=INT_MIN;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(mp.find(s[i])!=mp.end()){\\n                sum+=vals[mp[s[i]]];\\n            }\\n            else{\\n                sum+= s[i]-\\'a\\'+1;\\n            }\\n\\n            \\n            if(sum<0){\\n                sum=0;\\n            }\\n            maxe=max(maxe,sum);\\n        }\\n\\n        return maxe;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366619,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        nums = []\\n        c = {i: idx for idx, i in enumerate(chars)}\\n        \\n        for i in s:\\n            if i in c:\\n                nums.append(vals[c[i]])\\n            else:\\n                nums.append(ord(i) - ord(\\'a\\') + 1)\\n        \\n        res =0\\n        total = 0\\n        \\n        for i in nums:\\n            total += i\\n            res = max(res, total)\\n            \\n            if total < 0:\\n                total = 0\\n                \\n        return res           \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        nums = []\\n        c = {i: idx for idx, i in enumerate(chars)}\\n        \\n        for i in s:\\n            if i in c:\\n                nums.append(vals[c[i]])\\n            else:\\n                nums.append(ord(i) - ord(\\'a\\') + 1)\\n        \\n        res =0\\n        total = 0\\n        \\n        for i in nums:\\n            total += i\\n            res = max(res, total)\\n            \\n            if total < 0:\\n                total = 0\\n                \\n        return res           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366497,
                "title": "java-kadane-s-algo-easy-explanation-with-comments",
                "content": "So, basically the question is telling us to create the `cost` array & find the **maximum possible sum** of any subarray.\\nSo we apply **Kadane\\'s** Algorithm\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int[] nums = new int[n]; //Array used for detecting max cost\\n        char[] ch = s.toCharArray();\\n        \\n        //Creating the cost array\\n        for(int i=0;i<n;++i){\\n           int index = chars.indexOf(ch[i]);\\n            \\n           if(index == -1) nums[i] = (ch[i] - \\'a\\') + 1; //If that character is not present in \\'chars\\', use it\\'s order based value. \\n           //Eg: a-1, b-2, c-3....\\n            \\n           else nums[i] = vals[index]; //If that character is present in \\'chars\\', use it\\'s value from \\'vals\\' array\\n        }\\n        \\n        //Kadane\\'s Algorithm\\n        int currsum = 0, maxSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(currsum < 0) currsum=0; //If an element makes the cumulative sum \\'negative\\', don\\'t consider it\\n            \\n            currsum += nums[i]; //Add the current element into the cumulative sum\\n            maxSum = Math.max(maxSum, currsum); //Update maxSum\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int[] nums = new int[n]; //Array used for detecting max cost\\n        char[] ch = s.toCharArray();\\n        \\n        //Creating the cost array\\n        for(int i=0;i<n;++i){\\n           int index = chars.indexOf(ch[i]);\\n            \\n           if(index == -1) nums[i] = (ch[i] - \\'a\\') + 1; //If that character is not present in \\'chars\\', use it\\'s order based value. \\n           //Eg: a-1, b-2, c-3....\\n            \\n           else nums[i] = vals[index]; //If that character is present in \\'chars\\', use it\\'s value from \\'vals\\' array\\n        }\\n        \\n        //Kadane\\'s Algorithm\\n        int currsum = 0, maxSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(currsum < 0) currsum=0; //If an element makes the cumulative sum \\'negative\\', don\\'t consider it\\n            \\n            currsum += nums[i]; //Add the current element into the cumulative sum\\n            maxSum = Math.max(maxSum, currsum); //Update maxSum\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366493,
                "title": "kadane-algorithm-map-c",
                "content": "```\\n class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int ans =0;\\n        map<char,pair<int,int>>mp;\\n            for(int i=0; i<chars.size(); i++){\\n                mp[chars[i]].first++;\\n                mp[chars[i]].second = vals[i];\\n                \\n            }\\n        int temp=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(mp[s[i]].first==1){\\n                if(temp+mp[s[i]].second>0){\\n                    temp+=mp[s[i]].second;\\n                    ans = max(ans,temp);\\n\\n                }\\n                else{\\n                     \\n                    temp=0;\\n                }\\n                \\n            }\\n            else{\\n                if(temp+(s[i]-\\'a\\')+1>0){\\n                    temp+=(s[i]-\\'a\\'+1);\\n                    ans = max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int ans =0;\\n        map<char,pair<int,int>>mp;\\n            for(int i=0; i<chars.size(); i++){\\n                mp[chars[i]].first++;\\n                mp[chars[i]].second = vals[i];\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3366480,
                "title": "all-approaches-brute-to-optimized-kadane-s-algo",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force - Generate All substring -> O(N^2)\\nKadane Algo - O(N)\\n# Complexity\\n- Time complexity: `O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(26) ~ O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string &s, string &chars, vector<int>& vals) {\\n        \\n        vector<int>hash(26,INT_MAX);\\n        \\n        for(int i = 0; i<chars.size(); i++){\\n            hash[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        \\n        for(int i = 0; i<26; i++){\\n            if(hash[i]==INT_MAX) hash[i]=i+1;\\n        }\\n        \\n        int maxi = INT_MIN;\\n        //for(auto it:hash) cout<<it<<\" \";\\n        \\n        \\n        int temp = 0;\\n        for(int i = 0; i<s.size(); i++){\\n            temp+=hash[s[i]-\\'a\\'];\\n            if(temp>maxi) maxi = temp;\\n            if(temp<0) temp = 0;\\n        }\\n        \\n        // for(int i = 0; i<s.size(); i++){\\n        //     int temp = 0;\\n        //     for(int j = i; j<s.size(); j++){\\n        //         temp+=hash[s[j]-\\'a\\'];\\n        //         if(temp>maxi) maxi = temp;\\n        //     }\\n        // }\\n        return max(0,maxi);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string &s, string &chars, vector<int>& vals) {\\n        \\n        vector<int>hash(26,INT_MAX);\\n        \\n        for(int i = 0; i<chars.size(); i++){\\n            hash[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        \\n        for(int i = 0; i<26; i++){\\n            if(hash[i]==INT_MAX) hash[i]=i+1;\\n        }\\n        \\n        int maxi = INT_MIN;\\n        //for(auto it:hash) cout<<it<<\" \";\\n        \\n        \\n        int temp = 0;\\n        for(int i = 0; i<s.size(); i++){\\n            temp+=hash[s[i]-\\'a\\'];\\n            if(temp>maxi) maxi = temp;\\n            if(temp<0) temp = 0;\\n        }\\n        \\n        // for(int i = 0; i<s.size(); i++){\\n        //     int temp = 0;\\n        //     for(int j = i; j<s.size(); j++){\\n        //         temp+=hash[s[j]-\\'a\\'];\\n        //         if(temp>maxi) maxi = temp;\\n        //     }\\n        // }\\n        return max(0,maxi);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3366466,
                "title": "java-kadane-s-algo-o-n-solution",
                "content": "``` java []\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] a = new int[26];\\n        Arrays.fill(a,-1);\\n        int i=0;\\n        for(char ch:chars.toCharArray()){\\n            a[ch-\\'a\\']=i++;\\n        }\\n        int max=0, sum=0;\\n        for(char ch:s.toCharArray()){\\n            if(a[ch-\\'a\\']==-1){\\n                sum+=(ch-\\'a\\')+1;\\n            }\\n            else{\\n                sum+=vals[a[ch-\\'a\\']];\\n            }\\n            max=Math.max(max,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] a = new int[26];\\n        Arrays.fill(a,-1);\\n        int i=0;\\n        for(char ch:chars.toCharArray()){\\n            a[ch-\\'a\\']=i++;\\n        }\\n        int max=0, sum=0;\\n        for(char ch:s.toCharArray()){\\n            if(a[ch-\\'a\\']==-1){\\n                sum+=(ch-\\'a\\')+1;\\n            }\\n            else{\\n                sum+=vals[a[ch-\\'a\\']];\\n            }\\n            max=Math.max(max,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366416,
                "title": "find-the-substring-with-maximum-cost",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = s.length();\\n        unordered_map<char, int> char_values;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char_values[chars[i]] = vals[i];\\n        }\\n        int max_cost = 0;\\n        int curr_cost = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (char_values.find(s[i]) != char_values.end()) {\\n                curr_cost += char_values[s[i]];\\n            } else {\\n                curr_cost += (int)(s[i] - \\'a\\' + 1);\\n            }\\n            max_cost = max(max_cost, curr_cost);\\n            if (curr_cost < 0) {\\n                curr_cost = 0;\\n            }\\n        }\\n        return max_cost;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = s.length();\\n        unordered_map<char, int> char_values;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char_values[chars[i]] = vals[i];\\n        }\\n        int max_cost = 0;\\n        int curr_cost = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (char_values.find(s[i]) != char_values.end()) {\\n                curr_cost += char_values[s[i]];\\n            } else {\\n                curr_cost += (int)(s[i] - \\'a\\' + 1);\\n            }\\n            max_cost = max(max_cost, curr_cost);\\n            if (curr_cost < 0) {\\n                curr_cost = 0;\\n            }\\n        }\\n        return max_cost;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366410,
                "title": "c-dp-kadane-s-algorithms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> costs(26);\\n        for(int i = 0; i < 26; i++)costs[i] = i+1;\\n        \\n        for(int i = 0; i < size(vals); i++) {\\n            costs[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        \\n        int n = size(s), sum = 0, maxSum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            sum += costs[s[i] - \\'a\\'];\\n            \\n            if(sum < 0)sum = 0;\\n            maxSum = max(sum,maxSum);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> costs(26);\\n        for(int i = 0; i < 26; i++)costs[i] = i+1;\\n        \\n        for(int i = 0; i < size(vals); i++) {\\n            costs[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        \\n        int n = size(s), sum = 0, maxSum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            sum += costs[s[i] - \\'a\\'];\\n            \\n            if(sum < 0)sum = 0;\\n            maxSum = max(sum,maxSum);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366385,
                "title": "java-hashmap-kadane-s-algo-explained",
                "content": "### Approach explained using comments:\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        // Record the values of each letter in \\'s\\' \\n        Map<Character, Integer> map = new HashMap<>();\\n        // Go through \\'chars\\' and record values from \\'vals\\' array\\n        for (int i = 0; i < chars.length(); i++) {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        // Then for the characters that might be missing in \\'chars\\'\\n        // go through \\'s\\' and put its value (1-indexed as mentioned in the problem)\\n        // only if it\\'s not present in map (i.e. \\'chars\\')\\n        for (char c : s.toCharArray()) {\\n            if (!map.containsKey(c)) {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        \\n        // Now for a new array same length as of \\'s\\'\\n        // and put the values of each letter in \\'s\\' in the corresponding indices\\n        int[] arr = new int[s.length()];\\n        int idx = 0;\\n        for (char c : s.toCharArray()) {\\n            arr[idx++] = map.get(c);\\n        }\\n        \\n        // Maximum substring cost = Maximum subarray sum \\n        // Apply Kadane\\'s algo to get the maximum cost\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < arr.length; i++){\\n            sum += arr[i];\\n            if(sum > max) max = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n\\t\\t\\n        // In case max cost is negative, return 0\\n        return max < 0? 0 : max;\\n    }\\n}\\n```\\nLet $$n$$ be the length of string `s` and $$m$$ be the length of `chars`\\n##### Time complexity: $$O(m + 3.n)$$\\n##### Space complexity: $$O(m + n) + O(n)$$\\n---\\n\\n### We can also do it without creating the extra array, by directly applying Kadane\\'s algo on the string:\\n### Here is the solution:\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < chars.length(); i++) {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        for (char c : s.toCharArray()) {\\n            if (!map.containsKey(c)) {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        \\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (char c : s.toCharArray()){\\n            sum += map.get(c);\\n            if(sum > max) max = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n\\t\\t\\n        return Math.max(max, 0);\\n    }\\n}\\n```\\nLet $$n$$ be the length of string `s` and $$m$$ be the length of `chars`\\n##### Time complexity: $$O(m + 2.n)$$\\n##### Space complexity: $$O(m + n)$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        // Record the values of each letter in \\'s\\' \\n        Map<Character, Integer> map = new HashMap<>();\\n        // Go through \\'chars\\' and record values from \\'vals\\' array\\n        for (int i = 0; i < chars.length(); i++) {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        // Then for the characters that might be missing in \\'chars\\'\\n        // go through \\'s\\' and put its value (1-indexed as mentioned in the problem)\\n        // only if it\\'s not present in map (i.e. \\'chars\\')\\n        for (char c : s.toCharArray()) {\\n            if (!map.containsKey(c)) {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        \\n        // Now for a new array same length as of \\'s\\'\\n        // and put the values of each letter in \\'s\\' in the corresponding indices\\n        int[] arr = new int[s.length()];\\n        int idx = 0;\\n        for (char c : s.toCharArray()) {\\n            arr[idx++] = map.get(c);\\n        }\\n        \\n        // Maximum substring cost = Maximum subarray sum \\n        // Apply Kadane\\'s algo to get the maximum cost\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < arr.length; i++){\\n            sum += arr[i];\\n            if(sum > max) max = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n\\t\\t\\n        // In case max cost is negative, return 0\\n        return max < 0? 0 : max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < chars.length(); i++) {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        for (char c : s.toCharArray()) {\\n            if (!map.containsKey(c)) {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        \\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (char c : s.toCharArray()){\\n            sum += map.get(c);\\n            if(sum > max) max = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n\\t\\t\\n        return Math.max(max, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366375,
                "title": "c-map-use",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> mp;\\n        for(char a=\\'a\\';a<=\\'z\\';a++){\\n            mp[a] = a-\\'a\\'+1;\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        long long ans=0,sum=0;\\n        for(int i=0;i<s.size();i++){\\n            sum += mp[s[i]];\\n            if(ans<sum) ans = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> mp;\\n        for(char a=\\'a\\';a<=\\'z\\';a++){\\n            mp[a] = a-\\'a\\'+1;\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        long long ans=0,sum=0;\\n        for(int i=0;i<s.size();i++){\\n            sum += mp[s[i]];\\n            if(ans<sum) ans = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366357,
                "title": "python-dp-o-n-beats-100",
                "content": "```python\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        # convert string to array [1, -1000, 1, 1]\\n        cost = {c: v for c, v in zip(chars, vals)}\\n        arr = [cost.get(c, ord(c) - ord(\\'a\\') + 1) for c in s]\\n\\n        # linear search of largest value (DP)\\n        dp = [0]*len(arr)\\n        dp[0] = arr[0]\\n        for i in range(1, len(arr)):\\n            dp[i] = max(0, arr[i], dp[i - 1] + arr[i])\\n\\n        return max(0, max(dp))\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        # convert string to array [1, -1000, 1, 1]\\n        cost = {c: v for c, v in zip(chars, vals)}\\n        arr = [cost.get(c, ord(c) - ord(\\'a\\') + 1) for c in s]\\n\\n        # linear search of largest value (DP)\\n        dp = [0]*len(arr)\\n        dp[0] = arr[0]\\n        for i in range(1, len(arr)):\\n            dp[i] = max(0, arr[i], dp[i - 1] + arr[i])\\n\\n        return max(0, max(dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084018,
                "title": "c-unordered-map-kadane-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        //We can use kadanes algo here\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        int cs=0;\\n        int ms=0;\\n        for(int i=0;i<s.size();i++){\\n            int val;\\n            if(mp.count(s[i])){\\n                val=mp[s[i]];\\n            }\\n            else{\\n                val=((s[i]-\\'a\\')+1);\\n            }\\n\\n            if(cs>0){\\n                cs+=val;\\n            }\\n            else{\\n                cs=val;\\n            }\\n            if(cs>ms){\\n                ms=cs;\\n            }\\n        }\\n        return ms;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        //We can use kadanes algo here\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        int cs=0;\\n        int ms=0;\\n        for(int i=0;i<s.size();i++){\\n            int val;\\n            if(mp.count(s[i])){\\n                val=mp[s[i]];\\n            }\\n            else{\\n                val=((s[i]-\\'a\\')+1);\\n            }\\n\\n            if(cs>0){\\n                cs+=val;\\n            }\\n            else{\\n                cs=val;\\n            }\\n            if(cs>ms){\\n                ms=cs;\\n            }\\n        }\\n        return ms;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074178,
                "title": "sliding-window-o-n-solution-cpp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int>mymap;\\n        int cnt=1;\\n        char cur=\\'a\\';\\n        for(char chr:\"abcdefghijklmnopqrstuvwxyz\")\\n        {\\n            mymap[chr]=cnt;\\n            cnt++;\\n        }\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            mymap[chars[i]]=vals[i];\\n        }\\n        int left=0,right=0;\\n        int curmax=0;\\n        int runval=0;\\n        while(right<s.length() && left<s.length())\\n        {\\n            runval+=mymap[s[right]];\\n            if(runval<0)\\n            {\\n                runval=0;\\n                right++;\\n                left=right;\\n            }\\n            else\\n            {\\n                curmax=max(curmax,runval);\\n                right++;\\n            }\\n        }\\n       return curmax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int>mymap;\\n        int cnt=1;\\n        char cur=\\'a\\';\\n        for(char chr:\"abcdefghijklmnopqrstuvwxyz\")\\n        {\\n            mymap[chr]=cnt;\\n            cnt++;\\n        }\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            mymap[chars[i]]=vals[i];\\n        }\\n        int left=0,right=0;\\n        int curmax=0;\\n        int runval=0;\\n        while(right<s.length() && left<s.length())\\n        {\\n            runval+=mymap[s[right]];\\n            if(runval<0)\\n            {\\n                runval=0;\\n                right++;\\n                left=right;\\n            }\\n            else\\n            {\\n                curmax=max(curmax,runval);\\n                right++;\\n            }\\n        }\\n       return curmax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073854,
                "title": "just-max-subarray-sum-becomes-string-with-a-hashmap-java-solution",
                "content": "*I am a beginner in java, but the code below is just basically kadane + hashmap*\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> hmap = new HashMap<>();\\n        \\n        for(int i=0;i<chars.length();i++){\\n            char c = chars.charAt(i);\\n            hmap.put(c,vals[i]);\\n        };\\n        // max subarray sum problem \\n        int prev = 0;\\n        int res = 0;\\n        int val = 0;\\n        for(int i = 0; i<s.length();i++){\\n            char c = s.charAt(i);\\n            val = c-\\'a\\' + 1;\\n            if(hmap.containsKey(c)){\\n                val = hmap.get(c);\\n            }\\n            prev = Math.max(prev+val,val);\\n            res = Math.max(res,prev);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> hmap = new HashMap<>();\\n        \\n        for(int i=0;i<chars.length();i++){\\n            char c = chars.charAt(i);\\n            hmap.put(c,vals[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4044910,
                "title": "short-code-linear-time-constant-time-simple-kadane-s-algorithm",
                "content": "# Intuition\\nKadane\\'s Algorithm - Find maximum subarray sum with both positive and negative numbers. Just replace characters in **string s** with their values from vals or their respective values (\\'a\\' as 1, \\'b\\' as 2 .... and so on).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int m[26];\\n        for(int i=0;i<26;i++) m[i]=i+1;\\n        for(int i=0;i<chars.length();i++) m[chars[i]-\\'a\\']=vals[i];\\n        int res=0;\\n        int tmp=0;\\n        for(int i=0;i<s.length();i++){\\n            tmp+=m[s[i]-\\'a\\'];\\n            if(tmp>res) res=tmp;\\n            if(tmp<0) tmp=0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int m[26];\\n        for(int i=0;i<26;i++) m[i]=i+1;\\n        for(int i=0;i<chars.length();i++) m[chars[i]-\\'a\\']=vals[i];\\n        int res=0;\\n        int tmp=0;\\n        for(int i=0;i<s.length();i++){\\n            tmp+=m[s[i]-\\'a\\'];\\n            if(tmp>res) res=tmp;\\n            if(tmp<0) tmp=0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042421,
                "title": "java-100-faster",
                "content": "# Intuition\\nWe can discard negative sums because the empty substring has value 0.\\n\\n# Approach\\nBuild a map array with values for all characters. Initialize an array with values for all characters in the input string. Iterate through the array and keep track of the residual sum and the maximum sum. If the reidual sum becomes negative, reset it to 0. Return the maximum sum.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int maximumCostSubstring(String s, String chars, int[] vals)\\n    {\\n        int [] c = new int[26];\\n\\n        for(int i=0; i<26; i++)\\n            c[i] = i + 1;\\n\\n        for(int i=0; i<vals.length; i++)\\n            c[chars.charAt(i)-\\'a\\'] = vals[i];\\n\\n        if(s.length()==1)\\n            return Math.max(0,c[s.charAt(0)-\\'a\\']);\\n\\n        int l = s.length();\\n        int [] h = new int[l];\\n        int m = 0;\\n\\n        for(int i=0; i<l; i++)\\n            h[i] = c[s.charAt(i)-\\'a\\'];\\n\\n        for(int i=0, r=0; i<l; i++)\\n        {\\n            r += h[i];\\n            m = Math.max(m,r);\\n            r = Math.max(0,r);\\n        }\\n\\n        return Math.max(0,m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maximumCostSubstring(String s, String chars, int[] vals)\\n    {\\n        int [] c = new int[26];\\n\\n        for(int i=0; i<26; i++)\\n            c[i] = i + 1;\\n\\n        for(int i=0; i<vals.length; i++)\\n            c[chars.charAt(i)-\\'a\\'] = vals[i];\\n\\n        if(s.length()==1)\\n            return Math.max(0,c[s.charAt(0)-\\'a\\']);\\n\\n        int l = s.length();\\n        int [] h = new int[l];\\n        int m = 0;\\n\\n        for(int i=0; i<l; i++)\\n            h[i] = c[s.charAt(i)-\\'a\\'];\\n\\n        for(int i=0, r=0; i<l; i++)\\n        {\\n            r += h[i];\\n            m = Math.max(m,r);\\n            r = Math.max(0,r);\\n        }\\n\\n        return Math.max(0,m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026664,
                "title": "python-clean-kadane-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        \\n        character_values = defaultdict(int)\\n        idx = 1\\n\\n        for ch in ascii_lowercase:\\n            if ch in chars:\\n                character_values[ch] = vals[chars.index(ch)]\\n            else:\\n                character_values[ch] = idx\\n            idx += 1\\n        \\n        mx = -inf\\n        running_sum = 0\\n        for ch in s:\\n            if running_sum < 0:\\n                running_sum = 0\\n            running_sum += character_values[ch]\\n            mx = max(mx,running_sum)\\n        \\n        return max(mx,0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        \\n        character_values = defaultdict(int)\\n        idx = 1\\n\\n        for ch in ascii_lowercase:\\n            if ch in chars:\\n                character_values[ch] = vals[chars.index(ch)]\\n            else:\\n                character_values[ch] = idx\\n            idx += 1\\n        \\n        mx = -inf\\n        running_sum = 0\\n        for ch in s:\\n            if running_sum < 0:\\n                running_sum = 0\\n            running_sum += character_values[ch]\\n            mx = max(mx,running_sum)\\n        \\n        return max(mx,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010693,
                "title": "find-the-substring-with-maximum-cost",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        p = \"abcdefghijklmnopqrstuvwxyz\"\\n        d = {}\\n        l = []\\n        for i in range(len(p)):\\n            d[p[i]] = i+1\\n        for i,j in zip(chars,vals):\\n            d[i] = j\\n        count = 0\\n        res =0\\n        for i in range(len(s)):\\n            count+= d[s[i]]\\n            if count > 0:\\n                res = max(res,count)\\n            else:\\n                count = 0\\n        return res\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        p = \"abcdefghijklmnopqrstuvwxyz\"\\n        d = {}\\n        l = []\\n        for i in range(len(p)):\\n            d[p[i]] = i+1\\n        for i,j in zip(chars,vals):\\n            d[i] = j\\n        count = 0\\n        res =0\\n        for i in range(len(s)):\\n            count+= d[s[i]]\\n            if count > 0:\\n                res = max(res,count)\\n            else:\\n                count = 0\\n        return res\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981737,
                "title": "ruby-o-n",
                "content": "```ruby\\n# @param {String} s\\n# @param {String} chars\\n# @param {Integer[]} vals\\n# @return {Integer}\\ndef maximum_cost_substring(s, chars, vals)\\n  val_by_char = {}\\n  chars.chars.each_with_index { | char, idx |\\n    val_by_char[char] = vals[idx]\\n  }\\n  res, cur = 0, 0\\n  s.each_char { | char |\\n    cur = [cur + (val_by_char.has_key?(char) ? val_by_char[char] : char.ord - \"a\".ord + 1), 0].max\\n    res = [res, cur].max\\n  }\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {String} s\\n# @param {String} chars\\n# @param {Integer[]} vals\\n# @return {Integer}\\ndef maximum_cost_substring(s, chars, vals)\\n  val_by_char = {}\\n  chars.chars.each_with_index { | char, idx |\\n    val_by_char[char] = vals[idx]\\n  }\\n  res, cur = 0, 0\\n  s.each_char { | char |\\n    cur = [cur + (val_by_char.has_key?(char) ? val_by_char[char] : char.ord - \"a\".ord + 1), 0].max\\n    res = [res, cur].max\\n  }\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3981381,
                "title": "solution-with-comments-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsed a map to store the character and their values given in the vals array.\\n\\nNow Kadane\\'s Algorithm says\\nKeep on adding the continuous value till the time we don\\'t get a negative sum, parallely compare it with max_val.\\nIf sum becomes negative then this couldn\\'t be our ans so make sum=0 again hunt for max sum in remaining part of array.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\no(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// Kadane\\'s Algorithm\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n\\n        unordered_map<char,int> mp;\\n        //Store values of all char present in string chars\\n        for(int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=vals[i];\\n        }\\n        // For character which are not present in string chars can be computed as \\n        // val=\\'a\\'- 96  since ascii value of \\'a\\' is 97\\n\\n        int sum=0,max_sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            // If char is not present in map then calculate val using ascii \\n            if(mp.find(s[i])==mp.end())\\n            {\\n                sum+=(s[i]-96);\\n            }\\n            //IF val is present for char then take that value\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                sum+=mp[s[i]];\\n            }\\n            if(sum>max_sum) max_sum=sum;\\n            //Whenever we get negative sum for any contagious memory we will \\n            // discard it bcz max value will always be >= 0\\n            if(sum<0) sum=0;\\n\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// Kadane\\'s Algorithm\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n\\n        unordered_map<char,int> mp;\\n        //Store values of all char present in string chars\\n        for(int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=vals[i];\\n        }\\n        // For character which are not present in string chars can be computed as \\n        // val=\\'a\\'- 96  since ascii value of \\'a\\' is 97\\n\\n        int sum=0,max_sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            // If char is not present in map then calculate val using ascii \\n            if(mp.find(s[i])==mp.end())\\n            {\\n                sum+=(s[i]-96);\\n            }\\n            //IF val is present for char then take that value\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                sum+=mp[s[i]];\\n            }\\n            if(sum>max_sum) max_sum=sum;\\n            //Whenever we get negative sum for any contagious memory we will \\n            // discard it bcz max value will always be >= 0\\n            if(sum<0) sum=0;\\n\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957260,
                "title": "umap-running-sum",
                "content": "**time: `O(N)`; space: `O(C)`**\\n```\\nint maximumCostSubstring(string s, string c, vector<int>& v)\\n{\\n\\tunordered_map<int,int> um;    \\n\\tfor(int i{}; i<size(c); ++i)\\n\\t\\tum[c[i]] = v[i];\\n\\n\\tint out{};        \\n\\tfor(int i{}, t{}, m{}; i<size(s); ++i)\\n\\t{\\n\\t\\tt += um.count(s[i]) ? um[s[i]] : s[i]-\\'a\\'+1;\\n\\t\\tm = min(m, t);\\n\\t\\tout = max(out, t-m);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumCostSubstring(string s, string c, vector<int>& v)\\n{\\n\\tunordered_map<int,int> um;    \\n\\tfor(int i{}; i<size(c); ++i)\\n\\t\\tum[c[i]] = v[i];\\n\\n\\tint out{};        \\n\\tfor(int i{}, t{}, m{}; i<size(s); ++i)\\n\\t{\\n\\t\\tt += um.count(s[i]) ? um[s[i]] : s[i]-\\'a\\'+1;\\n\\t\\tm = min(m, t);\\n\\t\\tout = max(out, t-m);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944558,
                "title": "go-maximum-cost-substring-in-9ms-and-6-4mb-memory-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis approach drew inspiration from Algorithm casts on YouTube, where it was initially solved in Python, resulting in an execution time of 170ms and memory usage of 17MB. Applying the same concept in Go yielded a slightly quicker performance outcome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code defines a function maximumCostSubstring that calculates the maximum cost substring based on given characters and values. It initializes an array values with indices 1 to 26. Then, it updates these values according to provided characters and corresponding values. The code employs Kandane\\'s Algorithm to find the maximum contiguous sum of values in the string s. It iterates through the string, updating maxSumEndingHere as it adds values corresponding to characters. If maxSumEndingHere becomes negative, it resets to 0. The final result is stored in maxSumSoFar, representing the maximum cost substring. The function returns this maximum cost.\\n\\n# Complexity\\n- Time complexity: O(n + m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nInitializing values array: This takes constant time O(26) or simply O(1), as the array length is constant.\\nLoop to update values array: This loop iterates through the characters in the chars string and updates the values array. Since there are n characters in the chars string, this loop has a time complexity of O(n).\\nKandane\\'s Algorithm loop: This loop iterates through the characters in the s string. Since there are m characters in the s string, this loop has a time complexity of O(m).\\nCombining these complexities, the overall time complexity of the function is O(1) + O(n) + O(m), which simplifies to O(n + m), where n is the length of the chars string and m is the length of the s string.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nvalues array: This array has a constant length of 26, regardless of the input size. Thus, the space complexity of this array is O(26), which simplifies to O(1).\\n\\nInteger variables: The algorithm uses a few integer variables to store indices, sums, and maximum values. These variables occupy a constant amount of memory, so their space complexity is O(1).\\n\\nOverall, the space complexity of the algorithm is dominated by the values array and the integer variables, both of which have constant space requirements. Therefore, the space complexity of the entire algorithm is O(1).\\n\\n# Code\\n```\\nfunc maximumCostSubstring(s string, chars string, vals []int) int {\\n    //  initializes the values slice and The loop sets values from 1 to 26 for each index\\n    values := make([]int, 26)\\n\\n    // The loop sets values from 1 to 26 for each index\\n    for i := range values {\\n        values[i] = i + 1\\n    }\\n\\n    // This loop updates the values in the values slice based on the characters provided in the chars string and the corresponding values in the vals slice\\n    for i := 0; i < len(chars); i++ {\\n        values[chars[i] - \\'a\\'] = vals[i]\\n    }\\n\\n    // Using Kandane\\'s Algorithm\\n    maxSumEndingHere, maxSumSoFar := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        maxSumEndingHere += values[s[i]-\\'a\\']\\n        if (maxSumEndingHere < 0) {\\n            maxSumEndingHere = 0\\n        }\\n\\n        if (maxSumEndingHere > maxSumSoFar) {\\n            maxSumSoFar = maxSumEndingHere\\n        }\\n    }\\n\\n    return maxSumSoFar\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumCostSubstring(s string, chars string, vals []int) int {\\n    //  initializes the values slice and The loop sets values from 1 to 26 for each index\\n    values := make([]int, 26)\\n\\n    // The loop sets values from 1 to 26 for each index\\n    for i := range values {\\n        values[i] = i + 1\\n    }\\n\\n    // This loop updates the values in the values slice based on the characters provided in the chars string and the corresponding values in the vals slice\\n    for i := 0; i < len(chars); i++ {\\n        values[chars[i] - \\'a\\'] = vals[i]\\n    }\\n\\n    // Using Kandane\\'s Algorithm\\n    maxSumEndingHere, maxSumSoFar := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        maxSumEndingHere += values[s[i]-\\'a\\']\\n        if (maxSumEndingHere < 0) {\\n            maxSumEndingHere = 0\\n        }\\n\\n        if (maxSumEndingHere > maxSumSoFar) {\\n            maxSumSoFar = maxSumEndingHere\\n        }\\n    }\\n\\n    return maxSumSoFar\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925065,
                "title": "python-solution-mapping-and-kadane-s-algorithm",
                "content": "# Intuition\\nThe code essentially aims to find the contiguous substring within the input string s that has the maximum sum of associated values based on the provided character-value associations.\\n\\n# Approach\\nThe approach involves iterating through the input string s, maintaining a running sum of values (current_sum), and updating the maximum sum encountered (max_sum). This dynamic programming-like approach allows the code to consider both extending the current substring and starting a new substring at each character.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(n), where n is the length of the input string s. This is because the code iterates through the string once and performs constant-time operations (dictionary lookups, comparisons, and arithmetic) at each step.\\n\\n- Space complexity:\\nThe space complexity is O(1) since the additional space used (for variables like mapping, max_sum, and current_sum) remains constant regardless of the input size. The dictionary mapping takes a fixed amount of space, and the other variables used in the algorithm are not related to the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        mapping = dict(zip(string.ascii_lowercase, range(1,27)))\\n        for i in range(len(vals)):\\n            mapping[chars[i]] = vals[i]\\n\\n        max_sum = 0;\\n        current_sum = 0;\\n        for i in range(len(s)):\\n            current_sum = max(mapping[s[i]], current_sum + mapping[s[i]]);\\n            max_sum = max(max_sum, current_sum);\\n        return max_sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        mapping = dict(zip(string.ascii_lowercase, range(1,27)))\\n        for i in range(len(vals)):\\n            mapping[chars[i]] = vals[i]\\n\\n        max_sum = 0;\\n        current_sum = 0;\\n        for i in range(len(s)):\\n            current_sum = max(mapping[s[i]], current_sum + mapping[s[i]]);\\n            max_sum = max(max_sum, current_sum);\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912619,
                "title": "c-easy-clean-code-dp",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t(int i,string &s,map<char,int> &p,vector<int> &dp)\\n    {\\n        if(i>=s.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n\\n        int sum=0;\\n        if(p.count(s[i]))\\n        sum=p[s[i]];\\n        else\\n        sum=s[i]-\\'a\\'+1;\\n\\n        return dp[i]=max(sum,sum+t(i+1,s,p,dp));\\n    }\\n    int maximumCostSubstring(string s, string c, vector<int>& v) {\\n        map<char,int> p;\\n        for(int i=0;i<c.size();i++)\\n        p[c[i]]=v[i];\\n\\n        vector<int> dp(s.size(),-1);\\n        int l=0;\\n        for(int i=0;i<s.size();i++)\\n        l=max(l,t(i,s,p,dp));\\n\\n        return l;\\n    }\\n};\\n```\\n\\n![cat.png](https://assets.leetcode.com/users/images/a1575ec3-e2c0-4e34-af48-6ca6e850cf11_1692091688.0080094.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t(int i,string &s,map<char,int> &p,vector<int> &dp)\\n    {\\n        if(i>=s.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n\\n        int sum=0;\\n        if(p.count(s[i]))\\n        sum=p[s[i]];\\n        else\\n        sum=s[i]-\\'a\\'+1;\\n\\n        return dp[i]=max(sum,sum+t(i+1,s,p,dp));\\n    }\\n    int maximumCostSubstring(string s, string c, vector<int>& v) {\\n        map<char,int> p;\\n        for(int i=0;i<c.size();i++)\\n        p[c[i]]=v[i];\\n\\n        vector<int> dp(s.size(),-1);\\n        int l=0;\\n        for(int i=0;i<s.size();i++)\\n        l=max(l,t(i,s,p,dp));\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883110,
                "title": "easy-beats-90-using-kadane-s-algorithm-and-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n        for(int i = 0; i<chars.length(); i++) mp[chars[i]] = vals[i];\\n        int mx = 0;\\n        int sum = 0;\\n        for(int i = 0; i<s.length(); i++){\\n            if(mp.find(s[i])!=mp.end()) sum += mp[s[i]];\\n            else sum+= s[i] - \\'a\\' + 1;\\n            if(sum<0) sum = 0;\\n            mx = max(mx, sum);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n        for(int i = 0; i<chars.length(); i++) mp[chars[i]] = vals[i];\\n        int mx = 0;\\n        int sum = 0;\\n        for(int i = 0; i<s.length(); i++){\\n            if(mp.find(s[i])!=mp.end()) sum += mp[s[i]];\\n            else sum+= s[i] - \\'a\\' + 1;\\n            if(sum<0) sum = 0;\\n            mx = max(mx, sum);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882529,
                "title": "python-simple-intuitive-solution-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {a:i+1 for i, a in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\\n        for i, c in enumerate(chars):\\n            d[c] = vals[i]\\n\\n        cur_max = 0\\n        cur_val = 0\\n        for c in s:\\n            x = d[c]\\n            cur_val += x\\n            if cur_val < 0:\\n                cur_val = 0\\n                continue\\n            if cur_val > cur_max:\\n                cur_max = cur_val\\n        return cur_max\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {a:i+1 for i, a in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\\n        for i, c in enumerate(chars):\\n            d[c] = vals[i]\\n\\n        cur_max = 0\\n        cur_val = 0\\n        for c in s:\\n            x = d[c]\\n            cur_val += x\\n            if cur_val < 0:\\n                cur_val = 0\\n                continue\\n            if cur_val > cur_max:\\n                cur_max = cur_val\\n        return cur_max\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842022,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int ans=0;\\n        map<char,int>mp;\\n        for (int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=i;\\n        }\\n        int cur=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (mp.count(s[i]))\\n            {\\n                int ind=mp[s[i]];\\n                cur+=vals[ind];\\n            }\\n            else cur+=(s[i]-\\'a\\'+1);\\n            if (cur>ans) ans=cur;\\n            if (cur<0) cur=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int ans=0;\\n        map<char,int>mp;\\n        for (int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=i;\\n        }\\n        int cur=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (mp.count(s[i]))\\n            {\\n                int ind=mp[s[i]];\\n                cur+=vals[ind];\\n            }\\n            else cur+=(s[i]-\\'a\\'+1);\\n            if (cur>ans) ans=cur;\\n            if (cur<0) cur=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822819,
                "title": "easy-kadane-s-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> mp;\\n        for(int i=0; i<chars.size(); i++)\\n            mp[chars[i]]=vals[i];\\n        vector<int> values(s.length(), 0);\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n                values[i]=mp[s[i]];\\n            else\\n                values[i]=(s[i]-\\'a\\')+1;\\n        }\\n\\n        //finding max cost subarray\\n        int max_sum=0, curr_sum=0;\\n        for(int i=0; i<values.size(); i++)\\n        {\\n            curr_sum+=values[i];\\n            if(curr_sum<0)\\n                curr_sum=0;\\n            max_sum=max(max_sum, curr_sum);\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> mp;\\n        for(int i=0; i<chars.size(); i++)\\n            mp[chars[i]]=vals[i];\\n        vector<int> values(s.length(), 0);\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n                values[i]=mp[s[i]];\\n            else\\n                values[i]=(s[i]-\\'a\\')+1;\\n        }\\n\\n        //finding max cost subarray\\n        int max_sum=0, curr_sum=0;\\n        for(int i=0; i<values.size(); i++)\\n        {\\n            curr_sum+=values[i];\\n            if(curr_sum<0)\\n                curr_sum=0;\\n            max_sum=max(max_sum, curr_sum);\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822173,
                "title": "simple-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile reading the question you will get to know that this question is similar to Kadane algo question of Array where we had to return maxSumSoFar.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo as we did in kadanes algo, we will maintain curSum and MaxSum. Apart from that in this Particular case we need to store the value of characters which is predefined i.e if \\n``chars=[a,d,f]`` and `vals=[1,-25,9]` in unordered_map or any other data structure which ever u feel is better. I used map  because lookup was easy and `O(1)`.\\n\\nOnce our unordered map is ready we now have to traverse the string and check `if that particular element is present than add it to current` **or** `if not than we will extract 1 Indexed integeer value of char and add it to cur`.\\n\\nNow for some instance our `cur` would get less than `0` it means that this is not max because an **empty string** has value of `0` so we will cur with `0`.\\n\\nafter these all steps we will update our maxSum and return it.\\n\\n\\n# Complexity\\n- Time complexity:$$O(Max(N,M))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp.insert({chars[i],vals[i]});\\n        }\\n\\n        int cur=0,maxSum=0;\\n        for( auto c:s){\\n            if(mp.find(c)!=mp.end()){\\n                cur+=mp[c];\\n            }\\n            else {\\n                cur+=c-\\'a\\'+1;\\n            }\\n\\n            if(cur<0) cur=0;\\n\\n            maxSum=max(maxSum,cur);\\n        }\\n\\n        return maxSum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp.insert({chars[i],vals[i]});\\n        }\\n\\n        int cur=0,maxSum=0;\\n        for( auto c:s){\\n            if(mp.find(c)!=mp.end()){\\n                cur+=mp[c];\\n            }\\n            else {\\n                cur+=c-\\'a\\'+1;\\n            }\\n\\n            if(cur<0) cur=0;\\n\\n            maxSum=max(maxSum,cur);\\n        }\\n\\n        return maxSum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814672,
                "title": "solution-in-o-n-time-complexity-using-hashmap-and-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can first think to find all possible substrings which will take around O(N<sup>2</sup>) complexity.\\nBut we know if we have come across in the past that finding the maximum subarray sum there is an algorithm called Kadane\\'s Algorithm.\\nThis algorithm will reduce our time complexity to O(N).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will take help of hashmap so that we dont have to calculate the value of the previouly calculated character again.\\n2. Once our hash map is ready with the given values of characters, we can iterate across the given string array.\\n3. If the character from the string is missing, than we know that we just have to calculate the value of the missing character by the simple formula (character - \\'a\\' + 1).\\n4. Then we can store that value in the previous hashmap.\\n5. This value can be considered while calculating the maximimum sum with the help of Kadane\\'s Algorithm.\\n6. **Kadane\\'s Algorithm** - We just need to keep summing all the elements unless our sum becomes negative. When our sum becomes negative we just reset our sum to zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe need to loop through all the elements in the given string.\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nApproximately 26 hash items are required so it can considered as constant space.\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> umap;\\n        int maxi = 0;\\n        for(int i=0; i<chars.length(); i++) {\\n            umap[chars[i]] = vals[i];\\n        }\\n        int l = s.length();\\n        int sum = 0;\\n        for(int i=0; i<l; i++) {\\n            int x = 0;\\n            if(umap.find(s[i]) != umap.end()) {\\n                x = umap[s[i]];\\n            }\\n            else {\\n                x = s[i] - \\'a\\' + 1;\\n                umap[s[i]] = x;\\n            }\\n            sum = sum + x;\\n            if(sum<0) sum = 0;\\n            maxi = max(maxi, sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> umap;\\n        int maxi = 0;\\n        for(int i=0; i<chars.length(); i++) {\\n            umap[chars[i]] = vals[i];\\n        }\\n        int l = s.length();\\n        int sum = 0;\\n        for(int i=0; i<l; i++) {\\n            int x = 0;\\n            if(umap.find(s[i]) != umap.end()) {\\n                x = umap[s[i]];\\n            }\\n            else {\\n                x = s[i] - \\'a\\' + 1;\\n                umap[s[i]] = x;\\n            }\\n            sum = sum + x;\\n            if(sum<0) sum = 0;\\n            maxi = max(maxi, sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798047,
                "title": "python3-1d-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        dp = [0 for x in range(len(s)+1)]\\n        d = {}\\n        for x,y in zip(chars,vals):\\n            d[x] = y\\n        \\n        for idx,e in enumerate(s):\\n            if e in d.keys():\\n                dp[idx+1] = max(dp[idx]+d[e],d[e])\\n            else:\\n                dp[idx+1] = max(dp[idx]+ord(e)-96,ord(e)-96)\\n\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        dp = [0 for x in range(len(s)+1)]\\n        d = {}\\n        for x,y in zip(chars,vals):\\n            d[x] = y\\n        \\n        for idx,e in enumerate(s):\\n            if e in d.keys():\\n                dp[idx+1] = max(dp[idx]+d[e],d[e])\\n            else:\\n                dp[idx+1] = max(dp[idx]+ord(e)-96,ord(e)-96)\\n\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767869,
                "title": "maximum-cost-substring-calculation-with-character-mapping",
                "content": "### \"To the 21st-century adventures \\u2013 may they be epic, well-documented, and spark jealousy on social media!\"\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to find the maximum cost substring in string s based on the values assigned to characters in the pairs vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. .-->\\nThe code starts by creating the pairs vector, which maps characters \\'a\\' to \\'z\\' to their respective values. It then creates the use vector, which maps characters from the chars string to their assigned values from the vals vector. The use vector is sorted based on character values.\\n\\nNext, the code updates the values in the pairs vector based on the values in the use vector. It iterates over the pairs vector and matches characters with the corresponding character in the use vector. If a match is found, the value in the pairs vector is updated.\\n\\nFinally, the code iterates over the characters in string s and calculates the maximum cost substring by accumulating the values assigned to the characters. The max_till variable keeps track of the maximum value obtained so far, and the ans variable stores the maximum cost encountered.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe creation of the pairs vector takes O(26) or O(1) since it is of constant size. The sorting of the use vector takes O(m log m), where m is the length of the chars string. The iteration over string s takes O(n), where n is the length of string s. Therefore, the overall time complexity is O(m log m + n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(26) for the pairs vector, O(m) for the use vector, and O(1) for other variables. Hence, the overall space complexity is O(m).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<pair<char, int>> pairs;\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            pairs.emplace_back(c, c - \\'a\\' + 1);\\n        }\\n        vector<pair<char, int>> use;\\n        for(int i =0 ; i < chars.size() ; i++ ){\\n            use.emplace_back(chars[i], vals[i]);\\n        }\\n        sort(use.begin(), use.end());\\n        int index = 0;\\n        for (auto& pair : pairs) {\\n            if(index >= chars.size()) break;\\n            if (pair.first == use[index].first) {\\n                pair.second = use[index].second;\\n                index++;\\n            }\\n        }\\n        int ans = 0;\\n        int max_till = 0;\\n        for(int i = 0 ; i < s.size(); i++){\\n            max_till += pairs[s[i] - \\'a\\'].second;\\n            if(max_till < 0) max_till = 0;\\n\\n            ans = max(ans, max_till);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<pair<char, int>> pairs;\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            pairs.emplace_back(c, c - \\'a\\' + 1);\\n        }\\n        vector<pair<char, int>> use;\\n        for(int i =0 ; i < chars.size() ; i++ ){\\n            use.emplace_back(chars[i], vals[i]);\\n        }\\n        sort(use.begin(), use.end());\\n        int index = 0;\\n        for (auto& pair : pairs) {\\n            if(index >= chars.size()) break;\\n            if (pair.first == use[index].first) {\\n                pair.second = use[index].second;\\n                index++;\\n            }\\n        }\\n        int ans = 0;\\n        int max_till = 0;\\n        for(int i = 0 ; i < s.size(); i++){\\n            max_till += pairs[s[i] - \\'a\\'].second;\\n            if(max_till < 0) max_till = 0;\\n\\n            ans = max(ans, max_till);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765311,
                "title": "python3-simple-solution",
                "content": "# Code\\n```python\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        cost = [x for x in range(1, 27)]\\n        for i, c in enumerate(chars):\\n            cost[ord(c)-ord(\\'a\\')] = vals[i]\\n        maximum = 0\\n        current = 0\\n        for c in s:\\n            current += cost[ord(c)-ord(\\'a\\')]\\n            maximum = max(maximum, current)\\n            current = max(current, 0)\\n        return maximum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        cost = [x for x in range(1, 27)]\\n        for i, c in enumerate(chars):\\n            cost[ord(c)-ord(\\'a\\')] = vals[i]\\n        maximum = 0\\n        current = 0\\n        for c in s:\\n            current += cost[ord(c)-ord(\\'a\\')]\\n            maximum = max(maximum, current)\\n            current = max(current, 0)\\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755502,
                "title": "sliding-window-unordered-map-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        int c=1;\\n        int res=0;\\n        int j=0;\\n        int temp=0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++) m[i]=c++;\\n        for(int i=0;i<chars.size();i++) m[chars[i]]=vals[i];\\n        for(int i=0;i<s.size();i++){\\n            temp+=m[s[i]];\\n            while(temp<=0 and j<=i){\\n                temp-=m[s[j]];\\n                j++;\\n            }\\n            res=max(res,temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        int c=1;\\n        int res=0;\\n        int j=0;\\n        int temp=0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++) m[i]=c++;\\n        for(int i=0;i<chars.size();i++) m[chars[i]]=vals[i];\\n        for(int i=0;i<s.size();i++){\\n            temp+=m[s[i]];\\n            while(temp<=0 and j<=i){\\n                temp-=m[s[j]];\\n                j++;\\n            }\\n            res=max(res,temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737992,
                "title": "dynamic-programming-o-n-solution",
                "content": "# Intuition\\nUse dynamic programming for this\\n# Approach\\nCreate 1D table where t_i represents the max value for substring ending in s_i. Base cases is s_0 and s_1. for i in [2, n] the recurrence uses the maximum of either previous + current string or, simply the current string.\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nBeats 27%\\n- Space complexity:\\n$$O(n)$$\\nBeats 7%\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumCostSubstring(self, s, chars, vals):\\n        \"\"\"\\n        :type s: str\\n        :type chars: str\\n        :type vals: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        d = {x[1]: x[0] + 1 for x in enumerate(string.ascii_lowercase)}\\n \\n        for i in range(len(chars)):\\n            d[chars[i]] = vals[i]\\n\\n        n = len(s)\\n\\n        # DP - 1D table\\n        t = [0] * (n+1)\\n\\n        # Base cases\\n        t[0] = 0\\n        t[1] = d[s[0]]\\n\\n        # Recurrence\\n        for i in range(2, n+1):\\n            # max of previous and current or, just current\\n            t[i] = max(t[i-1] + d[s[i-1]], d[s[i-1]]) # Computers suck ! 0-indexes\\n\\n        # Return max of table\\n        return max(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumCostSubstring(self, s, chars, vals):\\n        \"\"\"\\n        :type s: str\\n        :type chars: str\\n        :type vals: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        d = {x[1]: x[0] + 1 for x in enumerate(string.ascii_lowercase)}\\n \\n        for i in range(len(chars)):\\n            d[chars[i]] = vals[i]\\n\\n        n = len(s)\\n\\n        # DP - 1D table\\n        t = [0] * (n+1)\\n\\n        # Base cases\\n        t[0] = 0\\n        t[1] = d[s[0]]\\n\\n        # Recurrence\\n        for i in range(2, n+1):\\n            # max of previous and current or, just current\\n            t[i] = max(t[i-1] + d[s[i-1]], d[s[i-1]]) # Computers suck ! 0-indexes\\n\\n        # Return max of table\\n        return max(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726228,
                "title": "java-recursive-memoization-kaden-s-algo-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nApproach one using recursive memoization (TLE)\\n\\n```\\nclass Solution {\\n\\n    Map<Character, Integer> charToCost;\\n    Integer[] memo;\\n\\n    int helper(String str, int[] vals, int index){\\n\\n        int n = str.length();\\n\\n        if(index >= n) return 0;\\n\\n        if(memo[index] != null) return memo[index];\\n\\n        int maxScore = 0;\\n        int currSum = 0;\\n\\n        for(int i = index; i < n; i++){\\n\\n            char ch = str.charAt(i);\\n            \\n            currSum += charToCost.getOrDefault(ch, ((ch - \\'a\\') + 1));\\n\\n            maxScore = Math.max(maxScore, Math.max(currSum, helper(str, vals, i + 1)));\\n        }\\n\\n        return memo[index] = maxScore;\\n    }\\n\\n    public int approachRecursiveMemoization(String s, String chars, int[] vals) {\\n        int n = s.length();\\n\\n        memo = new Integer[n + 1];\\n        \\n        charToCost = new HashMap<>();\\n        for(int i = 0; i < chars.length(); i++) charToCost.put(chars.charAt(i), vals[i]);\\n\\n        return helper(s, vals, 0);\\n    }\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        return approachRecursiveMemoization(s, chars, vals);\\n    }\\n}\\n```\\n\\nApproach two using kaden\\'s algo\\n\\n```\\nclass Solution {\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        int n = s.length();\\n\\n        int[] alphabetCost = new int[26];\\n\\n        //default cost for each char of alphabet (acc to question)\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n\\n            alphabetCost[ch - \\'a\\'] = ((ch - \\'a\\') + 1);\\n        }\\n\\n        //specific cost of i-th char from \\'chars\\' string is vals[i]\\n        for (int i = 0; i < chars.length(); i++) {\\n\\n            char chr = chars.charAt(i);\\n            int chrCost = vals[i];\\n\\n            alphabetCost[chr - \\'a\\'] = chrCost;\\n        }\\n\\n        //kaden\\'s algo\\n        int currCost = 0;\\n        //subarray cost can be negative, so keep the initial maxCost as\\n        //Int.MIN\\n        int maxCost = Integer.MIN_VALUE;\\n\\n        for(char ch : s.toCharArray()){\\n\\n            int cost = alphabetCost[ch - \\'a\\'];\\n\\n            currCost = Math.max(currCost + cost, cost);\\n            maxCost = Math.max(maxCost, currCost);\\n        }\\n\\n        //final maxCost to choose from the curr maxCost\\n        //or empty substring (\"\")\\n        //The cost of an empty string is considered 0\\n        //for cases like example 2\\n        return Math.max(maxCost, \"\".length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    Map<Character, Integer> charToCost;\\n    Integer[] memo;\\n\\n    int helper(String str, int[] vals, int index){\\n\\n        int n = str.length();\\n\\n        if(index >= n) return 0;\\n\\n        if(memo[index] != null) return memo[index];\\n\\n        int maxScore = 0;\\n        int currSum = 0;\\n\\n        for(int i = index; i < n; i++){\\n\\n            char ch = str.charAt(i);\\n            \\n            currSum += charToCost.getOrDefault(ch, ((ch - \\'a\\') + 1));\\n\\n            maxScore = Math.max(maxScore, Math.max(currSum, helper(str, vals, i + 1)));\\n        }\\n\\n        return memo[index] = maxScore;\\n    }\\n\\n    public int approachRecursiveMemoization(String s, String chars, int[] vals) {\\n        int n = s.length();\\n\\n        memo = new Integer[n + 1];\\n        \\n        charToCost = new HashMap<>();\\n        for(int i = 0; i < chars.length(); i++) charToCost.put(chars.charAt(i), vals[i]);\\n\\n        return helper(s, vals, 0);\\n    }\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        return approachRecursiveMemoization(s, chars, vals);\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        int n = s.length();\\n\\n        int[] alphabetCost = new int[26];\\n\\n        //default cost for each char of alphabet (acc to question)\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n\\n            alphabetCost[ch - \\'a\\'] = ((ch - \\'a\\') + 1);\\n        }\\n\\n        //specific cost of i-th char from \\'chars\\' string is vals[i]\\n        for (int i = 0; i < chars.length(); i++) {\\n\\n            char chr = chars.charAt(i);\\n            int chrCost = vals[i];\\n\\n            alphabetCost[chr - \\'a\\'] = chrCost;\\n        }\\n\\n        //kaden\\'s algo\\n        int currCost = 0;\\n        //subarray cost can be negative, so keep the initial maxCost as\\n        //Int.MIN\\n        int maxCost = Integer.MIN_VALUE;\\n\\n        for(char ch : s.toCharArray()){\\n\\n            int cost = alphabetCost[ch - \\'a\\'];\\n\\n            currCost = Math.max(currCost + cost, cost);\\n            maxCost = Math.max(maxCost, currCost);\\n        }\\n\\n        //final maxCost to choose from the curr maxCost\\n        //or empty substring (\"\")\\n        //The cost of an empty string is considered 0\\n        //for cases like example 2\\n        return Math.max(maxCost, \"\".length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710826,
                "title": "c-easy-solution",
                "content": "# Approach\\nKadane\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumCostSubstring(string s, string chars, int[] vals) {\\n        var map = new int[26];\\n        int local_max = 0, global_max = 0;\\n\\n        for(int idx = 1; idx <= 26; idx++)\\n            map[idx - 1] = idx;\\n\\n        for(int idx = 0; idx < chars.Length; idx++)\\n            map[chars[idx] - \\'a\\'] = vals[idx];\\n\\n        for(int idx = 0; idx < s.Length; idx++) {\\n            local_max += map[s[idx] - \\'a\\'];\\n            global_max = Math.Max(global_max, local_max);\\n            if(local_max < 0)\\n                local_max = 0;\\n        }\\n\\n        return global_max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumCostSubstring(string s, string chars, int[] vals) {\\n        var map = new int[26];\\n        int local_max = 0, global_max = 0;\\n\\n        for(int idx = 1; idx <= 26; idx++)\\n            map[idx - 1] = idx;\\n\\n        for(int idx = 0; idx < chars.Length; idx++)\\n            map[chars[idx] - \\'a\\'] = vals[idx];\\n\\n        for(int idx = 0; idx < s.Length; idx++) {\\n            local_max += map[s[idx] - \\'a\\'];\\n            global_max = Math.Max(global_max, local_max);\\n            if(local_max < 0)\\n                local_max = 0;\\n        }\\n\\n        return global_max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687497,
                "title": "python-dict",
                "content": "# Intuition\\nKadane\\'s algorithm:\\n1. maintains current cost of substr ending at i, cur\\n2. maintains max cost variable, res\\n3. iterate through the string and update above 2 variables\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        m = {k:v for k, v in zip(chars, vals)}\\n        res = cur = 0\\n        for c in s:\\n            cur += m.get(c, ord(c) - 96)\\n            if cur < 0:\\n                cur = 0\\n            res = max(res, cur)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        m = {k:v for k, v in zip(chars, vals)}\\n        res = cur = 0\\n        for c in s:\\n            cur += m.get(c, ord(c) - 96)\\n            if cur < 0:\\n                cur = 0\\n            res = max(res, cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685424,
                "title": "java-simple-explanation-with-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to the fact, that we have to find subarray with max sum, it`s obvious that we have to use Kadane\\u2019s Algorithm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe separate solution to two parts:\\n1)We have build array with cost values of elements from the s string. If val contains the element - we add it`s value, else we calculate the value using char value of the element.\\n2)We have to find a substring with the largest sum and return this sum. We use Kadane\\u2019s Algorithm to resolve thar. If the maximum sum is less than 0, we return 0, else we return the sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int [] costs = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cost=0;\\n            char ch = s.charAt(i);\\n            if(chars.indexOf(ch)==-1) cost=ch-96;\\n            else cost=vals[chars.indexOf(ch)];\\n            costs[i]=cost;\\n        }\\n        \\n        int max_so_far = Integer.MIN_VALUE;\\n        int max_ending_here =0;\\n\\n        for(int i=0;i<costs.length;i++){\\n            max_ending_here=max_ending_here+costs[i];\\n            if(max_so_far<max_ending_here)\\n                max_so_far=max_ending_here;\\n            if(max_ending_here<0)\\n                max_ending_here=0;\\n        }\\n        return Math.max(0,max_so_far);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int [] costs = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cost=0;\\n            char ch = s.charAt(i);\\n            if(chars.indexOf(ch)==-1) cost=ch-96;\\n            else cost=vals[chars.indexOf(ch)];\\n            costs[i]=cost;\\n        }\\n        \\n        int max_so_far = Integer.MIN_VALUE;\\n        int max_ending_here =0;\\n\\n        for(int i=0;i<costs.length;i++){\\n            max_ending_here=max_ending_here+costs[i];\\n            if(max_so_far<max_ending_here)\\n                max_so_far=max_ending_here;\\n            if(max_ending_here<0)\\n                max_ending_here=0;\\n        }\\n        return Math.max(0,max_so_far);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673492,
                "title": "kadanes-algorithm-o-n-simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n             int sum;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        if(mp.find(s[0])!=mp.end()){\\n            sum=mp[s[0]];\\n        }\\n        else{\\n            sum=(s[0]-\\'a\\')+1;\\n        }\\n        int maxsum=sum;\\n        for(int i=1;i<s.size();i++){\\n            int a=0;\\n            if(mp.find(s[i])!=mp.end()){\\n                a=mp[s[i]];\\n            }\\n            else{\\n                a=(s[i]-\\'a\\')+1;\\n            }\\n            sum=max(a,sum+a);\\n            if(sum>maxsum){\\n            maxsum=sum;\\n           }\\n        }\\n        \\n       if(maxsum<0){\\n           return 0;\\n       }\\n  return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n             int sum;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        if(mp.find(s[0])!=mp.end()){\\n            sum=mp[s[0]];\\n        }\\n        else{\\n            sum=(s[0]-\\'a\\')+1;\\n        }\\n        int maxsum=sum;\\n        for(int i=1;i<s.size();i++){\\n            int a=0;\\n            if(mp.find(s[i])!=mp.end()){\\n                a=mp[s[i]];\\n            }\\n            else{\\n                a=(s[i]-\\'a\\')+1;\\n            }\\n            sum=max(a,sum+a);\\n            if(sum>maxsum){\\n            maxsum=sum;\\n           }\\n        }\\n        \\n       if(maxsum<0){\\n           return 0;\\n       }\\n  return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657433,
                "title": "kadane-s-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>hash;\\n        for(int i=0;i<chars.length();i++)\\n        hash[chars[i]] = vals[i];\\n        int n = s.length();\\n        vector<int>nums(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash.find(s[i]) != hash.end())\\n            {\\n                nums[i] = hash[s[i]];\\n            }\\n            else\\n            nums[i] = s[i] - \\'a\\' + 1;\\n        }\\n        int currsum = 0;\\n        int maxsum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            currsum += nums[i];\\n            if(nums[i] > currsum)\\n            currsum = nums[i];\\n            maxsum = max(maxsum,currsum);\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>hash;\\n        for(int i=0;i<chars.length();i++)\\n        hash[chars[i]] = vals[i];\\n        int n = s.length();\\n        vector<int>nums(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash.find(s[i]) != hash.end())\\n            {\\n                nums[i] = hash[s[i]];\\n            }\\n            else\\n            nums[i] = s[i] - \\'a\\' + 1;\\n        }\\n        int currsum = 0;\\n        int maxsum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            currsum += nums[i];\\n            if(nums[i] > currsum)\\n            currsum = nums[i];\\n            maxsum = max(maxsum,currsum);\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627158,
                "title": "easy-o-n-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- tmp memorizes the cost of substring from nums[0] to nums[i]\\n- result memorizes the maximal cost of substring up to now\\n- tmp=max({v[s[i]-\\'a\\'],v[s[i]-\\'a\\']+tmp,0});\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for(int i=0;i<v.size();i++) v[i]=i+1;\\n        for(int i=0;i<chars.size();i++)\\n            v[chars[i]-\\'a\\']=vals[i];\\n        int tmp=0,result=0;\\n        for(int i=0;i<s.size();i++){\\n            tmp=max({v[s[i]-\\'a\\'],v[s[i]-\\'a\\']+tmp,0});\\n            result=max(tmp,result);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for(int i=0;i<v.size();i++) v[i]=i+1;\\n        for(int i=0;i<chars.size();i++)\\n            v[chars[i]-\\'a\\']=vals[i];\\n        int tmp=0,result=0;\\n        for(int i=0;i<s.size();i++){\\n            tmp=max({v[s[i]-\\'a\\'],v[s[i]-\\'a\\']+tmp,0});\\n            result=max(tmp,result);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609956,
                "title": "kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a new Array with mapped values from either vals[] if the current character is in chars or else use its Character Index. \\n\\nPerform Usual Kadane\\'s Algorithm in the next Step.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int len = s.length();\\n        int idx = 0;\\n        for(char c: chars.toCharArray())\\n            map.put(c, vals[idx++]);\\n\\n        int[] maxArr = new int[len];\\n\\n        for(int i = 0; i < len; i++)\\n        {\\n            int current = s.charAt(i) - 96;\\n            if(map.containsKey(s.charAt(i)))\\n                current = map.get(s.charAt(i));\\n            maxArr[i] = current;\\n        }\\n        \\n        int currentMax = maxArr[0];\\n        int max = maxArr[0];\\n\\n        for(int i = 1; i < len; i++)\\n        {\\n            currentMax = Math.max(maxArr[i], currentMax + maxArr[i]);\\n            max = Math.max(max, currentMax);\\n        }\\n\\n        return Math.max(max, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int len = s.length();\\n        int idx = 0;\\n        for(char c: chars.toCharArray())\\n            map.put(c, vals[idx++]);\\n\\n        int[] maxArr = new int[len];\\n\\n        for(int i = 0; i < len; i++)\\n        {\\n            int current = s.charAt(i) - 96;\\n            if(map.containsKey(s.charAt(i)))\\n                current = map.get(s.charAt(i));\\n            maxArr[i] = current;\\n        }\\n        \\n        int currentMax = maxArr[0];\\n        int max = maxArr[0];\\n\\n        for(int i = 1; i < len; i++)\\n        {\\n            currentMax = Math.max(maxArr[i], currentMax + maxArr[i]);\\n            max = Math.max(max, currentMax);\\n        }\\n\\n        return Math.max(max, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598084,
                "title": "easy-understanding-simple-logic-kadane-s-algo-clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string &s, string &chars, vector<int>& vals) {\\n        int n = s.size();\\n        \\n        int values[26] = {0};\\n        for(int i = 0; i < 26; ++i) {\\n            values[i] = i + 1;\\n        }\\n        \\n        int chsize = vals.size();\\n        for(int i = 0; i < chsize; ++i) {\\n            values[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        \\n        int cost = 0, curr_cost = 0;\\n        for(int i = 0; i < n; ++i) {\\n            curr_cost += values[s[i] - \\'a\\'];\\n            \\n            if(curr_cost < 0)\\n                curr_cost = 0;\\n            \\n            cost = max(cost, curr_cost);\\n        }\\n        \\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string &s, string &chars, vector<int>& vals) {\\n        int n = s.size();\\n        \\n        int values[26] = {0};\\n        for(int i = 0; i < 26; ++i) {\\n            values[i] = i + 1;\\n        }\\n        \\n        int chsize = vals.size();\\n        for(int i = 0; i < chsize; ++i) {\\n            values[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        \\n        int cost = 0, curr_cost = 0;\\n        for(int i = 0; i < n; ++i) {\\n            curr_cost += values[s[i] - \\'a\\'];\\n            \\n            if(curr_cost < 0)\\n                curr_cost = 0;\\n            \\n            cost = max(cost, curr_cost);\\n        }\\n        \\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584978,
                "title": "easy-kadane-s-algorithm-c-solution",
                "content": "\\n# Approach\\nKadane\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is the size of String s.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for(int i = 0;i<26;i++){\\n            v[i] = i+1;\\n        }\\n        for(int i = 0;i<chars.size();i++){\\n            v[chars[i]-\\'a\\'] =vals[i]; \\n        }\\n        vector<int> sd(s.size());\\n        for(int i = 0;i<s.size();i++){\\n            sd[i] = v[s[i]-\\'a\\'];\\n        }\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i = 0;i<sd.size();i++){\\n            sum+=sd[i];\\n            if(sum<0){\\n                sum = 0;\\n            }\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for(int i = 0;i<26;i++){\\n            v[i] = i+1;\\n        }\\n        for(int i = 0;i<chars.size();i++){\\n            v[chars[i]-\\'a\\'] =vals[i]; \\n        }\\n        vector<int> sd(s.size());\\n        for(int i = 0;i<s.size();i++){\\n            sd[i] = v[s[i]-\\'a\\'];\\n        }\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i = 0;i<sd.size();i++){\\n            sum+=sd[i];\\n            if(sum<0){\\n                sum = 0;\\n            }\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581173,
                "title": "java-simple-solution-hashmap-sum-90-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> lettersCost = new HashMap<>();\\n        for (int i = 0; i < 26; i++) {\\n            char letter = (char) (97 + i);\\n            int indexOfLetter = chars.indexOf(letter);\\n            if (indexOfLetter != -1) {\\n                lettersCost.put(letter, vals[indexOfLetter]);\\n            } else {\\n                lettersCost.put(letter, i + 1);\\n            }\\n        }\\n\\n        int maxCost = lettersCost.get(s.charAt(0));\\n        int currentSum = maxCost;\\n        for (int i = 1; i < s.length(); i++) {\\n            int currentCost = lettersCost.get(s.charAt(i));\\n            currentSum = Math.max(currentCost, currentSum + currentCost);\\n            maxCost = Math.max(maxCost, currentSum);\\n        }\\n        \\n        return Math.max(0, maxCost);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> lettersCost = new HashMap<>();\\n        for (int i = 0; i < 26; i++) {\\n            char letter = (char) (97 + i);\\n            int indexOfLetter = chars.indexOf(letter);\\n            if (indexOfLetter != -1) {\\n                lettersCost.put(letter, vals[indexOfLetter]);\\n            } else {\\n                lettersCost.put(letter, i + 1);\\n            }\\n        }\\n\\n        int maxCost = lettersCost.get(s.charAt(0));\\n        int currentSum = maxCost;\\n        for (int i = 1; i < s.length(); i++) {\\n            int currentCost = lettersCost.get(s.charAt(i));\\n            currentSum = Math.max(currentCost, currentSum + currentCost);\\n            maxCost = Math.max(maxCost, currentSum);\\n        }\\n        \\n        return Math.max(0, maxCost);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537906,
                "title": "kadane-s-algorithm-python-easy-solution-9-lines",
                "content": "# Intuition\\nThis is basically Kadane\\'s algorithm (subarray with the gratest value), but we have letters instead of numbers. We need to map those letters to their values.\\n\\n# Approach\\n- We create a dictionary with the letters and their values.\\n- Inside Kadane\\'s loop we need to calculate the value of the letter:\\n    - If the letter is in the dictionary, get the value from it.\\n    - Otherwise, get the position of the letter in the alphabet(`ord(c) - ord(\\'a\\') + 1`).\\n- Return the greatest value found.\\n\\n# Complexity\\n- Time complexity: $$O(s.length)$$\\n\\n- Space complexity: $$O(chars.length)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {}\\n        for c, v in zip(chars, vals):\\n            d[c] = v\\n\\n        # KADANES\\n        maxSum = currSum = 0\\n\\n        for c in s:\\n            val = d[c] if c in d else ord(c) - ord(\\'a\\') + 1\\n            currSum = max(currSum + val, 0)\\n            maxSum = max(maxSum, currSum)\\n\\n        return maxSum\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {}\\n        for c, v in zip(chars, vals):\\n            d[c] = v\\n\\n        # KADANES\\n        maxSum = currSum = 0\\n\\n        for c in s:\\n            val = d[c] if c in d else ord(c) - ord(\\'a\\') + 1\\n            currSum = max(currSum + val, 0)\\n            maxSum = max(maxSum, currSum)\\n\\n        return maxSum\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521386,
                "title": "elixir-solution-use-enum-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 428ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 82.3MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec maximum_cost_substring(s :: String.t, chars :: String.t, vals :: [integer]) :: integer\\n  def maximum_cost_substring(s, chars, vals) do\\n    char_dict = Enum.reduce(String.to_charlist(chars), {0, %{}}, fn ch, {i, dic} ->\\n      {i + 1, Map.put(dic, ch, Enum.at(vals, i))}\\n    end) |> elem(1)\\n\\n    String.to_charlist(s) |>\\n    Enum.reduce({0, 0}, fn ch, {max_cost, curr_cost} ->\\n      curr_cost = curr_cost + Map.get(char_dict, ch, ch - ?a + 1)\\n      curr_cost =\\n        if curr_cost < 0 do\\n          0\\n        else\\n          curr_cost\\n        end\\n      {max(curr_cost, max_cost), curr_cost}\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec maximum_cost_substring(s :: String.t, chars :: String.t, vals :: [integer]) :: integer\\n  def maximum_cost_substring(s, chars, vals) do\\n    char_dict = Enum.reduce(String.to_charlist(chars), {0, %{}}, fn ch, {i, dic} ->\\n      {i + 1, Map.put(dic, ch, Enum.at(vals, i))}\\n    end) |> elem(1)\\n\\n    String.to_charlist(s) |>\\n    Enum.reduce({0, 0}, fn ch, {max_cost, curr_cost} ->\\n      curr_cost = curr_cost + Map.get(char_dict, ch, ch - ?a + 1)\\n      curr_cost =\\n        if curr_cost < 0 do\\n          0\\n        else\\n          curr_cost\\n        end\\n      {max(curr_cost, max_cost), curr_cost}\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3519584,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0; i < chars.length(); i++)\\n        {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if(!map.containsKey(c))\\n            {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        int maxi = Integer.MIN_VALUE;\\n        int val = -(int)1e9;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char r = s.charAt(i);\\n            val = val + map.get(r);\\n            maxi = Math.max(maxi, Math.max(val, map.get(r)));\\n            if(map.get(r) > val)\\n            {\\n                val = map.get(r);\\n            }\\n        }\\n        \\n        return maxi < 0 ? 0 : maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0; i < chars.length(); i++)\\n        {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if(!map.containsKey(c))\\n            {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        int maxi = Integer.MIN_VALUE;\\n        int val = -(int)1e9;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char r = s.charAt(i);\\n            val = val + map.get(r);\\n            maxi = Math.max(maxi, Math.max(val, map.get(r)));\\n            if(map.get(r) > val)\\n            {\\n                val = map.get(r);\\n            }\\n        }\\n        \\n        return maxi < 0 ? 0 : maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515026,
                "title": "java-kadane-s-algo-variation-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private int getVal(char c, Map<Character, Integer> map) {\\n        if(map.containsKey(c)){\\n            return map.get(c);\\n        }\\n        else {\\n            return c - \\'a\\' + 1;\\n        }\\n    }\\n   public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int n = s.length();\\n        for(int i=0;i<chars.length();i++) {\\n            char c = chars.charAt(i);\\n            map.put(c, vals[i]);\\n        }\\n        int maxcosttillhere = 0, maxcosttillnow = 0;\\n        for(int i=0;i<n;i++) {\\n            char c = s.charAt(i);\\n            int val = getVal(c, map);\\n            maxcosttillhere += val;\\n            if( maxcosttillhere <= 0) {\\n                maxcosttillhere = 0;\\n            }\\n            else if(maxcosttillhere > maxcosttillnow) {\\n                maxcosttillnow = maxcosttillhere;\\n            }\\n        }\\n        return maxcosttillnow;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private int getVal(char c, Map<Character, Integer> map) {\\n        if(map.containsKey(c)){\\n            return map.get(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3511799,
                "title": "kadane-algo-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n        int score=0;\\n        int max=0;\\n        for(int i=0;i<chars.length();i++)\\n            map.put(chars.charAt(i),vals[i]);\\n        for(int i=0;i<s.length();i++)\\n        {\\n           \\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                score=score+ map.get(s.charAt(i));\\n                \\n                if(score<0){\\n               \\n                score=0;\\n                }\\n            }\\n            else \\n            score=score + s.charAt(i)-\\'a\\'+1; \\n              max= Math.max(score,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n        int score=0;\\n        int max=0;\\n        for(int i=0;i<chars.length();i++)\\n            map.put(chars.charAt(i),vals[i]);\\n        for(int i=0;i<s.length();i++)\\n        {\\n           \\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                score=score+ map.get(s.charAt(i));\\n                \\n                if(score<0){\\n               \\n                score=0;\\n                }\\n            }\\n            else \\n            score=score + s.charAt(i)-\\'a\\'+1; \\n              max= Math.max(score,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505187,
                "title": "best-java-sollution-kadane-s-hashmap",
                "content": "\\n```\\nclass Solution {\\n    //static int k =0;\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int ansarr[] = new int[n];\\n        \\n        HashMap<Character, Integer> hm  = new HashMap<>();\\n        for(int i =0; i<chars.length();i++)\\n        {\\n            hm.put(chars.charAt(i), vals[i]);\\n        }\\n        \\n        for(int j =0;j<n;j++)\\n        {\\n            if(hm.containsKey(s.charAt(j)))\\n            {\\n                ansarr[j] = hm.get(s.charAt(j));\\n            }\\n            \\n            else\\n            {\\n                ansarr[j] = s.charAt(j)-96;\\n            }\\n        }\\n       int locMax =0;\\n       int glbMax = Integer.MIN_VALUE;\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            locMax = Math.max(ansarr[k], locMax+ansarr[k]);\\n            glbMax = Math.max(locMax, glbMax);\\n        }\\n        \\n        return glbMax <0 ? 0:glbMax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //static int k =0;\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int ansarr[] = new int[n];\\n        \\n        HashMap<Character, Integer> hm  = new HashMap<>();\\n        for(int i =0; i<chars.length();i++)\\n        {\\n            hm.put(chars.charAt(i), vals[i]);\\n        }\\n        \\n        for(int j =0;j<n;j++)\\n        {\\n            if(hm.containsKey(s.charAt(j)))\\n            {\\n                ansarr[j] = hm.get(s.charAt(j));\\n            }\\n            \\n            else\\n            {\\n                ansarr[j] = s.charAt(j)-96;\\n            }\\n        }\\n       int locMax =0;\\n       int glbMax = Integer.MIN_VALUE;\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            locMax = Math.max(ansarr[k], locMax+ansarr[k]);\\n            glbMax = Math.max(locMax, glbMax);\\n        }\\n        \\n        return glbMax <0 ? 0:glbMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504275,
                "title": "python3-o-n-presum",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        costs = list(range(1, 27))\\n        for c, v in zip(chars, vals): costs[ord(c) - ord(\\'a\\')] = v\\n        presum = [0] * (len(s) + 1)\\n        for i in range(len(s)): presum[i + 1] = presum[i] + costs[ord(s[i]) - ord(\\'a\\')]\\n        ans, curmax = max(presum), float(\\'-inf\\')\\n        for i in range(len(s) - 1, -1, -1):\\n            ans = max(ans, curmax - presum[i + 1])\\n            curmax = max(curmax, presum[i + 1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        costs = list(range(1, 27))\\n        for c, v in zip(chars, vals): costs[ord(c) - ord(\\'a\\')] = v\\n        presum = [0] * (len(s) + 1)\\n        for i in range(len(s)): presum[i + 1] = presum[i] + costs[ord(s[i]) - ord(\\'a\\')]\\n        ans, curmax = max(presum), float(\\'-inf\\')\\n        for i in range(len(s) - 1, -1, -1):\\n            ans = max(ans, curmax - presum[i + 1])\\n            curmax = max(curmax, presum[i + 1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503644,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        s=list(s)\\n        x=list(set(s))\\n        d={}\\n        chars=list(chars)\\n        for i in range(len(x)):\\n            if x[i] in chars:\\n                d[x[i]]=vals[chars.index(x[i])]\\n            else:\\n                d[x[i]]=ord(x[i])-96\\n        for i in range(len(s)):\\n            s[i]=d[s[i]]\\n        def maxSubArraySum(a, size):\\n            max_so_far = 0\\n            max_ending_here = 0\\n        \\n            for i in range(0, size):\\n                max_ending_here = max_ending_here + a[i]\\n                if (max_so_far < max_ending_here):\\n                    max_so_far = max_ending_here\\n        \\n                if max_ending_here < 0:\\n                    max_ending_here = 0\\n            return max_so_far\\n        return maxSubArraySum(s, len(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        s=list(s)\\n        x=list(set(s))\\n        d={}\\n        chars=list(chars)\\n        for i in range(len(x)):\\n            if x[i] in chars:\\n                d[x[i]]=vals[chars.index(x[i])]\\n            else:\\n                d[x[i]]=ord(x[i])-96\\n        for i in range(len(s)):\\n            s[i]=d[s[i]]\\n        def maxSubArraySum(a, size):\\n            max_so_far = 0\\n            max_ending_here = 0\\n        \\n            for i in range(0, size):\\n                max_ending_here = max_ending_here + a[i]\\n                if (max_so_far < max_ending_here):\\n                    max_so_far = max_ending_here\\n        \\n                if max_ending_here < 0:\\n                    max_ending_here = 0\\n            return max_so_far\\n        return maxSubArraySum(s, len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496291,
                "title": "c-kadane-algorithm-maximum-sum-substring-optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKadane Algorithm \\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=vals[i];\\n        }\\n        \\n        int n=s.length();\\n        int maxc=0,cost=0;\\n\\n        // kadane\\'s algorithm\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                c=mp[s[i]];\\n            }\\n            else\\n            {\\n                c=s[i]-96;\\n            }\\n            cost+=c;\\n            if(cost<0)\\n                cost=0;\\n            maxc=max(maxc,cost);\\n        }\\n        return maxc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=vals[i];\\n        }\\n        \\n        int n=s.length();\\n        int maxc=0,cost=0;\\n\\n        // kadane\\'s algorithm\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                c=mp[s[i]];\\n            }\\n            else\\n            {\\n                c=s[i]-96;\\n            }\\n            cost+=c;\\n            if(cost<0)\\n                cost=0;\\n            maxc=max(maxc,cost);\\n        }\\n        return maxc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490336,
                "title": "creating-dict-from-alphabet-and-update-with-chars-kadane",
                "content": "# Intuition\\nMy solution is not that much different, except in the beginning i make a full dict and only replace values specified in chars/vals arrays. \\n1. create 1..26 array with alphabet\\n2. update the specific chars with vals if present\\n3. this part - kadane algo i did not get myself.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) - run thru the string s once\\n\\n- Space complexity:\\nO(n) - cuz we use dict here to store costs\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n\\n\\n        cost1 = dict(zip(chars, vals))\\n\\n        ind = [i for i in range(1, 27)]\\n        val = string.ascii_lowercase\\n\\n        cost = dict(zip(val, ind))\\n\\n        for k, v in cost1.items():\\n            if k in cost:\\n                cost[k] = v\\n\\n        max_cost = 0\\n        cur_cost = 0\\n        for i in range(len(s)):\\n\\n            cur_cost += cost[s[i]]\\n\\n            if cur_cost < 0:\\n                cur_cost = 0\\n            max_cost = max(cur_cost, max_cost)\\n        print(max_cost)\\n        return max_cost\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n\\n\\n        cost1 = dict(zip(chars, vals))\\n\\n        ind = [i for i in range(1, 27)]\\n        val = string.ascii_lowercase\\n\\n        cost = dict(zip(val, ind))\\n\\n        for k, v in cost1.items():\\n            if k in cost:\\n                cost[k] = v\\n\\n        max_cost = 0\\n        cur_cost = 0\\n        for i in range(len(s)):\\n\\n            cur_cost += cost[s[i]]\\n\\n            if cur_cost < 0:\\n                cur_cost = 0\\n            max_cost = max(cur_cost, max_cost)\\n        print(max_cost)\\n        return max_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480377,
                "title": "simple-greedy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGreedy Approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mc[150];\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i, j, k, l, m, ans=0, mx=0, x;\\n\\n        for(i=0; i<chars.length(); i++) mc[chars[i]]=i+1;\\n\\n        for(i=0; i<s.length(); i++) {\\n            if(mc[s[i]]) x = vals[mc[s[i]]-1];\\n            else x = s[i]-\\'a\\'+1;\\n\\n            if((ans+x)>0) ans+=x;\\n            else ans=0;\\n\\n            mx = max(mx, ans);\\n        }\\n\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mc[150];\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i, j, k, l, m, ans=0, mx=0, x;\\n\\n        for(i=0; i<chars.length(); i++) mc[chars[i]]=i+1;\\n\\n        for(i=0; i<s.length(); i++) {\\n            if(mc[s[i]]) x = vals[mc[s[i]]-1];\\n            else x = s[i]-\\'a\\'+1;\\n\\n            if((ans+x)>0) ans+=x;\\n            else ans=0;\\n\\n            mx = max(mx, ans);\\n        }\\n\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476121,
                "title": "c-solution-easy-80",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int res = 0,temp = 0;\\n        for(char x : s){\\n            if(chars.find(x) == string::npos){\\n                temp += x-96;\\n            }\\n            else{\\n                temp += vals[chars.find(x)];\\n            }\\n            if(temp > 0){\\n                res = max(res,temp);\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int res = 0,temp = 0;\\n        for(char x : s){\\n            if(chars.find(x) == string::npos){\\n                temp += x-96;\\n            }\\n            else{\\n                temp += vals[chars.find(x)];\\n            }\\n            if(temp > 0){\\n                res = max(res,temp);\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464415,
                "title": "optimizing-substring-cost-calculations-with-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is like Kadane\\'s Algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array values with the default values for each character (1 for \\'a\\', 2 for \\'b\\', etc.).\\n2. Update the values of the characters in chars using the array vals.\\n3. Initialize two variables cur and max to 0. \\n4. Iterate through each character c in the string s.\\n5. Compute the value of c using the array values.\\n6. Update cur using Kadane\\'s algorithm: cur = Math.max(cur + value, value), where value is the value of the current character.\\n7. Update max using max = Math.max(cur, max).\\n8. Return max.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26) or O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int maximumCostSubstring(String s, String chars, int[] vals) \\n    {\\n        int[] values = new int[26];\\n        for(int i=0; i<26; i++)\\n            values[i] = i + 1;\\n        int n = vals.length;\\n        for(int i=0; i<n; i++)\\n            values[chars.charAt(i) - \\'a\\'] = vals[i];\\n        int cur = 0;\\n        int max = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            cur = Math.max(cur + values[c - \\'a\\'], values[c - \\'a\\']);\\n            max = Math.max(cur, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maximumCostSubstring(String s, String chars, int[] vals) \\n    {\\n        int[] values = new int[26];\\n        for(int i=0; i<26; i++)\\n            values[i] = i + 1;\\n        int n = vals.length;\\n        for(int i=0; i<n; i++)\\n            values[chars.charAt(i) - \\'a\\'] = vals[i];\\n        int cur = 0;\\n        int max = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            cur = Math.max(cur + values[c - \\'a\\'], values[c - \\'a\\']);\\n            max = Math.max(cur, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463346,
                "title": "javascript-kadane-s-algorithm",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(26)$$\\n\\n# Code\\n```\\nvar maximumCostSubstring = function(s, chars, vals) {\\n    let max = 0, ans = 0, values = Array.from({ length: 26 }, (_, i) => i + 1);\\n    for (let i = 0; i < chars.length; i++)\\n        values[chars.charCodeAt(i) - 97] = vals[i];\\n\\n    for (const char of s) {\\n        max = Math.max(0, max + values[char.charCodeAt() - 97]);\\n        ans = Math.max(ans, max)\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar maximumCostSubstring = function(s, chars, vals) {\\n    let max = 0, ans = 0, values = Array.from({ length: 26 }, (_, i) => i + 1);\\n    for (let i = 0; i < chars.length; i++)\\n        values[chars.charCodeAt(i) - 97] = vals[i];\\n\\n    for (const char of s) {\\n        max = Math.max(0, max + values[char.charCodeAt() - 97]);\\n        ans = Math.max(ans, max)\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454362,
                "title": "c-dp",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int cost[26] = {0};\\n        for (int i = 0; i < 26; i++) {\\n            cost[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.size(); i++) {\\n            cost[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        // \\u53D8\\u6210\\u6700\\u5927\\u5B50\\u6570\\u7EC4\\u548C\\n        int n = s.length();\\n        vector<int> dp(n, 0);\\n        dp[0] = cost[s[0] - \\'a\\'];\\n        int ans = max(dp[0], 0);\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = max(cost[s[i] - \\'a\\'], cost[s[i] - \\'a\\'] + dp[i - 1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int cost[26] = {0};\\n        for (int i = 0; i < 26; i++) {\\n            cost[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.size(); i++) {\\n            cost[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        // \\u53D8\\u6210\\u6700\\u5927\\u5B50\\u6570\\u7EC4\\u548C\\n        int n = s.length();\\n        vector<int> dp(n, 0);\\n        dp[0] = cost[s[0] - \\'a\\'];\\n        int ans = max(dp[0], 0);\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = max(cost[s[i] - \\'a\\'], cost[s[i] - \\'a\\'] + dp[i - 1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452555,
                "title": "kadaen",
                "content": "```\\nint n=s.length();\\n        HashMap<Character,Integer>map= new HashMap<>();\\n\\t\\t\\n\\t\\t//put all the character and its val in map\\n\\t\\t\\n        for(int i=0;i<c.length();i++)\\n        {\\n            map.put(c.charAt(i),vals[i]);\\n        }\\n        int max=0;\\n        int sum=0;\\n\\t\\t\\n\\t\\t//use kadane algo for finding the maximim cost\\n        for(int i=0;i<n;i++)\\n        {\\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                 sum= sum+map.get(s.charAt(i));\\n            }\\n           if(!map.containsKey(s.charAt(i)))\\n           {\\n               sum=(sum+((s.charAt(i)-\\'a\\')+1));\\n           }\\n            if(max<sum)\\n            {\\n                max=sum;\\n            }\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n        }\\n        return max;    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint n=s.length();\\n        HashMap<Character,Integer>map= new HashMap<>();\\n\\t\\t\\n\\t\\t//put all the character and its val in map\\n\\t\\t\\n        for(int i=0;i<c.length();i++)\\n        {\\n            map.put(c.charAt(i),vals[i]);\\n        }\\n        int max=0;\\n        int sum=0;\\n\\t\\t\\n\\t\\t//use kadane algo for finding the maximim cost\\n        for(int i=0;i<n;i++)\\n        {\\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                 sum= sum+map.get(s.charAt(i));\\n            }\\n           if(!map.containsKey(s.charAt(i)))\\n           {\\n               sum=(sum+((s.charAt(i)-\\'a\\')+1));\\n           }\\n            if(max<sum)\\n            {\\n                max=sum;\\n            }\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n        }\\n        return max;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3448448,
                "title": "o-len-s-time-o-1-space-kadane-s-algorithm-easy",
                "content": "# Intuition\\nWe need to find array sub-sequence with the greatest sum, where value at each index is defined as per rules, either char number or value from chars array. We can use Kadane\\'s algorithm to compute that fast. \\n\\n# Approach\\ncompute value for each char, this is O(len(chars)). \\ntransform starting s to the array of in values\\nusing Kadane\\'s algorithm compute greatest sum of sub-sequence in array in a one scan\\n\\n# Complexity\\n- Time complexity:\\nO(1) pre-compute initi values for each char\\nO(len(vals)) update values for chars in vals, upper bound is 26 (max different englidh letters)\\nO(len(s)) compute max sum of char values\\n\\nO(len(s)) - total complexity\\n\\n- Space complexity:\\nO(1) - array of char values \\nO(1) - Kadane\\'s algorithm uses few variables to keep state\\n\\nO(1) - total\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            counts[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.length(); i++) {\\n            counts[chars.charAt(i) - \\'a\\'] = vals[i];\\n        }\\n        \\n        int local = 0, global = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            local = Math.max(local + counts[s.charAt(i) - \\'a\\'], counts[s.charAt(i) - \\'a\\']);\\n            global = Math.max(global, local);\\n        }\\n        return global;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            counts[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.length(); i++) {\\n            counts[chars.charAt(i) - \\'a\\'] = vals[i];\\n        }\\n        \\n        int local = 0, global = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            local = Math.max(local + counts[s.charAt(i) - \\'a\\'], counts[s.charAt(i) - \\'a\\']);\\n            global = Math.max(global, local);\\n        }\\n        return global;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437638,
                "title": "easiest-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        vector<int> values;\\n        \\n        for(auto a : s){\\n            bool flag = false;\\n            for(int j = 0; j <chars.size();j++){\\n                if(a==chars[j]){\\n                    flag = true;\\n                    values.push_back(vals[j]);\\n                }\\n            }\\n            if(flag == false){\\n                \\n                values.push_back(int(a)-96);\\n                \\n            }\\n        }\\n        \\n      \\n        \\n        int maxx = INT_MIN;\\n        int maxx2 = 0;\\n\\n        for(int i = 0; i<values.size();i++){\\n\\n            maxx2 = maxx2+values[i];\\n            if(maxx<maxx2){\\n                maxx = maxx2;\\n            }\\n            if(maxx2<0){\\n                maxx2 = 0;\\n            }\\n\\n\\n        }\\n        if(maxx<0){\\n            return 0;\\n        }\\n        \\n        return maxx;\\n        \\n        \\n        \\n        \\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        vector<int> values;\\n        \\n        for(auto a : s){\\n            bool flag = false;\\n            for(int j = 0; j <chars.size();j++){\\n                if(a==chars[j]){\\n                    flag = true;\\n                    values.push_back(vals[j]);\\n                }\\n            }\\n            if(flag == false){\\n                \\n                values.push_back(int(a)-96);\\n                \\n            }\\n        }\\n        \\n      \\n        \\n        int maxx = INT_MIN;\\n        int maxx2 = 0;\\n\\n        for(int i = 0; i<values.size();i++){\\n\\n            maxx2 = maxx2+values[i];\\n            if(maxx<maxx2){\\n                maxx = maxx2;\\n            }\\n            if(maxx2<0){\\n                maxx2 = 0;\\n            }\\n\\n\\n        }\\n        if(maxx<0){\\n            return 0;\\n        }\\n        \\n        return maxx;\\n        \\n        \\n        \\n        \\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437309,
                "title": "simple-kadanes-algo-implementation",
                "content": "# Intuition\\nKadane Algo \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>v(26,0);\\n        for(int i=0;i<26;i++)\\n            v[i]=i+1;\\n        for(int i=0;i<vals.size();i++)\\n            v[chars[i]-\\'a\\']=vals[i];\\n        int currsum=0,ans=INT_MIN;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            currsum+=v[s[i]-\\'a\\'];\\n            ans=ans<currsum?currsum:ans;\\n            if(currsum<0)\\n                currsum=0;\\n        }\\n        return ans>0?ans:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>v(26,0);\\n        for(int i=0;i<26;i++)\\n            v[i]=i+1;\\n        for(int i=0;i<vals.size();i++)\\n            v[chars[i]-\\'a\\']=vals[i];\\n        int currsum=0,ans=INT_MIN;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            currsum+=v[s[i]-\\'a\\'];\\n            ans=ans<currsum?currsum:ans;\\n            if(currsum<0)\\n                currsum=0;\\n        }\\n        return ans>0?ans:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435699,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> m;\\n        for(int i=97,j=1;i<=122;i++,j++) m[i]=j;\\n        for(int i=0;i<vals.size();i++) m[chars[i]]=vals[i];\\n        int ans=0;\\n        int curr_sum=0;\\n        for(auto i : s){\\n            curr_sum+=m[i];\\n            if(curr_sum<0) curr_sum=0;\\n            if(curr_sum>0) ans=max(ans,curr_sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> m;\\n        for(int i=97,j=1;i<=122;i++,j++) m[i]=j;\\n        for(int i=0;i<vals.size();i++) m[chars[i]]=vals[i];\\n        int ans=0;\\n        int curr_sum=0;\\n        for(auto i : s){\\n            curr_sum+=m[i];\\n            if(curr_sum<0) curr_sum=0;\\n            if(curr_sum>0) ans=max(ans,curr_sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422930,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {\\n        \\n        func i(_ c: Character) -> Int {\\n            Int(c.asciiValue! - Character(\"a\").asciiValue!)\\n        }\\n\\n        var alphaCosts = (i(\"a\")...i(\"z\")).map { $0 + 1 }\\n\\n        for (c, v) in zip(chars, vals) {\\n            alphaCosts[i(c)] = v\\n        }\\n\\n        let costs = s.map { alphaCosts[i($0)] }\\n\\n        var best = 0\\n        var cur = 0\\n\\n        for c in costs {\\n            cur = max(0, cur + c)\\n            best = max(best, cur)\\n        }\\n\\n        return best\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {\\n        \\n        func i(_ c: Character) -> Int {\\n            Int(c.asciiValue! - Character(\"a\").asciiValue!)\\n        }\\n\\n        var alphaCosts = (i(\"a\")...i(\"z\")).map { $0 + 1 }\\n\\n        for (c, v) in zip(chars, vals) {\\n            alphaCosts[i(c)] = v\\n        }\\n\\n        let costs = s.map { alphaCosts[i($0)] }\\n\\n        var best = 0\\n        var cur = 0\\n\\n        for c in costs {\\n            cur = max(0, cur + c)\\n            best = max(best, cur)\\n        }\\n\\n        return best\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417359,
                "title": "easy-and-fast-c-solution-with-explanation",
                "content": "# Intuition\\nInitially, we need to calculate the cost of each character in the given string **s**. We can do this by iterating through the string and checking if the character is in the **chars** string. If it is, we use the corresponding value from the **vals** array, otherwise, we use the character\\'s position in the alphabet as its value. Then, we can iterate through the string, maintaining a running sum of the costs and resetting it to 0 if it becomes negative, keeping track of the maximum cost we have seen so far.\\n\\n# Approach\\n1. Create a dictionary **charValues** to store the values of characters in the **chars** string.\\n2. Iterate through the **chars** string and add each character and its corresponding value from the **vals** array to the dictionary.\\n3. Initialize variables **maxCost** and **currentCost** to 0.\\n4. Iterate through the string **s**:\\n- Calculate the value of the current character using the dictionary or its position in the alphabet.\\n- Add the character value to **currentCost**.\\n- If **currentCost** is negative, set it to 0.\\n- Update **maxCost** with the maximum value between **maxCost** and **currentCost**.\\n6. Return **maxCost**.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the length of the input string **s**. We need to iterate through the string once to calculate the cost of each character and once more to find the maximum cost among all substrings.\\n\\n- Space complexity: $$O(m)$$, where $$m$$ is the length of the input string **chars**. We need to store the values of characters in the **chars** string using a dictionary.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumCostSubstring(string s, string chars, int[] vals) {\\n        int n = s.Length;\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        \\n        Dictionary<char, int> charValues = new Dictionary<char, int>();\\n        for (int i = 0; i < chars.Length; i++) {\\n            charValues.Add(chars[i], vals[i]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            char currentChar = s[i];\\n            int charValue;\\n\\n            if (charValues.ContainsKey(currentChar)) {\\n                charValue = charValues[currentChar];\\n            } else {\\n                charValue = currentChar - \\'a\\' + 1;\\n            }\\n\\n            currentCost += charValue;\\n            if (currentCost < 0) {\\n                currentCost = 0;\\n            }\\n            maxCost = Math.Max(maxCost, currentCost);\\n        }\\n\\n        return maxCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumCostSubstring(string s, string chars, int[] vals) {\\n        int n = s.Length;\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        \\n        Dictionary<char, int> charValues = new Dictionary<char, int>();\\n        for (int i = 0; i < chars.Length; i++) {\\n            charValues.Add(chars[i], vals[i]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            char currentChar = s[i];\\n            int charValue;\\n\\n            if (charValues.ContainsKey(currentChar)) {\\n                charValue = charValues[currentChar];\\n            } else {\\n                charValue = currentChar - \\'a\\' + 1;\\n            }\\n\\n            currentCost += charValue;\\n            if (currentCost < 0) {\\n                currentCost = 0;\\n            }\\n            maxCost = Math.Max(maxCost, currentCost);\\n        }\\n\\n        return maxCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415428,
                "title": "100-fast-c-rolling-sum-if-negative-then-shift-to-new-index-start-sum-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> val(26,0);\\n        for(int i =0; i <26; i++)\\n        {\\n            val[i] = i+1;\\n        }\\n        int j = 0;\\n        for(auto i:chars)\\n        {\\n            val[i-\\'a\\'] = vals[j];\\n            j++;\\n        }\\n        int ma = 0;\\n        int sum = 0;\\n        for(int k = 0; k < s.size();k++ )\\n        {\\n            int i,sum = 0;\\n        for(i =k; i < s.size(); i++)\\n        {\\n            sum+=val[s[i]- \\'a\\'];\\n            ma = max(sum,ma);\\n            if(sum < 0)  break;\\n        }\\n        k = i;\\n        }\\n        return ma;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> val(26,0);\\n        for(int i =0; i <26; i++)\\n        {\\n            val[i] = i+1;\\n        }\\n        int j = 0;\\n        for(auto i:chars)\\n        {\\n            val[i-\\'a\\'] = vals[j];\\n            j++;\\n        }\\n        int ma = 0;\\n        int sum = 0;\\n        for(int k = 0; k < s.size();k++ )\\n        {\\n            int i,sum = 0;\\n        for(i =k; i < s.size(); i++)\\n        {\\n            sum+=val[s[i]- \\'a\\'];\\n            ma = max(sum,ma);\\n            if(sum < 0)  break;\\n        }\\n        k = i;\\n        }\\n        return ma;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404227,
                "title": "easy-c-solution-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to find the maximum cost substring in a given string s by using a character-cost mapping defined by two parallel vectors chars and vals.\\n\\nTo achieve this, the code scans through the string s character by character, and for each character, it checks its corresponding cost in the vals vector. If the character is not present in chars, its cost is assumed to be its ASCII value. Otherwise, its cost is obtained from the vals vector.\\n\\nThe code maintains a running sum of the costs encountered so far and updates the maximum cost encountered during the scan. If the running sum ever becomes negative, it is reset to zero, since a substring with negative cost is not considered.\\n\\nAt the end of the scan, the code returns the maximum cost encountered during the scan, which corresponds to the maximum cost substring.\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = s.size();\\n        int m = chars.size();\\n        vector<int> freq(26,1001);\\n        for(int i=0; i<m; i++){\\n            freq[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int sum = 0;\\n        int i=0;\\n        int maxCost = 0;\\n        while(i < n){\\n            if(freq[s[i]-\\'a\\'] == 1001){\\n                sum += s[i]-\\'a\\'+1;\\n            }\\n            else if(freq[s[i]-\\'a\\'] != 0){\\n                sum += freq[s[i]-\\'a\\'];\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n            maxCost = max(maxCost,sum);\\n            i++;\\n        }\\n        return maxCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = s.size();\\n        int m = chars.size();\\n        vector<int> freq(26,1001);\\n        for(int i=0; i<m; i++){\\n            freq[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int sum = 0;\\n        int i=0;\\n        int maxCost = 0;\\n        while(i < n){\\n            if(freq[s[i]-\\'a\\'] == 1001){\\n                sum += s[i]-\\'a\\'+1;\\n            }\\n            else if(freq[s[i]-\\'a\\'] != 0){\\n                sum += freq[s[i]-\\'a\\'];\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n            maxCost = max(maxCost,sum);\\n            i++;\\n        }\\n        return maxCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403076,
                "title": "python-kadane",
                "content": "Transform the input to an array of costs. Then find the maximum subarray.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        n = len(s)\\n        costs = {}\\n        for i, c in enumerate(chars):\\n            costs[c] = vals[i]\\n        \\n        def cost(x):\\n            return costs[x] if x in costs else ord(x) - 96\\n\\n        nums = [cost(c) for c in s]\\n        res = 0\\n        curr = 0\\n        for n in nums:\\n            if curr < 0:\\n                curr = 0\\n            curr += n\\n            res = max(res, curr)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        n = len(s)\\n        costs = {}\\n        for i, c in enumerate(chars):\\n            costs[c] = vals[i]\\n        \\n        def cost(x):\\n            return costs[x] if x in costs else ord(x) - 96\\n\\n        nums = [cost(c) for c in s]\\n        res = 0\\n        curr = 0\\n        for n in nums:\\n            if curr < 0:\\n                curr = 0\\n            curr += n\\n            res = max(res, curr)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397572,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the value for each character and then perform max subbarray to calculate the maximum sum. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        arr = [-1002] * 26\\n        maxval = 0\\n        prev = 0\\n        q = {}\\n        for i in range(len(chars)):\\n            q[chars[i]] = i\\n        for i in range(len(s)):\\n            t = ord(s[i]) - ord(\\'a\\')\\n            if arr[t] == -1002:\\n                if s[i] not in q:\\n                    arr[t] = t + 1    \\n                else:\\n                    arr[t] = vals[q[s[i]]]\\n            if i == 0:\\n                maxval = max(maxval, arr[t])\\n                prev = maxval\\n            else:\\n                x = max(prev + arr[t], 0)\\n                maxval = max(maxval, x)\\n                prev = x\\n        return maxval\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        arr = [-1002] * 26\\n        maxval = 0\\n        prev = 0\\n        q = {}\\n        for i in range(len(chars)):\\n            q[chars[i]] = i\\n        for i in range(len(s)):\\n            t = ord(s[i]) - ord(\\'a\\')\\n            if arr[t] == -1002:\\n                if s[i] not in q:\\n                    arr[t] = t + 1    \\n                else:\\n                    arr[t] = vals[q[s[i]]]\\n            if i == 0:\\n                maxval = max(maxval, arr[t])\\n                prev = maxval\\n            else:\\n                x = max(prev + arr[t], 0)\\n                maxval = max(maxval, x)\\n                prev = x\\n        return maxval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397083,
                "title": "c-dp-solution",
                "content": "Its kaden\\'s algorithm.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> res; \\n        unordered_map<char,int> mpp; \\n        char c = \\'a\\';\\n        int ziz = 1; \\n        while(c <= \\'z\\'){\\n            mpp[c] = ziz++; \\n            ++c; \\n        }\\n        for(int i = 0 ; i < vals.size() ; ++i){\\n            char curr = chars[i]; \\n            mpp[curr] = vals[i]; \\n        }\\n        for(int i = 0 ; i < s.length(); ++i){\\n            char curr = s[i]; \\n            int val = mpp[curr] ; \\n            res.push_back(val); \\n        }\\n        for(auto x : res) cout << x << \" \"; \\n        cout << endl;\\n        int n = int(res.size()); \\n        int dp[n]; \\n        memset(dp , 0 , sizeof dp); \\n        dp[0] = res[0]; \\n        int maxx = dp[0]; \\n        for(int i = 1 ; i < s.length(); ++i){\\n            dp[i] = max(res[i], dp[i-1] + res[i]); \\n            maxx = max(maxx , dp[i]); \\n        }\\n        maxx = max(0 , maxx); \\n        return maxx; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> res; \\n        unordered_map<char,int> mpp; \\n        char c = \\'a\\';\\n        int ziz = 1; \\n        while(c <= \\'z\\'){\\n            mpp[c] = ziz++; \\n            ++c; \\n        }\\n        for(int i = 0 ; i < vals.size() ; ++i){\\n            char curr = chars[i]; \\n            mpp[curr] = vals[i]; \\n        }\\n        for(int i = 0 ; i < s.length(); ++i){\\n            char curr = s[i]; \\n            int val = mpp[curr] ; \\n            res.push_back(val); \\n        }\\n        for(auto x : res) cout << x << \" \"; \\n        cout << endl;\\n        int n = int(res.size()); \\n        int dp[n]; \\n        memset(dp , 0 , sizeof dp); \\n        dp[0] = res[0]; \\n        int maxx = dp[0]; \\n        for(int i = 1 ; i < s.length(); ++i){\\n            dp[i] = max(res[i], dp[i-1] + res[i]); \\n            maxx = max(maxx , dp[i]); \\n        }\\n        maxx = max(0 , maxx); \\n        return maxx; \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3396539,
                "title": "unique-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(string &s,map<char,int>&mp){\\n\\n    int res = 0;\\n    int sum = 0;\\n\\n    for(int i = 0;i<s.size();i++){\\n\\n        if(mp.find(s[i])!=mp.end()){\\n\\n            sum = sum + mp[s[i]];\\n\\n        }\\n         if(mp.find(s[i])==mp.end()){\\n            int n = s[i]-\\'0\\';\\n            sum = sum + n-48;\\n        }\\n        res = max(res,sum);\\n        if(sum<0)sum = 0;\\n        \\n    }\\n    return res;\\n\\n    \\n}\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        map<char,int>mp;\\n        for(int i = 0;i<chars.size();i++){\\n\\n            mp[chars[i]] = vals[i];\\n        }\\n\\n        return solve(s,mp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(string &s,map<char,int>&mp){\\n\\n    int res = 0;\\n    int sum = 0;\\n\\n    for(int i = 0;i<s.size();i++){\\n\\n        if(mp.find(s[i])!=mp.end()){\\n\\n            sum = sum + mp[s[i]];\\n\\n        }\\n         if(mp.find(s[i])==mp.end()){\\n            int n = s[i]-\\'0\\';\\n            sum = sum + n-48;\\n        }\\n        res = max(res,sum);\\n        if(sum<0)sum = 0;\\n        \\n    }\\n    return res;\\n\\n    \\n}\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        map<char,int>mp;\\n        for(int i = 0;i<chars.size();i++){\\n\\n            mp[chars[i]] = vals[i];\\n        }\\n\\n        return solve(s,mp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396413,
                "title": "o-n-with-explanation-simple-java-dp-solution",
                "content": "# Intuition\\nUsing a dp[n + 1] to record the max value among all possible substring valus which ends with s.char(n).\\nTravel from 0 to n-1, record dp[i], and restore the max value with dp[i], then return the maxValue\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// AC: Runtime 24 ms Beats 30.39% \\n// Memory 43.4 MB Beats 47.89%\\n// DP.\\n// T:O(n), S:O(n + 26)\\n// \\nclass Solution {\\n    private HashMap<Character, Integer> charToValue = new HashMap<>();\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        for (int i = 0; i < chars.length(); i++) {\\n            charToValue.put(chars.charAt(i), i);\\n        }\\n        int len = s.length(), ret = 0;\\n        int[] dp = new int[len + 1];\\n        for (int i = 0; i < len; i++) {\\n            int val = getVal(s.charAt(i), chars, vals);\\n            dp[i + 1] = Math.max(dp[i] + val, val);\\n            ret = Math.max(ret, dp[i + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    private int getVal(char c, String chars, int[] vals) {\\n        \\n        if (charToValue.containsKey(c)) {\\n            return vals[charToValue.get(c)];\\n        }\\n\\n        return c - \\'a\\' + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// AC: Runtime 24 ms Beats 30.39% \\n// Memory 43.4 MB Beats 47.89%\\n// DP.\\n// T:O(n), S:O(n + 26)\\n// \\nclass Solution {\\n    private HashMap<Character, Integer> charToValue = new HashMap<>();\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        for (int i = 0; i < chars.length(); i++) {\\n            charToValue.put(chars.charAt(i), i);\\n        }\\n        int len = s.length(), ret = 0;\\n        int[] dp = new int[len + 1];\\n        for (int i = 0; i < len; i++) {\\n            int val = getVal(s.charAt(i), chars, vals);\\n            dp[i + 1] = Math.max(dp[i] + val, val);\\n            ret = Math.max(ret, dp[i + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    private int getVal(char c, String chars, int[] vals) {\\n        \\n        if (charToValue.containsKey(c)) {\\n            return vals[charToValue.get(c)];\\n        }\\n\\n        return c - \\'a\\' + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395471,
                "title": "swift-kadane-s-algorithm",
                "content": "**Kadane\\'s Algorithm (accepted answer)**\\n```\\nclass Solution {\\n    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {\\n        let LOWER_A_ASCII = 97\\n        \\n        var costs = Array(1...26)\\n        for (ch, val) in zip(chars, vals) {\\n            costs[Int(ch.asciiValue!) - LOWER_A_ASCII] = val\\n        }\\n        \\n        var localMax = 0\\n        var globalMax = 0\\n        \\n        for ch in s {\\n            let cost = costs[Int(ch.asciiValue!) - LOWER_A_ASCII]\\n            localMax = max(cost, cost + localMax)\\n            globalMax = max(localMax, globalMax)\\n        }\\n        \\n        return globalMax\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {\\n        let LOWER_A_ASCII = 97\\n        \\n        var costs = Array(1...26)\\n        for (ch, val) in zip(chars, vals) {\\n            costs[Int(ch.asciiValue!) - LOWER_A_ASCII] = val\\n        }\\n        \\n        var localMax = 0\\n        var globalMax = 0\\n        \\n        for ch in s {\\n            let cost = costs[Int(ch.asciiValue!) - LOWER_A_ASCII]\\n            localMax = max(cost, cost + localMax)\\n            globalMax = max(localMax, globalMax)\\n        }\\n        \\n        return globalMax\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393827,
                "title": "intutive-c-solution-kadane-hashmap-heavily-commented",
                "content": "# Intuition\\n1. Calculate the value of each character in the given string according to the given conditions.\\n2. Apply Kadane\\'s Algo to get the maximum sum.\\n\\n# Approach\\n### EXPLAINED IN THE CODE THROUGH COMMENTS.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        unordered_map<char,int>mp;// map to store the corrosponding value of chars from vals\\n        map<char,int>mp2; // map to store indexed value of a character, yu can also use array.\\n        \\n        //storing the values of character.\\n        char ch=\\'a\\';\\n        for(int i=1;i<=26;i++) mp2[ch++]=i;\\n\\n        // storing the value of characters from the vals array.\\n        for(int i=0;i<chars.size();i++) mp[chars[i]]=vals[i];\\n        \\n        //Now make a temporray array using the values evaluated.\\n        vector<int>tmp;\\n        for(int i=0;i<s.size();i++){\\n            if(mp.find(s[i])!=mp.end()) tmp.push_back(mp[s[i]]);\\n            else tmp.push_back(mp2[s[i]]);\\n        }\\n        \\n        //Now simply apply KADANE\\'s ALGO on temporay array to get the maximum subarray sum.\\n        int sum=0, maxi=INT_MIN;\\n        for(auto it : tmp){\\n            sum+=it;\\n            maxi=max(maxi,sum);\\n            if(sum<0) sum=0;\\n        }\\n        \\n        //if sum is -ve , then empty subarray have maximum sum\\n        if(maxi<0) maxi=0;\\n        return maxi;\\n    }\\n};\\n```\\nPLEASE UPVOTE IF YOU LIKE \\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        unordered_map<char,int>mp;// map to store the corrosponding value of chars from vals\\n        map<char,int>mp2; // map to store indexed value of a character, yu can also use array.\\n        \\n        //storing the values of character.\\n        char ch=\\'a\\';\\n        for(int i=1;i<=26;i++) mp2[ch++]=i;\\n\\n        // storing the value of characters from the vals array.\\n        for(int i=0;i<chars.size();i++) mp[chars[i]]=vals[i];\\n        \\n        //Now make a temporray array using the values evaluated.\\n        vector<int>tmp;\\n        for(int i=0;i<s.size();i++){\\n            if(mp.find(s[i])!=mp.end()) tmp.push_back(mp[s[i]]);\\n            else tmp.push_back(mp2[s[i]]);\\n        }\\n        \\n        //Now simply apply KADANE\\'s ALGO on temporay array to get the maximum subarray sum.\\n        int sum=0, maxi=INT_MIN;\\n        for(auto it : tmp){\\n            sum+=it;\\n            maxi=max(maxi,sum);\\n            if(sum<0) sum=0;\\n        }\\n        \\n        //if sum is -ve , then empty subarray have maximum sum\\n        if(maxi<0) maxi=0;\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392912,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.stream.IntStream;\\n\\npublic class Solution {\\n\\n    private static final int ALPHABET_SIZE = 26;\\n\\n    public int maximumCostSubstring(String input, String chars, int[] values) {\\n        int[] costForChar = IntStream.rangeClosed(1, ALPHABET_SIZE).toArray();\\n        for (int i = 0; i < chars.length(); ++i) {\\n            costForChar[chars.charAt(i) - \\'a\\'] = values[i];\\n        }\\n\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        for (int i = 0; i < input.length(); ++i) {\\n            currentCost = Math.max(0, currentCost + costForChar[input.charAt(i) - \\'a\\']);\\n            maxCost = Math.max(maxCost, currentCost);\\n        }\\n        return maxCost;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string} input\\n * @param {string} chars\\n * @param {number[]} values\\n * @return {number}\\n */\\nvar maximumCostSubstring = function (input, chars, values) {\\n    const ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const costForChar = Array.from(Array(ALPHABET_SIZE).keys(), n => n + 1);\\n    for (let i = 0; i < chars.length; ++i) {\\n        costForChar[chars.codePointAt(i) - ASCII_SMALL_CASE_A] = values[i];\\n    }\\n\\n    let maxCost = 0;\\n    let currentCost = 0;\\n    for (let i = 0; i < input.length; ++i) {\\n        currentCost = Math.max(0, currentCost + costForChar[input.codePointAt(i) - ASCII_SMALL_CASE_A]);\\n        maxCost = Math.max(maxCost, currentCost);\\n    }\\n    return maxCost;\\n};\\n```\\n**C++**\\n```\\n#include <array>\\n#include <string>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    static const int ALPHABET_SIZE = 26;\\n    \\npublic:\\n    int maximumCostSubstring(const string& input, const string& chars, const vector<int>& values) const {\\n        array<int, ALPHABET_SIZE> costForChar;\\n        iota(costForChar.begin(), costForChar.end(), 1);\\n        for (int i = 0; i < chars.length(); ++i) {\\n            costForChar[chars[i] - \\'a\\'] = values[i];\\n        }\\n\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        for (const auto& letter : input) {\\n            currentCost = max(0, currentCost + costForChar[letter - \\'a\\']);\\n            maxCost = max(maxCost, currentCost);\\n        }\\n        return maxCost;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.stream.IntStream;\\n\\npublic class Solution {\\n\\n    private static final int ALPHABET_SIZE = 26;\\n\\n    public int maximumCostSubstring(String input, String chars, int[] values) {\\n        int[] costForChar = IntStream.rangeClosed(1, ALPHABET_SIZE).toArray();\\n        for (int i = 0; i < chars.length(); ++i) {\\n            costForChar[chars.charAt(i) - \\'a\\'] = values[i];\\n        }\\n\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        for (int i = 0; i < input.length(); ++i) {\\n            currentCost = Math.max(0, currentCost + costForChar[input.charAt(i) - \\'a\\']);\\n            maxCost = Math.max(maxCost, currentCost);\\n        }\\n        return maxCost;\\n    }\\n}\\n```\n```\\n/**\\n * @param {string} input\\n * @param {string} chars\\n * @param {number[]} values\\n * @return {number}\\n */\\nvar maximumCostSubstring = function (input, chars, values) {\\n    const ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const costForChar = Array.from(Array(ALPHABET_SIZE).keys(), n => n + 1);\\n    for (let i = 0; i < chars.length; ++i) {\\n        costForChar[chars.codePointAt(i) - ASCII_SMALL_CASE_A] = values[i];\\n    }\\n\\n    let maxCost = 0;\\n    let currentCost = 0;\\n    for (let i = 0; i < input.length; ++i) {\\n        currentCost = Math.max(0, currentCost + costForChar[input.codePointAt(i) - ASCII_SMALL_CASE_A]);\\n        maxCost = Math.max(maxCost, currentCost);\\n    }\\n    return maxCost;\\n};\\n```\n```\\n#include <array>\\n#include <string>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    static const int ALPHABET_SIZE = 26;\\n    \\npublic:\\n    int maximumCostSubstring(const string& input, const string& chars, const vector<int>& values) const {\\n        array<int, ALPHABET_SIZE> costForChar;\\n        iota(costForChar.begin(), costForChar.end(), 1);\\n        for (int i = 0; i < chars.length(); ++i) {\\n            costForChar[chars[i] - \\'a\\'] = values[i];\\n        }\\n\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        for (const auto& letter : input) {\\n            currentCost = max(0, currentCost + costForChar[letter - \\'a\\']);\\n            maxCost = max(maxCost, currentCost);\\n        }\\n        return maxCost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3392748,
                "title": "easy-c-using-unordered-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n\\n        for(int i=0;i<chars.size();i++){\\n            m[chars[i]] = vals[i];\\n        }\\n\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i = 0; i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){\\n                temp+=m[s[i]];\\n            }else{\\n                temp += ((s[i] - \\'0\\') - 48);\\n            }\\n            ans = max(ans,temp);\\n  \\n            //if we have substring with negative value then why we add it to our answer..., so make temp = 0;  0 > (neg)\\n            if(temp < 0){\\n                temp = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n\\n        for(int i=0;i<chars.size();i++){\\n            m[chars[i]] = vals[i];\\n        }\\n\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i = 0; i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){\\n                temp+=m[s[i]];\\n            }else{\\n                temp += ((s[i] - \\'0\\') - 48);\\n            }\\n            ans = max(ans,temp);\\n  \\n            //if we have substring with negative value then why we add it to our answer..., so make temp = 0;  0 > (neg)\\n            if(temp < 0){\\n                temp = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392478,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        t = dict(zip(chars, vals))\\n        values = [t.get(ch, ord(ch)-96) for ch in s]\\n\\n        best, current = -math.inf, 0\\n        for val in values:\\n            current = max(current+val, 0)\\n            best = max(best, current)\\n\\n        return best\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        t = dict(zip(chars, vals))\\n        values = [t.get(ch, ord(ch)-96) for ch in s]\\n\\n        best, current = -math.inf, 0\\n        for val in values:\\n            current = max(current+val, 0)\\n            best = max(best, current)\\n\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392304,
                "title": "java-solution-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        char x = \\'a\\';\\n\\n        for(int i = 0; i < vals.length; i++)\\n            hm.put(chars.charAt(i), vals[i]);\\n\\n        for(int i = 0; i < 26; i++){\\n            if(!hm.containsKey(x))\\n                hm.put(x, i+1);\\n\\n            x++;\\n        }\\n\\n        int[] values = new int[s.length()];\\n\\n        for(int i = 0; i < s.length(); i++)\\n            values[i] = hm.get(s.charAt(i));\\n        \\n        int max = 0;\\n        int sum = 0;\\n\\n        for(int i = 0; i < values.length; i++){\\n            sum += values[i];\\n            max = Math.max(sum, max);\\n\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        char x = \\'a\\';\\n\\n        for(int i = 0; i < vals.length; i++)\\n            hm.put(chars.charAt(i), vals[i]);\\n\\n        for(int i = 0; i < 26; i++){\\n            if(!hm.containsKey(x))\\n                hm.put(x, i+1);\\n\\n            x++;\\n        }\\n\\n        int[] values = new int[s.length()];\\n\\n        for(int i = 0; i < s.length(); i++)\\n            values[i] = hm.get(s.charAt(i));\\n        \\n        int max = 0;\\n        int sum = 0;\\n\\n        for(int i = 0; i < values.length; i++){\\n            sum += values[i];\\n            max = Math.max(sum, max);\\n\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391084,
                "title": "kadane-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {}\\n        for i in range(len(chars)):\\n            d[chars[i]] = vals[i]\\n        res = 0 \\n        temp = 0\\n        for i in s:\\n            val = d[i] if i in d else ord(i) - 96\\n            temp = max(val,temp+val)\\n            res = max(res,temp)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {}\\n        for i in range(len(chars)):\\n            d[chars[i]] = vals[i]\\n        res = 0 \\n        temp = 0\\n        for i in s:\\n            val = d[i] if i in d else ord(i) - 96\\n            temp = max(val,temp+val)\\n            res = max(res,temp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388033,
                "title": "solution-modeled-after-maximum-subarray-lc-53",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGenerate All subarrays and find the maxiumum cost by eithe taking the 1 based index or the value from the vals\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerating sub array and taking the maximum sum approach is similar to\\n[LC 53](https://leetcode.com/problems/maximum-subarray/)\\n\\n# Complexity\\n- Time complexity:\\n- O(n) to compute\\n- O(chars) to create the map, which will be same as the chars in alphabet\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(K), if K is the number of chars in the alphabet\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] map = new int[26];\\n        Arrays.fill(map, -1001);\\n        for(int i = 0; i < chars.length(); i++) {\\n            map[chars.charAt(i) - \\'a\\'] = vals[i];\\n        }\\n        int gm = 0;\\n        int lm = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            int cost = map[s.charAt(i) - \\'a\\'] == -1001 ? s.charAt(i) - \\'a\\' + 1 : map[s.charAt(i) - \\'a\\'];\\n            lm = Math.max(cost, cost + lm);\\n            gm = Math.max(gm, lm);\\n        }\\n        \\n        return gm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] map = new int[26];\\n        Arrays.fill(map, -1001);\\n        for(int i = 0; i < chars.length(); i++) {\\n            map[chars.charAt(i) - \\'a\\'] = vals[i];\\n        }\\n        int gm = 0;\\n        int lm = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            int cost = map[s.charAt(i) - \\'a\\'] == -1001 ? s.charAt(i) - \\'a\\' + 1 : map[s.charAt(i) - \\'a\\'];\\n            lm = Math.max(cost, cost + lm);\\n            gm = Math.max(gm, lm);\\n        }\\n        \\n        return gm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387626,
                "title": "linear-python-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n) $$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        cur_cost = 0\\n        max_cost = 0\\n        cost = {\\n            \\'a\\':1,\\n            \\'b\\':2,\\n            \\'c\\':3,\\n            \\'d\\':4,\\n            \\'e\\':5,\\n            \\'f\\':6,\\n            \\'g\\':7,\\n            \\'h\\':8,\\n            \\'i\\':9,\\n            \\'j\\':10,\\n            \\'k\\':11,\\n            \\'l\\':12,\\n            \\'m\\':13,\\n            \\'n\\':14,\\n            \\'o\\':15,\\n            \\'p\\':16,\\n            \\'q\\':17,\\n            \\'r\\':18,\\n            \\'s\\':19,\\n            \\'t\\':20,\\n            \\'u\\':21,\\n            \\'v\\':22,\\n            \\'w\\':23,\\n            \\'x\\':24,\\n            \\'y\\':25,\\n            \\'z\\':26\\n            }\\n        for i in range(len(vals)):\\n            cost[chars[i]] = vals[i]\\n\\n        for c in s:\\n                cur_cost += cost[c]\\n                max_cost = max(max_cost, cur_cost)\\n                if cur_cost < 0:\\n                    cur_cost = 0\\n        return max_cost\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        cur_cost = 0\\n        max_cost = 0\\n        cost = {\\n            \\'a\\':1,\\n            \\'b\\':2,\\n            \\'c\\':3,\\n            \\'d\\':4,\\n            \\'e\\':5,\\n            \\'f\\':6,\\n            \\'g\\':7,\\n            \\'h\\':8,\\n            \\'i\\':9,\\n            \\'j\\':10,\\n            \\'k\\':11,\\n            \\'l\\':12,\\n            \\'m\\':13,\\n            \\'n\\':14,\\n            \\'o\\':15,\\n            \\'p\\':16,\\n            \\'q\\':17,\\n            \\'r\\':18,\\n            \\'s\\':19,\\n            \\'t\\':20,\\n            \\'u\\':21,\\n            \\'v\\':22,\\n            \\'w\\':23,\\n            \\'x\\':24,\\n            \\'y\\':25,\\n            \\'z\\':26\\n            }\\n        for i in range(len(vals)):\\n            cost[chars[i]] = vals[i]\\n\\n        for c in s:\\n                cur_cost += cost[c]\\n                max_cost = max(max_cost, cur_cost)\\n                if cur_cost < 0:\\n                    cur_cost = 0\\n        return max_cost\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387291,
                "title": "kadanes-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        su=0\\n        m=0\\n        a=dict(zip(chars,vals))\\n        for i in range(len(s)):\\n            if s[i] in chars:\\n                su+=a[s[i]]\\n            else:\\n                su+=ord(s[i])-96\\n            if(su<0):\\n                su=0\\n            m=max(m,su)\\n        return m\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        su=0\\n        m=0\\n        a=dict(zip(chars,vals))\\n        for i in range(len(s)):\\n            if s[i] in chars:\\n                su+=a[s[i]]\\n            else:\\n                su+=ord(s[i])-96\\n            if(su<0):\\n                su=0\\n            m=max(m,su)\\n        return m\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386117,
                "title": "c-easy-solution-kedane",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        unordered_map<char  , int> mp;\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            mp[chars[i]] = vals[i];\\n        }\\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n            v.push_back(mp[s[i]]);\\n            else\\n            {\\n                v.push_back(s[i]-\\'a\\'+1);\\n            }\\n        }\\n       \\n       int run_sum = 0;\\n       int ans_sum = INT_MIN;\\n       for(int i=0;i<v.size();i++)\\n       {\\n\\n\\n           run_sum = run_sum + v[i];\\n           ans_sum = max(ans_sum , run_sum);\\n\\n           if(run_sum<0)\\n           run_sum = 0;\\n       }\\n       if(ans_sum<0)\\n       return 0;\\n       return ans_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        unordered_map<char  , int> mp;\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            mp[chars[i]] = vals[i];\\n        }\\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n            v.push_back(mp[s[i]]);\\n            else\\n            {\\n                v.push_back(s[i]-\\'a\\'+1);\\n            }\\n        }\\n       \\n       int run_sum = 0;\\n       int ans_sum = INT_MIN;\\n       for(int i=0;i<v.size();i++)\\n       {\\n\\n\\n           run_sum = run_sum + v[i];\\n           ans_sum = max(ans_sum , run_sum);\\n\\n           if(run_sum<0)\\n           run_sum = 0;\\n       }\\n       if(ans_sum<0)\\n       return 0;\\n       return ans_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386017,
                "title": "o-n-kadane-s-algo-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> hashMap = new HashMap<>();\\n\\n        for(int i = 0; i < chars.length(); i++)\\n            hashMap.put(chars.charAt(i), i);\\n\\n        int maxCost = 0;\\n        int cost = 0;\\n        for(int j = 0; j < s.length(); j++){\\n            Character c = s.charAt(j);\\n\\n            if(hashMap.containsKey(c))\\n                cost += vals[hashMap.get(c)];\\n            else \\n                cost += c - \\'a\\' + 1;\\n\\n            maxCost = Math.max(maxCost, cost);\\n            cost = Math.max(cost, 0);\\n        }\\n        \\n        return maxCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> hashMap = new HashMap<>();\\n\\n        for(int i = 0; i < chars.length(); i++)\\n            hashMap.put(chars.charAt(i), i);\\n\\n        int maxCost = 0;\\n        int cost = 0;\\n        for(int j = 0; j < s.length(); j++){\\n            Character c = s.charAt(j);\\n\\n            if(hashMap.containsKey(c))\\n                cost += vals[hashMap.get(c)];\\n            else \\n                cost += c - \\'a\\' + 1;\\n\\n            maxCost = Math.max(maxCost, cost);\\n            cost = Math.max(cost, 0);\\n        }\\n        \\n        return maxCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384321,
                "title": "kadane-dp-solution",
                "content": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int dic[26];\\n        \\n        for(int i=0; i<26; i++)\\n            dic[i]=i+1;\\n        \\n        for(int i=0; i<vals.size(); i++)\\n            dic[chars[i]-\\'a\\']=vals[i];\\n        \\n        int n = s.size();\\n        int dp[n];\\n        int sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i]=0;\\n        }\\n        for(int i=0; i<s.size(); i++)\\n        {  \\n            if(i==0)\\n                dp[i] = max(0, dic[s[i]-\\'a\\']);\\n            else\\n                dp[i] = max(dp[i-1]+dic[s[i]-\\'a\\'], dic[s[i]-\\'a\\']);    \\n        }\\n        \\n        int ret=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ret = max(dp[i], ret);\\n        }\\n        return max(0, ret);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int dic[26];\\n        \\n        for(int i=0; i<26; i++)\\n            dic[i]=i+1;\\n        \\n        for(int i=0; i<vals.size(); i++)\\n            dic[chars[i]-\\'a\\']=vals[i];\\n        \\n        int n = s.size();\\n        int dp[n];\\n        int sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i]=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3383715,
                "title": "easy-solution-beginners-friendly-solution-kadane-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n             unordered_map<char,int> mp;                      \\n             \\n             for(int i = 0; i < chars.size();i++){\\n                   mp[chars[i]] = vals[i];\\n             }\\n\\n             int max_so_far = 0;\\n             int max_val = 0;\\n\\n             for(int i = 0; i < s.size();i++){\\n                   if(mp.find(s[i]) != mp.end()){\\n                        max_so_far += mp[s[i]];\\n                   }else{\\n                       max_so_far += ((s[i]-\\'0\\')-48);                 // (\\'a\\'-\\'0\\')-48 == 1;\\n             }  \\n                   if(max_so_far > max_val){          // (\\'a\\'-\\'0\\')-48 == 1;\\n                         max_val = max_so_far;                                             // if not in chars so, using \\n                                                                                          // corresponding index value.  \\n\\n                                                          // if it is negative then its better to go with 0 \\n                                                         // that is  empty string \"\".\\n                        \\n                   }\\n                   if(max_so_far < 0){\\n                        max_so_far = 0;\\n                   }\\n             }\\n\\n             return max_val;\\n             \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n             unordered_map<char,int> mp;                      \\n             \\n             for(int i = 0; i < chars.size();i++){\\n                   mp[chars[i]] = vals[i];\\n             }\\n\\n             int max_so_far = 0;\\n             int max_val = 0;\\n\\n             for(int i = 0; i < s.size();i++){\\n                   if(mp.find(s[i]) != mp.end()){\\n                        max_so_far += mp[s[i]];\\n                   }else{\\n                       max_so_far += ((s[i]-\\'0\\')-48);                 // (\\'a\\'-\\'0\\')-48 == 1;\\n             }  \\n                   if(max_so_far > max_val){          // (\\'a\\'-\\'0\\')-48 == 1;\\n                         max_val = max_so_far;                                             // if not in chars so, using \\n                                                                                          // corresponding index value.  \\n\\n                                                          // if it is negative then its better to go with 0 \\n                                                         // that is  empty string \"\".\\n                        \\n                   }\\n                   if(max_so_far < 0){\\n                        max_so_far = 0;\\n                   }\\n             }\\n\\n             return max_val;\\n             \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383345,
                "title": "very-fast-and-easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<chars.length();++i){\\n            map.put(chars.charAt(i),vals[i]);\\n        }\\n        \\n        \\n        int curr = 0;\\n        int max = 0;\\n        for(int i=0;i<s.length();++i){\\n            if(map.containsKey(s.charAt(i))){\\n                curr += map.get(s.charAt(i));\\n               if(curr<0){\\n                   curr = 0;\\n               }\\n            }else{\\n                curr += (s.charAt(i) - \\'a\\') + 1;\\n            }\\n            max = Math.max(max,curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<chars.length();++i){\\n            map.put(chars.charAt(i),vals[i]);\\n        }\\n        \\n        \\n        int curr = 0;\\n        int max = 0;\\n        for(int i=0;i<s.length();++i){\\n            if(map.containsKey(s.charAt(i))){\\n                curr += map.get(s.charAt(i));\\n               if(curr<0){\\n                   curr = 0;\\n               }\\n            }else{\\n                curr += (s.charAt(i) - \\'a\\') + 1;\\n            }\\n            max = Math.max(max,curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380234,
                "title": "using-kadane-s-algorithm-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int>m;\\n\\n        int sum = 0;\\n        int ans = 0;\\n\\n        for(int i=0; i<chars.size(); i++)\\n        {\\n            if(m.find(chars[i]) == m.end())\\n            {\\n                m[chars[i]] = vals[i];\\n            }\\n        }\\n            for(int i=0; i<s.size(); i++)\\n            {\\n                if(m.find(s[i]) != m.end())\\n                {\\n                    sum+=m[s[i]];\\n                }\\n                else\\n                {\\n                    sum += (int)(s[i]-\\'a\\')+1;\\n                }\\n                    if(sum<0)\\n                    {\\n                        sum = 0;\\n                    }\\n                    else\\n                    {\\n                        ans = max(ans,sum);\\n                    }\\n                \\n            }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int>m;\\n\\n        int sum = 0;\\n        int ans = 0;\\n\\n        for(int i=0; i<chars.size(); i++)\\n        {\\n            if(m.find(chars[i]) == m.end())\\n            {\\n                m[chars[i]] = vals[i];\\n            }\\n        }\\n            for(int i=0; i<s.size(); i++)\\n            {\\n                if(m.find(s[i]) != m.end())\\n                {\\n                    sum+=m[s[i]];\\n                }\\n                else\\n                {\\n                    sum += (int)(s[i]-\\'a\\')+1;\\n                }\\n                    if(sum<0)\\n                    {\\n                        sum = 0;\\n                    }\\n                    else\\n                    {\\n                        ans = max(ans,sum);\\n                    }\\n                \\n            }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380090,
                "title": "c-simple-maximizing-subarray-sum-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> cost(26,0); //freq array to store cost of each characters\\n        for(int i=1;i<=26;i++) cost[i-1]=i; //storing cost of characters which are not in {chars}\\n        for(int i=0;i<chars.size();i++) cost[chars[i]-\\'a\\']=vals[i];//which are there in {chars}\\n        int mx=0,sm=0; //This is similar maximum subarray sum\\n        for(int i=0;i<s.size();i++){\\n            sm+=cost[s[i]-\\'a\\'];\\n            if(sm<0) sm=0;\\n            mx=max(mx,sm);\\n        }\\n        return mx;\\n    }\\n};\\n```\\n**Hey, Upvote if you liked it !!**",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> cost(26,0); //freq array to store cost of each characters\\n        for(int i=1;i<=26;i++) cost[i-1]=i; //storing cost of characters which are not in {chars}\\n        for(int i=0;i<chars.size();i++) cost[chars[i]-\\'a\\']=vals[i];//which are there in {chars}\\n        int mx=0,sm=0; //This is similar maximum subarray sum\\n        for(int i=0;i<s.size();i++){\\n            sm+=cost[s[i]-\\'a\\'];\\n            if(sm<0) sm=0;\\n            mx=max(mx,sm);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379387,
                "title": "intuitive-the-basis-is-maximizing-subarray-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def value(self, ch):\\n        return ord(ch) - ord(\\'a\\') + 1\\n\\n    def cost(self, ch, chars, vals):\\n        idx = 0\\n        for char in chars:\\n            if ch == char:\\n                return vals[idx]\\n            idx += 1\\n        return 0\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        max_value = 0\\n        max_cost = 0\\n        for ch in s:\\n            if ch not in chars:\\n                max_cost += self.value(ch)\\n            else:\\n                max_cost += self.cost(ch, chars, vals)\\n            max_cost = max(0, max_cost)\\n            max_value = max(max_value, max_cost)\\n        return max_value\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def value(self, ch):\\n        return ord(ch) - ord(\\'a\\') + 1\\n\\n    def cost(self, ch, chars, vals):\\n        idx = 0\\n        for char in chars:\\n            if ch == char:\\n                return vals[idx]\\n            idx += 1\\n        return 0\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        max_value = 0\\n        max_cost = 0\\n        for ch in s:\\n            if ch not in chars:\\n                max_cost += self.value(ch)\\n            else:\\n                max_cost += self.cost(ch, chars, vals)\\n            max_cost = max(0, max_cost)\\n            max_value = max(max_value, max_cost)\\n        return max_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379081,
                "title": "explained-o-n-time-o-1-memory-c-solution",
                "content": "# Intuition\\nThis is a standard maximum sum subarray problem, the only variation here is we need a char value map.\\n\\n# Approach\\n1. Initialize the char->value map with the given values first.\\n2. Fill in the values of the rest of the characters.\\n\\nMax Subarray problem on string s:\\n\\n3. keep a cumulative sum of the char values in the array using the map\\n4. If at any point the sum drops below zero then it\\'s cheaper to ignore the previous part of the string and start at the current index.\\n5. Keep track of cumulative sum values and return the max.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> mp(26, INT32_MIN);\\n        for (int i = 0; i < chars.size(); ++i) mp[chars[i] - \\'a\\'] = vals[i];\\n        for (int i = 0; i < 26; ++i) if (mp[i] == INT32_MIN) mp[i] = i + 1;\\n\\n        int ans = 0, sum = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            sum = max(0, sum + mp[s[i] - \\'a\\']);\\n            ans = max(ans, sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> mp(26, INT32_MIN);\\n        for (int i = 0; i < chars.size(); ++i) mp[chars[i] - \\'a\\'] = vals[i];\\n        for (int i = 0; i < 26; ++i) if (mp[i] == INT32_MIN) mp[i] = i + 1;\\n\\n        int ans = 0, sum = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            sum = max(0, sum + mp[s[i] - \\'a\\']);\\n            ans = max(ans, sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378840,
                "title": "c-simple-sliding-window-2-pointer-solution-same-old-concepts-of-sliding-window",
                "content": "# Approach\\nAs the sum is positive we will keep on moving forward, because we can add positive sum to the future answer. But as the current sum gets negative we cannot add that sum into the future answer (as the sum has to be maximum i.e. either positive or 0 when no char it taken into consideration).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i = 0, j = 0;\\n        int currcost = 0;\\n        int ans = 0;\\n        vector<int>vec(26, INT_MIN);\\n        for(int k = 0; k<chars.size(); k++){\\n            vec[chars[k]-\\'a\\'] = vals[k];\\n        }\\n\\n        // cout<<j<<endl;\\n        while(j<s.size()){\\n            cout<<j<<endl;\\n            if(vec[s[j]-\\'a\\']!=INT_MIN){\\n                currcost+=vec[s[j]-\\'a\\'];\\n            }\\n\\n            else{\\n                currcost+=(s[j]-\\'a\\'+1);\\n            }\\n\\n            while(i<=j and currcost<0){\\n                if(vec[s[i]-\\'a\\']!=INT_MIN){\\n                    currcost-=vec[s[i]-\\'a\\'];\\n                }\\n\\n                else{\\n                    currcost-=(s[i]-\\'a\\'+1);\\n                }\\n                i++;\\n            }\\n\\n            ans = max(ans, currcost);\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i = 0, j = 0;\\n        int currcost = 0;\\n        int ans = 0;\\n        vector<int>vec(26, INT_MIN);\\n        for(int k = 0; k<chars.size(); k++){\\n            vec[chars[k]-\\'a\\'] = vals[k];\\n        }\\n\\n        // cout<<j<<endl;\\n        while(j<s.size()){\\n            cout<<j<<endl;\\n            if(vec[s[j]-\\'a\\']!=INT_MIN){\\n                currcost+=vec[s[j]-\\'a\\'];\\n            }\\n\\n            else{\\n                currcost+=(s[j]-\\'a\\'+1);\\n            }\\n\\n            while(i<=j and currcost<0){\\n                if(vec[s[i]-\\'a\\']!=INT_MIN){\\n                    currcost-=vec[s[i]-\\'a\\'];\\n                }\\n\\n                else{\\n                    currcost-=(s[i]-\\'a\\'+1);\\n                }\\n                i++;\\n            }\\n\\n            ans = max(ans, currcost);\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1850270,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1850487,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1850416,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1914288,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1850488,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1850305,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            }
        ]
    },
    {
        "title": "Make K-Subarray Sums Equal",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>arr</code> and an integer <code>k</code>. The array <code>arr</code> is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.</p>\n\n<p>You can do the following operation any number of times:</p>\n\n<ul>\n\t<li>Pick any element from <code>arr</code> and increase or decrease it by <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the minimum number of operations such that the sum of each <strong>subarray</strong> of length </em><code>k</code><em> is equal</em>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous part of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,4,1,3], k = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> we can do one operation on index 1 to make its value equal to 3.\nThe array after the operation is [1,3,1,3]\n- Subarray starts at index 0 is [1, 3], and its sum is 4 \n- Subarray starts at index 1 is [3, 1], and its sum is 4 \n- Subarray starts at index 2 is [1, 3], and its sum is 4 \n- Subarray starts at index 3 is [3, 1], and its sum is 4 \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,5,5,7], k = 3\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.\nThe array after the operations is [5,5,5,5]\n- Subarray starts at index 0 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 1 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 2 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 3 is [5, 5, 5], and its sum is 15 \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3366373,
                "title": "k-cycles",
                "content": "The sum of all subarrays of size `k` is equal if:\\n- `arr[i] == arr[i + k]`\\n- `arr[i] == arr[i + 2 * k]`\\n- and so on.\\n    \\nAs we roll a window of size `k`, we remove element `arr[i]` and add element `arr[i + k]`.\\n\\nFor the sum to stay the same, the removed and added element must be the same. This can be also proven by a contradiction. \\n\\nSo, for each position `i`, we collect all elements in the `k`-cycle.\\n    \\nThen, we determine the median and perform operations to make all elements equal to that median. \\n\\n**C++**  \\nWe use `nth_element` instead of sorting to find a median in O(n) in an average case.\\n```cpp\\nlong long makeSubKSumEqual(vector<int>& arr, int k) {\\n    long long sz = arr.size(), res = 0;\\n    for (int i = 0; i < k; ++i) {\\n        vector<int> cycle;\\n        for (int j = i; arr[j] != 0; j = (j + k) % sz) {\\n            cycle.push_back(arr[j]);\\n            arr[j] = 0;\\n        }\\n        nth_element(begin(cycle), begin(cycle) + cycle.size() / 2, end(cycle));\\n        for (int n : cycle)\\n            res += abs(n - cycle[cycle.size() / 2]);\\n    }\\n    return res;\\n}\\n```\\n\\n**Python 3**\\nOne-liner just for fun. Note that here we use `gcd(len(a), k)` to get all elements in the cycle instead of looping over a circular array.\\n```python\\nclass Solution:\\n    def makeSubKSumEqual(self, a: List[int], k: int) -> int:\\n        return sum(\\n            sum(abs(n - c[len(c) // 2]) for n in c)\\n            for c in [sorted(a[i::gcd(len(a), k)]) for i in range(gcd(len(a), k))]\\n        )\\n```\\n\\n**Java**\\nThe complexity is O(sort); we use sort because Java does not provide a standard quickselect implementation.\\n```java\\npublic long makeSubKSumEqual(int[] arr, int k) {\\n    long res = 0;\\n    for (int i = 0; i < k; ++i) {\\n        List<Integer> cycle = new ArrayList<>();\\n        for (int j = i; arr[j] != 0; j = (j + k) % arr.length) {\\n            cycle.add(arr[j]);\\n            arr[j] = 0;\\n        }\\n        Collections.sort(cycle);\\n        for (int n : cycle)\\n            res += Math.abs(n - cycle.get(cycle.size() / 2));\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nlong long makeSubKSumEqual(vector<int>& arr, int k) {\\n    long long sz = arr.size(), res = 0;\\n    for (int i = 0; i < k; ++i) {\\n        vector<int> cycle;\\n        for (int j = i; arr[j] != 0; j = (j + k) % sz) {\\n            cycle.push_back(arr[j]);\\n            arr[j] = 0;\\n        }\\n        nth_element(begin(cycle), begin(cycle) + cycle.size() / 2, end(cycle));\\n        for (int n : cycle)\\n            res += abs(n - cycle[cycle.size() / 2]);\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def makeSubKSumEqual(self, a: List[int], k: int) -> int:\\n        return sum(\\n            sum(abs(n - c[len(c) // 2]) for n in c)\\n            for c in [sorted(a[i::gcd(len(a), k)]) for i in range(gcd(len(a), k))]\\n        )\\n```\n```java\\npublic long makeSubKSumEqual(int[] arr, int k) {\\n    long res = 0;\\n    for (int i = 0; i < k; ++i) {\\n        List<Integer> cycle = new ArrayList<>();\\n        for (int j = i; arr[j] != 0; j = (j + k) % arr.length) {\\n            cycle.add(arr[j]);\\n            arr[j] = 0;\\n        }\\n        Collections.sort(cycle);\\n        for (int n : cycle)\\n            res += Math.abs(n - cycle.get(cycle.size() / 2));\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366442,
                "title": "python3-find-median-of-each-gcd-defined-subarray-w-examples",
                "content": "# First Thought\\nAny na\\xEFve checking algorithm would not work here as both `k` and `n (= arr.length)` could be up to $$10^5$$.\\n\\nSo, how can we come up with a better algorithm with improved time complexity?\\n\\n# Key Intuition\\nLet\\u2019s first look at a toy example by assuming `k = 3`. Because the problem requires the sum of each subarray of length `k` to be equal, we then need to have `arr[0] + arr[1] + arr[2] = arr[1] + arr[2] + arr[3]`, which implies that `arr[0] = arr[3]`. Essentially, this is saying that every `k`-th element of `arr` needs to be equal after all operations.\\n\\nThere is one caveat yet to make the argument complete: In this problem `arr` is not only a regular array but also a circular array. Suppose `n = 6` and `k = 4`, we need to have every `gcd(n, k) = gcd(6, 4) = 2`-th element of `arr` to be equal after all operations.\\n\\n# Representative Examples\\n![LC2607_resize.jpeg](https://assets.leetcode.com/users/images/24f7cdb9-ced7-4786-b22d-1735f9acb90f_1680366540.215105.jpeg)\\n\\n# Approach\\nFirst, we compute the greatest common divisor of `n` and `k`, denoted as `gcd`. For every `gcd`-th element of `arr`, we store it in a temporary array `tmp`, such that the problem reduces to finding the minimum number operations to make all elements in each of `tmp` equal.\\n\\nFor this sub-problem, we can sort the subarray `tmp` and find its median, which contributes to the final `ans` after operations.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$, could be improved to $$O(n)$$ on average;\\n\\n- Space complexity: $$O(n)$$.\\n\\n**Please upvote if you find this solution helpful. Thanks!**\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        gcd = math.gcd(n, k)\\n        ans = 0\\n        for i in range(gcd):\\n            tmp = sorted([arr[j] for j in range(i, n, gcd)])\\n            median = tmp[len(tmp) // 2]\\n            ans += sum(abs(num - median) for num in tmp)\\n        return ans\\n```\\n\\n# Follow-up (Bonus)\\nWe can potentially improve the average time complexity by applying quick-select to each of the subarray problem in finding the median.",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        gcd = math.gcd(n, k)\\n        ans = 0\\n        for i in range(gcd):\\n            tmp = sorted([arr[j] for j in range(i, n, gcd)])\\n            median = tmp[len(tmp) // 2]\\n            ans += sum(abs(num - median) for num in tmp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367765,
                "title": "explaining-like-you-are-five-years-old",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n[1,4,1,3]\\n\\nIt is a Circular Array, What are the possible subarray sums \\n```\\na. 1 + 4 = 5\\nb.     4 + 1 = 5\\nc.         1 + 3 = 4\\nd.             3 + 1 = 4\\n```\\n\\nFrom above you can understand the num which goes in should be equal to number which goes out.\\n\\n1 should be equal to 1\\n3 should be equal to 4\\n\\nIn case b, 1 (index = 2) gets in the window  and 1 (index = 0) gets out which are same.\\nIn case c,  3 (index = 3) gets in the window and 4 (index = 1) gets out which are not same.\\n\\n\\nHence we could have grouped them [1, 1] [3, 4] in these buckets and same they should be same to make subarray equal.\\n\\n**suppose k is 2**\\n\\n\\nWe need to know as array is circular, when we complete run in next run the start index will be different or not if yes what are the element which should be equal - That\\'s where GCD comes in.\\n\\n\\n```\\n        [1, 4, 1, 3]\\nstep 1   ^     ^ \\n\\n```\\n\\n\\n`^` these are pointers now if the array is circular and you take the pointer skipping one element the pointers will end again on 1 and 1, \\n\\ngcd (4, 2) = 2 which means there will be 2 buckets and every number will be put in after skipping one.\\n\\nbucket 1 = [1, 1]\\nbucket 2 = [3, 4]\\n\\n\\n**suppose k is 3**\\n```\\n        [2, 5, 5, 7]\\nstep 1   ^        ^\\nstep 2      ^  ^\\n```\\nThese where we use gcd to find buckets gcd (4, 3) = 1 which means there will be one bucket and every other number will be in it\\n\\nbucket 1 =  [2, 5, 5, 7]\\n\\n\\nNow the simplest task making each bucket equal\\n- The optimal way to do this is use gready approach and use median to find minimum operations to make numbers equal\\n\\n#### For example 1\\n\\n\\nmedian = sorted([4, 3]) = [3, 4] = 4\\nget absolute difference from all numbers in array which will be one (3 - 4) + (4 - 4) = 1\\n\\n**You have to do same operation on all buckets but elements in bucket 1 are same it will just give 0**\\n\\n#### For example 2\\n\\nmedian = sorted([2, 5, 5, 7]) = [2, 5, 5, 7] = 5\\nget absolute difference from all numbers in array which will be one (2 - 5) + (5 - 5) + (5 - 5)  + (7 - 5) = 5\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n`O(N) + O(K * KlogK)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(N)`\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n\\n        no_of_buckets = gcd (k, n)\\n        buckets = defaultdict(list)\\n\\n        for ind, num in enumerate(arr):\\n            buckets[ind % no_of_buckets].append(num)\\n\\n        result = 0\\n        for bucket_number, bucket in buckets.items():\\n            sorted_bucket = sorted(bucket)\\n            m = len(sorted_bucket)\\n            median = sorted_bucket[(m)//2]\\n            \\n            for num in bucket:\\n                result += abs(median - num)\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\na. 1 + 4 = 5\\nb.     4 + 1 = 5\\nc.         1 + 3 = 4\\nd.             3 + 1 = 4\\n```\n```\\n        [1, 4, 1, 3]\\nstep 1   ^     ^ \\n\\n```\n```\\n        [2, 5, 5, 7]\\nstep 1   ^        ^\\nstep 2      ^  ^\\n```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n\\n        no_of_buckets = gcd (k, n)\\n        buckets = defaultdict(list)\\n\\n        for ind, num in enumerate(arr):\\n            buckets[ind % no_of_buckets].append(num)\\n\\n        result = 0\\n        for bucket_number, bucket in buckets.items():\\n            sorted_bucket = sorted(bucket)\\n            m = len(sorted_bucket)\\n            median = sorted_bucket[(m)//2]\\n            \\n            for num in bucket:\\n                result += abs(median - num)\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372935,
                "title": "explained-gcd-median-very-simple-and-easy-to-understand-solution",
                "content": "# Approach \\nWe have to make equal each ith element and (i+k)th element here,  so that\\nwe awill get same value at eleast once on each window of size k.\\n\\nNo here is a ctach, when the arr.size is not divisible by k, we need to \\ncheck what is the max possible size that can be repeated in the \\narray which confirm presence of same element in each window.\\nTo do this we need to take the most common element that devides both k and \\narr.size => which is equal to their gcd.\\n\\nSo now the steps to the solution will be :\\n1. Take gcd as the new value of k as the gcd of k & arr.size()\\n2. Then iterate from 0 to k, and on each iteration collect the i + k, i +2k and so on ..\\n3. Then sort the elements collected and get the midian values. As to get a min cumulative summ midian can be used to equate with all other elements.\\n4. Make all elements equal to median and evaluate the operation cost for the same.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        k = __gcd(k, (int)arr.size()); //re-evaluate k as the gcd of both k & arr.size\\n        \\n        for(int i = 0; i < k; ++i){\\n            vector<int> v;\\n            for(int j = i; j < arr.size(); j += k) v.push_back(arr[j]);  //collect each ith number\\n            sort(v.begin(), v.end());    //sort the collection to get median\\n            int mn = v[v.size()/2];      //get the median value\\n            for(int j = i; j < arr.size(); j += k) ans += abs(mn - arr[j]); // evaluate the ans by making all values equal to median\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        k = __gcd(k, (int)arr.size()); //re-evaluate k as the gcd of both k & arr.size\\n        \\n        for(int i = 0; i < k; ++i){\\n            vector<int> v;\\n            for(int j = i; j < arr.size(); j += k) v.push_back(arr[j]);  //collect each ith number\\n            sort(v.begin(), v.end());    //sort the collection to get median\\n            int mn = v[v.size()/2];      //get the median value\\n            for(int j = i; j < arr.size(); j += k) ans += abs(mn - arr[j]); // evaluate the ans by making all values equal to median\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367285,
                "title": "easy-video-explanation-hindi-o-n-log-n-c",
                "content": "I would sugget you to watch the video and then read the code for better understanding \\nHindi Video Explanation :- [https://youtu.be/4fvwsGdBdok]()\\n\\n# Complexity\\n- Time complexity:\\n- O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n long long find(int val,vector<int>&arr){\\n     \\n     //findind the cost of making all values equal to val\\n     //in arr\\n     long long ans = 0;\\n     \\n     for(auto&x:arr){\\n         long long cur = abs(x-val);\\n         ans += cur;\\n     }\\n     \\n     return ans;\\n }\\n\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n       \\n        int n = arr.size();\\n        long long ans = 1e18;\\n         \\n             ans = 0;\\n            vector<int>vis(n);\\n             \\n            for(int i = 0;i<n;++i){\\n                if(vis[i])continue;\\n                \\n                \\n                vector<int>temp;\\n                long long tot = 0;\\n                int idx = i;\\n                \\n                //we are starting from index \\'i\\'\\n                //we will run while loop until we reach to some visited node\\n                \\n                while(!vis[idx]){\\n                    long long val = arr[idx];\\n                    vis[idx]++;\\n                    idx += k;\\n                    idx%=n;\\n                    tot += val;\\n                    //adding the values of cycle in temp array\\n                    temp.push_back(val);\\n                }\\n                \\n                long long cur = 0;\\n                \\n                //sorting the temp array because it is optimal to make \\n                //all elements equal to middle element of sorted arry\\n                sort(temp.begin(),temp.end());\\n                int sz = temp.size();\\n                \\n                //if array if of odd size then we have just 1 middle element\\n                if(sz%2){\\n                    int mid = (sz/2);\\n                    cur = find(temp[mid],temp);\\n                }\\n                else{\\n                    //for even size we have two middle values\\n                    int mid = (sz/2);\\n                    cur = find(temp[mid],temp);\\n                    cur = min(cur,find(temp[mid-1],temp));\\n                }\\n                 \\n                ans += cur;\\n            }\\n         \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n long long find(int val,vector<int>&arr){\\n     \\n     //findind the cost of making all values equal to val\\n     //in arr\\n     long long ans = 0;\\n     \\n     for(auto&x:arr){\\n         long long cur = abs(x-val);\\n         ans += cur;\\n     }\\n     \\n     return ans;\\n }\\n\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n       \\n        int n = arr.size();\\n        long long ans = 1e18;\\n         \\n             ans = 0;\\n            vector<int>vis(n);\\n             \\n            for(int i = 0;i<n;++i){\\n                if(vis[i])continue;\\n                \\n                \\n                vector<int>temp;\\n                long long tot = 0;\\n                int idx = i;\\n                \\n                //we are starting from index \\'i\\'\\n                //we will run while loop until we reach to some visited node\\n                \\n                while(!vis[idx]){\\n                    long long val = arr[idx];\\n                    vis[idx]++;\\n                    idx += k;\\n                    idx%=n;\\n                    tot += val;\\n                    //adding the values of cycle in temp array\\n                    temp.push_back(val);\\n                }\\n                \\n                long long cur = 0;\\n                \\n                //sorting the temp array because it is optimal to make \\n                //all elements equal to middle element of sorted arry\\n                sort(temp.begin(),temp.end());\\n                int sz = temp.size();\\n                \\n                //if array if of odd size then we have just 1 middle element\\n                if(sz%2){\\n                    int mid = (sz/2);\\n                    cur = find(temp[mid],temp);\\n                }\\n                else{\\n                    //for even size we have two middle values\\n                    int mid = (sz/2);\\n                    cur = find(temp[mid],temp);\\n                    cur = min(cur,find(temp[mid-1],temp));\\n                }\\n                 \\n                ans += cur;\\n            }\\n         \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366388,
                "title": "best-concise-solution-and-easy-to-understand-c",
                "content": "# Approach\\nIf n is divisible by k then perform the following otherwise update k to gcd of n and k (by observation)\\n\\nNow , for every element at a gap of k make them equal by subtracting all these numbers by their median we can do that by sorting all the elements and taking its middle to get the median\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        \\n        //due to circular array the gap k will be converted to gcd of\\n        // k and n by observation (check for n = 15 , k = 6 , and find out)\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            //taking the mid value of the sorted array to get the \\n            //median as it will require minimum operation to convert \\n            //all elements to the medain value\\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        \\n        //due to circular array the gap k will be converted to gcd of\\n        // k and n by observation (check for n = 15 , k = 6 , and find out)\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            //taking the mid value of the sorted array to get the \\n            //median as it will require minimum operation to convert \\n            //all elements to the medain value\\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366378,
                "title": "java-python-3-divide-into-sequences-such-that-every-two-consecutive-items-s-distance-is-gcd",
                "content": "**Intuition:**\\nAll `k`-size subarrays are equal  => \\n`sum(arr[0,...,k- 1]) == sum(arr[1,...,k])` =>\\n`arr[0] == arr[k]`\\n\\nsimilarly, we can conclude that `arr[i] = arr[i + k]`, further more, `arr` is **circular** array, hence we need stronger condition than `arr[i] = arr[i + k]`: only `gcd(k, arr.length)` to guarantee both **circular** and all `k`-size subarrays are equal.\\n\\n----\\n\\n1. Compute the `gcd` of `arr.length`and `k`;\\n2. The numbers in `arr` must be equal if their indices differenece is the multiple of the aforementioned `gcd`, in order to make all of the k-size subarray sums are equal; Therefore, in `arr` select each item every `gcd` index difference to construct a sequence, and there are totally `arr.length / gcd` such sequences;\\n3. In order to make the sequence equal, we need to get each sequence sorted and compute the needed minimum opertations.\\n\\n```java\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int gcd = gcd(arr.length, k);\\n        long minOps = 0;\\n        for (int i = 0; i < gcd; ++i) {\\n            minOps += getOperationsCount(arr, i, gcd);\\n        }\\n        return minOps;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n    private long getOperationsCount(int[] arr, int start, int gap) {\\n        int n = arr.length, m = n / gap;\\n        long min = Long.MAX_VALUE, sum = 0, cur = 0;\\n        int[] a = new int[m];\\n        for (int i = start, k = 0; i < n; i += gap, ++k) {\\n            a[k] = arr[i];\\n            sum += a[k];\\n        }\\n        Arrays.sort(a);\\n        for (int i = 0; i < m; ++i) {\\n            min = Math.min(min, (1L * i * a[i] - cur) + ((sum - cur) - 1L * (m - i) * a[i]));\\n            cur += a[i];\\n        }\\n        return min;\\n    }\\n```\\n```python\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        def getOperationsCount(arr: List[int]) -> int:\\n            sm, n = sum(arr), len(arr)\\n            mi = inf\\n            cur = 0\\n            for i, num in enumerate(sorted(arr)):\\n                mi = min(mi, (i * num - cur) + ((sm - cur) - (n - i) * num))\\n                cur += num\\n            return mi    \\n        \\n        gcd = math.gcd(len(arr), k)\\n        return sum(getOperationsCount(arr[i :: gcd]) for i in range(gcd))\\n```\\n\\nThe above codes can be simplified as follows:\\n\\n```java\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int gcd = gcd(arr.length, k);\\n        long minOps = 0;\\n        for (int i = 0; i < gcd; ++i) {\\n            minOps += getOperationsCount(arr, i, gcd);\\n        }\\n        return minOps;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n    private long getOperationsCount(int[] arr, int start, int gap) {\\n        int n = arr.length, m = n / gap;\\n        long sum = 0;\\n        int[] a = new int[m];\\n        for (int i = start, k = 0; i < n; i += gap, ++k) {\\n            a[k] = arr[i];\\n        }\\n        Arrays.sort(a);\\n        for (int i = 0, mid = m / 2; i < m; ++i) {\\n            sum += Math.abs(a[i] - a[mid]);\\n        }\\n        return sum;\\n    }\\n```\\n```python\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        def getOperationsCount(arr: List[int]) -> int:\\n            return sum(abs(a - arr[len(arr) // 2]) for a in arr)    \\n        \\n        gcd = math.gcd(len(arr), k)\\n        return sum(getOperationsCount(sorted(arr[i :: gcd])) for i in range(gcd))\\n```\\n\\n**Analysis:**\\n\\nSorting is the major part of the time cost, therefore\\n\\nTime: `O(nlogn)`, space: `O(n / gcd(n, k))`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int gcd = gcd(arr.length, k);\\n        long minOps = 0;\\n        for (int i = 0; i < gcd; ++i) {\\n            minOps += getOperationsCount(arr, i, gcd);\\n        }\\n        return minOps;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n    private long getOperationsCount(int[] arr, int start, int gap) {\\n        int n = arr.length, m = n / gap;\\n        long min = Long.MAX_VALUE, sum = 0, cur = 0;\\n        int[] a = new int[m];\\n        for (int i = start, k = 0; i < n; i += gap, ++k) {\\n            a[k] = arr[i];\\n            sum += a[k];\\n        }\\n        Arrays.sort(a);\\n        for (int i = 0; i < m; ++i) {\\n            min = Math.min(min, (1L * i * a[i] - cur) + ((sum - cur) - 1L * (m - i) * a[i]));\\n            cur += a[i];\\n        }\\n        return min;\\n    }\\n```\n```python\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        def getOperationsCount(arr: List[int]) -> int:\\n            sm, n = sum(arr), len(arr)\\n            mi = inf\\n            cur = 0\\n            for i, num in enumerate(sorted(arr)):\\n                mi = min(mi, (i * num - cur) + ((sm - cur) - (n - i) * num))\\n                cur += num\\n            return mi    \\n        \\n        gcd = math.gcd(len(arr), k)\\n        return sum(getOperationsCount(arr[i :: gcd]) for i in range(gcd))\\n```\n```java\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int gcd = gcd(arr.length, k);\\n        long minOps = 0;\\n        for (int i = 0; i < gcd; ++i) {\\n            minOps += getOperationsCount(arr, i, gcd);\\n        }\\n        return minOps;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n    private long getOperationsCount(int[] arr, int start, int gap) {\\n        int n = arr.length, m = n / gap;\\n        long sum = 0;\\n        int[] a = new int[m];\\n        for (int i = start, k = 0; i < n; i += gap, ++k) {\\n            a[k] = arr[i];\\n        }\\n        Arrays.sort(a);\\n        for (int i = 0, mid = m / 2; i < m; ++i) {\\n            sum += Math.abs(a[i] - a[mid]);\\n        }\\n        return sum;\\n    }\\n```\n```python\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        def getOperationsCount(arr: List[int]) -> int:\\n            return sum(abs(a - arr[len(arr) // 2]) for a in arr)    \\n        \\n        gcd = math.gcd(len(arr), k)\\n        return sum(getOperationsCount(sorted(arr[i :: gcd])) for i in range(gcd))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366408,
                "title": "subarray-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n = arr.size();\\n        k = gcd(n,k);\\n        ll ans = 0;\\n        for(ll i = 0; i < k; i++)\\n        {\\n            vector <ll> vec;\\n            for(ll j = i; j < n; j+=k)\\n                vec.push_back(arr[j]);\\n            sort(vec.begin(),vec.end());\\n            ll mid = vec.size()/2;\\n            for(ll ind = 0; ind < vec.size(); ind++)\\n                ans+=abs(vec[mid]-vec[ind]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Combinatorics"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n = arr.size();\\n        k = gcd(n,k);\\n        ll ans = 0;\\n        for(ll i = 0; i < k; i++)\\n        {\\n            vector <ll> vec;\\n            for(ll j = i; j < n; j+=k)\\n                vec.push_back(arr[j]);\\n            sort(vec.begin(),vec.end());\\n            ll mid = vec.size()/2;\\n            for(ll ind = 0; ind < vec.size(); ind++)\\n                ans+=abs(vec[mid]-vec[ind]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3366625,
                "title": "day-366-python-java-c-explained-intuition-algorithm-100-beats-o-n-o-1",
                "content": "# Please Upvote as it really motivates me\\n\\n##### \\u2022\\tThe problem statement is to make the sum of all subarrays of length k equal changing the elements of the array. The approach used in this problem is to group the elements of the array into k subarrays based on their remainder when divided by k. Then, for each subarray, the median value is calculated and the absolute difference between each element in the subarray and the median is added to the total answer.\\n\\n##### \\u2022\\tHere is the step-by-step algorithm:\\n##### \\u2022\\tInitialize a list of k subarrays.\\n##### \\u2022\\tCalculate the greatest common divisor of n and k, where n is the length of the input array.\\n##### \\u2022\\tGroup the elements of the input array into k subarrays based on their remainder when divided by k.\\n##### \\u2022\\tFor each subarray, sort the elements and calculate the median value.\\n##### \\u2022\\tFor each element in the subarray, calculate the absolute difference between the element and the median value, and add it to the total answer.\\n##### \\u2022\\tReturn the total answer.\\n\\n##### \\u2022\\tThe intuition behind this problem is that by grouping the elements into subarrays based on their remainder when divided by k, we can ensure that each subarray has the same number of elements. Then, by calculating the median value of each subarray, we can find a representative value that is close to the center of the subarray. By minimizing the absolute difference between each element and the median value, we can make the sum of all subarrays of length k equal.\\n\\n\\n\\n# Code\\n```python []\\nclass Solution:\\n    def makeSubKSumEqual(self,arr, k):\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            v[i].sort()\\n            x = v[i][len(v[i]) // 2]\\n            for j in v[i]:\\n                ans += abs(x - j)\\n        return ans\\n\\n    def gcd(a, b):\\n        if b == 0:\\n            return a\\n        return gcd(b, a % b)\\n```\\n\\n```java []\\nclass Solution{\\n    public static long makeSubKSumEqual(int[] arr, int k) {\\n    int n = arr.length;\\n    List<Integer>[] v = new ArrayList[n + 1];\\n    for (int i = 0; i <= n; i++) {\\n        v[i] = new ArrayList<>();\\n    }\\n    k = gcd(n, k);\\n    for (int i = 0; i < n; i++) {\\n        v[i % k].add(arr[i]);\\n    }\\n    long ans = 0;\\n    for (int i = 0; i < k; i++) {\\n        Collections.sort(v[i]);\\n        int x = v[i].get(v[i].size() / 2);\\n        for (int j : v[i]) {\\n            ans += Math.abs(x - j);\\n        }\\n    }\\n    return ans;\\n}\\n\\nprivate static int gcd(int a, int b) {\\n    if (b == 0) {\\n        return a;\\n    }\\n    return gcd(b, a % b);\\n}\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size() ;\\n        vector<int>v[n+1] ;\\n        k = __gcd(n , k) ;\\n        for(int i = 0 ; i < n ; ++i)\\n            v[i%k].push_back(arr[i]) ;\\n        long long ans = 0 ;\\n        for(int i = 0 ; i < k ; ++i)\\n        {\\n            sort(v[i].begin() , v[i].end()) ;\\n            int x = v[i][v[i].size() / 2] ;\\n            for(auto &j : v[i])\\n                ans += abs(x-j) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n\\n\\n\\n# Complexity\\n\\n##### \\u2022\\tThe time complexity (TC) of this algorithm is O(n log n), where n is the length of the input array. This is because the algorithm involves sorting each subarray, which takes O(k log k) time, where k is the size of each subarray. Since there are n/k subarrays, the total time complexity is O(n log k). However, since k is the greatest common divisor of n and k, it is at most n/2. Therefore, the time complexity can be simplified to O(n log n).\\n\\n##### \\u2022\\tThe space complexity (SC) of this algorithm is O(n), where n is the length of the input array. This is because the algorithm creates a list of k subarrays, each of which can contain up to n/k elements. Therefore, the total space complexity is O(n).\\n\\n# 2ND WAY\\n```C++ []\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> v[n+1];\\n        k = __gcd(n, k);\\n        for (int i = 0; i < n; ++i) {\\n            v[i%k].push_back(arr[i]);\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < k; ++i) {\\n            int median = quickselect(v[i], v[i].size() / 2);\\n            for (auto &j : v[i]) {\\n                ans += abs(median - j);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int quickselect(vector<int>& nums, int k) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int pivotIndex = partition(nums, left, right);\\n            if (pivotIndex == k) {\\n                return nums[k];\\n            } else if (pivotIndex < k) {\\n                left = pivotIndex + 1;\\n            } else {\\n                right = pivotIndex - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int partition(vector<int>& nums, int left, int right) {\\n        int pivotIndex = left + (right - left) / 2;\\n        int pivotValue = nums[pivotIndex];\\n        swap(nums[pivotIndex], nums[right]);\\n        int storeIndex = left;\\n        for (int i = left; i < right; i++) {\\n            if (nums[i] < pivotValue) {\\n                swap(nums[i], nums[storeIndex]);\\n                storeIndex++;\\n            }\\n        }\\n        swap(nums[storeIndex], nums[right]);\\n        return storeIndex;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public longSubKSumEqual(int[] arr, int k) {\\n        int n = arr.length;\\n        List<Integer>[] v = new List[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            v[i] = new ArrayList<>();\\n        }\\n        k = gcd(n, k);\\n        for (int i = 0; i < n; i++) {\\n            v[i%k].add(arr[i]);\\n        }\\n        long ans = 0;\\n        for (int i = 0; i < k; i++) {\\n            int median = quickselect(v[i], v[i].size() / 2);\\n            for (int j : v[i]) {\\n                ans += Math.abs(median - j);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int quickselect(List<Integer> nums, int k) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int pivotIndex = partition(nums, left, right);\\n            if (pivotIndex == k) {\\n                return nums.get(k);\\n            } else if (pivotIndex < k) {\\n                left = pivotIndex + 1;\\n            } else {\\n                right = pivotIndex - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int partition(List<Integer> nums, int left, int right) {\\n        int pivotIndex = left + (right - left) / 2;\\n        int pivotValue = nums.get(pivotIndex);\\n        Collections.swap(nums, pivotIndex, right);\\n        int storeIndex = left;\\n        for (int i = left; i < right; i++) {\\n            if (nums.get(i) < pivotValue) {\\n                Collections.swap(nums, i, storeIndex);\\n                storeIndex++;\\n            }\\n        }\\n        Collections.swap(nums, storeIndex, right);\\n        return storeIndex;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            median = self.quickselect(v[i], len(v[i]) // 2)\\n            for j in v[i]:\\n                ans += abs(median - j)\\n        return ans\\n\\n    def quickselect(self, nums: List[int], k: int) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            pivotIndex = self.partition(nums, left, right)\\n            if pivotIndex == k:\\n                return nums[k]\\n            elif pivotIndex < k:\\n                left = pivotIndex + 1\\n            else:\\n                right = pivotIndex - 1\\n        return -1\\n\\n    def partition(self, nums: List[int], left: int, right: int) -> int:\\n        pivotIndex = left + (right - left) // 2\\n        pivotValue = nums[pivotIndex]\\n        nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]\\n        storeIndex = left\\n        for i in range(left, right):\\n            if nums[i] < pivotValue:\\n                nums[i], nums[storeIndex] = nums[storeIndex], nums[i]\\n                storeIndex += 1\\n        nums[storeIndex], nums[right] = nums[right], nums[storeIndex]\\n        return storeIndex\\n\\n    def gcd(self, a: int, b: int) -> int:\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a % b)\\n```\\nThe time complexity of the optimized makeSubKSumEqual function is O log n), where n is the length of the input array arr . This is because the function performs a quickselect operation on each subarray, which has an average time complexity of O(n), and then iterates through each subarray to calculate the absolute difference between each element and the median. The sorting operation in the original code has been replaced by the quickselect operation, which is more efficient for finding the median.\\n\\nThe space complexity of the function is O(n), which is the space required to store the subarrays in the \\nv\\n vector. The quickselect algorithm has a space complexity of O(1) because it operates on the input array in place.\\n\\nOverall, the optimized solution has a better time complexity than the original solution, but the space complexity remains the same.\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n##### \\u2022 Thanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n##### \\u2022 Please give my solution an upvote! \\uD83D\\uDC4D\\n##### \\u2022 It\\'s a simple way to show your appreciation and\\n\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n[My post here ](https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366625/day-366-python-java-c-explained-intuition-algorithm-100-beats/?orderBy=hot) \\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def makeSubKSumEqual(self,arr, k):\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            v[i].sort()\\n            x = v[i][len(v[i]) // 2]\\n            for j in v[i]:\\n                ans += abs(x - j)\\n        return ans\\n\\n    def gcd(a, b):\\n        if b == 0:\\n            return a\\n        return gcd(b, a % b)\\n```\n```java []\\nclass Solution{\\n    public static long makeSubKSumEqual(int[] arr, int k) {\\n    int n = arr.length;\\n    List<Integer>[] v = new ArrayList[n + 1];\\n    for (int i = 0; i <= n; i++) {\\n        v[i] = new ArrayList<>();\\n    }\\n    k = gcd(n, k);\\n    for (int i = 0; i < n; i++) {\\n        v[i % k].add(arr[i]);\\n    }\\n    long ans = 0;\\n    for (int i = 0; i < k; i++) {\\n        Collections.sort(v[i]);\\n        int x = v[i].get(v[i].size() / 2);\\n        for (int j : v[i]) {\\n            ans += Math.abs(x - j);\\n        }\\n    }\\n    return ans;\\n}\\n\\nprivate static int gcd(int a, int b) {\\n    if (b == 0) {\\n        return a;\\n    }\\n    return gcd(b, a % b);\\n}\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size() ;\\n        vector<int>v[n+1] ;\\n        k = __gcd(n , k) ;\\n        for(int i = 0 ; i < n ; ++i)\\n            v[i%k].push_back(arr[i]) ;\\n        long long ans = 0 ;\\n        for(int i = 0 ; i < k ; ++i)\\n        {\\n            sort(v[i].begin() , v[i].end()) ;\\n            int x = v[i][v[i].size() / 2] ;\\n            for(auto &j : v[i])\\n                ans += abs(x-j) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> v[n+1];\\n        k = __gcd(n, k);\\n        for (int i = 0; i < n; ++i) {\\n            v[i%k].push_back(arr[i]);\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < k; ++i) {\\n            int median = quickselect(v[i], v[i].size() / 2);\\n            for (auto &j : v[i]) {\\n                ans += abs(median - j);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int quickselect(vector<int>& nums, int k) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int pivotIndex = partition(nums, left, right);\\n            if (pivotIndex == k) {\\n                return nums[k];\\n            } else if (pivotIndex < k) {\\n                left = pivotIndex + 1;\\n            } else {\\n                right = pivotIndex - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int partition(vector<int>& nums, int left, int right) {\\n        int pivotIndex = left + (right - left) / 2;\\n        int pivotValue = nums[pivotIndex];\\n        swap(nums[pivotIndex], nums[right]);\\n        int storeIndex = left;\\n        for (int i = left; i < right; i++) {\\n            if (nums[i] < pivotValue) {\\n                swap(nums[i], nums[storeIndex]);\\n                storeIndex++;\\n            }\\n        }\\n        swap(nums[storeIndex], nums[right]);\\n        return storeIndex;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public longSubKSumEqual(int[] arr, int k) {\\n        int n = arr.length;\\n        List<Integer>[] v = new List[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            v[i] = new ArrayList<>();\\n        }\\n        k = gcd(n, k);\\n        for (int i = 0; i < n; i++) {\\n            v[i%k].add(arr[i]);\\n        }\\n        long ans = 0;\\n        for (int i = 0; i < k; i++) {\\n            int median = quickselect(v[i], v[i].size() / 2);\\n            for (int j : v[i]) {\\n                ans += Math.abs(median - j);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int quickselect(List<Integer> nums, int k) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int pivotIndex = partition(nums, left, right);\\n            if (pivotIndex == k) {\\n                return nums.get(k);\\n            } else if (pivotIndex < k) {\\n                left = pivotIndex + 1;\\n            } else {\\n                right = pivotIndex - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int partition(List<Integer> nums, int left, int right) {\\n        int pivotIndex = left + (right - left) / 2;\\n        int pivotValue = nums.get(pivotIndex);\\n        Collections.swap(nums, pivotIndex, right);\\n        int storeIndex = left;\\n        for (int i = left; i < right; i++) {\\n            if (nums.get(i) < pivotValue) {\\n                Collections.swap(nums, i, storeIndex);\\n                storeIndex++;\\n            }\\n        }\\n        Collections.swap(nums, storeIndex, right);\\n        return storeIndex;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            median = self.quickselect(v[i], len(v[i]) // 2)\\n            for j in v[i]:\\n                ans += abs(median - j)\\n        return ans\\n\\n    def quickselect(self, nums: List[int], k: int) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            pivotIndex = self.partition(nums, left, right)\\n            if pivotIndex == k:\\n                return nums[k]\\n            elif pivotIndex < k:\\n                left = pivotIndex + 1\\n            else:\\n                right = pivotIndex - 1\\n        return -1\\n\\n    def partition(self, nums: List[int], left: int, right: int) -> int:\\n        pivotIndex = left + (right - left) // 2\\n        pivotValue = nums[pivotIndex]\\n        nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]\\n        storeIndex = left\\n        for i in range(left, right):\\n            if nums[i] < pivotValue:\\n                nums[i], nums[storeIndex] = nums[storeIndex], nums[i]\\n                storeIndex += 1\\n        nums[storeIndex], nums[right] = nums[right], nums[storeIndex]\\n        return storeIndex\\n\\n    def gcd(self, a: int, b: int) -> int:\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a % b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366524,
                "title": "easy-solution-c",
                "content": "# Approach\\nIf n is divisible by k then perform the following otherwise update k to gcd of n and k (by observation)\\n\\nNow , for every element at a gap of k make them equal by subtracting all these numbers by their median we can do that by sorting all the elements and taking its middle to get the median\\n<!-- Describe your approach to solving the problem. -->\\n- Why we are taking GCD of \\'n\\' and \\'k\\'?\\n As we want \\'k\\' to be as big as possible but also it should also divide the \\'n\\', to match our requirement.\\n\\n# Complexity\\n- Time complexity: O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long res = 0;\\n        int n = arr.size();\\n        k = __gcd(k , n);\\n\\n        for(int i=0;i<k;i++) {\\n            vector<int> vec;\\n            for(int j = i;j<n;j+=k)\\n                vec.push_back(arr[j]);\\n\\n            sort(vec.begin() , vec.end());\\n            long long mid = vec[vec.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) \\n                res += abs(midv - arr[j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long res = 0;\\n        int n = arr.size();\\n        k = __gcd(k , n);\\n\\n        for(int i=0;i<k;i++) {\\n            vector<int> vec;\\n            for(int j = i;j<n;j+=k)\\n                vec.push_back(arr[j]);\\n\\n            sort(vec.begin() , vec.end());\\n            long long mid = vec[vec.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) \\n                res += abs(midv - arr[j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367171,
                "title": "intuition-approach-c-easy-to-understand",
                "content": "### INTUITION\\n![image](https://assets.leetcode.com/users/images/070abc38-f150-4bf3-8db3-4a9edb3dfd76_1680372514.3126214.jpeg)\\n\\nCODE:\\n```\\n\\nlong long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        long long ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // finding elements in same group as explained in INTUITION\\n            vector<int> group;\\n            for (int j = i; a[j] != 0; j = (j+k)%n) {\\n                group.push_back(a[j]);\\n                a[j] = 0;\\n            }\\n            \\n            // median of that group\\n            if (group.size() > 0) {\\n                sort(group.begin(), group.end());\\n                int median = group[group.size() / 2];\\n\\n                // make all elements equal to median for minimum cost\\n                for (auto &x: group) {\\n                    ans += abs(x - median);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nlong long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        long long ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // finding elements in same group as explained in INTUITION\\n            vector<int> group;\\n            for (int j = i; a[j] != 0; j = (j+k)%n) {\\n                group.push_back(a[j]);\\n                a[j] = 0;\\n            }\\n            \\n            // median of that group\\n            if (group.size() > 0) {\\n                sort(group.begin(), group.end());\\n                int median = group[group.size() / 2];\\n\\n                // make all elements equal to median for minimum cost\\n                for (auto &x: group) {\\n                    ans += abs(x - median);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366858,
                "title": "best-c-solution-with-100-acuuracy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst observation is that if we want each subarray sum to be the same, it means that the array must have a repeated pattern of size k.\\nTo understand that, let\\'s just say that k is 4 and the array starts with [1 2 3 4...]\\nThen to have sum(1,2,3,4) == sum(2,3,4, x) the next element has to be a 1! Then the next one a 2, etc.\\n\\nSo this means that in the final array, arr[i] == arr[(i + k) %n] for every i.\\n\\nSince arr[i] == arr[(i + k) %n] == arr[(i + 2*k) %n] == arr[(i + 3*k) %n] == .... this gives us a set of indexes for which the values must be the same. First step is to find these sets of indexes.\\n\\nThen for each set must find the minimal number of operations to have all these values the same. This means finding v so that sum_x(|x -v|) is minimal. This is the median of these values.\\n\\nOnce we found the median, we just have to add the difference between each value and the median\\xA0to\\xA0the\\xA0result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        \\n        //due to circular array the gap k will be converted to gcd of\\n        // k and n by observation (check for n = 15 , k = 6 , and find out)\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            //taking the mid value of the sorted array to get the \\n            //median as it will require minimum operation to convert \\n            //all elements to the medain value\\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        \\n        //due to circular array the gap k will be converted to gcd of\\n        // k and n by observation (check for n = 15 , k = 6 , and find out)\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            //taking the mid value of the sorted array to get the \\n            //median as it will require minimum operation to convert \\n            //all elements to the medain value\\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369308,
                "title": "this-is-how-can-average-student-approach-this-question-easiest-solution-with-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the minimum cost to make all subarrays of length k equal. One of the ways to approach this problem is to divide the given array into k subarrays such that each subarray has elements at indices i, i+k, i+2k, i+3k, and so on. Then, we can find the median of each subarray, and the sum of medians of all subarrays will give us the minimum cost to make all subarrays of length k equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we find the GCD of n and k. Let\\'s call it gcd.\\n2. We create a vector of vectors, where the outer vector has size gcd and the inner vectors store elements at indices i, i+gcd, i+2gcd, and so on.\\n3. For each inner vector, we find the median using the median function. The median function sorts the vector and then calculates the sum of absolute differences of each element with the median.\\n4. We sum up all the medians calculated in step 3, and this gives us the minimum cost to make all subarrays of length k equal.\\n\\n# Complexity\\n- Time complexity: O(nlog(n)) for Sorting.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for storing.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n> Please upvote \\n\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    ll median(vector<int>&v){\\n        ll ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++) ans+=abs(v[i]-v[v.size()/2]);\\n        return ans;   \\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        ll ans=0;\\n        k=__gcd(n,k);\\n        vector<vector<int>>v(k);\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<n;j+=k){\\n                v[i].push_back(arr[j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            ans+=median(v[i]);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    ll median(vector<int>&v){\\n        ll ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++) ans+=abs(v[i]-v[v.size()/2]);\\n        return ans;   \\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        ll ans=0;\\n        k=__gcd(n,k);\\n        vector<vector<int>>v(k);\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<n;j+=k){\\n                v[i].push_back(arr[j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            ans+=median(v[i]);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366425,
                "title": "c-easy-solution",
                "content": "# Intuition\\nI remembered a similar question where we had to increase or decrease so that all elements are equal.\\n# Approach\\nI realized that all elements spaced with k indices should be equal.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long solve(vector<int> nums){\\n        long long sum = 0;\\n        if(nums.size()==0) return 0;\\n        sort(begin(nums),end(nums));\\n        int k = nums.size();\\n        sum = nums[k/2];\\n        long long ans = 0;\\n        for(auto it:nums)\\n            ans += abs(sum-it);\\n        return ans;\\n    }\\n    \\n    long long makeSubKSumEqual(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        set<int> st;\\n        for(int i=0; i<=min(k,n-1); ++i){\\n            vector<int> arr;\\n            int j = i;\\n            while(st.find(j) == st.end()){\\n                st.insert(j);\\n                arr.push_back(nums[j]);\\n                j = (j+k)%n;\\n            }\\n            ans += solve(arr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve(vector<int> nums){\\n        long long sum = 0;\\n        if(nums.size()==0) return 0;\\n        sort(begin(nums),end(nums));\\n        int k = nums.size();\\n        sum = nums[k/2];\\n        long long ans = 0;\\n        for(auto it:nums)\\n            ans += abs(sum-it);\\n        return ans;\\n    }\\n    \\n    long long makeSubKSumEqual(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        set<int> st;\\n        for(int i=0; i<=min(k,n-1); ++i){\\n            vector<int> arr;\\n            int j = i;\\n            while(st.find(j) == st.end()){\\n                st.insert(j);\\n                arr.push_back(nums[j]);\\n                j = (j+k)%n;\\n            }\\n            ans += solve(arr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366422,
                "title": "python-cycle-partition-o-nlogn",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        visited = set()\\n        n = len(arr)\\n        res = 0\\n        for i in range(len(arr)):\\n            if i in visited: continue\\n            curlist = []\\n            while i not in visited:\\n                visited.add(i)\\n                curlist.append(arr[i])\\n                i = (i+k)%n\\n            curlist.sort()\\n            m = len(curlist)//2\\n            res += sum([abs(num - curlist[m]) for num in curlist])\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        visited = set()\\n        n = len(arr)\\n        res = 0\\n        for i in range(len(arr)):\\n            if i in visited: continue\\n            curlist = []\\n            while i not in visited:\\n                visited.add(i)\\n                curlist.append(arr[i])\\n                i = (i+k)%n\\n            curlist.sort()\\n            m = len(curlist)//2\\n            res += sum([abs(num - curlist[m]) for num in curlist])\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980445,
                "title": "easy-c-solution-what-to-learn-from-the-problem",
                "content": "## Two points to remember:- \\n- gcd(n,k)helps in grouping the circular array of size n into groups of elements having difference of k;\\n- If you have to find the minimum cost to make all elements of array equal:-\\n1)Median is the correct choice if increasing or decreasing the element by 1 both increase the cost.\\n2) Mean is the correct choice if increasing element increases the cost by 1 and decreasing the element decreases the cost by 1 or vice versa.\\n3) Mode is the correct choice if the element can be directly increased or decreased to a certain element and each operations incurs equal cost.\\n4) Median is the correct choice if the element can be directly increased or decreased to a certain element and increasing and decreasing incurs opposite cost i.e one increases and another decreases equally.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int x=__gcd(n,k);\\n        vector<vector<int>>v(x);\\n        for(int i=0;i<n;i++){\\n            v[i%x].push_back(arr[i]);\\n        }\\n        long long ans=0;\\n        for(auto y:v){\\n            sort(y.begin(),y.end());\\n            int ind=(y.size()-1)/2;\\n            long long sum=0;\\n            for(auto z:y){\\n                sum+=abs(z-y[ind]);\\n            }\\n            ans+=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int x=__gcd(n,k);\\n        vector<vector<int>>v(x);\\n        for(int i=0;i<n;i++){\\n            v[i%x].push_back(arr[i]);\\n        }\\n        long long ans=0;\\n        for(auto y:v){\\n            sort(y.begin(),y.end());\\n            int ind=(y.size()-1)/2;\\n            long long sum=0;\\n            for(auto z:y){\\n                sum+=abs(z-y[ind]);\\n            }\\n            ans+=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619857,
                "title": "python-3-4-lines-w-comments-t-m-51-96",
                "content": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n\\n        g, d, ans = gcd(k,len(arr)), defaultdict(list), 0\\n\\n        for i, a in enumerate(arr): d[i%g].append(a)            # <-- construct a dict of sorted lists\\n        for i in d:d[i].sort()                                  #     of`arr`elements that must be equal\\n            \\n        return sum(d[i][-j-1]-d[i][j]                           # <-- determine the number of moves to \\n                   for j in range((len(d[i]))//2) for i in d)   #     make them equal. The sum of moves \\n                                                                #     for a symmetric pair (e.g., d[i][1]\\n                                                                #     and d[i][-2]) is their difference.\\n```\\n[https://leetcode.com/problems/make-k-subarray-sums-equal/submissions/926808484/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n\\n        g, d, ans = gcd(k,len(arr)), defaultdict(list), 0\\n\\n        for i, a in enumerate(arr): d[i%g].append(a)            # <-- construct a dict of sorted lists\\n        for i in d:d[i].sort()                                  #     of`arr`elements that must be equal\\n            \\n        return sum(d[i][-j-1]-d[i][j]                           # <-- determine the number of moves to \\n                   for j in range((len(d[i]))//2) for i in d)   #     make them equal. The sum of moves \\n                                                                #     for a symmetric pair (e.g., d[i][1]\\n                                                                #     and d[i][-2]) is their difference.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371767,
                "title": "thought-process-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s have a brief review on what we are going do then we will understand each step in detail.\\nFirst, we will create a container array of size gcd(n, k). Then we will store n/k elements in each container. After that we will iterate through each container and find their medians. Our ans will be the sum of absolute value of difference of median and each elements of that container.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBefore we proceed further I strongly suggest you go through this question once. [462. Minimum Moves to Equal Array Elements II](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/). Sorry to interrupt you in between but I can make sure that once you have gone through it then this will become crystal clear.\\n\\nFirst we have to create a container size gcd(n, k). Now the question arrises from were the hell this gcd came. Let me explain this in detail.\\nThe idea behind taking gcd(n, k) is to divide the array arr into `box_cnt` container, each having an equal number of elements. The gcd(n, k) ensures that the number of container is as small as possible while still having an equal number of elements in each container. For example, if n is a multiple of k, then `box_cnt` will be equal to k, and each container will have n / k elements. By dividing arr into `box_cnt` buckets, we can compute the median of each bucket efficiently. We will also see this in detail ahead.\\n***Basically if we did not take the gcd, we might end up with container of different sizes, which would complicate the calculation of the medians and the final result.***\\n\\nNow we have understood this part let\\'s move ahead. Now comes the time to store the values in the container. We will store the elements in following manner\\n\\n```\\nLet arr = [1, 4, 1, 3] and k = 2 then the box_cnt = gcd(n, k) = 2;\\ncontainer[0] = {1, 1}\\ncontainer[1] = {4, 3}\\ni.e., will add every next k element in a container\\n```\\n\\nOnce you have stored the elements in the container, now comes the time to calculate our ans. For that we will iterate over each container and find the median value in each. Now the question arrises why **Median**. If you have done the question which I have mentioned above then their will be no doubt. Still let me explain it. The main idea behind taking the median is to make all the elements in that particular container equal(not actually only conceptually). As median has the property that half of the elements in the container are greater than or equal to it, and half are less than or equal to it. So, this is only the best way to make all array equal.\\n\\nNow we calculate the sum of absolute differences between each element in the container and the median of that container. Finally, we can sum up the results for all the containers to get the final answer.\\n\\nSorry for the lengthy post. Hope you enjoyed solving this problem. If I was able to help you, then you thank me with a upvote.\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int box_cnt = __gcd(n, k);\\n\\n        vector<vector<long long>> container(box_cnt);\\n        for(int i = 0; i<n; i++){\\n            container[i%box_cnt].push_back(arr[i]);\\n        }\\n\\n        long long ans = 0;\\n        for(auto items : container){\\n            sort(begin(items), end(items));\\n            int item_size = items.size();\\n            int median;\\n            if(item_size%2 == 1)\\n                median = items[item_size/2];\\n            else\\n                median = (items[(item_size/2)-1]+items[item_size/2])/2;\\n\\n            for(auto ele: items){\\n                ans += abs(median-ele);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nLet arr = [1, 4, 1, 3] and k = 2 then the box_cnt = gcd(n, k) = 2;\\ncontainer[0] = {1, 1}\\ncontainer[1] = {4, 3}\\ni.e., will add every next k element in a container\\n```\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int box_cnt = __gcd(n, k);\\n\\n        vector<vector<long long>> container(box_cnt);\\n        for(int i = 0; i<n; i++){\\n            container[i%box_cnt].push_back(arr[i]);\\n        }\\n\\n        long long ans = 0;\\n        for(auto items : container){\\n            sort(begin(items), end(items));\\n            int item_size = items.size();\\n            int median;\\n            if(item_size%2 == 1)\\n                median = items[item_size/2];\\n            else\\n                median = (items[(item_size/2)-1]+items[item_size/2])/2;\\n\\n            for(auto ele: items){\\n                ans += abs(median-ele);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367122,
                "title": "python3-grouping-by-gcd",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/1dc118daa80cfe1161dcee412e7c3536970ca60d) for solutions of biweely 101. \\n\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        ans = 0 \\n        g = gcd(len(arr), k)\\n        for i in range(g): \\n            vals = []\\n            for _ in range(len(arr)//g): \\n                vals.append(arr[i])\\n                i = (i+k) % len(arr)\\n            vals.sort()\\n            cand = vals[len(vals)//2]\\n            ans += sum(abs(x-cand) for x in vals)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        ans = 0 \\n        g = gcd(len(arr), k)\\n        for i in range(g): \\n            vals = []\\n            for _ in range(len(arr)//g): \\n                vals.append(arr[i])\\n                i = (i+k) % len(arr)\\n            vals.sort()\\n            cand = vals[len(vals)//2]\\n            ans += sum(abs(x-cand) for x in vals)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366372,
                "title": "c-disjoint-set-and-prefix-sum-o-nlogn-with-explanation",
                "content": "**Intro** :\\nWe need the sum of each subarry of length k to be equal,\\nthus arr[i] should be equal to arr[(i+k)%n] for all i from 0 to n.\\nSo, we make different set of the values which needs to be equal and then solve for each set.\\n\\n**How to solve for each set :**\\nNow, for a set we need to calculate the minimum cost to make all the values equal.\\nFor this,we sort the numbers and then find cost of making all values equal to a given a[i] by using values :\\npref[i]- cost required to make a[0,i-1] equal to a[i].\\nsuff[i]- cost required to make a[i+1,a.size()-1] equal to a[i].\\nand taking minimum of all.\\n\\n**Final answe**r is the sum of minimum values for each set.\\n\\n**CODE-**\\n```\\n\\n\\nclass Solution {\\npublic:\\n    \\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n\\tbool same(int a, int b) { return get(a) == get(b); }\\n\\n\\tbool unite(int x, int y) {  \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n1=arr.size();\\n        DSU dsu(n1);\\n        for(int i=0;i<arr.size();i++){\\n            dsu.unite(i,(i+k)%n1);\\n        }\\n        \\n        vector<vector<long long>> v(k);\\n        for(int i=0;i<arr.size();i++){\\n            v[dsu.get(i)].push_back(arr[i]*1ll);\\n        }\\n        long long ans=0;\\n        for(int id=0;id<k;id++){\\n            vector<long long>a=v[id];\\n            sort(a.begin(),a.end());\\n            long long n=a.size();\\n            if(!n) continue;\\n            vector<long long>pref(n),suff(n);\\n            long long sum=a[0]; pref[0]=0;\\n            for(int i=1;i<n;i++){\\n                pref[i]=i*a[i]-sum;\\n                sum+=a[i];\\n            }\\n            sum=a[n-1]; suff[n-1]=0;\\n            for(int i=n-2;i>=0;i--){\\n                suff[i]=sum-(n-i-1)*a[i];\\n                sum+=a[i];\\n            }\\n            long long res=pref[0]+suff[0];\\n            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);\\n            ans=ans+res;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - O(nlogn)\\nSpace Complexity ~ O(n) (probably)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n\\tbool same(int a, int b) { return get(a) == get(b); }\\n\\n\\tbool unite(int x, int y) {  \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n1=arr.size();\\n        DSU dsu(n1);\\n        for(int i=0;i<arr.size();i++){\\n            dsu.unite(i,(i+k)%n1);\\n        }\\n        \\n        vector<vector<long long>> v(k);\\n        for(int i=0;i<arr.size();i++){\\n            v[dsu.get(i)].push_back(arr[i]*1ll);\\n        }\\n        long long ans=0;\\n        for(int id=0;id<k;id++){\\n            vector<long long>a=v[id];\\n            sort(a.begin(),a.end());\\n            long long n=a.size();\\n            if(!n) continue;\\n            vector<long long>pref(n),suff(n);\\n            long long sum=a[0]; pref[0]=0;\\n            for(int i=1;i<n;i++){\\n                pref[i]=i*a[i]-sum;\\n                sum+=a[i];\\n            }\\n            sum=a[n-1]; suff[n-1]=0;\\n            for(int i=n-2;i>=0;i--){\\n                suff[i]=sum-(n-i-1)*a[i];\\n                sum+=a[i];\\n            }\\n            long long res=pref[0]+suff[0];\\n            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);\\n            ans=ans+res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886366,
                "title": "beats-95-one-of-the-best-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long getans(vector<int> &temp)\\n    {\\n        if(temp.size()==1)\\n        return 0;\\n        else if(temp.size()==2)\\n        {\\n            return abs(temp[0]-temp[1]);\\n        }\\n        else\\n        {\\n            sort(temp.begin(),temp.end());\\n            int n = temp.size();\\n            if(n&1)\\n            {\\n                int mid = (n-1)/2;\\n                long long ans = 0;\\n                for(int i=0;i<n;i++)\\n                ans+=abs(temp[i]-temp[mid]);\\n\\n                return ans;\\n            }\\n            else\\n            {\\n                int mid = (n-1)/2;\\n                int mid2 = mid+1;\\n                long long a1=0,a2=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    a1+=abs(temp[i]-temp[mid]);\\n                    a2+=abs(temp[i]-temp[mid2]);\\n                }\\n\\n                if(a1<=a2)return a1;\\n                else\\n                return a2;\\n            }\\n        }\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        long long ans = 0;\\n        vector<bool> visited(n,false);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==true)continue;\\n            else\\n            {\\n                int j = i;\\n                vector<int> temp;\\n                while(true)\\n                {\\n                    if(visited[j]==true)\\n                    {\\n                        break;\\n                    }\\n                    temp.push_back(arr[j]);\\n                    visited[j] = true;\\n                    j =  (j+k)%n;\\n                }\\n\\n                ans+=getans(temp);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long getans(vector<int> &temp)\\n    {\\n        if(temp.size()==1)\\n        return 0;\\n        else if(temp.size()==2)\\n        {\\n            return abs(temp[0]-temp[1]);\\n        }\\n        else\\n        {\\n            sort(temp.begin(),temp.end());\\n            int n = temp.size();\\n            if(n&1)\\n            {\\n                int mid = (n-1)/2;\\n                long long ans = 0;\\n                for(int i=0;i<n;i++)\\n                ans+=abs(temp[i]-temp[mid]);\\n\\n                return ans;\\n            }\\n            else\\n            {\\n                int mid = (n-1)/2;\\n                int mid2 = mid+1;\\n                long long a1=0,a2=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    a1+=abs(temp[i]-temp[mid]);\\n                    a2+=abs(temp[i]-temp[mid2]);\\n                }\\n\\n                if(a1<=a2)return a1;\\n                else\\n                return a2;\\n            }\\n        }\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        long long ans = 0;\\n        vector<bool> visited(n,false);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==true)continue;\\n            else\\n            {\\n                int j = i;\\n                vector<int> temp;\\n                while(true)\\n                {\\n                    if(visited[j]==true)\\n                    {\\n                        break;\\n                    }\\n                    temp.push_back(arr[j]);\\n                    visited[j] = true;\\n                    j =  (j+k)%n;\\n                }\\n\\n                ans+=getans(temp);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367768,
                "title": "c-actually-explained-gcd-median-latexed",
                "content": "# Intuition\\nThis problem was too difficult for a medium imo.\\nSo first off, we want to notice that all subarrays of length $\\\\color{pink} k$ must contain the **same** elements. Why is this? Let\\'s start building an optimal solution. Suppose we have $\\\\color{pink} n$ elements and our $\\\\color{pink} k$ is 3.\\n\\nThe first length 3 subarray is $[a_0,a_1,a_2]$. The next one is $[a_1,a_2,a_3]$. Notice that the first subarray\\'s sum is $\\\\color{cyan} a_0 + a_1 + a_2$, and by the constraints, the next one must also equal that. If you do some simplifying, you see that $\\\\color{lime} a_3 = a_0$. You can continue this onwards to see that it must repeat every k (at the very most). It can be less, like test case 2, where the answer repeats every 1, but k is 2.\\n\\nOkay, let\\'s see how our good friend $\\\\color{pink} \\\\gcd$ comes into this. Let\\'s just focus on the *indices* of our array and for the sake of argument: let $\\\\color{pink} k = 4,n=6$.\\n\\nThen, let\\'s again try and build the optimal solution, starting with index 0. We have \\n$\\\\Large[a_0,a_1,a_2,a_3]$\\n$\\\\Large[a_4,a_5,a_0,a_1]$\\n$\\\\Large[a_2,a_3,a_4,a_5]$\\n$\\\\Large[a_0,a_1,a_2,a_3]$\\nNotice that it repeats. Using our idea that each value must repeat, we can say that $\\\\large \\\\color{yellow} a_0 = a_4 = a_2$\\n$\\\\large \\\\color{yellow} a_1 = a_5 = a_3$\\nLet\\'s formalize this. \\nWe can express the \"chain of values\" achieved with $\\\\color{orange} 4m + i \\\\pmod{6}$, where $\\\\color{orange} i$ is the index. For example, notice that when $\\\\color{orange} i =1$ and we iterate over $\\\\color{orange} m$, we get $\\\\color{white} \\\\{1,5,3,1,\\\\dotsc\\\\}$. Look familiar?\\n\\nAn important subtask will be to determine whether two indices $\\\\color{violet} i,j$ are part of the same chain. All that\\'s really saying is that$\\\\color{magenta} j \\\\equiv 4m + i \\\\pmod{6}$\\n\\nWhy? Because if $\\\\color{violet} i,j$ are in the same chain, then $\\\\color{violet} j$ is reachable by $\\\\color{violet} i$ by just adding $\\\\color{pink} k$ over and over mod $\\\\color{orange} n$ until we get there. If we never reach $\\\\color{violet} j$, then it\\'s not possible.\\n\\nSo if we solve the modular equation, we get $\\\\color{magenta} j-i \\\\equiv 4m \\\\pmod{6}$, now this is reducible since 4 and 6 share common factors. Therefore we can reduce it to \\n\\n$\\\\LARGE \\\\color{magenta} \\\\frac{j-i}{\\\\gcd(6,4)} \\\\equiv 2m \\\\pmod{3}$\\n\\nNow since 2 and 3 do not share common factors (**), we know that if this modular equation has a solution, the left side obviously has to be an integer, so $\\\\color{cyan} g \\\\coloneqq \\\\gcd(6,4) | (j-i)$\\n\\nAll this says is that $\\\\color{lime} j \\\\equiv i \\\\pmod{g}$, so now we have our condition!\\n\\nOkay, let\\'s now see the ideal values to set our group to! Let\\'s look at a test case: `[2,5,8,7,4,1,3], k = 3`\\n\\nWe use the approach above to notice that we have one big homogeneous group with all the numbers in it. Applying the operations to make all numbers equal is now equivalent to simply calculating the absolute deviation of the numbers to a central point $\\\\color{orange} x$, so we wish to find $$\\\\Large \\\\color{violet} \\\\min \\\\sum\\\\limits_{s \\\\in S} |s-\\\\color{orange} x \\\\color{violet}|$$\\n\\nIt is well known that the **median** minimizes the absolute deviation and so we let $\\\\color{orange} x$ be the **median**.\\n\\nEvaluating the sum results in 14, which is optimal.\\n\\n# Approach\\nI used an array of vectors where each index $\\\\color{lime} i$ represented a possible value of $\\\\color{lime} i \\\\pmod{\\\\gcd(n,k)}$, and just appended each element to its corresponding group.\\n\\nThe way I calculated the median was the simple way, where you just sort the list and query the middle element (middle two elements if the list size is even).\\n\\n# Complexity\\n- Time complexity: $\\\\color{violet} O(n \\\\log (n))$, since we are placing $\\\\color{violet} n$ elements in lists and worst case sort will be when all elements are in the same list, so that will just be $\\\\color{violet} O(n \\\\log (n))$. Since $\\\\color{violet} \\\\gcd(n,k) < n$, that second loop will not run more than n times.\\n\\n- Space complexity: $\\\\color{violet} O(n)$, as we only fill $\\\\color{violet} n$ elements worth of stuff in the vector array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        int g = gcd(n,k);\\n        vector<int> v[g];\\n        for (int i = 0; i < n; ++i)\\n            v[i % g].emplace_back(a[i]);\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < g; ++i){\\n            if (v[i].empty())\\n                continue;\\n            sort(v[i].begin(),v[i].end());\\n            int med = 0;\\n            if (v[i].size() & 1)\\n                med = v[i][v[i].size()/2];\\n            else\\n                med = (v[i][v[i].size()/2] + v[i][v[i].size()/2 - 1])/2;\\n            for (int j = 0; j < v[i].size(); ++j)\\n                ans += abs(v[i][j] - med);\\n        }\\n        return ans;\\n    }      \\n};\\n```\\n**: When we divide both k and n by the gcd, it\\'s **guaranteed** that the resultants won\\'t share common factors.",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        int g = gcd(n,k);\\n        vector<int> v[g];\\n        for (int i = 0; i < n; ++i)\\n            v[i % g].emplace_back(a[i]);\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < g; ++i){\\n            if (v[i].empty())\\n                continue;\\n            sort(v[i].begin(),v[i].end());\\n            int med = 0;\\n            if (v[i].size() & 1)\\n                med = v[i][v[i].size()/2];\\n            else\\n                med = (v[i][v[i].size()/2] + v[i][v[i].size()/2 - 1])/2;\\n            for (int j = 0; j < v[i].size(); ++j)\\n                ans += abs(v[i][j] - med);\\n        }\\n        return ans;\\n    }      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367499,
                "title": "gcd-median-c-python-greedy",
                "content": "# Intuition\\nFor a simple problem of k==1, we need to make all elements equal to some number. That number will be median which can be understood with the help of number line and some intuition. For even length array n/2 and n/2+1 position both will give out same answer.\\nSo now coming to this problem where we slide a k subarray window , observe that we can have equal sum in all subarrays only if the number going out and the number coming in the window are the same.\\nFor this we need to get some kind of a pattern like consider the following pattern- x,y,z,x,y,z,x,y,z.... this pattern will be for gcd (n,k)=3 .\\nAnd this is possible only if the length of the pattern is gcd of n and k. This is a necessary condition as we need to wrap the last array in a circular fashion.\\nSo it all boils down to creating such a pattern where x is median(arr[0],arr[0+g],arr[0+2*g],...) , y is median(arr[1],arr[1+g],arr[1+2*g],...) and so on..\\n\\n# Approach\\ncalculate all arrays for each index of gcd pattern and sort them to get the median and form the new result array. Take absolute difference of them and add it to answer.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) in worst case\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        long long n=arr.size();\\n        long long g=gcd(n,k);\\n        vector <long long> res;\\n        for (int i=0;i<g;i++){\\n            vector<long long> lol;\\n            for (int j=i;j<n;j+=g) lol.push_back(arr[j]);\\n            sort(lol.begin(),lol.end());\\n            res.push_back(lol[lol.size()/2]);\\n        }\\n        for (int i=0;i<n;i++) ans+=abs(res[i%g]-arr[i]);\\n        return ans;\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        g=gcd(n,k)\\n        ans=0\\n        nums=[]\\n        for i in range(g):\\n            lol=[]\\n            for j in range(i,n,g):\\n                lol.append(arr[j])\\n            lol.sort()\\n            nums.append(lol[len(lol)//2])\\n        for i in range(n):\\n            ans+=abs(nums[i%g]-arr[i])\\n        return ans\\n                \\n        \\n\\n                \\n        \\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        long long n=arr.size();\\n        long long g=gcd(n,k);\\n        vector <long long> res;\\n        for (int i=0;i<g;i++){\\n            vector<long long> lol;\\n            for (int j=i;j<n;j+=g) lol.push_back(arr[j]);\\n            sort(lol.begin(),lol.end());\\n            res.push_back(lol[lol.size()/2]);\\n        }\\n        for (int i=0;i<n;i++) ans+=abs(res[i%g]-arr[i]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        g=gcd(n,k)\\n        ans=0\\n        nums=[]\\n        for i in range(g):\\n            lol=[]\\n            for j in range(i,n,g):\\n                lol.append(arr[j])\\n            lol.sort()\\n            nums.append(lol[len(lol)//2])\\n        for i in range(n):\\n            ans+=abs(nums[i%g]-arr[i])\\n        return ans\\n                \\n        \\n\\n                \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366545,
                "title": "python-3-median-and-mod-gcd",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\\n        lA = len(A)\\n        g = gcd(lA, K)\\n        retV = 0\\n        for i in range(g):\\n            med = int(median(A[i::g]))\\n            retV += sum(abs(a-med) for a in A[i::g])\\n            \\n        return retV            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\\n        lA = len(A)\\n        g = gcd(lA, K)\\n        retV = 0\\n        for i in range(g):\\n            med = int(median(A[i::g]))\\n            retV += sum(abs(a-med) for a in A[i::g])\\n            \\n        return retV            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366534,
                "title": "dsu-prefix-sum-o-n-longn",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n\\tbool same(int a, int b) { return get(a) == get(b); }\\n\\n\\tbool unite(int x, int y) {  \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n1=arr.size();\\n        DSU dsu(n1);\\n        for(int i=0;i<arr.size();i++){\\n            dsu.unite(i,(i+k)%n1);\\n        }\\n        \\n        vector<vector<long long>> v(k);\\n        for(int i=0;i<arr.size();i++){\\n            v[dsu.get(i)].push_back(arr[i]*1ll);\\n        }\\n        long long ans=0;\\n        for(int id=0;id<k;id++){\\n            vector<long long>a=v[id];\\n            sort(a.begin(),a.end());\\n            long long n=a.size();\\n            if(!n) continue;\\n            vector<long long>pref(n),suff(n);\\n            long long sum=a[0]; pref[0]=0;\\n            for(int i=1;i<n;i++){\\n                pref[i]=i*a[i]-sum;\\n                sum+=a[i];\\n            }\\n            sum=a[n-1]; suff[n-1]=0;\\n            for(int i=n-2;i>=0;i--){\\n                suff[i]=sum-(n-i-1)*a[i];\\n                sum+=a[i];\\n            }\\n            long long res=pref[0]+suff[0];\\n            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);\\n            ans=ans+res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n\\tbool same(int a, int b) { return get(a) == get(b); }\\n\\n\\tbool unite(int x, int y) {  \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n1=arr.size();\\n        DSU dsu(n1);\\n        for(int i=0;i<arr.size();i++){\\n            dsu.unite(i,(i+k)%n1);\\n        }\\n        \\n        vector<vector<long long>> v(k);\\n        for(int i=0;i<arr.size();i++){\\n            v[dsu.get(i)].push_back(arr[i]*1ll);\\n        }\\n        long long ans=0;\\n        for(int id=0;id<k;id++){\\n            vector<long long>a=v[id];\\n            sort(a.begin(),a.end());\\n            long long n=a.size();\\n            if(!n) continue;\\n            vector<long long>pref(n),suff(n);\\n            long long sum=a[0]; pref[0]=0;\\n            for(int i=1;i<n;i++){\\n                pref[i]=i*a[i]-sum;\\n                sum+=a[i];\\n            }\\n            sum=a[n-1]; suff[n-1]=0;\\n            for(int i=n-2;i>=0;i--){\\n                suff[i]=sum-(n-i-1)*a[i];\\n                sum+=a[i];\\n            }\\n            long long res=pref[0]+suff[0];\\n            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);\\n            ans=ans+res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366386,
                "title": "best-concise-solution-and-easy-to-understand-c",
                "content": "# Approach\\nIf n is divisible by k then perform the following otherwise update k to gcd of n and k (by observation)\\n\\nNow , for every element at a gap of k make them equal by subtracting all these numbers by their median we can do that by sorting all the elements and taking its middle to get the median\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n        \\n        // if(n%k != 0) {\\n        //     sort(arr.begin() , arr.end());\\n        //     long long mid = arr[n/2];\\n        //     for(int i=0;i<n;i++) ans += abs(mid - arr[i]);\\n        // }\\n        // else {\\n        \\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            \\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n        \\n        // if(n%k != 0) {\\n        //     sort(arr.begin() , arr.end());\\n        //     long long mid = arr[n/2];\\n        //     for(int i=0;i<n;i++) ans += abs(mid - arr[i]);\\n        // }\\n        // else {\\n        \\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            \\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605884,
                "title": "beat-100-o-n-optimal-solution-selection-instead-of-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Subarray Equal Sum\\nIf every $k$-subarray has equal sum, then we have:\\n$$\\na_0 + a_1 + \\\\dots + a_{k-1} = a_1 + \\\\dots + a_{k-1} + a_k\\n\\\\Rightarrow a_0 = a_k\\n$$\\nAnd this applies to every other index, we would now have:\\n$a_i = a_{i + k}$ for every valid index $i$.\\nNot only that, our array is defined to be **circular**, which means when $i+k$ goes out of bounds it \"wraps\" back to the beginning. For example, when $n = 6$ and $k = 4$, we got\\n$$\\na_0 = a_4 \\\\\\\\\\na_1 = a_5\\n$$\\nand when the index \"wraps\" we have \\n$$\\na_2 = a_0 \\\\\\\\\\na_3 = a_1 \\\\\\\\\\na_4 = a_2 \\\\\\\\\\na_5 = a_3\\n$$\\nIf you focus on the pattern you can see that we actually got two \"chains\":\\n$$\\na_0 = a_4 = a_2 = a_0 \\\\\\\\\\na_1 = a_5 = a_3 = a_1\\n$$\\n\\nIt is now pretty straightforward to prove that the conditions of\\n> every $k$-subarray has equal sum\\n\\n is equivalent to \\n> $a_i = a_{i+\\\\gcd(k,n)}$ for every valid index $i$ \\n\\n## Min Operations Needed to Make an Array the Same\\nNow we can copy all numbers from the same \"chain\" into a separate array and solve an easier problem: what\\'s the min ops needed to make this array all equal.\\n\\nIt can be proven that if we operate every numbers in the array \"towards\" the median value we will achieve min ops.\\nWhen the size of the array is an even number, we don\\'t have to use the exact median value, but any value between the middle two values can do.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  * Find the `gcd` of `k` and array size, use that as the `k`\\n  * copy Each \"chain\" of number (in total `k` chains) into a new array.\\n  * Apply the median selection algorithm on the new array and then find the ops needed.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n**Caveate**: `std::nth_element()` is practically very fast but theorectically it is only average $\\\\Theta(N)$ and worst case it\\'s $\\\\Theta(N \\\\log N)$. If it\\'s important to keep it strictly $\\\\Theta(N)$ we need to use another selection algorithm (not readily available in `STL`).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N / \\\\gcd(k, N))$$\\nWe used a buffer to store each \"chain\" of numbers and the chain size is $N / k$ where the $k$ is actually the gcd of the original `k` and `N`.\\n\\nIf we are only allowed to use $O(1)$ extra space, it\\'s possible to do the selection algorithm directly on top of the input `arr` without copying. However, currently it\\'s not easy to adapt an C++ iterator and we would need to implement a selection algorithm ourselves (which I do not recommend unless you are asked to do so).\\n\\n# Code\\n```\\n// Returns the min operations needed to make every number in\\n// `nums` equal.\\nint64_t OpsNeeded(vector<int>& nums) {\\n  auto mid = nums.begin() + nums.size() / 2;\\n  std::nth_element(nums.begin(), mid, nums.end());\\n  const int mid_value = *mid;\\n  int64_t ops = 0;\\n  for (auto it = nums.begin(); it != mid; ++it) {\\n    ops += mid_value - *it;\\n  }\\n  for (auto it = mid + 1; it != nums.end(); ++it) {\\n    ops += *it - mid_value;\\n  }\\n  return ops;\\n}\\n\\nclass Solution {\\npublic:\\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    k = std::gcd(k, arr.size());\\n    if (k == 1) {\\n      return OpsNeeded(arr);\\n    }\\n    vector<int> buffer;\\n    int64_t ops = 0;\\n    for (int r = 0; r < k; ++r) {\\n      for (int i = r; i < arr.size(); i += k) {\\n        buffer.push_back(arr[i]);\\n      }\\n      ops += OpsNeeded(buffer);\\n      buffer.clear();\\n    }\\n    return ops;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Returns the min operations needed to make every number in\\n// `nums` equal.\\nint64_t OpsNeeded(vector<int>& nums) {\\n  auto mid = nums.begin() + nums.size() / 2;\\n  std::nth_element(nums.begin(), mid, nums.end());\\n  const int mid_value = *mid;\\n  int64_t ops = 0;\\n  for (auto it = nums.begin(); it != mid; ++it) {\\n    ops += mid_value - *it;\\n  }\\n  for (auto it = mid + 1; it != nums.end(); ++it) {\\n    ops += *it - mid_value;\\n  }\\n  return ops;\\n}\\n\\nclass Solution {\\npublic:\\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    k = std::gcd(k, arr.size());\\n    if (k == 1) {\\n      return OpsNeeded(arr);\\n    }\\n    vector<int> buffer;\\n    int64_t ops = 0;\\n    for (int r = 0; r < k; ++r) {\\n      for (int i = r; i < arr.size(); i += k) {\\n        buffer.push_back(arr[i]);\\n      }\\n      ops += OpsNeeded(buffer);\\n      buffer.clear();\\n    }\\n    return ops;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411353,
                "title": "proof-why-use-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven ```n = len(arr)``` and ```k```, we prove that every ```gcd(n,k)```-th element in ```arr``` should be the same in order to make k-subarray sums equal.\\n\\n1. Assume ```arr``` is just a regular array. If ```arr[i]+...+arr[i+k-1] = arr[i+1]+...+arr[i+k]```, then ```arr[i] = arr[i+k]```. Then ```arr[i] = arr[i+mk]``` for any ```m``` as long as ```i+mk < n```.\\n2. If ```arr``` is circular, we could extend the conclusion above to: given ```0<= i,j < n```, if there exist integers ```m, p``` such that ```j = i + mk - pn```, then ```arr[i] = arr[j]```.\\n3. The relationship between ```i, j``` is equivalent to ```j - i = mk - pn = (mk0 - pn0)*gcd(n,k)``` where ```k = k0*gcd(n,k)``` and ```n = n0*gcd(n,k)```. Note that ```gcd(n,k)``` is the greatest common divisor of ```n``` and ```k```, which is an integer greater than equal to ```1```. **Since ```mk0 - pn0``` could be any valid integer, then every ```gcd(n,k)```-th element in ```arr``` should be equal.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCollect every ```gcd(n,k)```-th element in a group, compute the median, calculate the number of adds and removes to move other elements to the median. Sum up all numbers for each group to get the answer.\\n\\n\\n# Complexity\\n- Time complexity: ```O(n log n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        ans, d = 0, math.gcd(n,k)\\n        for i in range(d):\\n            subarr = sorted(arr[i:n:d])\\n            median = subarr[len(subarr)//2]\\n            ans += sum(abs(a - median) for a in subarr)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```n = len(arr)```\n```k```\n```gcd(n,k)```\n```arr```\n```arr```\n```arr[i]+...+arr[i+k-1] = arr[i+1]+...+arr[i+k]```\n```arr[i] = arr[i+k]```\n```arr[i] = arr[i+mk]```\n```m```\n```i+mk < n```\n```arr```\n```0<= i,j < n```\n```m, p```\n```j = i + mk - pn```\n```arr[i] = arr[j]```\n```i, j```\n```j - i = mk - pn = (mk0 - pn0)*gcd(n,k)```\n```k = k0*gcd(n,k)```\n```n = n0*gcd(n,k)```\n```gcd(n,k)```\n```n```\n```k```\n```1```\n```mk0 - pn0```\n```gcd(n,k)```\n```arr```\n```gcd(n,k)```\n```O(n log n)```\n```O(n)```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        ans, d = 0, math.gcd(n,k)\\n        for i in range(d):\\n            subarr = sorted(arr[i:n:d])\\n            median = subarr[len(subarr)//2]\\n            ans += sum(abs(a - median) for a in subarr)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394943,
                "title": "unionfind-solution-intuitive-but-slow",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.rank = [1 for i in range(n)]\\n        self.pr = [i for i in range(n)]\\n    \\n    def union(self, n1, n2):\\n        p1, p2 = self.find(n1), self.find(n2)\\n        if p1 != p2:\\n            if self.rank[p1] >= self.pr[p2]:\\n                self.rank[p1] += self.rank[p2]\\n                self.pr[p2] = p1\\n            else:\\n                self.rank[p2] += self.pr[p1]\\n                self.pr[p1] = p2\\n    \\n    def find(self, n) -> int:\\n        while n != self.pr[n]:\\n            n = self.pr[n]\\n        return n\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        # 2023/04/08 11:02AM -> 11:52AM\\n        # create unionFind object\\n        uf = UnionFind(len(arr))\\n        # connect indices that need to equal\\n        for i in range(len(arr)):\\n            n1, n2 = i, (i + k) % len(arr)\\n            uf.union(n1, n2)\\n        groups = collections.defaultdict(list)\\n        # get groups\\n        for i, a in enumerate(arr):\\n            groups[uf.find(i)].append(a)\\n        # loop thru groups\\n        res = 0\\n        for p, l in groups.items():\\n            target = int(median(l))\\n            for i in l:\\n                res += abs(i - target)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.rank = [1 for i in range(n)]\\n        self.pr = [i for i in range(n)]\\n    \\n    def union(self, n1, n2):\\n        p1, p2 = self.find(n1), self.find(n2)\\n        if p1 != p2:\\n            if self.rank[p1] >= self.pr[p2]:\\n                self.rank[p1] += self.rank[p2]\\n                self.pr[p2] = p1\\n            else:\\n                self.rank[p2] += self.pr[p1]\\n                self.pr[p1] = p2\\n    \\n    def find(self, n) -> int:\\n        while n != self.pr[n]:\\n            n = self.pr[n]\\n        return n\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        # 2023/04/08 11:02AM -> 11:52AM\\n        # create unionFind object\\n        uf = UnionFind(len(arr))\\n        # connect indices that need to equal\\n        for i in range(len(arr)):\\n            n1, n2 = i, (i + k) % len(arr)\\n            uf.union(n1, n2)\\n        groups = collections.defaultdict(list)\\n        # get groups\\n        for i, a in enumerate(arr):\\n            groups[uf.find(i)].append(a)\\n        # loop thru groups\\n        res = 0\\n        for p, l in groups.items():\\n            target = int(median(l))\\n            for i in l:\\n                res += abs(i - target)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376184,
                "title": "python-explanation-why-gcd",
                "content": "Right from the beginning: I am not that smart to solve this by myself. It took some time to read the solutions given by others. Specifically [this post](https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366442/python3-find-median-of-each-gcd-defined-subarray-w-examples/) by [xil899](https://leetcode.com/xil899/) was very helpful\\n\\n# Approach\\nFirst let\\'s deal with the regular array taking, for example, `k = 4` and writing the conditions to be satisfied for subarrays to be equal\\n\\n$$ a_{0} + a_{1} + a_{2} + a_{3} = a_{1} + a_{2}+ a_{3} + a_{4};   \\\\rightarrow a_{0} = a_{4}$$\\n$$ a_{1} + a_{2}+ a_{3} + a_{4} = a_{2} + a_{3}+ a_{4} + a_{5};   \\\\rightarrow a_{1} = a_{5}$$\\n$$ a_{2} + a_{3}+ a_{4} + a_{5} = a_{3}+ a_{4} + a_{5} + a_{6};   \\\\rightarrow a_{2} = a_{6}$$\\n$$ a_{3}+ a_{4} + a_{5} + a_{6} = a_{4} + a_{5} + a_{6} + a_{7} ;   \\\\rightarrow a_{3} = a_{7}$$\\n...\\nYou probably got the point. Now we know that to make all subarrays of length `k` equal we must have\\n$$ a_{0} = a_{4} = a_{8} = ...$$\\n$$ a_{1} = a_{5} = a_{9} = ...$$\\n$$ a_{2} = a_{6} = a_{10} = ...$$\\n...\\n\\nNow for each of a<sub>i</sub> group that needs to be equal we have to solve problem [462 \"Minimum Moves to Equal Array Elemens II\"](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/).\\n\\nThe basic idea is the following. For array of two elements `[a, b]`, `a < b` we can select any number `num` between them `a <= num <= b` and equalize `a` and `b` to `num`. The result will be the same regardless of exact `num` value since `num - a + b - num = b - a`.\\nFor the array of length > `2`, we can follow the same logic: select min and max elements of the array. `num` should be between them. Now, delete these two elements and repeat. Finally we end up either with a single element if array size is odd, or with two remaining elements either of which can be selected. Half of deleted elements will be greater (or equal) than remaining element(s), and another half - smaller (or equal). Thus, basically we need to find a median of an array.\\nThe solution of this part (minimum number of operations to equalize array) from [problem 462](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/) is\\n```python\\ndef minMoves2(nums: List[int]) -> int:\\n    median = sorted(nums)[len(nums)//2]\\n    return sum(abs(num - median) for num in nums)\\n# end minMoves2(...)\\n```\\nNow the tricky part: we have to deal somehow with the fact the array is circular. In brief, all the elements with distance equal to the greatest common divisor of `n` and `k` fall into the same group that needs to be equalized. This is demonstrated on the following picture\\n![2607.jpg](https://assets.leetcode.com/users/images/5fac816b-0e10-489a-bf3f-a801ecd1e206_1680551796.0497987.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(arr)\\n        step = gcd(n, k)\\n        for i in range(step):\\n            nums = arr[i::step]\\n            nums.sort()\\n            median_idx = len(nums)//2\\n            median = nums[median_idx]\\n            for num in nums[:median_idx]:\\n                ans += median - num\\n            for num in nums[median_idx:]:\\n                ans += num - median\\n        return ans\\n    # end makeSubKSumEqual()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef minMoves2(nums: List[int]) -> int:\\n    median = sorted(nums)[len(nums)//2]\\n    return sum(abs(num - median) for num in nums)\\n# end minMoves2(...)\\n```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(arr)\\n        step = gcd(n, k)\\n        for i in range(step):\\n            nums = arr[i::step]\\n            nums.sort()\\n            median_idx = len(nums)//2\\n            median = nums[median_idx]\\n            for num in nums[:median_idx]:\\n                ans += median - num\\n            for num in nums[median_idx:]:\\n                ans += num - median\\n        return ans\\n    # end makeSubKSumEqual()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374945,
                "title": "simple-sorting-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity/ -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll res=0;\\n        int n=arr.size();\\n        for(int i=0; i<k; i++){\\n            vector<ll> t;\\n            for(int j=i; arr[j]; j=(j+k)%n){\\n                t.push_back(arr[j]);\\n                arr[j]=0;\\n            }\\n            if(t.size()){\\n                sort(t.begin(), t.end());\\n                ll med=t[t.size()/2];\\n                for(ll no:t)\\n                    res+=abs(no-med);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// [1,4,1,3], 2\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll res=0;\\n        int n=arr.size();\\n        for(int i=0; i<k; i++){\\n            vector<ll> t;\\n            for(int j=i; arr[j]; j=(j+k)%n){\\n                t.push_back(arr[j]);\\n                arr[j]=0;\\n            }\\n            if(t.size()){\\n                sort(t.begin(), t.end());\\n                ll med=t[t.size()/2];\\n                for(ll no:t)\\n                    res+=abs(no-med);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// [1,4,1,3], 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373176,
                "title": "python-greatest-common-divisor-o-n-log-n",
                "content": "1. Consider the example:\\n![image](https://assets.leetcode.com/users/images/26344d41-8ebe-4aa1-91cf-f15912b80fd1_1680499535.2074687.png)\\n`arr[0] + arr[1] + arr[2] + arr[3] = arr[1] + arr[2] + arr[3] + arr[4]`, so `arr[0] = arr[4]`. \\nBy similar calculation we have `arr[0] = arr[4] = arr[2]`, `arr[1] = arr[5] = arr[3]`.\\n2. As above, `arr` can be divided into subarrays of equal length, and the length would be `g := gcd(len(arr), k)`.\\n3. All subarrays would look the same after we finish operations, i.e. `arr[i] = arr[i+g] = arr[i+2*g] = ... for all i`.\\n4. Now the problem becomes: given some integers `i_0, i_1, i_2, ..., i_n`, what `x` would make the sum `abs(i_0 - x) + abs(i_1 - x) + abs(i_2 - x) + ... + abs(i_n - x)` smallest?\\n`x = median(i_0, i_1, i_2, ..., i_n)` would do.\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        gcd = math.gcd(len(arr), k)\\n        \\n        ans = 0\\n        for i in range(gcd):\\n            seq = arr[i::gcd]\\n            m = int(statistics.median(seq))\\n            for n in seq:\\n                ans += abs(n-m)\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Consider the example:\\n![image](https://assets.leetcode.com/users/images/26344d41-8ebe-4aa1-91cf-f15912b80fd1_1680499535.2074687.png)\\n`arr[0] + arr[1] + arr[2] + arr[3] = arr[1] + arr[2] + arr[3] + arr[4]`, so `arr[0] = arr[4]`. \\nBy similar calculation we have `arr[0] = arr[4] = arr[2]`, `arr[1] = arr[5] = arr[3]`.\\n2. As above, `arr` can be divided into subarrays of equal length, and the length would be `g := gcd(len(arr), k)`.\\n3. All subarrays would look the same after we finish operations, i.e. `arr[i] = arr[i+g] = arr[i+2*g] = ... for all i`.\\n4. Now the problem becomes: given some integers `i_0, i_1, i_2, ..., i_n`, what `x` would make the sum `abs(i_0 - x) + abs(i_1 - x) + abs(i_2 - x) + ... + abs(i_n - x)` smallest?\\n`x = median(i_0, i_1, i_2, ..., i_n)` would do.\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        gcd = math.gcd(len(arr), k)\\n        \\n        ans = 0\\n        for i in range(gcd):\\n            seq = arr[i::gcd]\\n            m = int(statistics.median(seq))\\n            for n in seq:\\n                ans += abs(n-m)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3370030,
                "title": "python-update-index-in-cycles-median-explained",
                "content": "**Intuition:**\\n* In order to have K-subarrays sums be equal, for all `i`, `arr[i] == arr[i+k] == arr[i+2*k] ...`.\\n* So we have to update every all these groups of `i` to be the same.\\n* For a particular `i`, we first find all the numbers belonging to that group. Each `i` can only belong to one group, so we used a `visited` boolean array to mark them.\\n* For each group, we need to find the minimal update, that is, which elements has the smallest difference between all elements in a group? That is the median.\\n* The number of operations in each `i` group is the absolute difference of all the elements and the median.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        N = len(arr)\\n        visited = [False]*N\\n        operations = 0\\n        for i in range(N):\\n            if visited[i]:\\n                continue\\n            visited[i] = True\\n            group = [arr[i]]\\n            j = (i+k)%N\\n            while not visited[j]:\\n                group.append(arr[j])\\n                visited[j] = True\\n                j = (j+k)%N\\n            group.sort()\\n            median = group[len(group)//2]\\n            operations += sum(abs(num-median) for num in group)\\n        return operations\\n```\\n\\n**Complexity Analysis:**\\n- Time Complexity: `O(NlogN)`\\n\\t- In the worst case, the sort will have `N` elements, this happens when `k=1`.\\n- Space Complexity: `O(N)`\\n\\t- For the `visited` boolean array.",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        N = len(arr)\\n        visited = [False]*N\\n        operations = 0\\n        for i in range(N):\\n            if visited[i]:\\n                continue\\n            visited[i] = True\\n            group = [arr[i]]\\n            j = (i+k)%N\\n            while not visited[j]:\\n                group.append(arr[j])\\n                visited[j] = True\\n                j = (j+k)%N\\n            group.sort()\\n            median = group[len(group)//2]\\n            operations += sum(abs(num-median) for num in group)\\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367794,
                "title": "golang-time-o-nlogn-gcd-medians",
                "content": "# Approach\\nFind Greatest common divisor of the array length and k.\\nFor example length=16, k=12, then GCD=4.\\n\\n```\\n______k=12_elements____\\n2,3,4,9,8,7,6,5,4,1,2,3,6,4,3,8\\n\\u203EGCD=4\\u203E\\n```\\n\\nWe split the list into chunks of length GCD=4.\\nNow we need to consider only the 0th elements from each chunk and make them equal, with the minimum number of increment/decrement operations. \\n\\n```\\nv       v       v       v\\n2,3,4,9,8,7,6,2,4,1,7,3,6,5,9,1\\n\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\n\\n[2,8,4,6]\\n```\\nThey must be equal to the median element from the list. The sum of absolute differences between the median and each element is the required minimum of operations to make all elements equal (to median).\\n```\\nmedian([2,8,4,6]) = median([2,4,6,8]) = 6  (or 4, doesn\\'t matter)\\nnum_of_operations = abs(2-6)+abs(4-6)+abs(6-6)+abs(8-6) = 8\\n```\\nCalculate `num_of_operations` for the remaining collections of elements with step GCD\\n```\\n  v       v       v       v\\n6,3,4,9,6,7,6,2,6,1,7,3,6,5,9,1\\n\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\n\\nevery 1st [3,7,1,5]\\nevery 2nd [4,6,7,9]\\nevery 3rd [9,2,3,1]\\n```\\nThe total sum of `num_of_operations` is the answer\\n\\n---\\n\\nAfter applying all the operations (we don\\'t need to actually update the list, it\\'s only for the explanation) the list will look like:\\n```\\n______k=12_elements____\\n6,5,7,3,6,5,7,3,6,5,7,3,6,5,7,3\\n\\u203E\\u203E\\u203E\\u203E\\u203E         \\u203E\\u203Ek=12_elements\\u203E\\u203E\\n```\\nEach sublist with k=12 elements will contain exactly the same set of elements: 3 chunks with [6,5,7,3] elements\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\nSorting lists in order to find median elements.\\nI also tried QuickSelect for finding the medians with avg~O(n), but the runtime was much longer (180ms vs 600ms).\\n\\n- Space complexity: $$O(n/gcd(n,k))$$\\n\\n# Code\\n```\\nfunc makeSubKSumEqual(arr []int, k int) int64 {\\n    n := len(arr)\\n    steppedListNum := gcd(n, k)\\n    steppedListLen := n / steppedListNum\\n    steppedList := make([]int, steppedListLen)\\n    result := 0\\n\\n    for shift:=0; shift<steppedListNum; shift++ {\\n        for i:=0; i<steppedListLen; i++ {\\n            steppedList[i] = arr[i*steppedListNum + shift]\\n        }\\n        sort.Ints(steppedList)\\n        median := steppedList[steppedListLen/2]\\n        for _, el := range steppedList {\\n            result += abs(median-el)\\n        }\\n    }\\n    return int64(result)\\n}\\n\\nfunc gcd(a, b int) int {\\n    for b != 0 {\\n        a, b = b, a%b\\n    }\\n    return a\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 { return a }\\n    return -a\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\n______k=12_elements____\\n2,3,4,9,8,7,6,5,4,1,2,3,6,4,3,8\\n\\u203EGCD=4\\u203E\\n```\n```\\nv       v       v       v\\n2,3,4,9,8,7,6,2,4,1,7,3,6,5,9,1\\n\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\n\\n[2,8,4,6]\\n```\n```\\nmedian([2,8,4,6]) = median([2,4,6,8]) = 6  (or 4, doesn\\'t matter)\\nnum_of_operations = abs(2-6)+abs(4-6)+abs(6-6)+abs(8-6) = 8\\n```\n```\\n  v       v       v       v\\n6,3,4,9,6,7,6,2,6,1,7,3,6,5,9,1\\n\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\n\\nevery 1st [3,7,1,5]\\nevery 2nd [4,6,7,9]\\nevery 3rd [9,2,3,1]\\n```\n```\\n______k=12_elements____\\n6,5,7,3,6,5,7,3,6,5,7,3,6,5,7,3\\n\\u203E\\u203E\\u203E\\u203E\\u203E         \\u203E\\u203Ek=12_elements\\u203E\\u203E\\n```\n```\\nfunc makeSubKSumEqual(arr []int, k int) int64 {\\n    n := len(arr)\\n    steppedListNum := gcd(n, k)\\n    steppedListLen := n / steppedListNum\\n    steppedList := make([]int, steppedListLen)\\n    result := 0\\n\\n    for shift:=0; shift<steppedListNum; shift++ {\\n        for i:=0; i<steppedListLen; i++ {\\n            steppedList[i] = arr[i*steppedListNum + shift]\\n        }\\n        sort.Ints(steppedList)\\n        median := steppedList[steppedListLen/2]\\n        for _, el := range steppedList {\\n            result += abs(median-el)\\n        }\\n    }\\n    return int64(result)\\n}\\n\\nfunc gcd(a, b int) int {\\n    for b != 0 {\\n        a, b = b, a%b\\n    }\\n    return a\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 { return a }\\n    return -a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367625,
                "title": "cluster-partition-of-indices-elements-congruence-python",
                "content": "```\\n\"\"\"\\nTreatment: Congruence\\n\\nThe requirment in this problem actually partitions the indices into clusters.\\nWithin each cluster, all the corresponding elements shall be equal. To make all\\nelements within a cluster equal, we make all element equal to the median.\\n\\nE.g. arr = [2,5,5,7] = [a_0, a_1, a_2, a_3], k = 3\\n\\nTo make length-k sum to be equal, we need:\\n\\na_0 + a_1 + a_2 = a_1 + a_2 + a_3 => a_0 = a_3\\na_1 + a_2 + a_3 = a_2 + a_3 + a_0 => a_1 = a_0 \\na_2 + a_3 + a_1 = a_3 + a_1 + a_2 => a_3 = a_1\\na_3 + a_0 + a_1. = a_0 + a_1 + a_2 => a3 = a_2\\n\\nThis induces a single cluster: {0, 1, 2, 3}. So we need to use as less ops as possible\\nto make all the corresponding 4 elements equal.\\n\\nLet us see the same arr with k = 2:\\n\\na_0 + a_1 = a_1 + a_2 => a_0 = a_2\\na_1 + a_2 = a_2 + a_3 => a_1 = a_3\\na_2 + a_3 = a_3 + a_0 => a_2 = a_0\\na_3 + a_0 = a_0 + a_1 => a_3 = a_1\\n\\nThis induces two clusters: {0, 2}, {1, 3}. So we need to use as less ops as possible\\nto make elements in each cluster equal.\\n\\nHow to get the clusters?\\n\\nLet d = gcd(n, k) where n = len(arr). Then starting from an fixed index, say i_0,\\nthen indices of form i_0 + k * d lie in the same group/cluster. In other words,\\ntwo indices i, j lie in the same cluster if and only if i - j = 0 (mod d). Or in plain\\nEnglish, the difference between i, j is a multiple of d.\\n\\nIn the example above, when k = 3, d = gcd(4, 3) = 1; while when k = 2,  d = gcd(4, 2) = 2.\\n\\nFollow up at Youtube Channel \"Code-Yao\"\\n\"\"\"\\n\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        d = math.gcd(n, k)\\n        res = 0\\n        for i in range(d):\\n            tmp = sorted([arr[j] for j in range(i, n, d)])\\n            median = tmp[len(tmp) // 2]\\n            res += sum(abs(num - median) for num in tmp)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: Congruence\\n\\nThe requirment in this problem actually partitions the indices into clusters.\\nWithin each cluster, all the corresponding elements shall be equal. To make all\\nelements within a cluster equal, we make all element equal to the median.\\n\\nE.g. arr = [2,5,5,7] = [a_0, a_1, a_2, a_3], k = 3\\n\\nTo make length-k sum to be equal, we need:\\n\\na_0 + a_1 + a_2 = a_1 + a_2 + a_3 => a_0 = a_3\\na_1 + a_2 + a_3 = a_2 + a_3 + a_0 => a_1 = a_0 \\na_2 + a_3 + a_1 = a_3 + a_1 + a_2 => a_3 = a_1\\na_3 + a_0 + a_1. = a_0 + a_1 + a_2 => a3 = a_2\\n\\nThis induces a single cluster: {0, 1, 2, 3}. So we need to use as less ops as possible\\nto make all the corresponding 4 elements equal.\\n\\nLet us see the same arr with k = 2:\\n\\na_0 + a_1 = a_1 + a_2 => a_0 = a_2\\na_1 + a_2 = a_2 + a_3 => a_1 = a_3\\na_2 + a_3 = a_3 + a_0 => a_2 = a_0\\na_3 + a_0 = a_0 + a_1 => a_3 = a_1\\n\\nThis induces two clusters: {0, 2}, {1, 3}. So we need to use as less ops as possible\\nto make elements in each cluster equal.\\n\\nHow to get the clusters?\\n\\nLet d = gcd(n, k) where n = len(arr). Then starting from an fixed index, say i_0,\\nthen indices of form i_0 + k * d lie in the same group/cluster. In other words,\\ntwo indices i, j lie in the same cluster if and only if i - j = 0 (mod d). Or in plain\\nEnglish, the difference between i, j is a multiple of d.\\n\\nIn the example above, when k = 3, d = gcd(4, 3) = 1; while when k = 2,  d = gcd(4, 2) = 2.\\n\\nFollow up at Youtube Channel \"Code-Yao\"\\n\"\"\"\\n\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        d = math.gcd(n, k)\\n        res = 0\\n        for i in range(d):\\n            tmp = sorted([arr[j] for j in range(i, n, d)])\\n            median = tmp[len(tmp) // 2]\\n            res += sum(abs(num - median) for num in tmp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367330,
                "title": "video-editorial-100-working",
                "content": "Link of the video - https://www.youtube.com/watch?v=86doDvV6Gdc&t=2s\\n\\n\\nHope it helps!\\nPlease like, share and subscribe if it does.",
                "solutionTags": [
                    "C++"
                ],
                "code": "Link of the video - https://www.youtube.com/watch?v=86doDvV6Gdc&t=2s\\n\\n\\nHope it helps!\\nPlease like, share and subscribe if it does.",
                "codeTag": "Unknown"
            },
            {
                "id": 3367155,
                "title": "detailed-explanation-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you observe then you get to know that the condition must be arr[i]==arr[i+k] and arr[i]==arr[i+2*k] and so on.so, lets take the all number from i, i+k, i+2*k ... so on.Then, make all the element equal. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s a detailed explanation of the code:\\n\\n1.Define a macro for long long (ll), which makes it easier to use long long integers in the code.\\n\\n2.The solve() function takes a vector of integers v as input and returns a long long integer. This function calculates the minimum total cost to make all elements in the vector v equal. The steps are as follows:\\na. Sort the vector v in non-decreasing order.\\nb. Find the median element in the vector v using the nth_element function from the C++ Standard Library.\\nc. Initialize a variable ans to store the total cost, initially set to 0.\\nd. Iterate through each element in the vector v and add the absolute difference between the current element and the median value to ans.\\ne. Return the total cost ans.\\n\\n3.The makeSubKSumEqual() function takes a vector of integers arr and an integer k as input and returns a long long integer. This function calculates the minimum total cost to make the sum of elements in every subsequence of length k equal in the array arr. The steps are as follows:\\na. Initialize a variable ans to store the total cost, initially set to 0.\\nb. Iterate through each element in the array arr using the variable i.\\nc. If the current element arr[i] is not 0, perform the following steps:\\n\\n->Initialize a vector v to store the elements of the subsequence.\\n\\n->Iterate through the array arr starting from the index i, with a step size of k. For each element in this iteration, add the element to the vector v and set the corresponding element in arr to 0.\\n\\n->Call the solve() function with the vector v as input and add the returned cost to ans.\\n\\n4.Return the total cost ans from the makeSubKSumEqual() function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll solve(vector<int> &v)\\n    {\\n     sort(v.begin(),v.end());\\n     int n;\\n     nth_element(begin(v), begin(v) + v.size() / 2, end(v));\\n      n=v[v.size()/2];\\n     ll ans=0;\\n     for(int i=0;i<v.size();i++)\\n     {\\n       ans+=(abs(n-v[i]));  \\n     }\\n     return ans;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    ll ans=0;\\n    int n=arr.size();\\n    for(int i=0;i<n;i++)\\n    {\\n      vector<int> v;  \\n     if(arr[i]!=0)\\n     {\\n      for(int j=i;arr[j%n]!=0;j+=k)\\n      {\\n       j=j%n;\\n       v.push_back(arr[j]);\\n       arr[j]=0;\\n      }\\n       ans+=(solve(v));  \\n     }   \\n    }\\n    return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll solve(vector<int> &v)\\n    {\\n     sort(v.begin(),v.end());\\n     int n;\\n     nth_element(begin(v), begin(v) + v.size() / 2, end(v));\\n      n=v[v.size()/2];\\n     ll ans=0;\\n     for(int i=0;i<v.size();i++)\\n     {\\n       ans+=(abs(n-v[i]));  \\n     }\\n     return ans;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    ll ans=0;\\n    int n=arr.size();\\n    for(int i=0;i<n;i++)\\n    {\\n      vector<int> v;  \\n     if(arr[i]!=0)\\n     {\\n      for(int j=i;arr[j%n]!=0;j+=k)\\n      {\\n       j=j%n;\\n       v.push_back(arr[j]);\\n       arr[j]=0;\\n      }\\n       ans+=(solve(v));  \\n     }   \\n    }\\n    return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366846,
                "title": "javascript-median-greedy-254ms",
                "content": "```\\nconst makeSubKSumEqual = (a, k) => medianGreedy(a, k)\\n\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst medianGreedy = (a, k) => {\\n    k = gcd(a.length, k);\\n    let res = 0;\\n    for (let i = 0; i < k; i++) {\\n        let b = [];\\n        for (let j = i; j < a.length; j += k) b.push(a[j]); // collect gcd(n, k) elements based on B\\xE9zout\\'s identity\\n        b.sort((x, y) => x - y);\\n        let mid = b[b.length >> 1];\\n        for (const x of b) res += Math.abs(x - mid); // greedy: reach to median have lowest cost\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nconst makeSubKSumEqual = (a, k) => medianGreedy(a, k)\\n\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst medianGreedy = (a, k) => {\\n    k = gcd(a.length, k);\\n    let res = 0;\\n    for (let i = 0; i < k; i++) {\\n        let b = [];\\n        for (let j = i; j < a.length; j += k) b.push(a[j]); // collect gcd(n, k) elements based on B\\xE9zout\\'s identity\\n        b.sort((x, y) => x - y);\\n        let mid = b[b.length >> 1];\\n        for (const x of b) res += Math.abs(x - mid); // greedy: reach to median have lowest cost\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366676,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        g = gcd(n, k)\\n        ret = 0\\n        for i in range(g):\\n            med = int(median(arr[i::g]))\\n            ret += sum(abs(a-med) for a in arr[i::g])\\n            \\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        g = gcd(n, k)\\n        ret = 0\\n        for i in range(g):\\n            med = int(median(arr[i::g]))\\n            ret += sum(abs(a-med) for a in arr[i::g])\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366621,
                "title": "python-3-disjoin-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ufds:\\n    parent_node = {}\\n    rank = {}\\n\\n    def make_set(self, u):\\n        for i in u:\\n            self.parent_node[i] = i\\n            self.rank[i] = 0\\n\\n    def op_find(self, k):\\n        if self.parent_node[k] != k:\\n            self.parent_node[k] = self.op_find(self.parent_node[k])\\n        return self.parent_node[k]\\n\\n    def op_union(self, a, b):\\n        x = self.op_find(a)\\n        y = self.op_find(b)\\n        \\n        if x == y:\\n            return\\n        if self.rank[x] > self.rank[y]:\\n            self.parent_node[y] = x\\n        elif self.rank[x] < self.rank[y]:\\n            self.parent_node[x] = y\\n        else:\\n            self.parent_node[x] = y\\n            self.rank[y] = self.rank[y] + 1\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def find_min_abs_sum(arr):\\n            n = len(arr)\\n            arr.sort()\\n            middle = arr[n//2]\\n            curr = 0\\n            for i in arr:\\n                curr += abs(i-middle)\\n            return curr\\n    \\n        if k==1:\\n            return find_min_abs_sum(arr)\\n\\n        uds = ufds()\\n        n = len(arr)\\n        uds.make_set(list(range(n)))\\n\\n        for i in range(n):\\n            uds.op_union(i, (i + k) % n)\\n\\n        dd = defaultdict(list)\\n        for i in range(n):\\n            dd[uds.op_find(i)].append(arr[i])\\n            \\n        res = 0\\n        for key in dd:\\n            temarr = dd[key]\\n            res += find_min_abs_sum(temarr)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ufds:\\n    parent_node = {}\\n    rank = {}\\n\\n    def make_set(self, u):\\n        for i in u:\\n            self.parent_node[i] = i\\n            self.rank[i] = 0\\n\\n    def op_find(self, k):\\n        if self.parent_node[k] != k:\\n            self.parent_node[k] = self.op_find(self.parent_node[k])\\n        return self.parent_node[k]\\n\\n    def op_union(self, a, b):\\n        x = self.op_find(a)\\n        y = self.op_find(b)\\n        \\n        if x == y:\\n            return\\n        if self.rank[x] > self.rank[y]:\\n            self.parent_node[y] = x\\n        elif self.rank[x] < self.rank[y]:\\n            self.parent_node[x] = y\\n        else:\\n            self.parent_node[x] = y\\n            self.rank[y] = self.rank[y] + 1\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def find_min_abs_sum(arr):\\n            n = len(arr)\\n            arr.sort()\\n            middle = arr[n//2]\\n            curr = 0\\n            for i in arr:\\n                curr += abs(i-middle)\\n            return curr\\n    \\n        if k==1:\\n            return find_min_abs_sum(arr)\\n\\n        uds = ufds()\\n        n = len(arr)\\n        uds.make_set(list(range(n)))\\n\\n        for i in range(n):\\n            uds.op_union(i, (i + k) % n)\\n\\n        dd = defaultdict(list)\\n        for i in range(n):\\n            dd[uds.op_find(i)].append(arr[i])\\n            \\n        res = 0\\n        for key in dd:\\n            temarr = dd[key]\\n            res += find_min_abs_sum(temarr)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057530,
                "title": "simple-solution-with-better-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to restructure the array in such a way that it contains a pattern like,  the element going out from the window is similar to the element comming into the window\\n- (x, y, z, x, y, z, x, y, z) for window of size 3\\n- pattern size must be equal to the gcd(n, k)\\n- x_g = median(a[i], a[i + g], a[i + 2g], ....)\\n- So the total number of operation for each element will be equal to abs(x_g - arr[i + g])\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: $$O(n)$$ -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: $$O(n)$$\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n        g = gcd(n, k)   # pattern_len\\n        ans = 0\\n\\n        for i in range(g):\\n        \\n            # Finding the median of (a[i], a[i + g], a[i + 2g], ....)\\n            x_g = int(median(arr[i::g]))\\n        \\n            # Finding the total number of operation required to transform the current element to median\\n            ans += sum(abs(x_g - a) for a in arr[i::g])\\n        \\n        return ans\\n\\n```\\n\\nThanks\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3367499/gcd-median-c-python-greedy/",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n        g = gcd(n, k)   # pattern_len\\n        ans = 0\\n\\n        for i in range(g):\\n        \\n            # Finding the median of (a[i], a[i + g], a[i + 2g], ....)\\n            x_g = int(median(arr[i::g]))\\n        \\n            # Finding the total number of operation required to transform the current element to median\\n            ans += sum(abs(x_g - a) for a in arr[i::g])\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047055,
                "title": "detailed-approach-explanation-math-number-theory",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. All k-sized segments (subarrays) have equal sums | xors <=> arr[i] = arr[i+k].\\n2. Arrays allow circular indexing: gcd(n, k) disjoint sets of indexes needed to cover the entire array. All the sets have the same size = n / gcd(n, k).\\n3. Because of disjoint sets, (1) <=> all elements of each set have to be equal, verify each set independently. So the minimum number of operations is the sum of the minimum number of operations of each set. \\n4. For each set, all its elements end up to be equal to a value c. The number of operations needed is f(c) = sum(|element - c|). c yields the minimum number of operations <=> differentiation of f(c): f\\'(c) = 0 <=> c is median. In case set.size is even, choosing any c in [leftMedian, rightMedian] still produce minimum. (leftMedian, rightMedian are elements that contributes to the median).\\n\\n# Complexity\\n- Time complexity: depends on the algorithm Find median is used.\\n    Comparison-based Sort: O(nlogn).\\n    Random partition: O(n), average running time. (used in code)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n / gcd(n/k))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\n\\nfunction gcd(a, b){\\n    if(b == 0){\\n        return a;\\n    }\\n\\n    return gcd(b, a%b);\\n}\\nfunction partition(arr, left, right){\\n    if(left >= right){\\n        return left;\\n    }\\n    let randomPivotIdx = left + Math.floor(Math.random() * (right - left + 1));\\n    [arr[right], arr[randomPivotIdx]] = [arr[randomPivotIdx], arr[right]];\\n\\n\\n    let i = left - 1;\\n    for(let j = left; j < right; j++){\\n        if(arr[j] >= arr[right]){\\n            continue;\\n        }\\n\\n        [arr[j], arr[i+1]] = [arr[i+1], arr[j]];\\n        i++;\\n    }\\n    [arr[right], arr[i+1]] = [arr[i+1], arr[right]];\\n\\n    \\n    return i + 1;\\n}\\n\\nfunction findMedian(arr){\\n    if(arr.length <= 2){\\n        return arr[0];\\n    }\\n    let left = 0;\\n    let right = arr.length - 1;\\n    let medianIdx = Math.floor(arr.length / 2);\\n    let mid;\\n    while((mid = partition(arr, left, right)) != medianIdx){\\n        if(mid < medianIdx){\\n            left = mid + 1;\\n        }else{\\n            right = mid - 1;\\n        }\\n    }\\n\\n    return arr[mid];\\n}\\n\\nvar makeSubKSumEqual = function(arr, k) {\\n    let n = arr.length;\\n    let numbOfSets = gcd(n, k);\\n    let setSize = n / numbOfSets;\\n    let minOps = 0;\\n\\n    // \\n    for(let i = 0; i < numbOfSets; i++){\\n        let set = [];\\n        for(let j = 0; j < setSize; j++){\\n            set.push(arr[(i + j*k) % n]);\\n        }\\n\\n        // let medianSet = set.sort((a,b) => a-b)[Math.floor(set.length/2)];\\n        let medianSet = findMedian(set);\\n        set.forEach(element => minOps += Math.abs(element -medianSet));\\n    }\\n\\n    return minOps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\n\\nfunction gcd(a, b){\\n    if(b == 0){\\n        return a;\\n    }\\n\\n    return gcd(b, a%b);\\n}\\nfunction partition(arr, left, right){\\n    if(left >= right){\\n        return left;\\n    }\\n    let randomPivotIdx = left + Math.floor(Math.random() * (right - left + 1));\\n    [arr[right], arr[randomPivotIdx]] = [arr[randomPivotIdx], arr[right]];\\n\\n\\n    let i = left - 1;\\n    for(let j = left; j < right; j++){\\n        if(arr[j] >= arr[right]){\\n            continue;\\n        }\\n\\n        [arr[j], arr[i+1]] = [arr[i+1], arr[j]];\\n        i++;\\n    }\\n    [arr[right], arr[i+1]] = [arr[i+1], arr[right]];\\n\\n    \\n    return i + 1;\\n}\\n\\nfunction findMedian(arr){\\n    if(arr.length <= 2){\\n        return arr[0];\\n    }\\n    let left = 0;\\n    let right = arr.length - 1;\\n    let medianIdx = Math.floor(arr.length / 2);\\n    let mid;\\n    while((mid = partition(arr, left, right)) != medianIdx){\\n        if(mid < medianIdx){\\n            left = mid + 1;\\n        }else{\\n            right = mid - 1;\\n        }\\n    }\\n\\n    return arr[mid];\\n}\\n\\nvar makeSubKSumEqual = function(arr, k) {\\n    let n = arr.length;\\n    let numbOfSets = gcd(n, k);\\n    let setSize = n / numbOfSets;\\n    let minOps = 0;\\n\\n    // \\n    for(let i = 0; i < numbOfSets; i++){\\n        let set = [];\\n        for(let j = 0; j < setSize; j++){\\n            set.push(arr[(i + j*k) % n]);\\n        }\\n\\n        // let medianSet = set.sort((a,b) => a-b)[Math.floor(set.length/2)];\\n        let medianSet = findMedian(set);\\n        set.forEach(element => minOps += Math.abs(element -medianSet));\\n    }\\n\\n    return minOps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042027,
                "title": "java-clean-code-gcd-grouping-median-cost",
                "content": "# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int steps = gcd(arr.length,k);\\n        int numberOfGroups = steps;\\n        long result=0;\\n        for(int groupStartIndex=0;groupStartIndex<numberOfGroups;groupStartIndex++)\\n        {\\n            int groupSize = arr.length / steps;\\n            int group[] = new int[groupSize];\\n            int j=0;\\n            for(int i=groupStartIndex;i<arr.length;i+=steps)\\n            {\\n                group[j] = arr[i];\\n                j++;\\n            }\\n           \\n            Arrays.sort(group);\\n            long operationsToEquateNumstoMedian = 0;\\n            int midIndex = group.length/2;\\n            int median = group[midIndex];\\n            for(int el:group)\\n            {\\n                operationsToEquateNumstoMedian += Math.abs(median-el);\\n            }\\n            result += operationsToEquateNumstoMedian;\\n        }\\n        return result;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n}\\n/*\\n\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; k=3 ; n=length\\nNumber of groups = gcd(n,k)\\nSize of each group = n/gcd;\\nG1: 1,4,7,10,13\\nG2: 2,5,8,11,14\\nG3: 3,6,9,12,15\\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int steps = gcd(arr.length,k);\\n        int numberOfGroups = steps;\\n        long result=0;\\n        for(int groupStartIndex=0;groupStartIndex<numberOfGroups;groupStartIndex++)\\n        {\\n            int groupSize = arr.length / steps;\\n            int group[] = new int[groupSize];\\n            int j=0;\\n            for(int i=groupStartIndex;i<arr.length;i+=steps)\\n            {\\n                group[j] = arr[i];\\n                j++;\\n            }\\n           \\n            Arrays.sort(group);\\n            long operationsToEquateNumstoMedian = 0;\\n            int midIndex = group.length/2;\\n            int median = group[midIndex];\\n            for(int el:group)\\n            {\\n                operationsToEquateNumstoMedian += Math.abs(median-el);\\n            }\\n            result += operationsToEquateNumstoMedian;\\n        }\\n        return result;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n}\\n/*\\n\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; k=3 ; n=length\\nNumber of groups = gcd(n,k)\\nSize of each group = n/gcd;\\nG1: 1,4,7,10,13\\nG2: 2,5,8,11,14\\nG3: 3,6,9,12,15\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925046,
                "title": "beats-92-c-check-this-out",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Try in this way!\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    // If the sum of each subarray of length k is equal, `arr` must have\\n    // repeated pattern of size k. E.g. arr = [1, 2, 3, ...] and k = 3, to have\\n    // sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\\n    // arr[(i + k) % n] for every i.\\n    const int n = arr.size();\\n    long long ans = 0;\\n    vector<bool> seen(n);\\n\\n    for (int i = 0; i < n; ++i) {\\n      vector<int> groups;\\n      int j = i;\\n      while (!seen[j]) {\\n        groups.push_back(arr[j]);\\n        seen[j] = true;\\n        j = (j + k) % n;\\n      }\\n      nth_element(groups.begin(), groups.begin() + groups.size() / 2,\\n                  groups.end());\\n      for (const int num : groups)\\n        ans += abs(num - groups[groups.size() / 2]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    // If the sum of each subarray of length k is equal, `arr` must have\\n    // repeated pattern of size k. E.g. arr = [1, 2, 3, ...] and k = 3, to have\\n    // sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\\n    // arr[(i + k) % n] for every i.\\n    const int n = arr.size();\\n    long long ans = 0;\\n    vector<bool> seen(n);\\n\\n    for (int i = 0; i < n; ++i) {\\n      vector<int> groups;\\n      int j = i;\\n      while (!seen[j]) {\\n        groups.push_back(arr[j]);\\n        seen[j] = true;\\n        j = (j + k) % n;\\n      }\\n      nth_element(groups.begin(), groups.begin() + groups.size() / 2,\\n                  groups.end());\\n      for (const int num : groups)\\n        ans += abs(num - groups[groups.size() / 2]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918931,
                "title": "golang-binary-search-solution",
                "content": "# Code\\n```go\\nfunc makeSubKSumEqual(arr []int, k int) int64 {\\n\\tif len(arr) == k {\\n\\t\\treturn 0\\n\\t}\\n\\tg := gcd(len(arr), k)\\n\\tcost := int64(0)\\n\\tfor i := 0; i < g; i++ {\\n\\t\\telem := make([]int, 0, 16)\\n\\t\\tfor j := i; j < len(arr); j += g {\\n\\t\\t\\telem = append(elem, arr[j])\\n\\t\\t}\\n\\t\\tcost += makeAllEqual(elem)\\n\\t}\\n\\treturn cost\\n}\\n\\nfunc makeAllEqual(arr []int) int64 {\\n\\tif len(arr) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tl, r := arr[0], arr[0]\\n\\tfor _, v := range arr {\\n\\t\\tif l > v {\\n\\t\\t\\tl = v\\n\\t\\t}\\n\\t\\tif r < v {\\n\\t\\t\\tr = v\\n\\t\\t}\\n\\t}\\n\\tm := 0\\n\\tfor l <= r {\\n\\t\\tm = (l+r) >> 1\\n\\t\\tif diff(arr, m) <= diff(arr, m+1) {\\n\\t\\t\\tr = m-1\\n\\t\\t} else {\\n\\t\\t\\tl = m+1\\n\\t\\t}\\n\\t}\\n\\tdiff1 := diff(arr, r+1)\\n\\tdiff2 := diff(arr, l)\\n\\tif diff1 < diff2 {\\n\\t\\treturn diff1\\n\\t}\\n\\treturn diff2\\n}\\n\\nfunc diff(arr []int, d int) int64 {\\n\\tdv := 0\\n\\tfor _, v := range arr {\\n\\t\\tif v >= d {\\n\\t\\t\\tdv += v-d\\n\\t\\t} else {\\n\\t\\t\\tdv += d-v\\n\\t\\t}\\n\\t}\\n\\treturn int64(dv)\\n}\\n\\nfunc gcd(x, y int) int {\\n\\tif x < y {\\n\\t\\tx, y = y, x\\n\\t}\\n\\tif x%y == 0 {\\n\\t\\treturn y\\n\\t}\\n\\treturn gcd(y, x%y)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\nfunc makeSubKSumEqual(arr []int, k int) int64 {\\n\\tif len(arr) == k {\\n\\t\\treturn 0\\n\\t}\\n\\tg := gcd(len(arr), k)\\n\\tcost := int64(0)\\n\\tfor i := 0; i < g; i++ {\\n\\t\\telem := make([]int, 0, 16)\\n\\t\\tfor j := i; j < len(arr); j += g {\\n\\t\\t\\telem = append(elem, arr[j])\\n\\t\\t}\\n\\t\\tcost += makeAllEqual(elem)\\n\\t}\\n\\treturn cost\\n}\\n\\nfunc makeAllEqual(arr []int) int64 {\\n\\tif len(arr) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tl, r := arr[0], arr[0]\\n\\tfor _, v := range arr {\\n\\t\\tif l > v {\\n\\t\\t\\tl = v\\n\\t\\t}\\n\\t\\tif r < v {\\n\\t\\t\\tr = v\\n\\t\\t}\\n\\t}\\n\\tm := 0\\n\\tfor l <= r {\\n\\t\\tm = (l+r) >> 1\\n\\t\\tif diff(arr, m) <= diff(arr, m+1) {\\n\\t\\t\\tr = m-1\\n\\t\\t} else {\\n\\t\\t\\tl = m+1\\n\\t\\t}\\n\\t}\\n\\tdiff1 := diff(arr, r+1)\\n\\tdiff2 := diff(arr, l)\\n\\tif diff1 < diff2 {\\n\\t\\treturn diff1\\n\\t}\\n\\treturn diff2\\n}\\n\\nfunc diff(arr []int, d int) int64 {\\n\\tdv := 0\\n\\tfor _, v := range arr {\\n\\t\\tif v >= d {\\n\\t\\t\\tdv += v-d\\n\\t\\t} else {\\n\\t\\t\\tdv += d-v\\n\\t\\t}\\n\\t}\\n\\treturn int64(dv)\\n}\\n\\nfunc gcd(x, y int) int {\\n\\tif x < y {\\n\\t\\tx, y = y, x\\n\\t}\\n\\tif x%y == 0 {\\n\\t\\treturn y\\n\\t}\\n\\treturn gcd(y, x%y)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893940,
                "title": "easy-solution-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function (arr, k) {\\n    let result = 0;\\n    const n = arr.length;\\n\\n    for (let i = 0; i < n; i++) {\\n        if (arr[i] === 0) continue;\\n        const temp = [];\\n        let j = i;\\n        while (arr[j] !== 0) {\\n            temp.push(arr[j]);\\n            arr[j] = 0;\\n            j = (j + k) % n;\\n        }\\n        temp.sort((a, b) => a - b);\\n        const midVal = temp[Math.floor(temp.length / 2)];\\n        for (const val of temp) {\\n            result += Math.abs(val - midVal);\\n        }\\n    }\\n\\n    return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function (arr, k) {\\n    let result = 0;\\n    const n = arr.length;\\n\\n    for (let i = 0; i < n; i++) {\\n        if (arr[i] === 0) continue;\\n        const temp = [];\\n        let j = i;\\n        while (arr[j] !== 0) {\\n            temp.push(arr[j]);\\n            arr[j] = 0;\\n            j = (j + k) % n;\\n        }\\n        temp.sort((a, b) => a - b);\\n        const midVal = temp[Math.floor(temp.length / 2)];\\n        for (const val of temp) {\\n            result += Math.abs(val - midVal);\\n        }\\n    }\\n\\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810208,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        k = gcd(k, len(arr))\\n\\n        lookup = defaultdict(list)\\n\\n        for i in range(len(arr)):\\n            lookup[i % k].append(arr[i])\\n\\n\\n        ans = 0\\n\\n        for key in lookup:\\n            vals = lookup[key]\\n        \\n            vals.sort()\\n\\n            median = len(vals) // 2\\n            medianVal = vals[median] if len(vals) % 2 else (vals[median] + vals[median - 1]) // 2\\n\\n\\n            for val in vals:\\n                ans += abs(val - medianVal)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        k = gcd(k, len(arr))\\n\\n        lookup = defaultdict(list)\\n\\n        for i in range(len(arr)):\\n            lookup[i % k].append(arr[i])\\n\\n\\n        ans = 0\\n\\n        for key in lookup:\\n            vals = lookup[key]\\n        \\n            vals.sort()\\n\\n            median = len(vals) // 2\\n            medianVal = vals[median] if len(vals) % 2 else (vals[median] + vals[median - 1]) // 2\\n\\n\\n            for val in vals:\\n                ans += abs(val - medianVal)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684927,
                "title": "c-solution-why-we-have-to-use-gcd-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery subarray have to be equal (not all the element have to be equal always) to get the optimal solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow here comes a question of what length of a subarray should we keep equal so that all the k- length subarrays equal. As it is a circular array, if k is divisible by the array size(n) then an element will always face the same need of operation. BUT if not, an element may face another number of operations needed after a rotation traversal of the circular array. This is why we have to do gcd of n and k, so that an element always falls in same situation (same number of operations needed) of every rotation. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        int n=arr.size();\\n        k=__gcd(k,n);\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            sort(temp.begin(),temp.end());\\n            long long tar=temp[temp.size()/2];\\n            for(int j=i;j<n;j+=k)\\n            {\\n                ans+=abs(arr[j]-tar);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        int n=arr.size();\\n        k=__gcd(k,n);\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            sort(temp.begin(),temp.end());\\n            long long tar=temp[temp.size()/2];\\n            for(int j=i;j<n;j+=k)\\n            {\\n                ans+=abs(arr[j]-tar);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674710,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long calc(int x,vector<int>&arr)\\n    {\\n        long long sum=0;\\n        for(auto &h:arr)\\n        {\\n            sum+=abs(h-x);\\n        }\\n        return sum;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        using ll=long long;\\n        vector<int>res(arr.size(),0);\\n        \\n        ll ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(res[i])\\n            continue;\\n            vector<int>temp;\\n            int ind=i;\\n            while(res[ind]!=1)\\n            {\\n                temp.push_back(arr[ind]);\\n                res[ind]=1;\\n                ind=(ind+k)%arr.size();\\n            }\\n        sort(temp.begin(),temp.end());\\n        int len=temp.size();\\n        ll p=0;\\n        if(len&1)\\n        {\\n            p=calc(temp[len/2],temp);\\n        }\\n        else{\\n            p=min(calc(temp[len/2],temp),calc(temp[(len/2)-1],temp));\\n        }\\n        ans+=p;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long calc(int x,vector<int>&arr)\\n    {\\n        long long sum=0;\\n        for(auto &h:arr)\\n        {\\n            sum+=abs(h-x);\\n        }\\n        return sum;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        using ll=long long;\\n        vector<int>res(arr.size(),0);\\n        \\n        ll ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(res[i])\\n            continue;\\n            vector<int>temp;\\n            int ind=i;\\n            while(res[ind]!=1)\\n            {\\n                temp.push_back(arr[ind]);\\n                res[ind]=1;\\n                ind=(ind+k)%arr.size();\\n            }\\n        sort(temp.begin(),temp.end());\\n        int len=temp.size();\\n        ll p=0;\\n        if(len&1)\\n        {\\n            p=calc(temp[len/2],temp);\\n        }\\n        else{\\n            p=min(calc(temp[len/2],temp),calc(temp[(len/2)-1],temp));\\n        }\\n        ans+=p;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587547,
                "title": "javascript-math-sort",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function (arr, k) {\\n  let ans = 0;\\n  const n = arr.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    let j = i;\\n    const temp = [];\\n    while (arr[j] !== 0) {\\n      temp.push(arr[j]);\\n      arr[j] = 0;\\n      j = (j + k) % n;\\n    }\\n\\n    temp.sort((a, b) => a - b);\\n    const midVal = temp[Math.floor(temp.length / 2)];\\n    for (const val of temp) {\\n      ans += Math.abs(val - midVal);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function (arr, k) {\\n  let ans = 0;\\n  const n = arr.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    let j = i;\\n    const temp = [];\\n    while (arr[j] !== 0) {\\n      temp.push(arr[j]);\\n      arr[j] = 0;\\n      j = (j + k) % n;\\n    }\\n\\n    temp.sort((a, b) => a - b);\\n    const midVal = temp[Math.floor(temp.length / 2)];\\n    for (const val of temp) {\\n      ans += Math.abs(val - midVal);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563000,
                "title": "verbose-explanation-of-logic",
                "content": "# Intuition\\nSo the trick to understanding this problem is that logically there is only one way these overlapping k-length subarrays can have an equal sum. That only way is if they have the same elements in the sub arrays. For example the following works:\\n```\\n    [1,2,3,1,2,3,1,2,3]  with k == 3\\n```\\nThere are 9 sub arrays:\\n```\\n    1,2,3\\n    2,3,1\\n    3,1,2\\n    1,2,3\\n    2,3,1\\n    3,1,2\\n    1,2,3\\n    2,3,1 // Note \"1\" from circuling back to beginning\\n    3,1,2 // Note \"1,2\" from circuling back to beginning\\n```\\n\\nThese all have the same sum. **Change any number in the array** and the optimal way to bring the k-sums back to equality will be to make the elements match again. \\n\\nNote, it is not enough to have the same \"elements\" they have to appear in the same order in the original array! Why is that? Because of the overlapping nature of k-sum arrays. Changing one element in the original array changes \"k\" of the sub arrays. In order for the sub arrays to get each of the elements needed to sum then they need to each have right elements. \\n\\nConsider how the last k array uses k-1 elements of the first k array. In the above example the first k-array is \"1,2,3\" and the last one us \"1,2\" from the first array as it loops over the end. The only way for it to match in \"sum\" with the first array is to add a \"3\". For every overlapping k array you can say it needs to have the element of the previous one to have the sum be equal.\\n\\nAll that explanation gives a picture of what the final answer will look like, but not how we get there. We still need to understand how to minimally change it to get there and a nuance on the repeating pattern and GCD.\\n\\nIn order to make the \"minimum number of moves\" we really need to compare the \"stripes\" in the pattern. Those are the pieces we need to be make all identical.\\n\\nAgain in our example above our repeating pattern is \"1,2,3\". Say instead the input array looked like this:\\n```\\n[1,2,3,2,3,4,1,2,3] with k== 3\\n```\\n\\nFor now let\\'s consider our pattern needs to repeat every \"k\" elements. Selecting the \"first\" of the k-repeating pattern we get the following values\\n```\\n    [1,_,_,2,_,_,1,_,_]\\n       or\\n    [1,2,1]\\n```\\n \\nThey all need to be equal. Visually we see the easiest way to make them equal is to turn the 2 into 1. However, programitically to make a list of numbers equal it is best to move them all to the \"median\". The \"median\" of \"1,2,1\" is \"1\". Median can be programmatically found by sorting and taking the middle element:\\n```\\n    [1,1,2] // 1 is the middle element of the sorted list\\n            // and thus the median\\n```\\n\\nThen you have to calculate the distance to move each number to that median. You can use \"absolute value\" and a subtraction for find which is bigger before subracting. Either way just make sure you are calculating the distance and not just the difference (keep answers positive).\\n\\nSum all those distances and you now know the minimum \"cost\" to make one stripe in the puzzle have an equal sum. You\\'ll have to do this for \"k\" stripes.\\n\\n**Wait!** There is one problem! If K does not evenly divide into the length of the array it will cause issues for our pattern. For example if k == 3 and our array is \"8\" long then we can\\'t possibly \"k\" repeat. See this example:\\n```\\n[a,b,c,a,b,c,a,b] with k==3 and a length of 8\\n c\\n```\\nNote with the looping end of the array we want the first element to be both \"c\" and \"a\". That means we canot us a k-length repeating pattern as it does not line up with itself as we loop off the end of the tail. \\n\\nThe best we can do in this case is to make everything the same.\\n```\\n[a,a,a,a,a,a,a,a] with k==3 and a length of 8\\n```\\n\\nWhy not have a two repeating pattern? Because k==3 and they wouldn\\'t have an equal sum\\n```\\n[a,b,a,b,a,b,a,b] with k==3 and a length of 8\\n\\n// k-arrays\\n[a,b,a]\\n[b,a,b] // already not equal.\\n\\n```\\n\\nYou can afford to have some repeating pattern when k does not even divide the length of the array. Taking advantage of that option reduces our total cost and is nescessary to get the minimum. The length is essentially something that will evenly work for the repeating part at the end. \\n\\nFor k==6 and an array of size 9:\\n```\\n[a,b,c,d,e,f,a,b,c] // repeating 6 pattern doesn\\'t work\\n[a,b,c,a,b,c,a,b,c] // repeating 3 pattern does fit!\\n```\\n\\nThe repeating pattern is not \"k\" but rather the greatest common divisor between \"k\" and the array length. \\n\\nReally, this problem should help us understand Euclid\\'s Theorem. Whatever is \"left over\" from a multiple of k will be wrapped back over the array and will need to \"match\" that k. We really only care about the remainder and how it matches up with our repeating pattern.\\n\\nThis concludes everything you need to understand for the intution part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ where $$g$$ is the $$gcd(n,k)$$\\n\\n- Space complexity:\\n$$O(n/g)$$ where $$g$$ is the $$gcd(n,k)$$. In some case this is n, so $$O(n)$$ is an appropriate description.\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MakeSubKSumEqual(int[] arr, int k) {\\n        //Intuition:\\n        // In order for the sums to be equal the elements in side need to be equal in a striped pattern throughout the array.\\n        // Since we loop at the end of the array back to the beginning that pattern is not as long as \"k\" but gcd(n,k) so that it\\n        // can match the patter when looping back from the end.\\n        // The optimal item to change them too in a striped segment is the median of the segment.\\n\\n        var g = GCD(k, arr.Length);\\n\\n        var ans = 0L;\\n        for(var i=0; i<g; i++) {\\n            var stripe = new List<int>();\\n            for(var j=i; j<arr.Length; j += g) {\\n                stripe.Add(arr[j]);\\n            }\\n\\n            stripe.Sort();\\n            var median = stripe[stripe.Count / 2];\\n\\n            foreach(var val in stripe) {\\n                ans += Math.Abs(median - val);\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n\\n    private int GCD(int a, int b) {\\n        while(a != 0 && b != 0) {\\n            if(a > b) {\\n                a %= b;\\n            } else {\\n                b %= a;\\n            }\\n        }\\n\\n        return  a | b; // short hand for returning the non-zero option of the two variables\\n    }\\n}\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    [1,2,3,1,2,3,1,2,3]  with k == 3\\n```\n```\\n    1,2,3\\n    2,3,1\\n    3,1,2\\n    1,2,3\\n    2,3,1\\n    3,1,2\\n    1,2,3\\n    2,3,1 // Note \"1\" from circuling back to beginning\\n    3,1,2 // Note \"1,2\" from circuling back to beginning\\n```\n```\\n[1,2,3,2,3,4,1,2,3] with k== 3\\n```\n```\\n    [1,_,_,2,_,_,1,_,_]\\n       or\\n    [1,2,1]\\n```\n```\\n    [1,1,2] // 1 is the middle element of the sorted list\\n            // and thus the median\\n```\n```\\n[a,b,c,a,b,c,a,b] with k==3 and a length of 8\\n c\\n```\n```\\n[a,a,a,a,a,a,a,a] with k==3 and a length of 8\\n```\n```\\n[a,b,a,b,a,b,a,b] with k==3 and a length of 8\\n\\n// k-arrays\\n[a,b,a]\\n[b,a,b] // already not equal.\\n\\n```\n```\\n[a,b,c,d,e,f,a,b,c] // repeating 6 pattern doesn\\'t work\\n[a,b,c,a,b,c,a,b,c] // repeating 3 pattern does fit!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3512476,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int n=arr.length;\\n        long ans=0;\\n        int vis[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            List<Integer>list=new ArrayList<>();\\n            if(vis[i]==1)\\n            continue;\\n            while(vis[i]==0){\\n                vis[i]=1;\\n                list.add(arr[i]);\\n                i=(i+k)%n;\\n            }\\n            Collections.sort(list);\\n            for(int j:list){\\n                ans+=Math.abs(j-list.get(list.size()/2));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int n=arr.length;\\n        long ans=0;\\n        int vis[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            List<Integer>list=new ArrayList<>();\\n            if(vis[i]==1)\\n            continue;\\n            while(vis[i]==0){\\n                vis[i]=1;\\n                list.add(arr[i]);\\n                i=(i+k)%n;\\n            }\\n            Collections.sort(list);\\n            for(int j:list){\\n                ans+=Math.abs(j-list.get(list.size()/2));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437922,
                "title": "c",
                "content": "```\\nclass Solution {\\n    long long helper(vector<int>&nums){\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        long long sum = 0 ;\\n        for(int i = 0; i < n; i++)\\n            sum += abs(nums[i] - nums[n/2]) ;\\n        return sum ;\\n    }\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size() ;\\n        vector<bool>visited(n) ;\\n            long long ret = 0 ;\\n        for(int i = 0; i < k; i++){\\n            int j = i ;\\n            vector<int>nums ;\\n            while(visited[j] == false){\\n                visited[j] = true ;\\n                nums.push_back(arr[j]) ;\\n                j = (j + k) % n ;\\n            }\\n            ret += helper(nums) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    long long helper(vector<int>&nums){\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        long long sum = 0 ;\\n        for(int i = 0; i < n; i++)\\n            sum += abs(nums[i] - nums[n/2]) ;\\n        return sum ;\\n    }\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size() ;\\n        vector<bool>visited(n) ;\\n            long long ret = 0 ;\\n        for(int i = 0; i < k; i++){\\n            int j = i ;\\n            vector<int>nums ;\\n            while(visited[j] == false){\\n                visited[j] = true ;\\n                nums.push_back(arr[j]) ;\\n                j = (j + k) % n ;\\n            }\\n            ret += helper(nums) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412285,
                "title": "python-consider-middle-value-count-the-operation-runtime-beats-96-memory-beats-89",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)  Find the greatest common divisor between len(arr) and k\\n    e.g. length = 6, k = 4, greatest common divisor = 2\\n    --> every substring with length = 2 must be equal.\\n2)  For each substring, take Position n (n = 0 to k - 1) to form a new substring, pass it to **countOperation**.\\n3) In **countOperation**, get the middle value, sum the absolute difference between the middle value and each value. return to output.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countOperation(self, arr):\\n        sub_res = 0\\n        arr.sort()\\n        avg = arr[len(arr)/2]   #####   Find the middle value     #####\\n        for a in arr:\\n            sub_res += abs(avg - a)\\n        return sub_res\\n\\n    def findConvK(self, l, k):\\n        while k > 1:\\n            if l % k == 0:\\n                return k\\n            d = l - k\\n            l, k = max(k, d), min(k, d)\\n        return k\\n\\n    def makeSubKSumEqual(self, arr, k):\\n        output = 0\\n        k = self.findConvK(len(arr), k)\\n        count = 0\\n        while count < k:\\n            sub_arr = arr[count::k]     #####   if subarray = arr, pass the whole arr to countOperation #####\\n            output += self.countOperation(sub_arr)    \\n            count += 1\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countOperation(self, arr):\\n        sub_res = 0\\n        arr.sort()\\n        avg = arr[len(arr)/2]   #####   Find the middle value     #####\\n        for a in arr:\\n            sub_res += abs(avg - a)\\n        return sub_res\\n\\n    def findConvK(self, l, k):\\n        while k > 1:\\n            if l % k == 0:\\n                return k\\n            d = l - k\\n            l, k = max(k, d), min(k, d)\\n        return k\\n\\n    def makeSubKSumEqual(self, arr, k):\\n        output = 0\\n        k = self.findConvK(len(arr), k)\\n        count = 0\\n        while count < k:\\n            sub_arr = arr[count::k]     #####   if subarray = arr, pass the whole arr to countOperation #####\\n            output += self.countOperation(sub_arr)    \\n            count += 1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408871,
                "title": "efficiently-rearranging-array-elements-to-make-sub-k-sum-equal-a-sorting-based-approach-in-c",
                "content": "# Intuition\\nFirst, we use the gcd function to calculate the greatest common divisor (GCD) of arrLen and k. This gives us the number of columns, colLen, in the rearranged array, where each column will have arrLen / colLen elements.\\nWe then calculate the number of rows, rowLen, in the rearranged array by dividing arrLen by colLen.\\nNext, we iterate through each column of the rearranged array, and for each column, we create a temporary buffer curColBuf of length rowLen to store the elements in that column.\\nWe call the minOperToMakeAllEqual function on curColBuf to calculate the minimum number of operations needed to make all elements in the column equal. This function uses a sorting approach to efficiently find the minimum number of operations.\\nWe add the result of minOperToMakeAllEqual for each column to the total result.\\nFinally, we return the total result as the final answer.\\n# Code\\n```\\nstatic int gcd(int a, int b) {\\n\\twhile (b != 0) {\\n\\t\\tconst int c = a % b;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t}\\n\\treturn a;\\n}\\n\\nstatic int cmp_int_asc(const void * const p1, const void * const p2) {\\n\\treturn *(const int *)p1 - *(const int *)p2;\\n}\\n\\nstatic int64_t minOperToMakeAllEqual(int * const nums, const int numsLen) {\\n\\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\\n\\tint64_t result = 0;\\n\\tfor (int left = 0, right = numsLen - 1; left < right; left += 1, right -= 1) {\\n\\t\\tresult += (nums[right] - nums[left]);\\n\\t}\\n\\treturn result;\\n}\\n\\nint64_t makeSubKSumEqual(const int * const arr, const int arrLen, const int k) {\\n\\tint64_t result = 0;\\n\\n\\tconst int colLen = gcd(arrLen, k);\\n\\tconst int rowLen = arrLen / colLen;\\n\\n\\tfor (int col = 0; col < colLen; col += 1) {\\n\\t\\tint curColBuf[rowLen];\\n\\t\\tfor (int row = 0; row < rowLen; row += 1) {\\n\\t\\t\\tcurColBuf[row] = arr[colLen * row + col];\\n\\t\\t}\\n\\t\\tresult += minOperToMakeAllEqual(curColBuf, rowLen);\\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic int gcd(int a, int b) {\\n\\twhile (b != 0) {\\n\\t\\tconst int c = a % b;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t}\\n\\treturn a;\\n}\\n\\nstatic int cmp_int_asc(const void * const p1, const void * const p2) {\\n\\treturn *(const int *)p1 - *(const int *)p2;\\n}\\n\\nstatic int64_t minOperToMakeAllEqual(int * const nums, const int numsLen) {\\n\\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\\n\\tint64_t result = 0;\\n\\tfor (int left = 0, right = numsLen - 1; left < right; left += 1, right -= 1) {\\n\\t\\tresult += (nums[right] - nums[left]);\\n\\t}\\n\\treturn result;\\n}\\n\\nint64_t makeSubKSumEqual(const int * const arr, const int arrLen, const int k) {\\n\\tint64_t result = 0;\\n\\n\\tconst int colLen = gcd(arrLen, k);\\n\\tconst int rowLen = arrLen / colLen;\\n\\n\\tfor (int col = 0; col < colLen; col += 1) {\\n\\t\\tint curColBuf[rowLen];\\n\\t\\tfor (int row = 0; row < rowLen; row += 1) {\\n\\t\\t\\tcurColBuf[row] = arr[colLen * row + col];\\n\\t\\t}\\n\\t\\tresult += minOperToMakeAllEqual(curColBuf, rowLen);\\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3393246,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def makeSubKSumEqual(arr: Array[Int], k: Int): Long = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        def help(arr: Array[Int], start: Int, gap: Int):Long = {\\n            val n = arr.length\\n            val m = n / gap\\n            val as = (start until n by gap).foldLeft(List[Int]())((acc, i)=>{arr(i) +: acc}).sorted.toArray\\n            (0 until m).foldLeft(0L)((acc, i) => {acc + Math.abs(as(i) - as(m / 2))})\\n        }\\n\\n        val g = gcd(arr.length, k)\\n        (0 until g).foldLeft(0L)((acc, i) =>{ acc + help(arr, i, g) })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def makeSubKSumEqual(arr: Array[Int], k: Int): Long = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        def help(arr: Array[Int], start: Int, gap: Int):Long = {\\n            val n = arr.length\\n            val m = n / gap\\n            val as = (start until n by gap).foldLeft(List[Int]())((acc, i)=>{arr(i) +: acc}).sorted.toArray\\n            (0 until m).foldLeft(0L)((acc, i) => {acc + Math.abs(as(i) - as(m / 2))})\\n        }\\n\\n        val g = gcd(arr.length, k)\\n        (0 until g).foldLeft(0L)((acc, i) =>{ acc + help(arr, i, g) })\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3391633,
                "title": "easy-understand-solution-though-not-optimal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif subArray[i, i+k-1] == subArray[i+1, i+k], then a[i] == a[i+k]\\nObviously, this can apply to all subArray, so we can conclud a[i] == a[(i + n * k) % length], n = 0, 1, 2, ...\\n\\nSo the intuition is we have to deal with each group of numbers where the indeces of numbers should match the pattern above. Regarding to the same group, we can just change all numbers to median number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlgn) since sorting\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        long res = 0;\\n        int n = arr.length;\\n        \\n        int[] visited = new int[n];\\n        for (int i = 0; i < k; i++) {\\n            if (visited[i] == 1) {\\n                continue;\\n            }\\n            int index = i;\\n            List<Integer> tmp = new ArrayList<>();\\n            while (visited[index] == 0) {\\n                visited[index] = 1;\\n                tmp.add(arr[index]);\\n                index = (index + k) % n;\\n            }\\n            Collections.sort(tmp);\\n            int mid = tmp.get((tmp.size() - 1) / 2);\\n            for (int num : tmp) {\\n                res += Math.abs(num - mid);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        long res = 0;\\n        int n = arr.length;\\n        \\n        int[] visited = new int[n];\\n        for (int i = 0; i < k; i++) {\\n            if (visited[i] == 1) {\\n                continue;\\n            }\\n            int index = i;\\n            List<Integer> tmp = new ArrayList<>();\\n            while (visited[index] == 0) {\\n                visited[index] = 1;\\n                tmp.add(arr[index]);\\n                index = (index + k) % n;\\n            }\\n            Collections.sort(tmp);\\n            int mid = tmp.get((tmp.size() - 1) / 2);\\n            for (int num : tmp) {\\n                res += Math.abs(num - mid);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389851,
                "title": "javascript-solution-k-cycles",
                "content": "# Intuition\\nI am way too dumb for this.\\nThis is refer to @votrubac\\'s solution and revise to javascript.\\n\\n# Important\\nHere is an important mathematical proof for this question made by @venkatkri5h.\\nYou can check this out in @votrubac\\'s solution below.\\n\\n```\\nConsider array \\n[x, y, z, a, b, c]\\nLet k be 3. \\n[x, y, z, a, b, c]\\n |     |         - Let this Sum be A (x + y + z)\\nNow slide window\\n[x, y, z, a, b, c]\\n    |     |      - Let this Sum be B (A - x + a)\\nHere Sum of this subarray B can be equal to A only if a is equal to x. \\n```\\nSo we can say:\\n```\\narr[i] == arr[i + k]\\narr[i] == arr[i + 2 * k]\\nand so on.\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) when the k === 1\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function(arr, k) {\\n    let res = 0\\n\\n    for(let i = 0; i < k; i++) {\\n        let list = []\\n\\n        // (j + k) % arr.length can let us circle the array\\n        // and by re-assign the arr[j] to 0, it can make sure we won\\'t go visited element\\n        for(let j = i; arr[j] !== 0; j = (j + k) % arr.length) {\\n            list.push(arr[j])\\n            arr[j] = 0\\n        }\\n\\n        list.sort((a,b)=>a-b)\\n\\n        for(let l of list) {\\n            // Use the middle element as the subtrahend to get the overall minimum difference\\n            // Yes, we need another math genius to prove it!\\n            res += Math.abs(l - list[~~(list.length / 2)])\\n        }\\n    }  \\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nConsider array \\n[x, y, z, a, b, c]\\nLet k be 3. \\n[x, y, z, a, b, c]\\n |     |         - Let this Sum be A (x + y + z)\\nNow slide window\\n[x, y, z, a, b, c]\\n    |     |      - Let this Sum be B (A - x + a)\\nHere Sum of this subarray B can be equal to A only if a is equal to x. \\n```\n```\\narr[i] == arr[i + k]\\narr[i] == arr[i + 2 * k]\\nand so on.\\n```\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function(arr, k) {\\n    let res = 0\\n\\n    for(let i = 0; i < k; i++) {\\n        let list = []\\n\\n        // (j + k) % arr.length can let us circle the array\\n        // and by re-assign the arr[j] to 0, it can make sure we won\\'t go visited element\\n        for(let j = i; arr[j] !== 0; j = (j + k) % arr.length) {\\n            list.push(arr[j])\\n            arr[j] = 0\\n        }\\n\\n        list.sort((a,b)=>a-b)\\n\\n        for(let l of list) {\\n            // Use the middle element as the subtrahend to get the overall minimum difference\\n            // Yes, we need another math genius to prove it!\\n            res += Math.abs(l - list[~~(list.length / 2)])\\n        }\\n    }  \\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389512,
                "title": "dart-o-nlogn-group-and-sum-the-count-of-makeeverythingequals",
                "content": "# Intuition\\n- Make group of given list by k jump. \\n- Then, make the group of groups to makeEveryThingEqual and sum the count. \\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int makeSubKSumEqual(List<int> arr, int k) {\\n    int n = arr.length;\\n    List<List<int>> gps = [];\\n    HashSet<int> visited = HashSet();\\n\\n    for (var i = 0; i < n; i++) {\\n      int j = i;\\n      List<int> gp = [];\\n      while (visited.add(j % n)) {\\n        gp.add(arr[j % n]);\\n        j += k;\\n      }\\n      if (gp.isNotEmpty) {\\n        gps.add(gp);\\n      }\\n    }\\n\\n    int res = 0;\\n    for (var gp in gps) {\\n      res += minOperationsToMakeEverythingEquals(gp);\\n    }\\n\\n    return res;\\n  }\\n\\n  int minOperationsToMakeEverythingEquals(List<int> nums) {\\n    int n = nums.length;\\n    nums.sort();\\n    int mid = nums[n ~/ 2];\\n    int count = 0;\\n    for (var x in nums) {\\n      count += (mid - x).abs();\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int makeSubKSumEqual(List<int> arr, int k) {\\n    int n = arr.length;\\n    List<List<int>> gps = [];\\n    HashSet<int> visited = HashSet();\\n\\n    for (var i = 0; i < n; i++) {\\n      int j = i;\\n      List<int> gp = [];\\n      while (visited.add(j % n)) {\\n        gp.add(arr[j % n]);\\n        j += k;\\n      }\\n      if (gp.isNotEmpty) {\\n        gps.add(gp);\\n      }\\n    }\\n\\n    int res = 0;\\n    for (var gp in gps) {\\n      res += minOperationsToMakeEverythingEquals(gp);\\n    }\\n\\n    return res;\\n  }\\n\\n  int minOperationsToMakeEverythingEquals(List<int> nums) {\\n    int n = nums.length;\\n    nums.sort();\\n    int mid = nums[n ~/ 2];\\n    int count = 0;\\n    for (var x in nums) {\\n      count += (mid - x).abs();\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388195,
                "title": "a-few-solutions",
                "content": "Given the input array `A` with cardinality `N` and subarray length `K`, we derive the formula `A[i] = A[(i + K) % N]` from the equalities below:\\n\\n![image](https://assets.leetcode.com/users/images/dfca501a-b1b2-4117-8a71-5e5a7af9b4e1_1680829152.7669816.jpeg)\\n\\n\\nThus, we partition `A` into `groups` starting at each index `i = 0..K-1` inclusive and update all values per `group` to the `median` value of the `group` to accumulate the `cost` as the sum of absolute differences `diff` between the `median` and each value of the `group`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun makeSubKSumEqual(A: IntArray, K: Int): Long {\\n        var (groups, seen, N) = Triple(mutableListOf<List<Int>>(), mutableSetOf<Int>(), A.size)\\n        for (i_ in 0 until K) {\\n            var (i, group) = Pair(i_, mutableListOf<Int>())\\n            while (!seen.contains(i)) {\\n                group.add(A[i]); seen.add(i); i = (i + K) % N\\n            }\\n            if (0 < group.size)\\n                groups.add(group.sorted().toList())\\n        }\\n        var cost = 0L\\n        for (group in groups) {\\n            var median = group[group.size / 2]\\n            var diff = group.map{ Math.abs(median.toLong() - it.toLong()) }.sum()\\n            cost += diff\\n        }\\n        return cost\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet makeSubKSumEqual = (A, K, cost = 0) => {\\n    let [groups, seen, N] = [[], new Set(), A.length];\\n    for (let i = 0; i < K; ++i) {\\n        let group = [];\\n        while (!seen.has(i))\\n            group.push(A[i]), seen.add(i), i = (i + K) % N;\\n        if (group.length)\\n            groups.push(group.sort((a, b) => a - b));\\n    }\\n    for (let group of groups) {\\n        let median = group[Math.floor(group.length / 2)];\\n        let diff = _.sum(group.map(x => Math.abs(median - x)));\\n        cost += diff;\\n    }\\n    return cost;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int, cost = 0) -> int:\\n        groups, seen, N = [], set(), len(A)\\n        for i in range(K):\\n            group = []\\n            while i not in seen:\\n                group.append(A[i]); seen.add(i); i = (i + K) % N\\n            if len(group):\\n                groups.append(sorted(group))\\n        for group in groups:\\n            median = group[len(group) // 2]\\n            diff = sum(abs(median - x) for x in group)\\n            cost += diff\\n        return cost\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn make_sub_k_sum_equal(A: Vec<i32>, K: i32) -> i64 {\\n        let (mut groups, mut seen, N) = (vec![], HashSet::new(), A.len());\\n        for i in 0..K as usize {\\n            let (mut i, mut group) = (i, vec![]);\\n            while !seen.contains(&i) {\\n                group.push(A[i]); seen.insert(i); i = (i + K as usize) % N;\\n            }\\n            if 0 < group.len() {\\n                group.sort(); groups.push(group);\\n            }\\n        }\\n        let mut cost = 0i64;\\n        for group in groups {\\n            let median = group[group.len() / 2];\\n            let diff = group.iter().map(|x| (median as i64 - *x as i64).abs()).sum::<i64>();\\n            cost += diff;\\n        }\\n        cost\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    LL makeSubKSumEqual(VI& A, int K, LL cost = 0) {\\n        auto [groups, seen, N] = make_tuple(VVI{}, Set{}, A.size());\\n        for (auto i{ 0 }; i < K; ++i) {\\n            VI group;\\n            while (seen.insert(i).second)\\n                group.push_back(A[i]), i = (i + K) % N;\\n            if (group.size())\\n                groups.emplace_back(group);\\n        }\\n        for (auto& group: groups) {\\n            sort(group.begin(), group.end());\\n            auto median = group[group.size() / 2];\\n            auto diff = accumulate(group.begin(), group.end(), 0LL, [=](auto t, auto x) { return t + abs(median - x); });\\n            cost += diff;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun makeSubKSumEqual(A: IntArray, K: Int): Long {\\n        var (groups, seen, N) = Triple(mutableListOf<List<Int>>(), mutableSetOf<Int>(), A.size)\\n        for (i_ in 0 until K) {\\n            var (i, group) = Pair(i_, mutableListOf<Int>())\\n            while (!seen.contains(i)) {\\n                group.add(A[i]); seen.add(i); i = (i + K) % N\\n            }\\n            if (0 < group.size)\\n                groups.add(group.sorted().toList())\\n        }\\n        var cost = 0L\\n        for (group in groups) {\\n            var median = group[group.size / 2]\\n            var diff = group.map{ Math.abs(median.toLong() - it.toLong()) }.sum()\\n            cost += diff\\n        }\\n        return cost\\n    }\\n}\\n```\n```\\nlet makeSubKSumEqual = (A, K, cost = 0) => {\\n    let [groups, seen, N] = [[], new Set(), A.length];\\n    for (let i = 0; i < K; ++i) {\\n        let group = [];\\n        while (!seen.has(i))\\n            group.push(A[i]), seen.add(i), i = (i + K) % N;\\n        if (group.length)\\n            groups.push(group.sort((a, b) => a - b));\\n    }\\n    for (let group of groups) {\\n        let median = group[Math.floor(group.length / 2)];\\n        let diff = _.sum(group.map(x => Math.abs(median - x)));\\n        cost += diff;\\n    }\\n    return cost;\\n};\\n```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int, cost = 0) -> int:\\n        groups, seen, N = [], set(), len(A)\\n        for i in range(K):\\n            group = []\\n            while i not in seen:\\n                group.append(A[i]); seen.add(i); i = (i + K) % N\\n            if len(group):\\n                groups.append(sorted(group))\\n        for group in groups:\\n            median = group[len(group) // 2]\\n            diff = sum(abs(median - x) for x in group)\\n            cost += diff\\n        return cost\\n```\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn make_sub_k_sum_equal(A: Vec<i32>, K: i32) -> i64 {\\n        let (mut groups, mut seen, N) = (vec![], HashSet::new(), A.len());\\n        for i in 0..K as usize {\\n            let (mut i, mut group) = (i, vec![]);\\n            while !seen.contains(&i) {\\n                group.push(A[i]); seen.insert(i); i = (i + K as usize) % N;\\n            }\\n            if 0 < group.len() {\\n                group.sort(); groups.push(group);\\n            }\\n        }\\n        let mut cost = 0i64;\\n        for group in groups {\\n            let median = group[group.len() / 2];\\n            let diff = group.iter().map(|x| (median as i64 - *x as i64).abs()).sum::<i64>();\\n            cost += diff;\\n        }\\n        cost\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    LL makeSubKSumEqual(VI& A, int K, LL cost = 0) {\\n        auto [groups, seen, N] = make_tuple(VVI{}, Set{}, A.size());\\n        for (auto i{ 0 }; i < K; ++i) {\\n            VI group;\\n            while (seen.insert(i).second)\\n                group.push_back(A[i]), i = (i + K) % N;\\n            if (group.size())\\n                groups.emplace_back(group);\\n        }\\n        for (auto& group: groups) {\\n            sort(group.begin(), group.end());\\n            auto median = group[group.size() / 2];\\n            auto diff = accumulate(group.begin(), group.end(), 0LL, [=](auto t, auto x) { return t + abs(median - x); });\\n            cost += diff;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384336,
                "title": "the-only-thing-you-need-to-realise-gcd-k-len-arr-is-the-length-of-the-repeating-array",
                "content": "\\n# Code\\n```\\ndef makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n    def gcd(a, b):\\n        while a != 0:\\n            a, b = b%a, a\\n        return b\\n            \\n    g = gcd(k, len(arr))\\n    sets = (arr[i::g] for i in range(g))\\n    ret = 0\\n    for s in sets:\\n        mid = int(statistics.median(s))\\n        ret += sum([abs(a-mid) for a in s])\\n    return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n    def gcd(a, b):\\n        while a != 0:\\n            a, b = b%a, a\\n        return b\\n            \\n    g = gcd(k, len(arr))\\n    sets = (arr[i::g] for i in range(g))\\n    ret = 0\\n    for s in sets:\\n        mid = int(statistics.median(s))\\n        ret += sum([abs(a-mid) for a in s])\\n    return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3379718,
                "title": "c-simple-approach",
                "content": "# Description\\nSolved this code with the help of discussion forum.\\n\\n# Intuition\\nSolved using GCD and median technique\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\nRuntime 186 ms\\nBeats 97.91%\\n\\n- Space complexity:\\nMemory 109 MB\\nBeats 54.34%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        //res is a variable to store the no of operations\\n        long long res = 0;\\n        int n = arr.size();\\n        //taking gcd to get the number of buckets (subarrays)\\n        k = __gcd(k,n);\\n        //outer loop to get values of all buckets\\n        for(int i = 0; i<k; i++){\\n            //creating vector to store the values in each bucket\\n            vector<int>v;\\n            for(int j = i; j<n; j+=k){\\n                v.push_back(arr[j]);\\n            }\\n            sort(v.begin(), v.end());\\n            //finding median to get the no of operations\\n            long long mid = v[v.size()/2];\\n            //finding the absolute difference by subtracting all the elements with median \\n            for(int j = 0; j < v.size(); j++){\\n                res += abs(mid - v[j]);\\n            }\\n        }\\n        return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        //res is a variable to store the no of operations\\n        long long res = 0;\\n        int n = arr.size();\\n        //taking gcd to get the number of buckets (subarrays)\\n        k = __gcd(k,n);\\n        //outer loop to get values of all buckets\\n        for(int i = 0; i<k; i++){\\n            //creating vector to store the values in each bucket\\n            vector<int>v;\\n            for(int j = i; j<n; j+=k){\\n                v.push_back(arr[j]);\\n            }\\n            sort(v.begin(), v.end());\\n            //finding median to get the no of operations\\n            long long mid = v[v.size()/2];\\n            //finding the absolute difference by subtracting all the elements with median \\n            for(int j = 0; j < v.size(); j++){\\n                res += abs(mid - v[j]);\\n            }\\n        }\\n        return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379161,
                "title": "c-gcd",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll helper(vector<int>& arr)\\n    {\\n        ll tot=0;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        ll mid=arr[n/2];\\n        ll res=0;\\n        for(auto &x:arr)res+=abs(mid-x);\\n        return res;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        if(n==k)return 0;\\n        int group=gcd(n,k);\\n        vector<vector<int>>record(group);\\n        for(int i=0;i<n;i++)record[i%group].push_back(arr[i]);\\n        ll res=0;\\n        for(auto &x:record)res+=helper(x);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll helper(vector<int>& arr)\\n    {\\n        ll tot=0;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        ll mid=arr[n/2];\\n        ll res=0;\\n        for(auto &x:arr)res+=abs(mid-x);\\n        return res;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        if(n==k)return 0;\\n        int group=gcd(n,k);\\n        vector<vector<int>>record(group);\\n        for(int i=0;i<n;i++)record[i%group].push_back(arr[i]);\\n        ll res=0;\\n        for(auto &x:record)res+=helper(x);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378578,
                "title": "easy-best-step-by-step-c-solution",
                "content": "\\n# Approach\\n\\nTo have subarray sum of size K  as equal in  a circular array\\n\\n# **A[i] = A[(i+k)%n]** \\n\\nand then for next A[i+k)%n] = A[(i+2k)%n] .. so on and stop as soon an index which is already marked is reached.\\n\\nNOTE : Mark all the index i , i+k %n , i+2k % n ... \\n\\nContinously store these elements which are in a cycle since we have to make them equal.\\n\\nFor making these elements as equal at min operation/cost we first sort them and make a target value as middle value.\\n\\n# Complexity\\n- Time complexity: TELL ME IN COMMENTS\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: TELL ME IN COMMENTS\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Finding min cost to make array elements as equal\\n\\n    // 1. Sort them\\n    // 2 . Adding , abs(A[i]-midVal) target element to make is midVal\\n\\n    long long solve(vector <int> &temp){\\n\\n        int n = temp.size();\\n\\n        sort(temp.begin(),temp.end());\\n\\n        long long ans = 0;\\n\\n        long long ans1 = 0 , ans2 = 0;\\n\\n        // odd\\n        if(n%2 == 1){\\n\\n            int mid = n/2;\\n\\n            for(int &val : temp){\\n\\n                ans += abs(val-temp[mid]);\\n\\n            }\\n            \\n        }\\n\\n        // even\\n        else{\\n\\n            int mid1 = n/2;\\n            int mid2 = n/2-1;\\n\\n            // in even case there are two mids hence find the min cost amongst the two mid target values\\n\\n            for(auto &val : temp){\\n\\n                ans1 += abs(val-temp[mid1]);\\n                ans2 += abs(val-temp[mid2]);\\n\\n            }\\n\\n            ans = min(ans1,ans2);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        // A[i] = A[(i+k)%n] should be equal\\n\\n        // And a acycle will be formed i -> i+k % n -> i+2k % n ----> i\\n\\n        long long ans = 0;\\n\\n        int n = arr.size();\\n\\n        vector <bool> marked(n,0);\\n\\n        for(int i=0 ; i<n ; i++){\\n            \\n            // Already marked index\\n            if(marked[i] == 1) continue;\\n\\n            // temp is used to store all the cycle elements that we need to make equal\\n            vector <int> temp;\\n\\n            // not marked yet\\n            while(marked[i] != 1){\\n                \\n                marked[i] = 1;\\n\\n                temp.push_back(arr[i]);\\n\\n                // moving ahead in cycle\\n                i = (i+k)%n;\\n\\n            }\\n\\n            // solve functions find the minimum cost to make all the elements int temop array as equal\\n            long long ops = solve(temp);\\n\\n            ans += ops;\\n\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Finding min cost to make array elements as equal\\n\\n    // 1. Sort them\\n    // 2 . Adding , abs(A[i]-midVal) target element to make is midVal\\n\\n    long long solve(vector <int> &temp){\\n\\n        int n = temp.size();\\n\\n        sort(temp.begin(),temp.end());\\n\\n        long long ans = 0;\\n\\n        long long ans1 = 0 , ans2 = 0;\\n\\n        // odd\\n        if(n%2 == 1){\\n\\n            int mid = n/2;\\n\\n            for(int &val : temp){\\n\\n                ans += abs(val-temp[mid]);\\n\\n            }\\n            \\n        }\\n\\n        // even\\n        else{\\n\\n            int mid1 = n/2;\\n            int mid2 = n/2-1;\\n\\n            // in even case there are two mids hence find the min cost amongst the two mid target values\\n\\n            for(auto &val : temp){\\n\\n                ans1 += abs(val-temp[mid1]);\\n                ans2 += abs(val-temp[mid2]);\\n\\n            }\\n\\n            ans = min(ans1,ans2);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        // A[i] = A[(i+k)%n] should be equal\\n\\n        // And a acycle will be formed i -> i+k % n -> i+2k % n ----> i\\n\\n        long long ans = 0;\\n\\n        int n = arr.size();\\n\\n        vector <bool> marked(n,0);\\n\\n        for(int i=0 ; i<n ; i++){\\n            \\n            // Already marked index\\n            if(marked[i] == 1) continue;\\n\\n            // temp is used to store all the cycle elements that we need to make equal\\n            vector <int> temp;\\n\\n            // not marked yet\\n            while(marked[i] != 1){\\n                \\n                marked[i] = 1;\\n\\n                temp.push_back(arr[i]);\\n\\n                // moving ahead in cycle\\n                i = (i+k)%n;\\n\\n            }\\n\\n            // solve functions find the minimum cost to make all the elements int temop array as equal\\n            long long ops = solve(temp);\\n\\n            ans += ops;\\n\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378550,
                "title": "c-solution-using-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        if(n == k) return 0;\\n        long long res = 0;\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<k;i++){\\n            int j = i;\\n            priority_queue<int> pq;\\n            if(vis[j]) break;\\n            while(!vis[j]){\\n                vis[j] = 1;\\n                pq.push(-a[j]);\\n                j = (j+k) % n;\\n            }\\n            vector<int> v;\\n            while(!pq.empty()) {v.push_back(-pq.top()); pq.pop();}\\n            int m = v.size();\\n            int ref = v[m/2]; \\n            for(int ind=0;ind<m;ind++) res += abs(ref-v[ind]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        if(n == k) return 0;\\n        long long res = 0;\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<k;i++){\\n            int j = i;\\n            priority_queue<int> pq;\\n            if(vis[j]) break;\\n            while(!vis[j]){\\n                vis[j] = 1;\\n                pq.push(-a[j]);\\n                j = (j+k) % n;\\n            }\\n            vector<int> v;\\n            while(!pq.empty()) {v.push_back(-pq.top()); pq.pop();}\\n            int m = v.size();\\n            int ref = v[m/2]; \\n            for(int ind=0;ind<m;ind++) res += abs(ref-v[ind]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378106,
                "title": "c-find-connected-component-by-gcd-arr-size-k",
                "content": "# Observation\\n- For making each subarray sum equal of window size k we have to make each index is equal to index+kth value \\n- and we have to take care of one more thing which is the array is circular so we have to take care of this thing also \\n- As given in question array is circular so we can conclude if array length and k does not have any common devisor we have to make all the element of array equal this is for sure becoz when we check connection between idx=> idx+k we found out each element is some how connected to each other element\\n- If there is some common element so idx=>idx+gcd(size,k) going to connected and so on so take them in one group and find answer\\n- So fro finding answer for group it is more optimal to take median \\n\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findMedian(vector<int> &temp){\\n        sort(temp.begin(),temp.end());\\n\\n        if(temp.size()%2==1){\\n            return temp[temp.size()/2];\\n        }\\n        return (temp[temp.size()/2]+temp[temp.size()/2-1])/2;\\n    }\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        if(__gcd(n,k)>1){\\n            k=__gcd(n,k);\\n            long long ans=0;\\n            for(int i=0;i<k;i++){\\n                vector<int> temp;\\n                for(int j=i;j<arr.size();j+=k){\\n                    temp.push_back(arr[j]);\\n                }\\n                int val=findMedian(temp);\\n                for(auto x:temp){\\n                    ans+=abs(x-val);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n        else{\\n            int val=findMedian(arr);\\n            long long ans=0;\\n            for(auto x:arr){\\n                ans+=abs(x-val);\\n            }\\n            return ans;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findMedian(vector<int> &temp){\\n        sort(temp.begin(),temp.end());\\n\\n        if(temp.size()%2==1){\\n            return temp[temp.size()/2];\\n        }\\n        return (temp[temp.size()/2]+temp[temp.size()/2-1])/2;\\n    }\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        if(__gcd(n,k)>1){\\n            k=__gcd(n,k);\\n            long long ans=0;\\n            for(int i=0;i<k;i++){\\n                vector<int> temp;\\n                for(int j=i;j<arr.size();j+=k){\\n                    temp.push_back(arr[j]);\\n                }\\n                int val=findMedian(temp);\\n                for(auto x:temp){\\n                    ans+=abs(x-val);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n        else{\\n            int val=findMedian(arr);\\n            long long ans=0;\\n            for(auto x:arr){\\n                ans+=abs(x-val);\\n            }\\n            return ans;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377254,
                "title": "using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long f(vector<int> &v , int mid){\\n        \\n        long long sum = 0;\\n        for(int i=0 ; i<v.size() ; i++){\\n            sum += abs(v[i]-mid);\\n        }\\n        return sum;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        \\n        long long fin_ans = 0;        \\n        \\n        k = __gcd(k,(int)arr.size());\\n\\n        for(int i=0 ; i<k ; i++){\\n            \\n            int j = i;\\n            vector<int>v;\\n            int mini = INT_MAX;\\n            int maxi = INT_MIN;\\n            while(j<arr.size()){\\n                v.push_back(arr[j]);\\n                mini = min(mini , arr[j]);\\n                maxi = max(maxi , arr[j]);\\n                j += k;\\n            }            \\n            int l = mini;\\n            int r = maxi;\\n            int ans = 0;\\n            while(l<=r){\\n                int mid = l +(r-l)/2 ;\\n                \\n                if(f(v,mid+1)>=f(v,mid) && f(v,mid)<=f(v,mid-1)){\\n                    ans = mid;\\n                    break;\\n                }\\n                \\n                else if(f(v,mid-1)<=f(v,mid)){\\n                    r =  mid - 1;\\n                }\\n                \\n                else if(f(v,mid-1)>=f(v,mid)){\\n                    l = mid + 1;\\n                }\\n                \\n            }\\n        \\n            \\n            \\n            fin_ans += f(v , ans);\\n            \\n            \\n        }\\n        \\n        \\n        return fin_ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long f(vector<int> &v , int mid){\\n        \\n        long long sum = 0;\\n        for(int i=0 ; i<v.size() ; i++){\\n            sum += abs(v[i]-mid);\\n        }\\n        return sum;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        \\n        long long fin_ans = 0;        \\n        \\n        k = __gcd(k,(int)arr.size());\\n\\n        for(int i=0 ; i<k ; i++){\\n            \\n            int j = i;\\n            vector<int>v;\\n            int mini = INT_MAX;\\n            int maxi = INT_MIN;\\n            while(j<arr.size()){\\n                v.push_back(arr[j]);\\n                mini = min(mini , arr[j]);\\n                maxi = max(maxi , arr[j]);\\n                j += k;\\n            }            \\n            int l = mini;\\n            int r = maxi;\\n            int ans = 0;\\n            while(l<=r){\\n                int mid = l +(r-l)/2 ;\\n                \\n                if(f(v,mid+1)>=f(v,mid) && f(v,mid)<=f(v,mid-1)){\\n                    ans = mid;\\n                    break;\\n                }\\n                \\n                else if(f(v,mid-1)<=f(v,mid)){\\n                    r =  mid - 1;\\n                }\\n                \\n                else if(f(v,mid-1)>=f(v,mid)){\\n                    l = mid + 1;\\n                }\\n                \\n            }\\n        \\n            \\n            \\n            fin_ans += f(v , ans);\\n            \\n            \\n        }\\n        \\n        \\n        return fin_ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376663,
                "title": "swift-solution-not-so-well-optimized-but-worked",
                "content": "# Approach\\n1. First, we find the GCD of the array length and k. If the GCD is equal to the length of the array, then it\\'s the same as the case where k=1. If the GCD is 1, then it\\'s the same as the case where k=length of the array. So in both cases, we just return the answer for the cases where k=1 and k=length of the array.\\n2. Otherwise, we divide the array into k groups, each with length of the length of the array divided by the GCD. For each group, we find the median of the group, and then we add the sum of the absolute differences between the median and each number in the group to the answer.\\n3. Then, we return the minimum of the answer above and the answer for the case where k=1.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {\\n        var k = k\\n        k = gcd(arr.count, k)\\n        if k == arr.count { return 0 }\\n        if k == 1 { return getVal(arr) }\\n\\n        var ptd = 0\\n        var arr2 = [Int](repeating: 0, count: arr.count/k)\\n        for i in 0..<k {\\n            for j in stride(from: i, to: arr.count, by: k) {\\n                arr2[j/k] = arr[j]\\n            }\\n            ptd += getVal(arr2)\\n        }\\n        return min(ptd, getVal(arr))\\n    }\\n    private func getVal(_ arrx: [Int]) -> Int {\\n        var arrx = arrx\\n        arrx.sort()\\n        let s = arrx[arrx.count/2]\\n        var r = 0\\n        for t in arrx { r += abs(s-t) }\\n        return r\\n    }\\n\\n    private func gcd(_ a: Int, _ b: Int) -> Int {\\n        if a < b { return gcd(b, a) }\\n        if a % b == 0 { return b }\\n        return gcd(b, a%b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {\\n        var k = k\\n        k = gcd(arr.count, k)\\n        if k == arr.count { return 0 }\\n        if k == 1 { return getVal(arr) }\\n\\n        var ptd = 0\\n        var arr2 = [Int](repeating: 0, count: arr.count/k)\\n        for i in 0..<k {\\n            for j in stride(from: i, to: arr.count, by: k) {\\n                arr2[j/k] = arr[j]\\n            }\\n            ptd += getVal(arr2)\\n        }\\n        return min(ptd, getVal(arr))\\n    }\\n    private func getVal(_ arrx: [Int]) -> Int {\\n        var arrx = arrx\\n        arrx.sort()\\n        let s = arrx[arrx.count/2]\\n        var r = 0\\n        for t in arrx { r += abs(s-t) }\\n        return r\\n    }\\n\\n    private func gcd(_ a: Int, _ b: Int) -> Int {\\n        if a < b { return gcd(b, a) }\\n        if a % b == 0 { return b }\\n        return gcd(b, a%b)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373899,
                "title": "100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*  \\n        Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\\n        In one move, you can increment or decrement an element of the array by 1.\\n    */\\n    long long minMoves2(vector<int>& nums) {\\n\\n        //**************************METHOD 2********************************************************************\\n        /*  \\n            Sum of of absolute deviation is minimum if it is taken w.r.t median:\\n            \\n            Lets take the Sum of absolute deviation w.r.t x: \\n            S = Sum(|a[i] - x|) for i = 1 to n\\n\\n            Now S in minimum if derivative is 0 ==> from this we can get x = median  \\n\\n            Also, if the number of elements is even, then instead of median we cant take any value \\n            betweeen the middle two elements as x for min Sum of absolute deviation.\\n            Here we are taking the n/2-th element as x, when no. of elements is even.\\n        */\\n        \\n        int n = nums.size();\\n        int mid = n / 2;\\n        nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n\\n        int x = nums[mid];\\n        long long res = 0;\\n        for(int ele : nums)\\n            res += abs(ele - x);\\n\\n        return res;         \\n    }\\n\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        /*\\n            Psuedo intuition :\\n                for each subarray of size k to be equal:\\n                    sum[(i)...(i+k-1)%m] = sum[(i+1)%m....(i+k)%m]\\n                    or, a[i] = a[(i+k)%m] for all i\\n\\n                    that is, we need to make each subsequence {a[i], a[i+k], a[i+2k], .... } equal.\\n                    This is similar to : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/ \\n        */  \\n\\n        int n = arr.size();\\n\\n        long long res = 0;\\n        vector<bool> visited(n, false);\\n        \\n        for(int i = 0; i< k; i++)\\n        {\\n            vector<int> subseq;\\n            int j = i;\\n            while(!visited[j])\\n            {\\n                subseq.push_back(arr[j]);\\n                visited[j] = true;\\n                j = (j + k) % n;\\n            }\\n\\n            if(subseq.size() > 0)\\n                res += minMoves2(subseq);\\n        }\\n\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*  \\n        Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\\n        In one move, you can increment or decrement an element of the array by 1.\\n    */\\n    long long minMoves2(vector<int>& nums) {\\n\\n        //**************************METHOD 2********************************************************************\\n        /*  \\n            Sum of of absolute deviation is minimum if it is taken w.r.t median:\\n            \\n            Lets take the Sum of absolute deviation w.r.t x: \\n            S = Sum(|a[i] - x|) for i = 1 to n\\n\\n            Now S in minimum if derivative is 0 ==> from this we can get x = median  \\n\\n            Also, if the number of elements is even, then instead of median we cant take any value \\n            betweeen the middle two elements as x for min Sum of absolute deviation.\\n            Here we are taking the n/2-th element as x, when no. of elements is even.\\n        */\\n        \\n        int n = nums.size();\\n        int mid = n / 2;\\n        nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n\\n        int x = nums[mid];\\n        long long res = 0;\\n        for(int ele : nums)\\n            res += abs(ele - x);\\n\\n        return res;         \\n    }\\n\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        /*\\n            Psuedo intuition :\\n                for each subarray of size k to be equal:\\n                    sum[(i)...(i+k-1)%m] = sum[(i+1)%m....(i+k)%m]\\n                    or, a[i] = a[(i+k)%m] for all i\\n\\n                    that is, we need to make each subsequence {a[i], a[i+k], a[i+2k], .... } equal.\\n                    This is similar to : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/ \\n        */  \\n\\n        int n = arr.size();\\n\\n        long long res = 0;\\n        vector<bool> visited(n, false);\\n        \\n        for(int i = 0; i< k; i++)\\n        {\\n            vector<int> subseq;\\n            int j = i;\\n            while(!visited[j])\\n            {\\n                subseq.push_back(arr[j]);\\n                visited[j] = true;\\n                j = (j + k) % n;\\n            }\\n\\n            if(subseq.size() > 0)\\n                res += minMoves2(subseq);\\n        }\\n\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373272,
                "title": "java-easy-way-by-using-gcd-and-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        k=gcd(arr.length, k);\\n        if(k==arr.length)return 0;\\n        if(k==1) return getVal(arr);\\n\\n        long ptd=0;\\n        int[] arr2 = new int[arr.length/k];\\n        for(int i=0; i<k; i++){\\n            for(int j=i; j<arr.length; j+=k){\\n                arr2[j/k]=arr[j];\\n            }\\n            ptd+=getVal(arr2);\\n        }\\n        return Math.min(ptd,getVal(arr));\\n    }\\n    private long getVal(int[] arrx){\\n        Arrays.sort(arrx);\\n        int s = arrx[arrx.length/2];\\n        long r=0;\\n        for(int t:arrx) r+=Math.abs(s-t);\\n        return r;\\n    }\\n\\n    private int gcd(int a, int b){\\n        if(a<b)return gcd(b,a);\\n        if(a%b==0)return b;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        k=gcd(arr.length, k);\\n        if(k==arr.length)return 0;\\n        if(k==1) return getVal(arr);\\n\\n        long ptd=0;\\n        int[] arr2 = new int[arr.length/k];\\n        for(int i=0; i<k; i++){\\n            for(int j=i; j<arr.length; j+=k){\\n                arr2[j/k]=arr[j];\\n            }\\n            ptd+=getVal(arr2);\\n        }\\n        return Math.min(ptd,getVal(arr));\\n    }\\n    private long getVal(int[] arrx){\\n        Arrays.sort(arrx);\\n        int s = arrx[arrx.length/2];\\n        long r=0;\\n        for(int t:arrx) r+=Math.abs(s-t);\\n        return r;\\n    }\\n\\n    private int gcd(int a, int b){\\n        if(a<b)return gcd(b,a);\\n        if(a%b==0)return b;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372216,
                "title": "java-faster-then-100",
                "content": "# Intuition\\nif groups are formed on basis of this pattern :\\n\\n# Approach\\n1,4   ,1,3   ,6,8\\nthen we can take median(after sorting) of 1,1,6 and then difference of each element with is ans=5\\nsimilarly find for 4,3,8 and add in ans+=5\\nans=10\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n    int n=arr.length,h=gcd(n,k),q=n/h;\\n    long ans=0;\\n    for(int i=0;i<h;i++)\\n    {\\n        int x[]=new int[q];\\n        for(int j=0;j<q;j++)\\n        {\\n            x[j]=arr[(h*j)+i];\\n        }\\n        Arrays.sort(x);\\n        int v=q/2;\\n        int u=q%2==0?(x[v]+x[v-1])/2:x[v];\\n        for(int o=0;o<q;o++)\\n        {ans+=Math.abs(u-x[o]);}\\n    }\\n        return ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, Math.abs(a - b));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n    int n=arr.length,h=gcd(n,k),q=n/h;\\n    long ans=0;\\n    for(int i=0;i<h;i++)\\n    {\\n        int x[]=new int[q];\\n        for(int j=0;j<q;j++)\\n        {\\n            x[j]=arr[(h*j)+i];\\n        }\\n        Arrays.sort(x);\\n        int v=q/2;\\n        int u=q%2==0?(x[v]+x[v-1])/2:x[v];\\n        for(int o=0;o<q;o++)\\n        {ans+=Math.abs(u-x[o]);}\\n    }\\n        return ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, Math.abs(a - b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371353,
                "title": "simple-approach",
                "content": "# Intuition\\n/**\\n * the idea is simple , once you understand the basic thing, you can expand it towards the problem and see the answer\\n *\\n * Understanding: k is nothing but the size of the sliding window\\n * IDEA:: So every time the sliding window moves forwards, it leaves one element behind\\n * Solution: The element it leaves behind should be equal to the new element it adds to the sliding window\\n *\\n *\\n*/\\n\\n# Approach\\n/**\\n *\\n * Approach: since i th and (i+k)%n th elements should be same, I collect them and get the minimum number\\n * of steps required to make them equal\\n * then I return the total sum of number of moves;\\n */\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n\\n        if(k > arr.length) return minMove(Arrays.asList(Arrays.stream( arr ).boxed().toArray( Integer[]::new )));\\n        int len = arr.length;\\n        int flag[] = new int[arr.length];\\n        Arrays.fill(flag,0);\\n\\n\\n        List<Integer> temp = new ArrayList<>();\\n        long min =0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(flag[i] == 1) continue;\\n            int j=i;\\n            while(flag[j] == 0)\\n            {\\n                temp.add(arr[j]);\\n                flag[j] = 1;\\n                j = (j+k)%len;\\n            }\\n            min += (long)minMove(temp);\\n            temp = new ArrayList<>();\\n        }\\n\\n        return min;\\n\\n    }\\n\\n\\n    public long minMove(List<Integer> arr) {\\n        long res =0;\\n        Collections.sort(arr);\\n        Integer median = arr.get(arr.size()/2);\\n        for(Integer x:arr) res+= Math.abs(x - median);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n\\n        if(k > arr.length) return minMove(Arrays.asList(Arrays.stream( arr ).boxed().toArray( Integer[]::new )));\\n        int len = arr.length;\\n        int flag[] = new int[arr.length];\\n        Arrays.fill(flag,0);\\n\\n\\n        List<Integer> temp = new ArrayList<>();\\n        long min =0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(flag[i] == 1) continue;\\n            int j=i;\\n            while(flag[j] == 0)\\n            {\\n                temp.add(arr[j]);\\n                flag[j] = 1;\\n                j = (j+k)%len;\\n            }\\n            min += (long)minMove(temp);\\n            temp = new ArrayList<>();\\n        }\\n\\n        return min;\\n\\n    }\\n\\n\\n    public long minMove(List<Integer> arr) {\\n        long res =0;\\n        Collections.sort(arr);\\n        Integer median = arr.get(arr.size()/2);\\n        for(Integer x:arr) res+= Math.abs(x - median);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371274,
                "title": "make-k-subarray-sums-equal-java-group-same-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        long ans=0;\\n        int n=arr.length;\\n\\n        boolean []vis=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]){\\n                continue;\\n            }\\n\\n            List<Integer> group=new ArrayList<>();\\n\\n            group.add(arr[i]);\\n\\n            int next=(i+k)%n;\\n            while(next!=i){\\n                if(!vis[next]){\\n                    vis[next]=true;\\n                    group.add(arr[next]);\\n                }\\n\\n                next=(next+k)%n;\\n            }\\n\\n            Collections.sort(group);\\n            int median=group.get(group.size()/2);\\n\\n            for(int ele:group){\\n                ans+=Math.abs(ele-median);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        long ans=0;\\n        int n=arr.length;\\n\\n        boolean []vis=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]){\\n                continue;\\n            }\\n\\n            List<Integer> group=new ArrayList<>();\\n\\n            group.add(arr[i]);\\n\\n            int next=(i+k)%n;\\n            while(next!=i){\\n                if(!vis[next]){\\n                    vis[next]=true;\\n                    group.add(arr[next]);\\n                }\\n\\n                next=(next+k)%n;\\n            }\\n\\n            Collections.sort(group);\\n            int median=group.get(group.size()/2);\\n\\n            for(int ele:group){\\n                ans+=Math.abs(ele-median);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370651,
                "title": "gcd-good-performance",
                "content": "# Intuition\\nTo make the sum of every contiguous subarray of size k equal, we can transform the problem into a simpler problem of finding the median of every subarray of size k and then calculate the sum of the absolute differences between the median and every element in the subarray.\\n\\nTo achieve this, we can group the numbers into k groups, each group consisting of every k-th element starting from the i-th element for i in range k. We then sort each group and take the median value as the pivot. Finally, we calculate the sum of the absolute differences between the pivot and every element in the group.\\n\\n# Complexity\\n- Time complexity: $$O(k\\u2217nlogn)$$\\nThe outer loop iterates k times, and each iteration sorts a sub-array of size $$n/k$$. The time complexity of the inner sort operation is $$O(n/k * log (n/k))$$ which can be simplified as $$O(n log n - log k)$$. Since $$k <= n$$, we can say that the time complexity of each iteration is $$O(n log n)$$. Therefore, the time complexity of the entire loop is $$O(k * n log n)$$. \\nIn the worst-case scenario, where $$k$$ is equal to 1 or $$n$$, the time complexity of the code would be $$O(n^2$$) due to the nested loop over all elements in the sub-array. However, in practice, $$k$$ is usually much smaller than $$n$$, and the code performs much better with an average time complexity of $$O(n log n)$$.\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        res = 0\\n        n = len(arr)\\n        k = math.gcd(k, n)\\n        for i in range(k):\\n            sub_arr = sorted(arr[i::k])\\n            mid = sub_arr[len(sub_arr)//2]\\n\\n            for j in range(i, n, k):\\n                res += abs(mid - arr[j])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        res = 0\\n        n = len(arr)\\n        k = math.gcd(k, n)\\n        for i in range(k):\\n            sub_arr = sorted(arr[i::k])\\n            mid = sub_arr[len(sub_arr)//2]\\n\\n            for j in range(i, n, k):\\n                res += abs(mid - arr[j])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369647,
                "title": "c-map-sort",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n=a.size();\\n        if(n==1)return 0;\\n        ll ans=0;\\n        map<int,vector<int>> h;\\n        for(int i=0;i<k;i++)\\n        {\\n            int j=i;\\n            while(1)\\n            {\\n              if(a[j]==0)break;\\n              h[i].push_back(a[j]);\\n              a[j]=0;\\n              j=(j+k)%n;\\n            }\\n        }\\n        for(auto it:h)\\n        {\\n            vector<int> temp=it.second;  \\n            sort(temp.begin(),temp.end());\\n            int size=temp.size();\\n            int curr=temp[size/2];\\n            for(auto ele:it.second)\\n            {\\n                ans+=abs(ele-curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n=a.size();\\n        if(n==1)return 0;\\n        ll ans=0;\\n        map<int,vector<int>> h;\\n        for(int i=0;i<k;i++)\\n        {\\n            int j=i;\\n            while(1)\\n            {\\n              if(a[j]==0)break;\\n              h[i].push_back(a[j]);\\n              a[j]=0;\\n              j=(j+k)%n;\\n            }\\n        }\\n        for(auto it:h)\\n        {\\n            vector<int> temp=it.second;  \\n            sort(temp.begin(),temp.end());\\n            int size=temp.size();\\n            int curr=temp[size/2];\\n            for(auto ele:it.second)\\n            {\\n                ans+=abs(ele-curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369444,
                "title": "python-sort-median-gcd-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, for an array we want to make it to the same number with minimum cost. The optimal solution is making all element equal to median of the array. You can imagine a sorted array. Start with the median, if increas one in median. The left side of median needs to increase. \\nIt\\'s obviously arr[i] have to be the same with arr[i + k]. And then it\\'s a circular array. So how to deal with the head and tail, it\\'s kind of tricky. Especially for the cases `len(arr) % k != 0`. If `len(arr) % k == 0` we can find out that we could seperate array to k parts and make them equal.\\nFor the case `arr = [1,2,3,4,5,6] k = 4` we can find out that is equal to \\n`arr = [1,2,3,4,5,6] k = 2`. And you may find out this new k is GCD(len(arr), k).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the new k.\\n2. Seperate array to k parts.\\n3. Find the median of these k parts.\\n4. Sum the differen to medain in these k parts.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) for sort\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for seperate array.\\n# Others\\nI like this one. It needs more concepts than others to finished. The median part, it took me a while to think of the mean or median. And i tried two median for len(arr) is even in the contest. But I think this may be the same cost for using any one of them. The GCD part, it\\'s the tricky part. For me, if I met this in an interview, I thought it would be hard for me to proof the correcrtness. It might be reducable with the BFS or Union find.\\n\\nThanks for reading. If you thought this helps, please upvote. Or if you have any questions or ideas, comment and let\\'s discuss.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def cost(arr, target):\\n            ans = 0\\n            for i in range(len(arr)):\\n                ans += abs(target - arr[i])\\n            return ans\\n        def find_median(arr):\\n            arr.sort()\\n            n = len(arr)\\n            if n&1:\\n                return [arr[n//2]]\\n            else:\\n                return [arr[n//2], arr[n//2 - 1]]\\n            \\n        n = len(arr)\\n        m = n\\n        while m % k:\\n            m %= k\\n            if m < k:\\n                m, k = k, m\\n        \\n        subs = [[]for _ in range(k)]\\n        for i in range(n):\\n            subs[i%k].append(arr[i])\\n        ans = 0\\n        for sub in subs:\\n            current = math.inf\\n            for target in find_median(sub):\\n                current = min(current, cost(sub, target))\\n            ans += current\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def cost(arr, target):\\n            ans = 0\\n            for i in range(len(arr)):\\n                ans += abs(target - arr[i])\\n            return ans\\n        def find_median(arr):\\n            arr.sort()\\n            n = len(arr)\\n            if n&1:\\n                return [arr[n//2]]\\n            else:\\n                return [arr[n//2], arr[n//2 - 1]]\\n            \\n        n = len(arr)\\n        m = n\\n        while m % k:\\n            m %= k\\n            if m < k:\\n                m, k = k, m\\n        \\n        subs = [[]for _ in range(k)]\\n        for i in range(n):\\n            subs[i%k].append(arr[i])\\n        ans = 0\\n        for sub in subs:\\n            current = math.inf\\n            for target in find_median(sub):\\n                current = min(current, cost(sub, target))\\n            ans += current\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369079,
                "title": "easy-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        int no_of_buckets = __gcd(k, n);\\n        unordered_map<int, vector<int>> buckets;\\n\\n        for(int ind = 0; ind < n; ind++) {\\n            buckets[ind % no_of_buckets].push_back(arr[ind]);\\n        }\\n        \\n        long long result = 0;\\n        for(auto& bucket : buckets) {\\n            vector<int>& nums = bucket.second;\\n            int m = nums.size();\\n            \\n            for(auto x: nums) cout<<x<<\" \";\\n            cout<<endl;\\n            \\n            sort(nums.begin(), nums.end());\\n            int median = nums[m / 2];\\n\\n            for(auto& num : nums) {\\n                result += abs(median - num);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        int no_of_buckets = __gcd(k, n);\\n        unordered_map<int, vector<int>> buckets;\\n\\n        for(int ind = 0; ind < n; ind++) {\\n            buckets[ind % no_of_buckets].push_back(arr[ind]);\\n        }\\n        \\n        long long result = 0;\\n        for(auto& bucket : buckets) {\\n            vector<int>& nums = bucket.second;\\n            int m = nums.size();\\n            \\n            for(auto x: nums) cout<<x<<\" \";\\n            cout<<endl;\\n            \\n            sort(nums.begin(), nums.end());\\n            int median = nums[m / 2];\\n\\n            for(auto& num : nums) {\\n                result += abs(median - num);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3368978,
                "title": "beats-100-time-beats-100-meomry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        if(k>=arr.length) return 0;\\n        int n = arr.length;\\n        long sum = 0 ;\\n        boolean visited[]  =  new boolean[n]; \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(visited[i]==true)continue;\\n             ArrayList<Integer> ls = new ArrayList<>();\\n             int next = (i+k)%n ;\\n             ls.add(arr[i]);\\n             while(next!=i)\\n             {\\n                   visited[next] =  true;\\n                   ls.add(arr[next]);\\n                   next = (next+k)%n;\\n             }\\n            System.out.println(ls);\\n             Collections.sort(ls);\\n             int med = ls.get(ls.size()/2);\\n             for(int z :ls)\\n             {\\n                 sum+=Math.abs(med-z);\\n             }\\n             \\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        if(k>=arr.length) return 0;\\n        int n = arr.length;\\n        long sum = 0 ;\\n        boolean visited[]  =  new boolean[n]; \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(visited[i]==true)continue;\\n             ArrayList<Integer> ls = new ArrayList<>();\\n             int next = (i+k)%n ;\\n             ls.add(arr[i]);\\n             while(next!=i)\\n             {\\n                   visited[next] =  true;\\n                   ls.add(arr[next]);\\n                   next = (next+k)%n;\\n             }\\n            System.out.println(ls);\\n             Collections.sort(ls);\\n             int med = ls.get(ls.size()/2);\\n             for(int z :ls)\\n             {\\n                 sum+=Math.abs(med-z);\\n             }\\n             \\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368899,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn make_sub_k_sum_equal(arr: Vec<i32>, k: i32) -> i64 {\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        let arr = arr.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let k = k as i64;\\n        let n = arr.len() as i64;\\n        let k = gcd(n, k);\\n        let mut ans = 0;\\n        for i in 0..k {\\n            let mut vec = vec![];\\n            for j in (i..n).step_by(k as usize) {\\n                vec.push(arr[j as usize]);\\n            }\\n            vec.sort();\\n            let mid = vec.len() / 2;\\n            for ind in 0..vec.len() {\\n                ans += (vec[mid] - vec[ind]).abs();\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_sub_k_sum_equal(arr: Vec<i32>, k: i32) -> i64 {\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        let arr = arr.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let k = k as i64;\\n        let n = arr.len() as i64;\\n        let k = gcd(n, k);\\n        let mut ans = 0;\\n        for i in 0..k {\\n            let mut vec = vec![];\\n            for j in (i..n).step_by(k as usize) {\\n                vec.push(arr[j as usize]);\\n            }\\n            vec.sort();\\n            let mid = vec.len() / 2;\\n            for ind in 0..vec.len() {\\n                ans += (vec[mid] - vec[ind]).abs();\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368648,
                "title": "c-seperate-nums-into-group",
                "content": "To make sum of subarray all same, we need to make\\n\\t\\n\\tarr[i] == arr[i + k] == arr[i + 2 * k] == arr[i + 3 * k]...\\n\\tarr[i + 1] == arr[i + 1 + k] == arr[i + 1 + 2 * k] == arr[i + 1 + 3 * k]...\\n\\nTherefore, we can group the nums in arr according above roles, then result will be the sum of the deviation from median number in each group\\n\\n```\\n\\tpublic long MakeSubKSumEqual(int[] arr, int k) {\\n\\t\\tvar visited = new HashSet<int>();\\n        var groups = new List<HashSet<int>>();\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (visited.Contains(i)) continue;\\n            var group = new HashSet<int>();\\n            var index = i;\\n            while (group.Add(index))\\n                index = (index + k) % arr.Length;\\n            visited.UnionWith(group);\\n            groups.Add(group);\\n        }\\n        long res = 0;\\n        foreach (var group in groups)\\n            res += GetOperations(arr, group);\\n        return res;\\n    }\\n\\n    public static long GetOperations(int[] arr, HashSet<int> indexes) {\\n        var nums = indexes.Select(x => arr[x]).OrderBy(x => x).ToArray();\\n        var median = nums[nums.Length / 2];\\n        long res = 0;\\n        foreach (var num in nums) \\n            res += Math.Abs(num - median);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic long MakeSubKSumEqual(int[] arr, int k) {\\n\\t\\tvar visited = new HashSet<int>();\\n        var groups = new List<HashSet<int>>();\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (visited.Contains(i)) continue;\\n            var group = new HashSet<int>();\\n            var index = i;\\n            while (group.Add(index))\\n                index = (index + k) % arr.Length;\\n            visited.UnionWith(group);\\n            groups.Add(group);\\n        }\\n        long res = 0;\\n        foreach (var group in groups)\\n            res += GetOperations(arr, group);\\n        return res;\\n    }\\n\\n    public static long GetOperations(int[] arr, HashSet<int> indexes) {\\n        var nums = indexes.Select(x => arr[x]).OrderBy(x => x).ToArray();\\n        var median = nums[nums.Length / 2];\\n        long res = 0;\\n        foreach (var num in nums) \\n            res += Math.Abs(num - median);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367872,
                "title": "c-gcd",
                "content": "```C []\\nstatic int gcd(int a, int b){\\n\\twhile (b != 0){\\n\\t\\tconst int c = a % b;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t}\\n\\treturn a;\\n}\\n\\nstatic int cmp_int_asc(const void * const p1, const void * const p2){\\n\\treturn *(const int *)p1 - *(const int *)p2;\\n}\\n\\nstatic int64_t minOperToMakeAllEqual(int * const nums, const int numsLen){\\n\\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\\n\\tint64_t result = 0;\\n\\tfor (int left = 0, right = numsLen - 1; left < right; left += 1, right -= 1){\\n\\t\\tresult += (nums[right] - nums[left]);\\n\\t}\\n\\treturn result;\\n}\\n\\nint64_t makeSubKSumEqual(\\n\\tconst int * const arr,\\n\\tconst int arrLen,\\n\\tconst int k\\n){\\n\\tint64_t result = 0;\\n\\n\\tconst int\\n\\t\\tcolLen = gcd(arrLen, k),\\n\\t\\trowLen = arrLen / colLen\\n\\t;\\n\\tassert(arrLen % colLen == 0);\\n\\n\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\tint curColBuf[rowLen];\\n\\t\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\t\\tcurColBuf[row] = arr[colLen * row + col];\\n\\t\\t}\\n\\t\\tresult += minOperToMakeAllEqual(curColBuf, rowLen);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nstatic int gcd(int a, int b){\\n\\twhile (b != 0){\\n\\t\\tconst int c = a % b;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t}\\n\\treturn a;\\n}\\n\\nstatic int cmp_int_asc(const void * const p1, const void * const p2){\\n\\treturn *(const int *)p1 - *(const int *)p2;\\n}\\n\\nstatic int64_t minOperToMakeAllEqual(int * const nums, const int numsLen){\\n\\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\\n\\tint64_t result = 0;\\n\\tfor (int left = 0, right = numsLen - 1; left < right; left += 1, right -= 1){\\n\\t\\tresult += (nums[right] - nums[left]);\\n\\t}\\n\\treturn result;\\n}\\n\\nint64_t makeSubKSumEqual(\\n\\tconst int * const arr,\\n\\tconst int arrLen,\\n\\tconst int k\\n){\\n\\tint64_t result = 0;\\n\\n\\tconst int\\n\\t\\tcolLen = gcd(arrLen, k),\\n\\t\\trowLen = arrLen / colLen\\n\\t;\\n\\tassert(arrLen % colLen == 0);\\n\\n\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\tint curColBuf[rowLen];\\n\\t\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\t\\tcurColBuf[row] = arr[colLen * row + col];\\n\\t\\t}\\n\\t\\tresult += minOperToMakeAllEqual(curColBuf, rowLen);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367725,
                "title": "python-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr, k):\\n        n, dict1 = len(arr), defaultdict(int)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a,b = find(x),find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        def dfs(arr):\\n            n = len(arr)\\n            arr.sort()\\n            middle = arr[n//2]\\n            total = 0\\n\\n            for i in arr:\\n                total += abs(i-middle)\\n\\n            return total\\n\\n        for i in range(n):\\n            union(i,(i+k)%n)\\n\\n        if k == 1:\\n            return dfs(arr)\\n\\n        dict2 = defaultdict(list)\\n\\n        for i in range(n):\\n            dict2[find(i)].append(arr[i])\\n\\n        result = 0\\n\\n        for key in dict2:\\n            result += dfs(dict2[key])\\n\\n        return result\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr, k):\\n        n, dict1 = len(arr), defaultdict(int)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a,b = find(x),find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        def dfs(arr):\\n            n = len(arr)\\n            arr.sort()\\n            middle = arr[n//2]\\n            total = 0\\n\\n            for i in arr:\\n                total += abs(i-middle)\\n\\n            return total\\n\\n        for i in range(n):\\n            union(i,(i+k)%n)\\n\\n        if k == 1:\\n            return dfs(arr)\\n\\n        dict2 = defaultdict(list)\\n\\n        for i in range(n):\\n            dict2[find(i)].append(arr[i])\\n\\n        result = 0\\n\\n        for key in dict2:\\n            result += dfs(dict2[key])\\n\\n        return result\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367667,
                "title": "python-3-rule-based-approach",
                "content": "To make the sum of all subarry of size `k` equal, we need to make sure number `k` space apart should be equal.\\nFor example, if n = 4 and k = 2, then we need to make sure\\n```\\nnums[0] + nums[1] = nums[1] + nums[2] => nums[0] = nums[2]\\nnums[1] + nums[2] = nums[2] + nums[3] => nums[1] = nums[3]\\n```\\nMore generally\\n```\\nnums[i] + nums[i+1] + ... + nums[i+k-1] = nums[i+1] + nums[i+2] + ... + nums[i+k] => nums[i] = nums[i+k]\\n```\\nThus:\\n- Go from left to right to pick start points which are not visited\\n- Add all numbers `k` space apart into the queue\\n- Make them all equal by picking the median and calculate the absolute difference\\n\\n\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        j = 0\\n        n = len(arr)\\n        ans = 0\\n        vis = set()\\n        \\n        while len(vis) < n:\\n            # pick a start point never visited before\\n            while j in vis:\\n                j += 1\\n            \\n            i = j\\n            cands = []\\n            # visit all the number k-space apart\\n            while i not in vis:\\n                vis.add(i)\\n                cands.append(arr[i])\\n                i = (i + k) % n\\n                \\n            # make all numbers in the queue equal by finding the abs difference median and each number\\n            cands.sort()\\n            m = len(cands)\\n            mid = cands[m // 2]\\n            ans += mid * (m // 2) - sum(cands[:m // 2]) + sum(cands[m // 2:]) - mid * (m - m // 2)\\n\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nnums[0] + nums[1] = nums[1] + nums[2] => nums[0] = nums[2]\\nnums[1] + nums[2] = nums[2] + nums[3] => nums[1] = nums[3]\\n```\n```\\nnums[i] + nums[i+1] + ... + nums[i+k-1] = nums[i+1] + nums[i+2] + ... + nums[i+k] => nums[i] = nums[i+k]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367606,
                "title": "c-easy-to-understand-k-cycles-median-dfs",
                "content": "# Intuition\\nThe first thing to notice here is that every window of size k must be same in order to have same sum. Even if one of the windows is not in order / different, for some index the sum won\\'t be the same.\\n\\nAfter this intution, it is clear that every element at the index: x , x+k , x+2*k , x+3*k . . . (x+i*k)%n must be same forming a cycle.\\n\\n# Approach\\nIn order to achieve this, for every cycle independently, consider all its elements and then find the median.\\n\\nMedian is taken as it does not gets affected by the outliers. Suppose the numbers in a particular cycle are 1 11 12 . In this case, the Mean would be 8 and so 1 would be increased and 11 and 12 both would be decreased leading to more steps i.e 14. \\nwhen Median is considered then the steps would be 10 + 1 i.e 11.\\nSo, in this scenario median is more suitable representation of center.\\n\\nFinally, find the total number of steps required to make every element of the cycle equal to the Median and repeat the same process for each of the k cycles independently.\\n\\n# Complexity\\n- Time complexity:  O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& nums, int k) {\\n        long long int n=nums.size(),ans=0,med,vis[n];\\n        memset(vis,0,sizeof(vis));\\n        \\n        for(int x=0;x<k;x++){\\n            long long int temp=-1;\\n            vector<int> vals;\\n            for(int pos=x;!vis[pos];pos=(pos+k)%n){\\n                vals.push_back(nums[pos]);\\n                vis[pos]=1;\\n            }\\n            \\n            if(vals.size()>0){\\n                sort(vals.begin(),vals.end());\\n                if(vals.size()%2==0){\\n                    med=(vals[vals.size()/2]+vals[vals.size()/2-1])/2;\\n                }\\n                else{\\n                    med=vals[vals.size()/2];\\n                }\\n\\n                for(int y=0;y<vals.size();y++){\\n                    ans+=abs(vals[y]-med);\\n                }\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& nums, int k) {\\n        long long int n=nums.size(),ans=0,med,vis[n];\\n        memset(vis,0,sizeof(vis));\\n        \\n        for(int x=0;x<k;x++){\\n            long long int temp=-1;\\n            vector<int> vals;\\n            for(int pos=x;!vis[pos];pos=(pos+k)%n){\\n                vals.push_back(nums[pos]);\\n                vis[pos]=1;\\n            }\\n            \\n            if(vals.size()>0){\\n                sort(vals.begin(),vals.end());\\n                if(vals.size()%2==0){\\n                    med=(vals[vals.size()/2]+vals[vals.size()/2-1])/2;\\n                }\\n                else{\\n                    med=vals[vals.size()/2];\\n                }\\n\\n                for(int y=0;y<vals.size();y++){\\n                    ans+=abs(vals[y]-med);\\n                }\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367600,
                "title": "easy-solution-with-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDSU\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Alpha n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find_par(int a,int par[]){\\n    if(a==par[a])\\n    return a;\\n    return par[a]=find_par(par[a],par);\\n}int _union(int a,int b,int par[],int sz[]){\\n    a=find_par(a,par);\\n    b=find_par(b,par);\\n if(a==b)return 0;\\n if(sz[b]>sz[a])swap(a,b);\\n par[b]=a;\\n sz[a]+=sz[b];\\n return 1;\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n     \\n         int n=arr.size();\\n        long long ans=0;\\n    \\n        \\n        int par[n],sz[n];\\n        for(int i=0;i<n;i++){\\n            par[i]=i;sz[i]=1;\\n        }\\n       \\n        \\n\\n        for(int i=0;i<n;i++){\\n            _union(i,((i+k)%n),par,sz);\\n            \\n        }\\n    \\n         for(int i=0;i<n;i++){\\n           find_par(i,par);\\n            \\n        }\\n          map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[par[i]].push_back(arr[i]);\\n        }\\n       \\n        for(auto i:mp){\\n            vector<int>v=i.second;\\n            sort(v.begin(),v.end());\\n            for(int j=0;j<v.size();j++){\\n               \\n                ans+=abs(v[j]-v[v.size()/2]);       \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_par(int a,int par[]){\\n    if(a==par[a])\\n    return a;\\n    return par[a]=find_par(par[a],par);\\n}int _union(int a,int b,int par[],int sz[]){\\n    a=find_par(a,par);\\n    b=find_par(b,par);\\n if(a==b)return 0;\\n if(sz[b]>sz[a])swap(a,b);\\n par[b]=a;\\n sz[a]+=sz[b];\\n return 1;\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n     \\n         int n=arr.size();\\n        long long ans=0;\\n    \\n        \\n        int par[n],sz[n];\\n        for(int i=0;i<n;i++){\\n            par[i]=i;sz[i]=1;\\n        }\\n       \\n        \\n\\n        for(int i=0;i<n;i++){\\n            _union(i,((i+k)%n),par,sz);\\n            \\n        }\\n    \\n         for(int i=0;i<n;i++){\\n           find_par(i,par);\\n            \\n        }\\n          map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[par[i]].push_back(arr[i]);\\n        }\\n       \\n        for(auto i:mp){\\n            vector<int>v=i.second;\\n            sort(v.begin(),v.end());\\n            for(int j=0;j<v.size();j++){\\n               \\n                ans+=abs(v[j]-v[v.size()/2]);       \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367550,
                "title": "ported-swift-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {\\n        var result = 0\\n        var arr = arr\\n        \\n        for i in 0..<arr.count {\\n            var cycle = Array<Int>()\\n            \\n            var j = i\\n            while arr[j] != 0 {\\n                cycle.append(arr[j])\\n                arr[j] = 0\\n                j = (j + k) % arr.count\\n            }\\n            \\n            cycle.sort()\\n            let midIndex = cycle.count / 2\\n\\n            for n in cycle {\\n                result += abs(n - cycle[midIndex])\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {\\n        var result = 0\\n        var arr = arr\\n        \\n        for i in 0..<arr.count {\\n            var cycle = Array<Int>()\\n            \\n            var j = i\\n            while arr[j] != 0 {\\n                cycle.append(arr[j])\\n                arr[j] = 0\\n                j = (j + k) % arr.count\\n            }\\n            \\n            cycle.sort()\\n            let midIndex = cycle.count / 2\\n\\n            for n in cycle {\\n                result += abs(n - cycle[midIndex])\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367517,
                "title": "cycles-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cmp;\\n    vector<vector<int>> cmps;\\n    void dfs(int node, vector<int> &vis, vector<int> &arr, int k) {\\n        int n = vis.size();\\n        vis[node] = 1;\\n        cmp.push_back(arr[node]);\\n        node = (node + k) % n;\\n        if (!vis[node])\\n            dfs(node, vis, arr, k);\\n    }\\n    long long makeSubKSumEqual(vector<int> &arr, int k) {\\n        int n = arr.size();\\n        vector<int> vis(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (!vis[i]) {\\n                dfs(i, vis, arr, k);\\n                cmps.push_back(cmp);\\n                cmp.clear();\\n            }\\n        }\\n        long long res = 0;\\n        for (auto cmp : cmps) {\\n            sort(cmp.begin(), cmp.end());\\n            int len = cmp.size();\\n            int med = cmp[len / 2];\\n            long long ans = 0;\\n            for (auto num : cmp) {\\n                ans += abs(num - med);\\n            }\\n            res += ans;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cmp;\\n    vector<vector<int>> cmps;\\n    void dfs(int node, vector<int> &vis, vector<int> &arr, int k) {\\n        int n = vis.size();\\n        vis[node] = 1;\\n        cmp.push_back(arr[node]);\\n        node = (node + k) % n;\\n        if (!vis[node])\\n            dfs(node, vis, arr, k);\\n    }\\n    long long makeSubKSumEqual(vector<int> &arr, int k) {\\n        int n = arr.size();\\n        vector<int> vis(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (!vis[i]) {\\n                dfs(i, vis, arr, k);\\n                cmps.push_back(cmp);\\n                cmp.clear();\\n            }\\n        }\\n        long long res = 0;\\n        for (auto cmp : cmps) {\\n            sort(cmp.begin(), cmp.end());\\n            int len = cmp.size();\\n            int med = cmp[len / 2];\\n            long long ans = 0;\\n            for (auto num : cmp) {\\n                ans += abs(num - med);\\n            }\\n            res += ans;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367402,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `arr`\\n */\\nclass Solution {\\n public:\\n  long long makeSubKSumEqual(const vector<int> &arr, const int k) {\\n    const int n = static_cast<int>(arr.size());\\n    if (n == k) {\\n      return 0LL;\\n    }\\n    \\n    const int g = gcd(n, k);\\n    long long ret = 0LL;\\n    for (int start = 0; start < g; ++start) {\\n      vector<int> group;\\n      for (int index = start; index < n; index += g) {\\n        group.emplace_back(arr[index]);\\n      }\\n      const int n_group = static_cast<int>(group.size());\\n      const int mid_index = n_group / 2;\\n      nth_element(group.begin(), group.begin() + mid_index, group.end());\\n      for (const int num : group) {\\n        ret += abs(group[mid_index] - num);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `arr`\\n */\\nclass Solution {\\n public:\\n  long long makeSubKSumEqual(const vector<int> &arr, const int k) {\\n    const int n = static_cast<int>(arr.size());\\n    if (n == k) {\\n      return 0LL;\\n    }\\n    \\n    const int g = gcd(n, k);\\n    long long ret = 0LL;\\n    for (int start = 0; start < g; ++start) {\\n      vector<int> group;\\n      for (int index = start; index < n; index += g) {\\n        group.emplace_back(arr[index]);\\n      }\\n      const int n_group = static_cast<int>(group.size());\\n      const int mid_index = n_group / 2;\\n      nth_element(group.begin(), group.begin() + mid_index, group.end());\\n      for (const int num : group) {\\n        ret += abs(group[mid_index] - num);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367380,
                "title": "100-easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def rec(nums):\\n            if len(nums)==0:\\n                return 0\\n            nums.sort()\\n            psum=[nums[0]]\\n            for i in range(1,len(nums)):\\n                psum.append(psum[-1]+nums[i])\\n            s=psum[-1]\\n            ans=float(\"inf\")\\n            temp=0\\n            n=len(nums)\\n            for i in range(n):\\n                ii=nums[i]\\n                temp+=ii\\n                s-=ii\\n                a=abs(ii*(i+1)-temp)+abs(ii*(n-i-1)-s)\\n                ans=min(ans,a)\\n                # print(ii,ans,a)\\n            return ans\\n        # if len(arr)%k==0:\\n        fans=0\\n        vis=set()\\n        for i in range(k):\\n                temparr=[]\\n                \\n                j=i\\n                while True:\\n                    if j%len(arr) not in vis:\\n                        vis.add(j%len(arr))\\n                        temparr.append(arr[j%len(arr)])\\n                    else:\\n                        break\\n                    j+=k\\n                # print(temparr)\\n                fans+=rec(temparr)\\n                \\n                    \\n            \\n        return fans\\n                \\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def rec(nums):\\n            if len(nums)==0:\\n                return 0\\n            nums.sort()\\n            psum=[nums[0]]\\n            for i in range(1,len(nums)):\\n                psum.append(psum[-1]+nums[i])\\n            s=psum[-1]\\n            ans=float(\"inf\")\\n            temp=0\\n            n=len(nums)\\n            for i in range(n):\\n                ii=nums[i]\\n                temp+=ii\\n                s-=ii\\n                a=abs(ii*(i+1)-temp)+abs(ii*(n-i-1)-s)\\n                ans=min(ans,a)\\n                # print(ii,ans,a)\\n            return ans\\n        # if len(arr)%k==0:\\n        fans=0\\n        vis=set()\\n        for i in range(k):\\n                temparr=[]\\n                \\n                j=i\\n                while True:\\n                    if j%len(arr) not in vis:\\n                        vis.add(j%len(arr))\\n                        temparr.append(arr[j%len(arr)])\\n                    else:\\n                        break\\n                    j+=k\\n                # print(temparr)\\n                fans+=rec(temparr)\\n                \\n                    \\n            \\n        return fans\\n                \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367350,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public long MakeSubKSumEqual(int[] arr, int k)\\n    {\\n        var result = 0L;\\n        var size = arr.Length;\\n\\n        for (var i = 0; i < size; ++i)\\n        {\\n            var cycle = new List<int>();\\n\\n            for (var j = i; arr[j] != 0; j = (j + k) % size)\\n            {\\n                cycle.Add(arr[j]);\\n                arr[j] = 0;\\n            }\\n\\n            cycle.Sort();\\n            var median = cycle.Count != 0 ? cycle[cycle.Count / 2] : 0;\\n            result = cycle.Aggregate(result, (current, n) => current + Math.Abs(n - median));\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MakeSubKSumEqual(int[] arr, int k)\\n    {\\n        var result = 0L;\\n        var size = arr.Length;\\n\\n        for (var i = 0; i < size; ++i)\\n        {\\n            var cycle = new List<int>();\\n\\n            for (var j = i; arr[j] != 0; j = (j + k) % size)\\n            {\\n                cycle.Add(arr[j]);\\n                arr[j] = 0;\\n            }\\n\\n            cycle.Sort();\\n            var median = cycle.Count != 0 ? cycle[cycle.Count / 2] : 0;\\n            result = cycle.Aggregate(result, (current, n) => current + Math.Abs(n - median));\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367313,
                "title": "disjoint-set-c-group-all-arr-i-and-arr-i-k-and-find-median-of-grouping",
                "content": "# Intuition\\nSo **arr[i]** and **arr[i+k]** element must be same for the subarry at i and subarray at i-1 to have same sum.\\n\\nMake sure to use %n to wrap around, or you can use **i<2*n** along with **i%=n**.\\n\\nFor all elements that need to be same, we can find their median and make them all equal to it.\\n\\n# Approach\\nGroup all indexes that need to be same together.\\nNote that an index can end up in more than one group. In such case all elementas at the indexes present in both the groups would have to be equal.\\n\\nTo do this, do union find for all elements in same group.\\n\\nNow the number of parents remaining in union find is the total number of **distinct elements in final array**.\\n\\nNow for each distinct value of parent[i] make a vector with all values of indexes that have same parent as parent[i];\\n\\nNow for all such vectors solve by sorting and then calculating the absolute diffrence of each element with the median.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution\\n{\\nprivate:\\n    vector<int> par;\\n\\n    int find(int &x)\\n    {\\n        if (par[x] == x)\\n            return x;\\n        return par[x] = find(par[x]);\\n    }\\n\\n    void unionFind(int x, int y)\\n    {\\n        int px = find(x);\\n        int py = find(y);\\n        par[px] = py;\\n    }\\n\\n    long long minMovestoMakeArrayEqual(vector<int> &arr)\\n    {\\n        long long sum = 0;\\n        sort(arr.begin(), arr.end());\\n\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            sum += abs(arr[i] - arr[arr.size() / 2]);\\n        }\\n        return sum;\\n    }\\n\\npublic:\\n    long long makeSubKSumEqual(vector<int> &arr, int k)\\n    {\\n        long long ans = 0;\\n        vector<vector<int>> dp(k, vector<int>());\\n        int n = arr.size();\\n        for (int i = 0; i < 2 * n; i++)\\n        {\\n            dp[i % k].push_back(i % n);\\n        }\\n\\n        par.resize(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            par[i] = i;\\n        }\\n\\n        int sz;\\n        for (int i = 0; i < k; i++)\\n        {\\n            sz = dp[i].size();\\n            for (int j = 1; j < sz; j++)\\n            {\\n                unionFind(dp[i][j-1], dp[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n            find(i);\\n\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[par[i]].push_back(arr[i]);\\n        }\\n\\n        for (auto &x : mp)\\n        {\\n            ans += minMovestoMakeArrayEqual(x.second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    vector<int> par;\\n\\n    int find(int &x)\\n    {\\n        if (par[x] == x)\\n            return x;\\n        return par[x] = find(par[x]);\\n    }\\n\\n    void unionFind(int x, int y)\\n    {\\n        int px = find(x);\\n        int py = find(y);\\n        par[px] = py;\\n    }\\n\\n    long long minMovestoMakeArrayEqual(vector<int> &arr)\\n    {\\n        long long sum = 0;\\n        sort(arr.begin(), arr.end());\\n\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            sum += abs(arr[i] - arr[arr.size() / 2]);\\n        }\\n        return sum;\\n    }\\n\\npublic:\\n    long long makeSubKSumEqual(vector<int> &arr, int k)\\n    {\\n        long long ans = 0;\\n        vector<vector<int>> dp(k, vector<int>());\\n        int n = arr.size();\\n        for (int i = 0; i < 2 * n; i++)\\n        {\\n            dp[i % k].push_back(i % n);\\n        }\\n\\n        par.resize(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            par[i] = i;\\n        }\\n\\n        int sz;\\n        for (int i = 0; i < k; i++)\\n        {\\n            sz = dp[i].size();\\n            for (int j = 1; j < sz; j++)\\n            {\\n                unionFind(dp[i][j-1], dp[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n            find(i);\\n\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[par[i]].push_back(arr[i]);\\n        }\\n\\n        for (auto &x : mp)\\n        {\\n            ans += minMovestoMakeArrayEqual(x.second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367221,
                "title": "c-using-gcd-and-median",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        if(arr.size()==k) return 0;\\n        int n=arr.size();\\n        long long ans=0;\\n        int g=__gcd(n,k);\\n        int num=n/g;\\n        vector<vector<int>>v(g);\\n        for(int i=0;i<arr.size();i++){\\n            v[i%g].push_back(arr[i]);\\n        }\\n        for(int i=0;i<v.size();i++)\\n            sort(v[i].begin(), v[i].end());\\n        vector<int>w;\\n        if(num%2==0){\\n            for(int i=0;i<v.size();i++){\\n                int t=(long long)(v[i][num/2] + v[i][num/2 - 1])/2;   \\n                w.push_back(t); \\n            }\\n        }\\n        else {\\n            for(int i=0;i<v.size();i++){\\n                int t=v[i][num/2]; \\n                w.push_back(t); \\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            ans+=abs(arr[i]-w[i%g]);\\n        }\\n         return ans;\\n    }\\n};\\n```\\nplease upvote if it helps!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        if(arr.size()==k) return 0;\\n        int n=arr.size();\\n        long long ans=0;\\n        int g=__gcd(n,k);\\n        int num=n/g;\\n        vector<vector<int>>v(g);\\n        for(int i=0;i<arr.size();i++){\\n            v[i%g].push_back(arr[i]);\\n        }\\n        for(int i=0;i<v.size();i++)\\n            sort(v[i].begin(), v[i].end());\\n        vector<int>w;\\n        if(num%2==0){\\n            for(int i=0;i<v.size();i++){\\n                int t=(long long)(v[i][num/2] + v[i][num/2 - 1])/2;   \\n                w.push_back(t); \\n            }\\n        }\\n        else {\\n            for(int i=0;i<v.size();i++){\\n                int t=v[i][num/2]; \\n                w.push_back(t); \\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            ans+=abs(arr[i]-w[i%g]);\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367174,
                "title": "c-easy-solution-using-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int n){\\n    long long ans = 0;\\n    sort(nums.begin(), nums.end());\\n    long long K = nums[n / 2];\\n    for (int i = 0; i < n; ++i)\\n        ans += abs(nums[i] - K);\\n\\n    if (n % 2 == 0) {\\n        long long tmp = 0;\\n        K = nums[(n / 2) - 1];\\n        for (int i = 0; i < n; ++i)\\n            tmp += abs(nums[i] - K);\\n        ans = min(ans, tmp);\\n    }\\n    return ans;\\n}\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n = arr.size();\\n        if(__gcd(n,(long long)k) == 1) return minCost(arr,n);\\n        else {\\n            long long ans=0;\\n            for(int i=0; i<__gcd(n,(long long)k); i++){\\n                vector<int>v1;\\n                for(int j=i; j<arr.size(); j+=__gcd(n,(long long)k))\\n                    v1.push_back(arr[j]);\\n                ans+=minCost(v1,v1.size());\\n            }\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int n){\\n    long long ans = 0;\\n    sort(nums.begin(), nums.end());\\n    long long K = nums[n / 2];\\n    for (int i = 0; i < n; ++i)\\n        ans += abs(nums[i] - K);\\n\\n    if (n % 2 == 0) {\\n        long long tmp = 0;\\n        K = nums[(n / 2) - 1];\\n        for (int i = 0; i < n; ++i)\\n            tmp += abs(nums[i] - K);\\n        ans = min(ans, tmp);\\n    }\\n    return ans;\\n}\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n = arr.size();\\n        if(__gcd(n,(long long)k) == 1) return minCost(arr,n);\\n        else {\\n            long long ans=0;\\n            for(int i=0; i<__gcd(n,(long long)k); i++){\\n                vector<int>v1;\\n                for(int j=i; j<arr.size(); j+=__gcd(n,(long long)k))\\n                    v1.push_back(arr[j]);\\n                ans+=minCost(v1,v1.size());\\n            }\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367116,
                "title": "solution-easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is from YT->programming with Larry\\n\\nthe idea behind is  grouping  the element \\nExample\\n\\n[1,4,3,2,5,6,8] k=3\\n\\n1,4,3\\n#,4,3,2\\n#,#,3,2,5\\nand so on\\n\\nchanging the middle elements make no difference we need to make the end \\nelements equal that is  1,2,5 (thus forming a group)\\nsimlutating the process we will get more groups\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\nUPVOTE PLEASE\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N*log N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(N)$$\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        N=len(arr)\\n\\n        g=gcd(N,k)\\n\\n        c=collections.defaultdict(list)\\n\\n\\n        for i,x in enumerate(arr):\\n\\n            c[i%g].append(x)\\n    \\n\\n        count=0\\n\\n\\n        for i,k in c.items():\\n\\n            k.sort()\\n\\n            t=k[len(k)//2]\\n\\n            for y in k:\\n                count+=abs(t-y)\\n        return count\\n    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        N=len(arr)\\n\\n        g=gcd(N,k)\\n\\n        c=collections.defaultdict(list)\\n\\n\\n        for i,x in enumerate(arr):\\n\\n            c[i%g].append(x)\\n    \\n\\n        count=0\\n\\n\\n        for i,k in c.items():\\n\\n            k.sort()\\n\\n            t=k[len(k)//2]\\n\\n            for y in k:\\n                count+=abs(t-y)\\n        return count\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367109,
                "title": "divide-into-groups-easy-explaination",
                "content": "Lets divide the solution into 2 parts - \\n1. Divide into groups\\n2. Calculating for each group\\n\\n\\n\\n**Dividing into groups**\\n\\nLet arr = [a1 a2 a3 a4 a5 a6 a7]\\nfor k = 3, \\na1+a2+a3 = a2+a3+a4 => a1=a4\\n\\nFrom the above obervation we can see, that the elements at distance k should be equal , i.e a1=a4=a7\\nTherefore some chains would be created , in which the consecutive indexes in the chain would be at the distance k in the array\\n\\n\\n**Calculating for each group** \\nExacty same problem\\n    https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/submissions/735072118/\\n\\nWe can just find the median and then calculate cost to make each element equal to the median.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<vector<int> > groups;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[i]==-1) continue;\\n            vector<int> group;\\n            for(int j=i;arr[j]!=-1;j = (j+k)%n){\\n                group.push_back(arr[j]);\\n                arr[j]=-1;\\n            }\\n            groups.push_back(group);\\n        }\\n        \\n        long long ans=0;\\n        for(auto &group:groups){\\n            sort(group.begin(),group.end());\\n            int median = group[group.size()/2];\\n            for(auto &e:group){\\n                ans += abs(median-e);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<vector<int> > groups;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[i]==-1) continue;\\n            vector<int> group;\\n            for(int j=i;arr[j]!=-1;j = (j+k)%n){\\n                group.push_back(arr[j]);\\n                arr[j]=-1;\\n            }\\n            groups.push_back(group);\\n        }\\n        \\n        long long ans=0;\\n        for(auto &group:groups){\\n            sort(group.begin(),group.end());\\n            int median = group[group.size()/2];\\n            for(auto &e:group){\\n                ans += abs(median-e);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367057,
                "title": "c-find-centers-of-all-equivalent-groups",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        //group: [i],[i+k],[i+2k], ..., all have to be equal for all i = 0, 1, ... k-1\\n        long long n = arr.size(), op = 0;\\n        vector<bool> visited(k, false);\\n        for(int i = 0; i < k; ++i) {\\n            if(visited[i]) continue;\\n            \\n            vector<int> group;\\n            int j = i;\\n            do {\\n                visited[j] = true;\\n                for(; j < n; j += k)\\n                    group.push_back(arr[j]);\\n                j = j % n;\\n            }\\n            while(j < k && !visited[j]);\\n\\n            auto mid = group.begin() + group.size()/2;\\n            nth_element(group.begin(), mid, group.end());\\n            for_each(group.begin(), group.end(), [mid, &op](auto const& g) { op += abs(*mid - g); });\\n        }\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        //group: [i],[i+k],[i+2k], ..., all have to be equal for all i = 0, 1, ... k-1\\n        long long n = arr.size(), op = 0;\\n        vector<bool> visited(k, false);\\n        for(int i = 0; i < k; ++i) {\\n            if(visited[i]) continue;\\n            \\n            vector<int> group;\\n            int j = i;\\n            do {\\n                visited[j] = true;\\n                for(; j < n; j += k)\\n                    group.push_back(arr[j]);\\n                j = j % n;\\n            }\\n            while(j < k && !visited[j]);\\n\\n            auto mid = group.begin() + group.size()/2;\\n            nth_element(group.begin(), mid, group.end());\\n            for_each(group.begin(), group.end(), [mid, &op](auto const& g) { op += abs(*mid - g); });\\n        }\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366930,
                "title": "finding-median-of-cycles-code-breakdown-nth-element-to-find-median-quick-select-algorithm",
                "content": "# Intuition\\narr[i] should be equal to all arr[i+k] after all the operations are complete\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n## **Step By Step Code Breakdown :**\\n\\n```\\nint sz = arr.size(); long long ans=0;\\n```\\nInitialize the size of the input vector arr and a variable ans to keep track of the total absolute differences between the elements in each subarray and its median value.\\n```\\nfor(int i=0;i<sz;i++)\\n```\\n\\n Iterate through each index in the input vector arr.\\n\\n```\\nvector<int> cycle; \\n```\\n\\nCreate a new vector cycle to store the subarray of length k starting at index i.\\n\\n```\\nfor(int j = i; arr[j]!=0 ; j= (j+k)%sz)\\n```\\n\\nIterate through each index in the subarray, wrapping around to the beginning of the vector if necessary. The loop stops when it reaches an element with value 0, which is set by the code in step 7.\\n\\n```\\n{ cycle.push_back(arr[j]); arr[j]=0; }:\\n``` \\n\\nAdd the current element to the cycle vector and set its value to 0 to indicate that it has been included in a subarray.\\n\\n```\\nint median_idx = (int)cycle.size()/2;\\n```\\n\\nFind the median index of the cycle vector.\\n\\n```\\nnth_element(cycle.begin(),cycle.begin()+median_idx,cycle.end());\\n```\\nRearrange the elements in the cycle vector such that the median_idx element is in its final sorted position.\\n\\n```\\nfor(auto e : cycle) cout<<e<<\" \"; cout<<endl;\\n``` \\n\\nOutput the cycle vector to the console (for debugging purposes).\\n\\n```\\nfor(auto e : cycle) { ans+= abs(e-cycle[median_idx]); }\\n```\\nIterate through each element in the cycle vector and add the absolute difference between it and the median element to the ans variable.\\n\\n```\\nreturn ans;: \\n```\\nReturn the total absolute differences between the elements in each subarray and its median value.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# References \\n[https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366373/k-cycles-o-n/]()\\n\\n[https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366534/dsu-prefix-sum-o-n-longn/]()\\n\\n[https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366442/python-3-find-median-of-each-gcd-defined-subarray-w-examples/]()\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        int sz = arr.size(); long long ans=0;\\n\\n        for(int i=0;i<sz;i++)\\n        {\\n            vector<int> cycle;\\n\\n            for(int j = i; arr[j]!=0 ; j= (j+k)%sz)\\n               { \\n                   cycle.push_back(arr[j]);arr[j]=0;\\n                }\\n\\n            int median_idx = (int)cycle.size()/2;\\n\\n            nth_element(cycle.begin(),cycle.begin()+median_idx,cycle.end());\\n\\n\\n            for(auto e : cycle) cout<<e<<\" \"; cout<<endl;\\n            for(auto e : cycle)\\n            {\\n                ans+= abs(e-cycle[median_idx]);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Quickselect"
                ],
                "code": "```\\nint sz = arr.size(); long long ans=0;\\n```\n```\\nfor(int i=0;i<sz;i++)\\n```\n```\\nvector<int> cycle; \\n```\n```\\nfor(int j = i; arr[j]!=0 ; j= (j+k)%sz)\\n```\n```\\n{ cycle.push_back(arr[j]); arr[j]=0; }:\\n```\n```\\nint median_idx = (int)cycle.size()/2;\\n```\n```\\nnth_element(cycle.begin(),cycle.begin()+median_idx,cycle.end());\\n```\n```\\nfor(auto e : cycle) cout<<e<<\" \"; cout<<endl;\\n```\n```\\nfor(auto e : cycle) { ans+= abs(e-cycle[median_idx]); }\\n```\n```\\nreturn ans;: \\n```\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        int sz = arr.size(); long long ans=0;\\n\\n        for(int i=0;i<sz;i++)\\n        {\\n            vector<int> cycle;\\n\\n            for(int j = i; arr[j]!=0 ; j= (j+k)%sz)\\n               { \\n                   cycle.push_back(arr[j]);arr[j]=0;\\n                }\\n\\n            int median_idx = (int)cycle.size()/2;\\n\\n            nth_element(cycle.begin(),cycle.begin()+median_idx,cycle.end());\\n\\n\\n            for(auto e : cycle) cout<<e<<\" \"; cout<<endl;\\n            for(auto e : cycle)\\n            {\\n                ans+= abs(e-cycle[median_idx]);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3366914,
                "title": "python3-gcd-n-k-groups-o-n-o-nlogn",
                "content": "```python\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        \\n\\t\\t# in the same group means a[1] == a[1 + k] == a[1+ 2k]\\n\\t\\t# we need lcm(n, k) to repeat\\n\\t\\t# and we will have lcm(n, k)/k members for each group\\n\\t\\t# then the group count is n / (lcm(n, k) / k)\\n\\t\\t# which is (n * k) / lcm(n, k) == gcd(n, k)\\n\\t\\t\\n\\t\\t# how many groups we will have\\n        group_count = gcd(n, k)\\n        groups = [[] for _ in range(group_count)]\\n\\t\\t\\n\\t\\t# determine group id for each i\\n        for i in range(n):\\n            groups[i % group_count].append(arr[i])\\n\\n        res = 0\\n        for group in groups:\\n            group.sort()\\n\\t\\t\\t# sum distances to median\\n            res += sum(abs(g - group[len(group)//2]) for g in group)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        \\n\\t\\t# in the same group means a[1] == a[1 + k] == a[1+ 2k]\\n\\t\\t# we need lcm(n, k) to repeat\\n\\t\\t# and we will have lcm(n, k)/k members for each group\\n\\t\\t# then the group count is n / (lcm(n, k) / k)\\n\\t\\t# which is (n * k) / lcm(n, k) == gcd(n, k)\\n\\t\\t\\n\\t\\t# how many groups we will have\\n        group_count = gcd(n, k)\\n        groups = [[] for _ in range(group_count)]\\n\\t\\t\\n\\t\\t# determine group id for each i\\n        for i in range(n):\\n            groups[i % group_count].append(arr[i])\\n\\n        res = 0\\n        for group in groups:\\n            group.sort()\\n\\t\\t\\t# sum distances to median\\n            res += sum(abs(g - group[len(group)//2]) for g in group)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366884,
                "title": "sorting-to-find-the-median",
                "content": "# Intuition\\nWe should have arr[i] == arr[(i + k) % n] where n = arr.size(). So just get all these numbers in a group and find the median.\\n\\n# Approach\\nThis is to use the \"period\".\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long r = 0;\\n        const int n = arr.size();\\n        vector<bool> mark(n);\\n        for (int i = 0; i < k; ++i) {\\n            if (mark[i]) {\\n                continue;\\n            }\\n            vector<int> v;\\n            for (int j = i; !mark[j] ; j = (j + k) % n) {\\n                mark[j] = true;\\n                v.push_back(arr[j]);\\n            }\\n            sort(v.begin(), v.end());\\n            for (int x = 0, m = v.size() >> 1; x < v.size(); ++x) {\\n                r += x <= m ? (v[m] - v[x]) : (v[x] - v[m]);\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long r = 0;\\n        const int n = arr.size();\\n        vector<bool> mark(n);\\n        for (int i = 0; i < k; ++i) {\\n            if (mark[i]) {\\n                continue;\\n            }\\n            vector<int> v;\\n            for (int j = i; !mark[j] ; j = (j + k) % n) {\\n                mark[j] = true;\\n                v.push_back(arr[j]);\\n            }\\n            sort(v.begin(), v.end());\\n            for (int x = 0, m = v.size() >> 1; x < v.size(); ++x) {\\n                r += x <= m ? (v[m] - v[x]) : (v[x] - v[m]);\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366875,
                "title": "group-into-fixed-periods-and-make-each-group-equal",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def GCD(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        k = self.GCD(len(arr), k)\\n        ctr = [[] for _ in range(k)]\\n        median = [0] * k\\n        for i in range(len(arr)):\\n            ctr[i % k].append(arr[i])\\n        for i in range(k):\\n            n = len(ctr[i])\\n            ctr[i].sort()\\n            median[i] = ctr[i][(n - 1) // 2]\\n        res = 0\\n        for i in range(k):\\n            n = len(ctr[i])\\n            for j in range(n):\\n                res += abs(ctr[i][j] - median[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def GCD(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        k = self.GCD(len(arr), k)\\n        ctr = [[] for _ in range(k)]\\n        median = [0] * k\\n        for i in range(len(arr)):\\n            ctr[i % k].append(arr[i])\\n        for i in range(k):\\n            n = len(ctr[i])\\n            ctr[i].sort()\\n            median[i] = ctr[i][(n - 1) // 2]\\n        res = 0\\n        for i in range(k):\\n            n = len(ctr[i])\\n            for j in range(n):\\n                res += abs(ctr[i][j] - median[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366873,
                "title": "easy-solution-for-begginers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        int n = arr.size();\\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> temp;\\n            for(int j = i;j<n;j+=k) {\\n                temp.push_back(arr[j]);\\n            }\\n// the nth_element function will place the nth element of vector in the correct position after sorting, it takes O(n) for average case, we can find median by sorting also but it takes O(nlogn) time.\\n            nth_element(temp.begin(),temp.begin()+(temp.size()/2),temp.end());\\n            long long med = temp[temp.size()/2];\\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(med- arr[j]);\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        int n = arr.size();\\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> temp;\\n            for(int j = i;j<n;j+=k) {\\n                temp.push_back(arr[j]);\\n            }\\n// the nth_element function will place the nth element of vector in the correct position after sorting, it takes O(n) for average case, we can find median by sorting also but it takes O(nlogn) time.\\n            nth_element(temp.begin(),temp.begin()+(temp.size()/2),temp.end());\\n            long long med = temp[temp.size()/2];\\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(med- arr[j]);\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366660,
                "title": "easy-solution-to-great-problem-i-var",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to update some element in such a way that each subarray of given size sould have equal sum.\\nSo, how we can do this, think of a sequence of length n sub array sum will be equal only if first and last element are equal. Use this to solve further or continue to Read.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, moving forward with above idea, arr[i] should be equal to arr[(i+k)%n.\\nNow based on that idea we group elements which needs to have same value. now our problem is to find minimum number of given operations(++ or --) to make all element of arr equal.\\nApply this same to all group. Sum of all values will be the answer.\\n\\n# Complexity\\n- Time and Space complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    If you understand than comment time Complexity and space Complexity.\\n\\n# Code\\n``` C++ []\\nclass Solution {\\n    long long findMinVariance(vector<int> v){\\n        int n = v.size();\\n        vector<long long> uEle;\\n        map<int,int> m;\\n        long long sum=0;\\n        for(auto x:v){\\n            sum+=x;\\n            if(!m[x]){\\n                uEle.push_back(x);\\n            }\\n            m[x]++;\\n        }\\n        int n2 = uEle.size();\\n        vector<long long> count(n2+1,0);\\n        vector<long long> s(n2+1,0);\\n        \\n        for(int i=0;i<n2;i++){\\n            count[i+1] = count[i]+m[uEle[i]];\\n            s[i+1] = s[i]+uEle[i]*m[uEle[i]];\\n        }\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n2;i++){\\n            ans=min(ans,\\n                    count[i]*uEle[i]-s[i] + (sum-s[i+1])-(n-count[i+1])*uEle[i]\\n                   );\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        vector<int> flag(arr.size(),true);\\n        int n = arr.size();\\n        vector<vector<int>> sets;\\n        for(int i=0;i<n;i++){\\n            if(flag[i]){\\n                vector<int> temp;\\n                int j=i;\\n                while(flag[j]){\\n                    flag[j] = false;\\n                    temp.push_back(arr[j]);\\n                    j+=k;\\n                    j%=n;\\n                }\\n                sort(temp.begin(),temp.end());\\n                sets.push_back(temp);\\n            }\\n        }\\n        long long ans=0;\\n        for(auto s:sets){\\n            ans+=findMinVariance(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\n    long long findMinVariance(vector<int> v){\\n        int n = v.size();\\n        vector<long long> uEle;\\n        map<int,int> m;\\n        long long sum=0;\\n        for(auto x:v){\\n            sum+=x;\\n            if(!m[x]){\\n                uEle.push_back(x);\\n            }\\n            m[x]++;\\n        }\\n        int n2 = uEle.size();\\n        vector<long long> count(n2+1,0);\\n        vector<long long> s(n2+1,0);\\n        \\n        for(int i=0;i<n2;i++){\\n            count[i+1] = count[i]+m[uEle[i]];\\n            s[i+1] = s[i]+uEle[i]*m[uEle[i]];\\n        }\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n2;i++){\\n            ans=min(ans,\\n                    count[i]*uEle[i]-s[i] + (sum-s[i+1])-(n-count[i+1])*uEle[i]\\n                   );\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        vector<int> flag(arr.size(),true);\\n        int n = arr.size();\\n        vector<vector<int>> sets;\\n        for(int i=0;i<n;i++){\\n            if(flag[i]){\\n                vector<int> temp;\\n                int j=i;\\n                while(flag[j]){\\n                    flag[j] = false;\\n                    temp.push_back(arr[j]);\\n                    j+=k;\\n                    j%=n;\\n                }\\n                sort(temp.begin(),temp.end());\\n                sets.push_back(temp);\\n            }\\n        }\\n        long long ans=0;\\n        for(auto s:sets){\\n            ans+=findMinVariance(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366594,
                "title": "c-faster-than-95-math",
                "content": "# Intuition\\nFirst calculate the number of independent groups.\\n\\n# Approach\\nFirst calculate the number of independent groups - it will be the least common multiple of arr.Length and k:\\n```\\nprivate int GetMin(int n, int k)\\n```\\nThen calculate the result as a sum of results in each groups:\\n```\\nprivate long GetMin(List<int> list)\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(arr))$$\\n\\n- Space complexity:\\n$$O(len(arr))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MakeSubKSumEqual(int[] arr, int k) {\\n        var shift = GetMin(arr.Length, k);\\n        var rs = 0L;\\n        for (int i = 0; i < shift; i++)\\n        {\\n            var list = GetIthList(i, shift, arr);\\n            rs += GetMin(list);\\n        }\\n        return rs;\\n    }\\n    private long GetMin(List<int> list)\\n    {\\n        var rs = 0L;\\n        list.Sort();\\n        var val = list[list.Count / 2];\\n        for (int i = 0; i < list.Count; i++)\\n        {\\n            rs += Math.Abs(list[i] - val);\\n        }\\n        return rs;\\n    }\\n    private List<int> GetIthList(int index, int shift, int[] arr)\\n    {\\n        var rs = new List<int>();\\n        for (int i = index; i < arr.Length; i += shift)\\n        {\\n            rs.Add(arr[i]);\\n        }\\n        return rs;\\n    }\\n    private int GetMin(int n, int k)\\n    {\\n        if (n % k == 0) return k;\\n        return GetMin(k, n % k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate int GetMin(int n, int k)\\n```\n```\\nprivate long GetMin(List<int> list)\\n```\n```\\npublic class Solution {\\n    public long MakeSubKSumEqual(int[] arr, int k) {\\n        var shift = GetMin(arr.Length, k);\\n        var rs = 0L;\\n        for (int i = 0; i < shift; i++)\\n        {\\n            var list = GetIthList(i, shift, arr);\\n            rs += GetMin(list);\\n        }\\n        return rs;\\n    }\\n    private long GetMin(List<int> list)\\n    {\\n        var rs = 0L;\\n        list.Sort();\\n        var val = list[list.Count / 2];\\n        for (int i = 0; i < list.Count; i++)\\n        {\\n            rs += Math.Abs(list[i] - val);\\n        }\\n        return rs;\\n    }\\n    private List<int> GetIthList(int index, int shift, int[] arr)\\n    {\\n        var rs = new List<int>();\\n        for (int i = index; i < arr.Length; i += shift)\\n        {\\n            rs.Add(arr[i]);\\n        }\\n        return rs;\\n    }\\n    private int GetMin(int n, int k)\\n    {\\n        if (n % k == 0) return k;\\n        return GetMin(k, n % k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366552,
                "title": "sorting-gcd-absolute",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> val;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                val.push_back(arr[j]);\\n            }\\n            \\n            sort(val.begin() , val.end());\\n            \\n            long long midv = val[val.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> val;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                val.push_back(arr[j]);\\n            }\\n            \\n            sort(val.begin() , val.end());\\n            \\n            long long midv = val[val.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366496,
                "title": "group-the-elements-at-distance-k-o-n-log-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGroup the indices at a difference of k, together, sort them and get them as equal to median of that group.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        int n = arr.size();\\n        vector<bool> visited(n, false);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                vector<int> res;\\n                int d=i;\\n                while(!visited[d]){\\n                    visited[d]=true;\\n                    res.push_back(arr[d]);\\n                    d=d+k;\\n                    d%=n;\\n                }\\n                \\n                sort(res.begin(), res.end());\\n                //choose the median\\n                int dsiz=res.size();\\n                int med=0;\\n                if(dsiz%2){\\n                    med=res[dsiz/2];\\n                }\\n                else{\\n                    med=(res[dsiz/2]+res[(dsiz+1)/2])/2.0;\\n                }\\n                \\n                for(int j=0;j<dsiz;j++){\\n                    ans+=abs(res[j]-med);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        int n = arr.size();\\n        vector<bool> visited(n, false);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                vector<int> res;\\n                int d=i;\\n                while(!visited[d]){\\n                    visited[d]=true;\\n                    res.push_back(arr[d]);\\n                    d=d+k;\\n                    d%=n;\\n                }\\n                \\n                sort(res.begin(), res.end());\\n                //choose the median\\n                int dsiz=res.size();\\n                int med=0;\\n                if(dsiz%2){\\n                    med=res[dsiz/2];\\n                }\\n                else{\\n                    med=(res[dsiz/2]+res[(dsiz+1)/2])/2.0;\\n                }\\n                \\n                for(int j=0;j<dsiz;j++){\\n                    ans+=abs(res[j]-med);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1850414,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850218,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850205,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852323,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850314,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016810,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016652,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1867145,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852863,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1851228,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850414,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850218,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850205,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852323,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850314,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016810,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016652,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1867145,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852863,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1851228,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]